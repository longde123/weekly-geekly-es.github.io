<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ‘©ğŸ¾â€ğŸš’ ğŸ‹ garbage.collect () ğŸ• ğŸ‘¨ğŸ¿â€ğŸ”§ ğŸ“°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk menjalankan JavaScript, browser memerlukan sedikit memori, tetapi di suatu tempat Anda perlu menyimpan objek, primitif, fungsi yang dibuat untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>garbage.collect ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433318/">  Untuk menjalankan JavaScript, browser memerlukan sedikit memori, tetapi di suatu tempat Anda perlu menyimpan objek, primitif, fungsi yang dibuat untuk semua tindakan pengguna.  Oleh karena itu, browser pertama-tama mengalokasikan jumlah RAM yang diperlukan, dan ketika objek tidak digunakan, ia membersihkannya secara independen. <br><br>  Secara teori, itu terdengar bagus.  Dalam praktiknya, pengguna membuka 20 tab dari YouTube, jejaring sosial, membaca sesuatu, bekerja, peramban memakan memori, seperti Hummer H2 - bensin.  Pengumpul sampah, seperti monster ini dengan kain pel, mengaliri seluruh memori dan menambahkan kebingungan, semuanya melambat dan jatuh. <br><br><img src="https://habrastorage.org/webt/uc/vx/ke/ucvxke3xzwiqngna7opkqwllmq4.jpeg"><br><br>  Untuk mencegah situasi seperti itu terjadi dan kinerja situs dan aplikasi kami tidak menderita, pengembang front-end harus tahu bagaimana sampah memengaruhi aplikasi, bagaimana browser mengumpulkannya dan mengoptimalkan kerja dengan memori, dan bagaimana semuanya berbeda dari kenyataan pahit.  Ini hanya laporan <strong>Andrei Roenko ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">flapenguin</a> )</strong> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf 2018</a> . <br><br>  Kami menggunakan pengumpul sampah (bukan di rumah - dalam pengembangan front-end) setiap hari, tetapi kami tidak benar-benar berpikir tentang apa itu sama sekali, berapa biayanya bagi kami dan peluang serta keterbatasan apa yang dimilikinya. <br><br><blockquote>  Jika pengumpulan sampah benar-benar berfungsi dalam JavaScript, sebagian besar modul npm akan langsung terhapus setelah instalasi. <br></blockquote><br>  Tetapi sementara ini tidak demikian, dan kita akan berbicara tentang apa - tentang mengumpulkan benda-benda yang tidak perlu. <br><br><a name="habracut"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/tDbRVZqwxn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara</strong> : <strong>Andrei Roenko telah</strong> mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yandex.Map API</a> , telah berada di frontend selama enam tahun sekarang, dia suka membuat abstraksi tinggi sendiri dan turun dari orang lain ke tanah. <br><br><h2>  Mengapa Anda membutuhkan pengumpulan sampah? <br></h2><br>  Perhatikan contoh Yandex.Maps.  Yandex.Maps adalah layanan besar dan kompleks yang menggunakan banyak JS dan hampir semua API browser yang ada, kecuali untuk yang multimedia, dan waktu sesi rata-rata adalah 5-10 menit.  Kelimpahan JavaScript menciptakan banyak objek.  Menyeret peta, menambahkan organisasi, hasil pencarian, dan banyak peristiwa lain yang terjadi setiap detik menciptakan longsoran objek.  Tambahkan ke Bereaksi ini dan objek menjadi lebih. <br><br>  Namun, objek JS hanya menempati 30-40 Mb di peta.  Untuk sesi Yandex.Maps yang panjang dan alokasi objek baru yang konstan, ini tidak cukup. <br><br><blockquote>  Alasan volume kecil benda-benda adalah bahwa mereka berhasil dikumpulkan oleh pengumpul sampah dan memori digunakan kembali. <br></blockquote><br>  Hari ini kita akan berbicara tentang pengumpulan sampah dari empat sisi: <br><br><ul><li>  <strong>Teori</strong>  Mari kita mulai dengannya untuk berbicara dalam bahasa yang sama dan saling memahami. </li><li>  <strong>Realitas yang keras.</strong>  Pada akhirnya, komputer mengeksekusi kode mesin yang tidak ada semua abstraksi yang kita kenal.  Mari kita coba mencari tahu bagaimana pengumpulan sampah bekerja pada level rendah. </li><li>  <strong>Realita peramban.</strong>  Mari kita lihat bagaimana pengumpulan sampah diimplementasikan di mesin dan browser modern, dan kesimpulan apa yang bisa kita tarik dari ini. </li><li>  <strong>Kehidupan sehari-hari</strong> - mari kita bicara tentang penerapan praktis dari pengetahuan yang diperoleh dalam kehidupan sehari-hari. </li></ul><br>  Kami mendukung semua pernyataan dengan contoh bagaimana Anda bisa dan bagaimana Anda tidak perlu melakukannya. <br><br><h2>  Kenapa tahu semua ini? </h2><br>  Pengumpulan sampah adalah hal yang tidak terlihat bagi kami, namun, mengetahui bagaimana mengaturnya Anda akan: <br><br><ul><li>  Pikirkan alat yang Anda gunakan, yang berguna dalam pekerjaan Anda. </li><li>  Memahami di mana mengoptimalkan aplikasi yang sudah dirilis dan bagaimana merancang yang di masa depan sehingga mereka bekerja lebih baik dan lebih cepat </li><li>  Ketahui cara untuk tidak membuat kesalahan umum dan berhenti menghabiskan sumber daya untuk "optimisasi" yang tidak berguna dan berbahaya. </li></ul><br><h2>  Teori <br></h2><br>  Joel Spolsky pernah berkata: <br><br><blockquote>  Semua abstraksi non-sepele bocor. <br></blockquote><br>  Pengumpul sampah adalah abstraksi non-sepele besar yang ditambal dari semua sisi.  Untungnya, itu mengalir sangat jarang. <br><br>  Mari kita mulai dengan sebuah teori, tetapi tanpa definisi yang membosankan.  Mari kita menganalisis karya pengumpul menggunakan kode sederhana sebagai contoh: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Foo = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> }; } work(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xy, z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br><ul><li>  Ada <strong>kelas</strong> dalam kode. </li><li>  Kelas memiliki <strong>konstruktor</strong> . </li><li>  <strong>Metode kerja</strong> mengembalikan fungsi terkait. </li><li>  Di dalam fungsi, <strong>ini</strong> dan beberapa variabel dari penutupan digunakan. </li></ul><br>  Mari kita lihat bagaimana kode ini akan berperilaku jika kita menjalankannya seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//C   window.worker = foo.work('Brendan Eich'); //     bind,   window.foo = null; //   window.Foo = null; //  ,   -  window.worker(); window.worker = null; //   ,  </span></span></code> </pre><br>  Mari kita menganalisis kode dan komponen-komponennya secara lebih rinci dan mulai dengan kelas. <br><br><h3>  Deklarasi kelas <br></h3><br><img src="https://habrastorage.org/webt/nd/yq/ie/ndyqietonv9ggcg45mvfmwnsyae.png"><br><br>  Kita dapat mengasumsikan bahwa kelas dalam ECMAScript 2015 hanyalah gula sintaksis untuk fungsi.  Semua fungsi memiliki: <br><br><ul><li>  <strong>Fungsi. [[Prototipe]]</strong> adalah prototipe asli dari fungsi tersebut. </li><li>  <strong>Foo.prototype</strong> adalah prototipe untuk objek yang baru dibuat. </li><li>  Foo.prototype memiliki tautan kembali ke konstruktor melalui bidang konstruktor.  Ini adalah objek, jadi ia mewarisi dari <strong>Object.prototype</strong> . </li><li>  <strong>Metode kerja adalah</strong> fungsi terpisah yang memiliki tautan, mirip dengan konstruktor, karena keduanya sama-sama fungsi.  Dia juga dapat mengatur prototipe dan menyebutnya melalui yang baru, tetapi jarang ada yang menggunakan perilaku ini. </li></ul><br>  Prototipe membutuhkan banyak ruang di sirkuit, jadi mari kita ingat, tetapi akan menghapusnya untuk kesederhanaan. <br><br><h3>  Membuat Obyek Kelas <br></h3><br><img src="https://habrastorage.org/webt/f_/ea/5u/f_ea5uuq01wygmqkdfbrj4a8oja.png"><br><br><ul><li>  Kami menempatkan kelas kami di jendela, karena kelas tidak sampai di sana secara default. </li><li>  Buat objek kelas. </li><li>  Membuat objek secara otomatis memperlihatkan prototipe objek kelas di Foo.prototype.  Oleh karena itu, ketika Anda mencoba memanggil metode kerja pada objek, ia akan tahu jenis pekerjaan apa itu. </li><li>  Konstruktor kami membuat bidang <em>x</em> pada objek dari objek dengan string. </li></ul><br>  Inilah yang terjadi: <br><br><img src="https://habrastorage.org/webt/nb/xx/d1/nbxxd11pg7bmutfnn4bqh3_ooxs.png"><br><br>  Metode mengembalikan fungsi terikat - ini adalah objek "ajaib" khusus di JS, yang terdiri dari terikat ini dan fungsi yang harus dipanggil.  Fungsi terkait juga memiliki prototipe dan prototipe lain, tetapi kami tertarik pada penutupan.  Berdasarkan spesifikasi, penutupan disimpan di Lingkungan.  Kemungkinan besar Anda lebih akrab dengan kata Lingkup, tetapi <strong>dalam spesifikasi bidang ini disebut Lingkungan</strong> . <br><br><img src="https://habrastorage.org/webt/dv/zu/rn/dvzurne2uerkhr0vqxeahna5cum.png"><br><br>  Lingkungan menyimpan referensi ke LexicalEnvironment.  Ini adalah objek yang kompleks, lebih rumit dari pada slide, ini menyimpan tautan ke segala sesuatu yang dapat diakses dari suatu fungsi.  Misalnya, jendela, Foo, nama, dan z.  Itu juga menyimpan tautan ke bahkan apa yang tidak Anda gunakan secara eksplisit.  Misalnya, Anda dapat menggunakan eval dan secara tidak sengaja menggunakan objek yang tidak digunakan, tetapi JS tidak boleh rusak. <br><br>  Jadi, kami membangun semua benda dan sekarang kami akan menghancurkan segalanya. <br><br><h3>  Hapus tautan ke objek <br></h3><br>  Mari kita mulai dengan menghapus tautan ke objek, tautan ini dalam diagram disorot dengan warna merah. <br><br><img src="https://habrastorage.org/webt/zp/g_/mf/zpg_mfnx7pgoc1q46ruedg5oeve.png"><br><br>  Kami menghapus dan tidak ada yang terjadi, karena dari <strong>jendela</strong> ke objek ada jalan melalui <strong>fungsi</strong> fungsi <strong>terikat</strong> . <br><br><img src="https://habrastorage.org/webt/_w/lv/v6/_wlvv6dpon2qnjgaukobadopmas.png"><br><br>  Ini mendorong kita ke kesalahan tipikal. <br><br><h3>  Kesalahan umum - langganan yang terlupakan <br></h3><br><pre> <code class="javascript hljs">externalElement.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDoSomethingOnClick) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(); } })</code> </pre><br>  Terjadi ketika Anda berlangganan: menggunakan <strong>ini,</strong> secara eksplisit melalui fungsi bind atau melalui panah;  gunakan sesuatu di penutupan.  Kemudian Anda lupa untuk berhenti berlangganan, dan masa hidup objek Anda atau apa yang ada di sirkuit menjadi sama dengan masa berlangganan.  Misalnya, jika ini adalah elemen DOM yang tidak Anda sentuh, maka kemungkinan besar ini adalah waktu sampai akhir masa halaman. <br><br>  Untuk mengatasi masalah ini: <br><br><ul><li>  Berhenti berlangganan. </li><li>  Pikirkan selama masa berlangganan, dan siapa yang memilikinya. </li><li>  Jika karena alasan tertentu Anda tidak dapat berhenti berlangganan, maka batalkan tautannya (apa pun = nol), atau bersihkan semua bidang objek.  Jika objek Anda bocor, itu akan kecil dan itu tidak sayang. </li><li>  Gunakan WeakMap, mungkin ini akan membantu dalam beberapa situasi. </li></ul><br><h3>  Hapus referensi kelas <br></h3><br>  Teruskan dan coba hapus tautan merah yang disorot kelas. <br><br><img src="https://habrastorage.org/webt/px/sm/yf/pxsmyfvo0utc5d1wh3rfrqcpmlc.png"><br><br>  Kami menghapus tautan dan tidak ada perubahan bagi kami.  Alasannya adalah bahwa kelas dapat diakses melalui BoundThis, di mana ada tautan ke prototipe, dan di dalam prototipe ada tautan kembali ke konstruktor. <br><br><h3>  <s>Kesalahan</s> umum pekerjaan tidak berguna <br></h3><br>  Mengapa semua demonstrasi ini dibutuhkan?  Karena ada sisi lain dari masalah ketika orang mengambil saran untuk membatalkan tautan terlalu harfiah dan membatalkan segala sesuatu secara umum. <br><br><pre> <code class="javascript hljs">destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._y = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  10 this._foobar = null }</span></span></code> </pre><br>  Ini adalah pekerjaan yang sangat tidak berharga.  Jika objek hanya terdiri dari referensi ke objek lain dan tidak ada sumber daya di sana, maka tidak perlu menghancurkan ().  Cukup kehilangan referensi ke objek, dan dia akan mati sendiri. <br><br>  Tidak ada saran universal.  Bila perlu, batalkan, dan jika tidak, jangan batalkan.  Memusatkan perhatian bukanlah kesalahan, tetapi hanya pekerjaan sia-sia. <br><br>  Silakan.  Panggil metode fungsi terikat dan itu akan menghapus tautan dari [objek Foo] ke [Obyek objek].  Ini akan mengarah pada fakta bahwa objek-objek yang terpisah dalam sebuah persegi panjang biru muncul dalam diagram. <br><br><img src="https://habrastorage.org/webt/zl/ep/xc/zlepxcvklqpricdvth4gxnjp2ny.png"><br><br>  Objek-objek ini adalah sampah JS.  Dia baik-baik saja.  Namun, ada sampah yang tidak bisa dikumpulkan. <br><br><h3>  Sampah yang tidak mau <br></h3><br>  Di banyak API peramban, Anda dapat membuat dan menghancurkan objek.  Jika objek tidak dihancurkan, maka tidak ada kolektor yang dapat merakitnya. <br><br>  Objek dengan membuat / menghapus fungsi pasangan: <br><br><ul><li>  createObjectURL (), revokeObjectURL (); </li><li>  WebGL: membuat / menghapus Program / Shader / Buffer / Tekstur / dll; </li><li>  ImageBitmap.close (); </li><li>  indexDb.close (). </li></ul><br>  Misalnya, jika Anda lupa untuk menghapus ObjectURL dari video 200 MB, maka 200 MB ini akan tetap berada dalam memori sampai akhir masa halaman dan bahkan lebih lama, karena ada pertukaran data antara tab.  Demikian pula di WebGL, indexDb, dan API browser lainnya dengan sumber daya yang serupa. <br><br>  Untungnya, dalam contoh kita, persegi panjang biru hanya berisi objek JavaScript, jadi ini hanya sampah yang bisa dihapus. <br><br>  Langkah selanjutnya adalah menghapus tautan terakhir dari kiri ke kanan.  Ini adalah referensi ke metode yang kami terima, fungsi terkait. <br><br><img src="https://habrastorage.org/webt/5g/k5/h9/5gk5h96gg6zpw4bi64mq1guopom.png"><br><br>  Setelah dihapus, kita tidak akan memiliki tautan ke kiri dan kanan?  Bahkan, masih ada tautan dari penutupan. <br><br><img src="https://habrastorage.org/webt/hy/s0/vy/hys0vysevtslyjbht0gjngdaqaq.png"><br><br>  Penting bahwa tidak ada tautan dari kiri ke kanan, karena itu semua kecuali jendela adalah sampah dan akan mati. <br><br>  <strong>Catatan penting</strong> : ada referensi melingkar di sampah, yaitu objek yang saling merujuk.  Kehadiran tautan semacam itu tidak mempengaruhi apa-apa, karena pengumpul sampah tidak mengumpulkan benda-benda individual, tetapi seluruh sampah. <br><br><img src="https://habrastorage.org/webt/hl/qq/4f/hlqq4fn3nlubl4aefqycqyi4v8u.png"><br><br>  Kami melihat contoh-contohnya dan sekarang pada level intuitif kami memahami apa itu sampah, tetapi mari kita berikan definisi yang lengkap tentang konsep tersebut. <br><br><blockquote>  Sampah adalah segala sesuatu yang bukan benda hidup. <br></blockquote><br>  Segalanya menjadi sangat jelas.  Tapi apa benda hidup itu? <br><br>  <strong>Objek hidup adalah objek yang dapat dijangkau oleh tautan dari objek root.</strong> <br><br>  Dua konsep baru muncul: "ikuti tautan" dan "objek root".  Salah satu objek root yang sudah kita ketahui adalah window, jadi mari kita mulai dengan tautannya. <br><br><h3>  Apa artinya mengikuti tautan? <br></h3><br>  Ada banyak objek yang saling terkait dan merujuk satu sama lain.  Kami akan melambai di sepanjang mereka, mulai dengan objek root. <br><br>  Kami menginisialisasi langkah pertama, dan kemudian melanjutkan sesuai dengan algoritma berikut: katakanlah semua yang ada di puncak gelombang adalah benda hidup dan lihat apa yang mereka rujuk. <br><br><img src="https://habrastorage.org/webt/qd/vc/gv/qdvcgvf0tjyk-i85yx9_yzivgs8.png"><br><br>  Kami menginisialisasi langkah pertama.  Kemudian kita akan bertindak sesuai dengan algoritma berikut: katakanlah bahwa segala sesuatu yang kuning pada puncak gelombang adalah benda hidup dan mari kita lihat apa yang mereka rujuk. <br><br>  Apa yang mereka rujuk, kami akan membuat lambang baru dari gelombang: <br><br><img src="https://habrastorage.org/webt/k-/5p/bz/k-5pbzevhodbxxsj1ktayvgio34.png"><br><br>  Selesai dan mulai lagi dari awal: <br><br><ul><li>  Kami menghidupkan kembali. </li><li>  Kami melihat apa yang mereka rujuk. </li><li>  Buat lambang gelombang baru, benda bernyawa. </li><li>  Kami melihat apa yang mereka rujuk. </li></ul><br><img src="https://habrastorage.org/webt/nd/bb/8d/ndbb8dwnwadhclwfucgkozu42ea.png"><br><br>  Memperhatikan bahwa satu panah menunjuk ke objek yang sudah hidup, kita tidak melakukan apa-apa.  Lebih lanjut menurut algoritma, sampai objek untuk pergi kehabisan.  Lalu kami mengatakan bahwa kami menemukan semua benda hidup, dan yang lainnya adalah sampah. <br><br><img src="https://habrastorage.org/webt/pw/ms/6z/pwms6zisv2hasovzir04jtjna0k.png"><br><br>  Proses ini disebut <strong>penandaan</strong> . <br><br><h3>  Apa maksud objek root? <br></h3><br><br><ul><li>  Jendela </li><li>  Hampir semua API browser. </li><li>  Semua janji. </li><li>  Segala sesuatu yang dimasukkan ke dalam Microtask dan Macrotask. </li><li>  Pengamat mutasi, RAF, Idle-callbacks.  Segala sesuatu yang dapat dicapai dari apa yang ada di RAF tidak dapat dihapus, karena jika Anda menghapus objek yang digunakan dalam RAF, maka sesuatu mungkin akan salah. </li></ul><br>  Perakitan dapat terjadi kapan saja.  Setiap kali kawat gigi atau fungsi muncul, objek baru dibuat.  Mungkin tidak ada cukup memori, dan kolektor akan mencari secara gratis: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; <span class="hljs-comment"><span class="hljs-comment">// nomem, run gc D: // â€¦ } while (whatever()) bar(); }</span></span></code> </pre><br>  Dalam hal ini, objek root akan menjadi segalanya di tumpukan panggilan.  Jika Anda, misalnya, berhenti di baris dengan X dan menghapus apa yang dirujuk Y, maka aplikasi Anda akan macet.  JS tidak mengizinkan kami melakukan kesembronoan seperti itu, jadi Anda tidak dapat menghapus objek dari Y. <br><br>  Jika bagian sebelumnya tampak rumit, maka itu akan menjadi lebih sulit. <br><br><h2>  Realitas yang keras <br></h2><br>  Mari kita bicara tentang dunia mesin di mana kita berurusan dengan besi, dengan media fisik. <br><br>  Memori adalah satu array besar di mana angka-angka terletak, misalnya: Uint32Array baru (16 * 2 ** 30). <br><br>  Mari kita membuat objek dalam memori dan menambahkannya dari kiri ke kanan.  Kami membuat satu, kedua, ketiga - semuanya berukuran berbeda.  Kami menempatkan tautan di sepanjang jalan. <br><img src="https://habrastorage.org/webt/rg/ly/oy/rglyoyk5kjjz0re9ktp1m7r0dtg.png"><br><br>  Pada objek ketujuh, tempat itu telah berakhir, karena kita memiliki 2 kotak gratis, tetapi kita membutuhkan 5. <br><br>  Apa yang bisa dilakukan di sini?  Opsi pertama adalah crash.  Di halaman pada tahun 2018, setiap orang memiliki MacBook terbaru dan 16 GB RAM.  Tidak ada situasi ketika tidak ada memori! <br><br>  Namun, membiarkan segala sesuatunya berjalan dengan baik adalah ide yang buruk, karena di web ini mengarah ke layar yang sama: <br><br><img src="https://habrastorage.org/webt/un/lw/gn/unlwgnwcw1-7p5xunjhvo2hfwzg.png"><br><br>  Ini bukan perilaku yang kita inginkan dari program, tetapi secara umum itu valid.  Ada kategori kolektor yang disebut <strong>No-op</strong> . <br><br><h3>  Kolektor tanpa op <br></h3><br>  Pro: <br><br><ul><li>  Kolektornya sangat sederhana. </li><li>  Hanya tidak ada pengumpulan sampah. </li><li>  Tidak perlu menulis atau memikirkan memori. </li></ul><br>  Cons: <br><br><ul><li>  Semuanya jatuh sehingga tidak pernah naik lagi. </li></ul><br>  Untuk frontend, no-op collector tidak relevan, tetapi digunakan di backend.  Misalnya, memiliki beberapa server di belakang penyeimbang, aplikasi diberikan 32 GB RAM dan kemudian dimatikan seluruhnya.  Lebih sederhana dan kinerjanya hanya ditingkatkan dengan hanya me-restart ketika memori menjadi rendah. <br><br>  Di web itu tidak mungkin dan Anda harus membersihkannya. <br><br><h3>  Cari dan hapus sampah <br></h3><br>  Kami mulai membersihkan dengan sampah.  Kami sudah tahu bagaimana melakukannya.  Sampah - objek C dan F dalam skema sebelumnya, karena Anda tidak dapat menjangkau mereka di sepanjang panah dari objek root. <br><br>  Kami mengambil sampah ini, memberi makan kepada pencinta sampah dan Anda selesai. <br><br><img src="https://habrastorage.org/webt/g8/1l/s1/g81ls1ji6sco7buvbftj6xgr714.png"><br><br>  Setelah dibersihkan, masalahnya tidak terpecahkan, karena lubang tetap ada dalam memori.  Harap dicatat bahwa ada 7 kotak gratis, tetapi 5 di antaranya masih belum dapat kami alokasikan.  Terjadi fragmentasi dan perakitan selesai.  Algoritma dengan lubang seperti itu disebut <strong>Mark and Sweep</strong> . <br><br><h3>  Tandai dan sapu <br></h3><br>  Pro: <br><br><ul><li>  Algoritma yang sangat sederhana.  Salah satu yang pertama yang akan Anda pelajari jika Anda mulai belajar tentang pengumpul sampah. </li><li>  Ini bekerja secara proporsional dengan jumlah sampah, tetapi hanya mengatasi ketika ada sedikit sampah. </li><li>  Jika Anda hanya memiliki benda hidup, maka dia tidak membuang waktu dan tidak melakukan apa-apa. </li></ul><br>  Cons: <br><br><ul><li>  Dibutuhkan logika yang kompleks untuk mencari ruang kosong, karena ketika ada banyak lubang di memori, Anda harus mencoba objek di masing-masing untuk memahami apakah cocok atau tidak. </li><li>  Memori fragmen.  Suatu situasi dapat terjadi bahwa dengan gratis 200 MB memori dibagi menjadi potongan-potongan kecil dan, seperti pada contoh di atas, tidak ada bagian memori yang solid untuk objek. </li></ul><br>  Kami mencari ide lain.  Jika Anda melihat gambar dan berpikir, pikiran pertama adalah menggeser semuanya ke kiri.  Kemudian di sebelah kanan akan ada satu potongan besar dan bebas, di mana objek kita akan dengan tenang pas. <br><br>  Ada algoritma seperti itu dan disebut <strong>Mark and Compact</strong> . <br><br><h3>  Tandai dan ringkas <br></h3><br>  Pro: <br><br><ul><li>  Memori defragment. </li><li>  Ini bekerja secara proporsional dengan jumlah benda hidup, yang berarti dapat digunakan ketika praktis tidak ada puing. </li></ul><br>  Cons: <br><br><ul><li>  Sulit dalam pekerjaan dan implementasi. </li><li>  Memindahkan benda.  Kami memindahkan objek, menyalinnya, sekarang berada di tempat yang berbeda dan seluruh operasi cukup mahal. </li><li>  Ini membutuhkan 2-3 lintasan di seluruh memori, tergantung pada implementasinya - algoritme lambat. </li></ul><br>  Di sini kita sampai pada ide lain. <br><br><h3>  Pengumpulan sampah tidak gratis <br></h3><br>  Dalam API berkinerja tinggi seperti WebGL, WebAudio, dan WebGPU, yang masih dalam pengembangan, objek dibuat dan dihapus dalam fase terpisah.  Spesifikasi ini ditulis sehingga pengumpulan sampah tidak dalam proses.  Selain itu, bahkan tidak ada Janji di sana, tetapi tarik () - Anda hanya bertanya setiap frame: "Apakah ada sesuatu yang terjadi atau tidak?". <br><br><h3>  Semispace alias Lisp 2 <br></h3><br>  Ada seorang kolektor lain yang ingin saya bicarakan.  Bagaimana jika Anda tidak membebaskan memori, tetapi menyalin semua benda hidup di suatu tempat ke tempat lain. <br><br>  Mari kita coba salin objek root "apa adanya", yang merujuk ke suatu tempat. <br><br><img src="https://habrastorage.org/webt/oe/ck/uc/oeckucvn6dpbz9hgbg3ykkzmylm.png"><br><br>  Dan kemudian semua orang. <br><br><img src="https://habrastorage.org/webt/rf/ds/9x/rfds9xc3v1tp6pvlpokawj8pkn0.png"><br><br>  Tidak ada puing atau lubang di memori di atas.  Segalanya tampak baik-baik saja, tetapi muncul dua masalah: <br><br><ul><li>  Objek duplikat - kami memiliki dua objek hijau dan dua yang biru.  Yang mana yang akan digunakan? </li><li>  Tautan dari objek baru mengarah ke objek lama, dan bukan ke satu sama lain. </li></ul><br>  Dengan tautan, semuanya diselesaikan dengan bantuan "keajaiban" algoritmik khusus, dan kita dapat mengatasi duplikasi objek dengan menghapus semuanya di bawah ini. <br><img src="https://habrastorage.org/webt/cq/sr/ur/cqsrurkhqp_b01qsxjhzndggryg.png"><br><br>  Akibatnya, kami memiliki ruang kosong, dan hanya benda hidup dalam urutan normal di atas.  Algoritma ini disebut <strong>Semispace</strong> , <strong>Lisp 2,</strong> atau hanya "copy collector". <br><br>  Pro: <br><br><ul><li>  Memori defragment. </li><li>  Sederhana </li><li>  Dapat dikombinasikan dengan fase memotong. </li><li>  Ia bekerja secara proporsional dengan jumlah benda hidup dari waktu ke waktu. </li><li>  Bekerja dengan baik ketika ada banyak sampah.  Jika Anda memiliki 2 GB memori dan 3 objek di dalamnya, maka Anda hanya akan mem-bypass 3 objek, dan sisa 2 GB tampaknya hilang. </li></ul><br>  Cons: <br><br><ul><li>  Konsumsi memori ganda.  Anda menggunakan memori 2 kali lebih banyak dari yang diperlukan. </li><li>  Memindahkan benda juga bukan operasi yang sangat murah. </li></ul><br><blockquote>  Catatan: pengumpul sampah dapat memindahkan benda. <br></blockquote><br>  Di web, ini tidak relevan, tetapi pada Node.js bahkan sangat banyak.  Jika Anda menulis ekstensi dalam C ++, maka bahasanya tidak tahu tentang semua ini, jadi ada tautan ganda yang disebut pegangan dan terlihat seperti ini: v8 :: Local &lt;v8 :: String&gt;. <br><br>  Oleh karena itu, jika Anda akan menulis plugin untuk Node.js maka informasinya akan berguna. <br><br>  Kami meringkas berbagai algoritma dengan kelebihan dan kekurangannya dalam tabel.  Ini juga memiliki algoritma Eden, tetapi tentangnya nanti. <br><br><img src="https://habrastorage.org/webt/s9/zm/ec/s9zmecoite95yruxuvtafbzaimy.png"><br><br>  Saya benar-benar menginginkan algoritma tanpa kontra, tetapi ini bukan.  Karena itu, kami mengambil yang terbaik dari semua dunia: kami menggunakan beberapa algoritma pada saat yang bersamaan.  Dalam satu bagian memori, kami mengumpulkan sampah dengan satu algoritma, dan yang lain dengan algoritma lain. <br><br>  Bagaimana cara memahami efektivitas algoritma dalam situasi seperti itu? <br><br>  Kita dapat menggunakan pengetahuan tentang suami yang cerdas dari tahun 60an yang melihat semua program dan menyadari: <br><br><blockquote>  Hipotesis generasi yang lemah: sebagian besar benda mati muda. <br></blockquote><br>  Mereka ingin mengatakan bahwa semua program hanya menghasilkan sampah.  Dalam upaya untuk menggunakan pengetahuan, kita akan sampai pada apa yang disebut "perakitan oleh generasi". <br><br><h3>  Perakitan generasi <br></h3><br>  Kami membuat dua keping memori yang tidak terhubung dengan cara apa pun: di sebelah kiri adalah Eden, dan di sebelah kanan adalah Mark dan Sweep yang lambat.  Di Eden kita membuat objek.  Banyak objek. <br><br><img src="https://habrastorage.org/webt/_y/rt/tc/_yrttco6brh1zyz4sqkiuk4wrjo.png"><br><br>  Ketika Eden mengatakan sudah penuh, kami mulai mengumpulkan sampah di dalamnya.  Kami menemukan benda hidup dan menyalinnya ke kolektor lain. <br><br><img src="https://habrastorage.org/webt/38/si/a5/38sia5sg1nhfx6elimcuitdpqok.png"><br><br>  Eden sendiri sudah sepenuhnya dibersihkan, dan kita bisa menambahkan objek lebih jauh lagi. <br><br><img src="https://habrastorage.org/webt/pp/qc/3_/ppqc3_uk1okblort71qjndj7ije.png"><br><br>  Mengandalkan hipotesis generasi, kami memutuskan bahwa objek c, g, saya kemungkinan besar akan hidup untuk waktu yang lama, dan kami dapat memeriksa mereka lebih jarang.  Mengetahui hipotesis ini, Anda dapat menulis program yang menipu kolektor.  Ini bisa dilakukan, tetapi saya tidak menyarankan Anda, karena hampir selalu akan menyebabkan efek yang tidak diinginkan.  Jika Anda membuat sampah berumur panjang, pengumpul akan mulai percaya bahwa itu tidak perlu dikumpulkan. <br><br>  Contoh klasik kecurangan adalah LRU-cache.  Suatu objek terletak pada cache untuk waktu yang lama, kolektor melihatnya dan percaya bahwa ia belum akan mengoleksinya, karena objek tersebut akan hidup untuk waktu yang sangat lama.  Kemudian objek baru masuk ke cache, dan yang lama didorong keluar dan tidak mungkin lagi untuk segera merakit objek besar ini. <br><br>  Cara mengumpulkan sekarang kita tahu.  Bicara tentang kapan mengumpulkan. <br><br><h3>  Kapan harus mengumpulkan? <br></h3><br>  Opsi termudah adalah ketika kita <strong>hanya menghentikan semuanya</strong> , mulai build, dan kemudian mulai kerja JS lagi. <br><br><img src="https://habrastorage.org/webt/e-/1n/od/e-1nodx10w_v6q7x5w7xi9xdfvk.png"><br><br>  Di komputer modern, lebih dari satu utas eksekusi.  Di web, ini familiar dari Pekerja Web.  Mengapa tidak mengambil dan <strong>memparalelkan proses perakitan</strong> .  Melakukan beberapa operasi kecil pada saat yang sama akan lebih cepat daripada yang besar. <br><br><img src="https://habrastorage.org/webt/y6/yw/jh/y6ywjhxlis6qhu7kk5cumaruayu.png"><br><br>  Gagasan lain adalah dengan hati-hati membuat snapshot dari keadaan saat ini, dan <strong>membangun secara paralel dengan JS</strong> . <br><br><img src="https://habrastorage.org/webt/lm/fd/3w/lmfd3w2kiyhtxlwvp1wtlges6ia.png"><br><br><blockquote>  Jika ini menarik minat Anda, maka saya sarankan Anda untuk membaca: <br><br><ul><li>  Satu-satunya dan buku rakitan utama, Buku Pegangan Koleksi Sampah. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> sebagai sumber universal. </li><li>  Situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memorymanagement.org.</a> </li><li>  Laporan dan artikel oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Shepelev</a> .  Dia berbicara tentang Java, tetapi dalam hal sampah, Java dan V8 bekerja kurang lebih sama. </li></ul></blockquote><br><h2>  Realita peramban <br></h2><br>  Mari kita beralih ke bagaimana browser menggunakan semua yang kita bicarakan. <br><br><h3>  Mesin IOT <br></h3><br>  Mari kita mulai bukan dengan browser, tetapi dengan mesin Internet of Things: JerryScript dan Duktape.  Mereka menggunakan Mark'n'sweep dan Stop the world algorithm. <br><br>  Mesin IoT bekerja pada mikrokontroler, yang berarti: bahasanya lambat;  hang kedua;  fragmentasi  dan semua ini untuk teko dengan pencahayaan :) <br><br>  Jika Anda menulis Internet of Things dalam JavaScript, maka beri tahu kami di komentar?  apakah ada gunanya? <br><br>  Kami akan meninggalkan mesin IoT sendirian, kami tertarik pada: <br><br><ul><li>  V8. </li><li>  SpiderMonkey  Padahal, dia tidak punya logo.  Logo buatan sendiri :) </li><li>  JavaScriptCore digunakan oleh WebKit. </li><li>  ChakraCore yang digunakan di Edge. </li></ul><br><img src="https://habrastorage.org/webt/vw/0q/nj/vw0qnjkmktvnd2z0_dhrvkw4y_u.png"><br><br>  Semua mesin kira-kira sama, jadi kita akan berbicara tentang V8, sebagai yang paling terkenal. <br><br><h3>  V8 <br></h3><br><ul><li>  Hampir semua JavaScript sisi server, karena itu Node.js. </li><li>  Hampir 80% dari JavaScript sisi klien. </li><li>  Pengembang yang paling mudah bergaul, ada banyak informasi dan kode sumber yang baik yang paling mudah dibaca. </li></ul><br>  V8 menggunakan perakitan generasi. <br><img src="https://habrastorage.org/webt/u-/-7/r4/u--7r4ggek0kxgpscwhtzn8grfe.png"><br><br>  Satu-satunya perbedaan adalah bahwa kami dulu memiliki dua kolektor, dan sekarang tiga: <br><br><ul><li>  Sebuah objek dibuat di Eden. </li><li>  Di beberapa titik di Eden, ada terlalu banyak sampah dan objek dipindahkan ke Semispace. </li><li>  Objeknya masih muda dan ketika kolektor menyadari bahwa benda itu terlalu tua dan membosankan, benda itu melemparkannya ke Mark dan Sweep, tempat pengumpulan sampah sangat jarang. </li></ul><br>  Anda dapat dengan jelas melihat tampilannya pada <strong>jejak memori</strong> . <br><br><img src="https://habrastorage.org/webt/c7/s1/av/c7s1avnfboc9c57khyjw5xqjybm.png"><br><br>  Beberapa gelombang besar dengan gelombang kecil terlihat.  Yang kecil adalah majelis kecil, dan yang besar adalah yang utama. <br><br>  Arti dari keberadaan kita, menurut hipotesis generasi, adalah menghasilkan sampah, jadi kesalahan selanjutnya adalah takut menciptakan sampah. <br><br><blockquote>  Sampah dapat dibuat ketika benar-benar sampah.   ,         ,     ,    . <br></blockquote><br><h4>  mark <br></h4><br>    V8     . <br><img src="https://habrastorage.org/webt/40/dg/j5/40dgj5iiquv7dsag0mndget4s30.png"><br><br>     Stop the world,        ,       JS,        . <br><br><h4>     ? <br></h4><br>  1  3%,    . <br><br>  3% = 1/33     GameDev.  GameDev 3%  1 ,    .   GameDev     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pool = [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bullet = pool.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> !x.inUse); bullet.isUse = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bullet; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnToPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bullet</span></span></span><span class="hljs-function">) </span></span>{ bullet.inUse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Frame const bullet = getFromPool(); // ... returnToPool(bullet);</span></span></code> </pre><br>     , , 10 000        . <br><br>    â€”    .          ,         .      ,     . <br><br><h3>   : Chromium <br></h3><br>      , ,  ,   Chromium. <br><br><pre> <code class="javascript hljs">&gt; performance.memory MemoryInfo { <span class="hljs-attr"><span class="hljs-attr">totalJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">usedJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">jsHeapSizeLimit</span></span>: <span class="hljs-number"><span class="hljs-number">2330000000</span></span> }</code> </pre><br>  Chromium  <strong>performance.memory</strong>   ,       ,      Chromium  . <br><br> <strong>:</strong> Chromium   2    JavaScript. <br><br>  ,           . <br><br><h3>   : Node <br></h3><br>  Node.js    <strong>process.memoryUsage</strong> ,      . <br><br><pre> <code class="javascript hljs">&gt; process.memoryUsage() { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">22839296</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">10207232</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">5967968</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">12829</span></span> }</code> </pre><br> ,  -         ,    .          .     . <br><br><h3>  <br></h3><br> <strong> </strong> â€”    ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proposal</a> ,      . <br><br>    Node.js,    c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">node-weak</a>   , ,  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakRef(myJson); <span class="hljs-comment"><span class="hljs-comment">// 2   let json = cached.deref(); if (!json) { json = await fetchAgain(); }</span></span></code> </pre><br>     , ,    -  JS.         ,      ,      ,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  WebAssembly</a> ,    .   ,              ,     ,      . <br><br><blockquote>     :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">v8.dev</a>    JS. <br></blockquote><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/v8/v8/tree/7.0.237/src/heap</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/servo/mozjs/blob/master/mozjs/js/src/gc/</a> </li><li> <a href="">github.com/WebKit/webkit/.../JavaScriptCore/heap/MarkedSpace.cpp</a> </li><li> <a href="">github.com/Microsoft/ChakraCore/.../HeapAllocator.cpp</a> </li><li> <a href="">github.com/svaarala/duktape/.../duk_heap_markandsweep.c</a> </li><li> <a href="">github.com/jerryscript-project/jerryscript/.../ecma-gc.c</a> </li></ul><br>        ? <br><br><h2>  <br></h2><br>    DevTools    : <strong>Performance</strong>  <strong>Memory</strong> .     Chromium,     ,   Firefox  Safari  . <br><br><h3>  Performance <br></h3><br>   Trace,   Â«MemoryÂ»    Performance,    JS     . <br><br><img src="https://habrastorage.org/webt/vm/8b/hn/vm8bhnnurkvza6cquinxa61ema8.png"><br><br>     JS      V8     ,   .     .  ,  GC    30   1200  JS,   1/40. <br><br><h3>  Memory <br></h3><br>          . <br><br><img src="https://habrastorage.org/webt/1i/cl/br/1iclbrk21tcz3lmj472ukb5jwqc.png"><br><br>    . <br><br><img src="https://habrastorage.org/webt/fy/6i/0v/fy6i0v3tu6yq2onfzuz7ma7moks.png"><br><br>     ,           .    , ,  ,  V8   ,      .     ,     . <br><br> , ,  Q (   compiled code) â€”  React    .   ,   ? <br><br>    ,     ,             ,    . <br><br>     ,    . <br><br><img src="https://habrastorage.org/webt/-3/z_/si/-3z_si-wvtfdlbz87myro38qz1s.png"><br><br>     ,     ,   ,         .   ,    â€”  4     .  ,  . <br><br><img src="https://habrastorage.org/webt/pr/un/bt/prunbtssbfjjsklugfzwp2mv778.png"><br><br>      React,       - :         . ,   JSX. <br><br>  Performance  Memory   ,   : <br><br><ul><li>  Chromium: about:tracing. </li><li>  Firefox: about:memory  about:performance,    . </li><li>   Node â€” trace-gc, â€”expose-gc, require('trace_events').  trace_events    . </li></ul><br><h2>  Ringkasan <br></h2><br><ul><li>   ,    ,    ,   . </li><li>                . </li><li>    .   ,      ? </li><li>   ,       -        . </li><li>     SPA,     ,    1       ,   . </li><li>   ,       -   . </li></ul><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flapenguin.me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  -</a>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">++</a> .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong></strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>YouTube-</strong> <br></a> . <br><br>     ,     2018 ,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> 2018. <br><br>     ,   :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433318/">https://habr.com/ru/post/id433318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433302/index.html">Langkah Pertama untuk Karat</a></li>
<li><a href="../id433304/index.html">Muat pengujian dengan belalang. Bagian 3</a></li>
<li><a href="../id433306/index.html">Visual studio 2019</a></li>
<li><a href="../id433308/index.html">Mentransfer konfigurasi PBX ke layanan 3CX PBX Express</a></li>
<li><a href="../id433316/index.html">Intisari desain: orientasi, umpan balik, cari ide dan pengambilan keputusan</a></li>
<li><a href="../id433320/index.html">Layout Grid sebagai dasar dari layout modern</a></li>
<li><a href="../id433322/index.html">API JSON - kami bekerja sesuai dengan spesifikasi</a></li>
<li><a href="../id433324/index.html">Mengumpulkan bundel impian dengan Webpack</a></li>
<li><a href="../id433326/index.html">Kualitas kode</a></li>
<li><a href="../id433328/index.html">Lebih baik kehilangan sehari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>