<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💀 👈🏾 👇🏼 Android Oberfläche 👩🏿‍🤝‍👨🏽 📦 👦🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss 


 Dieser Artikel ist für Anfänger gedacht, die mit Android wenig Erfahrung im Umgang mit Videos und / oder Kameras haben, insbeso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Oberfläche</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480878/"><h2 id="diskleymer">  Haftungsausschluss </h2><br><p>  Dieser Artikel ist für Anfänger gedacht, die mit Android wenig Erfahrung im Umgang mit Videos und / oder Kameras haben, insbesondere für diejenigen, die mit der Analyse von <a href="https://github.com/google/grafika" rel="nofollow">Grafika-</a> Beispielen begonnen haben und diese als schwierig empfanden. Hier sehen wir uns ähnlichen Code mit einer vereinfachten Beschreibung der grundlegenden Schritte an, die durch Zustandsdiagramme veranschaulicht werden. </p><br><p>  Warum wird die Surface-Klasse im Header gerendert?  In Android haben viele Klassen das Wort <em>Surface</em> in ihrem Namen (Surface, SurfaceHolder, SurfaceTexture, SurfaceView, GLSurfaceView), sie sind nicht durch eine gemeinsame Hierarchie verbunden, sie werden jedoch durch eine Logik auf niedriger Ebene für die Arbeit mit der Bildausgabe kombiniert.  Es erschien mir vernünftig, es im Titel zu verwenden, um einen Versuch hervorzuheben, die Arbeit mit diesem bestimmten Teil des SDK offenzulegen. </p><a name="habracut"></a><br><h2 id="primer-ispolzovaniya-s-raznym-api">  Beispielanwendung mit unterschiedlicher API </h2><br><p>  Versuchen <strong>wir</strong> folgendes Beispiel zu schreiben: <strong>Wir nehmen eine Vorschau von der Kamera, überlagern eine animierte Zeichnung, zeigen alles auf dem Bildschirm an und schreiben, falls erforderlich, in eine Datei.</strong>  Der vollständige Code wird <a href="https://github.com/tttzof351/AndroidSurfaceExample/" rel="nofollow">https://github.com/tttzof351/AndroidSurfaceExample/</a> liegen. </p><br><p>  Für die Ausgabe auf den Bildschirmen verwenden wir <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="nofollow">GLSurfaceView</a> , um mit den Klassen <a href="https://developer.android.com/reference/android/media/MediaCodec" rel="nofollow">MediaCodec</a> und <a href="https://developer.android.com/reference/android/opengl/EGLSurface" rel="nofollow">EGLSurface aufzuzeichnen</a> und über <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary" rel="nofollow">API V2</a> mit der Kamera zu kommunizieren.  Das allgemeine Schema ist ungefähr wie folgt: </p><br><p><img src="https://habrastorage.org/webt/9o/rc/o5/9orco54m0chpg_og4db_qppsrjm.png"></p><br><h2 id="nalozhenie-neskolkih-surface">  Mehrere Oberflächenüberlagerungen </h2><br><p>  Die Oberfläche ist eigentlich ein Anfasser für den Bereich im Speicher, der mit dem Bild gefüllt werden muss.  Höchstwahrscheinlich versucht es, etwas auf dem Bildschirm oder in einer Datei anzuzeigen, sodass es wie ein Puffer für einen „Prozess“ funktioniert, der Daten erzeugt. </p><br><p>  Um ein Overlay aus mehreren Surface zu erstellen, verwenden wir OpenGL. <br>  Zu diesem Zweck werden zwei quadratische externe Texturen erstellt und daraus eine Oberfläche erstellt </p><br><p>  Im Code sieht es ungefähr so ​​aus: </p><br><p>  <a href="" rel="nofollow">OpenGLExtarnalTexture.kt</a> </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textures = IntArray(<span class="hljs-number"><span class="hljs-number">1</span></span>) GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, textures, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textureId = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    val textureWidth = ... val textureHeight = ... //  val surfaceTexture = SurfaceTexture(textureId) surfaceTexture.setDefaultBufferSize(textureWidth, textureHeight) //, surface  ""    val surface = Surface(surfaceTexture)</span></span></code> </pre> <br><p>  <strong>XYZ-Koordinaten</strong> </p><br><p>  Jetzt müssen wir verstehen, wie man Texturen erstellt und anordnet. Dazu müssen wir uns merken, wie das Koordinatengitter in OpenGL angeordnet ist: Sein Mittelpunkt fällt mit dem Mittelpunkt der Szene (Fenster) zusammen, und die Ränder werden normalisiert, d. H. Von -1 bis 1. </p><br><p>  In dieser Szene möchten wir zwei Rechtecke setzen (die Arbeit befindet sich in der Ebene, sodass alle z-Koordinaten logisch auf 0f gesetzt sind) - in Rot geben wir diejenige an, in der wir die Vorschau für die Kamera platzieren, und in Blau für das animierte Zeichenobjekt: </p><br><p>  Wir schreiben unsere Koordinaten explizit auf: </p><br><p><img src="https://habrastorage.org/webt/mu/fj/kr/mufjkrznafatofs4lsn-ywm_h7i.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, ) smallTexture = floatArrayOf( // X, Y, Z 0.3f, 0.3f, 0.0f, 0.8f, 0.3f, 0.0f, 0.3f, 0.8f, 0.0f, 0.8f, 0.8f, 0.0f )</span></span></code> </pre> <br><p>  <strong>UV-Koordinaten</strong> </p><br><p>  Reicht das  Es stellt sich heraus, dass nein :( </p><br><p>  Eine Textur ist eine Abbildung eines Bildes auf einen Szenenbereich. Um dies korrekt zu machen, müssen Sie genau angeben, wo die Punkte im Bild in diesen Bereich fallen. OpenGL verwendet dazu <strong>UV-</strong> Koordinaten. Sie kommen aus der unteren linken Ecke und haben Ränder von 0 bis 1 Achsen. </p><br><p>  Es funktioniert wie folgt: Wir setzen <strong>UV-</strong> Koordinaten für jeden Scheitelpunkt unserer Fläche und suchen nach den entsprechenden Punkten im Bild, vorausgesetzt, dass dort Breite und Höhe gleich 1 sind. </p><br><p>  Betrachten Sie ein Beispiel - wir gehen davon aus, dass die Kamera das Bild in einem invertierten und reflektierten Zustand liefert, und gleichzeitig möchten wir nur den rechten oberen Teil anzeigen, d. H. 0,8 in Breite und Höhe des Bildes. </p><br><p>  Der subtile Punkt - zu diesem Zeitpunkt kennen wir das Seitenverhältnis des Bereichs auf dem Bildschirm nicht - besteht nur aus einem Quadrat in relativen Koordinaten, das die gesamte Szene ausfüllt und entsprechend gedehnt wird.  Wenn wir eine Vollbildkamera herstellen würden, würden sich unsere relativen Größen (2 auf jeder Seite) auf die herkömmlichen 1080x1920 erstrecken.  Wir gehen davon aus, dass wir die Dimensionen der Szene so einstellen, dass ihr Verhältnis dem Verhältnis der Kamera entspricht. <br>  Mal sehen, wohin die Koordinaten gehen - der obere rechte Punkt unserer Fläche (1, 1, 0) sollte zur UV-Koordinate (0, 0) gehen, der untere linke in (0.8f, 0.8f) usw. </p><br><p><img src="https://habrastorage.org/webt/fk/ur/ig/fkurigpfo4l_hnl1fonbgj1dao0.png"></p><br><p>  So erhalten wir die Entsprechung von XYZ und UV: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 0.8f, 0.8f, 1.0f, -1.0f, 0.0f, 0.8f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.8f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f</span></span></code> </pre> <br><p>  Wenn das Seitenverhältnis zwischen der Vorschau von der Kamera und dem Bereich auf dem Bildschirm anfänglich übereinstimmt, wird es offensichtlich weiterhin gespeichert, da wir in unserem Fall nur mit 0,8f multipliziert haben. <br>  Und was werden wir essen, wir werden Werte größer als 1 festlegen?  Abhängig von den Einstellungen, die wir an OpenGL übergeben haben, erhalten wir Punkte für einen Teil des Bildes.  In unserem Beispiel wird die letzte Zeile entlang der entsprechenden Achse wiederholt, und es werden Artefakte in Form von "Streifen" angezeigt. </p><br><p>  <strong>Fazit: Wenn wir das Bild unter Beibehaltung der Position des Bereichs auf dem Bildschirm komprimieren / ausschneiden möchten, sind die UV-Koordinaten unsere Wahl!</strong> </p><br><p>  <strong>Stellen Sie die Koordinaten für unsere Texturen ein.</strong> </p><br><p><img src="https://habrastorage.org/webt/au/wp/zx/auwpzx9wgczhb79_4bbfu9nyk_a.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 1f, 0f, 1.0f, -1.0f, 0.0f, 0f, 0f, -1.0f, 1.0f, 0.0f, 1f, 1f, 1.0f, 1.0f, 0.0f, 0f, 1f ) smallTexture = floatArrayOf( // X, Y, Z, U, V 0.3f, 0.3f, 0.0f, 0f, 0f, 0.8f, 0.3f, 0.0f, 1f, 0f, 0.3f, 0.8f, 0.0f, 0f, 1f, 0.8f, 0.8f, 0.0f, 1f, 1f )</span></span></code> </pre> <br><p>  <strong>Shader</strong> </p><br><p>  Statische XYZ- und UV-Koordinaten sind nicht sehr praktisch. Wir möchten beispielsweise unsere Texturen mit Gesten verschieben und skalieren.  Um sie zu transformieren, erstellen wir zwei Matrizen für jede Textur: <strong>MVPMatrix</strong> und <strong>TexMatrix</strong> für <strong>XYZ-</strong> bzw. UV-Koordinaten. </p><br><p>  Jedes OpenGL2 muss Shader enthalten, um etwas auf dem Bildschirm anzuzeigen.  Natürlich ist dies kein Thema, das in einem Absatz offengelegt werden kann, in unserem Fall sind sie jedoch trivial, und daher können Sie schnell verstehen, was sie tun, ohne viel Wissen über das Material. </p><br><p>  Zunächst gibt es zwei Shader - Vertex und Fragment. </p><br><p>  Der erste (Vertex) verarbeitet unsere Vertices, <strong>dh</strong> multipliziert einfach unsere XYZ / UV-Koordinaten mit den entsprechenden Matrizen und <strong>fügt</strong> die OpenGL-Variable <strong>gl_Position ein,</strong> die genau für die endgültige Position unserer Textur auf dem Bildschirm verantwortlich ist. </p><br><p>  Das zweite (Fragment) sollte <strong>gl_FragColor mit</strong> Bildpixeln füllen. </p><br><p>  Insgesamt haben wir: die Variablen im Vertex-Shader, die wir in die Felder mit unseren Daten eintragen müssen, nämlich: </p><br><ul><li>  MVPMatrix -&gt; <strong>uMVPMatrix</strong> </li><li>  <strong>TexMatrix -&gt; uTexMatrix</strong> </li><li>  unsere XYZ-Eckpunktkoordinaten -&gt; <strong>aPosition</strong> </li><li>  UV-Koordinaten -&gt; <strong>aTextureCoord</strong> </li></ul><br><p>  <strong>vTextureCoord</strong> - wird benötigt, um Daten vom Vertex-Shader an den Fragment-Shader weiterzuleiten <br>  Im Fragment-Shader nehmen wir die konvertierten UV-Koordinaten und verwenden sie, um die Bildpixel im Texturbereich anzuzeigen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexShader = <span class="hljs-string"><span class="hljs-string">""" uniform mat4 uMVPMatrix; uniform mat4 uTexMatrix; attribute vec4 aPosition; attribute vec4 aTextureCoord; varying vec2 vTextureCoord; void main() { gl_Position = uMVPMatrix * aPosition; vTextureCoord = (uTexMatrix * aTextureCoord).xy; } """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">""" #extension GL_OES_EGL_image_external : require precision mediump float; varying vec2 vTextureCoord; uniform samplerExternalOES sTexture; void main() { gl_FragColor = texture2D(sTexture, vTextureCoord); } """</span></span></code> </pre> <br><p>  Als Referenz geben wir den Unterschied zwischen den Typen an: </p><br><ul><li>  uniform - Eine Variable dieses Typs behält Werte bei wiederholten Aufrufen bei. Wir verwenden einen Shader, der nacheinander für zwei Texturen aufgerufen wird, sodass wir ihn bei jedem Rendern überschreiben </li><li>  Attribut - Daten dieses Typs werden aus dem Vertex-Puffer gelesen und müssen bei jedem Rendern geladen werden </li><li>  Variieren - Wird benötigt, um Daten vom Vertex-Shader zum Fragment zu übertragen </li></ul><br><p>  Wie übergebe ich Parameter an einen Shader?  Dazu müssen Sie zuerst die ID (den Zeiger) der Variablen abrufen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle = GLES20.glGetAttribLocation(programId, <span class="hljs-string"><span class="hljs-string">"aPosition"</span></span>)</code> </pre> <br><p>  Für diese ID müssen Sie nun die Daten laden: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      floatbuffer val verticesBuffer = ByteBuffer.allocateDirect( fullscreenTexture.size * FLOAT_SIZE_BYTES ).order( ByteOrder.nativeOrder() ).asFloatBuffer() verticesBuffer.put(fullscreenTexture).position(0) /*    -  XYZ   0 .       id      ,     ,               - 5  - XYZUV,  4 - -   float */ verticesBuffer.position(0) GLES20.glVertexAttribPointer( aPositionHandle, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer )</span></span></code> </pre> <br><p>  <strong>Direkte Zeichnung</strong> </p><br><p>  Nachdem wir unsere Shader mit allen Daten gefüllt haben, sollten wir die Textur bitten, das Bild zu aktualisieren und OpenGL, um unsere Eckpunkte zu zeichnen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { ... surfaceTexture.updateTexImage() GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) }</code> </pre> <br><p>  In unserem Beispiel werden wir die Arbeit mit der OpenGL-Szene in zwei Klassen aufteilen - direkt Szenen und Texturen: </p><br><p>  <a href="https://github.com/tttzof351/AndroidSurfaceExample/blob/master/app/src/main/java/com/example/surfaces/helpers/OpenGLExternalTexture.kt/" rel="nofollow">OpenGLExternalTexture.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLExternalTexture</span></span></span></span>(verticesData: FloatArray, ...) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surfaceTexture: SurfaceTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surface: Surface <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    . } ... fun updateFrame(aPositionHandle: Int, ...) {...} // ,   fun release() {...} //   }</span></span></code> </pre> <br><p>  <a href="" rel="nofollow">OpenGLScene.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLScene</span></span></span></span>( sceneWidth: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sceneHeight: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, ... ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullscreenTexture = OpenGLExternalTexture(...) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = OpenGLExternalTexture(..) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        . } fun updateFrame() { ... fullscreenTexture.updateFrame(aPositionHandle, ...) smallTexture.updateFrame(aPositionHandle, ...) } fun release() { fullscreenTexture.release() smallTexture.release() } }</span></span></code> </pre> <br><h2 id="statemachine--mashina-sostoyaniy--konechnyy-avtomat">  StateMachine / State Machine / State Machine </h2><br><p>  Alle APIs, die wir in unserem Beispiel verwenden möchten, sind grundsätzlich asynchron (naja, vielleicht mit Ausnahme des animierten Drawable).  Wir werden solche Aufrufe in separate StateMachines einbinden, einen Ansatz, bei dem die Systemzustände explizit ausgeschrieben werden und Übergänge zwischen ihnen durch das Senden von Ereignissen auftreten. </p><br><p>  Schauen wir uns ein einfaches Beispiel an, wie dies aussehen wird. Nehmen wir an, wir haben diesen Code: </p><br><pre> <code class="kotlin hljs">imageView.setOnClickListener { loadImage { bitmap -&gt; imageView.setBitmap(bitmap) } }</code> </pre> <br><p>  Im Allgemeinen ist alles in Ordnung - schön und kompakt, aber wir werden versuchen, es folgendermaßen umzuschreiben: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiMachine = UIMachine() imageView.setOnClickListener { uiMachine.send(Click(imageView)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: State = WaitClick() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingClick &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Click -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitBitmap(imageView = action.imageView) loadImage { send(BitmapIsReady(bitmap = it)) } } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingBitmap &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> BitmapIsReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitClick state.imageView.setImageBitmap(action.bitmap) } } } } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> WaitingClick : State() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitingBitmap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): State() } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): Action() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitmapIsReady</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bitmap: Bitmap): Action() }</code> </pre> <br><p>  Einerseits stellte sich <strong><em>viel</em></strong> mehr heraus, dennoch erschienen einige implizite, aber nützliche Eigenschaften: Wiederholtes Drücken führt jetzt nicht zu unnötigen <strong>loadImage-</strong> Starts <strong>,</strong> obwohl dies bei einem solchen Volume nicht offensichtlich ist, aber wir haben den verschachtelten Rückruf beseitigt, den wir später verwenden werden und der Schreibstil der Übergangsmethode ermöglicht es Ihnen, ein Übergangsdiagramm zu erstellen, das den Code eins zu eins wiederholt, d. h. in unserem Fall: </p><br><p><img src="https://habrastorage.org/webt/-n/2p/mq/-n2pmqdwfsps932me0wfsrvyj_q.png"><br>  Grau kennzeichnet Übergänge, die nicht explizit ausgeschrieben sind.  Oft werden sie protokolliert oder lösen eine Ausnahme aus, da dies ein Anzeichen für einen Fehler ist.  Wir werden es vorerst schaffen, es einfach zu ignorieren und in Zukunft nicht mehr auf die Diagramme zu verweisen. </p><br><p>  Erstellen Sie die Basisschnittstellen für StateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S : State, A : Action</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: S <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><h2 id="glsurfaceview">  GLSurfaceView </h2><br><p>  Der einfachste Weg, etwas mit OpenGL in Android anzuzeigen, ist die GLSurfaceView-Klasse - sie erstellt automatisch einen neuen Stream zum Zeichnen, der mit den GLSurfaceView :: onResume / onPause-Methoden gestartet / angehalten wird. </p><br><p>  Der Einfachheit halber werden wir unsere Ansicht auf ein Verhältnis von 16: 9 einstellen. </p><br><p>  Der Rendervorgang selbst wird in einen separaten Rückruf verschoben - GLSurfaceView.Renderer. <br>  Wenn wir es in StateMachine einpacken, bekommen wir so etwas: </p><br><p>  <a href="" rel="nofollow">GLSurfaceMachine.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceMachine</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLSurfaceState, GLSurfaceAction</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: GLSurfaceState = WaitCreate() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Create -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady(...) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.glSurfaceView?.setRenderer(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> :Renderer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, width: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> send(SurfaceReady(width, height, gl)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, config: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EGLConfig</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { send(Draw) } }) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SurfaceReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openGLScene = OpenGLScene(width, height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = DrawingAvailable(openGLScene, ...) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { state.openGLScene.updateFrame() } state !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Stop -&gt; { state.uiHolder.glSurfaceView?.onPause() state.uiHolder.openGLScene?.release() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady() } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Start -&gt; { state.uiHolder.glSurfaceView?.onResume() } } } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceMachine = GLSurfaceMachine() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceView = findViewById(R.id.gl_view) glSurfaceView.layoutParams.width = width glSurfaceView.layoutParams.height = ((<span class="hljs-number"><span class="hljs-number">16f</span></span>/<span class="hljs-number"><span class="hljs-number">9f</span></span>) * width).toInt() glSurfaceMachine.send(GLSurfaceAction.Create(glSurfaceView, ...))</code> </pre> <br><p>  Zeichnen wir ein Übergangsdiagramm: </p><br><p><img src="https://habrastorage.org/webt/mx/5i/xb/mx5ixbssfaqci1ktsmumu94jbz0.png"></p><br><p>  Jetzt versucht unser Code, etwas auf dem Bildschirm anzuzeigen, aber im Moment funktioniert es nur schlecht - wir werden nichts anderes als einen schwarzen Bildschirm sehen.  Es ist nicht schwer zu erraten, dass jetzt nichts in unsere Oberfläche gelangt, da wir noch keine Bildquellen implementiert haben.  Lass uns das beheben - erstens erstelle ein CanvasDrawable: </p><br><p>  <a href="" rel="nofollow">CanvasDrawable.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasDrawable</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Drawable</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundPaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> circlePaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { canvas.drawRect(bounds, backgroundPaint) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = bounds.width() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> height = bounds.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posX = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posY = ... canvas.drawCircle(posX, posY, <span class="hljs-number"><span class="hljs-number">0.1f</span></span> * width, circlePaint) } ... }</code> </pre> <br><p>  Jetzt können wir den Abschnitt in GLSurfaceMachine ergänzen, indem wir canvasDrawable auf canvas rendern, wodurch die Oberfläche der entsprechenden Textur bereitgestellt wird: </p><br><pre> <code class="kotlin hljs">state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvasDrawable = state.canvasDrawable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = state.openGLScene.smallTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bounds = canvasDrawable.bounds <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvas = smallSurface.lockCanvas(bounds) canvasDrawable.draw(canvas) smallSurface.unlockCanvasAndPost(canvas) state.openGLScene.updateFrame() }</code> </pre> <br><p>  Danach sehen wir etwas wie: </p><br><p><img src="https://habrastorage.org/webt/vo/4r/-d/vo4r-dgpynjvynvxdomy2fezp9y.png"></p><br><h2 id="camera-api-v2">  Kamera-API V2 </h2><br><p>  Das grüne Rechteck macht sicherlich Spaß und ist faszinierend, aber es ist an der Zeit, die Vorschau von der Kamera auf die verbleibende Oberfläche zu bringen. </p><br><p>  Lassen Sie uns die Schritte für die Arbeit mit der Kamera aufschreiben: </p><br><ul><li>  Wir warten auf Erlaubnis.  Wir werden diesen Zustand <strong>WaitingStart haben</strong> </li><li>  Wir bekommen die Kamera-Manager-Instanz, wir finden die logische ID (normalerweise gibt es zwei davon - für die Rückseite und die Vorderseite, und die logische ist, weil die Kamera auf modernen Geräten aus vielen Sensoren bestehen kann) der gewünschten Kamera, wählen die entsprechende Größe, öffnen die Kamera, wir bekommen cameraDevice.  Status <strong>WaitingOpen</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> manager = getSystemService(Context.CAMERA_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CameraManager <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultCameraId: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultSize: Size? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cameraId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> manager.cameraIdList) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = manager.getCameraCharacteristics(cameraId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> facing = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(CameraCharacteristics.LENS_FACING) ?: -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing == LENS_FACING_BACK) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confMap = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sizes = confMap?.getOutputSizes(SurfaceTexture::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resultSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findSize</span></span></span></span>(sizes) resultCameraId = cameraId <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } resultCameraId?.let { cameraId -&gt; manager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraDevice.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(camera: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraDevice</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//Success open camera ... } }) }</span></span></code> </pre> <br><ul><li>  Bei geöffneter Kamera wenden wir uns an eine Oberfläche, um das Bild anzuzeigen.  <strong>WaitingSurface</strong> Status </li><li>  Nachdem wir cameraDevice, Surface haben, müssen wir eine Sitzung eröffnen, damit die Kamera endlich mit der Datenübertragung beginnt.  <strong>Wartesitzungsstatus</strong> </li></ul><br><pre> <code class="kotlin hljs">cameraDevice.createCaptureSession( arrayListOf(surface), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraCaptureSession</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { send(CameraAction.SessionReady(session)) } }, handler )</code> </pre> <br><ul><li>  Jetzt können wir die Vorschau erfassen.  <strong>StartingPreview</strong> Status </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = cameraDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW ).apply { addTarget(surface) } session.setRepeatingRequest( request.build(), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.CaptureCallback() {...} handler )</code> </pre> <br><p>  Wir veranschaulichen unser aktuelles Schema: </p><br><p>  <a href="" rel="nofollow">CameraMachine.kt</a> </p><br><p><img src="https://habrastorage.org/webt/i6/tj/q1/i6tjq12xls77hudocvpnt0m6qy0.png"></p><br><p><img src="https://habrastorage.org/webt/6w/ad/fp/6wadfpayduldvtqwcrjggkoce6y.png"></p><br><h2 id="mediacodec">  Mediacodec </h2><br><p>  MediaCodec ist eine Klasse für die Arbeit mit Systemcodecs auf niedriger Ebene. Im Allgemeinen besteht die API aus einer Reihe von Eingabe- / Ausgabepuffern (das klingt leider einfacher als damit zu arbeiten), in denen Daten (roh oder codiert, abhängig von der Betriebsart des Codierers / Decodierers) abgelegt werden Am Ausgang erhalten wir das Ergebnis. </p><br><p>  Obwohl ByteBuffer normalerweise als Puffer fungiert, können Sie Surface für die Arbeit mit Video verwenden, wodurch MediaCodec :: createInputSurface an uns zurückgegeben wird. Darauf sollten wir die aufzuzeichnenden Frames zeichnen (bei diesem Ansatz verspricht uns die Dokumentation eine schnellere Codierung durch die Verwendung von GPU ) </p><br><p>  Nun müssen wir lernen, wie wir die vorhandene Oberfläche zeichnen, die wir in GLSurfaceMachine auf Surface von MediaCodec erstellt haben.  Es ist wichtig, sich daran zu erinnern, dass Surface ein Objekt ist, das einen Konsumenten erzeugt, und im Allgemeinen ist es unmöglich, etwas daraus zu lesen, d. H. Es gibt keine bedingte Methode getBitmap / readImage / ... </p><br><p>  Wir werden wie folgt vorgehen: Auf der Grundlage des vorhandenen GL-Kontexts werden wir einen neuen erstellen, der ein gemeinsames Gedächtnis hat, und daher können wir ihn verwenden, um die ID-Shniks der Texturen, die wir zuvor dort erstellt haben, wiederzuverwenden.  Mit dem neuen GL-Kontext und Surface von MediaCodec erstellen wir dann ein EGLSurface - einen Off-Screen-Puffer, auf dem wir auch unsere OpenGLScene-Klasse erstellen können.  Dann versuchen wir bei jedem Frame-Rendering, den Frame parallel in die Datei zu schreiben. </p><br><p>  EGL bedeutet die Schnittstelle der Interaktion der OpenGL-API mit dem Fenstersubsystem der Plattform, wir werden die Arbeit damit von grafika stehlen.  Ich werde den Förderer (EncoderHelper) mit MediaCodec auch nicht direkt beschreiben, sondern nur das endgültige Interaktionsschema zwischen unseren Komponenten angeben: </p><br><p>  <a href="" rel="nofollow">EncoderMachine.kt</a> <br>  <a href="" rel="nofollow">EncoderHelper.kt</a> </p><br><p><img src="https://habrastorage.org/webt/d1/gc/kf/d1gckfqligsrwynmmkq_bb2yzoy.png"></p><br><h2 id="itog">  Das ergebnis: </h2><br><ul><li>  Das Arbeiten mit Videos erfordert mindestens Grundkenntnisse in OpenGL </li><li>  Die Android Media-API ist recht einfach, was Flexibilität bietet, aber manchmal zwingt sie Sie dazu, etwas mehr Code zu schreiben, als Sie möchten </li><li>  Asynchrone APIs können in StateMachines eingeschlossen werden </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480878/">https://habr.com/ru/post/de480878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480866/index.html">Eine neue Ära der Webentwicklung oder "alles ist schon da"</a></li>
<li><a href="../de480870/index.html">Jahrzehntelange Ergebnisse</a></li>
<li><a href="../de480872/index.html">Intel hat eine Sicherheitslücke geschlossen, die vor sechs Monaten gemeldet wurde</a></li>
<li><a href="../de480874/index.html">Das Studium der Neutrinos führte zu einer unerwarteten Entdeckung in der Mathematik</a></li>
<li><a href="../de480876/index.html">Wir bereinigen das Dock und machen die Anwendung ohne xCode</a></li>
<li><a href="../de480884/index.html">Python-GUI in 5 Minuten</a></li>
<li><a href="../de480886/index.html">Neuronale Netze und der goldene Schnitt: zweiter Lauf</a></li>
<li><a href="../de480888/index.html">DIY Coroutinen. Teil 1. Lazy Generators</a></li>
<li><a href="../de480890/index.html">Umfrageergebnisse zur Verwendung des Express-Panels</a></li>
<li><a href="../de480892/index.html">Ballon-Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>