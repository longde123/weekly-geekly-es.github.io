<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÄ üëàüèæ üëáüèº Android Oberfl√§che üë©üèø‚Äçü§ù‚Äçüë®üèΩ üì¶ üë¶üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haftungsausschluss 


 Dieser Artikel ist f√ºr Anf√§nger gedacht, die mit Android wenig Erfahrung im Umgang mit Videos und / oder Kameras haben, insbeso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Oberfl√§che</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480878/"><h2 id="diskleymer">  Haftungsausschluss </h2><br><p>  Dieser Artikel ist f√ºr Anf√§nger gedacht, die mit Android wenig Erfahrung im Umgang mit Videos und / oder Kameras haben, insbesondere f√ºr diejenigen, die mit der Analyse von <a href="https://github.com/google/grafika" rel="nofollow">Grafika-</a> Beispielen begonnen haben und diese als schwierig empfanden. Hier sehen wir uns √§hnlichen Code mit einer vereinfachten Beschreibung der grundlegenden Schritte an, die durch Zustandsdiagramme veranschaulicht werden. </p><br><p>  Warum wird die Surface-Klasse im Header gerendert?  In Android haben viele Klassen das Wort <em>Surface</em> in ihrem Namen (Surface, SurfaceHolder, SurfaceTexture, SurfaceView, GLSurfaceView), sie sind nicht durch eine gemeinsame Hierarchie verbunden, sie werden jedoch durch eine Logik auf niedriger Ebene f√ºr die Arbeit mit der Bildausgabe kombiniert.  Es erschien mir vern√ºnftig, es im Titel zu verwenden, um einen Versuch hervorzuheben, die Arbeit mit diesem bestimmten Teil des SDK offenzulegen. </p><a name="habracut"></a><br><h2 id="primer-ispolzovaniya-s-raznym-api">  Beispielanwendung mit unterschiedlicher API </h2><br><p>  Versuchen <strong>wir</strong> folgendes Beispiel zu schreiben: <strong>Wir nehmen eine Vorschau von der Kamera, √ºberlagern eine animierte Zeichnung, zeigen alles auf dem Bildschirm an und schreiben, falls erforderlich, in eine Datei.</strong>  Der vollst√§ndige Code wird <a href="https://github.com/tttzof351/AndroidSurfaceExample/" rel="nofollow">https://github.com/tttzof351/AndroidSurfaceExample/</a> liegen. </p><br><p>  F√ºr die Ausgabe auf den Bildschirmen verwenden wir <a href="https://developer.android.com/reference/android/opengl/GLSurfaceView" rel="nofollow">GLSurfaceView</a> , um mit den Klassen <a href="https://developer.android.com/reference/android/media/MediaCodec" rel="nofollow">MediaCodec</a> und <a href="https://developer.android.com/reference/android/opengl/EGLSurface" rel="nofollow">EGLSurface aufzuzeichnen</a> und √ºber <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary" rel="nofollow">API V2</a> mit der Kamera zu kommunizieren.  Das allgemeine Schema ist ungef√§hr wie folgt: </p><br><p><img src="https://habrastorage.org/webt/9o/rc/o5/9orco54m0chpg_og4db_qppsrjm.png"></p><br><h2 id="nalozhenie-neskolkih-surface">  Mehrere Oberfl√§chen√ºberlagerungen </h2><br><p>  Die Oberfl√§che ist eigentlich ein Anfasser f√ºr den Bereich im Speicher, der mit dem Bild gef√ºllt werden muss.  H√∂chstwahrscheinlich versucht es, etwas auf dem Bildschirm oder in einer Datei anzuzeigen, sodass es wie ein Puffer f√ºr einen ‚ÄûProzess‚Äú funktioniert, der Daten erzeugt. </p><br><p>  Um ein Overlay aus mehreren Surface zu erstellen, verwenden wir OpenGL. <br>  Zu diesem Zweck werden zwei quadratische externe Texturen erstellt und daraus eine Oberfl√§che erstellt </p><br><p>  Im Code sieht es ungef√§hr so ‚Äã‚Äãaus: </p><br><p>  <a href="" rel="nofollow">OpenGLExtarnalTexture.kt</a> </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textures = IntArray(<span class="hljs-number"><span class="hljs-number">1</span></span>) GLES20.glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, textures, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> textureId = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    val textureWidth = ... val textureHeight = ... //  val surfaceTexture = SurfaceTexture(textureId) surfaceTexture.setDefaultBufferSize(textureWidth, textureHeight) //, surface  ""    val surface = Surface(surfaceTexture)</span></span></code> </pre> <br><p>  <strong>XYZ-Koordinaten</strong> </p><br><p>  Jetzt m√ºssen wir verstehen, wie man Texturen erstellt und anordnet. Dazu m√ºssen wir uns merken, wie das Koordinatengitter in OpenGL angeordnet ist: Sein Mittelpunkt f√§llt mit dem Mittelpunkt der Szene (Fenster) zusammen, und die R√§nder werden normalisiert, d. H. Von -1 bis 1. </p><br><p>  In dieser Szene m√∂chten wir zwei Rechtecke setzen (die Arbeit befindet sich in der Ebene, sodass alle z-Koordinaten logisch auf 0f gesetzt sind) - in Rot geben wir diejenige an, in der wir die Vorschau f√ºr die Kamera platzieren, und in Blau f√ºr das animierte Zeichenobjekt: </p><br><p>  Wir schreiben unsere Koordinaten explizit auf: </p><br><p><img src="https://habrastorage.org/webt/mu/fj/kr/mufjkrznafatofs4lsn-ywm_h7i.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z -1.0f, -1.0f, 0.0f, 1.0f, -1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, ) smallTexture = floatArrayOf( // X, Y, Z 0.3f, 0.3f, 0.0f, 0.8f, 0.3f, 0.0f, 0.3f, 0.8f, 0.0f, 0.8f, 0.8f, 0.0f )</span></span></code> </pre> <br><p>  <strong>UV-Koordinaten</strong> </p><br><p>  Reicht das  Es stellt sich heraus, dass nein :( </p><br><p>  Eine Textur ist eine Abbildung eines Bildes auf einen Szenenbereich. Um dies korrekt zu machen, m√ºssen Sie genau angeben, wo die Punkte im Bild in diesen Bereich fallen. OpenGL verwendet dazu <strong>UV-</strong> Koordinaten. Sie kommen aus der unteren linken Ecke und haben R√§nder von 0 bis 1 Achsen. </p><br><p>  Es funktioniert wie folgt: Wir setzen <strong>UV-</strong> Koordinaten f√ºr jeden Scheitelpunkt unserer Fl√§che und suchen nach den entsprechenden Punkten im Bild, vorausgesetzt, dass dort Breite und H√∂he gleich 1 sind. </p><br><p>  Betrachten Sie ein Beispiel - wir gehen davon aus, dass die Kamera das Bild in einem invertierten und reflektierten Zustand liefert, und gleichzeitig m√∂chten wir nur den rechten oberen Teil anzeigen, d. H. 0,8 in Breite und H√∂he des Bildes. </p><br><p>  Der subtile Punkt - zu diesem Zeitpunkt kennen wir das Seitenverh√§ltnis des Bereichs auf dem Bildschirm nicht - besteht nur aus einem Quadrat in relativen Koordinaten, das die gesamte Szene ausf√ºllt und entsprechend gedehnt wird.  Wenn wir eine Vollbildkamera herstellen w√ºrden, w√ºrden sich unsere relativen Gr√∂√üen (2 auf jeder Seite) auf die herk√∂mmlichen 1080x1920 erstrecken.  Wir gehen davon aus, dass wir die Dimensionen der Szene so einstellen, dass ihr Verh√§ltnis dem Verh√§ltnis der Kamera entspricht. <br>  Mal sehen, wohin die Koordinaten gehen - der obere rechte Punkt unserer Fl√§che (1, 1, 0) sollte zur UV-Koordinate (0, 0) gehen, der untere linke in (0.8f, 0.8f) usw. </p><br><p><img src="https://habrastorage.org/webt/fk/ur/ig/fkurigpfo4l_hnl1fonbgj1dao0.png"></p><br><p>  So erhalten wir die Entsprechung von XYZ und UV: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 0.8f, 0.8f, 1.0f, -1.0f, 0.0f, 0.8f, 0.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.8f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f</span></span></code> </pre> <br><p>  Wenn das Seitenverh√§ltnis zwischen der Vorschau von der Kamera und dem Bereich auf dem Bildschirm anf√§nglich √ºbereinstimmt, wird es offensichtlich weiterhin gespeichert, da wir in unserem Fall nur mit 0,8f multipliziert haben. <br>  Und was werden wir essen, wir werden Werte gr√∂√üer als 1 festlegen?  Abh√§ngig von den Einstellungen, die wir an OpenGL √ºbergeben haben, erhalten wir Punkte f√ºr einen Teil des Bildes.  In unserem Beispiel wird die letzte Zeile entlang der entsprechenden Achse wiederholt, und es werden Artefakte in Form von "Streifen" angezeigt. </p><br><p>  <strong>Fazit: Wenn wir das Bild unter Beibehaltung der Position des Bereichs auf dem Bildschirm komprimieren / ausschneiden m√∂chten, sind die UV-Koordinaten unsere Wahl!</strong> </p><br><p>  <strong>Stellen Sie die Koordinaten f√ºr unsere Texturen ein.</strong> </p><br><p><img src="https://habrastorage.org/webt/au/wp/zx/auwpzx9wgczhb79_4bbfu9nyk_a.png"></p><br><pre> <code class="kotlin hljs">fullscreenTexture = floatArrayOf( <span class="hljs-comment"><span class="hljs-comment">// X, Y, Z, U, V -1.0f, -1.0f, 0.0f, 1f, 0f, 1.0f, -1.0f, 0.0f, 0f, 0f, -1.0f, 1.0f, 0.0f, 1f, 1f, 1.0f, 1.0f, 0.0f, 0f, 1f ) smallTexture = floatArrayOf( // X, Y, Z, U, V 0.3f, 0.3f, 0.0f, 0f, 0f, 0.8f, 0.3f, 0.0f, 1f, 0f, 0.3f, 0.8f, 0.0f, 0f, 1f, 0.8f, 0.8f, 0.0f, 1f, 1f )</span></span></code> </pre> <br><p>  <strong>Shader</strong> </p><br><p>  Statische XYZ- und UV-Koordinaten sind nicht sehr praktisch. Wir m√∂chten beispielsweise unsere Texturen mit Gesten verschieben und skalieren.  Um sie zu transformieren, erstellen wir zwei Matrizen f√ºr jede Textur: <strong>MVPMatrix</strong> und <strong>TexMatrix</strong> f√ºr <strong>XYZ-</strong> bzw. UV-Koordinaten. </p><br><p>  Jedes OpenGL2 muss Shader enthalten, um etwas auf dem Bildschirm anzuzeigen.  Nat√ºrlich ist dies kein Thema, das in einem Absatz offengelegt werden kann, in unserem Fall sind sie jedoch trivial, und daher k√∂nnen Sie schnell verstehen, was sie tun, ohne viel Wissen √ºber das Material. </p><br><p>  Zun√§chst gibt es zwei Shader - Vertex und Fragment. </p><br><p>  Der erste (Vertex) verarbeitet unsere Vertices, <strong>dh</strong> multipliziert einfach unsere XYZ / UV-Koordinaten mit den entsprechenden Matrizen und <strong>f√ºgt</strong> die OpenGL-Variable <strong>gl_Position ein,</strong> die genau f√ºr die endg√ºltige Position unserer Textur auf dem Bildschirm verantwortlich ist. </p><br><p>  Das zweite (Fragment) sollte <strong>gl_FragColor mit</strong> Bildpixeln f√ºllen. </p><br><p>  Insgesamt haben wir: die Variablen im Vertex-Shader, die wir in die Felder mit unseren Daten eintragen m√ºssen, n√§mlich: </p><br><ul><li>  MVPMatrix -&gt; <strong>uMVPMatrix</strong> </li><li>  <strong>TexMatrix -&gt; uTexMatrix</strong> </li><li>  unsere XYZ-Eckpunktkoordinaten -&gt; <strong>aPosition</strong> </li><li>  UV-Koordinaten -&gt; <strong>aTextureCoord</strong> </li></ul><br><p>  <strong>vTextureCoord</strong> - wird ben√∂tigt, um Daten vom Vertex-Shader an den Fragment-Shader weiterzuleiten <br>  Im Fragment-Shader nehmen wir die konvertierten UV-Koordinaten und verwenden sie, um die Bildpixel im Texturbereich anzuzeigen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexShader = <span class="hljs-string"><span class="hljs-string">""" uniform mat4 uMVPMatrix; uniform mat4 uTexMatrix; attribute vec4 aPosition; attribute vec4 aTextureCoord; varying vec2 vTextureCoord; void main() { gl_Position = uMVPMatrix * aPosition; vTextureCoord = (uTexMatrix * aTextureCoord).xy; } """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fragmentShader = <span class="hljs-string"><span class="hljs-string">""" #extension GL_OES_EGL_image_external : require precision mediump float; varying vec2 vTextureCoord; uniform samplerExternalOES sTexture; void main() { gl_FragColor = texture2D(sTexture, vTextureCoord); } """</span></span></code> </pre> <br><p>  Als Referenz geben wir den Unterschied zwischen den Typen an: </p><br><ul><li>  uniform - Eine Variable dieses Typs beh√§lt Werte bei wiederholten Aufrufen bei. Wir verwenden einen Shader, der nacheinander f√ºr zwei Texturen aufgerufen wird, sodass wir ihn bei jedem Rendern √ºberschreiben </li><li>  Attribut - Daten dieses Typs werden aus dem Vertex-Puffer gelesen und m√ºssen bei jedem Rendern geladen werden </li><li>  Variieren - Wird ben√∂tigt, um Daten vom Vertex-Shader zum Fragment zu √ºbertragen </li></ul><br><p>  Wie √ºbergebe ich Parameter an einen Shader?  Dazu m√ºssen Sie zuerst die ID (den Zeiger) der Variablen abrufen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle = GLES20.glGetAttribLocation(programId, <span class="hljs-string"><span class="hljs-string">"aPosition"</span></span>)</code> </pre> <br><p>  F√ºr diese ID m√ºssen Sie nun die Daten laden: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      floatbuffer val verticesBuffer = ByteBuffer.allocateDirect( fullscreenTexture.size * FLOAT_SIZE_BYTES ).order( ByteOrder.nativeOrder() ).asFloatBuffer() verticesBuffer.put(fullscreenTexture).position(0) /*    -  XYZ   0 .       id      ,     ,               - 5  - XYZUV,  4 - -   float */ verticesBuffer.position(0) GLES20.glVertexAttribPointer( aPositionHandle, 3, GLES20.GL_FLOAT, false, 5 * 4, verticesBuffer )</span></span></code> </pre> <br><p>  <strong>Direkte Zeichnung</strong> </p><br><p>  Nachdem wir unsere Shader mit allen Daten gef√ºllt haben, sollten wir die Textur bitten, das Bild zu aktualisieren und OpenGL, um unsere Eckpunkte zu zeichnen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { ... surfaceTexture.updateTexImage() GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) }</code> </pre> <br><p>  In unserem Beispiel werden wir die Arbeit mit der OpenGL-Szene in zwei Klassen aufteilen - direkt Szenen und Texturen: </p><br><p>  <a href="https://github.com/tttzof351/AndroidSurfaceExample/blob/master/app/src/main/java/com/example/surfaces/helpers/OpenGLExternalTexture.kt/" rel="nofollow">OpenGLExternalTexture.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLExternalTexture</span></span></span></span>(verticesData: FloatArray, ...) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surfaceTexture: SurfaceTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> surface: Surface <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,    . } ... fun updateFrame(aPositionHandle: Int, ...) {...} // ,   fun release() {...} //   }</span></span></code> </pre> <br><p>  <a href="" rel="nofollow">OpenGLScene.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenGLScene</span></span></span></span>( sceneWidth: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, sceneHeight: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, ... ) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullscreenTexture = OpenGLExternalTexture(...) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = OpenGLExternalTexture(..) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> aPositionHandle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,        . } fun updateFrame() { ... fullscreenTexture.updateFrame(aPositionHandle, ...) smallTexture.updateFrame(aPositionHandle, ...) } fun release() { fullscreenTexture.release() smallTexture.release() } }</span></span></code> </pre> <br><h2 id="statemachine--mashina-sostoyaniy--konechnyy-avtomat">  StateMachine / State Machine / State Machine </h2><br><p>  Alle APIs, die wir in unserem Beispiel verwenden m√∂chten, sind grunds√§tzlich asynchron (naja, vielleicht mit Ausnahme des animierten Drawable).  Wir werden solche Aufrufe in separate StateMachines einbinden, einen Ansatz, bei dem die Systemzust√§nde explizit ausgeschrieben werden und √úberg√§nge zwischen ihnen durch das Senden von Ereignissen auftreten. </p><br><p>  Schauen wir uns ein einfaches Beispiel an, wie dies aussehen wird. Nehmen wir an, wir haben diesen Code: </p><br><pre> <code class="kotlin hljs">imageView.setOnClickListener { loadImage { bitmap -&gt; imageView.setBitmap(bitmap) } }</code> </pre> <br><p>  Im Allgemeinen ist alles in Ordnung - sch√∂n und kompakt, aber wir werden versuchen, es folgenderma√üen umzuschreiben: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiMachine = UIMachine() imageView.setOnClickListener { uiMachine.send(Click(imageView)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: State = WaitClick() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Action</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingClick &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Click -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitBitmap(imageView = action.imageView) loadImage { send(BitmapIsReady(bitmap = it)) } } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitingBitmap &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> BitmapIsReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitClick state.imageView.setImageBitmap(action.bitmap) } } } } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> WaitingClick : State() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitingBitmap</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): State() } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> imageView: ImageView): Action() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitmapIsReady</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bitmap: Bitmap): Action() }</code> </pre> <br><p>  Einerseits stellte sich <strong><em>viel</em></strong> mehr heraus, dennoch erschienen einige implizite, aber n√ºtzliche Eigenschaften: Wiederholtes Dr√ºcken f√ºhrt jetzt nicht zu unn√∂tigen <strong>loadImage-</strong> Starts <strong>,</strong> obwohl dies bei einem solchen Volume nicht offensichtlich ist, aber wir haben den verschachtelten R√ºckruf beseitigt, den wir sp√§ter verwenden werden und der Schreibstil der √úbergangsmethode erm√∂glicht es Ihnen, ein √úbergangsdiagramm zu erstellen, das den Code eins zu eins wiederholt, d. h. in unserem Fall: </p><br><p><img src="https://habrastorage.org/webt/-n/2p/mq/-n2pmqdwfsps932me0wfsrvyj_q.png"><br>  Grau kennzeichnet √úberg√§nge, die nicht explizit ausgeschrieben sind.  Oft werden sie protokolliert oder l√∂sen eine Ausnahme aus, da dies ein Anzeichen f√ºr einen Fehler ist.  Wir werden es vorerst schaffen, es einfach zu ignorieren und in Zukunft nicht mehr auf die Diagramme zu verweisen. </p><br><p>  Erstellen Sie die Basisschnittstellen f√ºr StateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S : State, A : Action</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: S <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><h2 id="glsurfaceview">  GLSurfaceView </h2><br><p>  Der einfachste Weg, etwas mit OpenGL in Android anzuzeigen, ist die GLSurfaceView-Klasse - sie erstellt automatisch einen neuen Stream zum Zeichnen, der mit den GLSurfaceView :: onResume / onPause-Methoden gestartet / angehalten wird. </p><br><p>  Der Einfachheit halber werden wir unsere Ansicht auf ein Verh√§ltnis von 16: 9 einstellen. </p><br><p>  Der Rendervorgang selbst wird in einen separaten R√ºckruf verschoben - GLSurfaceView.Renderer. <br>  Wenn wir es in StateMachine einpacken, bekommen wir so etwas: </p><br><p>  <a href="" rel="nofollow">GLSurfaceMachine.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceMachine</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateMachine</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLSurfaceState, GLSurfaceAction</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state: GLSurfaceState = WaitCreate() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = transition(action) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLSurfaceAction</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Create -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady(...) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.glSurfaceView?.setRenderer(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> :Renderer { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, width: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> send(SurfaceReady(width, height, gl)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, config: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EGLConfig</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDrawFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GL10</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { send(Draw) } }) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SurfaceReady -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openGLScene = OpenGLScene(width, height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = DrawingAvailable(openGLScene, ...) } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { state.openGLScene.updateFrame() } state !<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitCreate &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Stop -&gt; { state.uiHolder.glSurfaceView?.onPause() state.uiHolder.openGLScene?.release() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = WaitSurfaceReady() } state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> WaitSurfaceReady &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Start -&gt; { state.uiHolder.glSurfaceView?.onResume() } } } } ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceMachine = GLSurfaceMachine() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> glSurfaceView = findViewById(R.id.gl_view) glSurfaceView.layoutParams.width = width glSurfaceView.layoutParams.height = ((<span class="hljs-number"><span class="hljs-number">16f</span></span>/<span class="hljs-number"><span class="hljs-number">9f</span></span>) * width).toInt() glSurfaceMachine.send(GLSurfaceAction.Create(glSurfaceView, ...))</code> </pre> <br><p>  Zeichnen wir ein √úbergangsdiagramm: </p><br><p><img src="https://habrastorage.org/webt/mx/5i/xb/mx5ixbssfaqci1ktsmumu94jbz0.png"></p><br><p>  Jetzt versucht unser Code, etwas auf dem Bildschirm anzuzeigen, aber im Moment funktioniert es nur schlecht - wir werden nichts anderes als einen schwarzen Bildschirm sehen.  Es ist nicht schwer zu erraten, dass jetzt nichts in unsere Oberfl√§che gelangt, da wir noch keine Bildquellen implementiert haben.  Lass uns das beheben - erstens erstelle ein CanvasDrawable: </p><br><p>  <a href="" rel="nofollow">CanvasDrawable.kt</a> </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasDrawable</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Drawable</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundPaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> circlePaint = Paint().apply { ... } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(canvas: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Canvas</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { canvas.drawRect(bounds, backgroundPaint) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = bounds.width() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> height = bounds.height() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posX = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> posY = ... canvas.drawCircle(posX, posY, <span class="hljs-number"><span class="hljs-number">0.1f</span></span> * width, circlePaint) } ... }</code> </pre> <br><p>  Jetzt k√∂nnen wir den Abschnitt in GLSurfaceMachine erg√§nzen, indem wir canvasDrawable auf canvas rendern, wodurch die Oberfl√§che der entsprechenden Textur bereitgestellt wird: </p><br><pre> <code class="kotlin hljs">state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DrawingAvailable &amp;&amp; action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Draw -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvasDrawable = state.canvasDrawable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> smallTexture = state.openGLScene.smallTexture <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bounds = canvasDrawable.bounds <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> canvas = smallSurface.lockCanvas(bounds) canvasDrawable.draw(canvas) smallSurface.unlockCanvasAndPost(canvas) state.openGLScene.updateFrame() }</code> </pre> <br><p>  Danach sehen wir etwas wie: </p><br><p><img src="https://habrastorage.org/webt/vo/4r/-d/vo4r-dgpynjvynvxdomy2fezp9y.png"></p><br><h2 id="camera-api-v2">  Kamera-API V2 </h2><br><p>  Das gr√ºne Rechteck macht sicherlich Spa√ü und ist faszinierend, aber es ist an der Zeit, die Vorschau von der Kamera auf die verbleibende Oberfl√§che zu bringen. </p><br><p>  Lassen Sie uns die Schritte f√ºr die Arbeit mit der Kamera aufschreiben: </p><br><ul><li>  Wir warten auf Erlaubnis.  Wir werden diesen Zustand <strong>WaitingStart haben</strong> </li><li>  Wir bekommen die Kamera-Manager-Instanz, wir finden die logische ID (normalerweise gibt es zwei davon - f√ºr die R√ºckseite und die Vorderseite, und die logische ist, weil die Kamera auf modernen Ger√§ten aus vielen Sensoren bestehen kann) der gew√ºnschten Kamera, w√§hlen die entsprechende Gr√∂√üe, √∂ffnen die Kamera, wir bekommen cameraDevice.  Status <strong>WaitingOpen</strong> </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> manager = getSystemService(Context.CAMERA_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CameraManager <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultCameraId: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultSize: Size? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cameraId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> manager.cameraIdList) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = manager.getCameraCharacteristics(cameraId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> facing = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(CameraCharacteristics.LENS_FACING) ?: -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing == LENS_FACING_BACK) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confMap = chars.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>( CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sizes = confMap?.getOutputSizes(SurfaceTexture::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resultSize</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findSize</span></span></span></span>(sizes) resultCameraId = cameraId <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } resultCameraId?.let { cameraId -&gt; manager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraDevice.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(camera: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraDevice</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//Success open camera ... } }) }</span></span></code> </pre> <br><ul><li>  Bei ge√∂ffneter Kamera wenden wir uns an eine Oberfl√§che, um das Bild anzuzeigen.  <strong>WaitingSurface</strong> Status </li><li>  Nachdem wir cameraDevice, Surface haben, m√ºssen wir eine Sitzung er√∂ffnen, damit die Kamera endlich mit der Daten√ºbertragung beginnt.  <strong>Wartesitzungsstatus</strong> </li></ul><br><pre> <code class="kotlin hljs">cameraDevice.createCaptureSession( arrayListOf(surface), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.StateCallback() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CameraCaptureSession</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { send(CameraAction.SessionReady(session)) } }, handler )</code> </pre> <br><ul><li>  Jetzt k√∂nnen wir die Vorschau erfassen.  <strong>StartingPreview</strong> Status </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = cameraDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW ).apply { addTarget(surface) } session.setRepeatingRequest( request.build(), <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : CameraCaptureSession.CaptureCallback() {...} handler )</code> </pre> <br><p>  Wir veranschaulichen unser aktuelles Schema: </p><br><p>  <a href="" rel="nofollow">CameraMachine.kt</a> </p><br><p><img src="https://habrastorage.org/webt/i6/tj/q1/i6tjq12xls77hudocvpnt0m6qy0.png"></p><br><p><img src="https://habrastorage.org/webt/6w/ad/fp/6wadfpayduldvtqwcrjggkoce6y.png"></p><br><h2 id="mediacodec">  Mediacodec </h2><br><p>  MediaCodec ist eine Klasse f√ºr die Arbeit mit Systemcodecs auf niedriger Ebene. Im Allgemeinen besteht die API aus einer Reihe von Eingabe- / Ausgabepuffern (das klingt leider einfacher als damit zu arbeiten), in denen Daten (roh oder codiert, abh√§ngig von der Betriebsart des Codierers / Decodierers) abgelegt werden Am Ausgang erhalten wir das Ergebnis. </p><br><p>  Obwohl ByteBuffer normalerweise als Puffer fungiert, k√∂nnen Sie Surface f√ºr die Arbeit mit Video verwenden, wodurch MediaCodec :: createInputSurface an uns zur√ºckgegeben wird. Darauf sollten wir die aufzuzeichnenden Frames zeichnen (bei diesem Ansatz verspricht uns die Dokumentation eine schnellere Codierung durch die Verwendung von GPU ) </p><br><p>  Nun m√ºssen wir lernen, wie wir die vorhandene Oberfl√§che zeichnen, die wir in GLSurfaceMachine auf Surface von MediaCodec erstellt haben.  Es ist wichtig, sich daran zu erinnern, dass Surface ein Objekt ist, das einen Konsumenten erzeugt, und im Allgemeinen ist es unm√∂glich, etwas daraus zu lesen, d. H. Es gibt keine bedingte Methode getBitmap / readImage / ... </p><br><p>  Wir werden wie folgt vorgehen: Auf der Grundlage des vorhandenen GL-Kontexts werden wir einen neuen erstellen, der ein gemeinsames Ged√§chtnis hat, und daher k√∂nnen wir ihn verwenden, um die ID-Shniks der Texturen, die wir zuvor dort erstellt haben, wiederzuverwenden.  Mit dem neuen GL-Kontext und Surface von MediaCodec erstellen wir dann ein EGLSurface - einen Off-Screen-Puffer, auf dem wir auch unsere OpenGLScene-Klasse erstellen k√∂nnen.  Dann versuchen wir bei jedem Frame-Rendering, den Frame parallel in die Datei zu schreiben. </p><br><p>  EGL bedeutet die Schnittstelle der Interaktion der OpenGL-API mit dem Fenstersubsystem der Plattform, wir werden die Arbeit damit von grafika stehlen.  Ich werde den F√∂rderer (EncoderHelper) mit MediaCodec auch nicht direkt beschreiben, sondern nur das endg√ºltige Interaktionsschema zwischen unseren Komponenten angeben: </p><br><p>  <a href="" rel="nofollow">EncoderMachine.kt</a> <br>  <a href="" rel="nofollow">EncoderHelper.kt</a> </p><br><p><img src="https://habrastorage.org/webt/d1/gc/kf/d1gckfqligsrwynmmkq_bb2yzoy.png"></p><br><h2 id="itog">  Das ergebnis: </h2><br><ul><li>  Das Arbeiten mit Videos erfordert mindestens Grundkenntnisse in OpenGL </li><li>  Die Android Media-API ist recht einfach, was Flexibilit√§t bietet, aber manchmal zwingt sie Sie dazu, etwas mehr Code zu schreiben, als Sie m√∂chten </li><li>  Asynchrone APIs k√∂nnen in StateMachines eingeschlossen werden </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480878/">https://habr.com/ru/post/de480878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480866/index.html">Eine neue √Ñra der Webentwicklung oder "alles ist schon da"</a></li>
<li><a href="../de480870/index.html">Jahrzehntelange Ergebnisse</a></li>
<li><a href="../de480872/index.html">Intel hat eine Sicherheitsl√ºcke geschlossen, die vor sechs Monaten gemeldet wurde</a></li>
<li><a href="../de480874/index.html">Das Studium der Neutrinos f√ºhrte zu einer unerwarteten Entdeckung in der Mathematik</a></li>
<li><a href="../de480876/index.html">Wir bereinigen das Dock und machen die Anwendung ohne xCode</a></li>
<li><a href="../de480884/index.html">Python-GUI in 5 Minuten</a></li>
<li><a href="../de480886/index.html">Neuronale Netze und der goldene Schnitt: zweiter Lauf</a></li>
<li><a href="../de480888/index.html">DIY Coroutinen. Teil 1. Lazy Generators</a></li>
<li><a href="../de480890/index.html">Umfrageergebnisse zur Verwendung des Express-Panels</a></li>
<li><a href="../de480892/index.html">Ballon-Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>