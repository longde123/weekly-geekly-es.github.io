<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏮 ➿ 🖐🏿 Cloud Smart Home. Bagian 1: Kontroler dan Sensor 🎅 📲 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, berkat perkembangan cepat mikroelektronika, saluran komunikasi, teknologi Internet dan Inteligensi Buatan, topik rumah pintar menjadi semaki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cloud Smart Home. Bagian 1: Kontroler dan Sensor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467219/"><img src="https://habrastorage.org/webt/q6/ni/9k/q6ni9k05gsedjwzqbsyfr_zc7sc.png"><br><br>  Hari ini, berkat perkembangan cepat mikroelektronika, saluran komunikasi, teknologi Internet dan Inteligensi Buatan, topik rumah pintar menjadi semakin relevan.  Tempat tinggal manusia telah mengalami perubahan signifikan sejak Zaman Batu dan di era Revolusi Industri 4.0 dan Internet of Things menjadi nyaman, fungsional dan aman.  Solusi datang ke pasar yang mengubah apartemen atau rumah pedesaan menjadi sistem informasi yang canggih, dikelola dari mana saja di dunia menggunakan smartphone.  Selain itu, pengetahuan tentang bahasa pemrograman tidak lagi diperlukan untuk interaksi manusia-mesin - berkat pengenalan ucapan dan algoritma sintesis bicara, seseorang berbicara bahasa aslinya dengan rumah pintar. <br><br>  Beberapa sistem rumah pintar yang saat ini ada di pasaran adalah pengembangan logis dari sistem pengawasan video berbasis cloud, pengembang yang menyadari perlunya solusi komprehensif tidak hanya untuk pemantauan, tetapi juga untuk mengelola objek jarak jauh. <br><br>  Kami menawarkan kepada Anda serangkaian tiga artikel, yang akan memberi tahu Anda tentang semua komponen utama sistem rumah pintar cloud, yang dikembangkan secara pribadi oleh penulis dan dioperasikan.  Artikel pertama dikhususkan untuk peralatan klien terminal yang dipasang di dalam rumah pintar, yang kedua untuk arsitektur penyimpanan awan dan sistem pemrosesan data, dan akhirnya, yang ketiga untuk aplikasi klien untuk mengelola sistem pada perangkat seluler dan alat-alat stasioner. <br><a name="habracut"></a><br><h1>  Peralatan Rumah Pintar </h1><br>  Pertama, mari kita bicara tentang cara membuat rumah pintar dari apartemen, pondok atau pondok biasa.  Untuk ini, sebagai aturan, diperlukan untuk menempatkan peralatan berikut di rumah: <br><br><ol><li>  sensor yang mengukur berbagai parameter lingkungan; </li><li>  aktuator yang bekerja pada objek eksternal; </li><li>  pengontrol yang melakukan perhitungan sesuai dengan pengukuran sensor dan logika tertanam, dan mengeluarkan perintah untuk aktuator. </li></ol><br>  Gambar berikut menunjukkan diagram rumah pintar, di mana ada sensor kebocoran air (1) di kamar mandi, suhu (2) dan pencahayaan (3) di kamar tidur, soket pintar (4) di dapur dan kamera video (5) di lorong. <br><br><img src="https://habrastorage.org/webt/nq/en/f-/nqenf-epwiuqhsimy3ft2wbyvpo.png"><br><br>  Saat ini, sensor nirkabel yang beroperasi di bawah protokol RF433, Z-Wave, ZigBee, Bluetooth dan WiFi banyak digunakan.  Keuntungan utama mereka adalah kemudahan instalasi dan penggunaan, serta biaya dan keandalan yang rendah, karena  Produsen berusaha membawa perangkat mereka ke pasar massal dan membuatnya tersedia bagi pengguna rata-rata. <br><br>  Sensor dan aktuator, sebagai suatu peraturan, terhubung melalui antarmuka nirkabel ke pengontrol rumah pintar (6) - komputer mikro khusus yang mengintegrasikan semua perangkat ini ke dalam satu jaringan dan mengendalikannya. <br><br>  Namun, beberapa solusi dapat menggabungkan sensor, aktuator, dan pengontrol secara bersamaan.  Misalnya, soket cerdas dapat diprogram untuk menghidupkan atau mematikan jadwal, dan kamera pengintai video berbasis cloud dapat merekam video berdasarkan sinyal dari detektor gerakan.  Dalam kasus paling sederhana, Anda dapat melakukannya tanpa pengontrol terpisah, tetapi untuk membuat sistem yang fleksibel dengan banyak skenario, itu perlu. <br><br>  Untuk menghubungkan pengontrol rumah pintar ke jaringan global, router Internet konvensional (7) dapat digunakan, yang telah lama menjadi alat rumah tangga yang akrab di rumah mana pun.  Ada satu argumen lagi yang mendukung pengontrol rumah pintar - jika koneksi ke Internet terputus, rumah pintar akan terus beroperasi secara normal karena blok logika yang disimpan di dalam pengontrol, dan bukan di layanan cloud. <br><br><h1>  Pengontrol rumah pintar </h1><br>  Pengontrol untuk sistem rumah pintar cloud yang dibahas dalam artikel ini dikembangkan atas dasar mikrokomputer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B</a> -board <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model 3 + B Raspberry Pi</a> , yang dirilis pada Maret 2018 dan memiliki sumber daya dan kinerja yang cukup untuk tugas-tugas rumah pintar.  Ini terdiri dari prosesor Cortex-A53 quad-core dengan arsitektur ARMv8-A 64-bit dengan frekuensi clock 1,4 GHz, serta 1 GB RAM, Wi-Fi 802.11ac, Bluetooth 4.2 dan adaptor gigabit Ethernet yang bekerja melalui bus USB 2.0. <br><br><img src="https://habrastorage.org/webt/ki/di/-_/kidi-_hdoclhmawxeqcgxvjxnwm.jpeg"><br><br>  Merakit pengontrol sangat sederhana - komputer mikro (1) dipasang di wadah plastik (2), kemudian kartu microSD 8 GB dengan perangkat lunak (3) dan pengontrol jaringan USB Z-Wave (4) dimasukkan ke dalam slot yang sesuai di dalamnya.  Pengontrol rumah pintar terhubung ke listrik melalui adaptor daya 5V, 2.1A (5) dan kabel USB-mikro-USB (6).  Setiap pengontrol memiliki nomor identifikasi unik, yang dicatat dalam file konfigurasi pada awal pertama dan diperlukan untuk interaksi dengan layanan cloud smart home. <br><br>  Perangkat lunak pengontrol rumah pintar dikembangkan oleh penulis artikel ini berdasarkan sistem operasi <b>Linux Raspbian Stretch</b> .  Ini terdiri dari subsistem utama berikut: <br><br><ul><li>  proses server untuk berinteraksi dengan peralatan rumah pintar dan cloud; </li><li>  antarmuka pengguna grafis untuk mengkonfigurasi parameter pengontrol dan operasi; </li><li>  Basis data untuk menyimpan konfigurasi pengontrol. </li></ul><br><img src="https://habrastorage.org/webt/s6/lx/k-/s6lxk-xr0gnx8cy5wohn6u8pgqo.png"><br><br>  <b>Basis data</b> pengontrol rumah pintar didasarkan pada DBMS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SQLite</a> tertanam dan merupakan file pada kartu SD dengan perangkat lunak sistem.  Ini berfungsi sebagai repositori dari konfigurasi pengontrol - informasi tentang peralatan yang terhubung dan keadaan saat ini, blok aturan produksi logis, serta informasi yang memerlukan pengindeksan (misalnya, nama file arsip video lokal).  Ketika controller dinyalakan kembali, informasi ini disimpan, yang memungkinkan untuk mengembalikan controller jika terjadi kegagalan daya. <br><br>  <b>Antarmuka grafis dari</b> pengontrol rumah pintar dikembangkan dalam PHP 7 menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Slim</a> microframework.  Server web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.lig">lighttpd</a> , yang sering digunakan dalam perangkat tertanam karena kinerjanya yang baik dan persyaratan sumber daya yang rendah, bertanggung jawab untuk pengoperasian aplikasi. <br><br> <a href=""><img src="https://habrastorage.org/webt/p6/jh/w0/p6jhw0khe-pnljdtzf54qjrtgna.png"></a> <br>  <font color="grey">(klik pada gambar untuk membuka dalam resolusi yang lebih tinggi)</font> <br><br>  Fungsi utama dari antarmuka grafis adalah untuk menghubungkan peralatan rumah pintar (IP-kamera dan sensor) ke controller.  Aplikasi web membaca konfigurasi dan status pengontrol dan perangkat saat ini yang terhubung dari database SQLite.  Untuk mengubah konfigurasi controller, ia mengirimkan perintah kontrol dalam format JSON melalui RESTful API dari proses server. <br><br><h1>  Proses server </h1><br>  <b>Proses server</b> adalah komponen kunci yang melakukan semua pekerjaan dasar mengotomatisasi proses informasi yang membentuk fondasi rumah pintar: menerima dan memproses data sensorik, mengeluarkan tindakan kontrol tergantung pada logika yang mendasarinya.  Tujuan dari proses server adalah untuk berinteraksi dengan peralatan rumah pintar, mengikuti aturan logika produksi, menerima dan memproses perintah dari antarmuka grafis dan cloud.  Proses server dalam pengontrol rumah pintar ini diimplementasikan sebagai aplikasi multi-ulir yang dikembangkan dalam C ++ dan diluncurkan sebagai layanan <b>systemd</b> terpisah dari <b>sistem</b> operasi <b>Linux Raspbian</b> . <br><br>  Blok utama dari proses server adalah: <br><br><ol><li>  Pengelola Pesan </li><li>  Server kamera IP; </li><li>  Server perangkat Z-Wave; </li><li>  Aturan logika produksi server; </li><li>  Database konfigurasi pengontrol dan blok aturan logis; </li><li>  Server API yang tenang untuk berinteraksi dengan antarmuka grafis; </li><li>  Klien MQTT untuk berinteraksi dengan cloud. </li></ol><br>  Blok proses server diimplementasikan sebagai aliran terpisah, informasi di antaranya dikirimkan dalam bentuk pesan dalam format JSON (atau struktur data yang mewakili format ini dalam memori proses). <br><br><img src="https://habrastorage.org/webt/vl/vm/md/vlvmmduxt7nsh-bjkpshrywrcqa.png"><br><br>  Komponen utama dari proses server adalah <b>manajer pesan</b> , yang merutekan pesan dalam format JSON untuk semua blok proses server.  Jenis bidang informasi pesan JSON dan nilai yang dapat mereka terima tercantum dalam tabel: <br><br><div class="scrollable-table"><table><tbody><tr><th>  tipe perangkat </th><th>  protokol </th><th>  Jenis pesan </th><th>  deviceState </th><th>  perintah </th></tr><tr><td>  kamera </td><td>  onvif </td><td>  sensorData </td><td>  pada </td><td>  streaming (Hidup / Mati) </td></tr><tr><td>  sensor </td><td>  zwave </td><td>  perintah </td><td>  off </td><td>  rekaman (Aktif / Nonaktif) </td></tr><tr><td>  efektor </td><td>  mqtt </td><td>  businessLogicRule </td><td>  streaming (Hidup / Mati) </td><td>  evice (Tambah / Hapus) </td></tr><tr><td></td><td>  businesslogic </td><td>  configurationData </td><td>  rekaman (Aktif / Nonaktif) </td><td></td></tr><tr><td></td><td>  bluetooth </td><td>  deviceState </td><td>  kesalahan </td><td></td></tr><tr><td></td><td>  wifi </td><td></td><td></td><td></td></tr><tr><td></td><td>  rf </td><td></td><td></td><td></td></tr></tbody></table></div><br><br>  Misalnya, pesan dari pendeteksi gerakan kamera terlihat seperti ini: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span>: <span class="hljs-string"><span class="hljs-string">"*****"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"timestampMs"</span></span>: <span class="hljs-string"><span class="hljs-string">"1566293475475"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"clientType"</span></span>: <span class="hljs-string"><span class="hljs-string">"gateway"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"1616453d-30cd-44b7-9bf0-************"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"onvif"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensorData"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorType"</span></span>: <span class="hljs-string"><span class="hljs-string">"camera"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"motionDetector"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorData"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span> }</code> </pre> <br><h1>  Logika produksi </h1><br>  Untuk menerima atau mengirim pesan dari dispatcher, blok proses server berlangganan pesan dari jenis tertentu.  Berlangganan adalah aturan logis produksi dari jenis <i>"Jika ... lalu ..."</i> , disajikan dalam format JSON, dan tautan ke penangan pesan di dalam blok proses server.  Misalnya, agar server kamera IP dapat menerima perintah dari GUI dan cloud, Anda perlu menambahkan aturan berikut: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"if"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"and"</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">"equal"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"1616453d-30cd-44b7-9bf0-************"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"equal"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"command"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"then"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"result"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> } }</code> </pre><br>  Jika kondisi yang ditentukan dalam <b>anteseden</b> (sisi kiri) dari aturan adalah benar, maka <b>aturan</b> (sisi kanan) dari aturan dijalankan, dan pawang mendapatkan akses ke isi pesan JSON.  Anteseden mendukung operator logis yang melakukan perbandingan pasangan nilai kunci JSON: <br><br><ol><li>  sama dengan "sama"; </li><li>  tidak sama dengan "not_equal"; </li><li>  kurang "kurang"; </li><li>  lebih "lebih besar"; </li><li>  kurang dari atau sama dengan "less_or_equal"; </li><li>  lebih besar dari atau sama dengan better_or_equal. </li></ol><br>  Hasil perbandingan dapat dihubungkan bersama menggunakan operator aljabar Boolean: <br><br><ol><li>  Dan "dan"; </li><li>  ATAU "atau"; </li><li>  TIDAK "tidak". </li></ol><br>  Jadi, menulis operator dan operan dalam notasi Polandia, adalah mungkin untuk membentuk kondisi yang cukup kompleks dengan sejumlah besar parameter. <br><br>  Mekanisme yang sama persis, berdasarkan pesan JSON dan aturan produksi dalam format JSON, digunakan dalam blok server logika produksi untuk mewakili pengetahuan dan membuat inferensi logis menggunakan data sensorik dari sensor rumah pintar. <br><br>  Menggunakan aplikasi seluler, pengguna membuat skrip yang menurutnya rumah pintar harus berfungsi.  Misalnya: <i>"Jika sensor untuk membuka pintu depan telah berfungsi, maka nyalakan lampu di lorong</i> . <i>"</i>  Aplikasi membaca pengidentifikasi sensor (sensor pembuka) dan aktuator (soket pintar atau lampu pintar) dari database dan menghasilkan aturan logis dalam format JSON, yang dikirim ke pengontrol rumah pintar.  Mekanisme ini akan dibahas secara lebih rinci dalam artikel ketiga dari seri kami, di mana kami akan berbicara tentang aplikasi klien untuk mengelola rumah pintar. <br><br>  Mekanisme logika produksi yang dibahas di atas diimplementasikan menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RapidJSON</a> , parser SAX dari format JSON dalam C ++.  Membaca dan parsing array aturan produksi yang konsisten membuatnya mudah untuk mengimplementasikan fungsi pencocokan data dalam anteseden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CRuleEngine::Process(PProperties pFact) { m_pActions-&gt;clear(); rapidjson::Reader reader; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(TStringMap::value_type&amp; rRule : m_Rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sRuleId = rRule.first; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sRuleBody = rRule.second; <span class="hljs-function"><span class="hljs-function">CRuleHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ruleHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pFact)</span></span></span></span>; rapidjson::<span class="hljs-function"><span class="hljs-function">StringStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ruleStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sRuleBody.c_str())</span></span></span></span>; rapidjson::ParseResult parseResult = reader.Parse(ruleStream, ruleHandler); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!parseResult) { m_Logger.LogMessage( NLogger2::ePriorityLevelError, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"JSON parse error"</span></span>), <span class="hljs-string"><span class="hljs-string">"CRuleEngine::Process()"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"RuleId: "</span></span>) + sRuleId); } PProperties pAction = ruleHandler.GetAction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pAction) { pAction-&gt;Set(<span class="hljs-string"><span class="hljs-string">"ruleId"</span></span>, sRuleId); m_pActions-&gt;push_back(pAction); } } }</code> </pre><br>  Di sini <b>pFact</b> adalah struktur yang berisi pasangan nilai kunci dari pesan JSON, <b>m_Rules</b> adalah array string aturan produksi.  Perbandingan pesan masuk dan aturan produksi dilakukan di fungsi <b>reader.Parse (ruleStream, ruleHandler)</b> , di mana <b>ruleHandler</b> adalah objek yang berisi logika operator Boolean dan operator perbandingan.  <b>sRuleId</b> adalah pengidentifikasi aturan yang unik, karena itu dimungkinkan untuk menyimpan dan mengedit aturan di dalam database pengontrol rumah pintar.  <b>m_pActions</b> - array dengan hasil inferensi logis: pesan JSON yang berisi konsistensi dari basis aturan dan diteruskan ke manajer pesan sehingga aliran pelanggan dapat memprosesnya. <br><br>  Kinerja RapidJSON sebanding dengan fungsi <b>strlen ()</b> , dan persyaratan sumber daya sistem minimum memungkinkan perpustakaan ini untuk digunakan dalam perangkat yang disematkan.  Menggunakan pesan dan aturan logis dalam format JSON memungkinkan Anda menerapkan sistem pertukaran informasi yang fleksibel antara semua komponen pengendali rumah pintar. <br><br><h2>  Sensor dan Aktuator Z-Wave </h2><br>  Keuntungan utama dari rumah pintar adalah dapat secara mandiri mengukur berbagai parameter lingkungan dan melakukan fungsi yang berguna tergantung pada situasinya.  Untuk melakukan ini, sensor dan aktuator terhubung ke pengontrol rumah pintar.  Dalam versi saat ini, ini adalah perangkat nirkabel yang beroperasi sesuai dengan protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Z-Wave</a> pada frekuensi yang dialokasikan khusus <b>869 MHz</b> untuk Rusia.  Untuk pekerjaan mereka, mereka digabungkan ke dalam jaringan mesh, di mana pengulang sinyal hadir untuk meningkatkan area jangkauan.  Perangkat juga memiliki mode hemat energi khusus - mereka menghabiskan sebagian besar waktu dalam mode tidur dan mengirim informasi hanya ketika keadaannya berubah, yang secara signifikan dapat memperpanjang usia baterai built-in. <br><br><img src="https://habrastorage.org/webt/d8/ur/dp/d8urdpbsw6yxxxxqov8uj-hphzs.jpeg"><br><br>  Di pasaran sekarang Anda dapat menemukan sejumlah besar perangkat Z-Wave yang berbeda.  Sebagai contoh, pertimbangkan beberapa: <br><br><ol><li>  Soket pintar Zipato PAN16 dapat mengukur parameter berikut: konsumsi daya (kW / jam), daya (W), tegangan (V) dan arus (A) di listrik.  Ini juga memiliki sakelar bawaan yang dapat digunakan untuk mengontrol alat listrik yang terhubung; </li><li>  Sensor kebocoran Neo Coolcam mendeteksi keberadaan cairan yang tumpah dengan menutup kontak probe jarak jauh; </li><li>  Detektor asap Zipato PH-PSG01 dipicu ketika partikel-partikel asap memasuki ruang analisis gas; </li><li>  Sensor gerak Neo Coolcam menganalisis radiasi inframerah dari tubuh manusia.  Selain itu ada sensor cahaya (Lx); </li><li>  Philio PST02-A multisensor mengukur suhu (° C), pencahayaan (%), bukaan pintu, keberadaan seseorang di ruangan; </li><li>  Z-Wave USB Stick ZME E UZB1 pengontrol jaringan, yang terhubung dengan sensor. </li></ol><br>  Sangat penting bahwa perangkat dan pengontrol bekerja pada frekuensi yang sama, jika tidak mereka tidak akan melihat satu sama lain pada saat koneksi.  Hingga 232 perangkat dapat dihubungkan ke satu pengontrol jaringan Z-Wave, yang cukup untuk sebuah apartemen atau rumah pedesaan.  Untuk memperluas area jangkauan di dalam ruangan jaringan, smart socket dapat digunakan sebagai pengulang sinyal. <br><br><img src="https://habrastorage.org/webt/o_/q2/oa/o_q2oa4n9w7hpqzr2vihyois9he.png"><br><br>  Dalam proses server pengendali rumah pintar, yang dibahas dalam paragraf sebelumnya, server Z-Wave bertanggung jawab untuk berinteraksi dengan perangkat Z-Wave.  Untuk mendapatkan informasi dari sensor, ia menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenZWave</a> di C ++, yang menyediakan antarmuka untuk interaksi dengan pengontrol USB dari jaringan Z-Wave dan bekerja dengan banyak sensor dan aktuator.  Nilai parameter lingkungan yang diukur oleh sensor direkam oleh server Z-Wave dalam bentuk pesan JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span>: <span class="hljs-string"><span class="hljs-string">"*****"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"timestampMs"</span></span>: <span class="hljs-string"><span class="hljs-string">"1566479791290"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"clientType"</span></span>: <span class="hljs-string"><span class="hljs-string">"gateway"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceId"</span></span>: <span class="hljs-string"><span class="hljs-string">"20873eb0-dd5e-4213-a175-************"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"deviceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"zwave"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"messageType"</span></span>: <span class="hljs-string"><span class="hljs-string">"sensorData"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"homeId"</span></span>: <span class="hljs-string"><span class="hljs-string">"0xefa0cfa7"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nodeId"</span></span>: <span class="hljs-string"><span class="hljs-string">"20"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorType"</span></span>: <span class="hljs-string"><span class="hljs-string">"METER"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Voltage"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sensorData"</span></span>: <span class="hljs-string"><span class="hljs-string">"229.3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"units"</span></span>: <span class="hljs-string"><span class="hljs-string">"V"</span></span> }</code> </pre><br>  Ini kemudian diteruskan ke manajer proses pesan server sehingga utas pelanggan dapat menerimanya.  Pelanggan utama adalah server logika produksi, yang membandingkan nilai bidang pesan dalam anteseden aturan logis.  Hasil dari output logis yang berisi perintah kontrol dikirim kembali ke manajer pesan dan dari sana mereka pergi ke server Z-Wave, yang menerjemahkan mereka dan mengirimkannya ke pengontrol USB dari jaringan Z-Wave.  Kemudian mereka jatuh ke dalam perangkat eksekutif, yang mengubah keadaan lingkungan, dan rumah pintar, dengan demikian, melakukan pekerjaan yang bermanfaat. <br><br> <a href=""><img src="https://habrastorage.org/webt/_s/1m/wk/_s1mwk6ysdi5l9ynhtawcbaolfg.png"></a> <br>  <font color="grey">(klik pada gambar untuk membuka dalam resolusi yang lebih tinggi)</font> <br><br>  Perangkat Z-Wave terhubung dalam antarmuka grafis pengontrol rumah pintar.  Untuk melakukan ini, buka halaman dengan daftar perangkat dan klik tombol "Tambah".  Perintah add melalui RESTful API masuk ke proses server dan, kemudian, dikirim oleh manajer pesan ke server Z-Wave, yang menempatkan Z-Wave USB controller dalam mode penambahan perangkat khusus.  Selanjutnya, pada perangkat Z-Wave, Anda perlu melakukan serangkaian penekanan cepat (3 penekanan dalam 1,5 detik) dari tombol layanan.  Pengontrol USB menghubungkan perangkat ke jaringan dan mengirimkan informasi tentangnya ke server Z-Wave.  Itu, pada gilirannya, menciptakan catatan baru dalam database SQLite dengan parameter perangkat baru.  Setelah interval waktu yang telah ditentukan, antarmuka grafis kembali ke halaman daftar perangkat Z-Wave, membaca informasi dari database dan menampilkan perangkat baru dalam daftar.  Pada saat yang sama, setiap perangkat menerima pengenal uniknya sendiri, yang digunakan dalam aturan inferensi produksi dan ketika bekerja di cloud.  Pengoperasian algoritma ini ditunjukkan dalam diagram UML: <br><br> <a href=""><img src="https://habrastorage.org/webt/np/01/lc/np01lc-tc4xbqzxccv18tfuxuz4.png"></a> <br>  <font color="grey">(klik pada gambar untuk membuka dalam resolusi yang lebih tinggi)</font> <br><br><h2>  Koneksi kamera IP </h2><br>  Sistem cloud smart home yang dibahas dalam artikel ini adalah modernisasi dari sistem pengawasan video cloud, juga dikembangkan oleh penulis, yang telah ada di pasaran selama beberapa tahun dan memiliki banyak instalasi di Rusia. <br><br>  Untuk sistem pengawasan video cloud, salah satu masalah akut adalah terbatasnya pilihan peralatan yang dapat digunakan integrasi.  Perangkat lunak yang bertanggung jawab untuk menghubungkan ke cloud dipasang di dalam camcorder, yang segera membuat tuntutan serius pada perangkat kerasnya - prosesor dan jumlah memori bebas.  Ini terutama menjelaskan harga yang lebih tinggi dari kamera pengintai video berbasis cloud dibandingkan dengan kamera IP konvensional.  Selain itu, tahap negosiasi yang panjang dengan produsen kamera CCTV diperlukan untuk mendapatkan akses ke sistem file kamera dan semua alat pengembangan yang diperlukan. <br><br><img src="https://habrastorage.org/webt/zx/c-/sq/zxc-sqnecsbismwgwmztyclcg9k.jpeg"><br><br>  Di sisi lain, semua kamera IP modern memiliki protokol standar untuk berinteraksi dengan peralatan lain (khususnya, DVR).  Dengan demikian, penggunaan pengontrol terpisah yang menghubungkan menggunakan protokol standar dan mengalirkan video stream dari kamera IP ke cloud memberikan keunggulan kompetitif yang signifikan untuk sistem pengawasan video cloud.  Selain itu, jika klien telah menginstal sistem pengawasan video berdasarkan kamera IP sederhana, maka dimungkinkan untuk mengembangkannya dan mengubahnya menjadi rumah pintar berawan penuh. <br><br>  Protokol yang paling populer untuk sistem pengawasan video-IP, yang sekarang didukung oleh semua produsen kamera-IP tanpa kecuali, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ONVIF Profile S</a> , spesifikasi yang ada dalam bahasa deskripsi layanan web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WSDL</a> .  Dengan menggunakan utilitas dari toolkit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gSOAP</a> , dimungkinkan untuk menghasilkan kode sumber layanan yang bekerja dengan kamera IP: <br><br><pre> <code class="bash hljs">$ wsdl2h -o onvif.h \ https://www.onvif.org/ver10/device/wsdl/devicemgmt.wsdl \ https://www.onvif.org/ver10/events/wsdl/event.wsdl \ https://www.onvif.org/ver10/media/wsdl/media.wsdl \ https://www.onvif.org/ver20/ptz/wsdl/ptz.wsdl $ soapcpp2 -Cwvbj -c++11 -d cpp_files/onvif -i onvif.h</code> </pre><br>  Sebagai hasilnya, kita mendapatkan satu set header "* .h" dan sumber "* .cpp" file dalam C ++, yang dapat ditempatkan langsung di aplikasi atau pustaka yang terpisah dan dikompilasi menggunakan kompiler GCC.  Karena banyak fungsi, kodenya besar dan membutuhkan optimasi tambahan.  Komputer mikro Raspberry Pi 3 model B + memiliki kinerja yang cukup untuk mengeksekusi kode ini, tetapi jika ada kebutuhan untuk port kode ke platform lain, perlu untuk memilih arsitektur prosesor dan sumber daya sistem dengan benar. <br><br>  Kamera IP yang mendukung standar ONVIF, ketika beroperasi pada jaringan lokal, terhubung ke grup multicast khusus dengan alamat <b>239.255.255.250</b> .  Ada protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WS-Discovery</a> , yang memungkinkan Anda mengotomatiskan pencarian perangkat di jaringan lokal. <br><br>  Antarmuka pintar pengontrol rumah pintar menerapkan fungsi pencarian untuk kamera IP dalam bahasa PHP, yang sangat nyaman saat berinteraksi dengan layanan web melalui pesan XML.  Ketika Anda memilih item menu <i>Perangkat&gt; Kamera IP&gt; Pindai</i> , algoritma pencarian untuk kamera IP dimulai, menampilkan hasilnya dalam tabel: <br><br> <a href=""><img src="https://habrastorage.org/webt/ew/xk/m6/ewxkm6g2tl7-2nqvjeyzfed8ees.png"></a> <br>  <font color="grey">(klik pada gambar untuk membuka dalam resolusi yang lebih tinggi)</font> <br><br>  Saat menambahkan kamera ke pengontrol, Anda dapat menentukan pengaturan yang akan berinteraksi dengan cloud.  Juga pada tahap ini, secara otomatis ditetapkan pengenal perangkat yang unik, yang dengannya dapat dengan mudah diidentifikasi di masa depan di dalam cloud. <br><br><img src="https://habrastorage.org/webt/jp/uq/al/jpuqalxe9cryxzzg2dpynptjjmy.png"><br><br>  Selanjutnya, pesan dihasilkan dalam format JSON yang berisi semua parameter kamera yang ditambahkan, dan dikirim ke proses server pengendali rumah pintar melalui perintah RESTful API, di mana parameter kamera diterjemahkan dan disimpan dalam database SQLite internal, dan juga digunakan untuk memulai utas pemrosesan berikut: <br><br><ol><li>  membangun koneksi RTSP untuk menerima streaming video dan audio; </li><li>  transcoding audio dari format G.711 mu-Law, G.711 A-Law, G.723, dll.  ke format AAC; </li><li>  transcoding video H.264 dan stream audio AAC ke wadah FLV dan mentransmisikannya ke cloud menggunakan RTMP; </li><li>  membangun koneksi dengan titik akhir detektor gerak kamera IP melalui protokol ONVIF dan pemungutan suara berkala; </li><li>  secara berkala menghasilkan gambar pratinjau gambar kecil dan mengirimkannya ke cloud menggunakan protokol MQTT; </li><li>  rekaman lokal aliran video dan audio dalam bentuk file terpisah dalam format MP4 pada kartu SD atau Flash pengendali rumah pintar. </li></ol><br><img src="https://habrastorage.org/webt/4m/yc/yb/4mycybe00ye3dxglny-fcgsohua.png"><br><br>  Untuk membuat koneksi dengan kamera, transcoding, pemrosesan dan perekaman stream video dalam proses server, fungsi dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FFmpeg</a> 4.1.0 digunakan. <br><br>  Dalam percobaan pengujian kinerja, 3 kamera terhubung ke controller: <br><br><ol><li>  HiWatch DS-I114W (resolusi - 720p, format kompresi - H.264, bitrate - 1 Mb / s, sound G.711 mu-Law); </li><li>  Microdigital MDC-M6290FTD-1 (resolusi - 1080p, format kompresi - H.264, bitrate - 1 Mb / s, tanpa suara); </li><li>  Dahua DH-IPC-HDW4231EMP-AS-0360B (resolusi - 1080p, format kompresi - H.264, bitrate - 1,5 Mb / s, suara AAC). </li></ol><br><img src="https://habrastorage.org/webt/h2/dv/mk/h2dvmkujuqu4sdp6daccgdimnre.png"><br><br>  Ketiga aliran secara bersamaan dikeluarkan ke cloud, transcoding suara dilakukan hanya dari satu kamera, rekaman arsip lokal dinonaktifkan.  Pemanfaatan CPU adalah sekitar 5%, penggunaan RAM adalah 32 MB (per proses), 56 MB (total dengan OS). <br><br>  Dengan demikian, sekitar 20 hingga 30 kamera (tergantung pada resolusi dan bit rate) dapat dihubungkan ke pengontrol rumah pintar, yang cukup untuk sistem pengawasan video pondok tiga lantai atau gudang kecil.  Dalam tugas-tugas di mana kinerja tinggi diperlukan, Anda dapat menggunakan nettop dengan prosesor multi-core Intel dan Linux Debian Sarge OS.  Saat ini, controller sedang menjalani operasi percobaan, dan data kinerjanya akan diperbarui. <br><br><h2>  Interaksi Cloud </h2><br>  Cloud smart home menyimpan data pengguna (pengukuran video dan sensor) di cloud.  Arsitektur penyimpanan awan akan dibahas secara lebih rinci di artikel berikutnya dalam seri kami.  Sekarang mari kita bicara tentang antarmuka untuk mengirimkan pesan informasi dari pengontrol rumah pintar ke cloud. <br><br>  Keadaan perangkat yang terhubung dan pengukuran sensor ditransmisikan menggunakan protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MQTT</a> , yang sering digunakan dalam proyek IoT karena kesederhanaan dan efisiensi energinya.  MQTT menggunakan model server-klien ketika klien berlangganan topik tertentu dalam broker dan mempublikasikan pesan mereka.  Pialang mengirim pesan ke semua pelanggan sesuai dengan aturan yang ditentukan oleh tingkat QoS (Kualitas Layanan): <br><br><ul><li>  QoS 0 - paling banyak sekali (tidak ada jaminan pengiriman); </li><li>  QoS 1 - setidaknya sekali (dengan konfirmasi pengiriman); </li><li>  QoS 2 - tepat sekali (dengan konfirmasi pengiriman tambahan). </li></ul><br>  Dalam kasus kami, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eclipse Mosquitto</a> digunakan sebagai broker MQTT.  Nama topik adalah pengidentifikasi unik pengontrol rumah pintar.  Klien MQTT di dalam proses server berlangganan ke topik ini dan menerjemahkan pesan JSON yang datang dari manajer pesan ke dalamnya.  Dan, sebaliknya, pesan dari broker MQTT dikirim kepada mereka di manajer pesan, yang kemudian multipleks ke pelanggan dalam proses server: <br><br><img src="https://habrastorage.org/webt/zx/ao/ea/zxaoeaqetsr7odlbfsx2xtn35fy.png"><br><br>  Untuk mengirim pesan tentang keadaan pengendali rumah pintar, mekanisme pesan tersimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyimpan pesan dari</a> protokol MQTT digunakan.  Ini memungkinkan Anda untuk memonitor momen-momen koneksi kembali dengan benar saat listrik mati. <br><br>  Klien MQTT dikembangkan berdasarkan implementasi perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eclipse Paho</a> di C ++. <br><br>  H.264 + Streaming media AAC dikirim ke cloud menggunakan protokol RTMP, di mana sekelompok server media bertanggung jawab atas pemrosesan dan penyimpanannya.  Untuk mendistribusikan beban secara optimal dalam kluster dan memilih server media yang paling sedikit dimuat, pengontrol rumah pintar membuat permintaan awal ke penyeimbang beban cloud dan baru kemudian mengirim aliran media. <br><br><h1>  Kesimpulan </h1><br>  Artikel ini meneliti satu implementasi spesifik dari pengontrol rumah pintar yang didasarkan pada komputer mikro Raspberry Pi 3 B +, yang dapat menerima, memproses informasi dan mengelola peralatan menggunakan protokol Z-Wave, berinteraksi dengan kamera IP menggunakan protokol ONVIF, dan juga bertukar data dan perintah dengan cloud Layanan protokol MQTT dan RTMP.  Mesin logika produksi telah dikembangkan berdasarkan perbandingan aturan logis dan fakta yang disajikan dalam format JSON. <br><br>  Sekarang pengendali rumah pintar sedang menjalani operasi uji coba di beberapa fasilitas di Moskow dan wilayah Moskow. <br><br>  Versi pengendali berikutnya berencana untuk menghubungkan jenis perangkat lain (RF, Bluetooth, WiFi, berkabel).  Untuk kenyamanan pengguna, prosedur untuk menghubungkan sensor dan kamera IP akan ditransfer ke aplikasi mobile.  Ada juga ide-ide untuk mengoptimalkan kode proses server dan porting perangkat lunak ke sistem operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenWrt</a> .  Ini akan menghemat pengontrol terpisah dan mentransfer fungsionalitas rumah pintar ke router rumah tangga biasa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467219/">https://habr.com/ru/post/id467219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467203/index.html">Hanya divisi, atau cara membuat teori matematika dan dapatkan $ 400K di atasnya. Seri dua, kedua dari belakang</a></li>
<li><a href="../id467205/index.html">Kami mengembangkan aplikasi yang mengirim data ke aplikasi lain (aplikasi ekosistem)</a></li>
<li><a href="../id467207/index.html">Lima bahasa pemrograman yang menjanjikan dengan masa depan yang cerah (3 tahun kemudian)</a></li>
<li><a href="../id467209/index.html">"Agen Otonomi" atau jalankan kode di Obyektif cryptoplatform terbuka</a></li>
<li><a href="../id467215/index.html">22 Museum Komputer: Panduan untuk Insinyur Bepergian di Eropa</a></li>
<li><a href="../id467223/index.html">Selamat datang di JavaScript Meetup SuperJob 10 Oktober</a></li>
<li><a href="../id467227/index.html">Cara membuka paket npm dengan penyebaran normal, CI, dan demo (tanpa kehilangan kesenangan dalam hidup)</a></li>
<li><a href="../id467231/index.html">Memperkenalkan Masuk dengan Apple di aplikasi iOS Anda</a></li>
<li><a href="../id467237/index.html">Naikkan server DNS-over-HTTPS Anda</a></li>
<li><a href="../id467239/index.html">Perbedaan antara Data Scientist dan seorang remaja dalam mobil sport</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>