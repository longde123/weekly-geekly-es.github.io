<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥂 💛 🕡 Podman e Buildah para usuários do Docker 🌽 🚲 ☝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Embora existam muitos blogs e tutoriais bons sobre Podman e Buildah, os usuários do Docker claramente não possuem explicações claras e concisas sobre ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Podman e Buildah para usuários do Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/467105/">  Embora existam muitos blogs e tutoriais bons sobre Podman e Buildah, os usuários do Docker claramente não possuem explicações claras e concisas sobre como eles mudam para o Podman, por que o Buildah é necessário em outros problemas desse tipo. <br><br><img src="https://habrastorage.org/webt/m9/de/um/m9deumkiupstpwlpynelflvucxo.png" width="100%"><br><br>  Vamos tentar responder a essas perguntas e explicar como migrar perfeitamente do Docker para o Podman. <br><a name="habracut"></a><br><h3>  Como o Docker funciona </h3><br>  Vamos começar esclarecendo como o Docker funciona para entender por que o Podman e o Buildah surgiram.  Como você sabe, os comandos do Docker funcionam apenas quando o processo do daemon do Docker está em execução.  A idéia com o demônio, ao que parece, era coletar em um só lugar todas as coisas legais que o Docker faz e, ao mesmo tempo, organizar APIs úteis para trabalhar com ele no futuro.  Conforme mostrado na figura abaixo, o daemon do Docker contém toda a funcionalidade necessária para executar as seguintes tarefas: <br><br><ul><li>  Operações de puxar e empurrar ao trabalhar com o registro de imagens; </li><li>  Criando cópias de imagens no armazenamento local do contêiner e adicionando camadas a esses contêineres; </li><li>  Confirmar alterações em contêineres e remover imagens de contêiner do repositório local no host; </li><li>  Solicite ao kernel do SO que inicie o contêiner no espaço de nomes correspondente, cgroup etc. </li></ul><br>  Em essência, o daemon do Docker cuida de todo o trabalho com registros, imagens, contêineres e kernel.  E você apenas diz a ele o que fazer através da interface da linha de comandos (CLI). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ot/n9/rpotn9q5ovfti-d-jv2m7yyhbta.png"></div><br><br>  Aqui não consideraremos os prós e os contras dessa abordagem, quando tudo estiver reunido em um processo demoníaco.  Muitos argumentos podem ser feitos a seu favor e, no momento do surgimento de Docker, fazia todo o sentido.  No entanto, com o uso ativo do Docker, começaram a surgir perguntas para ele, por exemplo: <br><br><ul><li>  Um único processo significa um único ponto de falha; </li><li>  O processo daemon possui todos os processos filhos (executando contêineres); </li><li>  Quando o demônio parte, os processos filhos permanecem órfãos; </li><li>  A montagem do contêiner possui falhas de segurança; </li><li>  Para executar qualquer operação do Docker, os usuários precisam de privilégios de root completos. </li></ul><br>  Houve outras queixas.  Pode-se não concordar com isso ou dizer que essas deficiências já foram eliminadas, mas não vamos discutir.  Os desenvolvedores do Podman acreditam que conseguiram resolver muitos desses problemas e, se você quiser tirar proveito do Podman, este artigo é para você. <br><br>  A essência do Podman é interagir com o registro de imagens, com contêineres e armazenamento de imagens, bem como com o kernel Linux, não através de um daemon, mas diretamente através do processo runC, responsável pelo lançamento de contêineres. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bf/a8/xo/bfa8xofe89azm6tc_bx71brzhcs.png"></div><br><br>  Agora que descobrimos parcialmente os motivos dos desenvolvedores do Podman, é hora de discutir o que a transição para o Podman significa para o usuário.  E aqui precisamos entender e esclarecer (o faremos abaixo) o seguinte: <br><br><ul><li>  Podman substitui o Docker.  Ao mesmo tempo, não é mais necessário iniciar algum tipo de processo de daemon, como o daemon do Docker; </li><li>  Os comandos familiares do Docker funcionam da mesma maneira em Podman; </li><li>  Podman não armazena contêineres e imagens no mesmo local que o Docker; </li><li>  As imagens Podman e Docker são compatíveis; </li><li>  Nos ambientes Kubernetes, o Podman é capaz de mais do que o Docker; </li><li>  E também vamos analisar o que é Buildah e por que é necessário. </li></ul><br><h3>  Instalação Podman </h3><br>  Se você usa o Docker, pode removê-lo quando decidir fazer uma troca.  No entanto, você pode deixar o Docker enquanto tenta o Podman.  Existem algumas <a href="">lições</a> úteis e ótimas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstrações</a> que podem ser úteis para ler e ver para iniciantes, para que você possa entender melhor o processo de transição.  Um exemplo na demonstração requer que o Docker mostre compatibilidade. <br><br>  Para instalar o Podman no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat Enterprise Linux</a> 7.6 ou posterior, use o seguinte;  se você estiver usando o Fedora, substitua o yum pelo dnf: <br><br><pre><code class="plaintext hljs"># yum -y install podman</code> </pre> <br><h3>  Podman usa os mesmos comandos que o Docker </h3><br>  O Podman foi projetado para facilitar a troca do Docker.  Portanto, todas as equipes que você conhece do Docker trabalham da mesma maneira no Podman.  Além disso, argumenta-se que os scripts de chamada do Docker devem funcionar bem se você criar o alias apropriado, como este: alias docker = podman - apenas tente.  Obviamente, antes disso, é necessário parar o Docker (systemctl stop docker).  Além disso, você pode instalar o pacote podman-docker, que fará todas as conversões necessárias para você.  Ele simplesmente coloca um script em / usr / bin / docker que executa o Podman com os mesmos argumentos que o Docker usa. <br><br>  Os comandos habituais do Docker, como pull, push, build, run, commit, tag, etc., estão todos no Podman.  Consulte o manual do Podman para obter mais informações.  Uma diferença importante é que no Podman algumas equipes adicionaram sinalizadores de conveniência, por exemplo, os sinalizadores --all (-a) para os comandos podman rm e podman rmi, que muitos acharão muito úteis. <br><br>  Além disso, o Podman pode ser executado como um usuário comum, sem privilégios de root.  É verdade que até agora isso só funciona no Fedora e no Podman 1.0, e no RHEL deve aparecer a partir das versões 7.7 e 8.1.  Isso foi possível graças a melhorias na proteção do espaço do usuário.  A execução como usuário comum significa que, por padrão, o Podman armazena imagens e contêineres no diretório inicial do usuário, discutiremos isso com mais detalhes na próxima seção.  Para saber mais sobre como executar o Podman sem privilégios de root, consulte o artigo de Dan Walsh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como funciona o Podman sem root?</a>  . <br><br><h3>  Imagens de Podman e contêiner </h3><br>  Quando você insere o comando podman images pela primeira vez, é provável que desanime, pois não verá nenhuma imagem do Docker que já tenha sido baixada no computador antes.  O fato é que o repositório local do Podman está localizado na pasta / var / lib / containers, e não no diretório / var / lib / docker.  Isso foi feito não apenas assim, mas como parte de uma nova estrutura de armazenamento que atende aos padrões da OCI (Open Containers Initiative). <br><br>  Em 2015, Docker, Red Hat, CoreOS, SUSE, Google e outros criadores de tendências de contêineres Linux criaram a Open Container Initiative, um órgão independente para gerenciar a especificação de padrões para o formato de imagens de contêineres e seu tempo de execução.  Como parte do OCI, projetos de containers / imagem e containers / armazenamento foram criados no GitHub. <br><br>  Como o Podman pode ser executado sem privilégios de root, ele precisa de um local separado para gravar imagens.  Portanto, o repositório Podman está localizado no diretório inicial do usuário ~ / .local / share / containers.  Isso ajuda a evitar uma situação em que eles possam escrever tudo em / var / lib / containers e em relação a outras práticas perigosas do ponto de vista da segurança.  Além disso, agora cada usuário possui seu próprio conjunto separado de contêineres, para que vários usuários possam trabalhar simultaneamente no host ao mesmo tempo.  Após concluir o trabalho, os usuários podem enviar por push ao registro geral para disponibilizar suas imagens para outras pessoas. <br><br>  Ao alternar do Docker para o Podman, conhecer os novos caminhos de localização do contêiner será útil durante a depuração, bem como quando você deseja limpar o repositório local com o comando rm -rf / var / lib / containers para iniciar tudo de novo.  No entanto, ao mudar para Podman, você provavelmente começará a usar a nova opção -all para os comandos podman rm e podman rmi, em vez deste comando. <br><br><h3>  Compatibilidade de contêiner entre Podman e outros tempos de execução </h3><br>  Apesar dos diferentes locais dos repositórios locais, o Docker e o Podman criam imagens de contêiner compatíveis com o padrão OCI.  O Podman pode usar registros populares de contêineres, como o Quay.io ou o Docker Hub, bem como registros particulares nas duas direções (empurrar e puxar).  Por exemplo, com o Podman, você pode baixar e executar a imagem mais recente do Fedora no Docker Hub.  Se você não especificar um registro, o Podman, por padrão, pesquisará os registros listados no arquivo registries.conf, seguindo a ordem especificada neste arquivo.  Inicialmente, o primeiro deste arquivo é o registro do Docker Hub. <br><br><pre> <code class="plaintext hljs">$ podman pull fedora:latest $ podman run -it fedora bash</code> </pre><br>  As imagens carregadas no registro usando o Docker podem ser baixadas e executadas usando o Podman.  Por exemplo, se criamos uma imagem do myfedora usando o Docker e a carregamos no nosso repositório Quay.io (ipbabble), você pode baixá-la usando o Podman, veja como: <br><br><pre> <code class="plaintext hljs">$ podman pull quay.io/ipbabble/myfedora:latest $ podman run -it myfedora bash</code> </pre><br>  O Podman permite mover imagens de maneira fácil e elegante entre os diretórios / var / lib / docker e / var / lib / containers usando os comandos push e pull, por exemplo: <br><br><pre> <code class="plaintext hljs">$ podman push myfedora docker-daemon:myfedora:latest</code> </pre><br>  É claro que, se você omitir o docker-daemon neste exemplo, o envio por envio será direcionado ao Docker Hub.  Se você especificar quay.io/myquayid/myfedora, a imagem será carregada no registro Quay.io (aqui myquayid é o nome da nossa conta no Quay.io): <br><br><pre> <code class="plaintext hljs">$ podman push myfedora quay.io/myquayid/myfedora:latest</code> </pre><br>  Se você decidir que está pronto para abandonar o Docker, para desinstalá-lo, simplesmente desligue o daemon e remova o pacote do Docker usando o gerenciador de pacotes.  Porém, antes disso, baixe todas as imagens necessárias usando o Docker para o registro externo (não local), para que você possa baixá-las posteriormente.  Ou você pode usar o Podman para baixá-los do repositório local Docker para o repositório local Podman OCI.  Por exemplo, no RHEL, a transferência de uma imagem do fedora é feita assim: <br><br><pre> <code class="plaintext hljs"># systemctl stop docker # podman pull docker-daemon:fedora:latest # yum -y remove docker # optional</code> </pre><br><h3>  Podman facilita a mudança para o Kubernetes </h3><br>  O Podman oferece vários recursos adicionais - comparados ao Docker - que são úteis para desenvolvedores e operadores de TI ao trabalhar com o Kubernetes, em particular, comandos úteis que o Docker simplesmente não possui.  Se você conhece o Docker e pensa em mudar para o Kubernetes / OpenShift como uma plataforma de contêiner, o Podman será útil. <br><br>  O Podman pode gerar um arquivo YAML do Kubernetes com base em um contêiner em execução usando o comando podman generate kube.  E ao depurar pods em execução, além dos comandos padrão para trabalhar com contêineres, você também pode usar o comando podman pod.  Para obter mais informações sobre como o Podman ajuda a mudar para o Kubernetes, consulte o artigo de Brent Baude, Podman agora pode facilitar a transição para o Kubernetes e o CRI-O. <br><br><h3>  Buildah - o que é e por quê </h3><br>  Buildah apareceu antes de Podman.  E isso às vezes desencoraja os usuários do Docker: “Por que os apologistas do Podman estão subitamente falando sobre o Buildah?  Podman não sabe construir? " <br><br>  Nós nos apressamos em tranquilizar, Podman pode, e faz exatamente como Docker.  Ou seja, a montagem pode ser executada usando o Dockerfile e o comando podman build, ou você pode iniciar o contêiner, fazer as alterações necessárias e depois confirmar (executar confirmação), criando uma nova tag na imagem do contêiner.  Em nossa interpretação, o Buildah é um conjunto estendido de comandos para criar e gerenciar imagens de contêiner e, portanto, fornece um controle muito mais preciso ao trabalhar com imagens.  O comando de construção do Podman contém parcialmente a funcionalidade Buildah e usa o mesmo código de programa para a construção que o próprio Buildah. <br><br>  A maneira mais eficiente de usar o Buildah é escrever scripts Bash para criar imagens, da mesma forma que você escreve para um Dockerfile. <br><br>  Quanto à cronologia do aparecimento de Buildah e Podman, os eventos ocorreram aproximadamente da seguinte maneira.  Quando o Kubernetes aprendeu a trabalhar com o CRI-O com base no padrão OCI para tempos de execução de contêiner, o daemon do Docker não era mais necessário.  Ou seja, não era mais necessário instalar o Docker em todos os nós do cluster Kubernetes para executar pods e contêineres nele.  Agora, o Kubernetes pode chamar o CRI-O e esse pode executar o RunC diretamente, o que, por sua vez, inicia os processos do contêiner.  No entanto, se ao mesmo tempo desejarmos usar o mesmo cluster Kubernetes não apenas para o lançamento, mas também para a montagem de contêineres (como, por exemplo, no OpenShift), precisaremos de uma nova ferramenta de construção que não dependa do daemon do Docker e , como resultado, não exigiria a instalação do Docker.  Além disso, essa ferramenta, criada com base nos projetos de contêineres / armazenamento e contêineres / imagem, eliminaria os riscos de segurança associados ao soquete aberto do daemon Docker durante a montagem, e muitos usuários do Docker estão preocupados com esses riscos. <br><br>  E a Buildah se tornou uma ferramenta tão nova (o nome se lê como “build” e imita o sotaque de Boston do gerente de projetos Dan Walsh ao pronunciar a palavra “builder”).  Mais informações sobre o Buildah podem ser encontradas em buildah.io, além de blogs e guias de links no final deste artigo. <br><br>  Há mais alguns detalhes para saber se você deseja usar o Buildah: <br><br><ol><li>  Ele fornece controle mais preciso ao criar camadas de imagem.  Em particular, ele permite que você faça o que muitos usuários de contêiner desejam há muito tempo - confirme muitas alterações de uma só vez com apenas uma camada. </li><li>  A corrida de Buildah e a corrida de Podman são duas coisas diferentes.  Como o Buildah foi projetado para criar imagens, seu comando de execução é essencialmente o mesmo que o comando RUN no Dockerfile.  William Henry, um dos desenvolvedores do Buildah, lembra como essa solução surgiu: “De alguma forma, eu estava reclamando que alguma porta ou montagem não funcionava como eu esperava.  Dan Walsh (@rhatdan) pesou tudo e disse que a Buildah não deveria trabalhar com contêineres dessa maneira.  Tudo, sem mais mapeamentos de portas e sem volumes de montagem.  Removemos esses sinalizadores e, em vez disso, usamos buildah run para executar os comandos necessários ao criar imagens de contêiner, por exemplo, buildah run dnf -y install nginx. " </li><li>  O Buildah pode criar imagens do zero (imagens do zero).  Ou seja, imagens nas quais não há nada, literalmente.  De fato, se você observar o armazenamento do contêiner criado como resultado do comando buildah from scratch, haverá um diretório vazio.  Isso é muito útil do ponto de vista da criação de imagens super leves, contendo apenas os pacotes necessários para executar o aplicativo. </li></ol><br>  Por que construir do zero?  Vamos comparar a imagem de desenvolvimento de um aplicativo Java com sua imagem para um ambiente de produção ou para um ambiente intermediário.  No estágio de desenvolvimento, a imagem pode conter o compilador Java, Maven e outras ferramentas necessárias ao desenvolvedor.  Porém, ao traduzir para produção, apenas o Java Runtime e seus pacotes devem permanecer na imagem.  A propósito, para remover o supérfluo, você não precisa de um gerenciador de pacotes, como DNF / YUM, nem precisa do Bash - você pode fazer tudo através da interface da Buildah CLI, como mostra a figura abaixo, onde o contêiner tradicional de múltiplas camadas fica à esquerda e a única camada à direita imagem arranhada.  Consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando uma imagem de contêiner</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buildah</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstração de introdução do Kubernetes</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buildah</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">obter</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">detalhes</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/kd/w5/qqkdw5dmlj4c5fuyxsi7chc1pew.png"></div><br><br>  Voltando à cronologia.  Então, o Kubernetes aprendeu a trabalhar com o CRI-O e o runC, e para a construção que empilhamos o Buildah - tudo, desde o Docker no host do Kubernetes, você pode recusar?  Não, a depuração ainda permanece.  Como resolver problemas com contêineres se o host não possui as ferramentas apropriadas?  Não coloque Docker nele, caso contrário, voltaremos ao demônio e todos os esforços foram em vão.  E então Podman entra em cena. <br><br>  Ou seja, Podman resolve dois problemas ao mesmo tempo.  Primeiro, permite que os operadores de TI inspecionem contêineres e imagens usando comandos familiares.  E segundo, ele fornece essas mesmas ferramentas para os desenvolvedores.  Como resultado, todos os usuários do Docker - desenvolvedores e operadores - podem mudar para Podman e executar calmamente as tarefas para as quais usavam o Docker anteriormente, além de resolver uma série de novas tarefas. <br><br><h3>  Recursos necessários: </h3><br><ul><li>  Site para os projetos Podman.io e Buildah.io. </li><li>  Projetos em github.com/containers (conecte-se, estude a fonte e veja o que está em desenvolvimento: <br><ul><li>  libpod (Podman); </li><li>  buildah; </li><li>  image (código para trabalhar com imagens OCI de contêiner); </li><li>  armazenamento (código para armazenamento local de imagens de contêiner). </li></ul><br></li></ul><br><h3>  Links úteis: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recipientes sem daemons: Podman e Buildah disponíveis no RHEL 7.6 e RHEL 8 Beta</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Podman: gerenciando pods e contêineres em um tempo de execução de contêiner local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciando serviços do sistema em contêiner com o Podman (Gerenciando contêineres do podman usando o systemd)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Construindo uma imagem de contêiner Buildah para o Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Podman agora pode facilitar a transição para Kubernetes e CRI-O</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Considerações de segurança para tempos de execução de contêiner (gravação de vídeo do desempenho de Dan Walsh no KubeCon 2018)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento e implantação de borda da IoT com contêineres através do OpenShift: Parte 1 (Montagem e teste de contêineres ARM64 na plataforma OpenShift usando sing podman, qemu, binfmt_misc e Ansible)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467105/">https://habr.com/ru/post/pt467105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467093/index.html">Espionando seus programas com Strace</a></li>
<li><a href="../pt467095/index.html">Mais fácil do que parece. 20</a></li>
<li><a href="../pt467097/index.html">Usando a biblioteca de paginação com o Realm</a></li>
<li><a href="../pt467099/index.html">Hapi para os mais pequenos</a></li>
<li><a href="../pt467101/index.html">O épico de criar um robô com o cheiro de um cachorro</a></li>
<li><a href="../pt467107/index.html">Como executar vários pipelines usando o GitLab CI / CD</a></li>
<li><a href="../pt467109/index.html">Como o controle de qualidade organiza a automação de teste em um projeto. Uma maneira prática</a></li>
<li><a href="../pt467111/index.html">Dicas radicais sobre como pendurar menos no telefone</a></li>
<li><a href="../pt467113/index.html">Como manter o usuário no site? Segredos de usabilidade</a></li>
<li><a href="../pt467115/index.html">"Ls" atípicos - Edição Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>