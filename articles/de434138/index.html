<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚öñÔ∏è ü§Ω üë®üèΩ‚Äç‚úàÔ∏è Wir schreiben unsere eigene virtuelle Maschine ‚õ∑Ô∏è üè• ‚úã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Tutorial zeige ich Ihnen, wie Sie Ihre eigene virtuelle Maschine (VM) schreiben, auf der Assembler-Programme wie 2048 (mein Freund) oder Rog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben unsere eigene virtuelle Maschine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/"> In diesem Tutorial zeige ich Ihnen, wie Sie Ihre eigene virtuelle Maschine (VM) schreiben, auf der Assembler-Programme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2048</a> (mein Freund) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roguelike</a> (meine) ausgef√ºhrt werden k√∂nnen.  Wenn Sie programmieren k√∂nnen, aber besser verstehen m√∂chten, was im Computer geschieht und wie Programmiersprachen funktionieren, ist dieses Projekt genau das Richtige f√ºr Sie.  Das Schreiben einer eigenen virtuellen Maschine mag etwas be√§ngstigend erscheinen, aber ich verspreche, dass das Thema √ºberraschend einfach und lehrreich ist. <br><br>  <a href="">Der endg√ºltige Code</a> besteht aus ungef√§hr 250 Zeilen in C. Es reicht aus, nur die Grundlagen von C oder C ++ zu kennen, z. B. die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bin√§re Arithmetik</a> .  Jedes Unix-System (einschlie√ülich macOS) eignet sich zum Erstellen und Ausf√ºhren.  Zum Konfigurieren der Konsoleneingabe und -anzeige werden mehrere Unix-APIs verwendet, die jedoch f√ºr den Hauptcode nicht unbedingt erforderlich sind.  (Die Implementierung der Windows-Unterst√ºtzung wird gesch√§tzt). <br><br><blockquote>  <b>Hinweis:</b> Diese VM ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompetentes Programm</a> .  Das hei√üt, Sie lesen gerade den Quellcode!  Jeder Code wird detailliert angezeigt und erkl√§rt, sodass Sie sicher sein k√∂nnen, dass nichts fehlt.  Der endg√ºltige Code wird durch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plexus</a> von Codebl√∂cken erstellt.  Projekt-Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Inhalt </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhaltsverzeichnis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architektur LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler-Beispiele</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmausf√ºhrung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umsetzung von Anweisungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung Spickzettel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verarbeitungsverfahren unterbrechen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spickzettel f√ºr Interrupt-Routinen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software herunterladen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherabgebildete Register</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattformfunktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Start der virtuellen Maschine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alternative Methode in C ++</a> </li></ol><br><a name="2"></a><h1>  2. Einf√ºhrung </h1><br><h3>  Was ist eine virtuelle Maschine? </h3><br>  Eine virtuelle Maschine ist ein Programm, das sich wie ein Computer verh√§lt.  Es simuliert einen Prozessor mit mehreren anderen Hardwarekomponenten, sodass Sie rechnen, aus dem Speicher lesen und in den Speicher schreiben und mit Eingabe- / Ausgabeger√§ten wie einem echten physischen Computer interagieren k√∂nnen.  Am wichtigsten ist, dass VM eine Maschinensprache versteht, die Sie zum Programmieren verwenden k√∂nnen. <br><br>  Wie viel Hardware eine bestimmte VM simuliert, h√§ngt von ihrem Zweck ab.  Einige VMs reproduzieren das Verhalten eines bestimmten Computers.  Die Leute haben kein NES mehr, aber wir k√∂nnen trotzdem Spiele f√ºr NES spielen, indem wir Hardware auf Software-Ebene simulieren.  Diese Emulatoren m√ºssen jedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Detail</a> und jede wichtige Hardwarekomponente des Originalger√§ts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">genau nachbilden</a> . <br><br>  Andere VMs entsprechen keinem bestimmten Computer, sondern teilweise mehreren gleichzeitig!  Dies geschieht haupts√§chlich, um die Softwareentwicklung zu erleichtern.  Stellen Sie sich vor, Sie m√∂chten ein Programm erstellen, das auf mehreren Computerarchitekturen ausgef√ºhrt wird.  Die virtuelle Maschine bietet eine Standardplattform, die Portabilit√§t bietet.  Es ist nicht erforderlich, das Programm f√ºr jede Architektur in verschiedenen Assembler-Dialekten neu zu schreiben.  Es reicht aus, nur eine kleine VM in jeder Sprache zu erstellen.  Danach kann jedes Programm nur noch einmal in der Assemblersprache einer virtuellen Maschine geschrieben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Hinweis: Der</b> Compiler l√∂st solche Probleme, indem er eine Standard <i>-Hochsprache</i> f√ºr verschiedene Prozessorarchitekturen kompiliert.  VM erstellt eine Standard- <i>CPU-Architektur</i> , die auf verschiedenen Hardwareger√§ten simuliert wird.  Einer der Vorteile des Compilers besteht darin, dass es keinen Laufzeit-Overhead wie bei VM gibt.  Obwohl Compiler gut funktionieren, ist das Schreiben eines neuen Compilers f√ºr mehrere Plattformen sehr schwierig, sodass VMs weiterhin n√ºtzlich sind.  In der Realit√§t werden auf verschiedenen Ebenen sowohl VM als auch Compiler zusammen verwendet. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Java Virtual Machine (JVM)</a> ist ein sehr erfolgreiches Beispiel.  Die JVM selbst ist relativ mittelgro√ü und klein genug, damit ein Programmierer sie verstehen kann.  Auf diese Weise k√∂nnen Sie Code f√ºr Tausende verschiedener Ger√§te, einschlie√ülich Telefone, schreiben.  Nach der Implementierung der JVM auf dem neuen Ger√§t kann jedes geschriebene Java-, Kotlin- oder Clojure-Programm ohne √Ñnderungen daran arbeiten.  Die einzigen Kosten sind nur der Overhead f√ºr die VM selbst und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere Abstraktion</a> von der Maschinenebene.  Dies ist normalerweise ein ziemlich guter Kompromiss. <br><br>  Eine VM muss nicht gro√ü oder allgegenw√§rtig sein, um √§hnliche Vorteile zu erzielen.  √Ñltere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videospiele verwendeten</a> h√§ufig kleine VMs, um einfache Skriptsysteme zu erstellen. <br><br>  VMs sind auch n√ºtzlich, um Programme sicher zu isolieren.  Eine Anwendung ist die Speicherbereinigung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt keine einfache M√∂glichkeit,</a> die automatische Speicherbereinigung √ºber C oder C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> implementieren, da das Programm keinen eigenen Stapel oder keine eigenen Variablen sehen kann.  Die VM befindet sich jedoch au√üerhalb des laufenden Programms und kann alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verweise auf Speicherzellen</a> auf dem Stapel beobachten. <br><br>  Ein weiteres Beispiel f√ºr dieses Verhalten sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intelligente Vertr√§ge</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> .  Intelligente Vertr√§ge sind kleine Programme, die von jedem Validierungsknoten in der Blockchain ausgef√ºhrt werden.  Das hei√üt, die Bediener erlauben die Ausf√ºhrung von Programmen, die von v√∂llig Fremden geschrieben wurden, auf ihren Maschinen, ohne die M√∂glichkeit zu haben, sie im Voraus zu studieren.  Um b√∂swillige Aktionen zu verhindern, werden sie auf einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VM ausgef√ºhrt</a> , die keinen Zugriff auf das Dateisystem, das Netzwerk, die Festplatte usw. hat.  Ethereum ist auch ein gutes Beispiel f√ºr Portabilit√§t.  Dank VM k√∂nnen Sie intelligente Vertr√§ge abschlie√üen, ohne die Funktionen vieler Plattformen zu ber√ºcksichtigen. <br><br><a name="3"></a><h1>  3. Architektur LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  Unsere VM simuliert einen fiktiven Computer namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LC-3</a> .  Es ist beliebt f√ºr das Unterrichten von Studenten Assembler.  Hier ein im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich zu x86</a> vereinfachter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehlssatz</a> , der jedoch alle grundlegenden Konzepte beibeh√§lt, die in modernen CPUs verwendet werden. <br><br>  Zun√§chst m√ºssen Sie die erforderlichen Hardwarekomponenten simulieren.  Versuchen Sie zu verstehen, was jede Komponente ist, aber machen Sie sich keine Sorgen, wenn Sie nicht sicher sind, wie sie in das Gesamtbild passt.  Beginnen wir mit der Erstellung einer Datei in C. Jeder Code aus diesem Abschnitt sollte in den globalen Bereich dieser Datei eingef√ºgt werden. <br><br><h3>  Die Erinnerung </h3><br>  Der LC-3 verf√ºgt √ºber 65.536 Speicherzellen (2 <sup>16</sup> ), von denen jede einen 16-Bit-Wert enth√§lt.  Dies bedeutet, dass nur 128 KB gespeichert werden k√∂nnen - viel weniger als Sie es gewohnt sind!  In unserem Programm ist dieser Speicher in einem einfachen Array gespeichert: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Register </h3><br>  Ein Register ist ein Steckplatz zum Speichern eines Wertes in der CPU.  Register sind wie eine CPU-Workbench.  Damit es mit einigen Daten arbeiten kann, muss es sich in einem der Register befinden.  Da es jedoch nur wenige Register gibt, kann zu einem bestimmten Zeitpunkt nur eine minimale Datenmenge heruntergeladen werden.  Programme umgehen dieses Problem, indem sie Werte aus dem Speicher in Register laden, Werte in andere Register berechnen und dann die Endergebnisse wieder im Speicher speichern. <br><br>  Es gibt nur 10 Register im LC-3 mit jeweils 16 Bit.  Die meisten von ihnen sind universell einsetzbar, aber einigen sind Rollen zugewiesen. <br><br><ul><li>  8 Allzweckregister ( <code>R0-R7</code> ) </li><li>  1 Register des Teamz√§hlers ( <code>PC</code> ) </li><li>  1 Bedingungsflagregister ( <code>COND</code> ) </li></ul><br>  Allzweckregister k√∂nnen verwendet werden, um beliebige Softwareberechnungen durchzuf√ºhren.  Der Befehlsz√§hler ist eine vorzeichenlose Ganzzahl, die die Speicheradresse des n√§chsten auszuf√ºhrenden Befehls ist.  Bedingungsflags geben Auskunft √ºber die vorherige Berechnung. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Wie der Speicher werden wir die Register in einem Array speichern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Befehlssatz </h3><br>  Eine Anweisung ist ein Befehl, der den Prozessor anweist, eine grundlegende Aufgabe auszuf√ºhren, z. B. zwei Zahlen hinzuzuf√ºgen.  Der Befehl enth√§lt einen <b>Opcode</b> (Operationscode), der den Typ der auszuf√ºhrenden Aufgabe angibt, sowie einen Satz von <b>Parametern</b> , die Eingaben f√ºr die auszuf√ºhrende Aufgabe liefern. <br><br>  Jeder <b>Opcode</b> stellt eine Aufgabe dar, die der Prozessor ‚Äûausf√ºhren‚Äú kann.  Es gibt 16 Opcodes in LC-3.  Ein Computer kann nur die Reihenfolge dieser einfachen Anweisungen berechnen.  Die L√§nge jedes Befehls betr√§gt 16 Bit, und die linken 4 Bit speichern den Operationscode.  Der Rest wird zum Speichern von Parametern verwendet. <br><br>  Sp√§ter werden wir detailliert besprechen, was jede Anweisung tut.  Definieren Sie momentan die folgenden Opcodes.  Stellen Sie sicher, dass Sie diese Reihenfolge einhalten, um den richtigen Aufz√§hlungswert zu erhalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Hinweis:</b> In der Intel x86-Architektur gibt es Hunderte von Anweisungen, w√§hrend es in anderen Architekturen wie ARM und LC-3 nur sehr wenige gibt.  Kleine Befehlss√§tze werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RISC bezeichnet</a> , w√§hrend gr√∂√üere als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CISC bezeichnet werden</a> .  Gro√üe Befehlss√§tze bieten in der Regel keine grundlegend neuen Funktionen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vereinfachen</a> jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">h√§ufig das Schreiben von Assembler-Code</a> .  Ein CISC-Befehl kann mehrere RISC-Befehle ersetzen.  CISC-Prozessoren sind jedoch komplexer und teurer in Design und Herstellung.  Dieser und andere Kompromisse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erlauben es nicht, das ‚Äûoptimale‚Äú Design zu nennen</a> . </blockquote><br><h3>  Bedingungsflags </h3><br>  Das Register <code>R_COND</code> speichert Bedingungsflags, die Informationen √ºber die zuletzt durchgef√ºhrte Berechnung liefern.  Auf diese Weise k√∂nnen Programme logische Bedingungen √ºberpr√ºfen, z. B. <code>if (x &gt; 0) { ... }</code> . <br><br>  Jeder Prozessor verf√ºgt √ºber viele Statusflags, um verschiedene Situationen zu signalisieren.  Der LC-3 verwendet nur drei Bedingungsflags, die das Vorzeichen der vorherigen Berechnung anzeigen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Hinweis:</b> (Das Zeichen <code>&lt;&lt;</code> wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linksverschiebungsoperator bezeichnet</a> . <code>(n &lt;&lt; k)</code> verschiebt die Bits <code>n</code> um <code>k</code> Stellen <code>n</code> links. Somit ist <code>1 &lt;&lt; 2</code> gleich <code>4</code> Lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier,</a> wenn Sie mit dem Konzept nicht vertraut sind. Dies ist sehr wichtig.) </blockquote><br>  Wir haben die Konfiguration der Hardwarekomponenten unserer virtuellen Maschine abgeschlossen!  Nach dem Hinzuf√ºgen von Standardeinschl√ºssen (siehe Link oben) sollte Ihre Datei ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Hier finden Sie Links zu nummerierten Abschnitten des Artikels, aus denen die entsprechenden Codefragmente stammen.</font>  <font color="gray">Eine vollst√§ndige Auflistung finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeitsprogramm</a> - ca.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Assembler-Beispiele </h1><br>  Schauen wir uns nun das LC-3-Assembler-Programm an, um eine Vorstellung davon zu bekommen, was die virtuelle Maschine tats√§chlich tut.  Sie m√ºssen nicht wissen, wie man in Assembler programmiert, oder hier alles verstehen.  Versuchen Sie einfach, eine allgemeine Vorstellung davon zu bekommen, was los ist.  Hier ist eine einfache "Hallo Welt": <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Wie in C f√ºhrt das Programm eine Anweisung von oben nach unten aus.  Im Gegensatz zu C gibt es jedoch keine verschachtelten Bereiche <code>{}</code> oder Kontrollstrukturen wie <code>if</code> oder <code>while</code> .  nur eine einfache Liste von Operatoren.  Daher ist es viel einfacher durchzuf√ºhren. <br><br>  Bitte beachten Sie, dass die Namen einiger Operatoren den zuvor definierten Opcodes entsprechen.  Wir wissen, dass die Anweisungen 16 Bit sind, aber jede Zeile sieht aus, als h√§tte sie eine andere Anzahl von Zeichen.  Wie ist eine solche Nicht√ºbereinstimmung m√∂glich? <br><br>  Dies liegt daran, dass der Code, den wir lesen, in <b>Assemblersprache geschrieben ist</b> - in Klartext, lesbar und beschreibbar.  Ein Tool, <b>Assembler genannt</b> , konvertiert jede Textzeile in eine 16-Bit-Bin√§ranweisung, die eine virtuelle Maschine versteht.  Diese bin√§re Form, bei der es sich im Wesentlichen um ein Array von 16-Bit-Anweisungen handelt, wird als <b>Maschinencode bezeichnet</b> und tats√§chlich von einer virtuellen Maschine ausgef√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Hinweis:</b> Obwohl Compiler und Assembler bei der Entwicklung eine √§hnliche Rolle spielen, sind sie nicht identisch.  Der Assembler codiert einfach das, was der Programmierer im Text geschrieben hat, ersetzt die Zeichen durch ihre bin√§re Darstellung und packt sie in Anweisungen. </blockquote><br>  Die <code>.STRINGZ</code> <code>.ORIG</code> und <code>.STRINGZ</code> sehen aus wie Anweisungen, aber nein.  Dies sind Assembler-Anweisungen, die einen Teil des Codes oder der Daten generieren.  Beispielsweise f√ºgt <code>.STRINGZ</code> eine Zeichenfolge an einer bestimmten Stelle in ein Bin√§rprogramm ein. <br><br>  Schleifen und Bedingungen werden mit einer goto-√§hnlichen Anweisung ausgef√ºhrt.  Hier ist ein weiteres Beispiel, das bis 10 z√§hlt. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Hinweis: In</b> diesem Lernprogramm muss die Montage nicht gelernt werden.  Wenn Sie jedoch interessiert sind, k√∂nnen Sie mit den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LC-3-Tools</a> Ihre eigenen LC-3-Programme schreiben und erstellen. </blockquote><br><a name="5"></a><h1>  5. Programmausf√ºhrung </h1><br>  Noch einmal, die vorherigen Beispiele geben nur eine Vorstellung davon, was die VM tut.  Um eine VM zu schreiben, ben√∂tigen Sie kein vollst√§ndiges Verst√§ndnis des Assemblers.  Solange Sie das entsprechende Verfahren zum Lesen und Ausf√ºhren von Anweisungen befolgen, funktioniert <i>jedes</i> LC-3-Programm unabh√§ngig von seiner Komplexit√§t ordnungsgem√§√ü.  Theoretisch kann eine VM sogar einen Browser oder ein Betriebssystem wie Linux ausf√ºhren! <br><br>  Wenn Sie tief nachdenken, dann ist dies eine philosophisch wunderbare Idee.  Die Programme selbst k√∂nnen beliebig komplexe Aktionen erzeugen, die wir nie erwartet haben und die wir m√∂glicherweise nicht verstehen k√∂nnen.  Gleichzeitig beschr√§nkt sich ihre gesamte Funktionalit√§t auf einfachen Code, den wir schreiben werden!  Gleichzeitig wissen wir alles und nichts dar√ºber, wie jedes Programm funktioniert.  Turing erw√§hnte diese wunderbare Idee: <br><br><blockquote>  ‚ÄûDie Meinung, dass Maschinen einen Menschen mit nichts √ºberraschen k√∂nnen, basiert meines Erachtens auf einem Fehler, f√ºr den Mathematiker und Philosophen besonders anf√§llig sind.  Ich meine die Annahme, dass, da eine Tatsache Eigentum des Geistes geworden ist, sofort alle Konsequenzen dieser Tatsache Eigentum des Geistes werden. ‚Äú  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Vorgehensweise </h3><br>  Hier ist die genaue Beschreibung der zu schreibenden Prozedur: <br><br><ol><li>  Laden Sie eine Anweisung aus dem Speicher unter der Adresse des <code>PC</code> Registers herunter. </li><li>  <code>PC</code> Register erh√∂hen. </li><li>  Zeigen Sie den Opcode an, um zu bestimmen, welche Art von Anweisung befolgt werden soll. </li><li>  Befolgen Sie die Anweisungen anhand der Parameter. </li><li>  Kehren Sie zu Schritt 1 zur√ºck. </li></ol><br>  Sie k√∂nnen die Frage stellen: "Aber wenn die Schleife den Z√§hler ohne <code>if</code> oder <code>while</code> weiter erh√∂ht, werden die Anweisungen dann nicht enden?"  Die Antwort ist nein.  Wie bereits erw√§hnt, √§ndern einige goto-√§hnliche Anweisungen den Ausf√ºhrungsfluss, indem sie √ºber den <code>PC</code> springen. <br><br>  Wir beginnen die Untersuchung dieses Prozesses als Beispiel f√ºr den Hauptzyklus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Umsetzung der Anweisungen </h1><br>  Jetzt besteht Ihre Aufgabe darin, f√ºr jeden Opcode die richtige Implementierung vorzunehmen.  Eine detaillierte Spezifikation jeder Anweisung ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektdokumentation enthalten</a> .  Aus der Spezifikation m√ºssen Sie herausfinden, wie jede Anweisung funktioniert, und eine Implementierung schreiben.  Das ist einfacher als es klingt.  Hier werde ich zeigen, wie zwei davon implementiert werden.  Code f√ºr den Rest finden Sie im n√§chsten Abschnitt. <br><br><h3>  HINZUF√úGEN </h3><br>  Der <code>ADD</code> Befehl nimmt zwei Zahlen, addiert sie und speichert das Ergebnis in einem Register.  Die Spezifikation finden Sie in der Dokumentation auf Seite 526. Jede <code>ADD</code> Anweisung lautet wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Das Diagramm enth√§lt zwei Zeilen, da es f√ºr diese Anweisung zwei verschiedene ‚ÄûModi‚Äú gibt.  Bevor ich die Modi erkl√§re, versuchen wir, die √Ñhnlichkeiten zwischen ihnen zu finden.  Beide beginnen mit vier identischen Bits <code>0001</code> .  Dies ist der Opcode-Wert f√ºr <code>OP_ADD</code> .  Die n√§chsten drei Bits sind f√ºr das Ausgangsregister mit <code>DR</code> gekennzeichnet.  Das Ausgaberegister ist der Ort, an dem der Betrag gespeichert wird.  Die folgenden drei Bits sind: <code>SR1</code> .  Dies ist ein Register, das die erste hinzuzuf√ºgende Nummer enth√§lt. <br><br>  Somit wissen wir, wo das Ergebnis gespeichert werden soll, und wir kennen die erste hinzuzuf√ºgende Zahl.  Es bleibt nur die zweite Nummer f√ºr die Hinzuf√ºgung herauszufinden.  Hier beginnen sich die beiden Linien zu unterscheiden.  Beachten Sie, dass das 5. Bit oben 0 und unten 1 ist. Dieses Bit entspricht entweder dem <i>Direktmodus</i> oder dem <i>Registermodus</i> .  Im Registermodus wird die zweite Nummer wie die erste im Register gespeichert.  Es ist als <code>SR2</code> markiert und in den Bits zwei bis null enthalten.  Die Bits 3 und 4 werden nicht verwendet.  In Assembler wird es so geschrieben: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  Im Sofortmodus wird der Sofortwert in den Befehl selbst eingebettet, anstatt den Inhalt des Registers hinzuzuf√ºgen.  Dies ist praktisch, da das Programm keine zus√§tzlichen Anweisungen ben√∂tigt, um diese Nummer aus dem Speicher in das Register zu laden.  Stattdessen befindet es sich bereits in der Anweisung, wenn wir es brauchen.  Der Nachteil ist, dass dort nur kleine Zahlen gespeichert werden k√∂nnen.  Um genau zu sein, maximal 2 <sup>5</sup> = 32.  Dies ist am n√ºtzlichsten, um Z√§hler oder Werte zu erh√∂hen.  In Assembler k√∂nnen Sie wie folgt schreiben: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Hier ist ein Auszug aus der Spezifikation: <br><br><blockquote>  Wenn Bit [5] 0 ist, wird der zweite Quelloperand von SR2 erhalten.  Wenn Bit [5] 1 ist, wird der zweite Quelloperand durch Erweitern von imm5 auf 16 Bit erhalten.  In beiden F√§llen wird der zweite Quelloperand zum Inhalt von SR1 hinzugef√ºgt und das Ergebnis in DR gespeichert.  (S. 526) </blockquote><br>  Dies √§hnelt dem, was wir besprochen haben.  Aber was ist eine ‚ÄûErweiterung der Bedeutung‚Äú?  Obwohl der Wert im Direktmodus nur 5 Bit hat, muss er mit einer 16-Bit-Nummer hinzugef√ºgt werden.  Diese 5 Bits sollten auf 16 erweitert werden, um einer anderen Zahl zu entsprechen.  F√ºr positive Zahlen k√∂nnen wir die fehlenden Bits mit Nullen f√ºllen und den gleichen Wert erhalten.  Bei negativen Zahlen funktioniert dies jedoch nicht.  Zum Beispiel ist -1 in f√ºnf Bits <code>1 1111</code> .  Wenn Sie es nur mit Nullen f√ºllen, erhalten wir <code>0000 0000 0001 1111</code> , was 32 ist!  Das Erweitern des Werts verhindert dieses Problem, indem Bits mit Nullen f√ºr positive Zahlen und Einsen f√ºr negative Zahlen gef√ºllt werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Hinweis:</b> Wenn Sie an bin√§ren negativen Zahlen interessiert sind, k√∂nnen Sie sich √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zus√§tzlichen Code informieren</a> .  Dies ist jedoch nicht wesentlich.  Kopieren Sie einfach den obigen Code und verwenden Sie ihn, wenn in der Spezifikation angegeben ist, dass der Wert erweitert werden soll. </blockquote><br>  Die Spezifikation hat den letzten Satz: <br><br><blockquote>  Die Bedingungscodes werden abh√§ngig davon festgelegt, ob das Ergebnis negativ, null oder positiv ist.  (S. 526) </blockquote><br>  Fr√ºher haben wir die Aufz√§hlungsbedingung f√ºr Flags definiert, und jetzt ist es Zeit, diese Flags zu verwenden.  Jedes Mal, wenn ein Wert in das Register geschrieben wird, m√ºssen die Flags aktualisiert werden, um das Vorzeichen anzuzeigen.  Wir schreiben eine Funktion zur Wiederverwendung: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Jetzt k√∂nnen wir den Code f√ºr <code>ADD</code> schreiben: <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Dieser Abschnitt enth√§lt viele Informationen. Fassen wir also zusammen. <br><br><ul><li>  <code>ADD</code> nimmt zwei Werte und speichert sie in einem Register. </li><li>  Im Registermodus befindet sich der zweite hinzuzuf√ºgende Wert im Register. </li><li>  Im direkten Modus ist der zweite Wert in die rechten 5 Bits des Befehls eingebettet. </li><li>  Werte, die k√ºrzer als 16 Bit sind, sollten erweitert werden. </li><li>  Jedes Mal, wenn der Befehl den Fall √§ndert, sollten die Bedingungsflags aktualisiert werden. </li></ul><br>  Sie k√∂nnen √ºberw√§ltigt sein, wenn Sie 15 weitere Anweisungen schreiben.  Die hier erhaltenen Informationen k√∂nnen jedoch wiederverwendet werden.  Die meisten Anweisungen verwenden eine Kombination aus Werterweiterung, verschiedenen Modi und Flag-Aktualisierungen. <br><br><h3>  LDI </h3><br>  LDI bedeutet "indirektes" oder "indirektes" Laden (indirektes Laden).  Dieser Befehl wird verwendet, um einen Wert von einem Speicherort in ein Register zu laden.  Spezifikation auf Seite 532. <br><br>  So sieht das bin√§re Layout aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  Im Gegensatz zu <code>ADD</code> gibt es keine Modi und weniger Parameter.  Diesmal lautet der Operationscode <code>1010</code> , was dem Aufz√§hlungswert <code>OP_LDI</code> .  Wieder sehen wir ein Drei-Bit- <code>DR</code> (Ausgangsregister) zum Speichern des geladenen Wertes.  Die restlichen Bits sind als <code>PCoffset9</code> markiert.  Dies ist der unmittelbare Wert, der in die Anweisung eingebettet ist (√§hnlich wie bei <code>imm5</code> ).  Da der Befehl aus dem Speicher geladen wird, k√∂nnen wir davon ausgehen, dass diese Nummer eine Art Adresse ist, die angibt, woher der Wert geladen werden soll.  In der Spezifikation wird n√§her erl√§utert: <br><br><blockquote>  Die Adresse wird berechnet, indem die Bits des Werts <code>[8:0]</code> auf 16 Bits erweitert und dieser Wert dem vergr√∂√üerten <code>PC</code> hinzugef√ºgt werden.  Was unter dieser Adresse im Speicher gespeichert ist, ist die Adresse der Daten, die in den <code>DR</code> geladen werden.  (S. 532) </blockquote><br>  Nach wie vor m√ºssen Sie diesen 9-Bit-Wert erweitern, diesmal jedoch zum aktuellen <code>PC</code> hinzuf√ºgen.  (Wenn Sie sich den Ausf√ºhrungszyklus ansehen, hat sich der <code>PC</code> unmittelbar nach dem Laden dieser Anweisung erh√∂ht.)  Die resultierende Summe ist die Ortsadresse im Speicher, und diese Adresse <i>enth√§lt einen anderen</i> Wert, n√§mlich die Adresse des Ladewerts. <br><br>  Dies mag wie ein Umweg erscheinen, um aus dem Speicher zu lesen, aber es ist notwendig.  Der <code>LD</code> Befehl ist auf einen Adressversatz von 9 Bit begrenzt, w√§hrend der Speicher eine Adresse von 16 Bit ben√∂tigt.  <code>LDI</code> ist n√ºtzlich, um Werte zu laden, die irgendwo au√üerhalb des aktuellen Computers gespeichert sind. Um sie jedoch zu verwenden, sollte die Adresse des endg√ºltigen Speicherorts in der N√§he gespeichert werden.  Sie k√∂nnen es sich als lokale Variable in C vorstellen, die auf einige Daten verweist: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Nach dem Schreiben des Werts in <code>DR</code> sollten die Flags wie zuvor aktualisiert werden: <br><br><blockquote>  Die Bedingungscodes werden abh√§ngig davon festgelegt, ob das Ergebnis negativ, null oder positiv ist.  (S. 532) </blockquote><br>  Hier ist der Code f√ºr diesen Fall: ( <code>mem_read</code> im n√§chsten Abschnitt erl√§utert): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Wie gesagt, f√ºr diese Anweisung haben wir einen wesentlichen Teil des Codes und der Kenntnisse verwendet, die wir zuvor beim Schreiben von <code>ADD</code> .  Das gleiche gilt f√ºr den Rest der Anleitung. <br><br>  Jetzt m√ºssen Sie den Rest der Anweisungen implementieren.  Befolgen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikationen</a> und verwenden Sie den bereits geschriebenen Code.  Der Code f√ºr alle Anweisungen finden Sie am Ende des Artikels.  Zwei der zuvor genannten Opcodes werden nicht ben√∂tigt: <code>OP_RTI</code> und <code>OP_RES</code> .  Sie k√∂nnen sie ignorieren oder einen Fehler machen, wenn sie aufgerufen werden.  Wenn Sie fertig sind, kann der Gro√üteil Ihrer VM als vollst√§ndig betrachtet werden! <br><br><a name="7"></a><h1>  7. Kinderbett gem√§√ü Anleitung </h1><br>  Dieser Abschnitt enth√§lt vollst√§ndige Implementierungen der verbleibenden Anweisungen, wenn Sie nicht weiterkommen. <br><br><h3>  RTI &amp; RES </h3><br>  (nicht verwendet) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bit "Und"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitweise NICHT</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Zweig </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Springe </h3><br>  <code>RET</code> wird in der Spezifikation als separate Anweisung angegeben, da dies ein weiterer Befehl in Assembler ist.  Dies ist eigentlich ein Sonderfall von <code>JMP</code> .  <code>RET</code> tritt immer dann auf, wenn <code>R1</code> 7 ist. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Sprungregister </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Laden </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Register laden </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Effektive Ladeadresse </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Speichern </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Indirekt speichern </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Ladenregister </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Interrupt-Handhabungsverfahren </h1><br>  LC-3 bietet mehrere vordefinierte Routinen f√ºr die Ausf√ºhrung allgemeiner Aufgaben und die Interaktion mit E / A-Ger√§ten.  Beispielsweise gibt es Verfahren zum Empfangen von Tastatureingaben und zum Ausgeben von Zeilen an die Konsole.  Sie werden Trap-Routinen genannt, die Sie sich als Betriebssystem oder API f√ºr LC-3 vorstellen k√∂nnen.  Jedem Unterprogramm wird ein Interrupt-Code (Trap-Code) zugewiesen, der es identifiziert (√§hnlich einem Opcode).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur Ausf√ºhrung wird eine Anweisung </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Code des gew√ºnschten Unterprogramms </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Legen Sie f√ºr jeden Interrupt-Code eine Aufz√§hlung fest: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie fragen sich m√∂glicherweise, warum Interrupt-Codes nicht in den Anweisungen enthalten sind. </font><font style="vertical-align: inherit;">Dies liegt daran, dass sie LC-3 tats√§chlich keine neuen Funktionen hinzuf√ºgen, sondern nur eine bequeme M√∂glichkeit bieten, die Aufgabe zu erledigen (wie Systemfunktionen in C). </font><font style="vertical-align: inherit;">Im offiziellen LC-3-Simulator werden Interrupt-Codes </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Assembler geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn ein Interrupt-Code aufgerufen wird, wechselt der Computer zur Adresse dieses Codes. </font><font style="vertical-align: inherit;">Die CPU f√ºhrt die Anweisungen der Prozedur aus und wird nach Abschluss </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an den Ort zur√ºckgesetzt, von dem aus der Interrupt aufgerufen wurde.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt keine Spezifikation f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementierung von Interrupt-Routinen: genau das, was sie tun sollen. In unserer VM verhalten wir uns etwas anders, indem wir sie in C schreiben. Wenn der Interrupt-Code aufgerufen wird, wird die Funktion C aufgerufen. Nach ihrer Operation wird der Befehl fortgesetzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Prozeduren in Assembler geschrieben werden k√∂nnen und der physische Computer LC-3 dies sein wird, ist dies nicht die beste Option f√ºr die VM. Anstatt Ihre eigenen primitiven Eingabe-Ausgabe-Prozeduren zu schreiben, k√∂nnen Sie diejenigen verwenden, die auf unserem Betriebssystem verf√ºgbar sind. Dies wird die virtuelle Maschine auf unseren Computern verbessern, den Code vereinfachen und eine h√∂here Abstraktionsebene f√ºr die Portabilit√§t bereitstellen.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein spezielles Beispiel ist die Tastatureingabe. </font><font style="vertical-align: inherit;">Die Assembler-Version verwendet eine Schleife, um die Tastatureingabe kontinuierlich zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Aber so viel Prozessorzeit wird verschwendet! </font><font style="vertical-align: inherit;">Mit der entsprechenden OS-Funktion kann das Programm vor dem Eingangssignal ruhig schlafen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie im Multiple-Choice-Operator f√ºr den Opcode </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen weiteren Schalter hinzu:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie bei den Anweisungen werde ich Ihnen zeigen, wie Sie ein Verfahren implementieren und den Rest selbst erledigen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putts </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Interrupt-Code wird </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet, um eine Zeichenfolge mit einer abschlie√üenden Null zur√ºckzugeben (√§hnlich </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C). </font><font style="vertical-align: inherit;">Spezifikation auf Seite 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eine Zeichenfolge anzuzeigen, m√ºssen wir der Interrupt-Routine eine Zeichenfolge zur Anzeige geben. </font><font style="vertical-align: inherit;">Dies erfolgt durch Speichern der Adresse des ersten Zeichens </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor Beginn der Verarbeitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus der Spezifikation:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie die ASCII-Zeichenfolge in der Konsolenanzeige an. </font><font style="vertical-align: inherit;">Zeichen sind in aufeinanderfolgenden Speicherzellen enthalten, ein Zeichen pro Zelle, beginnend mit der in angegebenen Adresse </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Ausgabe endet, wenn ein Wert im Speicher gefunden wird </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(S. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass im Gegensatz zu C-Zeichenfolgen die Zeichen hier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht in einem Byte, sondern an einer Stelle im Speicher gespeichert werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Speicherplatz des LC-3 betr√§gt 16 Bit, sodass jedes Zeichen in der Zeichenfolge 16 Bit betr√§gt. </font><font style="vertical-align: inherit;">Um dies in der C-Funktion anzuzeigen, m√ºssen Sie jeden Wert in ein Zeichen konvertieren und separat drucken.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr dieses Verfahren ist nichts mehr erforderlich. </font><font style="vertical-align: inherit;">Die Interrupt-Routinen sind ziemlich einfach, wenn Sie C kennen. Kehren Sie nun zu den Spezifikationen zur√ºck und implementieren Sie den Rest. </font><font style="vertical-align: inherit;">Wie bei den Anweisungen finden Sie den vollst√§ndigen Code am Ende dieses Handbuchs.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Spickzettel f√ºr Interruptroutinen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Abschnitt enth√§lt vollst√§ndige Implementierungen der verbleibenden Interruptroutinen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeicheneingabe </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichenausgabe </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeicheneingabeanforderung </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leitungsausgang </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programmbeendigung </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Programme herunterladen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben viel √ºber das Laden und Ausf√ºhren von Anweisungen aus dem Speicher gesprochen, aber wie gelangen Anweisungen im Allgemeinen in den Speicher? </font><font style="vertical-align: inherit;">Wenn Sie ein Assembler-Programm in Maschinencode konvertieren, ist das Ergebnis eine Datei, die ein Array von Anweisungen und Daten enth√§lt. </font><font style="vertical-align: inherit;">Sie k√∂nnen es herunterladen, indem Sie den Inhalt einfach direkt an eine Adresse im Speicher kopieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten 16 Bits der Programmdatei geben die Adresse im Speicher an, an der das Programm starten soll. </font><font style="vertical-align: inherit;">Diese Adresse wird als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ursprung bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es muss zuerst gelesen werden, danach werden die restlichen Daten aus der Datei in den Speicher eingelesen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der Code zum Laden des Programms in den LC-3-Speicher:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass f√ºr jeden geladenen Wert aufgerufen wird </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">LC-3-Programme werden in direkter Bytereihenfolge geschrieben, aber die meisten modernen Computer verwenden die umgekehrte Reihenfolge. </font><font style="vertical-align: inherit;">Infolgedessen m√ºssen wir jeden geladenen umdrehen </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Wenn Sie versehentlich einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fremden Computer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss nichts ge√§ndert werden.)</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Die </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bytereihenfolge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bezieht sich darauf, wie die Bytes einer Ganzzahl interpretiert werden. </font><font style="vertical-align: inherit;">In umgekehrter Reihenfolge ist das erste Byte die niedrigstwertige Ziffer und in umgekehrter Reihenfolge umgekehrt. </font><font style="vertical-align: inherit;">Soweit ich wei√ü, ist die Entscheidung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> willk√ºrlich. </font><font style="vertical-align: inherit;">Verschiedene Unternehmen haben unterschiedliche Entscheidungen getroffen, daher haben wir jetzt unterschiedliche Implementierungen. </font><font style="vertical-align: inherit;">F√ºr dieses Projekt m√ºssen Sie nichts mehr √ºber die Bytereihenfolge wissen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie auch eine praktische Funktion f√ºr hinzu </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Pfad f√ºr die Zeichenfolge √ºbernimmt:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Zugeordnete Register </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Sonderregister sind in der regul√§ren Registertabelle nicht verf√ºgbar. Stattdessen ist ihnen eine spezielle Adresse im Speicher vorbehalten. Um diese Register zu lesen und zu schreiben, lesen und schreiben Sie einfach in ihren Speicher. Sie werden als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speicherabgebildete Register bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Normalerweise werden sie zur Interaktion mit speziellen Hardwareger√§ten verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr unseren LC-3 m√ºssen wir zwei abbildbare Register implementieren. Dies ist das Tastaturstatusregister ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und das Tastaturdatenregister ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Die erste zeigt an, ob die Taste gedr√ºckt wurde, und die zweite gibt an, welche Taste gedr√ºckt wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Tastatureingaben mit angefordert werden k√∂nnen </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, blockiert sie die Ausf√ºhrung, bis Eingaben empfangen werden. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erlauben</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragen Sie den Status des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ger√§ts ab, w√§hrend Sie das Programm weiter ausf√ºhren, damit es w√§hrend des Wartens auf Eingaben reagiert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zugeordnete Register erschweren den Speicherzugriff etwas. </font><font style="vertical-align: inherit;">Wir k√∂nnen nicht direkt in das Speicherarray lesen und schreiben, sondern m√ºssen spezielle Funktionen aufrufen - den Setter und den Getter. </font><font style="vertical-align: inherit;">Nach dem Lesen des Speichers aus dem KBSR-Register √ºberpr√ºft der Getter die Tastatur und aktualisiert beide Speicherorte.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist die letzte Komponente einer virtuellen Maschine! </font><font style="vertical-align: inherit;">Wenn Sie den Rest der Interrupt-Routinen und -Anweisungen implementiert haben, sind Sie fast bereit, es zu versuchen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles, was geschrieben wurde, sollte in der folgenden Reihenfolge zur C-Datei hinzugef√ºgt werden:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Plattformfunktionen </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Abschnitt enth√§lt einige langwierige Details, die f√ºr den Zugriff auf die Tastatur und die ordnungsgem√§√üe Funktion erforderlich sind. </font><font style="vertical-align: inherit;">Der Betrieb virtueller Maschinen ist weder interessant noch informativ. </font><font style="vertical-align: inherit;">F√ºhlen Sie sich frei zu kopieren und einzuf√ºgen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie versuchen, die VM unter einem anderen Betriebssystem als Unix wie Windows zu starten, m√ºssen diese Funktionen durch die entsprechenden Windows-Funktionen ersetzt werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code zum Extrahieren des Pfads aus den Programmargumenten und zum Ausgeben eines Verwendungsbeispiels, falls diese fehlen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unix-spezifischer Konfigurationscode f√ºr die Terminaleingabe. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn das Programm unterbrochen wird, m√∂chten wir die Konsole auf ihre normalen Einstellungen zur√ºcksetzen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start der virtuellen Maschine </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen Sie die virtuelle LC-3-Maschine erstellen und ausf√ºhren! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilieren Sie das </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programm mit Ihrem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lieblings-Compiler.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie die kompilierte Version von </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunter </font><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºhren Sie das Programm mit der obj-Datei als Argument aus: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielen Sie im Jahr 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Programm nicht richtig funktioniert, haben Sie h√∂chstwahrscheinlich eine Anweisung falsch codiert. </font><font style="vertical-align: inherit;">Das Debuggen kann schwierig sein. </font><font style="vertical-align: inherit;">Ich empfehle, dass Sie gleichzeitig den Assembler-Code des Programms lesen - und mit Hilfe des Debuggers Schritt f√ºr Schritt den Anweisungen der virtuellen Maschine nacheinander folgen. </font><font style="vertical-align: inherit;">Stellen Sie beim Lesen des Codes sicher, dass die VM die vorgesehene Anweisung befolgt. </font><font style="vertical-align: inherit;">Wenn eine Nicht√ºbereinstimmung auftritt, finden Sie heraus, welche Anweisung das Problem verursacht hat. </font><font style="vertical-align: inherit;">Lesen Sie die Spezifikation erneut und √ºberpr√ºfen Sie den Code erneut.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Alternative Methode in C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist eine erweiterte Methode zum Ausf√ºhren von Anweisungen, die die Codegr√∂√üe erheblich reduziert. Dies ist ein v√∂llig optionaler Abschnitt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da C ++ w√§hrend des Kompilierungsprozesses leistungsstarke Generika unterst√ºtzt, k√∂nnen wir mit dem Compiler Teile von Anweisungen erstellen. Diese Methode reduziert die Codeduplizierung und liegt tats√§chlich n√§her an der Hardwareebene des Computers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee ist, die f√ºr jede Anweisung gemeinsamen Schritte wiederzuverwenden. Einige Anweisungen verwenden beispielsweise die indirekte Adressierung oder Erweiterung eines Werts und das Hinzuf√ºgen zum aktuellen Wert </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stimmen Sie zu, w√§re es sch√∂n, diesen Code einmal f√ºr alle Anweisungen zu schreiben?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir die Anweisung als eine Folge von Schritten betrachten, sehen wir, dass jede Anweisung nur eine Neuanordnung mehrerer kleinerer Schritte ist. </font><font style="vertical-align: inherit;">Wir werden Bit-Flags verwenden, um anzugeben, welche Schritte f√ºr jede Anweisung zu befolgen sind. </font><font style="vertical-align: inherit;">Der Wert </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Befehlsnummernbit gibt an, dass der Compiler f√ºr diesen Befehl diesen Codeabschnitt enthalten sollte.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Technik habe ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem von Bisqwit entwickelten NES-Emulator kennengelernt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie an Emulation oder NES interessiert sind, empfehle ich die Videos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Versionen von C ++ verwenden den bereits geschriebenen Code. </font><font style="vertical-align: inherit;">Vollversion </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434138/">https://habr.com/ru/post/de434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434128/index.html">PHP Digest Nr. 146 (10. - 24. Dezember 2018) + 2018 Ergebnisse</a></li>
<li><a href="../de434130/index.html">Reaktive Schnittstelle. Vortrag von Artyom Belov auf den FrontTalks 2018</a></li>
<li><a href="../de434132/index.html">Kaufen Sie einen Fernseher und rollen Sie ihn auf: LG plant, im kommenden Jahr mit dem Verkauf flexibler Fernseher zu beginnen</a></li>
<li><a href="../de434134/index.html">Analyse der Ergebnisse der Kaggle ML & DS-Umfrage 2018</a></li>
<li><a href="../de434136/index.html">Unternehmensanatomie</a></li>
<li><a href="../de434140/index.html">Eine kurze Geschichte der asynchronen Javascript-Funktionen</a></li>
<li><a href="../de434142/index.html">Das QRL-Team hat eine enge Frist f√ºr die Token-Migration festgelegt</a></li>
<li><a href="../de434146/index.html">Top 10 IT-Filme</a></li>
<li><a href="../de434150/index.html">Merkmale der Arbeitssuche in Europa</a></li>
<li><a href="../de434154/index.html">Neujahrsdatensatz 2018: Offene Semantik der russischen Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>