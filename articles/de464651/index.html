<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø üò§ üêû Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 5 ü§öüèΩ üçÅ üõå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Teil 4. Peripherieger√§te programmieren und Interrupts behandeln 
 Assembler Code Generator Library f√ºr AVR-Mikrocontroller 
 Teil 5. Entwerfen von M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler-Codegenerator-Bibliothek f√ºr AVR-Mikrocontroller. Teil 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Üê Teil 4. Peripherieger√§te programmieren und Interrupts behandeln</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Assembler Code Generator Library f√ºr AVR-Mikrocontroller </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Teil 5. Entwerfen von Multithread-Anwendungen </h3><br><p>  In den vorherigen Teilen des Artikels haben wir die Grundlagen der Programmierung mithilfe der Bibliothek erl√§utert.  Im vorherigen Teil haben wir uns mit der Implementierung von Interrupts und den Einschr√§nkungen vertraut gemacht, die bei der Arbeit mit ihnen auftreten k√∂nnen.  In diesem Teil des Beitrags werden wir uns mit einer der m√∂glichen Optionen zum Programmieren paralleler Prozesse unter Verwendung der <em>Parallel-</em> Klasse <em>befassen</em> .  Die Verwendung dieser Klasse erm√∂glicht es, die Erstellung von Anwendungen zu vereinfachen, in denen Daten in mehreren unabh√§ngigen Programmstr√∂men verarbeitet werden sollen. </p><a name="habracut"></a><br><p>  Alle Multitasking-Systeme f√ºr Single-Core-Systeme sind einander √§hnlich.  Multithreading wird durch die Arbeit des Dispatchers implementiert, der jedem Thread ein Zeitfenster zuweist. Wenn es beendet ist, √ºbernimmt es die Kontrolle und gibt dem n√§chsten Thread die Kontrolle.  Der Unterschied zwischen den verschiedenen Implementierungen liegt nur in den Details, daher werden wir uns haupts√§chlich mit den spezifischen Merkmalen dieser Implementierung befassen. </p><br><p>  Die Einheit der Prozessausf√ºhrung im Thread ist die Aufgabe.  Es kann eine unbegrenzte Anzahl von Aufgaben im System vorhanden sein, aber zu einem bestimmten Zeitpunkt kann nur eine bestimmte Anzahl von Aufgaben aktiviert werden, die durch die Anzahl der Workflows im Dispatcher begrenzt ist.  In dieser Implementierung wird die Anzahl der Workflows im Manager-Konstruktor angegeben und kann anschlie√üend nicht mehr ge√§ndert werden.  Dabei k√∂nnen Threads Aufgaben erledigen oder frei bleiben.  Im Gegensatz zu anderen L√∂sungen wechselt <em>Parallel</em> Manager keine Aufgaben.  Damit die Aufgabe die Kontrolle an den Dispatcher zur√ºckgeben kann, m√ºssen entsprechende Befehle in den Code eingef√ºgt werden.  Die Verantwortung f√ºr die Dauer des Zeitfensters in der Aufgabe liegt somit beim Programmierer, der an bestimmten Stellen im Code Interrupt-Befehle einf√ºgen muss, wenn die Aufgabe zu lange dauert, und das Verhalten des Threads nach Abschluss der Aufgabe bestimmen muss.  Der Vorteil dieses Ansatzes besteht darin, dass der Programmierer die Schaltpunkte zwischen Aufgaben steuert, wodurch Sie den Speicher- / Wiederherstellungscode beim Wechseln von Aufgaben erheblich optimieren und die meisten Probleme im Zusammenhang mit dem threadsicheren Datenzugriff beseitigen k√∂nnen. </p><br><p>  Um die Ausf√ºhrung laufender Aufgaben zu steuern, wird eine spezielle <em>Signalklasse</em> verwendet.  Das Signal ist eine Bitvariable, deren Einstellung als Freigabesignal zum Starten einer Aufgabe in einem Stream verwendet wird.  Signalwerte k√∂nnen entweder manuell oder durch ein diesem Signal zugeordnetes Ereignis eingestellt werden. </p><br><p>  Das Signal wird zur√ºckgesetzt, wenn die Aufgabe vom Dispatcher aktiviert wird oder programmgesteuert ausgef√ºhrt werden kann. </p><br><p>  Aufgaben im System k√∂nnen folgende Zust√§nde haben: </p><br><p>  <strong>Deaktiviert</strong> - Ausgangszustand f√ºr alle Aufgaben.  Die Aufgabe nimmt den Ablauf nicht auf und die Ausf√ºhrungskontrolle wird nicht √ºbertragen.  Die R√ºckkehr in diesen Zustand f√ºr aktivierte Aufgaben erfolgt nach Abschluss des Befehls. </p><br><p>  <strong>Aktiviert</strong> - Der Status, in dem sich die Aufgabe nach der Aktivierung befindet.  Der Aktivierungsprozess ordnet eine Aufgabe einem Ausf√ºhrungsthread und einem Aktivierungssignal zu.  Der Manager fragt die Threads ab und startet die Aufgabe, wenn das Aufgabensignal aktiviert ist. </p><br><p>  <strong>Blockiert</strong> - Wenn eine Aufgabe aktiviert ist, kann ihr bereits ein Signal als Signal zugewiesen werden, das bereits zur Steuerung eines anderen Threads verwendet wird.  In diesem Fall wird die aktivierte Aufgabe in den gesperrten Zustand versetzt, um die Mehrdeutigkeit des Programmverhaltens zu vermeiden.  In diesem Zustand belegt die Task den Thread, kann jedoch keine Kontrolle erhalten, selbst wenn ihr Signal aktiviert ist.  Nach Abschluss von Aufgaben oder beim √Ñndern des Aktivierungssignals √ºberpr√ºft und √§ndert der Dispatcher den Status von Aufgaben in den Threads.  Wenn die Threads Aufgaben blockiert haben, f√ºr die das Signal mit dem freigegebenen √ºbereinstimmt, wird die erste gefundene aktiviert.  Bei Bedarf kann der Programmierer Aufgaben unabh√§ngig von der erforderlichen Logik des Programms sperren und entsperren. </p><br><p>  <strong>Warten</strong> - Der Status, in dem sich die Aufgabe befindet, nachdem der Befehl <em>Verz√∂gerung</em> ausgef√ºhrt wurde.  In diesem Zustand erh√§lt die Aufgabe erst nach Ablauf des erforderlichen Intervalls die Kontrolle.  In der <em>Parallel-</em> Klasse werden 16-ms-WDT-Interrupts verwendet, um die Verz√∂gerung zu steuern, wodurch Zeitgeber f√ºr Systemanforderungen nicht belegt werden k√∂nnen.  Wenn Sie in kleinen Intervallen mehr Stabilit√§t oder Aufl√∂sung ben√∂tigen <em>, k√∂nnen</em> Sie anstelle der <em>Verz√∂gerung</em> die Aktivierung durch Timersignale verwenden.  Es ist zu beachten, dass die Verz√∂gerungsgenauigkeit immer noch gering ist und im Bereich von <em>"Dispatcher-Antwortzeit" - "maximale Zeitschlitzdauer im System + Dispatcher-Antwortzeit"</em> schwankt.  F√ºr Aufgaben mit genauen Zeitbereichen sollten Sie den Hybridmodus verwenden, in dem der Timer, der in der <em>Parallel-</em> Klasse nicht verwendet wird, unabh√§ngig vom Aufgabenablauf arbeitet und Intervalle im reinen Interrupt-Modus verarbeitet. </p><br><p>  Jede in einem Thread ausgef√ºhrte Aufgabe ist ein isolierter Prozess.  Dies erfordert die Definition von zwei Datentypen: lokale Daten eines Streams, die nur im Rahmen dieses Streams sichtbar sein und ge√§ndert werden sollten, und globale Daten f√ºr den Austausch zwischen Flows und den Zugriff auf gemeinsam genutzte Ressourcen.  Im Rahmen dieser Implementierung werden globale Daten durch zuvor ber√ºcksichtigte Befehle auf Ger√§teebene erstellt.  Um lokale Aufgabenvariablen zu erstellen, m√ºssen sie mit Methoden aus der Aufgabenklasse erstellt werden.  Das Verhalten der lokalen Taskvariablen ist wie folgt: Wenn die Task unterbrochen wird, bevor die Steuerung an den Dispatcher √ºbertragen wird, werden alle lokalen Registervariablen im Speicher des Streams gespeichert.  Wenn die Steuerung zur√ºckgegeben wird, werden die lokalen Registervariablen wiederhergestellt, bevor der n√§chste Befehl ausgef√ºhrt wird. <br>  Eine Klasse mit der <em>IHeap-</em> Schnittstelle, die der <em>Heap-</em> Eigenschaft der <em>Parallel-</em> Klasse zugeordnet ist, ist f√ºr das Speichern lokaler Daten des Streams verantwortlich.  Die einfachste Implementierung dieser Klasse ist <em>StaticHeap</em> , die die statische Zuordnung derselben Speicherbl√∂cke f√ºr jeden Thread implementiert.  <em>Wenn</em> die Aufgaben je nach Bedarf an lokaler Datenmenge sehr unterschiedlich sind, k√∂nnen Sie <em>DynamicHeap verwenden</em> , mit dem Sie die Gr√∂√üe des lokalen Speichers f√ºr jede Aufgabe einzeln bestimmen k√∂nnen.  Offensichtlich ist der Aufwand f√ºr die Arbeit mit dem Stream-Speicher in diesem Fall erheblich h√∂her. </p><br><p>  Schauen wir uns nun die Klassensyntax am Beispiel von zwei Streams genauer an, von denen jeder unabh√§ngig einen separaten Portausgang schaltet. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  Die obersten Zeilen des Programms sind Ihnen bereits bekannt.  In ihnen bestimmen wir den Reglertyp und weisen das erste und zweite Bit von Port B als Ausgang zu.  Als n√§chstes folgt die Initialisierung einer Variablen der <em>Parallel-</em> Klasse, wobei wir im zweiten Parameter die maximale Anzahl von Ausf√ºhrungsthreads bestimmen.  In der n√§chsten Zeile weisen wir Speicher zu, um lokale Variablenfl√ºsse aufzunehmen.  Wir haben gleiche Aufgaben, also verwenden wir <em>StaticHeap</em> .  Der n√§chste Codeblock ist die Aufgabendefinition.  Darin definieren wir zwei nahezu identische Aufgaben.  Der einzige Unterschied ist der Steuerport und die Verz√∂gerung.  Um mit lokalen Aufgabenobjekten zu arbeiten, wird ein Zeiger auf die lokale Aufgabe <em>tsk</em> an den Aufgabencodeblock √ºbergeben.  Der Aufgabentext selbst ist sehr einfach: </p><br><ul><li>  Ein lokales Label wird erstellt, um einen unendlichen Schaltzyklus zu organisieren </li><li>  Portstatus ist umgekehrt </li><li>  Die Steuerung wird an den Dispatcher zur√ºckgegeben, und die Task wird f√ºr die angegebene Anzahl von Millisekunden in den Wartestatus versetzt </li><li>  Der R√ºckgabezeiger wird auf den Startblock des Blocks gesetzt und die Steuerung an den Dispatcher zur√ºckgegeben. <br>  In einem konkreten Beispiel k√∂nnte der letzte Befehl nat√ºrlich durch einen normalen Befehl ersetzt werden, der an den Anfang des Blocks geht und im Beispiel nur zum Zwecke der Demonstration angegeben wird.  Falls gew√ºnscht, kann das Beispiel leicht erweitert werden, um eine gro√üe Anzahl von Schlussfolgerungen zu steuern, indem Aufgaben kopiert und die Anzahl der Threads erh√∂ht werden. </li></ul><br><p>  Eine vollst√§ndige Liste der Task-Abbruchbefehle zum √úbertragen der Steuerung an den Dispatcher lautet wie folgt <br>  <strong>AWAIT (Signal)</strong> - Der Stream speichert alle Variablen im Speicher des Streams und √ºbertr√§gt die Kontrolle an den Dispatcher.  Bei der n√§chsten Aktivierung des Streams werden die Variablen wiederhergestellt und die Ausf√ºhrung fortgesetzt, beginnend mit der n√§chsten Anweisung nach <em>AWAIT</em> .  Der Befehl dient dazu, die Aufgabe in Zeitschlitze zu unterteilen und die Zustandsmaschine gem√§√ü dem Schema <em>Signal ‚Üí Verarbeitung 1 ‚Üí Signal ‚Üí Verarbeitung 2</em> usw. zu implementieren. </p><br><p>  Der Befehl AWAIT kann ein Signal als optionalen Parameter haben.  Wenn der Parameter leer ist, wird das Aktivierungssignal gespeichert.  Wenn es im Parameter angegeben ist, werden alle nachfolgenden Taskaufrufe ausgef√ºhrt, wenn das angegebene Signal aktiviert wird und die Kommunikation mit dem vorherigen Signal unterbrochen wird. </p><br><p>  <strong>TaskContinue (Label, Signal)</strong> - Der Befehl beendet den Stream und gibt dem Dispatcher die Kontrolle, ohne Variablen zu speichern.  Bei der n√§chsten Aktivierung des Streams wird die Kontrolle auf das <em>Etikettenetikett √ºbertragen</em> .  Mit dem optionalen Parameter <em>Signal</em> k√∂nnen Sie das Stream-Aktivierungssignal f√ºr den n√§chsten Anruf √ºberschreiben.  Wenn nicht angegeben, bleibt das Signal gleich.  Ein Befehl ohne Angabe eines Signals kann verwendet werden, um Zyklen innerhalb einer einzelnen Aufgabe zu organisieren, wobei jeder Zyklus in einem separaten Zeitfenster ausgef√ºhrt wird.  Es kann auch verwendet werden, um dem aktuellen Thread nach Abschluss des vorherigen Threads eine neue Aufgabe zuzuweisen.  Der Vorteil dieses Ansatzes gegen√ºber dem Zyklus <em>Freigeben eines Threads ‚Üí Hervorheben eines Streams</em> ist ein effizienteres Programm.  Durch die Verwendung von <em>TaskContinue</em> muss der Manager nicht mehr nach einem freien Thread im Pool suchen und garantiert Fehler beim Zuweisen von Threads ohne freie Threads. </p><br><p>  <strong>TaskEnd ()</strong> - <strong>L√∂scht</strong> den Stream nach Abschluss der Aufgabe.  Die Aufgabe endet, der Thread wird freigegeben und kann verwendet werden, um mit dem Befehl <em>Aktivieren</em> eine neue Aufgabe zuzuweisen. </p><br><p>  <strong>Verz√∂gerung (ms)</strong> - Der Stream speichert wie bei der Verwendung von <em>AWAIT</em> alle Variablen im Speicher des Streams und √ºbertr√§gt die Steuerung an den Dispatcher.  In diesem Fall wird der Verz√∂gerungswert in Millisekunden im Stream-Header aufgezeichnet.  In der Dispatcher-Schleife wird bei einem Wert ungleich Null im Verz√∂gerungsfeld der Fluss nicht aktiviert.  Das √Ñndern der Werte im Verz√∂gerungsfeld f√ºr alle Fl√ºsse erfolgt durch Unterbrechen des WDT-Timers alle 16 ms.  Wenn der Nullwert erreicht ist, wird das Ausf√ºhrungsverbot aufgehoben und das Stream-Aktivierungssignal gesetzt.  Im Header wird nur ein Einzelbyte-Wert f√ºr die Verz√∂gerung gespeichert, was einen relativ engen Bereich m√∂glicher Verz√∂gerungen ergibt. Um l√§ngere Verz√∂gerungen zu implementieren, erstellt <em>Delay ()</em> eine interne Schleife unter Verwendung lokaler Stream-Variablen. <br>  Die Aktivierung der Befehle im Beispiel erfolgt mit den Befehlen <em>ContinuousActivate</em> und <em>ActivateNext</em> .  Dies ist eine spezielle Art der anf√§nglichen Aufgabenaktivierung beim Start.  In der ersten Aktivierungsphase ist garantiert kein einziger ausgelasteter Thread vorhanden, sodass f√ºr den Aktivierungsprozess keine vorl√§ufige Suche nach einem freien Thread f√ºr eine Aufgabe erforderlich ist und Sie Aufgaben nacheinander aktivieren k√∂nnen.  <em>ContinuousActivate</em> aktiviert die Aufgabe im Null-Thread und gibt einen Zeiger auf den Header des n√§chsten Threads zur√ºck. Die <em>ActivateNext-</em> Funktion verwendet diesen Zeiger, um die folgenden Aufgaben in sequentiellen Threads zu aktivieren. </p><br><p>  Im Beispiel wird als Aktivierungssignal das <em>AlwaysOn-</em> Signal verwendet.  Dies ist eines der Systemsignale.  Sein Zweck bedeutet, dass die Aufgabe immer ausgef√ºhrt wird, da dies das einzige Signal ist, das immer aktiviert ist und nicht durch Verwendung zur√ºckgesetzt wird. </p><br><p>  Das Beispiel endet mit einem <em>Loop-</em> Aufruf.  Diese Funktion startet den Dispatcher-Zyklus, daher sollte dieser Befehl der letzte im Code sein. </p><br><p>  Stellen Sie sich ein weiteres Beispiel vor, bei dem die Verwendung der Bibliothek die Struktur des Codes erheblich vereinfachen kann.  Es sei ein bedingtes Steuerger√§t, das ein analoges Signal registriert und es in Form eines HEX-Codes an das Terminal sendet. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Das soll nicht hei√üen, dass wir hier viele neue Dinge gesehen haben, aber Sie k√∂nnen etwas Interessantes in diesem Code sehen. </p><br><p>  In diesem Beispiel wird zuerst der ADC (Analog-Digital-Wandler) erw√§hnt.  Dieses Peripherieger√§t dient zur Umwandlung der Spannung des Eingangssignals in einen digitalen Code.  Der Konvertierungszyklus wird von der <em>ConvertAsync-</em> Funktion <em>gestartet</em> , die den Prozess nur startet, ohne auf das Ergebnis zu warten.  Wenn die Konvertierung abgeschlossen ist, generiert der ADC einen Interrupt, der das <em>adcSig-</em> Signal aktiviert.  <em>Achten Sie</em> auf die Definition des <em>adcSig-</em> Signals.  Neben dem Interrupt-Zeiger enth√§lt er auch einen Codeblock zum Speichern von Werten aus dem ADC-Datenregister.  Der gesamte Code, der vorzugsweise unmittelbar nach einem Interrupt ausgef√ºhrt wird (z. B. Lesen von Daten aus Ger√§teregistern), sollte sich an dieser Stelle befinden. <br>  Die <em>Konvertierungsaufgabe</em> besteht darin, einen bin√§ren Spannungscode in eine vierstellige HEX-Darstellung f√ºr unser bedingtes Terminal zu konvertieren.  Hier k√∂nnen wir die Verwendung von Funktionen zur Beschreibung sich wiederholender Fragmente zur Reduzierung der Gr√∂√üe des Quellcodes und die Verwendung einer konstanten Zeichenfolge f√ºr die Datenkonvertierung beachten. </p><br><p>  Das <em>√úbertragungsproblem</em> ist unter dem Gesichtspunkt der Implementierung einer formatierten Ausgabe eines Strings interessant, in dem die Ausgabe von statischen und dynamischen Daten kombiniert wird.  Der Mechanismus selbst kann nicht als ideal angesehen werden, sondern ist eine Demonstration der M√∂glichkeiten zur Verwaltung von Handlern.  Hier k√∂nnen Sie auch auf die Neudefinition des Aktivierungssignals w√§hrend der Ausf√ºhrung achten, wodurch das Aktivierungssignal von <em>ConvS</em> auf <em>TxS</em> und umgekehrt <em>ge√§ndert wird</em> . </p><br><p>  Zum besseren Verst√§ndnis beschreiben wir den Algorithmus des Programms in Worten. </p><br><p>  Im Ausgangszustand haben wir drei Aufgaben gestartet.  Zwei von ihnen haben inaktive Signale, da das Signal f√ºr die <em>Konvertierungsaufgabe (adcSig)</em> am Ende des Lesezyklus des analogen Signals aktiviert wird und <em>ConvS</em> f√ºr die <em>√úbertragungsaufgabe</em> durch einen Code aktiviert wird, der noch nicht ausgef√ºhrt wurde.  Daher ist die erste Aufgabe, die nach dem Start gestartet wird, immer die Messung.  Der Code f√ºr diese Task startet den ADC-Konvertierungszyklus. Danach geht die 500-ms-Task in den Wartezyklus.  Am Ende des Konvertierungszyklus wird das Flag <em>adcSig aktiviert</em> , wodurch die <em>Konvertierungsaufgabe</em> <em>ausgel√∂st</em> wird.  In dieser Aufgabe wird ein Zyklus zum Konvertieren der empfangenen Daten in eine Zeichenfolge implementiert.  Vor dem Beenden der Aufgabe aktivieren wir das <em>ConvS-</em> Flag, um zu verdeutlichen, dass neue Daten an das Terminal <em>gesendet werden</em> m√ºssen.  Der Befehl exit setzt den R√ºckgabepunkt auf den Beginn der Aufgabe zur√ºck und gibt dem Dispatcher die Kontrolle.  Der <em>ConvS-</em> Flag- <em>Satz</em> erm√∂glicht die √úbertragung der Steuerung auf die <em>√úbertragungsaufgabe</em> .  Nach dem Senden des ersten Bytes der Sequenz √§ndert sich das Aktivierungssignal in der Task zu <em>TxS</em> .  Infolgedessen wird nach Abschluss der √úbertragung des Bytes die √úbertragungsaufgabe erneut aufgerufen, was zur √úbertragung des n√§chsten Bytes f√ºhrt.  Nachdem das letzte Byte der Sequenz √ºbertragen wurde, gibt die Task das <em>ConvS-</em> Aktivierungssignal zur√ºck und setzt den R√ºckgabepunkt auf den Beginn der Task zur√ºck.  Der Zyklus ist abgeschlossen.  Der n√§chste Zyklus beginnt, wenn die Messaufgabe das Warten abgeschlossen und den n√§chsten Messzyklus aktiviert hat. </p><br><p>  In fast allen Multitasking-Systemen gibt es das Konzept von Warteschlangen f√ºr die Interaktion zwischen Threads.  Wir haben bereits herausgefunden, dass die Verwendung globaler Variablen zum Datenaustausch zwischen Aufgaben durchaus m√∂glich ist, da das Wechseln zwischen Aufgaben in diesem System ein vollst√§ndig kontrollierter Prozess ist.  Es gibt jedoch eine Reihe von Aufgaben, bei denen die Verwendung von Warteschlangen gerechtfertigt ist.  Daher werden wir dieses Thema nicht au√üer Acht lassen und sehen, wie es in der Bibliothek implementiert ist. </p><br><p>  Um eine Warteschlange in einem Programm zu implementieren, verwenden Sie am besten die <em>RingBuff-</em> Klasse.  Die Klasse implementiert, wie der Name schon sagt, einen Ringpuffer mit Schreib- und Abrufbefehlen.  Das Lesen und Schreiben von Daten erfolgt √ºber die Befehle <em>Lesen</em> und <em>Schreiben</em> .  Lese- und Schreibbefehle haben keine Parameter.  Der Puffer verwendet die im Konstruktor angegebene Registervariable als Datenquelle / Empf√§nger.  Der Zugriff auf diese Variable erfolgt √ºber den Parameter <em>IOReg</em> class.  Der Status des Puffers wird durch die beiden Flags <em>Ovf</em> und <em>Empty bestimmt</em> , mit deren Hilfe der √úberlaufstatus beim Schreiben und der √úberlauf beim Lesen ermittelt werden k√∂nnen.  Dar√ºber hinaus kann die Klasse den Code ermitteln, der bei √úberlauf- / √úberlaufereignissen ausgef√ºhrt wird.  <em>RingBuff</em> hat keine Abh√§ngigkeiten von der <em>Parallel-</em> Klasse und kann separat verwendet werden.  Die Einschr√§nkung bei der Arbeit mit der Klasse ist die zul√§ssige Kapazit√§t, die aus Gr√ºnden der Codeoptimierung ein Vielfaches der Zweierpotenz (8.16.32 usw.) sein sollte. </p><br><p>  Ein Beispiel f√ºr die Arbeit mit der Klasse ist unten angegeben. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("‚Äù)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ‚Äù)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Dieser Teil schlie√üt die √úbersicht √ºber die Bibliotheksfunktionen ab.  Leider gab es eine Reihe von Aspekten bez√ºglich der F√§higkeiten der Bibliothek, die nicht einmal erw√§hnt wurden.  In Zukunft sind bei Interesse an dem Projekt Artikel geplant, die sich der L√∂sung spezifischer Probleme mithilfe der Bibliothek und einer detaillierteren Beschreibung komplexer Probleme widmen, f√ºr die eine separate Ver√∂ffentlichung erforderlich ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464651/">https://habr.com/ru/post/de464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464641/index.html">So richten Sie PVS-Studio in Travis CI am Beispiel des PSP-Spielekonsolenemulators ein</a></li>
<li><a href="../de464643/index.html">Kein einziger Scan oder wie man einen Schwachstellenmanagementprozess in 9 Schritten erstellt</a></li>
<li><a href="../de464645/index.html">So konfigurieren Sie PVS-Studio in Travis CI am Beispiel des PSP-Spielekonsolenemulators</a></li>
<li><a href="../de464647/index.html">Harry Potter Zeitung</a></li>
<li><a href="../de464649/index.html">Dokumentenkollaborationssystem f√ºr Zimbra Open-Source Edition</a></li>
<li><a href="../de464655/index.html">Wie sich die Geh√§lter und die Popularit√§t von Programmiersprachen in den letzten 2 Jahren ver√§ndert haben</a></li>
<li><a href="../de464657/index.html">Reverse Engineering elektrisches Gesims AM82TV</a></li>
<li><a href="../de464659/index.html">Anwendungssicherheit oder Einbetten von Sicherheit in die benutzerdefinierte Entwicklung. Pers√∂nliche Erfahrung bei AGIMA</a></li>
<li><a href="../de464661/index.html">Wem soll der Entwurf der technischen Umr√ºstung und des Wiederaufbaus anvertraut werden?</a></li>
<li><a href="../de464665/index.html">Partitionierung in SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>