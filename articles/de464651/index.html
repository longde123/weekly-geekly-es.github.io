<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿 😤 🐞 Assembler-Codegenerator-Bibliothek für AVR-Mikrocontroller. Teil 5 🤚🏽 🍁 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="← Teil 4. Peripheriegeräte programmieren und Interrupts behandeln 
 Assembler Code Generator Library für AVR-Mikrocontroller 
 Teil 5. Entwerfen von M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembler-Codegenerator-Bibliothek für AVR-Mikrocontroller. Teil 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">← Teil 4. Peripheriegeräte programmieren und Interrupts behandeln</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Assembler Code Generator Library für AVR-Mikrocontroller </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Teil 5. Entwerfen von Multithread-Anwendungen </h3><br><p>  In den vorherigen Teilen des Artikels haben wir die Grundlagen der Programmierung mithilfe der Bibliothek erläutert.  Im vorherigen Teil haben wir uns mit der Implementierung von Interrupts und den Einschränkungen vertraut gemacht, die bei der Arbeit mit ihnen auftreten können.  In diesem Teil des Beitrags werden wir uns mit einer der möglichen Optionen zum Programmieren paralleler Prozesse unter Verwendung der <em>Parallel-</em> Klasse <em>befassen</em> .  Die Verwendung dieser Klasse ermöglicht es, die Erstellung von Anwendungen zu vereinfachen, in denen Daten in mehreren unabhängigen Programmströmen verarbeitet werden sollen. </p><a name="habracut"></a><br><p>  Alle Multitasking-Systeme für Single-Core-Systeme sind einander ähnlich.  Multithreading wird durch die Arbeit des Dispatchers implementiert, der jedem Thread ein Zeitfenster zuweist. Wenn es beendet ist, übernimmt es die Kontrolle und gibt dem nächsten Thread die Kontrolle.  Der Unterschied zwischen den verschiedenen Implementierungen liegt nur in den Details, daher werden wir uns hauptsächlich mit den spezifischen Merkmalen dieser Implementierung befassen. </p><br><p>  Die Einheit der Prozessausführung im Thread ist die Aufgabe.  Es kann eine unbegrenzte Anzahl von Aufgaben im System vorhanden sein, aber zu einem bestimmten Zeitpunkt kann nur eine bestimmte Anzahl von Aufgaben aktiviert werden, die durch die Anzahl der Workflows im Dispatcher begrenzt ist.  In dieser Implementierung wird die Anzahl der Workflows im Manager-Konstruktor angegeben und kann anschließend nicht mehr geändert werden.  Dabei können Threads Aufgaben erledigen oder frei bleiben.  Im Gegensatz zu anderen Lösungen wechselt <em>Parallel</em> Manager keine Aufgaben.  Damit die Aufgabe die Kontrolle an den Dispatcher zurückgeben kann, müssen entsprechende Befehle in den Code eingefügt werden.  Die Verantwortung für die Dauer des Zeitfensters in der Aufgabe liegt somit beim Programmierer, der an bestimmten Stellen im Code Interrupt-Befehle einfügen muss, wenn die Aufgabe zu lange dauert, und das Verhalten des Threads nach Abschluss der Aufgabe bestimmen muss.  Der Vorteil dieses Ansatzes besteht darin, dass der Programmierer die Schaltpunkte zwischen Aufgaben steuert, wodurch Sie den Speicher- / Wiederherstellungscode beim Wechseln von Aufgaben erheblich optimieren und die meisten Probleme im Zusammenhang mit dem threadsicheren Datenzugriff beseitigen können. </p><br><p>  Um die Ausführung laufender Aufgaben zu steuern, wird eine spezielle <em>Signalklasse</em> verwendet.  Das Signal ist eine Bitvariable, deren Einstellung als Freigabesignal zum Starten einer Aufgabe in einem Stream verwendet wird.  Signalwerte können entweder manuell oder durch ein diesem Signal zugeordnetes Ereignis eingestellt werden. </p><br><p>  Das Signal wird zurückgesetzt, wenn die Aufgabe vom Dispatcher aktiviert wird oder programmgesteuert ausgeführt werden kann. </p><br><p>  Aufgaben im System können folgende Zustände haben: </p><br><p>  <strong>Deaktiviert</strong> - Ausgangszustand für alle Aufgaben.  Die Aufgabe nimmt den Ablauf nicht auf und die Ausführungskontrolle wird nicht übertragen.  Die Rückkehr in diesen Zustand für aktivierte Aufgaben erfolgt nach Abschluss des Befehls. </p><br><p>  <strong>Aktiviert</strong> - Der Status, in dem sich die Aufgabe nach der Aktivierung befindet.  Der Aktivierungsprozess ordnet eine Aufgabe einem Ausführungsthread und einem Aktivierungssignal zu.  Der Manager fragt die Threads ab und startet die Aufgabe, wenn das Aufgabensignal aktiviert ist. </p><br><p>  <strong>Blockiert</strong> - Wenn eine Aufgabe aktiviert ist, kann ihr bereits ein Signal als Signal zugewiesen werden, das bereits zur Steuerung eines anderen Threads verwendet wird.  In diesem Fall wird die aktivierte Aufgabe in den gesperrten Zustand versetzt, um die Mehrdeutigkeit des Programmverhaltens zu vermeiden.  In diesem Zustand belegt die Task den Thread, kann jedoch keine Kontrolle erhalten, selbst wenn ihr Signal aktiviert ist.  Nach Abschluss von Aufgaben oder beim Ändern des Aktivierungssignals überprüft und ändert der Dispatcher den Status von Aufgaben in den Threads.  Wenn die Threads Aufgaben blockiert haben, für die das Signal mit dem freigegebenen übereinstimmt, wird die erste gefundene aktiviert.  Bei Bedarf kann der Programmierer Aufgaben unabhängig von der erforderlichen Logik des Programms sperren und entsperren. </p><br><p>  <strong>Warten</strong> - Der Status, in dem sich die Aufgabe befindet, nachdem der Befehl <em>Verzögerung</em> ausgeführt wurde.  In diesem Zustand erhält die Aufgabe erst nach Ablauf des erforderlichen Intervalls die Kontrolle.  In der <em>Parallel-</em> Klasse werden 16-ms-WDT-Interrupts verwendet, um die Verzögerung zu steuern, wodurch Zeitgeber für Systemanforderungen nicht belegt werden können.  Wenn Sie in kleinen Intervallen mehr Stabilität oder Auflösung benötigen <em>, können</em> Sie anstelle der <em>Verzögerung</em> die Aktivierung durch Timersignale verwenden.  Es ist zu beachten, dass die Verzögerungsgenauigkeit immer noch gering ist und im Bereich von <em>"Dispatcher-Antwortzeit" - "maximale Zeitschlitzdauer im System + Dispatcher-Antwortzeit"</em> schwankt.  Für Aufgaben mit genauen Zeitbereichen sollten Sie den Hybridmodus verwenden, in dem der Timer, der in der <em>Parallel-</em> Klasse nicht verwendet wird, unabhängig vom Aufgabenablauf arbeitet und Intervalle im reinen Interrupt-Modus verarbeitet. </p><br><p>  Jede in einem Thread ausgeführte Aufgabe ist ein isolierter Prozess.  Dies erfordert die Definition von zwei Datentypen: lokale Daten eines Streams, die nur im Rahmen dieses Streams sichtbar sein und geändert werden sollten, und globale Daten für den Austausch zwischen Flows und den Zugriff auf gemeinsam genutzte Ressourcen.  Im Rahmen dieser Implementierung werden globale Daten durch zuvor berücksichtigte Befehle auf Geräteebene erstellt.  Um lokale Aufgabenvariablen zu erstellen, müssen sie mit Methoden aus der Aufgabenklasse erstellt werden.  Das Verhalten der lokalen Taskvariablen ist wie folgt: Wenn die Task unterbrochen wird, bevor die Steuerung an den Dispatcher übertragen wird, werden alle lokalen Registervariablen im Speicher des Streams gespeichert.  Wenn die Steuerung zurückgegeben wird, werden die lokalen Registervariablen wiederhergestellt, bevor der nächste Befehl ausgeführt wird. <br>  Eine Klasse mit der <em>IHeap-</em> Schnittstelle, die der <em>Heap-</em> Eigenschaft der <em>Parallel-</em> Klasse zugeordnet ist, ist für das Speichern lokaler Daten des Streams verantwortlich.  Die einfachste Implementierung dieser Klasse ist <em>StaticHeap</em> , die die statische Zuordnung derselben Speicherblöcke für jeden Thread implementiert.  <em>Wenn</em> die Aufgaben je nach Bedarf an lokaler Datenmenge sehr unterschiedlich sind, können Sie <em>DynamicHeap verwenden</em> , mit dem Sie die Größe des lokalen Speichers für jede Aufgabe einzeln bestimmen können.  Offensichtlich ist der Aufwand für die Arbeit mit dem Stream-Speicher in diesem Fall erheblich höher. </p><br><p>  Schauen wir uns nun die Klassensyntax am Beispiel von zwei Streams genauer an, von denen jeder unabhängig einen separaten Portausgang schaltet. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  Die obersten Zeilen des Programms sind Ihnen bereits bekannt.  In ihnen bestimmen wir den Reglertyp und weisen das erste und zweite Bit von Port B als Ausgang zu.  Als nächstes folgt die Initialisierung einer Variablen der <em>Parallel-</em> Klasse, wobei wir im zweiten Parameter die maximale Anzahl von Ausführungsthreads bestimmen.  In der nächsten Zeile weisen wir Speicher zu, um lokale Variablenflüsse aufzunehmen.  Wir haben gleiche Aufgaben, also verwenden wir <em>StaticHeap</em> .  Der nächste Codeblock ist die Aufgabendefinition.  Darin definieren wir zwei nahezu identische Aufgaben.  Der einzige Unterschied ist der Steuerport und die Verzögerung.  Um mit lokalen Aufgabenobjekten zu arbeiten, wird ein Zeiger auf die lokale Aufgabe <em>tsk</em> an den Aufgabencodeblock übergeben.  Der Aufgabentext selbst ist sehr einfach: </p><br><ul><li>  Ein lokales Label wird erstellt, um einen unendlichen Schaltzyklus zu organisieren </li><li>  Portstatus ist umgekehrt </li><li>  Die Steuerung wird an den Dispatcher zurückgegeben, und die Task wird für die angegebene Anzahl von Millisekunden in den Wartestatus versetzt </li><li>  Der Rückgabezeiger wird auf den Startblock des Blocks gesetzt und die Steuerung an den Dispatcher zurückgegeben. <br>  In einem konkreten Beispiel könnte der letzte Befehl natürlich durch einen normalen Befehl ersetzt werden, der an den Anfang des Blocks geht und im Beispiel nur zum Zwecke der Demonstration angegeben wird.  Falls gewünscht, kann das Beispiel leicht erweitert werden, um eine große Anzahl von Schlussfolgerungen zu steuern, indem Aufgaben kopiert und die Anzahl der Threads erhöht werden. </li></ul><br><p>  Eine vollständige Liste der Task-Abbruchbefehle zum Übertragen der Steuerung an den Dispatcher lautet wie folgt <br>  <strong>AWAIT (Signal)</strong> - Der Stream speichert alle Variablen im Speicher des Streams und überträgt die Kontrolle an den Dispatcher.  Bei der nächsten Aktivierung des Streams werden die Variablen wiederhergestellt und die Ausführung fortgesetzt, beginnend mit der nächsten Anweisung nach <em>AWAIT</em> .  Der Befehl dient dazu, die Aufgabe in Zeitschlitze zu unterteilen und die Zustandsmaschine gemäß dem Schema <em>Signal → Verarbeitung 1 → Signal → Verarbeitung 2</em> usw. zu implementieren. </p><br><p>  Der Befehl AWAIT kann ein Signal als optionalen Parameter haben.  Wenn der Parameter leer ist, wird das Aktivierungssignal gespeichert.  Wenn es im Parameter angegeben ist, werden alle nachfolgenden Taskaufrufe ausgeführt, wenn das angegebene Signal aktiviert wird und die Kommunikation mit dem vorherigen Signal unterbrochen wird. </p><br><p>  <strong>TaskContinue (Label, Signal)</strong> - Der Befehl beendet den Stream und gibt dem Dispatcher die Kontrolle, ohne Variablen zu speichern.  Bei der nächsten Aktivierung des Streams wird die Kontrolle auf das <em>Etikettenetikett übertragen</em> .  Mit dem optionalen Parameter <em>Signal</em> können Sie das Stream-Aktivierungssignal für den nächsten Anruf überschreiben.  Wenn nicht angegeben, bleibt das Signal gleich.  Ein Befehl ohne Angabe eines Signals kann verwendet werden, um Zyklen innerhalb einer einzelnen Aufgabe zu organisieren, wobei jeder Zyklus in einem separaten Zeitfenster ausgeführt wird.  Es kann auch verwendet werden, um dem aktuellen Thread nach Abschluss des vorherigen Threads eine neue Aufgabe zuzuweisen.  Der Vorteil dieses Ansatzes gegenüber dem Zyklus <em>Freigeben eines Threads → Hervorheben eines Streams</em> ist ein effizienteres Programm.  Durch die Verwendung von <em>TaskContinue</em> muss der Manager nicht mehr nach einem freien Thread im Pool suchen und garantiert Fehler beim Zuweisen von Threads ohne freie Threads. </p><br><p>  <strong>TaskEnd ()</strong> - <strong>Löscht</strong> den Stream nach Abschluss der Aufgabe.  Die Aufgabe endet, der Thread wird freigegeben und kann verwendet werden, um mit dem Befehl <em>Aktivieren</em> eine neue Aufgabe zuzuweisen. </p><br><p>  <strong>Verzögerung (ms)</strong> - Der Stream speichert wie bei der Verwendung von <em>AWAIT</em> alle Variablen im Speicher des Streams und überträgt die Steuerung an den Dispatcher.  In diesem Fall wird der Verzögerungswert in Millisekunden im Stream-Header aufgezeichnet.  In der Dispatcher-Schleife wird bei einem Wert ungleich Null im Verzögerungsfeld der Fluss nicht aktiviert.  Das Ändern der Werte im Verzögerungsfeld für alle Flüsse erfolgt durch Unterbrechen des WDT-Timers alle 16 ms.  Wenn der Nullwert erreicht ist, wird das Ausführungsverbot aufgehoben und das Stream-Aktivierungssignal gesetzt.  Im Header wird nur ein Einzelbyte-Wert für die Verzögerung gespeichert, was einen relativ engen Bereich möglicher Verzögerungen ergibt. Um längere Verzögerungen zu implementieren, erstellt <em>Delay ()</em> eine interne Schleife unter Verwendung lokaler Stream-Variablen. <br>  Die Aktivierung der Befehle im Beispiel erfolgt mit den Befehlen <em>ContinuousActivate</em> und <em>ActivateNext</em> .  Dies ist eine spezielle Art der anfänglichen Aufgabenaktivierung beim Start.  In der ersten Aktivierungsphase ist garantiert kein einziger ausgelasteter Thread vorhanden, sodass für den Aktivierungsprozess keine vorläufige Suche nach einem freien Thread für eine Aufgabe erforderlich ist und Sie Aufgaben nacheinander aktivieren können.  <em>ContinuousActivate</em> aktiviert die Aufgabe im Null-Thread und gibt einen Zeiger auf den Header des nächsten Threads zurück. Die <em>ActivateNext-</em> Funktion verwendet diesen Zeiger, um die folgenden Aufgaben in sequentiellen Threads zu aktivieren. </p><br><p>  Im Beispiel wird als Aktivierungssignal das <em>AlwaysOn-</em> Signal verwendet.  Dies ist eines der Systemsignale.  Sein Zweck bedeutet, dass die Aufgabe immer ausgeführt wird, da dies das einzige Signal ist, das immer aktiviert ist und nicht durch Verwendung zurückgesetzt wird. </p><br><p>  Das Beispiel endet mit einem <em>Loop-</em> Aufruf.  Diese Funktion startet den Dispatcher-Zyklus, daher sollte dieser Befehl der letzte im Code sein. </p><br><p>  Stellen Sie sich ein weiteres Beispiel vor, bei dem die Verwendung der Bibliothek die Struktur des Codes erheblich vereinfachen kann.  Es sei ein bedingtes Steuergerät, das ein analoges Signal registriert und es in Form eines HEX-Codes an das Terminal sendet. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Das soll nicht heißen, dass wir hier viele neue Dinge gesehen haben, aber Sie können etwas Interessantes in diesem Code sehen. </p><br><p>  In diesem Beispiel wird zuerst der ADC (Analog-Digital-Wandler) erwähnt.  Dieses Peripheriegerät dient zur Umwandlung der Spannung des Eingangssignals in einen digitalen Code.  Der Konvertierungszyklus wird von der <em>ConvertAsync-</em> Funktion <em>gestartet</em> , die den Prozess nur startet, ohne auf das Ergebnis zu warten.  Wenn die Konvertierung abgeschlossen ist, generiert der ADC einen Interrupt, der das <em>adcSig-</em> Signal aktiviert.  <em>Achten Sie</em> auf die Definition des <em>adcSig-</em> Signals.  Neben dem Interrupt-Zeiger enthält er auch einen Codeblock zum Speichern von Werten aus dem ADC-Datenregister.  Der gesamte Code, der vorzugsweise unmittelbar nach einem Interrupt ausgeführt wird (z. B. Lesen von Daten aus Geräteregistern), sollte sich an dieser Stelle befinden. <br>  Die <em>Konvertierungsaufgabe</em> besteht darin, einen binären Spannungscode in eine vierstellige HEX-Darstellung für unser bedingtes Terminal zu konvertieren.  Hier können wir die Verwendung von Funktionen zur Beschreibung sich wiederholender Fragmente zur Reduzierung der Größe des Quellcodes und die Verwendung einer konstanten Zeichenfolge für die Datenkonvertierung beachten. </p><br><p>  Das <em>Übertragungsproblem</em> ist unter dem Gesichtspunkt der Implementierung einer formatierten Ausgabe eines Strings interessant, in dem die Ausgabe von statischen und dynamischen Daten kombiniert wird.  Der Mechanismus selbst kann nicht als ideal angesehen werden, sondern ist eine Demonstration der Möglichkeiten zur Verwaltung von Handlern.  Hier können Sie auch auf die Neudefinition des Aktivierungssignals während der Ausführung achten, wodurch das Aktivierungssignal von <em>ConvS</em> auf <em>TxS</em> und umgekehrt <em>geändert wird</em> . </p><br><p>  Zum besseren Verständnis beschreiben wir den Algorithmus des Programms in Worten. </p><br><p>  Im Ausgangszustand haben wir drei Aufgaben gestartet.  Zwei von ihnen haben inaktive Signale, da das Signal für die <em>Konvertierungsaufgabe (adcSig)</em> am Ende des Lesezyklus des analogen Signals aktiviert wird und <em>ConvS</em> für die <em>Übertragungsaufgabe</em> durch einen Code aktiviert wird, der noch nicht ausgeführt wurde.  Daher ist die erste Aufgabe, die nach dem Start gestartet wird, immer die Messung.  Der Code für diese Task startet den ADC-Konvertierungszyklus. Danach geht die 500-ms-Task in den Wartezyklus.  Am Ende des Konvertierungszyklus wird das Flag <em>adcSig aktiviert</em> , wodurch die <em>Konvertierungsaufgabe</em> <em>ausgelöst</em> wird.  In dieser Aufgabe wird ein Zyklus zum Konvertieren der empfangenen Daten in eine Zeichenfolge implementiert.  Vor dem Beenden der Aufgabe aktivieren wir das <em>ConvS-</em> Flag, um zu verdeutlichen, dass neue Daten an das Terminal <em>gesendet werden</em> müssen.  Der Befehl exit setzt den Rückgabepunkt auf den Beginn der Aufgabe zurück und gibt dem Dispatcher die Kontrolle.  Der <em>ConvS-</em> Flag- <em>Satz</em> ermöglicht die Übertragung der Steuerung auf die <em>Übertragungsaufgabe</em> .  Nach dem Senden des ersten Bytes der Sequenz ändert sich das Aktivierungssignal in der Task zu <em>TxS</em> .  Infolgedessen wird nach Abschluss der Übertragung des Bytes die Übertragungsaufgabe erneut aufgerufen, was zur Übertragung des nächsten Bytes führt.  Nachdem das letzte Byte der Sequenz übertragen wurde, gibt die Task das <em>ConvS-</em> Aktivierungssignal zurück und setzt den Rückgabepunkt auf den Beginn der Task zurück.  Der Zyklus ist abgeschlossen.  Der nächste Zyklus beginnt, wenn die Messaufgabe das Warten abgeschlossen und den nächsten Messzyklus aktiviert hat. </p><br><p>  In fast allen Multitasking-Systemen gibt es das Konzept von Warteschlangen für die Interaktion zwischen Threads.  Wir haben bereits herausgefunden, dass die Verwendung globaler Variablen zum Datenaustausch zwischen Aufgaben durchaus möglich ist, da das Wechseln zwischen Aufgaben in diesem System ein vollständig kontrollierter Prozess ist.  Es gibt jedoch eine Reihe von Aufgaben, bei denen die Verwendung von Warteschlangen gerechtfertigt ist.  Daher werden wir dieses Thema nicht außer Acht lassen und sehen, wie es in der Bibliothek implementiert ist. </p><br><p>  Um eine Warteschlange in einem Programm zu implementieren, verwenden Sie am besten die <em>RingBuff-</em> Klasse.  Die Klasse implementiert, wie der Name schon sagt, einen Ringpuffer mit Schreib- und Abrufbefehlen.  Das Lesen und Schreiben von Daten erfolgt über die Befehle <em>Lesen</em> und <em>Schreiben</em> .  Lese- und Schreibbefehle haben keine Parameter.  Der Puffer verwendet die im Konstruktor angegebene Registervariable als Datenquelle / Empfänger.  Der Zugriff auf diese Variable erfolgt über den Parameter <em>IOReg</em> class.  Der Status des Puffers wird durch die beiden Flags <em>Ovf</em> und <em>Empty bestimmt</em> , mit deren Hilfe der Überlaufstatus beim Schreiben und der Überlauf beim Lesen ermittelt werden können.  Darüber hinaus kann die Klasse den Code ermitteln, der bei Überlauf- / Überlaufereignissen ausgeführt wird.  <em>RingBuff</em> hat keine Abhängigkeiten von der <em>Parallel-</em> Klasse und kann separat verwendet werden.  Die Einschränkung bei der Arbeit mit der Klasse ist die zulässige Kapazität, die aus Gründen der Codeoptimierung ein Vielfaches der Zweierpotenz (8.16.32 usw.) sein sollte. </p><br><p>  Ein Beispiel für die Arbeit mit der Klasse ist unten angegeben. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("”)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ”)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Dieser Teil schließt die Übersicht über die Bibliotheksfunktionen ab.  Leider gab es eine Reihe von Aspekten bezüglich der Fähigkeiten der Bibliothek, die nicht einmal erwähnt wurden.  In Zukunft sind bei Interesse an dem Projekt Artikel geplant, die sich der Lösung spezifischer Probleme mithilfe der Bibliothek und einer detaillierteren Beschreibung komplexer Probleme widmen, für die eine separate Veröffentlichung erforderlich ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464651/">https://habr.com/ru/post/de464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464641/index.html">So richten Sie PVS-Studio in Travis CI am Beispiel des PSP-Spielekonsolenemulators ein</a></li>
<li><a href="../de464643/index.html">Kein einziger Scan oder wie man einen Schwachstellenmanagementprozess in 9 Schritten erstellt</a></li>
<li><a href="../de464645/index.html">So konfigurieren Sie PVS-Studio in Travis CI am Beispiel des PSP-Spielekonsolenemulators</a></li>
<li><a href="../de464647/index.html">Harry Potter Zeitung</a></li>
<li><a href="../de464649/index.html">Dokumentenkollaborationssystem für Zimbra Open-Source Edition</a></li>
<li><a href="../de464655/index.html">Wie sich die Gehälter und die Popularität von Programmiersprachen in den letzten 2 Jahren verändert haben</a></li>
<li><a href="../de464657/index.html">Reverse Engineering elektrisches Gesims AM82TV</a></li>
<li><a href="../de464659/index.html">Anwendungssicherheit oder Einbetten von Sicherheit in die benutzerdefinierte Entwicklung. Persönliche Erfahrung bei AGIMA</a></li>
<li><a href="../de464661/index.html">Wem soll der Entwurf der technischen Umrüstung und des Wiederaufbaus anvertraut werden?</a></li>
<li><a href="../de464665/index.html">Partitionierung in SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>