<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™ï¸ ğŸ… ğŸ§™ğŸ» Toute la vÃ©ritÃ© sur RTOS. Article # 9. Scheduler: implÃ©mentation ğŸ¥“ ğŸ›€ğŸ¾ ğŸ™ŒğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les principes de base du travail des planificateurs RTOS ont Ã©tÃ© examinÃ©s dans l'article Â«TÃ¢ches et planificationÂ». Dans cet article, nous examinerons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vÃ©ritÃ© sur RTOS. Article # 9. Scheduler: implÃ©mentation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422615/"><img src="https://habrastorage.org/webt/fe/zo/8m/fezo8mtb5js9kb_juvdmxayq1fa.jpeg"><br><p>  Les principes de base du travail des planificateurs RTOS ont Ã©tÃ© examinÃ©s dans l'article Â«TÃ¢ches et planificationÂ».  Dans cet article, nous examinerons plus en dÃ©tail les fonctionnalitÃ©s proposÃ©es par Nucleus RTOS, ainsi que celles fournies par Nucleus SE. </p><a name="habracut"></a><br><p> Articles prÃ©cÃ©dents de la sÃ©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et dÃ©ploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tÃ¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TÃ¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TÃ¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps rÃ©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </p><br><h2>  Planification chez Nucleus RTOS </h2><br><p>  Ã‰tant donnÃ© que Nucleus RTOS est un RTOS commercial Ã  part entiÃ¨re et bien Ã©tabli, nous pouvons supposer en toute sÃ©curitÃ© que l'ordonnanceur a Ã©tÃ© dÃ©veloppÃ© conformÃ©ment aux exigences d'un tel produit.  Ce systÃ¨me d'exploitation complexe et flexible offre au dÃ©veloppeur un large Ã©ventail de capacitÃ©s pour rÃ©soudre presque toutes les tÃ¢ches de programmation en temps rÃ©el imaginables. </p><br><p>  Le planificateur peut prendre en charge un nombre illimitÃ© de tÃ¢ches (limitÃ© uniquement par les ressources disponibles) et travailler avec la gestion des prioritÃ©s.  La tÃ¢che peut Ãªtre affectÃ©e d'une prioritÃ© de 0 Ã  255, oÃ¹ 0 est la prioritÃ© la plus Ã©levÃ©e et 255 la plus faible.  Une tÃ¢che a une prioritÃ© dynamique, c'est-Ã -dire qu'elle peut Ãªtre modifiÃ©e au moment de l'exÃ©cution par la tÃ¢che elle-mÃªme ou par une autre.  Plusieurs tÃ¢ches peuvent se voir attribuer le mÃªme niveau de prioritÃ©.  Dans un cas extrÃªme, toutes les tÃ¢ches peuvent se voir attribuer la mÃªme prioritÃ©, ce qui permet de mettre en Å“uvre une politique de planification sur le principe du Round Robin et du Time-Slice. <br>  S'il y a plusieurs tÃ¢ches avec la mÃªme prioritÃ©, elles seront planifiÃ©es en utilisant l'algorithme Round Robin dans l'ordre dans lequel elles ont Ã©tÃ© prÃ©parÃ©es.  La tÃ¢che doit suspendre ou transfÃ©rer le contrÃ´le pour que la tÃ¢che suivante dÃ©marre.  Des tÃ¢ches peuvent Ã©galement Ãªtre affectÃ©es Ã  des intervalles de temps qui offrent une sÃ©paration plus contrÃ´lÃ©e du temps processeur disponible. </p><br><p>  La planification des tÃ¢ches est dÃ©terministe Ã  100%, ce qui est attendu d'un noyau similaire.  Les tÃ¢ches peuvent Ã©galement Ãªtre crÃ©Ã©es et dÃ©truites dynamiquement, ce qui, grÃ¢ce au planificateur, passe inaperÃ§u par l'utilisateur. </p><br><h2>  Planification chez Nucleus SE </h2><br><p>  J'ai dÃ©veloppÃ© tous les aspects de Nucleus SE afin qu'ils soient gÃ©nÃ©ralement compatibles avec Nucleus RTOS, mais aussi plus simples et plus efficaces en termes de mÃ©moire.  Le planificateur ne fait pas exception.  Il fournit de nombreuses fonctionnalitÃ©s du planificateur Nucleus RTOS, mais est quelque peu limitÃ©.  La flexibilitÃ© est obtenue grÃ¢ce Ã  la configuration lors de l'assemblage. <br>  Une application Nucleus SE peut avoir un maximum de 16 tÃ¢ches (et au moins une).  Bien que thÃ©oriquement ce nombre puisse Ãªtre augmentÃ©, l'efficacitÃ© des algorithmes sera menacÃ©e;  un certain nombre de structures de donnÃ©es reposent sur le stockage du numÃ©ro d'index de tÃ¢che (de 0 Ã  15) dans un quartet (quatre bits), et elles devront Ãªtre traitÃ©es avec le code correspondant. </p><br><p>  Pour atteindre un Ã©quilibre entre flexibilitÃ© et simplicitÃ© (et taille), au lieu d'avoir un planificateur avec plusieurs capacitÃ©s, Nucleus SE propose l'un des quatre types de planificateurs au choix: ExÃ©cuter vers le composant (RTC), Round Robin (RR), Time-Slice ( TS) et Priority.  L'ordonnanceur est sÃ©lectionnÃ© statiquement au moment de l'assemblage.  Les dÃ©tails sur chaque type de planificateur sont dÃ©crits ci-dessous dans la section "Types de planificateur". </p><br><p>  Comme tout autre aspect de Nucleus SE, les tÃ¢ches sont des objets statiques.  Ils sont dÃ©terminÃ©s lors de la configuration et leur prioritÃ© (index) ne peut pas Ãªtre modifiÃ©e. </p><br><h2>  Planificateurs Nucleus SE </h2><br><p>  Comme indiquÃ© ci-dessus, Nucleus SE propose l'un des quatre types d'ordonnanceurs parmi lesquels choisir.  Comme la plupart des aspects de la configuration de Nucleus SE, ce choix est dÃ©terminÃ© en Ã©crivant dans <b>nuse_config.h,</b> le paramÃ¨tre <b>NUSE_SCHEDULER_TYPE</b> doit Ãªtre dÃ©fini en consÃ©quence, comme indiquÃ© dans ce fragment du fichier de configuration: </p><br><img src="https://habrastorage.org/webt/u8/ln/su/u8lnsu8ido7iqwna4a_nw1tblqc.jpeg"><br><p>  Quel que soit le planificateur sÃ©lectionnÃ©, son code de dÃ©marrage est appelÃ© immÃ©diatement aprÃ¨s l'initialisation du systÃ¨me.  Des informations complÃ¨tes sur l'initialisation de Nucleus SE seront prÃ©sentÃ©es dans le prochain article. </p><br><h3>  Run to Completion Scheduler </h3><br><p>  Le RTC Scheduler est la solution la plus simple et la plus appropriÃ©e s'il rÃ©pond aux exigences de l'application.  Chaque tÃ¢che doit terminer son travail avant d'exÃ©cuter la fonction de retour et de permettre au planificateur de terminer la tÃ¢che suivante. </p><br><p>  Il n'est pas nÃ©cessaire d'avoir une pile distincte pour chaque tÃ¢che.  Tout le code est Ã©crit en C, le langage d'assemblage n'est pas requis.  Vous trouverez ci-dessous l'intÃ©gralitÃ© du code du planificateur RTC. </p><br><img src="https://habrastorage.org/webt/lk/vf/z4/lkvfz4furcpo5bxyuwojbnmzkpq.jpeg"><br><p>  Le code est juste une boucle sans fin qui Ã  tour de rÃ´le appelle chaque tÃ¢che.  Le <b>tableau NUSE_Task_Start_Address []</b> contient des pointeurs vers la fonction externe de chaque tÃ¢che.  La macro PF0 est une simple conversion d'un pointeur <b>void</b> en un pointeur vers une fonction <b>void</b> sans paramÃ¨tre.  Il est conÃ§u pour assurer la lisibilitÃ© du code. <br>  La compilation conditionnelle est utilisÃ©e pour activer la prise en charge de fonctions supplÃ©mentaires: <b>NUSE_SUSPEND_ENABLE</b> dÃ©termine si les tÃ¢ches peuvent Ãªtre suspendues;  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> dÃ©termine si une valeur de compteur est requise chaque fois qu'une tÃ¢che est planifiÃ©e.  Vous trouverez plus d'informations Ã  ce sujet dans le prochain article. </p><br><h3>  Scheduler Round Robin </h3><br><p>  Si un peu plus de flexibilitÃ© est requise que celle fournie par l'ordonnanceur RTC, l'ordonnanceur RR convient.  Il permet Ã  la tÃ¢che de transfÃ©rer le contrÃ´le ou la pause, puis de continuer Ã  partir du mÃªme point.  La surcharge supplÃ©mentaire, en plus de la complexitÃ© du code et de la non-portabilitÃ©, est que chaque tÃ¢che nÃ©cessite sa propre pile. <br>  Le code du planificateur se compose de deux parties.  Le composant de lancement est le suivant: </p><br><img src="https://habrastorage.org/webt/-j/83/7r/-j837r3mppxr_3xjpeeazjsuwgc.jpeg"><br><p>  Si la prise en charge de l'Ã©tat initial de la tÃ¢che est activÃ©e (Ã  l'aide du paramÃ¨tre <b>NUSE_INITIAL_TASK_STATE_SUPPOR</b> T, voir Â«ParamÃ¨tresÂ» dans l'article suivant), la planification commence Ã  partir de la premiÃ¨re tÃ¢che terminÃ©e;  sinon, une tÃ¢che d'index 0 est utilisÃ©e. Le contexte de cette tÃ¢che est ensuite chargÃ© Ã  l'aide de <b>NUSE_Context_Load ()</b> .  Pour plus d'informations sur l'enregistrement et la restauration d'un contexte, consultez la section Â«Enregistrement du contexteÂ» dans l'article suivant. </p><br><p>  La deuxiÃ¨me partie de l'ordonnanceur est le composant Â«re-planningÂ»: </p><br><img src="https://habrastorage.org/webt/zb/rz/-k/zbrz-ku365uguee3z989gq4-pd8.jpeg"><br><p>  Ce code est appelÃ© lorsque la tÃ¢che libÃ¨re le processeur central ou fait une pause. </p><br><p>  Le code sÃ©lectionne la tÃ¢che avec l'index suivant pour dÃ©marrer et place la valeur dans <b>NUSE_Task_Next,</b> en tenant compte du fait que la suspension de la tÃ¢che est activÃ©e ou non.  La macro <b>NUSE_CONTEXT_SWAP ()</b> est ensuite utilisÃ©e pour appeler la commutation de contexte Ã  l'aide d'une interruption logicielle.  Pour plus d'informations sur l'enregistrement et la restauration d'un contexte, consultez la section Â«Enregistrement du contexteÂ» dans l'article suivant. </p><br><h3>  Planificateur de prioritÃ©s </h3><br><p>  Le planificateur de prioritÃ©s de Nucleus SE, comme les autres options, est conÃ§u pour fournir les fonctionnalitÃ©s requises, tout en Ã©tant assez simple.  Par consÃ©quent, chaque tÃ¢che a une prioritÃ© unique, il est impossible d'avoir plusieurs tÃ¢ches avec un niveau de prioritÃ©.  La prioritÃ© est dÃ©terminÃ©e par l'index de la tÃ¢che, oÃ¹ 0 est le niveau de prioritÃ© le plus Ã©levÃ©.  L'index de la tÃ¢che est dÃ©terminÃ© par son emplacement dans le <b>tableau NUSE_Task_Start_Address [].</b>  Le prochain article fournira des informations plus dÃ©taillÃ©es sur la configuration des tÃ¢ches. </p><br><p>  Comme les ordonnanceurs RR et TS, l'ordonnanceur prioritaire a deux composants.  Le composant de dÃ©marrage du planificateur prioritaire est le mÃªme que les planificateurs RR et TS, comme illustrÃ© ci-dessus.  La composante de rÃ©Ã©chelonnement est lÃ©gÃ¨rement diffÃ©rente: </p><br><img src="https://habrastorage.org/webt/eu/6v/n6/eu6vn6zlqoex1bacs9r1iwq4c4u.jpeg"><br><p>  Il n'y a pas de code conditionnel qui pourrait dÃ©sactiver la suspension des tÃ¢ches, car cette fonctionnalitÃ© est obligatoire pour le planificateur de prioritÃ©;  toute alternative serait illogique.  La fonction <b>NUSE_Reschedule ()</b> accepte un paramÃ¨tre qui Â«indiqueÂ» quelle tÃ¢che peut Ãªtre planifiÃ©e ensuite - <b>new_task.</b>  Cette valeur est dÃ©finie lorsque la replanification est invoquÃ©e car une autre tÃ¢che est invoquÃ©e.  L'index de cette tÃ¢che est transmis en tant que paramÃ¨tre.  Le planificateur peut alors dÃ©terminer s'il faut effectuer un changement de contexte en comparant la valeur de <b>new_task</b> avec l'index de la tÃ¢che en cours <b>(NUSE_Task_Active)</b> .  Si la replanification est le rÃ©sultat d'une pause de tÃ¢che, le paramÃ¨tre sera dÃ©fini sur <b>NUSE_NO_TASK</b> et le planificateur recherchera la tÃ¢che avec la prioritÃ© la plus Ã©levÃ©e. </p><br><h2>  Ã‰tats des tÃ¢ches </h2><br><p>  En rÃ¨gle gÃ©nÃ©rale, tous les systÃ¨mes d'exploitation ont le concept de trouver des tÃ¢ches dans un certain Â«Ã©tatÂ».  Les dÃ©tails varient en fonction du RTOS.  Dans cet article, nous verrons comment Nucleus RTOS et Nucleus SE utilisent les Ã©tats de tÃ¢che. </p><br><h3>  Ã‰tats des tÃ¢ches Nucleus RTOS </h3><br><p>  Nucleus RTOS prend en charge 5 Ã©tats de tÃ¢che. </p><br><ul><li>  ExÃ©cution: tÃ¢che qui gÃ¨re actuellement le processeur.  Ã‰videmment, une seule tÃ¢che peut occuper cet Ã©tat. </li><li>  PrÃ©paration: tÃ¢che prÃªte Ã  Ãªtre exÃ©cutÃ©e (ou Ã  poursuivre) avant que le planificateur ne dÃ©cide de la lancer.  En rÃ¨gle gÃ©nÃ©rale, une tÃ¢che a une prioritÃ© infÃ©rieure Ã  celle en cours d'exÃ©cution. </li><li>  Suspension: la tÃ¢che "dormir".  Il n'est pas pris en compte lors de la planification jusqu'Ã  ce qu'il se rÃ©veille, et Ã  ce moment il sera Â«prÃªtÂ» et pourra continuer Ã  s'exÃ©cuter plus tard.  Habituellement, une tÃ¢che est dans un Ã©tat de Â«sommeilÂ» car elle attend quelque chose: lorsque la ressource devient disponible, lorsque la pÃ©riode de temps dÃ©finie expire ou lorsqu'une autre tÃ¢che la rÃ©veille. </li><li>  Annuler: la tÃ¢che a Ã©tÃ© Â«tuÃ©eÂ».  Il n'est pas pris en compte lors de la planification tant qu'il n'est pas rÃ©initialisÃ©, aprÃ¨s quoi la tÃ¢che sera Â«prÃªteÂ» ou Â«suspendueÂ». </li><li>  Fin: la tÃ¢che est terminÃ©e et a quittÃ© sa fonction externe en quittant simplement l'unitÃ© externe ou en exÃ©cutant l'instruction return.  Il n'est pas pris en compte lors de la planification tant qu'il n'est pas rÃ©initialisÃ©, aprÃ¨s quoi la tÃ¢che sera Â«prÃªteÂ» ou Â«suspendueÂ». </li></ul>  Ã‰tant donnÃ© que Nucleus RTOS prend en charge la crÃ©ation et la destruction dynamiques d'objets, y compris des tÃ¢ches, la tÃ¢che peut Ã©galement Ãªtre considÃ©rÃ©e dans un Ã©tat Â«distantÂ».  Cependant, dÃ¨s que la tÃ¢che est supprimÃ©e, toutes ses ressources systÃ¨me cessent d'exister et la tÃ¢che elle-mÃªme n'existe plus, elle ne peut pas avoir d'Ã©tat.  Le code de tÃ¢che peut Ãªtre disponible, mais l'objet de tÃ¢che doit Ãªtre recrÃ©Ã©. <br><br><h3>  Ã‰tats des tÃ¢ches dans Nucleus SE </h3><br>  Le modÃ¨le d'Ã©tat de tÃ¢che dans Nucleus SE est un peu plus simple.  Habituellement, il n'y a que 3 Ã©tats: exÃ©cution, disponibilitÃ© et pause.  Le statut de chaque tÃ¢che est stockÃ© dans <b>NUSE_Task_Status []</b> , qui a des valeurs de type <b>NUSE_READY</b> , bien qu'il n'ait jamais de valeur qui reflÃ¨te le statut d'exÃ©cution.  Si la suspension de tÃ¢che n'est pas activÃ©e (voir Â«OptionsÂ» dans l'article suivant), seuls deux Ã©tats de tÃ¢che sont possibles et ce tableau est absent. <br><br>  Il existe plusieurs types de tÃ¢ches de pause.  Si une tÃ¢che est explicitement suspendue par elle-mÃªme ou par une autre tÃ¢che, cela s'appelle une Â«suspension pureÂ» et est reprÃ©sentÃ© par le statut NUSE_PURE_SUSPEND.  Si l'Ã©tat Â«veilleÂ» est activÃ© et que la tÃ¢che est suspendue pendant un certain temps, elle a le statut <br>  <b>NUSE_SLEEP_SUSPEND</b> .  Si la fonction de blocage des appels d'API est activÃ©e (via <b>NUSE_BLOCKING_ENABLE</b> , voir Â«ParamÃ¨tresÂ» dans l'article suivant), la tÃ¢che peut Ãªtre suspendue jusqu'Ã  ce que la ressource devienne disponible.  Chaque type d'objet a son propre Ã©tat de suspension de tÃ¢che, par exemple sous la forme <b>NUSE_MAILBOX_SUSPEND.</b>  Dans Nucleus SE, une tÃ¢che peut Ãªtre verrouillÃ©e dans une partition de mÃ©moire, un groupe d'Ã©vÃ©nements, une boÃ®te aux lettres, une file d'attente, un canal ou un sÃ©maphore. <br><br><h3>  Statut du fil </h3><br>  Lorsque vous discutez du comportement d'une tÃ¢che, les mots Â«StatutÂ» et Â«StatutÂ» sont gÃ©nÃ©ralement utilisÃ©s assez librement.  Il existe un facteur supplÃ©mentaire, que l'on peut conditionnellement appeler Â«l'Ã©tat du fluxÂ».  Il s'agit de la variable globale <b>NUSE_Thread_State,</b> qui contient une indication de la nature du code en cours d'exÃ©cution.  Cela s'applique au comportement de nombreux appels d'API.  Valeurs possibles: <br><br><ul><li>  <b>NUSE_TASK_CONTEXT</b> - L'appel d'API a Ã©tÃ© effectuÃ© Ã  partir d'une tÃ¢che. </li><li>  <b>NUSE_STARTUP_CONTEXT</b> - l'appel d'API a Ã©tÃ© effectuÃ© Ã  partir du code de dÃ©marrage;  le planificateur n'a pas encore Ã©tÃ© dÃ©marrÃ©. </li><li>  <b>NUSE_NISR_CONTEXT et NUSE_MISR_CONTEXT</b> - l'appel d'API a Ã©tÃ© effectuÃ© Ã  partir du gestionnaire d'interruption.  Les interruptions dans Nucleus SE seront discutÃ©es dans le prochain article. </li></ul><br>  Le prochain article dÃ©taillera les fonctionnalitÃ©s avancÃ©es du planificateur dans Nucleus SE, ainsi que le maintien du contexte. <br><br>  <b>Ã€ propos de l'auteur:</b> Colin Walls travaille dans l'industrie Ã©lectronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ingÃ©nieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de confÃ©rences et sÃ©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422615/">https://habr.com/ru/post/fr422615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422603/index.html">Un peu plus prÃ¨s de la perfection</a></li>
<li><a href="../fr422605/index.html">Cultiver un coffre-fort dÃ¨s le plus jeune Ã¢ge - programme Ã©ducatif de Rostelecom et MIPT</a></li>
<li><a href="../fr422609/index.html">BarriÃ¨re linguistique et PNL. Pourquoi les chatbots ne nous comprennent-ils pas?</a></li>
<li><a href="../fr422611/index.html">Gestionnaire d'erreurs standard dans RxJava2 ou pourquoi RxJava provoque des plantages d'application mÃªme si onError est implÃ©mentÃ©</a></li>
<li><a href="../fr422613/index.html">Le cyber groupe PowerPool a maÃ®trisÃ© la vulnÃ©rabilitÃ© du jour zÃ©ro dans l'appel de procÃ©dure locale avancÃ©e</a></li>
<li><a href="../fr422617/index.html">Toute la vÃ©ritÃ© sur RTOS. Article # 8. Nucleus SE: conception interne et dÃ©ploiement</a></li>
<li><a href="../fr422623/index.html">Comment sÃ©curiser C</a></li>
<li><a href="../fr422625/index.html">Nous avons parlÃ© avec Troy Miles - le programmeur de "Neuromancer"</a></li>
<li><a href="../fr422627/index.html">Recherche sur le marchÃ© du travail MongoDB et IT</a></li>
<li><a href="../fr422629/index.html">ArrÃªtez de nourrir les bÃ»cherons! Donnez plus de modificateurs! Champs finaux statiques paresseux. Projet d'esquisse d'objet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>