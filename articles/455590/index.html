<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèª üë©üèΩ‚Äç‚öñÔ∏è üß† MVCC en PostgreSQL-8. Congelaci√≥n üéûÔ∏è üéñÔ∏è üç¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comenzamos con problemas relacionados con el aislamiento , hicimos una digresi√≥n sobre la organizaci√≥n de datos en un nivel bajo y hablamos en detalle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-8. Congelaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Comenzamos con problemas relacionados con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislamiento</a> , hicimos una digresi√≥n sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">organizaci√≥n de datos en un nivel bajo</a> y hablamos en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre las versiones de fila</a> y c√≥mo se obtienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas</a> de las versiones. <br><br>  Luego examinamos diferentes tipos de limpieza: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intra-p√°gina</a> (junto con actualizaciones HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regular</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autom√°tica</a> . <br><br>  Y llegu√© al √∫ltimo tema de este ciclo.  Hoy hablaremos sobre el problema de la identificaci√≥n y el congelamiento de la transacci√≥n. <br><a name="habracut"></a><br><h1>  Desbordamiento de contador de transacciones </h1><br>  PostgreSQL tiene 32 bits asignados para el n√∫mero de transacci√≥n.  Este es un n√∫mero bastante grande (alrededor de 4 mil millones), pero con la operaci√≥n activa del servidor, puede agotarse.  Por ejemplo, con una carga de 1000 transacciones por segundo, esto suceder√° despu√©s de solo un mes y medio de operaci√≥n continua. <br><br>  Pero hablamos sobre el hecho de que el mecanismo de versiones m√∫ltiples se basa en la secuencia de numeraci√≥n; luego, de dos transacciones, se puede considerar que una transacci√≥n con un n√∫mero m√°s bajo comenz√≥ antes.  Por lo tanto, est√° claro que no puede simplemente reiniciar el contador y continuar numerando nuevamente. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  ¬øPor qu√© no se asignan 64 bits para el n√∫mero de transacci√≥n, ya que esto eliminar√≠a por completo el problema?  El hecho es que (como se discuti√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> ) en el encabezado de cada versi√≥n de la l√≠nea se almacenan dos n√∫meros de transacci√≥n: xmin y xmax.  El encabezado ya es bastante grande, al menos 23 bytes, y un aumento en la profundidad de bits conducir√≠a a su aumento en otros 8 bytes.  Esto es absolutamente de ninguna manera. <br><br><blockquote>  Los n√∫meros de transacci√≥n de 64 bits se implementan en el producto de nuestra empresa, Postgres Pro Enterprise, pero incluso all√≠ no son del todo honestos: xmin y xmax siguen siendo de 32 bits, y el encabezado de la p√°gina contiene el "comienzo de una era" com√∫n para toda la p√°gina. <br></blockquote><br>  Que hacer  En lugar de un diagrama lineal, todos los n√∫meros de transacci√≥n est√°n en bucle.  Para cualquier transacci√≥n, se considera que la mitad de los n√∫meros "en sentido antihorario" pertenecen al pasado y la mitad "en sentido horario" al futuro. <br><br>  La antig√ºedad de una transacci√≥n es el n√∫mero de transacciones que han pasado desde que apareci√≥ en el sistema (independientemente de si el contador pas√≥ por cero o no).  Cuando queremos entender si una transacci√≥n es m√°s antigua que otra o no, comparamos su edad, no los n√∫meros.  (Por lo tanto, por cierto, las operaciones "mayor" y "menor" no est√°n definidas para el tipo de datos xid). <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  Pero en un circuito tan cerrado, surge una situaci√≥n desagradable.  Una transacci√≥n que estaba en el pasado distante (transacci√≥n 1 en la figura), despu√©s de un tiempo estar√° en esa mitad del c√≠rculo que se relaciona con el futuro.  Esto, por supuesto, viola las reglas de visibilidad y generar√≠a problemas: los cambios realizados por la transacci√≥n 1 simplemente desaparecer√≠an de la vista. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  Congelaci√≥n de versiones y reglas de visibilidad </h1><br>  Para evitar tales "viajes" del pasado al futuro, el proceso de limpieza (adem√°s de liberar espacio en las p√°ginas) realiza otra tarea.  Encuentra versiones bastante antiguas y "fr√≠as" de las l√≠neas (que son visibles en todas las im√°genes y cuyo cambio ya es poco probable) y de una manera especial las marca: las "congela".  La versi√≥n congelada de la fila se considera m√°s antigua que cualquier dato normal y siempre est√° visible en todas las instant√°neas de datos.  Adem√°s, ya no es necesario mirar el n√∫mero de transacci√≥n xmin, y este n√∫mero puede reutilizarse de forma segura.  Por lo tanto, las versiones congeladas de cadenas siempre permanecen en el pasado. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Para marcar el n√∫mero de transacci√≥n xmin como congelado, ambos bits de sugerencia se establecen al mismo tiempo: el bit de confirmaci√≥n y el bit de cancelaci√≥n. <br><br>  Tenga en cuenta que la transacci√≥n xmax no necesita ser congelada.  Su presencia significa que esta versi√≥n de la cadena ya no es relevante.  Una vez que deja de ser visible en las instant√°neas de datos, esta versi√≥n de la fila se borrar√°. <br><br>  Para experimentos, crea una tabla.  Establecemos el factor de relleno m√≠nimo para que solo quepan dos l√≠neas en cada p√°gina, por lo que ser√° m√°s conveniente para nosotros observar lo que est√° sucediendo.  Y apague la automatizaci√≥n para controlar el tiempo de limpieza usted mismo. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Ya hemos creado varias variantes de la funci√≥n, que, utilizando la extensi√≥n pageinspect, mostr√≥ la versi√≥n de las l√≠neas que est√°n en la p√°gina.  Ahora crearemos otra variante de la misma funci√≥n: ahora mostrar√° varias p√°ginas a la vez y mostrar√° la antig√ºedad de la transacci√≥n xmin (para esto se utiliza la antig√ºedad de la funci√≥n del sistema): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Tenga en cuenta que el signo de congelaci√≥n (que mostramos con la letra f entre par√©ntesis) est√° determinado por la instalaci√≥n simult√°nea de mensajes confirmados y cancelados.  Muchas fuentes (incluida la documentaci√≥n) mencionan el n√∫mero especial FrozenTransactionId = 2, que marca las transacciones congeladas.  Tal sistema funcion√≥ hasta la versi√≥n 9.4, pero ahora ha sido reemplazado por bits de informaci√≥n sobre herramientas; esto le permite guardar el n√∫mero de transacci√≥n original en la versi√≥n de l√≠nea, lo cual es conveniente para fines de soporte y depuraci√≥n.  Sin embargo, las transacciones con el n√∫mero 2 todav√≠a pueden ocurrir en sistemas m√°s antiguos, incluso actualizadas a las √∫ltimas versiones. <br><br>  Tambi√©n necesitamos la extensi√≥n pg_visibility, que le permite mirar en el mapa de visibilidad: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Antes de PostgreSQL 9.6, el mapa de visibilidad conten√≠a un bit por p√°gina;  marc√≥ p√°ginas que solo conten√≠an versiones "bastante antiguas" de cadenas que ya est√°n garantizadas para ser visibles en todas las im√°genes.  La idea aqu√≠ es que si la p√°gina est√° marcada en el mapa de visibilidad, entonces para su versi√≥n de las l√≠neas no necesita verificar las reglas de visibilidad. <br><br>  A partir de la versi√≥n 9.6, se agreg√≥ un mapa congelado a la misma capa, un bit m√°s por p√°gina.  El mapa de congelaci√≥n marca las p√°ginas en las que se congelan todas las versiones de las filas. <br><br>  Insertamos varias filas en la tabla e inmediatamente realizamos la limpieza para crear un mapa de visibilidad: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Y vemos que ambas p√°ginas ahora est√°n marcadas en el mapa de visibilidad (all_visible), pero a√∫n no est√°n congeladas (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  La antig√ºedad de la transacci√≥n que cre√≥ las filas (xmin_age) es 1: esta es la √∫ltima transacci√≥n que se realiz√≥ en el sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  Edad m√≠nima para congelar </h1><br>  Tres par√°metros principales controlan la congelaci√≥n, y los consideraremos a su vez. <br><br>  Comencemos con <em>vacuum_freeze_min_age</em> , que define la edad m√≠nima de transacci√≥n xmin a la que se puede congelar la versi√≥n de cadena.  Cuanto menor sea este valor, m√°s costos innecesarios pueden resultar: si estamos lidiando con datos "activos" que cambian activamente, entonces la congelaci√≥n de m√°s y m√°s versiones nuevas desaparecer√° sin ning√∫n beneficio.  En este caso, es mejor esperar. <br><br>  El valor predeterminado para este par√°metro establece que las transacciones comienzan a congelarse despu√©s de que hayan pasado 50 millones de otras transacciones desde que aparecieron: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Para ver c√≥mo ocurre la congelaci√≥n, reducimos el valor de este par√°metro a la unidad. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Y actualizaremos una l√≠nea en la p√°gina cero.  La nueva versi√≥n llegar√° a la misma p√°gina debido al peque√±o valor del factor de relleno. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Esto es lo que vemos ahora en las p√°ginas de datos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Ahora las l√≠neas anteriores a <em>vacuum_freeze_min_age</em> = 1 deben congelarse.  Pero tenga en cuenta que la l√≠nea cero no est√° marcada en el mapa de visibilidad (el comando UPDATE restableci√≥ el bit, que cambi√≥ la p√°gina), y la primera permanece marcada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hemos dicho</a> que la limpieza escanea solo las p√°ginas que no est√°n marcadas en el mapa de visibilidad.  Y as√≠ resulta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  En la p√°gina cero, una versi√≥n est√° congelada, pero la primera p√°gina no consider√≥ la limpieza en absoluto.  Por lo tanto, si solo quedan versiones actuales en la p√°gina, la limpieza no llegar√° a dicha p√°gina y no las congelar√°. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  Edad para congelar toda la mesa </h1><br>  Para congelar la versi√≥n de las l√≠neas que quedan en las p√°ginas que la limpieza simplemente no ve, se proporciona un segundo par√°metro: <em>vacuum_freeze_table_age</em> .  Determina la antig√ºedad de la transacci√≥n, en la cual la limpieza ignora el mapa de visibilidad y pasa por todas las p√°ginas de la tabla para congelarse. <br><br>  Cada tabla almacena un n√∫mero de transacci√≥n, por lo que se sabe que todas las transacciones anteriores est√°n garantizadas para congelarse (pg_class.relfrozenxid).  Con la antig√ºedad de esta transacci√≥n recordada, se <em>compara</em> el valor del par√°metro <em>vacuum_freeze_table_age</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Antes de PostgreSQL 9.6, la limpieza realiz√≥ un escaneo completo de la tabla para asegurar que todas las p√°ginas fueran rastreadas.  Para mesas grandes, esta operaci√≥n fue larga y triste.  El asunto se agrav√≥ por el hecho de que si la limpieza no llegaba al final (por ejemplo, un administrador impaciente interrump√≠a la ejecuci√≥n de un comando), era necesario comenzar desde el principio. <br><br>  A partir de la versi√≥n 9.6, gracias al mapa congelado (que vemos en la columna all_frozen en la salida pg_visibility_map), al borrar solo se omiten aquellas p√°ginas que no est√°n marcadas en el mapa.  Esto no es solo una cantidad de trabajo mucho menor, sino tambi√©n una resistencia a las interrupciones: si el proceso de limpieza se detiene y comienza de nuevo, no tendr√° que volver a mirar las p√°ginas que ya logr√≥ marcar en el mapa de congelaci√≥n la √∫ltima vez. <br><br>  De una forma u otra, todas las p√°ginas de la tabla se congelan una vez en las <em>transacciones</em> ( <em>vacuum_freeze_table_age</em> - <em>vacuum_freeze_min_age</em> ).  Con los valores predeterminados, esto ocurre una vez por mill√≥n de transacciones: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Por lo tanto, est√° claro que no se debe establecer demasiada <em>aspiraci√≥n_freeze_min_age</em> , porque en lugar de reducir la sobrecarga, esto comenzar√° a aumentarlos. <br><br>  Veamos c√≥mo se congela toda la tabla, y para hacer esto, reduzca <em>vacuum_freeze_table_age</em> a 5 para que se cumpla la condici√≥n de congelaci√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Vamos a limpiar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Ahora, dado que se ha garantizado la verificaci√≥n de toda la tabla, se puede aumentar el n√∫mero de la transacci√≥n congelada; estamos seguros de que las p√°ginas no tienen una transacci√≥n anterior no congelada. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Ahora todas las versiones de las l√≠neas en la primera p√°gina est√°n congeladas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Adem√°s, la primera p√°gina est√° marcada en el mapa de congelaci√≥n: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  Edad para la respuesta "agresiva" </h1><br>  Es importante que las versiones de fila se congelen a tiempo.  Si surge una situaci√≥n en la que una transacci√≥n que a√∫n no se ha congelado corre el riesgo de entrar en el futuro, PostgreSQL se bloquear√° para evitar posibles problemas. <br><br>  ¬øCu√°l podr√≠a ser la raz√≥n de esto?  Hay varias razones <br><br><ul><li>  La limpieza autom√°tica se puede desactivar, y la limpieza regular tampoco comienza.  Ya hemos dicho que esto no es necesario, pero t√©cnicamente es posible. </li><li>  Incluso la limpieza autom√°tica incluida no llega a las bases de datos que no se utilizan (recuerde el par√°metro <em>track_counts</em> y la base de datos template0). </li><li>  Como vimos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima vez</a> , la limpieza omite las tablas en las que solo se agregan datos, pero no se eliminan o cambian. </li></ul><br>  En tales casos, se proporciona una operaci√≥n de <em>limpieza autom√°tica</em> "agresiva", y est√° regulada por el par√°metro <em>autovacuum_freeze_max_age</em> .  Si en cualquier tabla de cualquier base de datos puede haber una transacci√≥n no congelada anterior a la edad especificada en el par√°metro, la limpieza autom√°tica comienza a la fuerza (incluso si est√° desactivada) y tarde o temprano llegar√° a la tabla de problemas (independientemente de los criterios habituales). <br><br>  El valor predeterminado es bastante conservador: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  El l√≠mite para <em>autovacuum_freeze_max_age</em> es de 2 mil millones de transacciones, y se utiliza un valor 10 veces menor.  Esto tiene sentido: al aumentar el valor, aumentamos el riesgo de que durante el tiempo restante, la limpieza autom√°tica simplemente no tenga tiempo de congelar todas las versiones necesarias de las l√≠neas. <br><br>  Adem√°s, el valor de este par√°metro determina el tama√±o de la estructura XACT: dado que no deber√≠a haber ninguna transacci√≥n anterior en el sistema para la que deba averiguar el estado, la limpieza autom√°tica elimina los archivos innecesarios del segmento XACT, liberando espacio. <br><br>  Veamos c√≥mo la limpieza maneja las tablas de solo agregar, usando tfreeze como ejemplo.  Para esta tabla, la limpieza autom√°tica generalmente est√° deshabilitada, pero esto no ser√° un obst√°culo. <br><br>  Cambiar el par√°metro <em>autovacuum_freeze_max_age</em> requiere reiniciar el servidor.  Pero todos los par√°metros discutidos anteriormente tambi√©n se pueden establecer a nivel de tablas individuales usando par√°metros de almacenamiento.  Por lo general, solo tiene sentido hacer esto en casos especiales, cuando la mesa realmente requiere un cuidado especial. <br><br>  Entonces, estableceremos <em>autovacuum_freeze_max_age</em> en el nivel de la tabla (y al mismo tiempo devolveremos el factor de relleno normal tambi√©n).  Desafortunadamente, el valor m√≠nimo posible es 100,000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Desafortunadamente, porque tenemos que completar 100,000 transacciones para reproducir la situaci√≥n que nos interesa.  Pero, por supuesto, para fines pr√°cticos, este es un valor muy, muy bajo. <br><br>  Como vamos a agregar datos, insertaremos 100,000 filas en la tabla, cada una en nuestra transacci√≥n.  Y nuevamente tengo que hacer una reserva de que en la pr√°ctica esto no deber√≠a hacerse.  Pero ahora solo estamos explorando, podemos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Como podemos ver, la antig√ºedad de la √∫ltima transacci√≥n congelada en la tabla ha excedido el valor umbral: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Pero si espera un poco ahora, en el registro de mensajes del servidor habr√° una entrada sobre el vac√≠o agresivo autom√°tico de la tabla "test.public.tfreeze", el n√∫mero de la transacci√≥n congelada cambiar√° y su antig√ºedad volver√° a la decencia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Tambi√©n existe la posibilidad de congelar las transacciones m√∫ltiples, pero a√∫n no hablaremos de eso, lo pospondremos hasta que hablemos de bloqueos para no adelantarnos. <br></blockquote><br><h1>  Congelaci√≥n manual </h1><br>  A veces es conveniente controlar manualmente la congelaci√≥n en lugar de esperar la llegada de la limpieza autom√°tica. <br><br>  Puede congelar manualmente un comando con el comando VACUUM FREEZE: todas las versiones de fila se congelar√°n, independientemente de la antig√ºedad de las transacciones (como si el par√°metro <em>autovacuum_freeze_min_age</em> = 0).  Cuando se reconstruye una tabla con los comandos VACUUM FULL o CLUSTER, todas las filas tambi√©n se congelan. <br><br>  Para congelar todas las bases de datos, puede usar la utilidad: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Los datos tambi√©n se pueden congelar durante la carga inicial utilizando el comando COPIAR especificando el par√°metro FREEZE.  Para hacer esto, la tabla debe crearse (o vaciarse con el comando TRUNCATE) en el mismo <br>  transacciones como COPIA. <br><br>  Dado que existen reglas de visibilidad separadas para las filas congeladas, dichas filas ser√°n visibles en instant√°neas de datos de otras transacciones en violaci√≥n de las reglas de aislamiento habituales (esto se aplica a las transacciones con el nivel de lectura repetible o serializable). <br><br>  Para verificar esto, en otra sesi√≥n, inicie una transacci√≥n con el nivel de aislamiento de lectura repetible: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Tenga en cuenta que esta transacci√≥n gener√≥ una instant√°nea de los datos, pero no accedi√≥ a la tabla tfreeze.  Ahora vaciaremos la tabla tfreeze y cargaremos nuevas filas en ella en una transacci√≥n.  Si una transacci√≥n paralela lee el contenido de tfreeze, el comando TRUNCATE se bloquear√° hasta el final de la transacci√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ahora una transacci√≥n paralela ve datos nuevos, aunque esto rompe el aislamiento: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Pero, dado que es poco probable que dicha carga de datos ocurra regularmente, esto generalmente no es un problema. <br><br>  Significativamente peor, COPIAR CON CONGELAR no funciona con el mapa de visibilidad: las p√°ginas cargadas no est√°n marcadas como que solo contienen versiones de las l√≠neas que son visibles para todos.  Por lo tanto, cuando accede por primera vez a la tabla, la limpieza se ve obligada a volver a procesar todo y crear un mapa de visibilidad.  Para empeorar las cosas, las p√°ginas de datos tienen un signo de visibilidad completa en su propio encabezado, por lo que la limpieza no solo lee toda la tabla, sino que tambi√©n la reescribe por completo, colocando el bit deseado.  Desafortunadamente, la soluci√≥n a este problema no tiene que esperar antes de la versi√≥n 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n</a> ). <br><br><h1>  Conclusi√≥n </h1><br>  Esto concluye mi serie de art√≠culos sobre aislamiento PostgreSQL y multiversion.  Gracias por su atenci√≥n y especialmente por los comentarios: mejoran el material y a menudo se√±alan √°reas que requieren una atenci√≥n m√°s cuidadosa de mi parte. <br><br>  Qu√©date con nosotros, para continuar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455590/">https://habr.com/ru/post/455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455580/index.html">Impresiones de aplicaciones m√≥viles imprescindibles</a></li>
<li><a href="../455582/index.html">Navegaci√≥n en la tienda: a trav√©s de la realidad aumentada hasta el estante deseado</a></li>
<li><a href="../455584/index.html">Entrevistas personalizadas con las fuerzas internas de la empresa: desde errores hasta descubrimientos</a></li>
<li><a href="../455586/index.html">Ciclo de conferencias sobre rob√≥tica del profesor Gregor Sch√∂ner, director del Instituto de Neuroinform√°tica (INI) Bochum, Alemania</a></li>
<li><a href="../455588/index.html">C√≥mo educar a tu comunidad para no bailar con una pandereta</a></li>
<li><a href="../455592/index.html">Virus que atacan a empresas industriales como una amenaza para la seguridad f√≠sica</a></li>
<li><a href="../455594/index.html">Microsoft Edge de CVE a RCE en Windows 10</a></li>
<li><a href="../455596/index.html">DevConfX :: Gesti√≥n - informes de gerentes en palabras simples</a></li>
<li><a href="../455598/index.html">Actualice urgentemente Exim a 4.92: hay una infecci√≥n activa</a></li>
<li><a href="../455600/index.html">La plataforma 3DEXPERIENCE ayuda a crear el transporte p√∫blico del futuro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>