<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游눰 游뛊游낕 游걋 Acerca de [[trivial_abi]] en Clang 游뗹游낖 鮫勇 游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="춰Finalmente, escrib칤 una publicaci칩n sobre [[trivial_abi]]! 

 Esta es una nueva caracter칤stica patentada en el tronco de Clang, nueva a partir de feb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acerca de [[trivial_abi]] en Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  춰Finalmente, escrib칤 una publicaci칩n sobre [[trivial_abi]]! <br><br>  Esta es una nueva caracter칤stica patentada en el tronco de Clang, nueva a partir de febrero de 2018. Esta es una extensi칩n del proveedor del lenguaje C ++, no es C ++ est치ndar, no es compatible con el tronco GCC, y no hay propuestas activas de WG21 para incluirlo en el est치ndar C ++, que yo sepa. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  No particip칠 en la implementaci칩n de esta funci칩n.  Solo mir칠 los parches en la lista de correo de cfe-commits y me aplaud칤 en silencio.  Pero esta es una caracter칤stica tan genial que creo que todos deber칤an saberlo. <br><a name="habracut"></a><br>  Entonces, lo primero con lo que comenzaremos: este no es un atributo est치ndar, y el tronco de Clang no admite la ortograf칤a est치ndar del atributo [[trivial_abi]] para 칠l.  En cambio, debe escribirlo en el estilo antiguo, como se muestra a continuaci칩n: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Y, dado que este es un atributo, el compilador es muy exigente con respecto a d칩nde lo pega y silenciosamente agresivo si lo pega en el lugar equivocado (ya que los atributos no reconocidos simplemente se ignoran sin mensajes).  Esto no es un error, esta es una caracter칤stica.  La sintaxis correcta es esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  쯈u칠 problema resuelve esto? </h3><br><br>  Recuerdas mi publicaci칩n el 17/04/2018 donde mostr칠 dos versiones de la clase? <br><br><blockquote>  Nota  perev: Dado que la publicaci칩n del 17/04/2018 tiene un peque침o volumen, no lo publiqu칠 por separado, sino que lo insert칠 aqu칤 debajo del spoiler. <br></blockquote><div class="spoiler">  <b class="spoiler_title">publicar desde 17/04/2018</b> <div class="spoiler_text"><h3>  Desventajas de la Llamada de Destructor Trivial Perdida </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consulte la Lista de correo de propuestas est치ndar de C ++.</a>  쮺u치l de las dos funciones, foo o bar, tendr치 el mejor c칩digo generado por el compilador? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilaci칩n</a> con GCC y libstdc ++.  Adivina verdad? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Esto es lo que sucede aqu칤: GCC es lo suficientemente inteligente como para comprender que cuando se inicia un destructor para una regi칩n de memoria, su vida 칰til finaliza y todas las entradas anteriores a esta regi칩n de memoria est치n "muertas".  Pero GCC tambi칠n es lo suficientemente inteligente como para comprender que un destructor trivial (como el pseudo destructor ~ int ()) no hace nada y no produce efectos. <br><br>  Entonces, la funci칩n de barra llama a pop_back, que ejecuta ~ Integer (), lo que hace que vec.back () est칠 muerto, y GCC elimina completamente la multiplicaci칩n por 0xDEADBEEF. <br><br>  Por otro lado, foo llama a pop_back, que lanza el pseudo destructor ~ int () (puede omitir por completo la llamada, pero no lo hace), GCC ve que est치 vac칤o y se olvida de ello.  Por lo tanto, GCC no ve que vec.back () est치 muerto y no elimina la multiplicaci칩n por 0xDEADBEEF. <br><br>  Esto sucede para un destructor trivial, pero no para un pseudo destructor como ~ int ().  Reemplace nuestro ~ Integer () {} con ~ Integer () = default;  춰y mira c칩mo la instrucci칩n completa apareci칩 nuevamente! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  En esa publicaci칩n, se proporciona el c칩digo en el que el compilador gener칩 c칩digo para Foo peor que para Bar.  Vale la pena discutir por qu칠 esto fue inesperado.  Los programadores intuitivamente esperan que el c칩digo "trivial" sea mejor que el c칩digo "no trivial".  Este es el caso en la mayor칤a de las situaciones.  En particular, este es el caso cuando realizamos una llamada a una funci칩n o la devolvemos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compila</a> el siguiente c칩digo: <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comando</a> x86 que significa "agregar"). Vemos que nuestro obj de 4 bytes se pasa a incr en el registro% edi, y agregamos 1 a su valor y lo devolvemos a% eax.  Cuatro bytes en la entrada, cuatro bytes en la salida, f치cil y simple. <br><br>  Ahora veamos incr (el caso con un destructor no trivial). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Aqu칤, obj no se pasa en el registro, a pesar del hecho de que aqu칤 los mismos 4 bytes con la misma sem치ntica.  Aqu칤 se pasa obj y se devuelve a la direcci칩n.  Aqu칤 la persona que llama reserva un espacio para el valor de retorno y nos pasa un puntero a este espacio en rdi, y la persona que llama nos da un puntero para el valor de retorno obj en el siguiente registro de argumentos% rsi.  Extraemos el valor de (% rsi), agregamos 1, lo guardamos de nuevo en (% rsi) para actualizar el valor de obj, y luego (trivialmente) copiamos 4 bytes de obj en la ranura para el valor de retorno se침alado por% rdi.  Finalmente, copiamos el puntero original pasado por la persona que llama de% rdi a% rax, ya que el documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x86-64 ABI</a> (p. 22) nos dice que hagamos esto. <br><br>  La raz칩n por la que Bar es tan diferente de Foo es porque Bar tiene un destructor no trivial, y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x86-64 ABI</a> (p. 19) establece espec칤ficamente: <br><br><blockquote>  Si un objeto C ++ tiene un constructor de copia no trivial o un destructor no trivial, se pasa a trav칠s de un enlace invisible (el objeto se reemplaza con un puntero [...] en la lista de par치metros) </blockquote><br>  Un documento posterior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Itanium C ++ ABI</a> define lo siguiente: <br><blockquote>  Si el tipo de par치metro no es trivial para el prop칩sito de la llamada, la persona que llama debe asignar un lugar temporal y pasar un enlace a este lugar temporal: <br>  [...] <br>  Un tipo se considera no trivial para el prop칩sito de la llamada si: <br><br>  Tiene un constructor de copia no trivial, un constructor m칩vil, un destructor, o todos sus constructores m칩viles y de copia se eliminan. </blockquote><br>  Esto explica todo: Bar tiene una generaci칩n de c칩digo m치s pobre porque se pasa a trav칠s de un enlace invisible.  Se transmite a trav칠s de un enlace invisible ya que se ha producido una combinaci칩n desafortunada de dos circunstancias independientes: <br><ul><li>  El documento ABI dice que los objetos con destructor no trivial se pasan a trav칠s de enlaces invisibles </li><li>  Bar tiene un destructor no trivial. </li></ul><br>  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">silogismo</a> cl치sico: el primer punto es la premisa principal, el segundo es privado.  Como resultado, Bar se transmite a trav칠s de un enlace invisible. <br><br>  Que alguien nos d칠 un silogismo: <br><ul><li>  Todas las personas son mortales </li><li>  S칩crates es un hombre. </li><li>  En consecuencia, S칩crates es mortal. </li></ul><br><br>  Si queremos refutar la conclusi칩n "S칩crates es mortal", debemos refutar una de las premisas: refutar lo principal (quiz치s algunas personas no son mortales) o refutar lo privado (quiz치s S칩crates no es una persona). <br><br>  Para que Bar se apruebe en un registro (como Foo), debemos refutar una de las dos premisas.  La ruta est치ndar de C ++ es darle a Bar un destructor trivial, destruyendo la premisa privada.  Pero hay otra manera! <br><br><h3>  C칩mo [[trivial_abi]] resuelve el problema </h3><br>  El nuevo atributo Clang destruye la premisa principal.  Clang extiende el documento ABI de la siguiente manera: <br><blockquote>  Si el tipo de par치metro no es trivial para el prop칩sito de la llamada, la persona que llama debe asignar un lugar temporal y pasar un enlace a este lugar temporal: <br>  [...] <br>  Un tipo se considera no trivial a los efectos de la llamada si est치 marcado como [[trivial_abi]] y: <br>  Tiene un constructor de copia no trivial, un constructor m칩vil, un destructor, o todos sus constructores m칩viles y de copia se eliminan. <br></blockquote><br>  Incluso si una clase con un constructor o destructor en movimiento no trivial puede considerarse trivial para el prop칩sito de la llamada, si est치 marcada como [[trivial_abi]]. <br><br>  As칤 que ahora, usando Clang, podemos escribir as칤: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  compile incr &lt;Baz&gt; y obtenga el mismo c칩digo que incr &lt;Foo&gt;! <br><h3>  Advertencia # 1: [[trivial_abi]] a veces no hace nada </h3><br>  Espero que podamos hacer envoltorios "triviales para llamadas" sobre tipos de biblioteca est치ndar, como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Por desgracia, esto no funciona.  Si su clase tiene alguna clase base o campos no est치ticos que son "no triviales para el prop칩sito de la llamada", entonces la extensi칩n Clang en la forma en que est치 escrita ahora hace que su clase sea "irreversiblemente no trivial", y el atributo no tendr치 efecto.  (No se emiten mensajes de diagn칩stico. Esto significa que puede usar [[trivial_abi]] en la plantilla de clase como un atributo opcional, y la clase ser치 "condicionalmente trivial", lo que a veces es 칰til. La desventaja, por supuesto, es que puede marque la clase como trivial y luego descubra que el compilador la arregl칩 en silencio). <br><br>  El atributo se ignora sin mensajes si su clase tiene una clase base virtual o funciones virtuales.  En estos casos, es posible que no quepa en los registros, y no s칠 qu칠 quiere obtener al pasarlo por valor, pero probablemente lo sepa. <br><br>  Entonces, que yo sepa, la 칰nica forma de usar TRIVIAL_ABI para "tipos utilitarios est치ndar" como opcional &lt;T&gt;, unique_ptr &lt;T&gt; y shared_ptr &lt;T&gt; es <br><ul><li>  implem칠ntelos usted mismo desde cero y aplique el atributo, o </li><li>  irrumpir en su copia local de libc ++ e insertar el atributo all칤 con las manos </li></ul><br>  (en el mundo de c칩digo abierto, ambos m칠todos son esencialmente iguales) <br><br><h3>  Advertencia # 2: responsabilidad del destructor </h3><br>  En el ejemplo con Foo / Bar, la clase tiene un destructor vac칤o.  Deje que nuestra clase tenga un destructor no trivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Esto deber칤a serle familiar, esto es unique_ptr &lt;int&gt;, simplificado al l칤mite, con el mensaje impreso cuando se elimina. <br><br>  Sin TRIVIAL_ABI, incr &lt;Up1&gt; solo se parece a incr &lt;Bar&gt;: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  춰Con TRIVIAL_ABI, incr parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m치s grande y aterrador</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  En la convenci칩n de llamada tradicional, los tipos con un destructor no trivial siempre pasan por un enlace invisible, lo que significa que el lado receptor (incr en este caso) siempre acepta un puntero a un objeto de par치metro sin poseer este objeto.  El objeto es propiedad de la persona que llama. 춰Esto hace que el trabajo de elisi칩n funcione! <br><br>  Cuando se pasa un tipo con [[trivial_abi]] en los registros, esencialmente hacemos una copia del objeto de par치metro. <br><br>  Como x86-64 solo tiene un registro para devolver (aplausos), la funci칩n llamada no tiene forma de devolver el objeto al final.  춰La funci칩n llamada deber칤a tomar posesi칩n del objeto que le pasamos!  Esto significa que la funci칩n llamada debe llamar al destructor del objeto de par치metro cuando finalice. <br><br>  En nuestro ejemplo anterior, Foo / Bar / Baz, se llama al destructor, pero estaba vac칤o y no lo notamos.  Ahora en incr &lt;Up2&gt; vemos c칩digo adicional generado por el destructor al lado de la funci칩n llamada. <br><br>  Se puede suponer que este c칩digo adicional se puede generar en algunos casos de usuario.  Pero, por el contrario, 춰la llamada del destructor no aparece en ning칰n lado!  Se llama en incr porque no se llama en la funci칩n de llamada.  Y en general, el precio y los beneficios ser치n equilibrados. <br><br><h3>  Advertencia # 3: Orden del Destructor </h3><br>  El destructor para un par치metro con un ABI trivial ser치 llamado por la funci칩n llamada, y no por la llamada (advertencia No. 2).  Richard Smith se침ala que esto significa que no se lo llamar치 en el orden en que se encuentran los destructores de los otros par치metros. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Este c칩digo imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  cuando TRIVIAL_ABI se define como [[clang :: trivial_abi]], imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Relaci칩n con un objeto "trivialmente reubicable" / "mover-reubicar" </h3><br>  Sin relaci칩n ... 쯘h? <br><br>  Como puede ver, no hay requisitos para que la clase [[trivial_abi]] tenga una sem치ntica espec칤fica para el constructor en movimiento, el destructor o el constructor predeterminado.  Cualquier clase particular probablemente ser치 trivialmente reubicable, simplemente porque la mayor칤a de las clases son trivialmente reubicables. <br><br>  Simplemente podemos hacer la clase offset_ptr para que no sea reubicable trivialmente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Aqu칤 est치 el c칩digo completo.</a> <br>  Cuando se define TRIVIAL_ABI, la troncal de Clang pasa esta prueba en -O0 y -O1, pero en -O2 (es decir, tan pronto como intenta en l칤nea las llamadas a trivial_offset_ptr :: operator + = y al constructor de la copia), se bloquea en la afirmaci칩n. <br><br>  Entonces una advertencia m치s.  Si su tipo hace algo tan loco con este puntero, probablemente no quiera pasarlo en los registros. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bug 37319</a> , de hecho, una solicitud de documentaci칩n.  En este caso, resulta que no hay forma de hacer que el c칩digo funcione de la manera que el programador quiere.  Decimos que el valor de value_ debe depender del valor de este puntero, pero en el l칤mite entre las funciones de llamada y llamadas, 춰el objeto est치 en registros y el puntero no existe!  Por lo tanto, la funci칩n de llamada lo escribe en la memoria y pasa el puntero de este nuevamente, y 쯖칩mo deber칤a la funci칩n llamada calcular el valor correcto para escribirlo en value_?  Quiz치s sea mejor preguntar c칩mo funciona incluso en -O0.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este c칩digo no deber칤a funcionar en absoluto.</a> <br><br>  Por lo tanto, si desea utilizar [[trivial_abi]], debe evitar las funciones de los miembros (no solo especiales, sino cualquiera en general) que dependen en gran medida de la propia direcci칩n del objeto (con un significado indefinido de la palabra "esencial"). <br><br>  Intuitivamente, cuando una clase se marca como [[trivial_abi]], cada vez que espera copiar, puede obtener copia m치s memcpy.  Y de manera similar, cuando esperas un movimiento, puedes obtener el movimiento m치s memcpy. <br><br>  Cuando un tipo es "trivialmente reubicable" (como lo defin칤 en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ ahora</a> ), cada vez que espere copiar y destruir, puede obtener memcpy.  Y de manera similar, cuando esperas desplazamiento y destrucci칩n, puedes obtener memcpy.  De hecho, las llamadas a funciones especiales se pierden si hablamos de "reubicaci칩n trivial", pero cuando la clase tiene el atributo [[trivial_abi]] de Clang, las llamadas no se pierden.  Simplemente obtienes (por as칤 decirlo) memcpy adem치s de las llamadas que esperabas.  Esta (especie de) memoria es el precio que paga por una convenci칩n de registro de llamadas m치s r치pida. <br><br><h3>  Enlaces para lecturas adicionales: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El hilo cfe-dev de Akira Hatanaka de noviembre de 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci칩n oficial de Clang</a> <br>  <a href="">La unidad prueba para trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Error 37319: trivial_offset_ptr no puede funcionar</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468759/">https://habr.com/ru/post/468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468741/index.html">Internet en la ciudad inteligente</a></li>
<li><a href="../468747/index.html">C칩mo pas칠 el verano en VK</a></li>
<li><a href="../468749/index.html">Android LiveData Events</a></li>
<li><a href="../468753/index.html">Dalt칩nico - amigo del hombre (el Ministerio de Salud no tiene raz칩n)</a></li>
<li><a href="../468757/index.html">Conexi칩n MySQL despu칠s del error 1040: demasiadas conexiones</a></li>
<li><a href="../468761/index.html">Resoluci칩n de problemas con pwnable.kr 24: inicio de sesi칩n simple. Superposici칩n de marco de pila</a></li>
<li><a href="../468765/index.html">La importancia de confirmar los comandos de control usando Delimobile como ejemplo</a></li>
<li><a href="../468767/index.html">Juguetes de madera, segunda parte - 1986-1988</a></li>
<li><a href="../468769/index.html">Xavier Noria on Rails 6, consultor칤a y m치s</a></li>
<li><a href="../468773/index.html">La compa침칤a india de energ칤a NTPC construir치 un parque solar de 5,000 megavatios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>