<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💱 🚴🏻 🈵 Acerca de [[trivial_abi]] en Clang 🙆🏼 ♏️ 🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Finalmente, escribí una publicación sobre [[trivial_abi]]! 

 Esta es una nueva característica patentada en el tronco de Clang, nueva a partir de feb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acerca de [[trivial_abi]] en Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  ¡Finalmente, escribí una publicación sobre [[trivial_abi]]! <br><br>  Esta es una nueva característica patentada en el tronco de Clang, nueva a partir de febrero de 2018. Esta es una extensión del proveedor del lenguaje C ++, no es C ++ estándar, no es compatible con el tronco GCC, y no hay propuestas activas de WG21 para incluirlo en el estándar C ++, que yo sepa. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  No participé en la implementación de esta función.  Solo miré los parches en la lista de correo de cfe-commits y me aplaudí en silencio.  Pero esta es una característica tan genial que creo que todos deberían saberlo. <br><a name="habracut"></a><br>  Entonces, lo primero con lo que comenzaremos: este no es un atributo estándar, y el tronco de Clang no admite la ortografía estándar del atributo [[trivial_abi]] para él.  En cambio, debe escribirlo en el estilo antiguo, como se muestra a continuación: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Y, dado que este es un atributo, el compilador es muy exigente con respecto a dónde lo pega y silenciosamente agresivo si lo pega en el lugar equivocado (ya que los atributos no reconocidos simplemente se ignoran sin mensajes).  Esto no es un error, esta es una característica.  La sintaxis correcta es esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  ¿Qué problema resuelve esto? </h3><br><br>  ¿Recuerdas mi publicación el 17/04/2018 donde mostré dos versiones de la clase? <br><br><blockquote>  Nota  perev: Dado que la publicación del 17/04/2018 tiene un pequeño volumen, no lo publiqué por separado, sino que lo inserté aquí debajo del spoiler. <br></blockquote><div class="spoiler">  <b class="spoiler_title">publicar desde 17/04/2018</b> <div class="spoiler_text"><h3>  Desventajas de la Llamada de Destructor Trivial Perdida </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consulte la Lista de correo de propuestas estándar de C ++.</a>  ¿Cuál de las dos funciones, foo o bar, tendrá el mejor código generado por el compilador? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilación</a> con GCC y libstdc ++.  Adivina verdad? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Esto es lo que sucede aquí: GCC es lo suficientemente inteligente como para comprender que cuando se inicia un destructor para una región de memoria, su vida útil finaliza y todas las entradas anteriores a esta región de memoria están "muertas".  Pero GCC también es lo suficientemente inteligente como para comprender que un destructor trivial (como el pseudo destructor ~ int ()) no hace nada y no produce efectos. <br><br>  Entonces, la función de barra llama a pop_back, que ejecuta ~ Integer (), lo que hace que vec.back () esté muerto, y GCC elimina completamente la multiplicación por 0xDEADBEEF. <br><br>  Por otro lado, foo llama a pop_back, que lanza el pseudo destructor ~ int () (puede omitir por completo la llamada, pero no lo hace), GCC ve que está vacío y se olvida de ello.  Por lo tanto, GCC no ve que vec.back () está muerto y no elimina la multiplicación por 0xDEADBEEF. <br><br>  Esto sucede para un destructor trivial, pero no para un pseudo destructor como ~ int ().  Reemplace nuestro ~ Integer () {} con ~ Integer () = default;  ¡y mira cómo la instrucción completa apareció nuevamente! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  En esa publicación, se proporciona el código en el que el compilador generó código para Foo peor que para Bar.  Vale la pena discutir por qué esto fue inesperado.  Los programadores intuitivamente esperan que el código "trivial" sea mejor que el código "no trivial".  Este es el caso en la mayoría de las situaciones.  En particular, este es el caso cuando realizamos una llamada a una función o la devolvemos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compila</a> el siguiente código: <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comando</a> x86 que significa "agregar"). Vemos que nuestro obj de 4 bytes se pasa a incr en el registro% edi, y agregamos 1 a su valor y lo devolvemos a% eax.  Cuatro bytes en la entrada, cuatro bytes en la salida, fácil y simple. <br><br>  Ahora veamos incr (el caso con un destructor no trivial). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Aquí, obj no se pasa en el registro, a pesar del hecho de que aquí los mismos 4 bytes con la misma semántica.  Aquí se pasa obj y se devuelve a la dirección.  Aquí la persona que llama reserva un espacio para el valor de retorno y nos pasa un puntero a este espacio en rdi, y la persona que llama nos da un puntero para el valor de retorno obj en el siguiente registro de argumentos% rsi.  Extraemos el valor de (% rsi), agregamos 1, lo guardamos de nuevo en (% rsi) para actualizar el valor de obj, y luego (trivialmente) copiamos 4 bytes de obj en la ranura para el valor de retorno señalado por% rdi.  Finalmente, copiamos el puntero original pasado por la persona que llama de% rdi a% rax, ya que el documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x86-64 ABI</a> (p. 22) nos dice que hagamos esto. <br><br>  La razón por la que Bar es tan diferente de Foo es porque Bar tiene un destructor no trivial, y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x86-64 ABI</a> (p. 19) establece específicamente: <br><br><blockquote>  Si un objeto C ++ tiene un constructor de copia no trivial o un destructor no trivial, se pasa a través de un enlace invisible (el objeto se reemplaza con un puntero [...] en la lista de parámetros) </blockquote><br>  Un documento posterior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Itanium C ++ ABI</a> define lo siguiente: <br><blockquote>  Si el tipo de parámetro no es trivial para el propósito de la llamada, la persona que llama debe asignar un lugar temporal y pasar un enlace a este lugar temporal: <br>  [...] <br>  Un tipo se considera no trivial para el propósito de la llamada si: <br><br>  Tiene un constructor de copia no trivial, un constructor móvil, un destructor, o todos sus constructores móviles y de copia se eliminan. </blockquote><br>  Esto explica todo: Bar tiene una generación de código más pobre porque se pasa a través de un enlace invisible.  Se transmite a través de un enlace invisible ya que se ha producido una combinación desafortunada de dos circunstancias independientes: <br><ul><li>  El documento ABI dice que los objetos con destructor no trivial se pasan a través de enlaces invisibles </li><li>  Bar tiene un destructor no trivial. </li></ul><br>  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">silogismo</a> clásico: el primer punto es la premisa principal, el segundo es privado.  Como resultado, Bar se transmite a través de un enlace invisible. <br><br>  Que alguien nos dé un silogismo: <br><ul><li>  Todas las personas son mortales </li><li>  Sócrates es un hombre. </li><li>  En consecuencia, Sócrates es mortal. </li></ul><br><br>  Si queremos refutar la conclusión "Sócrates es mortal", debemos refutar una de las premisas: refutar lo principal (quizás algunas personas no son mortales) o refutar lo privado (quizás Sócrates no es una persona). <br><br>  Para que Bar se apruebe en un registro (como Foo), debemos refutar una de las dos premisas.  La ruta estándar de C ++ es darle a Bar un destructor trivial, destruyendo la premisa privada.  Pero hay otra manera! <br><br><h3>  Cómo [[trivial_abi]] resuelve el problema </h3><br>  El nuevo atributo Clang destruye la premisa principal.  Clang extiende el documento ABI de la siguiente manera: <br><blockquote>  Si el tipo de parámetro no es trivial para el propósito de la llamada, la persona que llama debe asignar un lugar temporal y pasar un enlace a este lugar temporal: <br>  [...] <br>  Un tipo se considera no trivial a los efectos de la llamada si está marcado como [[trivial_abi]] y: <br>  Tiene un constructor de copia no trivial, un constructor móvil, un destructor, o todos sus constructores móviles y de copia se eliminan. <br></blockquote><br>  Incluso si una clase con un constructor o destructor en movimiento no trivial puede considerarse trivial para el propósito de la llamada, si está marcada como [[trivial_abi]]. <br><br>  Así que ahora, usando Clang, podemos escribir así: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  compile incr &lt;Baz&gt; y obtenga el mismo código que incr &lt;Foo&gt;! <br><h3>  Advertencia # 1: [[trivial_abi]] a veces no hace nada </h3><br>  Espero que podamos hacer envoltorios "triviales para llamadas" sobre tipos de biblioteca estándar, como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Por desgracia, esto no funciona.  Si su clase tiene alguna clase base o campos no estáticos que son "no triviales para el propósito de la llamada", entonces la extensión Clang en la forma en que está escrita ahora hace que su clase sea "irreversiblemente no trivial", y el atributo no tendrá efecto.  (No se emiten mensajes de diagnóstico. Esto significa que puede usar [[trivial_abi]] en la plantilla de clase como un atributo opcional, y la clase será "condicionalmente trivial", lo que a veces es útil. La desventaja, por supuesto, es que puede marque la clase como trivial y luego descubra que el compilador la arregló en silencio). <br><br>  El atributo se ignora sin mensajes si su clase tiene una clase base virtual o funciones virtuales.  En estos casos, es posible que no quepa en los registros, y no sé qué quiere obtener al pasarlo por valor, pero probablemente lo sepa. <br><br>  Entonces, que yo sepa, la única forma de usar TRIVIAL_ABI para "tipos utilitarios estándar" como opcional &lt;T&gt;, unique_ptr &lt;T&gt; y shared_ptr &lt;T&gt; es <br><ul><li>  impleméntelos usted mismo desde cero y aplique el atributo, o </li><li>  irrumpir en su copia local de libc ++ e insertar el atributo allí con las manos </li></ul><br>  (en el mundo de código abierto, ambos métodos son esencialmente iguales) <br><br><h3>  Advertencia # 2: responsabilidad del destructor </h3><br>  En el ejemplo con Foo / Bar, la clase tiene un destructor vacío.  Deje que nuestra clase tenga un destructor no trivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Esto debería serle familiar, esto es unique_ptr &lt;int&gt;, simplificado al límite, con el mensaje impreso cuando se elimina. <br><br>  Sin TRIVIAL_ABI, incr &lt;Up1&gt; solo se parece a incr &lt;Bar&gt;: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  ¡Con TRIVIAL_ABI, incr parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más grande y aterrador</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  En la convención de llamada tradicional, los tipos con un destructor no trivial siempre pasan por un enlace invisible, lo que significa que el lado receptor (incr en este caso) siempre acepta un puntero a un objeto de parámetro sin poseer este objeto.  El objeto es propiedad de la persona que llama. ¡Esto hace que el trabajo de elisión funcione! <br><br>  Cuando se pasa un tipo con [[trivial_abi]] en los registros, esencialmente hacemos una copia del objeto de parámetro. <br><br>  Como x86-64 solo tiene un registro para devolver (aplausos), la función llamada no tiene forma de devolver el objeto al final.  ¡La función llamada debería tomar posesión del objeto que le pasamos!  Esto significa que la función llamada debe llamar al destructor del objeto de parámetro cuando finalice. <br><br>  En nuestro ejemplo anterior, Foo / Bar / Baz, se llama al destructor, pero estaba vacío y no lo notamos.  Ahora en incr &lt;Up2&gt; vemos código adicional generado por el destructor al lado de la función llamada. <br><br>  Se puede suponer que este código adicional se puede generar en algunos casos de usuario.  Pero, por el contrario, ¡la llamada del destructor no aparece en ningún lado!  Se llama en incr porque no se llama en la función de llamada.  Y en general, el precio y los beneficios serán equilibrados. <br><br><h3>  Advertencia # 3: Orden del Destructor </h3><br>  El destructor para un parámetro con un ABI trivial será llamado por la función llamada, y no por la llamada (advertencia No. 2).  Richard Smith señala que esto significa que no se lo llamará en el orden en que se encuentran los destructores de los otros parámetros. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Este código imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  cuando TRIVIAL_ABI se define como [[clang :: trivial_abi]], imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Relación con un objeto "trivialmente reubicable" / "mover-reubicar" </h3><br>  Sin relación ... ¿eh? <br><br>  Como puede ver, no hay requisitos para que la clase [[trivial_abi]] tenga una semántica específica para el constructor en movimiento, el destructor o el constructor predeterminado.  Cualquier clase particular probablemente será trivialmente reubicable, simplemente porque la mayoría de las clases son trivialmente reubicables. <br><br>  Simplemente podemos hacer la clase offset_ptr para que no sea reubicable trivialmente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Aquí está el código completo.</a> <br>  Cuando se define TRIVIAL_ABI, la troncal de Clang pasa esta prueba en -O0 y -O1, pero en -O2 (es decir, tan pronto como intenta en línea las llamadas a trivial_offset_ptr :: operator + = y al constructor de la copia), se bloquea en la afirmación. <br><br>  Entonces una advertencia más.  Si su tipo hace algo tan loco con este puntero, probablemente no quiera pasarlo en los registros. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bug 37319</a> , de hecho, una solicitud de documentación.  En este caso, resulta que no hay forma de hacer que el código funcione de la manera que el programador quiere.  Decimos que el valor de value_ debe depender del valor de este puntero, pero en el límite entre las funciones de llamada y llamadas, ¡el objeto está en registros y el puntero no existe!  Por lo tanto, la función de llamada lo escribe en la memoria y pasa el puntero de este nuevamente, y ¿cómo debería la función llamada calcular el valor correcto para escribirlo en value_?  Quizás sea mejor preguntar cómo funciona incluso en -O0.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este código no debería funcionar en absoluto.</a> <br><br>  Por lo tanto, si desea utilizar [[trivial_abi]], debe evitar las funciones de los miembros (no solo especiales, sino cualquiera en general) que dependen en gran medida de la propia dirección del objeto (con un significado indefinido de la palabra "esencial"). <br><br>  Intuitivamente, cuando una clase se marca como [[trivial_abi]], cada vez que espera copiar, puede obtener copia más memcpy.  Y de manera similar, cuando esperas un movimiento, puedes obtener el movimiento más memcpy. <br><br>  Cuando un tipo es "trivialmente reubicable" (como lo definí en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ ahora</a> ), cada vez que espere copiar y destruir, puede obtener memcpy.  Y de manera similar, cuando esperas desplazamiento y destrucción, puedes obtener memcpy.  De hecho, las llamadas a funciones especiales se pierden si hablamos de "reubicación trivial", pero cuando la clase tiene el atributo [[trivial_abi]] de Clang, las llamadas no se pierden.  Simplemente obtienes (por así decirlo) memcpy además de las llamadas que esperabas.  Esta (especie de) memoria es el precio que paga por una convención de registro de llamadas más rápida. <br><br><h3>  Enlaces para lecturas adicionales: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El hilo cfe-dev de Akira Hatanaka de noviembre de 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación oficial de Clang</a> <br>  <a href="">La unidad prueba para trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Error 37319: trivial_offset_ptr no puede funcionar</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468759/">https://habr.com/ru/post/468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468741/index.html">Internet en la ciudad inteligente</a></li>
<li><a href="../468747/index.html">Cómo pasé el verano en VK</a></li>
<li><a href="../468749/index.html">Android LiveData Events</a></li>
<li><a href="../468753/index.html">Daltónico - amigo del hombre (el Ministerio de Salud no tiene razón)</a></li>
<li><a href="../468757/index.html">Conexión MySQL después del error 1040: demasiadas conexiones</a></li>
<li><a href="../468761/index.html">Resolución de problemas con pwnable.kr 24: inicio de sesión simple. Superposición de marco de pila</a></li>
<li><a href="../468765/index.html">La importancia de confirmar los comandos de control usando Delimobile como ejemplo</a></li>
<li><a href="../468767/index.html">Juguetes de madera, segunda parte - 1986-1988</a></li>
<li><a href="../468769/index.html">Xavier Noria on Rails 6, consultoría y más</a></li>
<li><a href="../468773/index.html">La compañía india de energía NTPC construirá un parque solar de 5,000 megavatios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>