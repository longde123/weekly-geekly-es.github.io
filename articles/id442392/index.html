<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ãŠ—ï¸ ğŸ° ğŸ›ŒğŸ½ Log NodeJS dibuat benar ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ½ ğŸ€ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang paling mengganggu Anda saat berpikir tentang masuk ke NodeJS? Jika Anda bertanya kepada saya, saya akan mengatakan kurangnya standar industri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Log NodeJS dibuat benar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442392/"><p><img src="https://habrastorage.org/webt/5a/em/fo/5aemfoyk841-ll_xjint9es2kao.jpeg"></p><br><p> Apa yang paling mengganggu Anda saat berpikir tentang masuk ke NodeJS?  Jika Anda bertanya kepada saya, saya akan mengatakan kurangnya standar industri untuk membuat ID jejak.  Dalam artikel ini, kami akan mengulas bagaimana kami dapat membuat ID jejak ini (artinya kami akan memeriksa secara singkat bagaimana penyimpanan lokal yang berkelanjutan alias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CLS</a> bekerja) dan menggali lebih dalam tentang bagaimana kami dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proxy</a> untuk membuatnya bekerja dengan logger APA PUN. </p><a name="habracut"></a><br><h2 id="why-is-it-even-a-problem-to-have-a-trace-id-for-each-request-in-nodejs">  Mengapa bahkan memiliki ID jejak untuk setiap permintaan di NodeJS? </h2><br><p>  Nah, pada platform yang menggunakan multi-threading dan menelurkan utas baru untuk setiap permintaan.  Ada sesuatu yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan thread-local alias TLS</a> , yang memungkinkan menjaga data sewenang-wenang tersedia untuk apa pun dalam utas.  Jika Anda memiliki API asli untuk melakukannya, cukup sepele untuk membuat ID acak untuk setiap permintaan, masukkan ke TLS dan gunakan di controller atau layanan Anda nanti.  Jadi apa masalahnya dengan NodeJS? <br>  Seperti yang Anda ketahui, NodeJS adalah platform single-threaded (tidak terlalu benar lagi karena sekarang kami memiliki pekerja, tetapi itu tidak mengubah gambaran besar) platform, yang membuat TLS usang.  Alih-alih mengoperasikan utas yang berbeda, NodeJS menjalankan panggilan balik yang berbeda dalam utas yang sama (ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel hebat</a> tentang perulangan acara di NodeJS jika Anda tertarik) dan NodeJS memberi kami cara untuk mengidentifikasi secara unik panggilan balik ini dan melacak hubungan mereka satu sama lain . </p><br><p>  Kembali di masa lalu (v0.11.11) kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">addAsyncListener</a> yang memungkinkan kami untuk melacak peristiwa asinkron.  Berdasarkan hal itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forrest Norvell</a> membangun implementasi pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan lokal lanjutan alias CLS</a> .  Kami tidak akan membahas implementasi CLS karena fakta bahwa kami, sebagai pengembang, telah kehilangan API tersebut di v0.12. </p><br><p>  Sampai NodeJS 8 kami tidak memiliki cara resmi untuk terhubung ke pemrosesan acara async NodeJS.  Dan akhirnya NodeJS 8 memberi kita kekuatan yang hilang melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async_hooks</a> (jika Anda ingin mendapatkan pemahaman yang lebih baik tentang async_hooks lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> ).  Ini membawa kita ke implementasi CLS berbasis async_hooks modern - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cls-hooked</a> . </p><br><h2 id="cls-overview">  Ikhtisar CLS </h2><br><p>  Berikut alur sederhana tentang cara kerja CLS: </p><br><p><img src="https://habrastorage.org/webt/ix/xe/wj/ixxewjdn0xn7r5feuvgdl1vnjow.jpeg"></p><br><p>  Mari kita uraikan langkah demi langkah: </p><br><ol><li>  Katakanlah, kami memiliki server web yang khas.  Pertama kita harus membuat namespace CLS.  Sekali seumur hidup aplikasi kita. </li><li>  Kedua, kita harus mengkonfigurasi middleware untuk membuat konteks CLS baru untuk setiap permintaan.  Untuk kesederhanaan, mari kita asumsikan bahwa middleware ini hanyalah panggilan balik yang dipanggil saat menerima permintaan baru. </li><li>  Jadi ketika permintaan baru tiba, kami memanggil fungsi panggilan balik itu. </li><li>  Dalam fungsi itu kami membuat konteks CLS baru (salah satu caranya adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">run</a> API call). </li><li>  Pada titik ini CLS menempatkan konteks baru dalam peta konteks dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ID eksekusi saat ini</a> . </li><li> Setiap namespace CLS memiliki properti <code>active</code> .  Pada tahap ini CLS menetapkan <code>active</code> ke konteks. </li><li>  Di dalam konteks kami membuat panggilan ke sumber daya tidak sinkron, katakanlah, kami meminta beberapa data dari database.  Kami meneruskan panggilan balik ke panggilan itu, yang akan berjalan begitu permintaan ke database selesai. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">init</a> async hook diaktifkan untuk operasi asinkron baru.  Itu menambahkan konteks saat ini ke peta konteks dengan ID async (menganggapnya sebagai pengidentifikasi operasi asinkron baru). </li><li>  Karena kami tidak lagi memiliki logika di dalam callback pertama kami, ia keluar secara efektif mengakhiri operasi asinkron pertama kami. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah</a> hook async dipecat untuk panggilan balik pertama.  Ini menetapkan konteks aktif pada namespace menjadi <code>undefined</code> (itu tidak selalu benar karena kita mungkin memiliki beberapa konteks bersarang, tetapi untuk kasus yang paling sederhana itu benar). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghancurkan</a> kait dipecat untuk operasi pertama.  Ini menghapus konteks dari peta konteks kami dengan ID async-nya (sama dengan ID eksekusi saat ini dari callback pertama kami). </li><li>  Permintaan ke database telah selesai dan panggilan balik kedua kami akan dipicu. </li><li>  Pada titik ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelum</a> async hook berperan.  ID eksekusi saat ini sama dengan ID async dari operasi kedua (permintaan basis data).  Ini mengatur properti <code>active</code> namespace ke konteks yang ditemukan oleh ID eksekusi saat ini.  Ini konteks yang kami buat sebelumnya. </li><li>  Sekarang kita jalankan panggilan balik kedua.  Jalankan beberapa logika bisnis di dalam.  Dalam fungsi itu kita bisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendapatkan nilai dengan kunci</a> dari CLS dan itu akan mengembalikan apa pun yang ditemukan oleh kunci dalam konteks yang kita buat sebelumnya. </li><li>  Dengan asumsi bahwa itu adalah akhir dari pemrosesan permintaan fungsi kami kembali. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah</a> kait async dipecat untuk panggilan balik kedua.  Ini mengatur konteks aktif pada namespace menjadi <code>undefined</code> . </li><li>  <code>destroy</code> kait ditembakkan untuk operasi asinkron kedua.  Itu menghapus konteks kita dari peta konteks dengan ID async-nya meninggalkannya benar-benar kosong. </li><li>  Karena kami tidak lagi memegang referensi ke objek konteks, pemulung kami membebaskan memori yang terkait dengannya. </li></ol><br><p>  Ini adalah versi sederhana dari apa yang terjadi di bawah tenda, namun mencakup semua langkah utama.  Jika Anda ingin menggali lebih dalam, Anda dapat melihat <a href="">kode sumbernya</a> .  Itu kurang dari 500 baris. </p><br><h2 id="generating-trace-ids">  Menghasilkan jejak ID </h2><br><p>  Jadi, begitu kita mendapatkan pemahaman keseluruhan tentang CLS, mari kita pikirkan bagaimana kita dapat menggunakannya untuk kebaikan kita sendiri.  Satu hal yang bisa kami lakukan adalah membuat middleware yang membungkus setiap permintaan dalam suatu konteks, menghasilkan pengidentifikasi acak dan meletakkannya di CLS dengan key <code>traceID</code> .  Kemudian, di dalam salah satu trilyun pengontrol dan layanan kami, kami bisa mendapatkan pengenal itu dari CLS. </p><br><p>  Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengekspresikan</a> middleware ini bisa terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsNamespace = cls.createNamespace(<span class="hljs-string"><span class="hljs-string">'app'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req and res are event emitters. We want to access CLS context inside of their event callbacks clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() clsNamespace.run(() =&gt; { clsNamespace.set('traceID', traceID) next() }) }</span></span></code> </pre> <br><p>  Kemudian di controller kami, kami bisa mendapatkan jejak ID yang dihasilkan seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'traceID'</span></span>) }</code> </pre> <br><p>  Tidak ada banyak penggunaan ID jejak ini kecuali kami menambahkannya ke log kami. </p><br><p>  Mari tambahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">winston</a> kami. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { createLogger, format, transports } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'winston'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTraceId = printf(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = info.message <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'taceID'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traceID) { message = <span class="hljs-string"><span class="hljs-string">`[TraceID: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${traceID}</span></span></span><span class="hljs-string">]: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = createLogger({ <span class="hljs-attr"><span class="hljs-attr">format</span></span>: addTraceId, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> transports.Console()], })</code> </pre> <br><p>  Nah, jika semua penebang mendukung formatters dalam bentuk fungsi (banyak dari mereka tidak melakukannya karena alasan yang baik) artikel ini tidak akan ada.  Jadi bagaimana caranya menambahkan jejak jejak ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pino</a> kesayanganku?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proksi</a> untuk menyelamatkan! </p><br><h2 id="combining-proxy-and-cls">  Menggabungkan Proxy dan CLS </h2><br><p>  Proxy adalah objek yang membungkus objek asli kita sehingga memungkinkan kita untuk menimpa perilakunya dalam situasi tertentu.  Daftar situasi ini (sebenarnya disebut jebakan) terbatas dan Anda dapat melihat seluruh rangkaian di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi kami hanya tertarik pada jebakan perangkap.  Ini memberi kami kemampuan untuk mencegat akses properti.  Ini berarti bahwa jika kita memiliki objek <code>const a = { prop: 1 }</code> dan membungkusnya dalam Proxy, dengan <code>get</code> trap kita bisa mengembalikan apa pun yang kita inginkan untuk <code>a.prop</code> . </p><br><p>  Jadi idenya adalah untuk menghasilkan ID jejak acak untuk setiap permintaan dan membuat <a href="">logger pino anak</a> dengan ID jejak dan memasukkannya ke dalam CLS.  Kemudian kita bisa membungkus logger asli kita dengan Proxy, yang akan mengarahkan ulang semua permintaan logging ke logger anak di CLS jika ditemukan dan tetap menggunakan logger asli sebaliknya. </p><br><p>  Dalam skenario ini Proksi kami dapat terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = pino() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loggerCls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(logger, { get(target, property, receiver) { <span class="hljs-comment"><span class="hljs-comment">// Fallback to our original logger if there is no child logger in CLS target = clsNamespace.get('loggerCls') || target return Reflect.get(target, property, receiver) }, })</span></span></code> </pre> <br><p>  Middleware kami akan berubah menjadi seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req and res are event emitters. We want to access CLS context inside of their event callbacks clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() const loggerWithTraceId = logger.child({ traceID }) clsNamespace.run(() =&gt; { clsNamespace.set('loggerCls', loggerWithTraceId) next() }) }</span></span></code> </pre> <br><p>  Dan kita bisa menggunakan logger seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { loggerCls.info(<span class="hljs-string"><span class="hljs-string">'Long live rocknroll!'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Logs something like // {"level":30,"time":1551385666046,"msg":"Long live rocknroll!","pid":25,"hostname":"eb6a6c70f5c4","traceID":"9ba393f0-ec8c-4396-8092-b7e4b6f375b5","v":1} }</span></span></code> </pre> <br><h2 id="cls-proxifyhttpsgithubcomkeenondrumscls-proxify">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cls-proxify</a> </h2><br><p>  Berdasarkan ide di atas, sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan kecil bernama cls-proxify</a> telah dibuat.  Ini memiliki integrasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">express</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koa</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fastify</a> out-of-the-box. <br>  Ini berlaku tidak hanya <code>get</code> jebakan ke objek asli, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak lainnya</a> juga.  Jadi ada kemungkinan aplikasi yang tak terbatas.  Anda dapat memanggil fungsi panggilan, konstruksi kelas, hampir apa saja!  Anda hanya dibatasi oleh imajinasi Anda! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihatlah demo langsung menggunakannya dengan pino dan kencangkan, pino dan ekspres</a> . </p><br><p>  Semoga Anda menemukan sesuatu yang berguna untuk proyek Anda.  Silakan sampaikan umpan balik Anda kepada saya!  Saya sangat menghargai kritik dan pertanyaan apa pun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442392/">https://habr.com/ru/post/id442392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442376/index.html">Kepadatan plot eceran</a></li>
<li><a href="../id442378/index.html">Satu klik pada antarmuka Pemesanan com dapat merusak liburan atau mengapa sistem peringkat kerja penting</a></li>
<li><a href="../id442380/index.html">Semacam Kekacauan</a></li>
<li><a href="../id442384/index.html">Memperluas fungsi sistem audio standar</a></li>
<li><a href="../id442386/index.html">Thymeleaf: Tata Letak Dialek + Spring Boot 2</a></li>
<li><a href="../id442396/index.html">Acara digital di Moskow dari 04 Maret hingga 10 Maret</a></li>
<li><a href="../id442402/index.html">Paling penting. Integrasi dengan layanan eksternal</a></li>
<li><a href="../id442404/index.html">Paling penting. Integrasi dengan layanan eksternal (bagian 2)</a></li>
<li><a href="../id442406/index.html">Intisari Fintech: transfer gratis dalam sistem SBP, kerentanan bank terhadap serangan dan berita lainnya</a></li>
<li><a href="../id442408/index.html">Mesin universal untuk melakukan tes DIY, Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>