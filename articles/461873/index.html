<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏿 🙏 📬 ViewPager 2: nueva funcionalidad en el contenedor antiguo ⛹️ 👎🏽 🤟🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ViewPager es uno de los componentes más famosos y ampliamente utilizados de la Biblioteca de soporte de Android. Todos los carruseles, incorporaciones...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ViewPager 2: nueva funcionalidad en el contenedor antiguo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/461873/">  ViewPager es uno de los componentes más famosos y ampliamente utilizados de la Biblioteca de soporte de Android.  Todos los carruseles, incorporaciones y controles deslizantes más simples están hechos en él.  En febrero de 2019, el equipo de desarrollo de AndroidX lanzó ViewPager2.  Veamos cuáles eran estos requisitos previos y qué ventajas tiene la versión actualizada del componente. <br><br><img src="https://habrastorage.org/webt/eu/aw/ss/euawsscpwdgkcngbjdjqabx1uhc.png"><br><a name="habracut"></a><br><h3>  ViewPager 2 </h3><br>  En el momento de escribir la publicación (julio de 2019), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">está disponible</a> una versión beta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ViewPager2</a> , lo que significa que los problemas mencionados a continuación se pueden solucionar y mejorar y ampliar la funcionalidad.  Los desarrolladores prometen en el futuro agregar soporte para TabLayout (aunque solo puede funcionar con la primera versión), optimizar el rendimiento del adaptador, hacer muchas correcciones menores y finalizar la documentación. <br><br><h3>  Integración </h3><br>  El componente no se suministra con paquetes estándar, pero se conecta por separado.  Para hacer esto, agregue la siguiente línea al bloque de dependencias en el script gradle de su módulo: <br><br><pre><code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">"androidx.viewpager2:viewpager2:1.0.0-beta02"</span></span></code> </pre> <br><h3>  Implementación </h3><br>  Comencemos con las buenas noticias: la transición de la primera a la segunda versión es lo más simple posible y se reduce a un cambio en las importaciones.  La buena sintaxis anterior no se tocó: el método <i>getCurrentItem ()</i> devuelve la página actual, <i>ViewPager2.onPageChangeCallback le</i> permite suscribirse al <i>estado</i> del localizador, el adaptador todavía está instalado a través de <i>setAdapter ().</i> <br><br><hr><br>  Vale la pena profundizar más, ya que queda claro que el primer y el segundo localizador no tienen nada en común excepto las interfaces.  La familiaridad con la implementación del método setAdapter () no deja lugar a dudas: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Adapter adapter)</span></span></span><span class="hljs-function"> </span></span>{ mRecyclerView.setAdapter(adapter); }</code> </pre><br>  Sí, ViewPager2 es solo un contenedor sobre <b>RecyclerView</b> .  Por un lado, esta es una gran ventaja, por otro, agrega un dolor de cabeza.  Disfrazar <i>RecyclerView</i> como folleto se hizo posible con el advenimiento de <b>PagerSnapHelper</b> .  Esta clase cambia la física del desplazamiento.  Cuando el usuario suelta su dedo, <i>PagerSnapHelper</i> calcula qué elemento de la lista está más cerca de la línea central de la lista, y con una animación suave lo alinea exactamente en el centro.  Por lo tanto, si el deslizamiento fue lo suficientemente nítido, la lista se desplaza al siguiente elemento, de lo contrario, con la animación vuelve a su estado original. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PagerSnapHelper().attachToRecyclerView(mRecyclerView);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/737/962/b7a/737962b7a5620216a2a6d0c71353a2a1.gif" alt="imagen"><br><blockquote>  Cuando utilice PagerSnapHelper, asegúrese de que el ancho y el alto de RecyclerView, así como todos sus ViewHolders, estén configurados en MATCH_PARENT.  De lo contrario, el comportamiento de SnapHelper será impredecible, pueden producirse errores en lugares completamente inesperados.  Todo esto hace que la creación de un carrusel de elementos de pequeña altura lleve bastante tiempo, aunque sea posible. </blockquote><br>  Dado todo lo anterior, en el diseño el widget se verá así: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">androidx.viewpager2.widget.ViewPager2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/main_pager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  En el mismo paquete que <i>ViewPager2,</i> también podemos encontrar la clase <b>ScrollEventAdapter</b> , que ayuda a mantener la continuidad de la sintaxis.  <i>ScrollEventAdapter</i> implementa <b>RecyclerView.OnScrollListener</b> y transforma los eventos de desplazamiento <b>en</b> eventos <b>OnPageChangeCallback</b> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG &amp;&amp; newState == RecyclerView.SCROLL_STATE_DRAGGING) { ... dispatchStateChanged(SCROLL_STATE_DRAGGING); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre><br>  Ahora <i>OnPageChangeCallback no</i> está representado por una interfaz, sino por una clase abstracta, que le permite anular solo los métodos necesarios (en la mayoría de los casos, solo necesita <i>nPageSelected (Int)</i> , que funciona cuando se selecciona una página específica): <br><br><pre> <code class="java hljs">main_pager.registerOnPageChangeCallback( object : ViewPager2.OnPageChangeCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPageSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: Int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do your stuff } } )</span></span></code> </pre><br><h3>  Caracteristicas </h3><br>  <b>Cabe destacar el</b> método <b>setPageTransformer ()</b> , que toma <b>ViewPager2.PageTransformer</b> como parámetro.  Establece una <i>devolución</i> de <i>llamada</i> para cada evento de selección de página y sirve para establecer su propia animación para esta página.  <i>La devolución de llamada</i> recibe la <i>Vista de la</i> página actual y su número como entrada.  El análogo más cercano a este método es el <i>ItemAnimator</i> de <i>RecyclerView</i> . <br><br>  En las nuevas versiones de la biblioteca, se agregaron dos implementaciones del transformador: <br><br>  <b>CompositePageTransformer</b> y <b>MarginPageTransformer</b> .  El primero es responsable de combinar transformadores para aplicar varias transformaciones a un localizador a la vez, y el segundo para sangrar entre páginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53d/c0d/49b/53dc0d49b39527079355f55a5c5cf4e0.gif" alt="imagen"><br><br>  Además, el nuevo widget admite cambios de orientación: simplemente llamando al método <b>setOrientation ()</b> , puede convertir su localizador en una lista vertical con deslizamientos de arriba a abajo: <br><br><pre> <code class="kotlin hljs">main_pager.setOrientation(ViewPager2.ORIENTATION_VERTICAL)</code> </pre><br>  Esto sucede nuevamente gracias a la transición a <i>RecyclerView</i> : debajo del capó, <i>se llama</i> un cambio en la orientación del <i>LayoutManager</i> , que es responsable de mostrar los elementos de la lista.  Cabe señalar que delegar una gran cantidad de tareas a otras clases ha beneficiado al nuevo componente: su listado se ha vuelto mucho más compacto y legible. <br><br>  Este no es el final de la diversión.  En una actualización, <i>ViewPager2</i> recibió soporte para <i>ItemDecoration</i> : una clase <i>auxiliar</i> para decorar la <i>vista</i> infantil.  Este mecanismo se puede utilizar para dibujar separadores entre elementos, bordes, resaltado de celdas. <br><br>  Ya hay muchas implementaciones de decoradores listas para usar, porque durante muchos años se han utilizado con éxito al trabajar con el <i>RecyclerView</i> habitual.  Todos los desarrollos ahora son aplicables a los buscapersonas.  Fuera de la caja, está disponible una implementación estándar de separadores de buscapersonas: <br><br><pre> <code class="kotlin hljs">main_pager.addItemDecoration( DividerItemDecoration(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, RecyclerView.HORIZONTAL) )</code> </pre><br>  Junto con la próxima actualización en mayo de 2019, <i>ViewPager2</i> agregó otro método importante: <b>setOffscreenPageLimit (Int)</b> .  Él es responsable de cuántos elementos a la derecha e izquierda de la central se inicializarán en el localizador.  Aunque <i>RecyclerView</i> es responsable de almacenar en caché y mostrar la <i>Vista de</i> forma predeterminada, con este método puede establecer explícitamente el número deseado de elementos para cargar. <br><br><h3>  Adaptador </h3><br>  El sucesor ideológico del primer adaptador de buscapersonas es el <i>FragmentStateAdapter</i> : las interfaces de interacción y los nombres de clase son casi iguales.  Los cambios solo afectaron el nombramiento de algunos métodos.  Si antes era necesario implementar la función abstracta <i>getItem (posición)</i> para devolver la instancia de <i>Fragmento</i> deseada para la posición dada, y este nombre podría interpretarse de dos maneras, ahora esta función ha sido renombrada para <i>crear Fragmento (posición)</i> .  La función <i>getCount ()</i> proporciona el número total de fragmentos como antes. <br><br>  De los cambios estructurales importantes en la interfaz, también debe tenerse en cuenta que el adaptador ahora tiene la capacidad de controlar el ciclo de vida de sus elementos, por lo tanto, junto con el <i>FragmentManager</i> en el constructor, acepta un <i>objeto Lifecycle</i> , ya sea una <i>Actividad</i> o un <i>Fragmento</i> .  Debido a esto, por seguridad, los <i>métodos saveState ()</i> y <i>restoreState ()</i> se declararon definitivos y cerrados por herencia. <br>  La clase <b>FragmentViewHolder</b> es responsable de almacenar fragmentos dentro de <i>RecyclerView</i> .  El método <b>onCreateViewHolder ()</b> de <b>FragmentStateAdapter</b> llama a <b>FragmentViewHolder.create ()</b> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FragmentViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ FrameLayout container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(parent.getContext()); container.setLayoutParams( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) ); container.setId(ViewCompat.generateViewId()); container.setSaveEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FragmentViewHolder(container); }</code> </pre><br>  Cuando se <b>llama al</b> método <b>onBindViewHolder ()</b> , se <b>asocia</b> el identificador del elemento en la posición actual y el identificador <i>ViewHolder</i> , para adjuntarle aún más el fragmento: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> itemId = holder.getItemId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHolderId = holder.getContainer().getId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long boundItemId = itemForViewHolder(viewHolderId); ... mItemIdToViewHolder.put(itemId, viewHolderId); ensureFragment(position); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Y finalmente, cuando se <i>adjunta</i> un contenedor desde <i>ViewHolder</i> a la jerarquía de <i>Vista</i> , se ejecuta una <i>FragmentTransaction</i> , agregando un <i>Fragment</i> al contenedor: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">placeFragmentInViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FragmentViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Fragment fragment = mFragments.get(holder.getItemId()); ... scheduleViewAttach(fragment, container); mFragmentManager.beginTransaction() .add(fragment, <span class="hljs-string"><span class="hljs-string">"f"</span></span> + holder.getItemId()) .setMaxLifecycle(fragment, STARTED) .commitNow(); ... }</code> </pre><br>  Por lo tanto, <i>surgen</i> dos usos de <i>ViewPager2</i> : heredando la clase de adaptador, ya sea directamente desde <i>RecyclerView.Adapter</i> o desde <i>FragmentStateAdapter</i> . <br><br><hr><br>  Seguramente tendrá una pregunta: ¿por qué usar un segundo localizador con Fragmentos y un adaptador para ellos cuando hay una primera versión que funciona normalmente?  <i>ViewPager</i> está lejos de ser una "bala de plata" cuando se trabaja con grandes listas de datos dinámicos.  Es ideal para crear carruseles con un conjunto estático de imágenes o pancartas, pero las noticias paginadas con la carga de publicaciones publicitarias y el filtrado dan lugar a monstruos feos y con un gran apoyo.  Tarde o temprano, seguramente se encontrará con un deseo ardiente de reescribir todo en <i>RecyclerView</i> .  Ahora no tiene que hacer esto, porque el buscapersonas mismo se convirtió en él, tomando prestadas sus poderosas capacidades para trabajar con listas dinámicas, mientras las ajusta en la sintaxis habitual. <br><br>  Lo único que <i>PagerAdapter</i> puede ofrecernos es el método <b>notifyDataSetChanged ()</b> , que obliga al <i>ViewPager a</i> volver <i>a</i> dibujar todos los elementos de la lista representada.  Puede notar razonablemente que nadie nos impide almacenar una lista de posiciones para elementos existentes y devolver <i>POSITION_UNCHANGED</i> desde el método <i>getItemPosition ()</i> para ellos, eso es todo.  Sin embargo, esta solución no se puede llamar hermosa, es bastante engorrosa, además, es difícil ampliar en aquellos casos en que los elementos en la lista cambian constantemente, y no solo se agregan secuencialmente al final.  <i>FragmentStateAdapter</i> tiene un arsenal completo de métodos <i>RecyclerView.Adapter</i> , por lo que la lógica de redibujar elementos se puede configurar de manera mucho más flexible.  Además, junto con el <i>FragmentStateAdapter,</i> puede usar <i>DiffUtil</i> , que le permite automatizar casi por completo el trabajo de notificación de cambios. <br><br><img src="https://habrastorage.org/webt/8s/j9/xg/8sj9xgon6lnfcn1thlzbhox2jtw.png"><br><blockquote>  <b>Atencion</b>  Para que los métodos de <i>notificación</i> ... funcionen correctamente (excepto para <i>notifyDataSetChanged</i> ), los <b>métodos getItemId (Int)</b> y c <b>ontainsItem (Long)</b> deben redefinirse.  Esto se hace porque la implementación predeterminada solo mira el número de página, y si, por ejemplo, agrega un nuevo elemento después del actual, no se agregará, ya que <i>getItemId</i> permanecerá sin cambios.  Un ejemplo de anulación de estos dos métodos basado en una lista de elementos de tipo <i>Int</i> : </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[position].toLong() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(itemId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.contains(itemId.toInt()) }</code> </pre><br><hr><br>  La razón principal de la aparición de <i>ViewPager2</i> es la renuencia a reinventar la rueda.  Por un lado, el <b>equipo de</b> desarrollo de <b>AndroidX está</b> claramente listo para abandonar el obsoleto <i>ViewPager</i> ahora y ciertamente no va a invertir en expandir su funcionalidad.  Si y por que?  Después de todo, <i>RecyclerView</i> ya sabe todo lo que se necesita.  Por otro lado, la eliminación y finalización del soporte para un componente tan ampliamente utilizado obviamente no agregará lealtad a la comunidad. <br><br>  Para resumir: <i>ViewPager2 es</i> definitivamente digno de atención, aunque en este momento no está exento de fallas graves. <br><br><h3>  Contras </h3><br><ul><li>  Humedad y una gran cantidad de errores (excusable para la versión beta); </li><li>  Cercanía.  <i>RecyclerView</i> es un campo <i>privado</i> de <i>ViewPager2</i> , que nos priva de muchas oportunidades: es imposible implementar <i>deslizar para descartar</i> o <i>arrastrar y soltar</i> ( <b>ItemTouchHelper se</b> conecta directamente a <i>RecyclerView</i> ), no puede redefinir <b>ItemAnimator</b> de ninguna manera, no acceda a <b>LayoutManager</b> directamente y use <b>RecycledViewPool</b> .  Sin embargo, con el lanzamiento de nuevas versiones del componente, la cantidad de métodos de interfaz heredados de <i>RecyclerView</i> está creciendo (por ejemplo, <i>ItemDecoration</i> ), y podemos esperar agregar los métodos que faltan en el futuro. </li></ul><br><h3>  Pros </h3><br><ul><li>  Soporte para todas las ventajas de <i>RecyclerView.Adapter</i> : combina elementos de diferentes tipos en una lista, agrega y elimina elementos directamente durante el deslizamiento, redibuja animadamente el contenido de la lista al cambiar; </li><li>  Soporte para todo el espectro de <i>los</i> métodos de <i>notificación</i> ... y cálculo automático de cambios usando <i>DiffUtil</i> ; </li><li>  Facilidad de transición debido a la continuidad de la sintaxis; </li><li>  Soporte para orientación vertical y horizontal "fuera de la caja"; </li><li>  Soporte <i>RTL</i> ; </li><li>  <i>Artículo de</i> soporte <i>Decorador</i> ; </li><li>  Soporte para el <i>desplazamiento de</i> software a través de <i>fakeScrollBy ()</i> ; </li><li>  Capacidad para establecer manualmente el número de elementos cargados; </li><li>  La capacidad de utilizar cualquiera de las soluciones de código abierto listas para usar para reducir el <i>código repetitivo</i> , lo cual es inevitable cuando se escribe <i>RecyclerView.Adapter</i> personalizado.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>EasyAdapter</i></a> . </li></ul><br>  Como resumen, quiero decir que realmente vale la pena ver <b>más de cerca ViewPager2</b> .  Esta es una solución prometedora, extensible y funcional.  Y aunque es demasiado pronto para lanzar un <i>nuevo widget</i> en producción, es seguro decir que después de un lanzamiento completo puede y debe suplantar por completo a su antepasado. <br><br>  Para aquellos atrevidos y decisivos, a quienes el artículo inspiró para experimentar, <i>PagerSnapHelper</i> apareció en la versión 28 de la <b>Biblioteca de soporte</b> , lo que significa que puede usarlo junto con su <i>RecyclerView</i> creando <i>ViewPager2 usted mismo</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La</a> operación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muestra</a> de <i>ViewPager2</i> y <i>FragmentStateAdapter</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Notas de lanzamiento</a> oficiales ViewPager2 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461873/">https://habr.com/ru/post/461873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461859/index.html">No sabes nada de tecnología de alimentos.</a></li>
<li><a href="../461861/index.html">Office 365 Cloud Security: Check Point CloudGuard SaaS Testing</a></li>
<li><a href="../461865/index.html">Video curso “Introducción a la inversión desde cero utilizando IDA PRO. Capitulo 1</a></li>
<li><a href="../461867/index.html">Cómo reconocer imágenes y textos en su teléfono usando ML Kit</a></li>
<li><a href="../461871/index.html">101 consejos para convertirte en un buen programador (y humano)</a></li>
<li><a href="../461875/index.html">5 nm vs 3 nm</a></li>
<li><a href="../461877/index.html">Java vs Kotlin para Android: opiniones de desarrolladores</a></li>
<li><a href="../461879/index.html">El libro "Linux en acción"</a></li>
<li><a href="../461881/index.html">Guía de registro de Node.js</a></li>
<li><a href="../461885/index.html">EDS es otro tipo de fraude</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>