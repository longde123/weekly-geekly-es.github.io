<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ ğŸ‘¨ğŸ¿â€ğŸ­ ğŸ¤›ğŸ¾ Buku Bereaksi Cepat. Aplikasi web dalam React, JSX, Redux dan GraphQL Â» ğŸ‘©â€ğŸš’ ğŸ‘©â€ğŸš€ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Edisi asli dirilis pada musim gugur 2017, tetapi masih dianggap sebagai buku terbaik untuk menjelajahi React. Penulis terus memperb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku Bereaksi Cepat. Aplikasi web dalam React, JSX, Redux dan GraphQL Â»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/446440/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/za/bm/rw/zabmrwn_latmfqhxzpog6svpeoe.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Edisi asli dirilis pada musim gugur 2017, tetapi masih dianggap sebagai buku terbaik untuk menjelajahi React.  Penulis terus memperbarui dan memodifikasi kode untuk buku di repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> . <br><br>  Kami menyarankan dalam posting untuk berkenalan dengan bagian "Serikat dan peran mereka dalam sifat interaktif React" <br><br>  Jika Anda harus membaca hanya satu bab dalam buku ini, Anda harus memilih yang ini!  Tanpa status, komponen Bereaksi tetap tidak lebih dari pola statis lanjut.  Saya harap Anda berbagi antusiasme saya karena memahami konsep-konsep dalam bab ini akan memungkinkan Anda untuk membangun aplikasi yang jauh lebih menarik. <br><br><a name="habracut"></a><br>  Bayangkan Anda sedang membangun bidang input dengan pelengkapan otomatis (Gbr. 4.1).  Saat memasukkan data, bidang harus mengeluarkan permintaan ke server untuk mendapatkan informasi tentang opsi yang sesuai untuk menampilkan output di halaman web.  Anda telah bekerja dengan properti sejauh ini, dan Anda tahu bahwa mengubah properti memungkinkan Anda untuk mendapatkan tampilan berbeda.  Namun, properti tidak dapat diubah dalam konteks komponen saat ini, karena mereka dilewatkan ketika komponen dibuat. <br><br><img src="https://habrastorage.org/webt/hv/b_/s0/hvb_s0fbckd7lprixqyfldxeyao.png" align="left" alt="gambar">  Dengan kata lain, properti tidak dapat diubah dalam komponen saat ini, yang berarti bahwa Anda tidak dapat mengubah properti di komponen ini kecuali jika Anda membuat ulang komponen dan mentransfer nilai baru dari induknya (Gbr. 4.2).  Tetapi informasi yang diterima dari server perlu disimpan di suatu tempat, dan kemudian daftar opsi baru harus ditampilkan dalam tampilan.  Bagaimana cara memperbarui tampilan jika properti tidak dapat diubah? <br><br>  Salah satu solusi yang mungkin adalah membuat elemen dengan properti baru setiap kali Anda menerima respons baru dari server.  Tetapi kemudian Anda harus menempatkan logika di luar komponen - dan komponen berhenti mandiri.  Jelas, jika nilai properti tidak dapat diubah, dan pelengkapan otomatis harus mandiri, tidak mungkin untuk menggunakan properti.  Kemudian muncul pertanyaan: bagaimana cara memperbarui tampilan dalam menanggapi peristiwa tanpa membuat ulang komponen (createElement () atau JSX &lt;NAME /&gt;)?  Inilah masalah yang dipecahkan negara bagian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rh/2n/rm/rh2nrmgxmoggbssmhcytpnqlwmk.png" alt="gambar"></div><br>  Setelah respons dari server siap, kode panggilan balik akan mengubah status komponen yang sesuai.  Anda harus menulis kode ini sendiri.  Namun, setelah negara diperbarui, Bereaksi akan secara otomatis memperbarui tampilan untuk Anda (hanya di tempat-tempat di mana harus diperbarui, yaitu, di mana data negara digunakan). <br><br>  Dengan status komponen Bereaksi, Anda dapat membuat aplikasi Bereaksi yang interaktif dan bermakna.  Status adalah konsep dasar yang memungkinkan Anda membangun komponen Bereaksi yang dapat menyimpan data dan memperbarui tampilan secara otomatis sesuai dengan perubahan data. <br><br><h3>  Bagaimana keadaan komponen Bereaksi? </h3><br>  Keadaan Bereaksi adalah penyimpanan data komponen yang dapat diubah - blok berorientasi fungsi yang berdiri sendiri dari antarmuka pengguna dan logika.  "Variabilitas" berarti bahwa nilai status dapat berubah.  Dengan menggunakan status dalam tampilan (render ()) dan mengubah nilai nanti, Anda dapat memengaruhi tampilan tampilan. <br><br>  Metafora: jika Anda membayangkan komponen dalam bentuk fungsi, ke input yang properti dan negara ditransmisikan, hasil dari fungsi akan menjadi deskripsi antarmuka pengguna (presentasi).  Properti dan status memperluas tampilan, tetapi digunakan untuk tujuan yang berbeda (lihat bagian 4.3). <br><br>  Saat bekerja dengan negara, Anda mengaksesnya dengan nama.  Nama adalah atribut (yaitu, kunci objek atau properti objek - bukan properti komponen) objek this.state, misalnya this.state.autocompleMatches atau this.state.inputFieldValue. <br><br>  Status data sering digunakan untuk menampilkan informasi dinamis dalam tampilan untuk memperluas rendering tampilan.  Kembali ke contoh sebelumnya dari bidang autocomplete: status berubah sebagai respons terhadap permintaan XHR ke server, yang, pada gilirannya, dimulai dengan memasukkan data ke dalam bidang.  Bereaksi memastikan bahwa tampilan diperbarui ketika keadaan yang digunakan dalam perubahan tampilan.  Bahkan, ketika keadaan berubah, hanya bagian yang sesuai dari representasi yang berubah (ke elemen individual dan bahkan nilai atribut dari elemen individual). <br><br>  Segala sesuatu yang lain di DOM tetap tidak berubah.  Ini dimungkinkan berkat model DOM virtual (lihat bagian 1.1.1), yang Bereaksi gunakan untuk menentukan delta (totalitas perubahan) selama proses rekonsiliasi.  Fakta ini memungkinkan Anda untuk menulis kode dengan gaya deklaratif.  Bereaksi melakukan semua rutin untuk Anda.  Tahapan utama untuk mengubah presentasi dibahas di Bab 5. <br><br>  Bereaksi pengembang menggunakan status untuk menghasilkan antarmuka pengguna baru.  Properti komponen (this.props), variabel biasa (inputValue) dan atribut kelas (this.inputValue) tidak cocok untuk ini, karena mengubah nilainya (dalam konteks komponen saat ini) tidak memicu perubahan dalam tampilan.  Misalnya, cuplikan berikut ini adalah antipattern, yang menunjukkan bahwa mengubah nilai di mana pun kecuali keadaan tidak akan menyebabkan tampilan menyegarkan: <br><br><pre><code class="plaintext hljs">// :   ! let inputValue = 'Texas' class Autocomplete extends React.Component { updateValues() â† {      ( ) this.props.inputValue = 'California' inputValue = 'California' this.inputValue = 'California' } render() { return ( &lt;div&gt; {this.props.inputValue} {inputValue} {this.inputValue} &lt;/div&gt; ) } }</code> </pre> <br>  Sekarang mari kita lihat bagaimana cara bekerja dengan keadaan komponen Bereaksi. <br><br><h3>  Bekerja dengan negara </h3><br>  Untuk bekerja dengan status, Anda harus dapat mengakses nilai, memperbaruinya, dan menetapkan nilai awal.  Mari kita mulai dengan merujuk pada status dalam komponen Bereaksi. <br><br><h3>  Akses ke negara </h3><br>  Objek status adalah atribut komponen, dan Anda harus mengaksesnya melalui tautan ini, misalnya this.state.name.  Seperti yang Anda ingat, variabel dapat diakses dan ditampilkan dalam kode JSX dalam kurung kurawal ({}).  Demikian pula, dalam render (), Anda dapat membuat ini.state (seperti atribut variabel atau kelas lainnya dari komponen non-standar), misalnya {this.state.inputFieldValue}.  Sintaks ini mirip dengan sintaks untuk mengakses properti di this.props.name. <br><br><img src="https://habrastorage.org/webt/ei/wy/cj/eiwycjaglq1319bi377c13zyat8.png" align="left" alt="gambar">  Kami menggunakan apa yang Anda pelajari untuk mengimplementasikan jam dalam gambar.  4.3.  Tujuan kami adalah membuat kelas komponen otonom yang dapat diimpor dan digunakan siapa pun dalam aplikasi mereka tanpa banyak kesulitan.  Jam harus menampilkan waktu saat ini. <br><br>  Proyek ini memiliki struktur sebagai berikut: <br><br><pre> <code class="plaintext hljs">/clock index.html /jsx script.jsx clock.jsx /js script.js clock.js react.js react-dom.js</code> </pre> <br>  Saya menggunakan Babel CLI dengan flag pelacakan (-w) dan direktori (-d) untuk mengkompilasi semua file sumber JSX dari clock / jsx ke folder target jam / js dan mengkompilasi ulang ketika perubahan terdeteksi.  Selain itu, saya menyimpan perintah sebagai skrip npm di file package.json dari folder induk ch04 untuk mengeksekusi perintah run-jam npm run dari ch04: <br><br><pre> <code class="plaintext hljs">"scripts": { "build-clock": "./node_modules/.bin/babel clock/jsx -d clock/js -w" },</code> </pre> <br>  Tentu saja, waktu tidak berhenti (apakah kita suka atau tidak).  Karena itu, Anda harus terus memperbarui tampilan, dan untuk ini Anda dapat menggunakan negara.  Beri nama currentTime dan coba render status seperti yang ditunjukkan pada Listing 4.1. <br><br>  Daftar 4.1.  Render keadaan BEJ <br><br><pre> <code class="plaintext hljs">class Clock extends React.Component { render() { return &lt;div&gt;{this.state.currentTime}&lt;/div&gt; } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById('content') )</code> </pre> <br>  Anda akan menerima pesan kesalahan: UnEught TypeError: Tidak dapat membaca properti 'currentTime' dari nol.  Biasanya pesan kesalahan JavaScript memiliki manfaat yang sama dengan segelas air dingin untuk orang yang tenggelam.  Sangat bagus bahwa setidaknya dalam kasus ini, JavaScript menampilkan pesan yang bermakna. <br><br>  Pesan tersebut menunjukkan bahwa nilai currentTime tidak terdefinisi.  Tidak seperti properti, status tidak disetel pada induk.  Memanggil setState di render () juga gagal, karena itu akan membuat loop (setState -&gt; render -&gt; setState ...) - dan Bereaksi akan melaporkan kesalahan. <br><br><h3>  Penugasan keadaan awal </h3><br>  Anda telah melihat bahwa sebelum menggunakan data status di render (), Anda harus menginisialisasi status.  Untuk mengatur keadaan awal, gunakan status ini dalam konstruktor dengan sintaks kelas ES6 React.Component.  Ingatlah untuk memanggil super () dengan properti;  jika tidak, logika di induk (React.Component) tidak akan berfungsi: <br><br><pre> <code class="plaintext hljs">class MyFancyComponent extends React.Component { constructor(props) { super(props) this.state = {...} } render() { ... } }</code> </pre> <br>  Saat menetapkan keadaan awal, Anda juga dapat menambahkan logika lain - misalnya, atur nilai currentTime menggunakan Date baru ().  Anda bahkan dapat menggunakan toLocaleString () untuk mendapatkan format tanggal / waktu yang benar untuk lokasi pengguna saat ini, seperti yang ditunjukkan di bawah ini (ch04 / jam). <br><br>  Listing 4.2.  Konstruktor komponen jam <br><br><pre> <code class="plaintext hljs">class Clock extends React.Component { constructor(props) { super(props) this.state = {currentTime: (new Date()).toLocaleString()} } ... }</code> </pre> <br>  Nilai this.state harus berupa objek.  Kami tidak akan membahas detail konstruktor () dari ES6;  lihat Lampiran D dan Ringkasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ES6</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/azat-co/cheatsheets/tree/master/es6</a> .  Intinya adalah bahwa, seperti dalam bahasa OOP lainnya, sebuah konstruktor (yaitu konstruktor ()) dipanggil ketika instance kelas dibuat.  Nama metode konstruktor harus hanya itu;  pertimbangkan ini salah satu aturan ES6.  Selain itu, saat membuat metode konstruktor (), panggilan super () hampir selalu disertakan di dalamnya, tanpanya, konstruktor induk tidak akan dieksekusi.  Di sisi lain, jika Anda tidak mendefinisikan metode constructor (), maka panggilan ke super () akan dianggap secara default. <br><br>  Nama currentTime adalah opsional;  Anda harus menggunakan nama yang sama nanti ketika membaca dan memperbarui keadaan ini. <br><br>  Objek keadaan dapat berisi objek atau array bersarang.  Contoh berikut menambahkan array deskripsi buku ke keadaan: <br><br><pre> <code class="plaintext hljs">class Content extends React.Component { constructor(props) { super(props) this.state = { githubName: 'azat-co', books: [ 'pro express.js', 'practical node.js', 'rapid prototyping with js' ] } } render() { ... } }</code> </pre> <br>  Metode constructor () dipanggil hanya sekali, ketika membuat elemen Bereaksi berdasarkan kelas.  Dengan demikian, Anda dapat mengatur negara secara langsung menggunakan this.state hanya sekali - dalam metode constructor ().  Jangan mengatur atau memperbarui negara secara langsung dengan this.state = ... di tempat lain, karena ini dapat menyebabkan konsekuensi yang tidak terduga. <br><br>  Jadi Anda hanya mendapatkan nilai awal, yang dengan cepat akan menjadi usang - hanya dalam 1 detik.  Siapa yang butuh arloji yang tidak menunjukkan waktu saat ini?  Untungnya, ada mekanisme untuk memperbarui keadaan saat ini. <br><br><h3>  Pembaruan status </h3><br>  Status diubah dengan metode kelas this.setState (data, callback).  Ketika metode ini dipanggil, Bereaksi menggabungkan data dengan status saat ini dan panggilan render (), setelah itu ia memanggil panggilan balik. <br><br>  Mendefinisikan callback callback di setState () penting karena metode ini bekerja secara tidak sinkron.  Jika aplikasi tergantung pada status baru, Anda dapat menggunakan panggilan balik ini untuk memastikan bahwa status baru telah tersedia. <br><br>  Jika Anda hanya berasumsi bahwa negara telah diperbarui tanpa menunggu setState () selesai, yaitu bekerja secara serempak saat melakukan operasi asinkron, kesalahan dapat terjadi: program bergantung pada pemutakhiran nilai status, tetapi keadaan tetap lama. <br>  Sejauh ini, kami telah memberikan waktu dari negara.  Anda sudah tahu cara mengatur keadaan awal, tetapi harus diperbarui setiap detik, bukan?  Untuk melakukan ini, gunakan fungsi pengatur waktu browser setInterval () (http://mng.bz/P2d6), yang akan memperbarui status setiap n milidetik.  Metode setInterval () diimplementasikan di hampir semua browser modern sebagai global, yang berarti dapat digunakan tanpa pustaka atau awalan tambahan.  Contoh: <br><br><pre> <code class="plaintext hljs">setInterval(()=&gt;{ console.log('Updating time...') this.setState({ currentTime: (new Date()).toLocaleString() }) }, 1000)</code> </pre> <br>  Untuk memulai hitungan mundur, Anda perlu memanggil setInterval () hanya sekali.  Kami membuat metode launchClock () hanya untuk tujuan ini;  launchClock () akan dipanggil di konstruktor.  Versi terakhir dari komponen ini ditunjukkan pada Listing 4.3 (ch04 / clock / jsx / clock.jsx). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wk/uz/ez/wkuzezejgvya-npm71161pn-_aa.png" alt="gambar"></div><br>  Metode setState () dapat dipanggil di mana saja, tidak hanya dalam metode launchClock () (yang disebut dalam konstruktor), seperti pada contoh.  Biasanya, metode setState () dipanggil dari event handler atau sebagai panggilan balik ketika data diterima atau diperbarui. <br><br><blockquote>  TIP Upaya mengubah status dalam kode dengan perintah dari formulir this.state.name = 'nama baru' tidak akan menghasilkan apa pun.  Ini tidak akan menyebabkan rendering ulang dan memperbarui model DOM yang sebenarnya, apa yang Anda inginkan.  Dalam sebagian besar kasus, perubahan status langsung tanpa setState () bersifat antipattern dan harus dihindari. </blockquote><br>  Penting untuk dicatat bahwa metode setState () hanya memutakhirkan status yang diteruskan (sebagian atau digabung, tetapi tanpa penggantian yang lengkap).  Itu tidak mengganti seluruh objek negara setiap waktu.  Oleh karena itu, jika hanya satu dari tiga negara telah berubah, dua lainnya akan tetap tidak berubah.  Dalam contoh berikut, userEmail dan userId tidak akan berubah: <br><br><pre> <code class="plaintext hljs">constructor(props) { super(props) this.state = { userName: 'Azat Mardan', userEmail: 'hi@azat.co', userId: 3967 } } updateValues() { this.setState({userName: 'Azat'}) }</code> </pre> <br>  Jika Anda bermaksud memperbarui ketiga status, Anda harus melakukan ini secara eksplisit dengan meneruskan nilai baru dari status ini ke setState ().  (Juga dalam kode lama, yang sekarang tidak lagi berfungsi, metode this.replaceState () kadang-kadang ditemukan; secara resmi tidak digunakan 1. Seperti yang Anda tebak dengan namanya, ia mengganti seluruh objek keadaan dengan semua atributnya.) <br><br>  Ingat bahwa memanggil setState () memulai eksekusi render ().  Dalam kebanyakan kasus, ini berfungsi.  Dalam beberapa kasus khusus di mana kode tergantung pada data eksternal, Anda dapat memulai render dengan memanggil this.forceUpdate ().  Namun demikian, keputusan seperti itu tidak diinginkan, karena mengandalkan data eksternal (bukan negara) membuat komponen kurang dapat diandalkan dan tergantung pada faktor-faktor eksternal (ikatan ketat). <br><br>  Seperti yang disebutkan sebelumnya, objek keadaan dapat diakses di entri this.state.  Di BEJ, nilai-nilai output terlampir dalam kurung kurawal ({}), oleh karena itu, untuk menyatakan properti negara dalam tampilan (yaitu, dalam perintah pengembalian metode render), gunakan notasi {this.state.NAME}. <br><br>  Bereaksi ajaib terjadi ketika Anda menggunakan data status dalam tampilan (misalnya, dalam output, dalam perintah if / else, sebagai nilai atribut atau nilai properti anak), lalu meneruskan setState () nilai baru.  Bah!  Bereaksi pembaruan semua markup HTML yang diperlukan untuk Anda.  Anda dapat memverifikasi ini di konsol DevTools, di mana siklus "Memperbarui ..." dan "Rendering ..." harus ditampilkan.  Dan hal yang hebat adalah bahwa ini hanya akan mempengaruhi elemen DOM minimum absolut yang diperlukan. <br><br>  Â»Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 20% untuk penjaja - <b>Bereaksi</b> <br><br>  Setelah pembayaran versi kertas buku, versi elektronik buku dikirim melalui email. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446440/">https://habr.com/ru/post/id446440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446430/index.html">Pendinginan partikel nano melayang melalui resonator optik</a></li>
<li><a href="../id446432/index.html">Sebuah seminar tentang manajemen dokumen teknis diadakan di Crimea</a></li>
<li><a href="../id446434/index.html">Zimbra Collaboration Suite Scaling</a></li>
<li><a href="../id446436/index.html">Cara menghasilkan hipotesis tentang kebutuhan konsumen potensial produk masa depan Anda</a></li>
<li><a href="../id446438/index.html">Pengalaman Pembuatan API Gateway Kami</a></li>
<li><a href="../id446444/index.html">Dari Skype ke WebRTC: Bagaimana Kami Mengatur Komunikasi Video Web</a></li>
<li><a href="../id446446/index.html">Dasar-dasar mesin JavaScript: bentuk umum dan cache inline. Bagian 1</a></li>
<li><a href="../id446448/index.html">5 aturan dasar untuk melakukan wawancara masalah untuk mengidentifikasi kebutuhan konsumen</a></li>
<li><a href="../id446452/index.html">Misi Lunar "Bereshit" - 4 April 2019, transisi ke orbit bulan selesai, 7 hari penerbangan di depan, 6 manuver dan 1 pendaratan</a></li>
<li><a href="../id446454/index.html">Pengembangan Server Web Golang - Dari Mudah ke Kompleks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>