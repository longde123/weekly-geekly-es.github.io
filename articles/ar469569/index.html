<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👩 🙅 🛌🏿 Arend - لغة الكتابة المعتمدة على بروتوكول HoTT (الجزء 1) 👨🏽‍🌾 ℹ️ 👐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في هذا المنشور ، سنتحدث عن لغة JetBrains التي تم إصدارها حديثًا مع الأنواع المعتمدة من Arend (تم تسمية اللغة باسم Gating Rent ). تم تطوير هذه اللغة بو...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - لغة الكتابة المعتمدة على بروتوكول HoTT (الجزء 1)</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/" style=";text-align:right;direction:rtl"> في هذا المنشور ، سنتحدث عن لغة JetBrains التي تم إصدارها حديثًا مع الأنواع المعتمدة من Arend (تم تسمية اللغة باسم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Gating Rent</a> ).  تم تطوير هذه اللغة بواسطة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">JetBrains Research</a> خلال السنوات القليلة الماضية.  على الرغم من إتاحة المستودعات قبل عام بشكل عام على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">github.com/JetBrains</a> ، إلا أن الإصدار الكامل من Arend لم يحدث إلا في يوليو من هذا العام. <br><br>  سنحاول معرفة كيف يختلف Arend عن الأنظمة الحالية للرياضيات النظامية استنادًا إلى الأنواع التابعة ، والوظائف المتوفرة الآن لمستخدميها.  نحن نفترض أن قارئ هذه المقالة معتادًا بشكل عام على الأنواع التابعة وقد سمع واحدة على الأقل من اللغات المعتمدة على أنواع تابعة: Agda أو Idris أو Coq أو Lean.  ومع ذلك ، لا نتوقع أن يكون للقارئ أنواع تابعة في مستوى متقدم. <br><br>  من أجل البساطة والاطمئنان ، سترافق قصتنا حول أنواع Arend و homotopy عن طريق تطبيق Arend لأبسط خوارزميات فرز القائمة - حتى مع هذا المثال ، يمكنك أن تشعر بالفرق بين Arend و Agda و Coq.  يوجد بالفعل عدد من المقالات حول Habré المخصصة للأنواع التابعة.  دعنا نقول عن تنفيذ قوائم الفرز باستخدام طريقة QuickSort على Agda هناك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثل هذه المقالة</a> .  سنقوم بتنفيذ خوارزمية أبسط لفرز إدراج.  في هذه الحالة ، سوف نركز على إنشاءات لغة Arend ، وليس على خوارزمية الفرز نفسها. <br><a name="habracut"></a><br>  لذلك ، فإن الاختلاف الرئيسي بين Arend واللغات الأخرى ذات الأنواع التابعة هو النظرية المنطقية التي تقوم عليها.  يستخدم Arend هكذا نظرية نوع homotopy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V. Voevodsky</a> المكتشفة حديثًا.  بشكل أكثر تحديدًا ، يعتمد Arend على صيغة HTT تسمى "نظرية الكتابة ذات التباعد".  تذكر أن Coq يستند إلى ما يسمى بحساب التفاضل والتكامل للإنشاءات الاستقرائي (حساب التفاضل والتكامل للإنشاءات الاستقرائية) ، في حين تستند Agda و Idris على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نظرية Martin-Löf المكثفة للأنواع</a> .  حقيقة أن Arend يعتمد على HoTT تؤثر بشكل كبير على الإنشاءات النحوية وتشغيل خوارزمية التحقق من النوع (typcheker).  سنناقش هذه الميزات في هذه المقالة. <br><br>  دعنا نحاول أن تصف بإيجاز حالة البنية الأساسية للغات.  بالنسبة إلى Arend ، يوجد مكون إضافي لبرنامج IntelliJ IDEA ، والذي يمكن تثبيته مباشرة من مستودع إضافات IDEA.  من حيث المبدأ ، يكفي تثبيت المكوّن الإضافي للعمل بشكل كامل مع Arend ، لا تزال لا تحتاج إلى تنزيل وتثبيت أي شيء.  بالإضافة إلى التحقق من الكتابة ، يوفر البرنامج المساعد Arend وظيفة مألوفة لمستخدمي IDEA: هناك تسليط الضوء على ومواءمة التعليمات البرمجية ، مختلف refactorings والنصائح.  هناك أيضًا خيار استخدام إصدار وحدة التحكم من Arend.  يمكن العثور <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> على وصف أكثر تفصيلاً لعملية التثبيت. <br><br>  تستند أمثلة التعليمات البرمجية في هذه المقالة إلى مكتبة Arend القياسية ، لذلك نوصي بتنزيل التعليمات البرمجية المصدر الخاصة بها من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المستودع</a> .  بعد التنزيل ، يجب استيراد الدليل المصدر كمشروع IDEA باستخدام أمر استيراد المشروع.  في Arend ، تم بالفعل إضفاء الطابع الرسمي على بعض أقسام نظرية نوع homotopy ونظرية الحلقة.  على سبيل المثال ، في المكتبة القياسية ، يتم تنفيذ سلسلة الأعداد المنطقية Q مع أدلة جميع الخصائص النظرية المطلوبة. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثائق اللغة</a> التفصيلية ، التي يتم فيها شرح الكثير من النقاط التي تتناولها هذه المقالة بمزيد من التفصيل ، هي أيضًا في المجال العام.  يمكنك طرح الأسئلة مباشرة على مطوري Arend في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قناة التلغراف</a> . <br><br><h2 style=";text-align:right;direction:rtl">  1. نظرة عامة على HoTT / Arend </h2><br>  نظرية نوع Homotopy (أو باختصار HoTT) هي نوع من نظرية النوع المكثف التي تختلف عن نظرية النوع Martin-Löf الكلاسيكية (MLTT ، التي تستند إليها Agda) وحساب التفاضل والتكامل الاستقرائي (CIC ، الذي يستند إليه Coq) ، تحتوي البيانات والمجموعات على الأنواع المسماة بمستوى homotopy العالي. <br><br>  في هذا المقال ، لا نضع أنفسنا هدفًا لشرح أسس HoTT بالتفصيل - من أجل عرض تفصيلي لهذه النظرية ، سيكون من الضروري إعادة كتابة الكتاب بالكامل (انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا المنشور</a> ).  نلاحظ فقط أن النظرية القائمة على البديهيات في HoTT ، إلى حد ما ، أكثر أناقة وإثارة للاهتمام من نظرية النوع مارتن لووف الكلاسيكية.  وبالتالي ، فإن عددًا من البديهيات التي كان لابد من فرضها مسبقًا (على سبيل المثال ، الإمتداد الوظيفي) قد ثبت في HoTT كنظريات.  بالإضافة إلى ذلك ، في HoTT ، يمكن للمرء تحديد مجالات homotopy متعددة الأبعاد داخليًا وحتى حساب بعض <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مجموعات homotopy</a> الخاصة بهم. <br><br>  ومع ذلك ، فإن هذه الجوانب من HoTT مثيرة للاهتمام في المقام الأول لعلماء الرياضيات ، والغرض من هذه المقالة هو شرح كيف يقارن Arend المستندة إلى HoTT بشكل إيجابي مع Agda / MLTT و Coq / CIC من خلال مثال تمثيل مثل بسيط ومألوف لأي كيانات مبرمج.  عند قراءة هذا المقال ، يكفي أن نعامل HoTT كنوع من نظرية النوع المكثف مع بديهيات أكثر تطوراً ، مما يعطي الراحة عند العمل مع الأكوان والمساواة. <br><br><h2 style=";text-align:right;direction:rtl">  1.1 الأنواع التابعة ، مراسلة كاري - هوارد ، الأكوان </h2><br>  تذكر أن اللغات ذات الأنواع التابعة تختلف عن لغات البرمجة الوظيفية العادية في ذلك بالإضافة إلى أنواع البيانات المعتادة ، مثل القوائم أو الأرقام الطبيعية ، هناك أنواع تعتمد على قيمة المعلمة.  أبسط الأمثلة على هذه الأنواع هي متجهات بطول معين n أو أشجار متوازنة بعمق معين d.  تم ذكر بعض الأمثلة الإضافية على هذه الأنواع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا.</a> <br><br>  تذكر أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مراسلات Curry - Howard</a> تسمح للمرء بتفسير عبارات المنطق كأنواع تابعة.  الفكرة الرئيسية لهذه المراسلات هي أن النوع الفارغ يتوافق مع بيان خاطئ ، وأنواع السكان المأهولة تتوافق مع عبارة حقيقية.  يمكن اعتبار عناصر الكتابة كدليل على البيان المنطقي المقابل.  على سبيل المثال ، يمكن اعتبار أي عنصر مثل الأعداد الصحيحة كدليل على حقيقة وجود أعداد صحيحة (أي ، يتم ملء نوع الأعداد الصحيحة). <br><br>  تتوافق الإنشاءات الطبيعية المختلفة على الأنواع مع روابط منطقية مختلفة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <i>يُطلق على منتج النوعين A × B</i> أحيانًا نوع الزوج Pair A B. نظرًا لأن هذا النوع يتم تعبئته في حالة ملء كلا النوعين A و B فقط ، فإن هذا البناء يتوافق مع المنطق "و". </li><li style=";text-align:right;direction:rtl">  <i>مجموع الأنواع A + B.</i> في Haskell ، يسمى هذا النوع إما A B. حيث أن هذا النوع ممتلئ إذا وفقط إذا كان أحد الأنواع A أو B ، فإن هذا البناء يتوافق مع منطقية "أو". <br></li><li style=";text-align:right;direction:rtl">  <i>نوع وظيفي A → B.</i>  أي وظيفة من هذا النوع تحول عناصر A إلى عناصر B. وبالتالي ، فإن هذه الوظيفة موجودة بالضبط عندما يعني وجود عنصر من النوع A وجود عنصر من النوع B. لذلك ، فإن هذا البناء يتوافق مع الآثار الضمنية. <br></li></ul><br>  لنفترض الآن أننا حصلنا على نوع معين A ومجموعة من الأنواع B ذات معلمات بعنصر a من النوع A. فلنقدم أمثلة على إنشاءات أكثر تعقيدًا على أنواع تابعة. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <i>نوع الوظيفة التابعة</i> <b>Π</b> (a: A) (B a).  يتزامن هذا النوع مع النوع الوظيفي المعتاد A → B إذا كانت B مستقلة عن A. وظيفة من النوع <b>Π</b> (a: A) (B a) تحول أي عنصر a من النوع A إلى عنصر من النوع B a.  وهكذا ، توجد مثل هذه الوظيفة إذا كان هناك عنصر B a.  لذلك ، هذا البناء يتوافق مع الكمي العالمي ∀.  بالنسبة للنوع الوظيفي التابع ، يستخدم Arend بناء الجملة <code><b>\Pi</b> (x : A) -&gt; B a</code> ، ويمكن بناء المصطلح الذي يسكن هذا النوع باستخدام تعبير lambda <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li style=";text-align:right;direction:rtl">  <i>نوع الأزواج التابعة هو <b>Σ</b> (a: A) (B a).</i>  يتزامن هذا النوع مع الأنواع المعتادة من أزواج A × B إذا كانت B مستقلة عن A. يتم ملء النوع <b>a</b> (a: A) (B a) بالضبط عند <i>وجود</i> عنصر a: A وعنصر من النوع B a.  وبالتالي ، فإن هذا النوع يتوافق مع <code>∃</code> وجود <code>∃</code> .  تتم الإشارة إلى نوع الأزواج التابعة في Arend بواسطة <code>\Sigma (a : A) (B a)</code> ، ويتم إنشاء المصطلحات التي تسكنها باستخدام مُنشئ الزوج <code>(a, b)</code> <i>التابع)</i> <code>(a, b)</code> . <br></li><li style=";text-align:right;direction:rtl">  <i>نوع المساواة هو</i> a = a '، حيث a و a' عنصران من نوع A. يتم ملء هذا النوع إذا كانت a و a 'متساوية ، فارغة.  من الواضح أن هذا النوع هو تناظر للمساواة في المنطق. </li></ul><br>  في هذه المرحلة ، نحيل القارئ إلى المصادر التي تناقش فيها مراسلات كاري - هاورد بمزيد من التفصيل (انظر ، على سبيل المثال ، مجموعة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من المحاضرات</a> أو المقالات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> ). <br><br>  يجب أن تحتوي كل التعبيرات التي تم بحثها في نظرية النوع على نوع ما.  نظرًا لأن التعبيرات التي تشير إلى الأنواع تُعتبر أيضًا في إطار هذه النظرية ، فإنها تحتاج أيضًا إلى تعيين نوع معين.  والسؤال هو ، أي نوع من أنواع ينبغي أن يكون؟ <br><br>  أول قرار ساذج يتبادر إلى الذهن هو تخصيص نوع رسمي لكل الأنواع ، يسمى <i>الكون</i> (يطلق عليه ذلك لأنه يحتوي على جميع الأنواع بشكل عام).  إذا استخدمنا هذا الكون ، فستتلقى إنشاءات المبلغ ونوع المنتجات المذكورة أعلاه التوقيع <code>\Type → \Type → \Type</code> ، والإنشاءات الأكثر تعقيدًا للمنتج التابع وسيحصل المجموع التابع على التوقيع <code><b>Π</b> (A : \Type) → ((A → \Type) → \Type)</code> . <br><br>  عند هذه النقطة ، يطرح السؤال ، ما نوع يجب أن يكون <code>\Type</code> الكون نفسه؟  محاولة ساذجة للقول إن نوع الكون <code>\Type</code> ، بحكم تعريفه ، هو <code>\Type</code> نفسه يؤدي إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مفارقة جيرارد</a> ، لذلك بدلاً من كون واحد <code>\Type</code> ضع في الاعتبار <i>التسلسل الهرمي</i> اللانهائي <i>للكون</i> ، أي  السلسلة المتداخلة من الأكوان <code>\Type 1 &lt; \Type 2 &lt; …</code> ، والتي يتم ترقيم مستوياتها بالأرقام الطبيعية ، ونوع الكون <code>\Type i</code> ، بحكم التعريف ، هو الكون <code>\Type (i+1)</code> .  بالنسبة للإنشاءات المذكورة أعلاه ، يجب أيضًا تقديم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">توقيعات</a> أكثر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تعقيدًا</a> . <br><br>  وبالتالي ، هناك حاجة الأكوان في نظرية النوع بحيث أي تعبير له نوع معين.  في بعض أنواع نظرية النوع ، تستخدم الأكوان لغرض آخر: التمييز بين أنواع الأنواع.  لقد رأينا بالفعل أن المجموعات والبيانات هي حالات خاصة بأنواعها.  هذا يدل على أنه قد يكون من المنطقي أن ندخل في النظرية عالمًا منفصلاً للدعائم للبيانات وسلسلة هرمية منفصلة من أكوان Set <sub>i</sub> للمجموعات.  هذا هو بالضبط النهج المستخدم في حساب التفاضل والتكامل الإنشائي للإنشاءات ، وهي النظرية التي يقوم عليها نظام Coq. <br><br><h2 style=";text-align:right;direction:rtl">  1.2 أمثلة على أبسط أنواع الاستقراء والوظائف العودية </h2><br>  النظر في التعاريف على Arend من أبسط أنواع البيانات الاستقرائي: نوع منطقية ، ونوع الرقم الطبيعي ، وقوائم متعددة الأشكال.  يستخدم Arend الكلمة الرئيسية <code>\data</code> لإدخال أنواع استقلالية جديدة. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  كما ترى من الأمثلة أعلاه ، بعد الكلمة الرئيسية <code>\data</code> ، تحتاج إلى تحديد اسم النوع الاستقرائي وقائمة منشئيها.  في الوقت نفسه ، قد يحتوي نوع البيانات والمنشئين على بعض المعلمات.  دعنا نقول في المثال أعلاه أن نوع <code>List</code> يحتوي على معلمة واحدة <code>A</code>  <code>nil</code> يحتوي مُنشئ قائمة <code>nil</code> على أية معلمات ، كما أن المُنشئ: -: يحتوي على معلمتين (إحداها من النوع <code>A</code> ، والآخر من النوع <code>List A</code> ).  يتكون الكون <code>\Set</code> من أنواع مجموعات (سيتم تحديد تعريف المجموعات في القسم التالي).  <code>\infixr</code> تتيح لك استخدام تدوينات infix <code>\infixr</code> : -: بالإضافة إلى ذلك ، يخبر محلل Arend أن العامل: -: هو عملية ربط يمين ذات أولوية 5. <br><br>  في Arend ، تبدأ جميع الكلمات الرئيسية بحرف خط مائل عكسي ("\") ، وهو تطبيق مستوحى من LaTeX.  لاحظ فقط أن القواعد المعجمية في Arend هي متحررة جدًا: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> وحتى <code>n:Nat</code> - كل هذه الحرف هي أمثلة <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> صحيحة في Arend.  يوضح المثال الأخير مدى أهمية <i>أن يتذكر</i> مستخدم Arend <i>وضع مسافات بين المعرفات وحروف النقطتين</i> .  لاحظ أنه في معرفات Arend ، لا يُسمح باستخدام أحرف Unicode (على وجه الخصوص ، لا يمكنك استخدام السيريلية). <br><br>  يستخدم Arend الكلمة الأساسية <code>\func</code> لتحديد الوظائف.  يكون بناء الجملة لهذا البناء كالتالي: بعد الكلمة الأساسية <code>\func</code> ، تحتاج إلى تحديد اسم الوظيفة ومعلماتها ونوع القيمة المرجعة.  العنصر الأخير في تحديد الوظيفة هو جسمها. <br><br>  إذا كان من الممكن تحديد التعبير الذي سيتم حساب الوظيفة المحددة فيه صراحة ، فمن أجل الإشارة إلى نص الوظيفة ، يتم استخدام الرمز المميز =&gt;.  خذ بعين الاعتبار ، على سبيل المثال ، تعريف دالة إلغاء النوع. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  لا يجب دائمًا تحديد نوع الإرجاع لوظيفة ما بشكل صريح.  في المثال أعلاه ، سيكون Arend قادرًا على استنتاج النوع " <code>Not</code> بشكل مستقل ، ويمكننا حذف تعبير ": <code>\Type</code> " بعد الأقواس. <br><br>  كما هو الحال في معظم أنظمة الرياضيات الرسمية ، لا يتعين على المستخدم تحديد مستوى تنبؤي صريح للكون <code>\Type</code> ، والتعاريف التي تستخدم فيها الأكوان دون تحديد مستوى تنبؤي بشكل صريح تعتبر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">متعددة الأشكال</a> . <br><br>  الآن دعونا نحاول تحديد وظيفة تحسب طول القائمة.  هذه الوظيفة سهلة التحديد من خلال مطابقة الأنماط.  يستخدم Arend الكلمة الرئيسية <code>\elim</code> لهذا.  بعد ذلك ، يجب عليك تحديد المتغيرات التي يتم بها إجراء المقارنة (إذا كان هناك أكثر من متغير واحد ، فيجب كتابتها بفاصلة).  إذا تم إجراء المقارنة لجميع المعلمات الصريحة ، فيمكن حذف <code>\elim</code> مع المتغيرات.  يتبع ذلك كتلة من نقاط المقارنة ، مفصولة عن بعضها البعض بشريط عمودي "|".  كل عنصر في هذه الكتلة هو تعبير عن النموذج <code>«,    » =&gt; «»</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  في المثال أعلاه ، تحيط المعلمة A الخاصة بوظيفة <code>length</code> بأقواس مجعدة.  تُستخدم الأقواس الموجودة في Arend للإشارة إلى الوسائط الضمنية ، أي  الوسائط التي يمكن للمستخدم حذفها عند استدعاء وظيفة أو استخدام نوع.  لاحظ أنه في Arend لا يمكنك استخدام تدوينات infix لتعيين المنشئات عند المطابقة مع نقش ، لذلك يتم استخدام تدوين البادئة في المثال النموذجي. <br><br>  كما هو الحال في Coq / Agda ، في Arend ، يجب ضمان أن جميع الوظائف مكتملة (على سبيل المثال ، التحقق من الإنهاء موجود في Arend).  في تعريف دالة الطول ، يكون هذا الفحص ناجحًا ، حيث إن المكالمة العودية تقلل بشكل صارم أول وسيطة صريحة.  إذا لم يحدث هذا التخفيض ، فسوف يقدم Arend رسالة خطأ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  يتيح Arend التبعيات الدائرية ووظائف العودية المتبادلة التي يتم أيضًا إجراء اختبارات إكمالها.  يتم تنفيذ خوارزمية هذا الاختيار بناءً على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالة</a> أ. أبيل.  ستجد فيه وصفًا أكثر تفصيلًا للشروط التي يجب أن تستوفيها العودية المتبادلة. <br><br><h2 style=";text-align:right;direction:rtl">  1.3 كيف تختلف المجموعات عن البيانات؟ </h2><br>  سبق أن كتبنا أن أمثلة الأنواع هي مجموعات وبيانات.  بالإضافة إلى ذلك ، استخدمنا الكلمات الرئيسية <code>\Type</code> و <code>\Set</code> للدلالة على الأكوان في أرند.  سنحاول في هذا القسم أن نوضح بمزيد من التفصيل كيف تختلف العبارات عن المجموعات من حيث أنواع نظرية النوع المكثف (MLTT ، CIC ، HoTT) ، وفي نفس الوقت سنشرح معنى الكلمة الرئيسية <code>\Prop</code> و <code>\Set</code> و <code>\Type</code> in Arend. <br><br>  تذكر أنه في نظرية مارتن لوف الكلاسيكية لا يوجد فصل بين الأنواع في مجموعات وبيانات.  على وجه الخصوص ، من الناحية النظرية ، يوجد واحد فقط من الكون التراكمي (والذي تتم الإشارة إليه إما بواسطة Set في Agda أو Type in Idris أو Sort in Lean).  هذا النهج هو أبسط ، ولكن هناك مواقف تتجلى فيها أوجه القصور فيها.  لنفترض أننا نحاول تنفيذ نوع "القائمة المرتبة" كزوج تابع يتكون من قائمة وإثبات لترتيبها.  اتضح بعد ذلك ، في إطار MLTT "النقي" ، لن يكون من الممكن إثبات المساواة في القوائم المرتبة التي تتكون من عناصر متطابقة ، والتي تختلف في الوقت نفسه من حيث إثبات الطلب.  سيكون الحصول على مثل هذه المساواة أمرًا طبيعيًا ومرغوبًا فيه ، لذا فإن استحالة إثبات ذلك يمكن اعتبارها عيبًا نظريًا في MLTT. <br><br>  في Agda ، يتم حل هذه المشكلة جزئيًا بمساعدة ما يسمى بملاحظات عدم الأهمية (راجع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المصدر</a> ، حيث تتم مناقشة مثال القائمة بمزيد من التفاصيل).  ومع ذلك ، فإن هذه التعليقات التوضيحية ليست بناءً من نظرية MLTT ، كما أنها ليست بنيات كاملة على أنواع (من المستحيل وضع علامة مع تعليق توضيحي للنوع غير مستخدم في وسيطة الدالة). <br><br>  في CIC ، استنادًا إلى CIC ، يوجد أكوان مختلفان متداخلان في بعضهما البعض: <code>Prop</code> (عالم العبارات) و <code>Set</code> (عالم المجموعات) ، وهما مغموران في التسلسل الهرمي الشامل لأكوان <code>Type</code> .  الفرق الرئيسي بين <code>Prop</code> و <code>Set</code> هو وجود عدد من القيود على المتغيرات التي ينتمي نوعها إلى <code>Prop</code> في Coq.  على سبيل المثال ، لا يمكن استخدامها في العمليات الحسابية ، والمقارنة مع العينة الخاصة بهم ممكنة فقط داخل دليل البيانات الأخرى.  من ناحية أخرى ، جميع العناصر من النوع الذي ينتمي إلى عالم <code>Prop</code> متساوية في بديهية الأدلة غير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المهمة</a> ، انظر البيان في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Coq.Logic.ProofIrrelibility</a> .  باستخدام هذه البديهية ، يمكننا بسهولة إثبات المساواة في القوائم المطلوبة المذكورة أعلاه. <br><br>  أخيرًا ، فكر في مقاربة Arend / HoTT للبيانات والأكوان.  الفرق الرئيسي هو أن HoTT يستغني عن البديهية من الأدلة غير الهامة.  وهذا يعني أنه لا يوجد من البديهية الخاصة في HoTT التي تفترض أن جميع عناصر البيانات متساوية.  ولكن في HoTT ، يعتبر النوع ، <i>بحكم تعريفه</i> ، بيانًا إذا كان يمكن إثبات أن جميع عناصره متساوية مع بعضها البعض.  يمكننا تحديد تقدير على أنواع صحيحة إذا كان النوع عبارة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  السؤال الذي يطرح نفسه: ما هي الأنواع التي تفي بهذا المسند ، أي هي البيانات؟  من السهل التحقق من صحة ذلك بالنسبة للأنواع الفارغة والمفردة.  بالنسبة للأنواع التي يوجد بها عنصرين مختلفين على الأقل ، لن يكون هذا صحيحًا بعد الآن. <br><br>  بالطبع ، نريد تحديد جميع الروابط المنطقية اللازمة عبر البيانات.  في القسم 1.1 ، ناقشنا بالفعل كيف يمكن تحديدها باستخدام التركيبات النظرية للكتابة.  ومع ذلك ، هناك المشكلة التالية: ليست كل العمليات التي <code>isProp</code> تحتفظ <code>isProp</code> .  تحتفظ المنشآت الخاصة بمنتج الأنواع والنوع الوظيفي (التابع) بهذه الخاصية ، بينما لا تحتفظ تركيبات مجموع الأنواع والأزواج التابعة.  وبالتالي ، لا يمكننا استخدام الخلل وقياس الوجود. <br><br>  يمكن حل هذه المشكلة بمساعدة بناء جديد ، يتم إضافته إلى HoTT ، ما يسمى <i>باقتراح الاقتراح</i> .  يسمح لك هذا التصميم بتحويل أي نوع إلى بيان.  يمكن اعتباره عملية رسمية ، مما يجعل جميع المصطلحات التي تسكن هذا النوع متساوية.  تشبه هذه العملية إلى حد ما التعليقات التوضيحية لعدم الأهمية من Agda ، ومع ذلك ، فهي ، على عكسها ، عملية كاملة على الأنواع ذات التوقيع <code>\Type -&gt; \Prop</code> . <br><br>  المثال الأخير الهام للبيانات هو المساواة بين عنصرين من نوع ما.  اتضح أنه في الحالة العامة <code>a = a'</code> لا يجب أن يكون نوع المساواة <code>a = a'</code> عبارة.  تسمى الأنواع التي هي واحدة مجموعات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  جميع الأنواع التي توجد في لغات البرمجة العادية تفي بهذا المسند ، أي أن المساواة بينهم هي بيان.  على سبيل المثال ، ينطبق هذا على الأرقام الطبيعية والأعداد الصحيحة ومنتجات المجموعات ومجموعات المجموعات والوظائف على المجموعات وقوائم المجموعات وأنواع البيانات الاستقرائية الأخرى التي تم إنشاؤها من مجموعات.  هذا يعني أننا إذا كنا مهتمين فقط بهذه الإنشاءات المألوفة ، فلا يمكننا التفكير في الأنواع التعسفية التي لا تفي بهذا المسند.  جميع الأنواع الموجودة في كوك هي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مجموعات</a> . <br><br>  تصبح الأنواع غير المحددة مفيدة إذا كنت تريد التعامل مع نظرية نوع homotopy.  في الوقت الحالي ، نقوم ببساطة بإحالة القارئ إلى <a href="">الوحدة النمطية</a> للمكتبة القياسية التي تحتوي على تعريف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المجال البعد n</a> ، مثال على نوع ليس مجموعة. <br><br>  يحتوي Arend على أكوان خاصة <code>\Prop</code> و <code>\Set</code> ، تتكون من بيانات ومجموعات ، على التوالي.  إذا علمنا بالفعل أن النوع A موجود في الكون <code>\Prop</code> (أو <code>\Set</code> ) ، فيمكن الحصول على دليل <code>isProp</code> (أو <code>isSet</code> ) <code>isSet</code> في Arend باستخدام <code>Path.inProp</code> axiom المضمنة في <a href="">المقدمة</a> (نعطي مثالًا على استخدام هذه البديهية في القسم 2.3). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  لقد لاحظنا بالفعل أنه ليس كل التركيبات الطبيعية على الأنواع تحتفظ <code>isProp</code> .  على سبيل المثال ، أنواع البيانات الاستقرائية مع اثنين أو أكثر من المنشئات لا ترضيها.  كما هو مذكور أعلاه ، يمكننا استخدام بنية <i>الاقتطاع المقترحة</i> التي تحول أي نوع إلى بيان. <br>  في مكتبة Arend ، يُطلق على التطبيق القياسي للاقتراح <code>Logic.TruncP</code> .  يمكننا تحديد نوع من المنطقية "أو" في Arend على أنه اقتطاع مجموع الأنواع: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical “or”, analogue of Coq's type "\/"</code> </pre> <br>  في Arend ، هناك طريقة أخرى أبسط وأكثر ملاءمة لتحديد نوع حثي مقطوع بشكل مقترح.  للقيام بذلك ، ما عليك سوى إضافة الكلمة الرئيسية <code>\truncated</code> قبل تحديد نوع البيانات.  على سبيل المثال ، يتم تقديم تعريف المنطقي "أو" في مكتبة Arend القياسية على النحو التالي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical “or”, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  يشبه العمل الإضافي مع الأنواع المقطوعة بشكل مقترح ، الأنواع التي تم تعيينها <code>Prop</code> في Coq.  على سبيل المثال ، يُسمح بمطابقة النقش لمتغير يكون نوعه عبارة فقط في موقف يكون فيه نوع التعبير الذي يتم تعريفه عبارة عن عبارة.  وبالتالي ، من السهل دائمًا تحديد الوظيفة <code>Or-to-||</code>  من خلال المقارنة مع العينة ، ولكن الوظيفة العكسية لها ، فقط إذا كان النوع A <code>`Or`</code> B عبارة (وهو أمر نادر بما فيه الكفاية ، على سبيل المثال ، عندما يكون النوعان <code>A</code> و <code>B</code> عبارة عن عبارات <code>`Or`</code> كل منهما الآخر). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  أذكر أيضًا أن خصوصية آلية الأكوان في Coq هي أنه إذا تم تخصيص بعض التعريفات لكون <code>Prop</code> ، فلن يكون من الممكن بأي حال من الأحوال استخدامه في الحساب.  لهذا السبب ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لا ينصح</a> مطورو Coq أنفسهم باستخدام الإنشاءات المقترحة ، ولكن ينصحون باستبدالها بنظائر من عالم المجموعات إن أمكن.  لا تحتوي آلية أكوان Arend على هذا العيب ، أي أنه في بعض المواقف يمكن استخدام البيانات في العمليات الحسابية.  سنقدم مثالاً على مثل هذا الموقف عندما نناقش تنفيذ خوارزمية فرز القائمة. <br><br><h2 style=";text-align:right;direction:rtl">  1.4 فصول في أرند </h2><br>  نظرًا لأن هدفنا هو تطبيق أبسط خوارزميات الفرز ، يبدو أنه من المفيد أن تتعرف على تنفيذ المجموعات المرتبة المتوفرة في مكتبة Arend القياسية. <br><br>  في Arend ، يتم استخدام الفئات لتضمين العمليات والبديهيات التي تحدد الهياكل الرياضية ، وكذلك لتسليط الضوء على العلاقات بين هذه الهياكل باستخدام الوراثة.  الفصول هي أيضا مساحات أسماء ، والتي من المناسب أن تضع الإنشاءات والنظريات المناسبة في المعنى. <br><br>  الفئة الأساسية التي يتم من خلالها توريث جميع فئات الترتيب في Arend هي فئة <code>BaseSet</code> ، والتي لا تحتوي على أي أعضاء بخلاف التعيين <code>E</code> لمجموعة المضيف (على سبيل المثال ، المجموعة التي <code>BaseSet</code> المنحدرة من <code>BaseSet</code> بالفعل بتقديم عمليات متنوعة).  النظر في تعريف هذه الفئة من مكتبة Arend القياسية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  في التعريف أعلاه ، يُعلن عن الموجة الحاملة <code>E</code> معلمة صنف.  قد يتساءل المرء ، هل هناك اختلاف في التعريف أعلاه لـ <code>BaseSet</code> عن التعريف التالي ، في أي ناقل E يتم تعريفه كحقل فئة؟ <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  الجواب غير متوقع قليلاً هو أنه في Arend <i>لا يوجد فرق</i> بين التعريفين ، بمعنى أن أي معلمة فئة (حتى ضمنية) في Arend هي ، في الواقع ، مجالها.  وبالتالي ، بالنسبة لكل من <code>BaseSet</code> ، يمكن للمرء استخدام التعبير <code>xE</code> للوصول إلى الحقل E. <code>BaseSet</code> يزال هناك فرق بين المتغيرات المذكورة أعلاه لتعريف <code>BaseSet</code> ، لكن الأمر أكثر دقة ، وسوف ندرسه بمزيد من التفاصيل في القسم التالي عندما نناقش مثيلات الفصل الدراسي ( حالات الطبقة). <br><br>  لا يكون تشغيل فرز قائمة منطقيًا إلا إذا تم تحديد ترتيب خطي على نوع الكائنات في القائمة ، وبالتالي ، فإننا نأخذ بعين الاعتبار تعاريف مجموعة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صارمة مرتبة جزئيًا ومجموعة محددة</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ترتيبًا خطيًا.</a> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  من وجهة نظر نظرية النوع ، يمكن اعتبار الفئات في Arend نظائرها لأنواع سيغما مع بناء جملة أكثر ملاءمة للتوقعات والمنشئين.  ,  Arend-    -,       . <br><br>     ,     <i></i> .     ,      . ,  StrictPoset  <code>&lt;-irreflexive</code>  <code>&lt;-transitive</code>  ,   <code>E</code>  <code>&lt;</code> — .     ,     (,  ,    )    ,       . <br><br>        ,   ,    .   ,   Arend  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a> ,  ,      .  ,       . ,     ,        ,     ,      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a>  : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br>  <code>Dec</code>     ,  <code>Dec E</code>     ,  <code>E</code> ,      <code>E</code> ,   <code>E</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أخيرًا ، ضع في الاعتبار الفصل </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(من الكلمة decidable) من الوحدة النمطية </font></font><code>Order.LinearOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. تطبق الفئة ديسمبر أوامر خطية قابلة للحل ، وعلى وجه الخصوص ، تحتوي على البديهية التي نحتاجها </font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، مما يعني أن أي عنصرين من النوع </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قابلان للمقارنة فيما يتعلق بالترتيب &lt;. وبالتالي ، </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن اعتباره بمثابة تماثل للواجهة المقارنة من Java.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br>   <code>Dec</code>         <code>Dec</code> ,    ,   ,  ,            .     <code>Dec</code>    ,     . <br><br>       ,          <code>Dec</code> (        ).  <code>Dec</code> ,   Arend    ( <code>Dec</code>     <code>LinearOrder,</code>  <code>DecSet</code> ),  ,     (diamond inheritance). <br><br>       :                ,     (    ,       ). <br><br>    <code>Dec</code>   <code>Order.LinearOrder</code>   IDEA    (      [Ctrl]+[H]),   ,    . <br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br>              Arend (    IDEA    <code>BaseSet</code> ).   ,      . <br><br><h2 style=";text-align:right;direction:rtl"> 1.5  ,  ,     . </h2><br>        <code>StrictPoset</code>     Nat.  Arend       ,     .       -,  ,    ,   - (   ),           . <br><br>         :   .             . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br>       <code>\func</code>   <code>\lemma</code> .      ,       ,        ,     .      ,   <code>\lemma</code>  ,        <code>\Prop</code> . <br><br>    <code>x'&lt;y'</code> —    -,    <code>x' &lt; y'</code> .         - (.. ,       ,     ). <br><br>      (instance)  <code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. يحتوي Arend على العديد من خيارات بناء الجملة المختلفة لهذا الغرض. الطريقة الأولى لإنشاء مثيل لفصل دراسي هي استخدام كلمة أساسية </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">داخل أي تعبير. في هذه الحالة ، سيتم إنشاء "مثيل فئة مجهولة".</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  <code>StrictPoset { … }</code>       <code>\new</code> :       - <code>StrictPoset</code> .   -    , ,    ,        <code>\new</code>  .   <code>\new C { … }</code>   <code>C { … }</code> .       C,      C. ,    ,  <code>NatOrder</code>    <code>StrictPoset</code> . <br><br>    ,         .  ,       <code>StrictPoset Nat</code>      <code>StrictPoset { | E =&gt; Nat }</code> . ,        <code>NatOrder</code>  <code>StrictPoset</code> ,           (     ). <br><br>      <code>NatOrder</code>      <code>\cowith</code>    (          - ). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br> , ,          <code>\instance.</code> <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  Arend     ,     Haskell.   <code>NatOrder</code>    <code>\instance</code>    <code>\cowith</code>      ,           <code>StrictPoset</code> (    ). <br><br> ,    <code>BaseSet</code>    - E     (   ),      ,         E   .      . <br><br>  ,         Arend      .   Arend  ,            ,       (  ,  « <i> </i> »         <code>\classifying \field</code> ,    Arend      ).      : <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Arend                . ,  <code>X</code>   <code>StrictPoset</code> ,   <code>List X</code>         <code>List XE</code> . <br></li><li style=";text-align:right;direction:rtl"> Arend          . </li></ul><br>  ,    . ,         <code>\instance</code>    <code>StrictPoset</code>    ,     <code>Nat</code>    <code>Int</code> (   <code>NatOrder</code>  <code>IntOrder</code> ). <br><br> ,      <code>x &lt; y</code>      ,  x, y   ,    ,  x, y   .    Arend  ,     <code>NatOrder.&lt;</code> ,    — <code>IntOrder.&lt;</code> . <br><br>    ,     . Arend ,   &lt;    <code>StrictPoset</code> ,       E. , Arend      <code>x&lt;y</code>          <code>StrictPoset</code> (  ),     E   .    ,    <code>&lt;</code>     . <br><br> ,                     Arend.        ,     <code>\use \coerce</code>  <i> </i>  .  Arend      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- بعض مساحة الاسم المستخدمة لوضع مختلف الهياكل المساعدة في ذلك. لإضافة أي تعريفات أخرى إلى وحدة التعريف المرتبطة ، يتم استخدام الكلمة الأساسية </font></font><code>\where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النظر في أبسط مثال على استخدام آلية تحويل النوع. </font></font><code>fromNat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيتم استخدام </font><font style="vertical-align: inherit;">الدالة </font><font style="vertical-align: inherit;">لتحويل الأرقام الطبيعية ضمنيًا إلى أعداد صحيحة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br>    <code>\use \coerce</code>  <code>\func</code>   ,          .     ,         ,      (,     ,        ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar469569/">https://habr.com/ru/post/ar469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar469551/index.html">VDS مع بطاقة الفيديو - نحن نعرف الكثير عن الانحرافات</a></li>
<li><a href="../ar469555/index.html">البث: لقاء موسكو Kubernetes رقم 6</a></li>
<li><a href="../ar469557/index.html">Generic Recycler View أو كيف لا تكتب كود boilerplate</a></li>
<li><a href="../ar469561/index.html">حساب عدد صحيح مربع الجذر</a></li>
<li><a href="../ar469567/index.html">الخلفية: تفاصيل عن iPhone 11 و 11 Pro و Apple Watch الجديد بعد أسبوعين من الاختبار</a></li>
<li><a href="../ar469573/index.html">Linux Piter 2019: ما ينتظر الضيوف لحضور مؤتمر Linux واسع النطاق ولماذا لا ينبغي تفويته</a></li>
<li><a href="../ar469575/index.html">كيفية إعادة برمجة وضع السكون: 30 يومًا كل صباح ، أشرق الضوء الأخضر الساطع في عيني</a></li>
<li><a href="../ar469577/index.html">الطب الشرعي القرص ، الطب الشرعي الذاكرة وسجل الطب الشرعي. إطار التقلب والتشريح. حل المشكلات باستخدام r0ot-mi. الجزء 1</a></li>
<li><a href="../ar469581/index.html">تحليل تأثير بيكابو</a></li>
<li><a href="../ar469583/index.html">OpenVPN و Active Directory (Kerberos بدون شهادات المستخدم)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>