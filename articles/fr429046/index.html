<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🎳 📣 Quatre ans de développement de SObjectizer-5.5. Comment SObjectizer a-t-il changé pendant cette période? 😸 👨🏼‍🏭 🍐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La première version de SObjectizer dans le cadre de la branche 5.5 a été publiée il y a un peu plus de quatre ans - début octobre 2014. Et aujourd'hui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quatre ans de développement de SObjectizer-5.5. Comment SObjectizer a-t-il changé pendant cette période?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429046/">  La première version de SObjectizer dans le cadre de la branche 5.5 a été publiée il y a un peu plus de quatre ans - début octobre 2014.  Et aujourd'hui, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la prochaine version est sortie sous le numéro 5.5.23</a> , ce qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clôturera</a> très probablement l'histoire de SObjectizer-5.5.  À mon avis, c'est une excellente raison de regarder en arrière et de voir ce qui a été fait au cours des quatre dernières années. <br><br>  Dans cet article, je vais essayer d'analyser de manière abstraite les changements et innovations les plus importants et significatifs: ce qui a été ajouté, pourquoi, comment cela a affecté le SObjectizer lui-même ou son utilisation. <br><br>  Peut-être que quelqu'un sera intéressé par une telle histoire du point de vue de l'archéologie.  Et quelqu'un, peut-être, sera tenu à l'écart d'une aventure aussi douteuse que le développement de son propre framework d'acteur pour C ++;) <br><a name="habracut"></a><br><h1>  Une petite digression lyrique sur le rôle des anciens compilateurs C ++ </h1><br>  L'histoire de SObjectizer-5 a commencé à la mi-2010.  Dans le même temps, nous nous sommes immédiatement concentrés sur C ++ 0x.  Déjà en 2011, les premières versions de SObjectizer-5 ont commencé à être utilisées pour écrire du code de production.  Il est clair que nous n'avions pas alors de compilateurs avec un support C ++ 11 normal. <br><br>  Pendant longtemps, nous n'avons pas pu utiliser pleinement toutes les fonctionnalités du "C ++ moderne": modèles variadic, noexcept, constexpr, etc. Cela ne pouvait qu'affecter l'API SObjectizer.  Et cela a affecté pendant très, très longtemps.  Par conséquent, si lors de la lecture de la description d'une fonctionnalité, vous avez une question: «Pourquoi cela n'a-t-il pas été fait auparavant?», La réponse à cette question est très probablement: «Parce que cela n'était pas possible auparavant». <br><br><h1>  Qu'est-ce qui est apparu et / ou changé dans SObjectizer-5.5 dans le passé? </h1><br>  Dans cette section, nous allons passer en revue un certain nombre de fonctionnalités qui ont eu un impact significatif sur SObjectizer.  L'ordre dans cette liste est aléatoire et n'est pas lié à la «signification» ou au «poids» des caractéristiques décrites. <br><br><h2>  Rejeter l'espace de noms so_5 :: rt </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  Initialement, dans le cinquième SObjectizer, tout ce qui concerne le runtime SObjectizer a été défini dans l'espace de noms so_5 :: rt.  Par exemple, nous avions so_5 :: rt :: environment_t, so_5 :: rt :: agent_t, so_5 :: rt :: message_t, etc.  Ce que vous pouvez voir, par exemple, dans l'exemple traditionnel HelloWorld de SO-5.5.0: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::rt::agent_t { public: a_hello_t( so_5::rt::environment_t &amp; env ) : so_5::rt::agent_t( env ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5." &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::rt::environment_t &amp; env ) { env.register_agent_as_coop( "coop", new a_hello_t( env ) ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  L'abréviation "rt" signifie run-time.  Et il nous a semblé que l'enregistrement «so_5 :: rt» est bien meilleur et plus pratique que «so_5 :: runtime». <br><br>  Mais il s'est avéré que pour beaucoup de gens, «rt» n'est que «en temps réel» et rien d'autre.  Et l'utilisation de "rt" comme raccourci pour "runtime" viole tellement leurs sentiments que parfois les annonces des versions de SObjectizer dans RuNet se transformaient en holivar sur le sujet d'une interprétation [non] permise de "rt" autre que "en temps réel". <br><br>  Au final, on en a assez.  Et nous venons de décompresser l'espace de noms so_5 :: rt. <br><br><h3>  Qu'est devenu? </h3><br>  Tout ce qui a été défini dans "so_5 :: rt" est simplement passé à "so_5".  En conséquence, le même HelloWorld ressemble maintenant à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::agent_t { public: a_hello_t( context_t ctx ) : so_5::agent_t( ctx ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5 (" &lt;&lt; SO_5_VERSION &lt;&lt; ")" &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { env.register_agent_as_coop( "coop", env.make_agent&lt;a_hello_t&gt;() ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  Mais les anciens noms de "so_5 :: rt" sont restés disponibles malgré tout en utilisant s (typedefs).  Le code écrit pour les premières versions de SO-5.5 est donc également utilisable dans les versions récentes de SO-5.5. <br><br>  Enfin, l'espace de noms so_5 :: rt sera supprimé dans la version 5.6. <br><br><h3>  Quel impact cela a-t-il eu? </h3><br>  Probablement, le code sur SObjectizer est maintenant plus lisible.  Pourtant, so_5 :: send () est mieux perçu que so_5 :: rt :: send (). <br><br>  Eh bien, ici, comme avec les développeurs SObjectizer, le mal de tête a diminué.  Il y avait trop de bavardages vides et de raisonnements inutiles autour des annonces de SObjectizer à la fois (à partir des questions «Pourquoi les acteurs sont-ils nécessaires en C ++ en général» et se terminant par «Pourquoi n'utilisez-vous pas PascalCase pour nommer des entités»).  Un sujet inflammable est devenu moins et c'était bien :) <br><br><h2>  Simplifiez l'envoi de messages et l'évolution des gestionnaires de messages </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  Même dans les toutes premières versions de SObjectizer-5.5, le message habituel était envoyé à l'aide de la méthode delivery_message, qui devait être appelée sur la mbox du destinataire.  Pour envoyer un message en attente ou périodique, il fallait appeler single_timer / schedule_timer sur un objet de type environment_t.  Et l'envoi d'une demande synchrone à un autre agent nécessitait généralement toute une chaîne d'opérations.  Voici, par exemple, à quoi tout cela aurait pu ressembler il y a quatre ans (std :: make_unique (), qui n'était pas encore disponible en C ++ 11): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . mbox-&gt;deliver_message(std::make_unique&lt;my_message&gt;(...)); //   . env.single_timer(std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2)); //   . auto timer_id = env.schedule_timer( std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2), std::chrono::seconds(5)); //         10 . auto reply = mbox-&gt;get_one&lt;std::string&gt;() .wait_for(std::chrono::seconds(10)) .sync_get(std::make_unique&lt;my_message&gt;(...));</span></span></code> </pre><br>  De plus, le format des gestionnaires de messages dans SObjectizer a évolué vers la version 5.5.  Si initialement dans SObjectizer-5, tous les gestionnaires doivent avoir le format: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; &amp; cmd)</span></span></span></span>;</code> </pre> <br>  puis au fil du temps, quelques autres ont été ajoutés aux formats autorisés: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  Msg --  ,   . ret_value evt_handler(const Msg &amp; msg); ret_value evt_handler(Msg msg); //  ,     . ret_value evt_handler();</span></span></code> </pre><br>  Les nouveaux formats de gestionnaire sont devenus largement utilisés depuis  peindre constamment «const so_5 :: event_data_t &lt;Msg&gt; &amp;» est toujours un plaisir.  Mais, d'un autre côté, les formats plus simples n'étaient pas adaptés aux agents modèles.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_To_Process&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_actor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg_To_Process &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Oops! ... } };</span></span></code> </pre> <br>  Un tel agent modèle ne fonctionnera que si Msg_To_Process est un type de message, pas un type de signal. <br><br><h3>  Qu'est devenu? </h3><br>  Dans la branche 5.5, une famille de fonctions d'envoi est apparue et a considérablement évolué.  Pour ce faire, tout d'abord, j'ai dû mettre à ma disposition des compilateurs prenant en charge les modèles variadic.  Et, d'autre part, pour accumuler une expérience suffisante de travail à la fois avec les modèles variadic en général et avec les premières versions des fonctions d'envoi.  De plus, dans différents contextes: dans les agents ordinaires et dans les agents ad-hoc, et dans les agents qui sont implémentés par des classes modèles et les agents externes en général.  Y compris lors de l'utilisation de fonctions d'envoi avec des chaînes (elles seront discutées ci-dessous). <br><br>  En plus d'envoyer des fonctions, des fonctions request_future / request_value sont apparues, conçues pour une interaction synchrone entre les agents. <br><br>  Par conséquent, l'envoi de messages est désormais le suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . so_5::send&lt;my_message&gt;(mbox, ...); //   . so_5::send_delayed&lt;my_message&gt;(env, mbox, std::chrono::seconds(2), ...); //   . auto timer_id = so_5::send_periodic&lt;my_message&gt;( env, mbox, std::chrono::seconds(2), std::chrono::seconds(5), ...); //         10 . auto reply =so_5::request_value&lt;std::string, my_message&gt;(mbox, std::chrono::seconds(10), ...);</span></span></code> </pre> <br>  Un autre format possible pour les gestionnaires de messages a été ajouté.  De plus, c'est ce format qui sera laissé dans les prochaines versions majeures de SObjectizer comme principal (et, peut-être, le seul).  Il s'agit du format suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ret_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; cmd)</span></span></span></span>;</code> </pre> <br>  Où Msg peut être un type de message ou un type de signal. <br><br>  Ce format brouille non seulement la ligne entre les agents sous forme de classes ordinaires et les agents sous forme de classes modèles.  Mais cela simplifie également la transmission du message / signal (grâce à la famille de fonctions d'envoi): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> my_agent::on_msg(<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;Some_Msg&gt; cmd) { ... <span class="hljs-comment"><span class="hljs-comment">// -  . //       . so_5::send(another_agent, std::move(cmd)); }</span></span></code> </pre> <br><h3>  Quel impact cela a-t-il eu? </h3><br>  L'apparition de fonctions d'envoi et de gestionnaires de messages recevant mhood_t &lt;Msg&gt;, nous pouvons dire, a fondamentalement changé le code dans lequel les messages sont envoyés et traités.  C'est juste le cas quand il ne reste qu'à regretter qu'au tout début des travaux sur SObjectizer-5, nous n'avions ni compilateurs prenant en charge les modèles variadiques, ni expérience de leur utilisation.  La famille des fonctions d'envoi et mhood_t aurait dû être dès le début.  Mais l'histoire s'est développée comme elle s'est développée ... <br><br><h2>  Prise en charge des types de messages personnalisés </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  Initialement, tous les messages envoyés étaient censés être des classes descendantes de la classe so_5 :: message_t.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//  my_message. my_message(...) : ... {...} //   my_message. };</span></span></code> </pre> <br>  Bien que le cinquième SObjectizer n'ait été utilisé que par nous-mêmes, cela n'a soulevé aucune question.  Eh bien, comme ça et comme ça. <br><br>  Mais dès que des utilisateurs tiers ont commencé à s'intéresser à SObjectizer, nous sommes immédiatement tombés sur une question récurrente: "Dois-je hériter un message de so_5 :: message_t?"  Ce problème était particulièrement pertinent dans les situations où il était nécessaire d'envoyer des objets de types en tant que messages que l'utilisateur ne pouvait pas influencer du tout.  Supposons qu'un utilisateur utilise un SObjectizer et une autre bibliothèque externe.  Et dans cette bibliothèque externe, il existe un certain type M, dont l'utilisateur souhaite envoyer des messages.  Eh bien et comment dans de telles conditions se faire des amis de type M et so_5 :: message_t?  Seuls les wrappers supplémentaires que l'utilisateur devait écrire manuellement. <br><br><h3>  Qu'est devenu? </h3><br>  Nous avons ajouté la possibilité d'envoyer des messages à SObjectizer-5.5 même si le type de message n'est pas hérité de so_5 :: message_t.  C'est-à-dire  L'utilisateur peut désormais facilement écrire: <br><br><pre> <code class="cpp hljs">so_5::send&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mbox, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>);</code> </pre> <br>  So_5 :: message_t reste de toute façon sous le capot, juste à cause du modèle magic send () comprend que std :: string n'est pas hérité de so_5 :: message_t et pas une simple std :: string n'est construite à l'intérieur de send, mais un héritier spécial de so_5 :: message_t, dans lequel se trouve déjà la chaîne std :: de l'utilisateur. <br><br>  La magie du modèle similaire s'applique aux abonnements.  Lorsque SObjectizer voit un gestionnaire de messages du formulaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> <br>  alors SObjectizer comprend qu'en fait un message spécial viendra avec l'objet std :: string à l'intérieur.  Et ce dont vous avez besoin pour appeler le gestionnaire en lui passant un lien vers std :: string à partir de ce message spécial. <br><br><h3>  Quel impact cela a-t-il eu? </h3><br>  L'utilisation de SObjectizer est devenue plus facile, en particulier lorsque vous devez envoyer non seulement des objets de vos propres types en tant que messages, mais également des objets de bibliothèques externes.  Plusieurs personnes ont même pris le temps de vous remercier spécialement pour cette fonctionnalité. <br><br><h2>  Messages mutables </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  Initialement, dans SObjectizer-5, seul le modèle d'interaction 1: N a été utilisé.  C'est-à-dire  un message envoyé peut avoir plusieurs destinataires (ou il peut y en avoir plusieurs).  Même si les agents devaient interagir en mode 1: 1, ils communiquaient toujours via une boîte aux lettres multi-producteurs / multi-consommateurs.  C'est-à-dire  en mode 1: N, juste N dans ce cas était strictement une unité. <br><br>  Dans les conditions où un message peut être reçu par plusieurs agents destinataires, les messages envoyés doivent être immuables.  C'est pourquoi les gestionnaires de messages avaient les formats suivants: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . ret_type evt_handler(const event_data_t&lt;Msg&gt; &amp; cmd); //       . ret_type evt_handler(const Msg &amp; msg); //    . //        . ret_type evt_handler(Msg msg);</span></span></code> </pre> <br>  En général, une approche simple et compréhensible.  Cependant, ce n'est pas très pratique lorsque les agents doivent communiquer entre eux en mode 1: 1 et, par exemple, se transférer la propriété de certaines données.  Disons qu'un message aussi simple ne peut pas être fait si tous les messages sont des objets strictement immuables: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process_image</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image_; process_image(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image) : image_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image)) {} };</code> </pre> <br>  Plus précisément, un tel message pourrait être envoyé.  Mais l'ayant reçu comme un objet constant, il n'aurait pas été possible de supprimer le contenu de process_image :: image_ pour lui-même.  Je devrais marquer un tel attribut comme mutable.  Mais alors nous perdrions le contrôle du compilateur si process_image est envoyé pour une raison quelconque en mode 1: N. <br><br><h3>  Qu'est devenu? </h3><br>  Dans SObjectizer-5.5, la possibilité d'envoyer et de recevoir des messages modifiables a été ajoutée.  Dans le même temps, l'utilisateur doit spécialement marquer le message lors de son envoi et lors de son abonnement. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    . so_5::send&lt;my_message&gt;(mbox, ...); //     my_message. so_5::send&lt;so_5::mutable_msg&lt;my_message&gt;&gt;(mbox, ...); ... //     . void my_agent::on_some_event(mhood_t&lt;my_message&gt; cmd) {...} //      my_message. void my_agent::on_another_event(mhood_t&lt;so_5::mutable_msg&lt;my_message&gt;&gt; cmd) {...}</span></span></code> </pre><br>  Pour SObjectizer, my_message et mutable_msg &lt;my_message&gt; sont deux types de messages différents. <br><br>  Lorsqu'une fonction d'envoi voit qu'on lui demande d'envoyer un message modifiable, la fonction d'envoi vérifie à quelle boîte aux lettres elle essaie d'envoyer le message.  S'il s'agit d'une boîte multi-consommateurs, l'envoi n'est pas effectué, mais une exception est levée avec le code d'erreur correspondant.  C'est-à-dire  SObjectizer garantit que les messages modifiables ne peuvent être utilisés que lorsqu'ils interagissent en mode 1: 1 (via des boîtes aux lettres à consommateur unique ou des mchains, qui sont une forme de boîtes aux lettres à consommateur unique).  Pour fournir cette garantie, soit dit en passant, SObjectizer interdit d'envoyer des messages modifiables sous forme de messages périodiques. <br><br><h3>  Quel impact cela a-t-il eu? </h3><br>  Avec des messages mutables, cela s'est avéré de façon inattendue.  Nous les avons ajoutés à SObjectizer à la suite d'une discussion en marge d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport sur SObjectizer à C ++ Russia-2017</a> .  Avec le sentiment, "Eh bien, s'ils demandent, alors quelqu'un en a besoin, donc ça vaut le coup d'essayer."  Eh bien, ils l'ont fait sans grand espoir d'une demande généralisée.  Bien que pour cela, j'ai dû "fumer du bambou" pendant très longtemps avant de penser à comment ajouter des messages modifiables à SO-5.5 sans rompre la compatibilité. <br><br>  Mais lorsque des messages mutables sont apparus dans SObjectizer, il s'est avéré qu'il n'y avait pas si peu d'applications pour eux.  Et que les messages mutables sont utilisés de manière surprenante souvent (mention de cela peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la deuxième partie de l'histoire du projet de démonstration de Shrimp</a> ).  Donc, dans la pratique, cette fonctionnalité était plus qu'utile, car  il vous permet de résoudre des problèmes qui, sans le support des messages modifiables au niveau de SObjectizer, n'avaient pas de solution normale. <br><br><h2>  Agents de la machine d'état hiérarchique </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  Les agents de SObjectizer étaient à l'origine des machines à états.  Les agents devaient décrire explicitement les états et s'abonner aux messages dans des états spécifiques. <br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"free"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_bufy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"busy"</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     st_free. so_subscribe(mbox).in(st_free).event(...); //     st_busy. so_subscribe(mbox).in(st_busy).event(...); ... } };</span></span></code> </pre> <br>  Mais c'étaient de simples machines à états.  Les États ne pouvaient pas être imbriqués les uns dans les autres.  Il n'y avait aucun support pour les gestionnaires d'entrée et de sortie de l'État.  Il n'y avait aucune restriction sur le temps passé dans l'État. <br><br>  Même un support aussi limité pour les machines d'état était pratique et nous l'avons utilisé pendant plus d'un an.  Mais à un moment donné, nous voulions plus. <br><br><h3>  Qu'est devenu? </h3><br>  SObjectizer introduit la prise en charge des machines à états hiérarchiques. <br><br>  Désormais, les états peuvent être imbriqués les uns dans les autres.  Les gestionnaires d'événements des états parents sont automatiquement "hérités" par les états enfants. <br><br>  Les gestionnaires d'entrée et de sortie d'un état sont pris en charge. <br><br>  Il est possible de fixer une limite au temps pendant lequel l'agent reste dans l'état. <br><br>  Il est possible de garder une histoire pour l'État. <br><br>  Pour ne pas être infondé, voici un exemple d'agent qui n'est pas une machine à états hiérarchique complexe (le code de l'exemple standard est clignotant_led): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Nous avons déjà décrit tout cela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article séparé</a> , il n'est pas nécessaire de le répéter. <br><br>  Il n'y a actuellement aucun support pour les états orthogonaux.  Mais ce fait a deux explications.  Premièrement, nous avons essayé d'apporter cet appui et avons rencontré un certain nombre de difficultés, dont la résolution nous a paru trop coûteuse.  Et, deuxièmement, personne n'a encore demandé d'états orthogonaux.  Lorsqu'on lui a demandé, revenons à ce sujet. <br><br><h3>  Quel impact cela a-t-il eu? </h3><br>  On a l'impression que c'est très grave (bien que nous soyons ici, bien sûr, subjectifs et partiaux).  Après tout, c'est une chose lorsque, face à des machines à états finis complexes dans le domaine, vous commencez à chercher des solutions de contournement, simplifiez quelque chose, dépensez plus de force sur quelque chose.  Et c'est une tout autre chose lorsque vous pouvez mapper des objets de votre application à votre code C ++ presque 1-en-1. <br><br>  De plus, à en juger par les questions posées, par exemple, par le comportement des gestionnaires d'entrée / sortie dans / hors de l'état, cette fonctionnalité est utilisée. <br><br><h2>  mchain's </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  C'était une situation intéressante.  SObjectizer était souvent utilisé de sorte que seule une partie de l'application était écrite dans SObjectizer.  Le reste du code de l'application pourrait n'avoir rien à voir avec les acteurs en général, ou avec SObjectizer en particulier.  Par exemple, une application GUI dans laquelle un SObjectizer est utilisé pour certaines tâches d'arrière-plan, tandis que le travail principal est effectué sur le thread principal de l'application. <br><br>  Et dans de tels cas, il s'est avéré que de la partie non SObjectizer à la partie SObjectizer, l'envoi d'informations est aussi simple que simple: il suffit d'appeler des fonctions d'envoi ordinaires.  Mais la diffusion d'informations en sens inverse n'est pas si simple.  Il nous a semblé que ce n'est pas bon et que vous devriez avoir des canaux de communication pratiques entre les parties SObjectizer de l'application et les parties non-SObjectizer directement hors de la boîte. <br><br><h3>  Qu'est devenu? </h3><br>  Ainsi, les chaînes de messages ou, dans la notation plus familière, les mchains sont apparues dans SObjectizer. <br><br>  Mchain est une variante spécifique d'une boîte aux lettres à consommateur unique où les messages sont envoyés par des fonctions d'envoi régulières.  Mais pour extraire des messages de mchain, vous n'avez pas besoin de créer d'agents et de les signer.  Il existe deux fonctions spéciales qui peuvent être appelées même à l'intérieur des agents, même à l'extérieur des agents: recevoir () et sélectionner ().  Le premier lit les messages d'un seul canal, tandis que le second peut lire les messages de plusieurs canaux à la fois: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); select( from_all().handle_n(<span class="hljs-number"><span class="hljs-number">3</span></span>).empty_timeout(<span class="hljs-number"><span class="hljs-number">200</span></span>ms), case_(ch1, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;first_message_type&gt; msg) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;second_message_type&gt; msg) { ... }), case_(ch2, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;third_message_type&gt; msg ) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_signal_type&gt;){...}, ... ));</code> </pre> <br>  Nous avons déjà parlé de mchain à plusieurs reprises ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en août 2017</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en mai 2018</a> .  Par conséquent, en particulier sur le sujet de l'apparence du travail avec les chaînes, nous n'approfondirons pas ici. <br><br><h3>  Quel impact cela a-t-il eu? </h3><br>  Après l'apparition de mchains dans SObjectizer-5.5, il s'est avéré que SObjectizer, en fait, est devenu encore moins un framework «acteur» qu'auparavant.  En plus de prendre en charge le modèle d'acteur et Pub / Sub, SObjectizer a également ajouté la prise en charge du modèle CSP (communicating sequential process).  Mchains vous permet de développer des applications multi-threads assez complexes sur SObjectizer sans aucun acteur.  Et pour certaines tâches, c'est plus que pratique.  Ce que nous utilisons nous-mêmes de temps en temps. <br><br><h2>  Mécanisme de limitation des messages </h2><br><h3>  Qu'est-ce qui se passait? </h3><br>  L'une des lacunes les plus graves du modèle des acteurs est sa prédisposition à la surcharge.  Il est très facile de se retrouver dans une situation où l'acteur expéditeur envoie des messages à l'acteur destinataire à un rythme plus rapide que l'acteur destinataire peut traiter les messages. <br><br>  En règle générale, l'envoi de messages dans les frameworks d'acteurs est une opération non bloquante.  Par conséquent, lorsqu'une paire de «producteur agile et consommateur ringard» se produit, la file d'attente de l'acteur destinataire augmente alors qu'il existe au moins une sorte de mémoire libre. <br><br>  La principale difficulté de ce problème est qu'un bon mécanisme de protection contre la surcharge doit être affiné pour la tâche appliquée et les caractéristiques du domaine.  Par exemple, pour comprendre quels messages peuvent être dupliqués (et donc pouvoir éliminer les doublons en toute sécurité).  Pour comprendre quels messages ne peuvent pas être jetés de toute façon.  Qui peut être suspendu et de combien, et qui n'est pas autorisé du tout.  Etc., etc. <br><br>  Une autre difficulté est qu'il n'est pas toujours nécessaire d'avoir un bon mécanisme de défense.  Parfois, il suffit d'avoir quelque chose de primitif, mais efficace, accessible et prêt à l'emploi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afin de ne pas forcer l'utilisateur à faire son contrôle de surcharge là où il suffit de jeter simplement des messages «supplémentaires» ou de transmettre ces messages à un autre agent. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est devenu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juste pour que, dans des scénarios simples, vous puissiez utiliser des outils de protection contre les surcharges prêts à l'emploi, </font><font style="vertical-align: inherit;">limites de messages. </font><font style="vertical-align: inherit;">Ce mécanisme vous permet de supprimer les messages inutiles, ou de les envoyer à d'autres destinataires, ou même simplement d'interrompre l'application si les limites sont dépassées.</font></font> Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: worker(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx <span class="hljs-comment"><span class="hljs-comment">//     100  handle_data, //      //  . + limit_then_redirect&lt;handle_data&gt;(100, [this]{ return another_worker_;}) //     1  check_status, //       . + limit_then_drop&lt;check_status&gt;(1) //     1  reconfigure, //     , ..  reconfigure //        . + limit_then_abore&lt;reconfigure&gt;(1) } {...} ... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette rubrique est décrite plus en détail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un article séparé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel impact cela a-t-il eu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne veut pas dire que l'émergence de limites de message est devenue quelque chose qui a fondamentalement changé SObjectizer, les principes de son travail ou travailler avec lui. </font><font style="vertical-align: inherit;">Il peut plutôt être comparé à un parachute de secours, qui n'est utilisé qu'en dernier recours. </font><font style="vertical-align: inherit;">Mais quand vous devez l'utiliser, vous êtes content qu'il existe même.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mécanisme de suivi de la remise des messages </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-ce qui se passait? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 était une boîte noire pour les développeurs. Dans lequel le message est envoyé et ... Et soit il arrive au destinataire, soit il ne vient pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le message n'atteint pas le destinataire, alors l'utilisateur est confronté à la nécessité de passer par une quête passionnante à la recherche d'une raison. Dans la plupart des cas, les raisons sont triviales: soit le message a été envoyé à la mauvaise mbox, soit l'abonnement n'a pas été effectué (par exemple, l'utilisateur a effectué un abonnement dans un état de l'agent, mais a oublié de le faire dans un autre). Mais il peut y avoir des cas plus complexes lorsqu'un message est, par exemple, rejeté par un mécanisme de protection contre les surcharges.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problème était que le mécanisme de livraison des messages était caché au fond des abats de SObjectizer Run-Time et, par conséquent, il était difficile même pour les développeurs de SObjectizer d'acheminer le message vers le destinataire, sans parler des utilisateurs. </font><font style="vertical-align: inherit;">Surtout pour les utilisateurs novices qui ont commis le plus grand nombre d'erreurs aussi triviales.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est devenu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans SObjectizer-5.5, un mécanisme spécial de traçage du processus de remise des messages appelé traçage de remise des messages (ou simplement msg_tracing) a été ajouté, puis finalisé. </font><font style="vertical-align: inherit;">Ce mécanisme et ses capacités ont été décrits plus en détail dans un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article séparé</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors maintenant, si des messages sont perdus à la livraison, vous pouvez simplement activer msg_tracing et voir pourquoi cela se produit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel impact cela a-t-il eu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le débogage d'applications écrites dans SObjectizer est devenu beaucoup plus simple et plus agréable. </font><font style="vertical-align: inherit;">Même </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour nous</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le concept d'env_infrastructure et d'env_infrastructures monothread </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-ce qui se passait? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons toujours considéré SObjectizer comme un outil pour simplifier le développement de code multi-thread. </font><font style="vertical-align: inherit;">Par conséquent, les premières versions de SObjectizer-5 ont été écrites pour fonctionner uniquement dans un environnement multithread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela a été exprimé par l'utilisation de primitives de synchronisation à l'intérieur du SObjectizer pour protéger les composants internes du SObjectizer lorsque vous travaillez dans un environnement multithread. </font><font style="vertical-align: inherit;">C'est donc dans la création de plusieurs threads de travail auxiliaires à l'intérieur du SObjectizer lui-même (pour effectuer des opérations importantes telles que l'entretien du temporisateur et la suppression de l'enregistrement des coopérations d'agent).</font></font><br><br>  C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer a été créé pour la programmation multi-thread et pour une utilisation dans des environnements multi-thread. </font><font style="vertical-align: inherit;">Et cela nous convenait parfaitement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, comme le SObjectizer était utilisé «à l'état sauvage», des situations ont été découvertes où la tâche était suffisamment difficile pour utiliser des acteurs dans sa solution. </font><font style="vertical-align: inherit;">Mais, en même temps, tout le travail pouvait et, en outre, devait être exécuté sur un seul flux de travail. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous avons été confrontés à un problème très intéressant: est-il possible d'apprendre à SObjectizer à travailler sur un seul thread de travail?</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est devenu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'est avéré que c'était possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous a coûté beaucoup d'argent, il a fallu beaucoup de temps et d'efforts pour trouver une solution. </font><font style="vertical-align: inherit;">Mais la solution a été inventée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un concept tel que l'infrastructure d'environnement a été introduit (ou env_infrastructure sous une forme légèrement abrégée). </font><font style="vertical-align: inherit;">Env_infrastructure a pris en charge la gestion de la cuisine interne de SObjectizer. </font><font style="vertical-align: inherit;">En particulier, il a résolu des problèmes tels que l'entretien des minuteries, l'enregistrement et la radiation des coopératives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour SObjectizer, plusieurs options env_infrastructures à thread unique ont été faites. </font><font style="vertical-align: inherit;">Cela nous a permis de développer des applications monothread sur SObjectizer, à l'intérieur desquelles se trouvent des agents normaux échangeant des messages réguliers entre eux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons parlé de cette fonctionnalité </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">plus en</font></a><font style="vertical-align: inherit;"> détail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un article séparé.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel impact cela a-t-il eu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-être la chose la plus importante qui s'est produite lors de la mise en œuvre de cette fonctionnalité a été la rupture de nos propres modèles. </font><font style="vertical-align: inherit;">Un regard sur SObjectizer ne sera plus jamais le même. </font><font style="vertical-align: inherit;">Pendant tant d'années, considérez SObjectizer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exclusivement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme un outil pour développer du code multi-thread. </font><font style="vertical-align: inherit;">Et puis encore! </font><font style="vertical-align: inherit;">Et trouvez que le code à thread unique sur SObjectizer peut également être développé. </font><font style="vertical-align: inherit;">La vie est pleine de surprises.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outils de surveillance d'exécution </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est-ce qui se passait? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 était une boîte noire non seulement en termes de mécanisme de livraison de messages. </font><font style="vertical-align: inherit;">Mais il n'y avait également aucun moyen de savoir combien d'agents travaillent actuellement dans l'application, combien et quels répartiteurs sont créés, combien de threads de travail sont impliqués, combien de messages attendent dans les files d'attente des répartiteurs, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes ces informations sont très utiles pour surveiller les applications fonctionnant 24h / 24 et 7j / 7. </font><font style="vertical-align: inherit;">Mais pour le débogage, je voudrais également comprendre de temps en temps si les files d'attente augmentent ou si le nombre d'agents augmente / diminue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, pour l'instant, nos mains n'ont tout simplement pas atteint le point d'ajouter des fonds à SObjectizer pour collecter et diffuser ces informations.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qu'est devenu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À un moment donné </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans SObjectizer-5.5, des outils sont apparus pour surveiller l'exécution des composants internes de SObjectizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par défaut, la surveillance de l'exécution est désactivée, mais si vous l'activez, des messages seront envoyés régulièrement à la mbox spéciale, à l'intérieur de laquelle il y aura des informations sur le nombre d'agents et de coopérations, sur le nombre de temporisateurs, sur les threads de travail appartenant aux répartiteurs (et il y aura déjà des informations sur le nombre de messages dans les files d'attente, le nombre d'agents liés à ces threads). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, au fil du temps, il est devenu possible d'activer en outre la collecte d'informations sur le temps que les agents passent à l'intérieur des gestionnaires d'événements. </font><font style="vertical-align: inherit;">Cela vous permet de détecter les situations où certains agents sont trop lents (ou perdent du temps à bloquer les appels).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel impact cela a-t-il eu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre pratique, la surveillance d'exécution n'est pas souvent utilisée. </font><font style="vertical-align: inherit;">Mais quand vous en avez besoin, vous vous rendez compte de son importance. </font><font style="vertical-align: inherit;">En effet, sans un tel mécanisme, il est impossible (enfin, ou très difficile) de déterminer ce qui ne fonctionne pas et comment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit donc d'une caractéristique de la catégorie «vous pouvez le faire», mais sa présence, à notre avis, transfère immédiatement l'instrument à une autre catégorie de poids.</font></font> Parce que<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faire un prototype de cadre d'acteur "à genoux" n'est pas si difficile. </font><font style="vertical-align: inherit;">Beaucoup l'ont fait et beaucoup d'autres le feront. </font><font style="vertical-align: inherit;">Mais ensuite, pour équiper votre développement d'une telle chose que la surveillance de l'exécution ... À l'heure actuelle, tous les projets dessinés au genou ne survivent pas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et encore une chose en une seule ligne </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant quatre ans, SObjectizer-5.5 a eu beaucoup d'innovations et de changements, dont la description, même dans un synopsis, prendra trop de place. Par conséquent, nous en désignons une partie par littéralement une ligne. Dans un ordre aléatoire, sans aucune priorité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.5 ajoute la prise en charge du système de construction CMake. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Désormais, SObjectizer-5 peut être construit à la fois en tant que bibliothèque dynamique et statique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.5 est maintenant construit et fonctionne sur Android (à la fois via </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrystaX NDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et via le nouveau NDK Android). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des répartiteurs privés sont apparus. Vous pouvez maintenant créer et utiliser des répartiteurs que personne d'autre ne voit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémentation du mécanisme de filtres de livraison. Désormais, lorsque vous vous abonnez à des messages provenant de MPMC-mbox, vous pouvez interdire la remise de messages dont le contenu ne vous intéresse pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les outils de création et d'enregistrement des coopérations ont été considérablement simplifiés: les méthodes introduisent_coop / introduisent_enfant_coop, make_agent / make_agent_with_binder et c'est tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le concept d'une usine d'objets de verrouillage est apparu et vous pouvez maintenant choisir les objets de verrouillage dont vous avez besoin (basés sur des mutex-s, des verrous tournants, combinés ou d'autres). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La classe wrapped_env_t est apparue et vous pouvez maintenant exécuter SObjectizer dans votre application non seulement avec so_5 :: launch ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le concept de stop_guards est apparu et vous pouvez maintenant influencer le processus d'arrêt de SObjectizer. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez empêcher l'arrêt de SObjectizer jusqu'à ce que certains agents aient terminé leur travail d'application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez désormais intercepter les messages qui ont été remis à l'agent mais qui n'ont pas été traités par l'agent (les soi-disant dead_letter_handlers). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il était possible d'envelopper les messages dans des "enveloppes" spéciales. </font><font style="vertical-align: inherit;">Les enveloppes peuvent contenir des informations supplémentaires sur le message et peuvent effectuer une action lorsque le message est remis au destinataire.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.5.0 à 5.5.23 en chiffres </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est également intéressant de regarder le chemin parcouru en termes de code / tests / exemples. </font><font style="vertical-align: inherit;">Voici ce que l'utilitaire cloc nous dit sur la quantité de code du noyau SObjectizer-5.5.0:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En-tête C / C ++ 58 2119 5156 5762</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 39 1167 779 4759</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 2 30 2 75</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 99 3316 5937 10596</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et voici la même chose, mais pour la v.5.5.23 (dont 1147 lignes sont le code de la bibliothèque optionnelle-lite): </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En-tête C / C ++ 133 6279 22173 21068</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 53 2498 2760 10398</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 2 29 0 177</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 4 53 2 129</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 192 8859 24935 31772</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Volume de tests pour v.5.5.0: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 84 2510 390 11540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 162 496 0 1054</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En-tête C / C ++ 1 11 0 32</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 247 3017390 12626</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tests pour v.5.5.23: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 324 7345 1305 35231</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 675 2353 0 4671</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 338 43 0 955</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En-tête C / C ++ 11107 3448</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 1348 9848 1308 41305</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eh bien, des exemples pour la v.5.5.0: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 27 765 463 3322</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 28 95 0192</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 55 860 463 3514</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils le sont, mais déjà pour la v.5.5.23: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code de commentaire vierge des fichiers de langue</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 67 2141 2061 9341</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rubis 133451 0868</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 67 93 0 595</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En-tête C / C ++ 1 12 11 32</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOMME: 268 2697 2072 10836</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presque partout, une augmentation de près de trois fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et la quantité de documentation pour SObjectizer a probablement encore augmenté.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plans pour un avenir proche (et pas seulement) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les plans de développement préliminaires de SObjectizer après la sortie de la version 5.5.23 ont été décrits </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici il y a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> environ un mois. Fondamentalement, ils n'ont pas changé. Mais il y avait un sentiment que la version 5.6.0, dont la sortie est prévue pour le début de 2019, devra être positionnée comme le début de la prochaine branche stable de SObjectizer. En gardant à l'esprit que pendant 2019, SObjectizer se développera sous la branche 5.6 sans aucun changement significatif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela permettra à ceux qui utilisent désormais SO-5.5 dans leurs projets de passer progressivement à SO-5.6 sans craindre de devoir également passer à SO-5.7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version 5.7, dans laquelle nous voulons nous permettre de nous éloigner quelque part des principes de base de SO-5.5 et SO-5.6, sera considérée comme expérimentale en 2019. </font><font style="vertical-align: inherit;">Avec stabilisation et libération, si tout se passe bien, déjà dans la 2020e année.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je voudrais remercier tous ceux qui nous ont aidés avec le développement de SObjectizer pendant tout ce temps. </font><font style="vertical-align: inherit;">Et je voudrais remercier séparément tous ceux qui ont osé essayer de travailler avec SObjectizer. </font><font style="vertical-align: inherit;">Vos commentaires nous ont toujours été très utiles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous voulons dire à ceux qui n'ont pas encore utilisé SObjectizer: essayez-le. </font><font style="vertical-align: inherit;">Ce n'est pas aussi effrayant que cela puisse paraître. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous n’aimiez pas quelque chose ou n’en aviez pas assez dans SObjectizer, dites-le nous. </font><font style="vertical-align: inherit;">Nous écoutons toujours les critiques constructives. </font><font style="vertical-align: inherit;">Et, s'il est en notre pouvoir, nous donnons vie aux souhaits des utilisateurs.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429046/">https://habr.com/ru/post/fr429046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429034/index.html">Quelques histoires sur les programmeurs underground</a></li>
<li><a href="../fr429038/index.html">Rust News # 2 (octobre 2018)</a></li>
<li><a href="../fr429040/index.html">Patch de code Java sur la production sans anesthésie</a></li>
<li><a href="../fr429042/index.html">Nous testons SharxBase, une plate-forme de virtualisation logicielle et matérielle du fournisseur russe SharxDC</a></li>
<li><a href="../fr429044/index.html">Les actions Apple ont connu la pire chute depuis 2014. Les grands investisseurs ont perdu des milliards</a></li>
<li><a href="../fr429048/index.html">Conseils pour un hébergeur novice</a></li>
<li><a href="../fr429050/index.html">Attaque d'échange de crypto-monnaie Gate.io enregistrée</a></li>
<li><a href="../fr429052/index.html">Pourquoi sur les ordinateurs portables tactiles, certains SPA ont cessé de prendre en charge les événements tactiles</a></li>
<li><a href="../fr429054/index.html">Trouvez N différences. Expérience de test de mise en page Tinkoff.ru</a></li>
<li><a href="../fr429056/index.html">La physique, pas la biologie, rend le vieillissement inévitable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>