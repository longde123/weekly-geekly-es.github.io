<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 🧦 🎅 L'intégration Kubernetes Container remplace Docker prêt pour la production 💆🏿 🧔🏻 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque perev. : Nous avons écrit plus d'une fois à propos de containerd et d' autres runtimes pour Kubernetes. La nouvelle publication est une tradu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'intégration Kubernetes Container remplace Docker prêt pour la production</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/414875/"><img src="https://habrastorage.org/webt/bw/-e/lu/bw-elulxcq_ts7y7ln0cjnwyxng.png"><br><br>  <i><b>Remarque</b></i>  <i><b>perev.</b></i>  <i>: Nous avons écrit plus d'une fois à propos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">containerd</a> et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> runtimes pour Kubernetes.</i>  <i>La nouvelle publication est une traduction de l'annonce récente d'une étape importante dans le développement de containerd, publiée sur le blog officiel du projet Kubernetes.</i>  <i>Le texte a été écrit par des employés de Google et d'IBM, qui (bien sûr, avec Docker Inc) contribuent de manière significative à l'amélioration de containerd.</i> <br><br>  Plus tôt dans le blog - dans la note <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Containerd apporte plus d'options d'exécution de conteneurs pour Kubernetes</a> - nous avons présenté une version alpha de l'intégration de containerd avec Kubernetes.  Les 6 prochains mois de développement ont conduit au fait que l'intégration est devenue publique!  Cela signifie que vous pouvez désormais utiliser <a href="">containerd 1.1</a> comme environnement d'exécution pour les conteneurs des clusters Kubernetes en production. <br><br>  Containerd 1.1 fonctionne avec Kubernetes version 1.10 et supérieure, prend en charge toutes les fonctionnalités de Kubernetes.  Dans l'infrastructure de test de Kubernetes, la couverture des tests d'intégration containerd sur Google Cloud Platform est devenue la même que l'intégration avec Docker (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de bord de test</a> ). <a name="habracut"></a><br><br><blockquote>  «Nous sommes ravis de voir Container atteindre rapidement cette étape importante.  Chez Alibaba Cloud, nous avons commencé à utiliser activement containerd dès ses débuts et, grâce à l'accent mis sur la simplicité et la fiabilité, nous avons fait de containerd le moteur de conteneur par défaut dans son produit Serverless Kubernetes, qui impose des exigences élevées en termes de performances et de stabilité.  Containerd sera sans aucun doute le principal moteur de l'ère des conteneurs et conduira au développement de l'innovation. »  <i>- Xinwei, ingénieur à temps plein d'Alibaba Cloud</i> </blockquote><br><h2>  Améliorations architecturales </h2><br>  L'architecture d'intégration de containerd avec Kubernetes a changé deux fois.  Chacune de ses étapes évolutives s'est stabilisée et a amélioré l'efficacité de la pile. <br><br><h3>  Containerd 1.0 - CRI-Containerd (a cessé d'exister) </h3><br><img src="https://habrastorage.org/webt/8q/n4/2o/8qn42ofstq8qrrucp5txrrb2wze.png"><br><br>  Dans containerd 1.0, le démon cri-containerd était requis pour l'interaction entre <i>Kubelet</i> et containerd <i>(nous en avons parlé à la fin de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> - <b>environ Transl.</b> )</i> .  Ce démon a envoyé des requêtes à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface d'exécution de conteneur (CRI)</a> de <i>Kubelet</i> et utilisé containerd pour gérer correctement les conteneurs et les images de conteneur.  Cette approche a éliminé un lien supplémentaire dans la pile par rapport à l'implémentation Docker CRI ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dockershim</a> ) - <i>voir l'illustration ci-dessus</i> . <br><br>  Cependant, cri-containerd et containerd 1.0 étaient deux démons distincts interagissant sur GRPC.  Un démon supplémentaire dans cet ensemble a rendu la vie difficile aux utilisateurs à la fois pour comprendre l'appareil et pendant le déploiement, et a également généré des frais généraux inutiles pour l'interaction. <br><br><h3>  Containerd 1.1 - Plugin CRI (version actuelle) </h3><br><img src="https://habrastorage.org/webt/sc/hl/uw/schluwslee8y_n4kihjgseh0kpw.png"><br><br>  Dans containerd 1.1, le démon cri-containerd a été refait dans le plugin CRI containerd.  Ce plugin est intégré à containerd 1.1 et est activé par défaut.  Contrairement à cri-containerd, le plugin interagit avec containerd en invoquant directement les fonctions nécessaires.  La nouvelle architecture a rendu l'intégration plus stable et productive, éliminant un autre lien (GRPC) de la pile.  Maintenant containerd 1.1 peut être utilisé directement dans Kubernetes, et le démon cri-containerd n'est plus requis. <br><br><h2>  Performances </h2><br>  L'un des principaux objectifs de containerd 1.1 était d'améliorer les performances.  Des optimisations ont été réalisées au niveau du temps de démarrage et des ressources utilisées par le démon. <br><br>  Les résultats suivants sont une comparaison de containerd 1.1 et Docker 18.03 CE.  Intégration containerd 1.1 utilise le plug-in CRI intégré et l'intégration pour Docker 18.03 CE fonctionne avec dockershim.  Les résultats ont été générés à l'aide du test de performances des nœuds Kubernetes, qui fait partie des <a href="">tests e2e pour les nœuds K8s</a> .  La plupart des données de comparaison sont accessibles au public sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de bord des performances</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nœud</a> . <br><br><h3>  Retard de démarrage du foyer </h3><br>  Les résultats du <i>benchmark de démarrage par lots de 105 pods</i> montrent que l'intégration de containerd 1.1 a moins de retard dans le démarrage d'un pod que Docker 18.03 CE avec dockershim (le plus petit est le mieux). <br><br><img src="https://habrastorage.org/webt/1e/20/re/1e20rewi6uzg9ixrkmfsybifidk.png"><br><br><h3>  CPU et mémoire </h3><br>  Dans un état inactif, l'intégration containerd 1.1 avec 105 foyers consomme moins de processeur et de mémoire que l'intégration Docker 18.03 CE avec dockershim.  Les résultats peuvent varier en fonction du nombre de foyers lancés sur le nœud - le nombre de 105 foyers est sélectionné, car  la valeur par défaut est désormais la valeur maximale pour les foyers personnalisés sur le nœud. <br><br>  Comme le montrent les graphiques ci-dessous, l'intégration de containerd 1.1 avec <i>Kubelet</i> consomme 30,89% de CPU en moins et 11,30% de mémoire RSS en moins (taille de l'ensemble résident), ainsi que 12,78% de mémoire RSS en moins consommée par le runtime du conteneur . <br><br><img src="https://habrastorage.org/webt/ic/w6/rf/icw6rfbsd1rqn6byqbzosaalkim.png"><br><br><h3>  <i>Ajout du traducteur</i> </h3><br>  <i>Il convient de noter qu'une autre solution alternative, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRI-O</a> , continue de se développer.</i>  <i>En particulier, lors d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open Source Summit Japan 2018</a> ces jours-ci, un employé de NTT a présenté un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> avec une comparaison approfondie des environnements exécutables existants pour les conteneurs.</i>  <i>Et voici une de ses diapositives comparant leurs performances:</i> <br><br><img src="https://habrastorage.org/webt/q8/vv/zf/q8vvzfa4zw7ydge80hhj_higkhi.png"><br><br><h2>  crictl </h2><br>  L'interface de console Container Runtime (CLI) est un outil utile pour identifier les problèmes dans le système et l'application.  Lors de l'utilisation de Docker comme environnement de conteneur dans Kubernetes, les administrateurs système se rendent parfois sur le site de Kubernetes pour exécuter des commandes Docker et collecter des informations sur le système et / ou l'application.  Par exemple, ils peuvent utiliser <code>docker ps</code> et <code>docker inspect</code> pour vérifier l'état du processus, les <code>docker images</code> pour obtenir une liste d'images sur le nœud, les <code>docker info</code> pour obtenir la configuration du runtime pour les conteneurs, etc. <br><br>  Pour containerd et tous les autres environnements compatibles CRI tels que dockershim, nous vous recommandons d'utiliser <i>crictl</i> comme alternative CLI aux commandes de la console Docker pour analyser les problèmes sur les pods, les conteneurs et les images de conteneurs hébergés sur les nœuds Kubernetes. <br><br>  <i>crictl</i> est un utilitaire qui offre des fonctionnalités similaires à la Docker CLI et fonctionne aussi bien pour tous les environnements d'exécution pour les conteneurs compatibles avec CRI.  Il peut être trouvé dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel kubernetes-incubator / cri-tools</a> ;  la version actuelle est <a href="">cri-tools v1.11.0</a> <i>(la version a été corrigée pour la version actuelle il y a 3 jours au lieu de <a href="">v1.0.0-beta.1</a> , indiquée dans l'article original, <b>approximativement</b> <a href="">traduit</a> )</i> .  Bien que l'utilitaire <i>crictl</i> soit conçu pour être similaire à la Docker CLI, offrant une transition simple pour les utilisateurs, il n'en est pas une copie complète.  Quelques différences importantes sont décrites ci-dessous. <br><br><h3>  Utilisation limitée: crictl est un outil de dépannage </h3><br>  <i>crictl</i> ne remplace <code>kubectl</code> <code>docker</code> ou <code>kubectl</code> - son utilisation est limitée à la portée de l'identification et de l'analyse des problèmes.  L'interface de la console Docker offre un riche ensemble de commandes, ce qui en fait un outil de développement très utile.  Cependant, ce n'est pas la meilleure option pour le dépannage sur les nœuds Kubernetes.  Certaines commandes Docker (par exemple, le <code>docker network</code> Docker et la <code>docker build</code> Docker) sont inutiles pour Kubernetes, et certaines (par exemple, Docker Rename) peuvent tout casser.  Le but de <i>crictl</i> est de fournir suffisamment de commandes pour identifier les problèmes sur les nœuds qui sont sûrs à utiliser dans les environnements de production. <br><br><h3>  Focus sur Kubernetes </h3><br>  <i>crictl</i> offre une vue des conteneurs plus compréhensible dans le monde Kubernetes.  L'interface de la console Docker ne fonctionne pas avec les concepts de base de Kubernetes, tels que under (pod) et namespace ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">namespace</a> ), ce qui empêche la représentation visuelle des conteneurs et des foyers <i>(l'importance de ce problème est vraie, déjà dans le contexte de surveillance, dont nous avons récemment parlé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce rapport</a> - <b>note . perev.</b> )</i> .  Un tel exemple est <code>docker ps</code> montrant des noms longs et obscurs pour les conteneurs Docker et une liste de conteneurs de pause avec les conteneurs d'application: <br><br><img src="https://habrastorage.org/webt/4w/ne/cs/4wnecsys4wdvacswvpxcfgmhtj8.png"><br><br>  Cependant, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs de pause</a> font partie de la mise en œuvre du foyer, où un tel conteneur est utilisé pour chaque foyer;  ils ne doivent pas être affichés lors de l'affichage de conteneurs faisant partie du foyer. <br><br>  <i>crictl</i> , en revanche, a été créé pour Kubernetes.  L'utilitaire fournit différents ensembles de commandes pour les foyers et les conteneurs.  Par exemple, <code>crictl pods</code> affiche des informations sur les <code>crictl pods</code> et <code>crictl ps</code> affiche uniquement des informations sur les conteneurs d'application.  Toutes les données sont formatées dans une vue tabulaire: <br><br><img src="https://habrastorage.org/webt/fq/su/ck/fqsuckdyowdo74u-u88okijpjsk.png"><br><br><img src="https://habrastorage.org/webt/iy/xg/tf/iyxgtfzobswe9woyeay9lqylwsy.png"><br><br>  Un autre exemple - dans les <code>crictl pods</code> il y a un argument <code>--namespace</code> , qui permet de filtrer les pods par les espaces de noms définis dans Kubernetes: <br><br><img src="https://habrastorage.org/webt/ib/gq/3u/ibgq3udmdsf_wbjdw5lto57ckqa.png"><br><br>  Pour plus d'informations sur l'utilisation de crictl avec containerd, voir ici: <br><br><ul><li>  <a href="">La documentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo de démonstration à asciinema</a> . </li></ul><br><h2>  Mais qu'en est-il du Docker Engine? </h2><br>  Nous entendons souvent la question suivante: «Est-ce que le passage à containerd signifie que je ne peux plus utiliser le Docker Engine?», Et la réponse courte est «NON». <br><br>  Docker Engine est basé sur containerd.  La prochaine version de Docker Community Edition (Docker CE) utilisera containerd version 1.1.  En conséquence, il aura un plug-in CRI intégré et activé par défaut.  Cela signifie que les utilisateurs auront la possibilité de continuer à travailler avec le moteur Docker pour d'autres scénarios typiques, ainsi que la possibilité de configurer Kubernetes pour utiliser le conteneur sous-jacent fourni avec le moteur Docker et qui est simultanément utilisé par le moteur Docker sur le même hôte.  Jetez un œil au schéma architectural ci-dessous montrant comment le même containerd est utilisé par le Docker Engine et <i>Kubelet</i> : <br><br><img src="https://habrastorage.org/webt/qj/f2/r2/qjf2r2vn_j4odysnyxytokycz9u.png"><br><br>  Étant donné que containerd est utilisé à la fois par <i>Kubelet</i> et le Docker Engine, les utilisateurs qui choisissent de s'intégrer à containerd obtiendront non seulement toutes les nouvelles fonctionnalités de Kubernetes, des améliorations des performances et de la stabilité, mais aussi la possibilité d'utiliser le Docker Engine, comme auparavant, pour d'autres besoins. <br><br>  Le mécanisme d' <a href="">espace de noms</a> dans containerd garantit que <i>Kubelet</i> et le moteur Docker n'auront pas accès aux conteneurs et aux images qu'ils n'ont pas créés.  Cela signifie qu'ils n'interféreront pas les uns avec les autres, ainsi que: <br><br><ul><li>  Les utilisateurs entrant la <code>docker ps</code> ne verront pas les conteneurs créés dans Kubernetes.  Utilisez <code>crictl ps</code> pour cela.  Inversement, les utilisateurs ne verront pas les conteneurs créés dans la Docker CLI sur Kubernetes ou la commande <code>crictl ps</code> .  Les commandes <code>crictl create</code> et <code>crictl run</code> sont uniquement destinées au dépannage.  Il n'est pas recommandé d'exécuter manuellement des foyers ou des conteneurs à l'aide de <code>crictl</code> sur les nœuds de production. </li><li>  Les utilisateurs saisissant la <code>docker images</code> ne verront pas les images de Kubernetes.  Pour ce faire, utilisez la commande <code>crictl images</code> .  À l'inverse, Kubernetes ne verra pas les images créées par les commandes Puller Docker Load et Docker Build.  Pour ce faire, utilisez la commande <code>crictl pull</code> , ainsi que <code><a href="">ctr</a> cri load</code> , si vous souhaitez charger l'image. </li></ul><br><h2>  Résumé </h2><br><ul><li>  Containerd 1.1 a un support CRI natif.  Il peut être utilisé directement par Kubernetes. </li><li>  Containerd 1.1 est prêt pour la production. </li><li>  Containerd 1.1 a de bonnes performances en termes de temps de démarrage du pod et d'utilisation des ressources système. </li><li>  crictl est un utilitaire de console (CLI) pour communiquer avec containerd 1.1 et d'autres environnements d'exécution pour les conteneurs qui sont conformes à CRI afin d'identifier les problèmes sur le nœud. </li><li>  Containerd 1.1 sera inclus dans la prochaine version stable de Docker CE.  Les utilisateurs auront la possibilité de continuer à travailler avec Docker dans les cas non-Kubernetes et de configurer Kubernetes pour utiliser le containerd sous-jacent qui fait partie de Docker. </li></ul><br>  Nous tenons à remercier tous ceux de Google, IBM, Docker, ZTE, ZJU et les développeurs individuels qui ont contribué et rendu tout cela possible! <br><br>  Pour une liste détaillée des modifications apportées à containerd 1.1, consultez les <a href="">notes de publication</a> . <br><br><h2>  Comment essayer </h2><br>  Instructions pour configurer un cluster Kubernetes pour utiliser containerd comme runtime par défaut: <br><br><ul><li>  pour un cluster sur GCE, levé en utilisant <code>kube-up.sh</code> , - <a href="">ici</a> ; </li><li>  pour installer un cluster de nombreux nœuds en utilisant Ansible et kubeadm - <a href="">ici</a> ; </li><li>  pour créer un cluster à partir de zéro dans Google Cloud - voir " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes the Hard Way</a> "; </li><li>  pour une installation manuelle à partir des archives tarball - <a href="">ici</a> ; </li><li>  pour l'installation à l'aide de LinuxKit sur une machine virtuelle locale - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br><h2>  Comment contribuer </h2><br>  Plugin CRI Containerd - Un projet open source sur GitHub, qui fait partie de containerd: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/containerd/cri</a> .  Toutes les modifications proposées sont les bienvenues sous forme d'idées, de tickets, de corrections.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide de</a> démarrage pour les développeurs est un bon point de départ pour apporter des modifications. <br><br><h2>  PS du traducteur </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRI-O - une alternative à Docker pour le lancement de conteneurs dans Kubernetes</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que Docker fait et pourquoi Moby s'intègre-t-il à Kubernetes?"</a>  "; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quatre CNCF publient 1.0 et des annonces majeures sur Kubernetes avec KubeCon 2017</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pourquoi avons-nous besoin de containerd et pourquoi il a été séparé de Docker</a> "; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelle est l'essence du projet Moby et pourquoi Moby / Moby est-il devenu soudainement le principal référentiel Docker?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414875/">https://habr.com/ru/post/fr414875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414865/index.html">iMaterialist Furniture Challenge ou 50 nuances de chaises</a></li>
<li><a href="../fr414867/index.html">ThinkingHome.Migrator - migration versionnée du schéma de base de données sur la plate-forme .NET Core</a></li>
<li><a href="../fr414869/index.html">Cadres en voie de disparition</a></li>
<li><a href="../fr414871/index.html">La tempête de poussière sur Mars a atteint l'échelle planétaire, même la curiosité est affectée</a></li>
<li><a href="../fr414873/index.html">IDisposable - que votre maman n'a pas parlé de libérer des ressources. Partie 1</a></li>
<li><a href="../fr414877/index.html">Un objectif inhabituel pour un appareil photo ordinaire ou comment arrêter de penser à la mise au point</a></li>
<li><a href="../fr414879/index.html">Pourquoi 2 extrudeuses dans une imprimante 3D?</a></li>
<li><a href="../fr414881/index.html">Un peu de VK dans les coulisses</a></li>
<li><a href="../fr414883/index.html">Les souvenirs résonnaient d'une manière nouvelle: la BBC a mis à jour les archives sonores du projet RemArc</a></li>
<li><a href="../fr414885/index.html">Nous traitons les erreurs et les «béquilles» dans le Registre d'État unifié des entités juridiques - le registre d'État des entités juridiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>