<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 👶🏻 🖕🏼 Devops, JUnit5 e testes de microsserviços: uma visão subjetiva do Heisenbag de Moscou 👵🏿 🤛🏻 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos dias 6 e 7 de dezembro, a quinta conferência Heisenbag foi realizada em Moscou. 
 O slogan dela é “Teste. Não apenas para testadores! ”, E por doi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Devops, JUnit5 e testes de microsserviços: uma visão subjetiva do Heisenbag de Moscou</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432736/"><img src="https://habrastorage.org/webt/yy/ey/ao/yyeyao2gdkf5rkv4vqbkhwdnic8.jpeg"><br><br>  Nos dias 6 e 7 de dezembro, a quinta conferência Heisenbag foi realizada em Moscou. <br>  O slogan dela é “Teste.  Não apenas para testadores! ”, E por dois anos de visitas regulares aos Heisenbags, eu (anteriormente desenvolvedor Java, agora líder técnico em uma pequena empresa que nunca havia trabalhado em controle de qualidade), aprendi muito em testes e implementou muito em nossa equipe.  Quero compartilhar uma revisão subjetiva dos relatórios que me lembro dessa vez. <br><a name="habracut"></a><br>  <b>Isenção de responsabilidade.</b>  Obviamente, essa é apenas uma pequena fração (8 em 30) dos relatórios selecionados com base em minhas preferências pessoais.  Quase todos esses relatórios estão de alguma forma relacionados ao Java e não há um único sobre desenvolvimento front-end e móvel.  Em alguns lugares, me permitirei uma polêmica com o orador.  Se você estiver interessado em uma revisão mais completa e neutra, por tradição, ela deve aparecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no blog dos organizadores</a> .  Mas, talvez, seja interessante para alguém descobrir exatamente sobre esses relatórios que eles não puderam acessar. <br><br>  <i>As fotos do artigo são do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">twitter oficial da</a> conferência.</i> <br><br><h3>  Baruch Sadogursky.  Temos DevOps.  Vamos demitir todos os testadores </h3><br><img src="https://habrastorage.org/webt/ht/my/tt/htmyttor7b0ij-jr5dx4ydosj0w.jpeg"><br>  <i>(Na foto - o hype quando Baruch distribuiu o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Liquid Software</a> )</i> <br><br>  Aqueles envolvidos em Java e participando de conferências do Grupo JUGRU, Baruch Sadogursky não precisa de apresentações.  No entanto, ele se apresentou pela primeira vez no Heisenbug. <br><br>  Em poucas palavras - foi um relatório de revisão sobre as principais idéias do DevOps.  A necessidade do público por esses relatórios permanece, porque, quando perguntados "Dê a definição de DevOps" ao público, as pessoas ainda respondem antes de tudo "Esta é uma pessoa ..." <br><br>  Mas mesmo aqueles que já aprenderam algo sobre esse assunto, será muito interessante aprender sobre os estudos da associação DORA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">devops-research.com</a> , que recebeu porcentagens de variedades de trabalho manual em equipes com desempenho diferente.  E sobre a curva que liga a velocidade e a qualidade da entrega (em algum momento, a velocidade diminui, porque precisamos de tempo para "testar melhor", mas à medida que a equipe se desenvolve, a correlação se torna direta): <br><br><img src="https://habrastorage.org/webt/fw/8v/8o/fw8v8ocre1tvccsgnwvihwc7eaw.png" width="400"><br><br>  Embora o título do relatório tenha sido provocativo e, no cronograma, o relatório tenha sido marcado com a categoria “queimará”, seu conteúdo, na minha opinião, era bastante popular.  Evidentemente, não se tratava da demissão de testadores sob as condições da transformação do Devops, mas de uma mudança na natureza do trabalho dos testadores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alan Page</a> e Nikolai Alimenkov falaram muito sobre essas coisas há um ano.  Tanto a mudança de papéis quanto o desenvolvimento “horizontal” de habilidades em forma de T foram discutidos há um ano na mesa redonda “o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que um testador deve saber em 2018</a> ”. <br><br>  “Claro, se você não quer mudar, há trabalho para você, embora não seja tão interessante.  Até o momento, ainda há trabalho para quem deseja dar suporte a sistemas escritos em COBOL nos anos 70 ”, disse Baruch. <br><br><h3>  Artyom Eroshenko.  Precisa refatorar um projeto?  Tenha uma IDÉIA! </h3><br><img src="https://habrastorage.org/webt/nz/i0/hm/nzi0hmxhws-r45ww43c8bl8lsr0.jpeg"><br><br>  Artyom está familiarizado com os participantes da Heisenbag com relatórios sobre o sistema de relatórios Allure (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está seu relatório</a> sobre as oportunidades da Allure que apareceram em 2018 a partir da Heisenbug anterior em São Petersburgo).  O próprio Allure nasceu no contexto de projetos com milhares, dezenas de milhares e até mais de centenas de milhares de testes e foi projetado para simplificar a interação entre desenvolvedores e testadores.  Ele tem a capacidade de vincular testes a recursos externos, como sistemas de emissão de bilhetes e confirmações no sistema de controle de versão.  Em nossa micro equipe, enquanto a contagem de testes passou apenas por dezenas, lidamos completamente com os meios padrão.  Mas como o número de testes em um dos produtos atingiu 700 e a tarefa geral era criar relatórios de alta qualidade para os clientes, comecei a olhar para o Allure. <br><br>  No entanto, este relatório não era sobre Allure, embora também sobre ele. <br><br>  Artyom convenceu o público de que escrever plugins para o IntelliJ IDEA é uma atividade simples e fascinante.  Por que isso seria necessário?  Para automatizar a modificação do código em massa.  Por exemplo, para converter um grande número de códigos-fonte de JUnit4 em JUnit5.  Ou do uso do Allure 1 ao Allure 2. Ou para automatizar a marcação dos testes com a comunicação com o sistema de marcação. <br><br>  Quem trabalha com o IDEA sabe quais truques ele pode fazer com o código (por exemplo, traduza automaticamente o código usando loops para código usando o Java Streams e vice-versa, ou traduza instantaneamente o Java para o Kotlin).  Quanto mais interessante foi ver como é aberto o véu de sigilo sobre as transformações de código no IDEA, somos convidados a participar disso e a criar nossos próprios plugins para nossas necessidades exclusivas.  Na próxima vez, quando precisar fazer algo com uma grande base de códigos, lembrarei deste relatório e verei como ele pode ser automatizado usando um plug-in genérico no IDEA. <br><br><h3>  Kirill Merkushev.  Projeto Java e Reactor - e os testes? </h3><br><img src="https://habrastorage.org/webt/35/u5/ze/35u5zepym4if2dyz-hwev3e0_mg.jpeg"><br><br>  Parece-me que esse relatório poderia ter sido realizado nas conferências Joker ou JPoint Java.  Kirill falou sobre como ele usa a estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projectreactor.io</a> em uma arquitetura de microsserviço com um único log de eventos (Kafka), um pouco sobre a essência da codificação em "fluxos reativos", incluindo como os aplicativos que usam essa estrutura podem ser depurados e testados. <br><br>  A vida também está incentivando nossa equipe a usar a arquitetura com um único log de eventos, e também analisamos o Kafka.  É verdade que, para eventos de streaming, estamos experimentando a API Kafka Streams (onde, ao que me parece, mais coisas como processamento com estado são implementadas de forma transparente para o desenvolvedor) e não o Reator.  No entanto, como sempre acontece com as novas tecnologias, o "rake" e as "armadilhas" não são conhecidos antecipadamente.  Portanto, era importante ouvir a história de um especialista que já está trabalhando com tecnologia. <br><br><h3>  Leonid Rudenko.  Gerenciando um cluster Selenoid com Terraform </h3><br><img src="https://habrastorage.org/webt/6h/xu/s8/6hxus8uek7c3xoztsywkvfwlqlq.jpeg"><br><br>  Se o relatório anterior lembrava uma conferência da JPoint, este certamente é sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOops</a> .  Leonid falou sobre como usar as especificações do Terraform para aumentar e configurar um cluster Selenoid.  Sobre o que o próprio Selenoid era, havia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um relatório</a> sobre o Heisenbug do ano passado - é um rico sistema distribuído que funciona como um serviço elástico e permite executar um grande número de testes de Selenium em vários navegadores.  Como qualquer sistema que exija implantação em várias máquinas, a instalação manual do Selenoid é difícil.  Aqui, os sistemas modernos de configuração como código são úteis. <br><br>  Leonid fez uma visão geral bastante detalhada dos recursos do Terraform - um sistema que provavelmente não era familiar para a maioria do público, mas na verdade já era bem conhecido pela automação do DevOps (por exemplo, na conferência Devoops-2018, houve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um excelente relatório de</a> Anton Babenko sobre as melhores práticas para criar e manter o código Terraform).  Além disso, foi mostrado como usar os scripts do Terraform para descrever os parâmetros dos contêineres do docker com o Selenoid para cada uma das máquinas no cluster e os parâmetros das próprias máquinas virtuais do cluster. <br><br>  Embora o caso específico considerado por Leonid possa certamente facilitar a tarefa de implantar o Selenoid, não concordo com o orador em tudo.  Essencialmente, ele usa o Terraform para duas tarefas diferentes: criar recursos e configurá-los.  E isso leva ao fato de que Leonid é forçado a lançar o Terraform uma vez para criar máquinas virtuais e mais uma vez para cada uma das máquinas virtuais elevar contêineres de docker sobre elas.  Na minha opinião, o Terraform, que resolve bem o problema de criar recursos, não resolve muito bem o problema de configuração.  Seria possível evitar a multiplicação de projetos de terraform e seu lançamento repetido usando sistemas de configuração especiais, por exemplo, Ansible ou outras soluções. <br><br>  Mas, em geral, como um "programa educacional" para testadores no campo de Infraestrutura como Código, este relatório é muito útil. <br><br><h3>  Andrey Markelov.  Teste de integração elegante do zoológico de microsserviço com TestContainers e JUnit 5 usando o exemplo da plataforma global de SMS </h3><br><img src="https://habrastorage.org/webt/rk/3d/mo/rk3dmodcrkabye2qc8mdl_vskws.jpeg"><br><br>  E novamente sobre microsserviços!  Desta vez, a conversa foi sobre como executar testes que exigem o lançamento e a interação de vários serviços ao mesmo tempo.  A JUnit5, com seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistema de extensão</a> e a conhecida (e excelente) estrutura TestContainers, foi proposta como base da solução (consulte, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o relatório do ano passado de Sergey Egorov</a> ). <br><br>  Se você está escrevendo algo em Java e ainda não sabe o que é o TestContainers, recomendo com urgência que você o estude.  O TestContainers permite, usando a tecnologia Docker, diretamente no código de teste, coletar bancos de dados reais e outros serviços, conectá-los pela rede e, como resultado, executar testes de integração no ambiente criado no momento em que os testes foram iniciados e destruídos imediatamente após.  Ao mesmo tempo, tudo funciona diretamente do código Java, se conecta como uma dependência do Maven e não requer a instalação de nada além do Docker na máquina / servidor de IC do desenvolvedor.  Estamos usando o TestContainers há mais de um ano. <br><br>  Andrei mostrou um exemplo bastante impressionante de como você pode especificar a configuração do ambiente de teste para testes de ponta a ponta usando as extensões JUnit5, anotações personalizadas e TestContainers.  Por exemplo, escrevendo anotações sobre seu teste (código condicional) <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Billing</span></span> <span class="hljs-meta"><span class="hljs-meta">@Messaging</span></span></code> </pre> <br>  podemos, relativamente falando, escrever <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">systemIsDoingRightThings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BillingService b, MessagingService m)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre><br>  nos parâmetros pelos quais as interfaces Java serão passadas através das quais você pode se comunicar com serviços reais gerados (despercebidos pelo desenvolvedor de teste) em contêineres. <br><br>  Esses exemplos parecem muito elegantes.  Para mim, como usuário ativo do TestContainers e JUnit 5, eles são compreensíveis e relativamente fáceis de implementar. <br><br>  Mas, em geral, com essa abordagem, a grande questão permanece por resolver, relacionada ao fato de que a maneira de configurar os sistemas de teste e produção é fundamentalmente diferente. <br><br>  A implementação de lançamentos rápidos na produção sem medo de quebrar tudo é possível apenas se durante o teste de ponta a ponta, não apenas o sistema inteiro tiver sido testado, mas também a maneira de configurá-lo.  Se executássemos repetidamente o script de implantação do sistema durante o processo de desenvolvimento e teste, não teríamos dúvida de que esse script funcionaria mesmo quando iniciado na produção.  A função do código que configura o ambiente de teste no exemplo de Andrey é desempenhada por anotações.  Mas, na produção, organizamos o sistema usando um código completamente diferente - Ansible, Kubernetes, qualquer coisa - não envolvido de forma alguma com esse teste do sistema.  E isso limita esses testes, que não são completamente de ponta a ponta. <br><br><h3>  Andrey Glazkov.  Testando sistemas com dependências externas: problemas, soluções, Mountebank </h3><br><img src="https://habrastorage.org/webt/rc/u5/pm/rcu5pm2i_wcdfacaaglje5bcqmy.jpeg"><br><br>  Para aqueles para quem o tópico deste relatório é relevante, recomendo que você assista também a uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">brilhante apresentação de Andrei Solntsev</a> sobre uma abordagem baseada em princípios para testar sistemas que dependem de serviços externos.  Solntsev fala de maneira convincente sobre a necessidade de usar zombarias de sistema externo para testes abrangentes.  E Andrei Glazkov, em seu relatório, descreve um dos sistemas para esse molhamento - o Mountebank, escrito no NodeJS. <br><br>  Você pode elevar o Mountebank como servidor e "treinar" as respostas às solicitações pela rede de maneira semelhante à forma como treinamos as simulações de interface ao escrever testes de unidade.  A única diferença é que é uma simulação de um serviço de rede.  Um caso curioso de usar o Mountebank é a capacidade de usá-lo como proxy - enviando algumas solicitações para um sistema externo real. <br><br>  Deve-se notar aqui que eu recomendaria que os desenvolvedores Java (e Andrei concordaram na área de discussão) também procurem a biblioteca WireMock, que é criada em Java e pode ser executada no modo incorporado, ou seja, diretamente dos testes sem instalar nenhum Serviços para a máquina do desenvolvedor ou servidor de IC (embora também possa funcionar como um servidor independente).  Como o Mountebank, o WireMock suporta o modo proxy.  Temos alguma experiência positiva com o WireMock. <br><br>  A vantagem do Mountebank, no entanto, é o suporte a protocolos de nível inferior (o WireMock funciona apenas para HTTP) e a capacidade de trabalhar em um "zoológico" de diferentes tecnologias (existem bibliotecas para diferentes idiomas para o Mountebank). <br><br><h3>  Kirill Tolkachev.  Testando e chorando com o Spring Boot Test </h3><br><img src="https://habrastorage.org/webt/k0/zu/tc/k0zutcg8ntbu0_a4suehr0lsqww.jpeg"><br><br>  E novamente Java, microsserviços e JUnit 5. Kirill é outro orador das conferências Joker e JPoint, bem conhecidas da comunidade Java, que falaram pela primeira vez na Heisenbug. <br><br>  Este relatório é uma versão modificada do relatório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spring Curse</a> do ano passado, com exemplos modificados para JUnit5 e Spring Boot 2. Vários problemas práticos relacionados à configuração de testes do Spring Boot em testes de componentes / microsserviços são examinados em profundidade.  Por exemplo, fiquei impressionado com o exemplo de usar o <code>@SpringBootConfiguration StopConfiguration</code> vazio no lugar certo na árvore de origem para interromper o processo de verificação da configuração, bem como a possibilidade de usar <code>@MockBean</code> e <code>@SpyBean</code> vez de zombarias.  Como outros relatórios de Cyril e Evgeny Borisov, este é um material que faz sentido retornar ao processo de uso prático do Spring Framework. <br><br><h3>  Andrey Karpov.  O que os analisadores estáticos podem fazer, o que os programadores e testadores não podem </h3><br><img src="https://habrastorage.org/webt/ze/xw/5b/zexw5bvquuivqfswlpzhocrx4pe.jpeg"><br><br>  A análise de código estático é uma coisa boa.  De acordo com os cânones da Entrega Contínua, deve ser a primeira fase do pipeline de entrega, filtrando o código com problemas que podem ser detectados pela "leitura" do código.  A análise estática é boa porque é rápida (muito mais rápida que os testes) e barata (não requer esforços adicionais da equipe na forma de escrever testes: todas as verificações já foram escritas pelos autores do analisador). <br><br>  Andrey Karpov, um dos fundadores do projeto PVS-Studio (familiar aos leitores da Habr em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blog</a> ) criou um relatório sobre exemplos de quais erros na análise de código de produtos conhecidos foram encontrados usando o PVS-Studio.  O PVS Studio em si é um produto poliglota, suporta C, C ++, C # e, mais recentemente, Java. <br><br>  Apesar de os exemplos acima serem interessantes e a utilidade da análise estática deles ser óbvia, na minha opinião, o relatório de Andrey apresentava falhas. <br><br>  Em primeiro lugar, o relatório foi elaborado exclusivamente com base no produto PVS-Studio (para o qual, segundo o orador, "o preço médio é de US $ 10.000").  Mas vale a pena mencionar que, de fato, em muitos idiomas existem muitos sistemas de análise estática OpenSource desenvolvidos.  Somente em Java - o Checkstyle e o SpotBugs gratuitos (o sucessor do projeto FindBugs congelado), bem como o analisador IntelliJ IDEA, que pode ser executado separadamente do IDE e receber um relatório, fizeram um tremendo progresso. <br><br>  Em segundo lugar, falando em análise estática, parece-me que sempre vale a pena mencionar as limitações fundamentais desse método.  Nem todo mundo passou pela teoria dos algoritmos na universidade e está familiarizado com o "problema do desligamento", por exemplo. <br><br>  E, finalmente, os problemas de introdução da análise estática na base de códigos existente não foram levantados, o que ainda impede muitos do uso regular de analisadores em projetos.  Por exemplo, executamos o analisador em um grande projeto herdado e encontramos 100.500 vorings.  Não há tempo e esforço para corrigi-los no local, e alterar massivamente algo no código é um risco.  O que fazer com isso, como fazer a análise estática funcionar como uma porta de qualidade?  Esse problema foi discutido na área de discussão com Andrei, mas esse problema não foi considerado no próprio relatório. <br><br>  Em geral, desejo a Andrey e sua equipe todo sucesso.  Seu produto é interessante e a idéia de ocupar seu nicho nessa área é muito ousada. <br><br><h3>  *** </h3><br>  Talvez eu não diga nada sobre as notas finais do primeiro e do segundo dia: ambos eram programas de direitos autorais que você só precisa assistir.  Falar sobre eles é como recontar palavras, por exemplo, uma performance de uma banda de rock. <br><br>  No meu relatório de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ano atrás,</a> eu já tentei transmitir a atmosfera geral da conferência e falei sobre o que está acontecendo nas áreas de discussão, no almoço e na festa, para não me repetir. <br><br>  Concluindo, gostaria de agradecer aos organizadores por outra conferência lindamente realizada.  Pelo que entendi, o interesse na conferência excedeu um pouco as expectativas, houve algumas reservas em excesso e nem todos tinham lembranças suficientes.  Mas, com certeza, todos tinham coisas mais importantes: relatórios interessantes, espaço para discussões, alimentos e bebidas.  Estou ansioso para novas reuniões! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432736/">https://habr.com/ru/post/pt432736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432726/index.html">Máquina RAM</a></li>
<li><a href="../pt432728/index.html">Vulnerabilidade na API do Google+ revelou dados privados de 52,5 milhões de usuários</a></li>
<li><a href="../pt432730/index.html">MQTT, Smart Home, ESP-8266 e Plug & Play</a></li>
<li><a href="../pt432732/index.html">Minha experiência na implementação de 1C (parte 1. Introdutória)</a></li>
<li><a href="../pt432734/index.html">Torcido nas nuvens: perspectivas de desenvolvimento e o outro lado dos serviços em nuvem</a></li>
<li><a href="../pt432740/index.html">"CMS" com base nas planilhas do Google para sites estáticos</a></li>
<li><a href="../pt432742/index.html">Pressão de tempo corporativa</a></li>
<li><a href="../pt432744/index.html">DWDM: a solução é mais barata que a operadora em 30-50% (classe Enterprise)</a></li>
<li><a href="../pt432746/index.html">Por três dias em terapia intensiva ou o que há de errado com a seção Equilíbrio entre vida profissional e pessoal no Mobius'18?</a></li>
<li><a href="../pt432748/index.html">Dicas e truques do Kubernetes: alocação de nós e carregamento de aplicativos da web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>