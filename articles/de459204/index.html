<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üë©üèø‚Äçü§ù‚Äçüë©üèº üßëüèø 10 ++ M√∂glichkeiten, mit Hardwareregistern in C ++ zu arbeiten (z. B. IAR und Cortex M) üßëüèø‚Äçü§ù‚Äçüßëüèø üöÆ üìõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abb. I. Kiyko 

 Gute Gesundheit an alle! 

 Sie erinnern sich wahrscheinlich an eine b√§rtige Anekdote und vielleicht an eine wahre Geschichte dar√ºber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 ++ M√∂glichkeiten, mit Hardwareregistern in C ++ zu arbeiten (z. B. IAR und Cortex M)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459204/"><img src="https://habrastorage.org/webt/fd/id/cl/fdidclwtjklierjxrqybnqmttui.jpeg" alt="Den sichersten Weg w√§hlen"><br>  <sub><b>Abb.</b></sub>  <sub><b>I. Kiyko</b></sub> <br><br>  Gute Gesundheit an alle! <br><br>  Sie erinnern sich wahrscheinlich an eine b√§rtige Anekdote und vielleicht an eine wahre Geschichte dar√ºber, wie ein Sch√ºler gefragt wurde, wie er die H√∂he eines Geb√§udes mit einem Barometer messen kann.  Der Sch√ºler zitierte meiner Meinung nach ungef√§hr 20 oder 30 M√∂glichkeiten, ohne den direkten (durch den Druckunterschied) zu erw√§hnen, den der Lehrer erwartet hatte. <br><br>  In etwa der gleichen Weise m√∂chte ich die Verwendung von C ++ f√ºr Mikrocontroller weiter diskutieren und M√∂glichkeiten f√ºr die Arbeit mit Registern unter Verwendung von C ++ in Betracht ziehen.  Und ich m√∂chte darauf hinweisen, dass es keinen einfachen Weg gibt, um einen sicheren Zugang zu den Registern zu erreichen.  Ich werde versuchen, alle Vor- und Nachteile der Methoden aufzuzeigen.  Wenn Sie mehr M√∂glichkeiten kennen, werfen Sie sie in die Kommentare.  Also fangen wir an: <br><a name="habracut"></a><br><h3>  Methode 1. Offensichtlich und offensichtlich nicht die beste </h3><br>  Die gebr√§uchlichste Methode, die auch in C ++ verwendet wird, ist die Beschreibung der Registerstrukturen aus der Header-Datei des Herstellers.  Zur Demonstration nehme ich zwei Port-A-Register (ODR - Ausgangsdatenregister und IDR - Eingangsdatenregister) des STM32F411-Mikrocontrollers, damit ich die blinkende LED ‚ÄûHello World‚Äú zum Einbetten ausf√ºhren kann. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; GPIOA-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,      }</span></span></code> </pre> <br>  Mal sehen, was hier passiert und wie dieses Design funktioniert.  Der Mikroprozessor-Header enth√§lt die <code>GPIO_TypeDef</code> Struktur und eine <code>GPIOA</code> auf diese <code>GPIOA</code> Struktur.  Es sieht so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MODER; <span class="hljs-comment"><span class="hljs-comment">//port mode register, Address offset: 0x00 __IO uint32_t OTYPER; //port output type register, Address offset: 0x04 __IO uint32_t OSPEEDR; //port output speed register, Address offset: 0x08 __IO uint32_t PUPDR; //port pull-up/pull-down register, Address offset: 0x0C __IO uint32_t IDR; //port input data register, Address offset: 0x10 __IO uint32_t ODR; //port output data register, Address offset: 0x14 __IO uint32_t BSRR; //port bit set/reset register, Address offset: 0x18 __IO uint32_t LCKR; //port configuration lock register, Address offset: 0x1C __IO uint32_t AFR[2]; //alternate function registers, Address offset: 0x20-0x24 } GPIO_TypeDef; #define PERIPH_BASE 0x40000000U //Peripheral base address in the alias region #define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000U) #define GPIOA_BASE (AHB1PERIPH_BASE + 0x0000U) #define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span></code> </pre><br>  Um es in einfachen menschlichen Worten <code>GPIO_TypeDef</code> Die gesamte Struktur des <code>GPIO_TypeDef</code> Typs "legt" sich an der Adresse <code>GPIOA_BASE</code> . Wenn Sie sich auf ein bestimmtes Feld der Struktur beziehen, beziehen Sie sich im Wesentlichen auf die Adresse dieser Struktur + Offset zu einem Element dieser Struktur.  Wenn Sie <code>#define GPIOA</code> entfernen, <code>#define GPIOA</code> der Code folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; ((GPIO_TypeDef *) GPIOA_BASE)-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  In Bezug auf die Programmiersprache C ++ wird eine Ganzzahladresse in einen <code>GPIO_TypeDef</code> auf die <code>GPIO_TypeDef</code> Struktur <code>GPIO_TypeDef</code> .  In C ++ versucht der Compiler bei Verwendung der C-Konvertierung, die Konvertierung in der folgenden Reihenfolge durchzuf√ºhren: <br><br><ul><li>  const_cast </li><li>  static_cast </li><li>  static_cast neben const_cast, </li><li>  reinterpret_cast </li><li>  reinterpret_cast neben const_cast </li></ul><br>  d.h.  Wenn der Compiler den Typ nicht mit const_cast konvertieren konnte, versucht er, static_cast usw. anzuwenden.  Als Ergebnis wird der Anruf: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  es gibt nichts wie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt; (GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  In der Tat w√§re es f√ºr C ++ - Anwendungen richtig, die Struktur wie folgt auf die Adresse zu ziehen: <br><br><pre> <code class="cpp hljs">GPIO_TypeDef * GPIOA{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt;(GPIOA_BASE)} ;</code> </pre> <br>  In jedem Fall gibt es aufgrund der Typkonvertierung ein gro√ües Minus f√ºr diesen Ansatz f√ºr C ++.  Es besteht in der Tatsache, dass <code>reinterpret_cast</code> weder in <code>constexpr</code> Konstruktoren und -Funktionen noch in Vorlagenparametern verwendet werden kann, was die Verwendung von C ++ - Funktionen f√ºr Mikrocontroller erheblich reduziert. <br>  Ich werde dies anhand von Beispielen erkl√§ren.  Dies ist m√∂glich: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Test* mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Geta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;a; } Test test{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Geta&lt;&amp;test&gt;() ; }</code> </pre><br>  Dies k√∂nnen Sie jedoch noch nicht tun: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;GPIO_TypeDef * mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;IDR; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//GPIOA  reinterpret_cast&lt;GPIO_TypeDef *&gt; (GPIOA_BASE) //  ,        GetIdr&lt;GPIOA&gt;() ; // } //      : struct Port { constexpr Port(GPIO_TypeDef * ptr): port(*ptr) {} GPIO_TypeDef &amp; port ; } //  GPIOA  reinterpret_cast,   //  constexpr      constexpr Port portA{GPIOA}; //   </span></span></code> </pre><br>  Die direkte Verwendung dieses Ansatzes f√ºhrt daher zu erheblichen Einschr√§nkungen bei der Verwendung von C ++.  Wir werden das Objekt, das den <code>GPIOA</code> im ROM verwenden m√∂chte, mit den <code>GPIOA</code> nicht finden k√∂nnen, und wir werden die Metaprogrammierung f√ºr ein solches Objekt nicht nutzen k√∂nnen. <br>  Dar√ºber hinaus ist diese Methode im Allgemeinen keine Sicherheit (wie unsere westlichen Partner sagen).  Immerhin ist es durchaus m√∂glich, NON-FUN zu machen <br>  Im Zusammenhang mit dem oben Gesagten fassen wir zusammen: <br><blockquote><h4>  Vorteile </h4><br><ul><li>  Die √úberschrift des Herstellers wird verwendet (es wird gepr√ºft, es gibt keine Fehler) </li><li>  Es gibt keine zus√§tzlichen Gesten und Kosten, die Sie nehmen und verwenden </li><li>  Benutzerfreundlichkeit </li><li>  Jeder kennt und versteht diese Methode. </li><li>  Kein Overhead </li></ul><br><h4>  Nachteile </h4><br><ul><li>  Eingeschr√§nkte Verwendung von Metaprogrammierung </li><li>  Unf√§higkeit zur Verwendung in constexpr-Konstruktoren </li><li>  Bei Verwendung von Wrappern in Klassen ist der zus√§tzliche RAM-Verbrauch ein Zeiger auf ein Objekt dieser Struktur </li><li>  Du kannst dumm machen </li></ul></blockquote>  Schauen wir uns nun Methode 2 an <br><br><h3>  Methode 2. Brutal </h3><br>  Es ist offensichtlich, dass jeder Embed-Programmierer die Adressen aller Register f√ºr alle Mikrocontroller ber√ºcksichtigt, sodass Sie einfach immer die folgende Methode verwenden k√∂nnen, die von Anfang an folgt: <br><br><pre> <code class="cpp hljs">*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaOdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaIdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  √úberall im Programm k√∂nnen Sie jederzeit die Konvertierung in die <code>volatile uint32_t</code> Registeradresse <code>volatile uint32_t</code> aufrufen und dort zumindest etwas installieren. <br>  Hier gibt es insbesondere keine Pluspunkte, aber zu den Minuspunkten, die zu zus√§tzlichen Unannehmlichkeiten und der Notwendigkeit f√ºhren, die Adresse jedes Registers selbst in eine separate Datei zu schreiben.  Daher wenden wir uns der Methode Nummer 3 zu. <br><br><h3>  Methode 3. Offensichtlich und offensichtlich korrekter </h3><br>  Wenn der Zugriff auf die Register √ºber das Strukturfeld erfolgt, k√∂nnen Sie anstelle eines Zeigers auf das Strukturobjekt die ganzzahlige Strukturadresse verwenden.  Die Adresse der Strukturen befindet sich in der Header-Datei des Herstellers (z. B. GPIOA_BASE f√ºr GPIOA). Sie m√ºssen sich diese also nicht merken, k√∂nnen sie jedoch in Vorlagen und in constexpr-Ausdr√ºcken verwenden und die Struktur dann mit dieser Adresse "√ºberlagern". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Registers = GPIO_TypeDef ; __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     addr Registers *GpioPort{reinterpret_cast&lt;Registers*&gt;(addr)}; GpioPort-&gt;ODR ^= (1 &lt;&lt; pinNum) ; } }; int main() { using Led1 = Pin&lt;GPIOA_BASE, 5&gt; ; Led1::Toggle() ; }</span></span></code> </pre><br>  Aus meiner Sicht gibt es keine besonderen Minuspunkte.  Im Prinzip eine funktionierende Option.  Aber schauen wir uns doch andere M√∂glichkeiten an. <br><br><h3>  Methode 4. Exoteric Wrap </h3><br>  F√ºr Kenner von verst√§ndlichem Code k√∂nnen Sie einen Wrapper √ºber das Register erstellen, damit Sie bequem darauf zugreifen k√∂nnen und ‚Äûsch√∂n‚Äú aussehen. Erstellen Sie einen Konstruktor und definieren Sie die Operatoren neu: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> : ptr</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) } { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; <span class="hljs-comment"><span class="hljs-comment">//    }; int main() { Register Odr{GpioaOdrAddr}; Odr ^= (1 &lt;&lt; 5); Register Idr{GpioaIdrAddr}; Idr ^= (1 &lt;&lt; 5); // }</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, m√ºssen Sie sich entweder die Ganzzahladressen aller Register merken oder sie irgendwo setzen, und Sie m√ºssen auch einen Zeiger auf die Registeradresse speichern.  Aber was wieder nicht sehr gut ist, <code>reinterpret_cast</code> passiert wieder im Konstruktor <br>  Einige Nachteile und die Tatsache, dass in der ersten und zweiten Version die Notwendigkeit hinzugef√ºgt wurde, dass jedes verwendete Register einen Zeiger auf 4 Bytes im RAM speichert.  Im Allgemeinen keine Option.  Wir schauen uns Folgendes an. <br><br><h3>  Methode 4,5.  Exoteric Wrap mit Muster </h3><br>  Wir f√ºgen ein K√∂rnchen Metaprogrammierung hinzu, aber es gibt nicht viel Nutzen daraus.  Diese Methode unterscheidet sich von der vorherigen nur dadurch, dass die Adresse nicht an den Konstruktor √ºbertragen wird. Im Vorlagenparameter sparen wir jedoch ein wenig an Registern, wenn wir die Adresse an den Konstruktor √ºbergeben. Es ist bereits gut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Register() : ptr{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr)} { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  Und so der gleiche Rechen, Seitenansicht. <br><br><h3>  Methode 5. Vern√ºnftig </h3><br>  Nat√ºrlich m√ºssen Sie den Zeiger entfernen, also machen wir dasselbe, aber entfernen Sie den unn√∂tigen Zeiger aus der Klasse. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  Sie k√∂nnen hier bleiben und ein wenig nachdenken.  Diese Methode l√∂st sofort zwei Probleme, die zuvor von der ersten Methode geerbt wurden.  Erstens kann ich jetzt den Zeiger auf das <code>Register</code> Objekt in der Vorlage verwenden, und zweitens kann ich ihn an den <code>constexrp</code> Konstruktor √ºbergeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Register * <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ^= mask ; } Register&lt;GpioaOdrAddr&gt; GpioaOdr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Xor&lt;&amp;GpioaOdr&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//  } //   struct Port { constexpr Port(Register&amp; ref): register(ref) {} Register &amp; register ; } constexpr Port portA{GpioaOdr};</span></span></code> </pre><br>  Nat√ºrlich ist es wieder notwendig, entweder einen eidetischen Speicher f√ºr die Adressen der Register zu haben oder alle Adressen der Register irgendwo in einer separaten Datei manuell zu bestimmen ... <br><blockquote><h4>  Vorteile </h4><br><ul><li>  Benutzerfreundlichkeit </li><li>  F√§higkeit zur Verwendung von Metaprogrammierung </li><li>  F√§higkeit zur Verwendung in constexpr-Konstruktoren </li></ul><br><h4>  Nachteile </h4><br><ul><li>  Die √ºberpr√ºfte Header-Datei des Herstellers wird nicht verwendet </li><li>  Sie m√ºssen alle Adressen der Register selbst einstellen </li><li>  Sie m√ºssen ein Objekt der Klasse Register erstellen </li><li>  Du kannst dumm machen </li></ul></blockquote><br>  Gro√üartig, aber es gibt immer noch viele Minuspunkte ... <br><br><h3>  Methode 6. Kl√ºger als vern√ºnftig </h3><br>  Bei der vorherigen Methode war es f√ºr den Zugriff auf das Register erforderlich, ein Objekt dieses Registers zu erstellen. Dies ist eine unn√∂tige Verschwendung von RAM und ROM. Daher erstellen wir einen Wrapper mit statischen Methoden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= mask; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case6 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;GpioaOdrAddr&gt;; Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;GpioaIdrAddr&gt;; Idr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  Ein Plus hinzugef√ºgt <br><blockquote><ul><li>  Kein Overhead.  Schneller kompakter Code, wie in Option 1 (Bei Verwendung von Wrappern in Klassen fallen keine zus√§tzlichen RAM-Kosten an, da das Objekt nicht erstellt wird, sondern statische Methoden verwendet werden, ohne Objekte zu erstellen.) </li></ul></blockquote>  Mach weiter ... <br><br><h3>  Methode 7. Dummheit entfernen </h3><br>  Offensichtlich mache ich st√§ndig NON-FUNNY im Code und schreibe etwas in das Register, das eigentlich nicht zum Schreiben gedacht ist.  Es ist nat√ºrlich okay, aber DUMM muss verboten werden.  Verbieten wir Unsinn.  Dazu f√ºhren wir Hilfsstrukturen ein: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {};</code> </pre> <br>  Jetzt k√∂nnen wir die Register zum Schreiben einstellen und die Register sind schreibgesch√ºtzt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegisterType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//       WriteReg,    // ,  ,       __forceinline template &lt;typename T = RegisterType, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteReg, T&gt;::value&gt;&gt; Register &amp;operator^=(const uint32_t right) { *reinterpret_cast&lt;volatile uint32_t *&gt;(addr) ^= right; return *this; } };</span></span></code> </pre><br>  Versuchen wir nun, unseren Test zu kompilieren und <code>Idr</code> dass der Test nicht kompiliert wird, da der Operator <code>^=</code> f√ºr das <code>Idr</code> Register nicht vorhanden ist: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr Odr ; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr Idr ; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre> <br>  Also, jetzt gibt es mehr Pluspunkte ... <br><blockquote><h4>  Vorteile </h4><br><ul><li>  Benutzerfreundlichkeit </li><li>  F√§higkeit zur Verwendung von Metaprogrammierung </li><li>  F√§higkeit zur Verwendung in constexpr-Konstruktoren </li><li>  Schneller kompakter Code, wie in Option 1 </li><li>  Bei der Verwendung von Wrappern in Klassen fallen keine zus√§tzlichen RAM-Kosten an, da das Objekt nicht erstellt wird, sondern statische Methoden verwendet werden, ohne Objekte zu erstellen </li><li>  Dummheit kann man nicht machen </li></ul><br><h4>  Nachteile </h4><br><ul><li>  Die √ºberpr√ºfte Header-Datei des Herstellers wird nicht verwendet </li><li>  Sie m√ºssen alle Adressen der Register selbst einstellen </li><li>  Sie m√ºssen ein Objekt der Klasse Register erstellen </li></ul></blockquote><br>  Entfernen wir also die M√∂glichkeit, eine Klasse zu erstellen, um mehr zu sparen <br><br><h3>  Methode 8. Ohne Unsinn und ohne Klassenobjekt </h3><br>  Sofort Code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre><br>  Wir f√ºgen ein weiteres Plus hinzu, wir erstellen kein Objekt.  Aber mach weiter, wir haben immer noch Nachteile <br><br><h3>  Methode 9. Methode 8 mit Strukturintegration </h3><br>  In der vorherigen Methode wurde nur der Fall definiert.  Bei Methode 1 werden jedoch alle Register zu Strukturen zusammengefasst, sodass Sie bequem √ºber Module darauf zugreifen k√∂nnen.  Lass es uns tun ... <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case9 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, ReadWriteReg&gt;; <span class="hljs-comment"><span class="hljs-comment">//      using Otyper = Register&lt;addr + OtyperShift, ReadWriteReg&gt; ; using Ospeedr = Register&lt;addr + OspeedrShift,ReadWriteReg&gt; ; using Pupdr = Register&lt;addr + PupdrShift,ReadWriteReg&gt; ; using Idr = Register&lt;addr + IdrShift, ReadReg&gt; ; using Odr = Register&lt;addr + OdrShift, WriteReg&gt; ; }; int main() { using Gpioa = Gpio&lt;GPIOA_BASE&gt; ; Gpioa::Odr::Xor(1 &lt;&lt; 5) ; Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr    }</span></span></code> </pre><br>  Hier ist das Minus, dass die Strukturen neu registriert werden m√ºssen und die Offsets aller Register irgendwo gespeichert und bestimmt werden sollten.  Es w√§re sch√∂n, wenn die Offsets vom Compiler und nicht von der Person festgelegt w√ºrden, aber dies ist sp√§ter, aber im Moment werden wir eine andere interessante Methode betrachten, die mein Kollege vorgeschlagen hat. <br><br><h3>  Methode 10. Wrap √ºber das Register durch einen Zeiger auf ein Mitglied der Struktur </h3><br>  Hier verwenden wir ein solches Konzept als Zeiger auf ein Mitglied der Struktur und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zugriff darauf</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterStructWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PT::*member, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; <span class="hljs-comment"><span class="hljs-comment">//   ,     . } } ; using GpioaWrapper = RegisterStructWrapper&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; int main() { GpioaWrapper::Xor(&amp;GPIO_TypeDef::ODR, (1 &lt;&lt; 5)) ; GpioaWrapper::Xor(&amp;GPIO_TypeDef::IDR, (1 &lt;&lt; 5)) ; // return 0 ; }</span></span></code> </pre><br><blockquote><h4>  Vorteile </h4><br><ul><li>  Benutzerfreundlichkeit </li><li>  F√§higkeit zur Verwendung von Metaprogrammierung </li><li>  F√§higkeit zur Verwendung in constexpr-Konstruktoren </li><li>  Schneller kompakter Code, wie in Option 1 </li><li>  Bei der Verwendung von Wrappern in Klassen fallen keine zus√§tzlichen RAM-Kosten an, da das Objekt nicht erstellt wird, sondern statische Methoden verwendet werden, ohne Objekte zu erstellen </li><li>  Die vom Hersteller √ºberpr√ºfte Header-Datei wird verwendet. </li><li>  Sie m√ºssen nicht alle Registeradressen selbst festlegen </li><li>  Es ist nicht erforderlich, ein Objekt der Klasse Register zu erstellen </li></ul><br><h4>  Nachteile </h4><br><ul><li>  Sie k√∂nnen Dummheit machen und sogar √ºber die Verst√§ndlichkeit des Codes spekulieren. </li></ul></blockquote><br><h3>  Methode 10.5.  Kombinieren Sie Methode 9 und 10 </h3><br>  Um die Verschiebung des Registers relativ zum Anfang der Struktur herauszufinden, k√∂nnen Sie den Zeiger auf das Mitglied der Struktur verwenden: <code>volatile uint32_t T::*member</code> gibt den Offset des Mitglieds der Struktur relativ zu seinem Anfang in Bytes zur√ºck.  Zum Beispiel haben wir die <code>GPIO_TypeDef</code> Struktur, dann ist die Adresse <code>&amp;GPIO_TypeDef::ODR</code> 0x14. <br>  Wir nutzen diese Gelegenheit und berechnen die Adressen der Register aus Methode 9 mit dem Compiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> T::*member, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = RegType, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Otyper = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OTYPER, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ospeedr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OSPEEDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pupdr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::PUPDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::IDR, ReadReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, WriteReg&gt;; } ;</code> </pre> <br>  Sie k√∂nnen exoterischer mit Registern arbeiten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case11 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Gpioa = Gpio&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; Gpioa::Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr   </span></span></code> </pre> <br>  Nat√ºrlich m√ºssen hier alle Strukturen neu geschrieben werden.  Dies kann automatisch durch ein Skript in Phyton an der Eingabe wie stm32f411xe.h an der Ausgabe Ihrer Datei mit Strukturen zur Verwendung in C ++ erfolgen. <br>  In jedem Fall gibt es verschiedene M√∂glichkeiten, die in einem bestimmten Projekt funktionieren k√∂nnen. <br><br><h3>  Bonus  Wir f√ºhren die Spracherweiterung und den Parsim-Code mit Phyton ein </h3><br>  Das Problem der Arbeit mit Registern in C ++ besteht schon seit geraumer Zeit.  Die Leute l√∂sen es auf unterschiedliche Weise.  Nat√ºrlich w√§re es gro√üartig, wenn die Sprache beim Kompilieren so etwas wie das Umbenennen von Klassen unterst√ºtzen w√ºrde.  Sagen wir mal, was w√§re, wenn es so w√§re: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;classname = [PortName]&gt; class Gpio[Portname] { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { GPIO[PortName]-&gt;ODR ^= mask ; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioA = Gpio&lt;<span class="hljs-string"><span class="hljs-string">"A"</span></span>&gt; ; GpioA::Xor(<span class="hljs-number"><span class="hljs-number">5</span></span>) ; }</code> </pre><br>  Leider unterst√ºtzt diese Sprache nicht.  Daher besteht die L√∂sung darin, Code mit Python zu analysieren.  Das hei√üt,  Einige Spracherweiterungen werden eingef√ºhrt.  Der Code, der diese Erweiterung verwendet, wird dem Python-Parser zugef√ºhrt, der ihn in C ++ - Code √ºbersetzt.  Ein solcher Code sieht ungef√§hr so ‚Äã‚Äãaus: (Ein Beispiel stammt aus der Modm-Bibliothek; <a href="">hier sind die vollst√§ndigen Quellen</a> ): <br><br><pre> <code class="cpp hljs">%% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> port = gpio[<span class="hljs-string"><span class="hljs-string">"port"</span></span>] | upper %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> reg = <span class="hljs-string"><span class="hljs-string">"GPIO"</span></span> ~ port %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> pin = gpio[<span class="hljs-string"><span class="hljs-string">"pin"</span></span>] class Gpio{{ port ~ pin }} : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Gpio { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor() { GPIO{{port}}-&gt;ODR ^= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; {{pin}} ; } } <span class="hljs-comment"><span class="hljs-comment">//        class Gpio5 : public Gpio { __forceinline inline static void Xor() { GPIO-&gt;ODR ^= 1 &lt;&lt; 5 ; } } //     using Led = Gpio5; Led::Xor();</span></span></code> </pre><br><br><h3>  Update: Bonus.  SVD-Dateien und Parser auf Phyton </h3><br>  Ich habe vergessen, eine weitere Option hinzuzuf√ºgen.  ARM ver√∂ffentlicht f√ºr jeden SVD-Hersteller eine Registerbeschreibungsdatei.  Daraus k√∂nnen Sie dann eine C ++ - Datei mit einer Beschreibung der Register generieren.  Paul Osborne hat alle diese Dateien auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub zusammengestellt</a> .  Er schrieb auch ein Python-Skript, um sie zu analysieren. <br><br>  Das ist alles ... meine Fantasie ist ersch√∂pft.  Wenn Sie noch Ideen haben, wenden Sie sich bitte an.  Hier liegt ein Beispiel mit allen Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> <br><br><h4>  Referenzen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typesicherer Registerzugriff in C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dinge erledigen lassen - Zugriff auf Hardware aus C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dinge dazu bringen, Dinge zu tun - Teil 3</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dinge dazu bringen, Dinge zu tun - Struktur√ºberlagerung</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459204/">https://habr.com/ru/post/de459204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459184/index.html">Grundlegende Einheitsf√§higkeiten</a></li>
<li><a href="../de459188/index.html">Debian 10 Buster und Linux 5.2 ver√∂ffentlicht</a></li>
<li><a href="../de459194/index.html">Wie wir SCSS-Freunde mit CSS-Variablen mithilfe des UI-Kit-Themas gefunden haben</a></li>
<li><a href="../de459196/index.html">Von Monolithen zu modularen Teams</a></li>
<li><a href="../de459198/index.html">Abfrageleistungsanalyse in ClickHouse. Yandex-Bericht</a></li>
<li><a href="../de459206/index.html">9 Jahre in einem Monolithen bei Node.JS</a></li>
<li><a href="../de459208/index.html">Laufen mit Prothesen: Nekstgen-Simulation der menschlichen Bewegung mit Muskeln, Knochen und einem neuronalen Netzwerk</a></li>
<li><a href="../de459212/index.html">Eigenschaftsimplementierung in C ++</a></li>
<li><a href="../de459214/index.html">Fehlertoleranz im Qsan-Speicher</a></li>
<li><a href="../de459216/index.html">B-Baum-Datenstruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>