<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 🚉 👩‍🎤 Toute la vérité sur Linux Epoll 👨🏻‍🎤 🤷🏼 🙎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eh bien, ou presque tous ... 





 Je crois que le problème sur l'Internet moderne est une surabondance d'informations de qualité différente. Trouver...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur Linux Epoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p>  Eh bien, ou presque tous ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p>  Je crois que le problème sur l'Internet moderne est une surabondance d'informations de qualité différente.  Trouver du matériel sur un sujet d'intérêt n'est pas un problème; le problème est de distinguer le bon matériel du mauvais matériel si vous avez peu d'expérience dans ce domaine.  J'observe une image quand il y a beaucoup d'informations de synthèse "au sommet" (presque au niveau d'une simple énumération), très peu d'articles approfondis et pas d'articles de transition du simple au complexe.  Néanmoins, c'est la connaissance des caractéristiques d'un mécanisme particulier qui nous permet de faire un choix éclairé lors du développement. </p><br><p>  Dans l'article, j'essaierai de révéler quelle est la différence fondamentale entre <strong>epoll</strong> et d'autres mécanismes, ce qui le rend unique, ainsi que de citer des articles que vous avez juste besoin de lire pour mieux comprendre les possibilités et les problèmes d' <strong>epoll</strong> . </p><br><blockquote> Tout le monde peut manier une hache, mais il faut un vrai guerrier pour lui faire chanter la mélodie de mêlée. </blockquote><p>  Je suppose que le lecteur connaît bien <strong>epoll</strong> , au moins lisez la page de manuel.  On en a assez écrit sur <strong>epoll</strong> , <strong>poll</strong> , <strong>select</strong> pour que tous ceux qui développent sous Linux en aient entendu parler au moins une fois. </p><a name="habracut"></a><br><h1 id="mnoga--fd">  Beaucoup de fd </h1><br><p>  Lorsque les gens parlent d' <strong>epoll,</strong> j'entends essentiellement la thèse selon laquelle «ses performances sont meilleures quand il y a beaucoup de descripteurs de fichiers». </p><br><p>  Je veux juste poser une question - combien coûte combien?  Combien de connexions sont nécessaires et, surtout, dans quelles conditions <strong>epoll</strong> commencera-t-il à apporter des gains de performances tangibles? </p><br><p>  Pour ceux qui ont étudié <strong>epoll</strong> (il y a beaucoup de matériel, y compris des articles scientifiques), la réponse est évidente - il vaut mieux si et seulement si le nombre de composés "en attente d'un événement" dépasse considérablement le nombre de "prêts pour le traitement".  La marque de la quantité, lorsque le gain devient si important qu'il n'y a tout simplement pas d'urine pour ignorer ce fait, les composés 10k sont considérés [4]. </p><br><p>  L'hypothèse selon laquelle la plupart des connexions seront en attente provient de la logique sonore et de la surveillance de la charge des serveurs en cours d'utilisation. </p><br><p>  Si le nombre de composés actifs vise le nombre total, <del>  il n'y aura aucun gain </del>  il n'y aura pas de gain significatif, un gain significatif est dû et uniquement au fait que <strong>epoll</strong> ne retourne que les descripteurs nécessitant une attention, et <strong>poll</strong> renvoie tous les descripteurs qui ont été ajoutés pour observation. </p><br><p>  Évidemment, dans ce dernier cas, nous passons du temps à parcourir tous les descripteurs + les frais généraux de copie d'un tableau d'événements à partir du noyau. </p><br><p>  En effet, dans la mesure de performance initiale, qui était attachée au patch [9], ce point n'est pas souligné et on ne peut que le deviner par la présence de l'utilitaire deadcon mentionné dans l'article (malheureusement, le code de l'utilitaire pipetest.c est perdu).  En revanche, dans d'autres sources [6, 8], il est très difficile de ne pas le remarquer, car ce fait se prolonge pratiquement. </p><br><p>  La question se pose immédiatement, mais que se passe-t-il maintenant s'il n'est pas prévu de desservir un tel nombre de descripteurs de fichiers <strong>epoll</strong> , pour ainsi dire, et n'est pas nécessaire? </p><br><p>  Malgré le fait <strong>qu'epoll ait</strong> été initialement créé spécifiquement pour de telles situations [5, 8, 9], c'est loin d'être la seule différence entre <strong>epoll</strong> . </p><br><h1 id="epollet">  EPOLLET </h1><br><p>  Pour commencer, nous allons examiner la différence entre les déclencheurs déclenchés par front et les déclencheurs déclenchés par niveau. Il y a une très bonne déclaration à ce sujet dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interruptions déclenchées par niveau déclenchées contre Edge déclenchées - Venkatesh Yadav</a> : </p><br><blockquote>  Interruption de niveau, c'est comme un enfant.  Si le bébé pleure, vous devez abandonner tout ce que vous avez fait et courir vers le bébé pour le nourrir.  Ensuite, vous remettez le bébé dans le berceau.  S'il pleure encore, vous ne le laisserez nulle part, mais vous essayerez de le calmer.  Et pendant que l'enfant pleure, vous ne le quitterez pas un instant, et vous ne retournerez au travail que lorsqu'il se calmera.  Mais disons que nous sommes sortis dans le jardin (interruption désactivée) lorsque l'enfant a commencé à pleurer, puis lorsque vous êtes rentré chez vous (interruption activée) la première chose que vous faites est d'aller voir l'enfant.  Mais vous ne saurez jamais qu'il pleurait pendant que vous étiez dans le jardin. <br><br>  L'interruption sur le devant est comme une nounou électronique pour parents sourds.  Dès que l'enfant commence à pleurer sur l'appareil, un voyant rouge s'allume et s'allume jusqu'à ce que vous appuyiez sur le bouton.  Même si l'enfant a commencé à pleurer, mais s'est rapidement arrêté et s'est endormi, vous saurez toujours que l'enfant pleurait.  Mais s'il a commencé à pleurer et que vous avez appuyé sur le bouton (confirmation de l'interruption), la lumière ne s'allumera pas même s'il continue de pleurer.  Le niveau sonore dans la pièce doit baisser puis remonter pour que la lumière s'allume. </blockquote><p>  Si l' <strong>epoll</strong> (ainsi que <strong>poll</strong> / <strong>select</strong> ) est déverrouillé dans le comportement déclenché par le niveau si le descripteur est dans l'état spécifié et sera considéré comme actif jusqu'à ce que cet état soit effacé, le déclenchement sur front est déverrouillé uniquement en changeant l'état ordonné donné actuel. </p><br><p>  Cela vous permet de gérer l'événement plus tard, et pas immédiatement après sa réception (presque une analogie directe avec la moitié supérieure et la moitié inférieure du gestionnaire d'interruption). </p><br><p>  Exemple spécifique avec epoll: </p><br><p>  Niveau déclenché </p><br><ul><li>  poignée ajoutée à <strong>epoll</strong> avec drapeau <strong>EPOLLIN</strong> </li><li>  <strong>epoll_wait ()</strong> bloque en attendant un événement </li><li>  écrire dans le descripteur de fichier 19 octets </li><li>  <strong>epoll_wait () se</strong> déverrouille avec l'événement <strong>EPOLLIN</strong> </li><li>  nous ne faisons rien avec les données qui sont venues </li><li>  <strong>epoll_wait () se</strong> déverrouille à nouveau avec l'événement <strong>EPOLLIN</strong> </li></ul><br><p>  Et cela continuera jusqu'à ce que nous comptions ou réinitialisions complètement les données du descripteur. </p><br><p>  Déclenchement sur front </p><br><ul><li>  nouvelle poignée ajoutée à <strong>epoll</strong> avec les drapeaux <strong>EPOLLIN |</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait ()</strong> bloque en attendant un événement </li><li>  écrire dans le descripteur de fichier 19 octets </li><li>  <strong>epoll_wait () se</strong> déverrouille avec l'événement <strong>EPOLLIN</strong> </li><li>  nous ne faisons rien avec les données qui sont venues </li><li>  <strong>epoll_wait () est</strong> bloqué en attendant un nouvel événement </li><li>  écrire encore 19 octets dans le descripteur de fichier </li><li>  <strong>epoll_wait () se</strong> déverrouille avec le nouvel événement <strong>EPOLLIN</strong> </li><li>  <strong>epoll_wait () est</strong> bloqué en attendant un nouvel événement </li></ul><br><p>  exemple simple: <a href="">epollet_socket.c</a> </p><br><p>  Ce mécanisme est <strong>conçu</strong> pour empêcher le retour de <strong>epoll_wait () en</strong> raison d'un événement qui est déjà en cours de traitement. </p><br><p>  Si, dans le cas du niveau, lors de l'appel à <strong>epoll_wait (), le</strong> noyau vérifie si fd est dans cet état, alors edge saute cette vérification et met immédiatement le processus appelant en état de veille. </p><br><p>  <strong>EPOLLET lui</strong> - <strong>même</strong> est ce qui fait d' <strong>epoll</strong> O (1) un multiplexeur d'événements. </p><br><p>  Il est nécessaire d'expliquer <strong>EAGAIN</strong> et <strong>EPOLLET</strong> - la recommandation avec <strong>EAGAIN n'est</strong> pas de traiter le flux d'octets, le danger dans ce dernier cas ne survient que si vous n'avez pas lu le descripteur à la fin, et de nouvelles données ne sont pas arrivées.  Ensuite, la queue se bloque dans le descripteur, mais vous ne recevrez pas de nouvelle notification.  Avec <strong>accept (), la</strong> situation est juste différente, vous devez continuer jusqu'à ce que <strong>accept ()</strong> renvoie <strong>EAGAIN</strong> , seulement dans ce cas le bon fonctionnement est garanti. </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p>  Avec cette propriété, la famine suffit: </p><br><ul><li>  les paquets arrivent au descripteur </li><li>  lire les paquets dans le tampon </li><li>  un autre paquet vient </li><li>  lire les paquets dans le tampon </li><li>  vient une petite portion </li><li>  ... </li></ul><br><p>  Ainsi <strong>,</strong> nous ne recevrons pas <strong>EAGAIN</strong> prochainement, mais nous ne le recevrons peut-être pas du tout. </p><br><p>  Ainsi, d'autres descripteurs de fichiers ne reçoivent pas de temps pour le traitement, et nous sommes occupés à lire de petites portions de données qui arrivent constamment. </p><br><h1 id="thundering-nerd-herd">  tonnerre <del>  nerd </del>  troupeau </h1><br><p>  Pour passer au dernier indicateur, vous devez comprendre pourquoi il a été créé et l'un des problèmes rencontrés par les développeurs avec l'évolution de la technologie et des logiciels. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://en.wikipedia.org/wiki/">Problème de troupeau tonnerre</a> </p><br><blockquote>  Problème de troupeau de tonnerre <br><br>  Imaginez un grand nombre de processus en attente d'un événement.  Si un événement se produit, ils seront réveillés et la lutte pour les ressources commencera, bien qu'un seul processus soit nécessaire pour gérer le traitement ultérieur de l'événement.  Le reste des processus dormira à nouveau. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terminologie informatique - Vasily Alekseenko</a> </blockquote><p>  Dans ce cas, nous nous intéressons au problème de l' <strong>acceptation ()</strong> et de la <strong>lecture ()</strong> distribuées sur les flux conjointement avec <strong>epoll</strong> . </p><br><h1 id="accept">  accepter </h1><br><p>  En fait, avec un appel bloquant pour <strong>accepter (),</strong> il n'y a pas eu de problème depuis longtemps.  Le noyau veillera à ce qu'un seul processus ait été déverrouillé pour cet événement et que toutes les connexions entrantes soient sérialisées. </p><br><p>  Mais avec <strong>epoll,</strong> une telle astuce ne fonctionnera pas.  Si nous avons <strong>écouté ()</strong> sur une socket non bloquante, lorsque la connexion est établie, tous les <strong>epoll_wait () attendront</strong> l'événement de ce descripteur. </p><br><p>  Bien sûr, <strong>accept ()</strong> ne pourra faire qu'un seul thread, les autres recevront <strong>EAGAIN</strong> , mais c'est un gaspillage de ressources. </p><br><p>  De plus, <strong>EPOLLET</strong> ne nous aide pas non plus, car nous ne savons pas exactement combien de connexions se trouvent dans la file d'attente de connexions ( <strong>backlog</strong> ).  Comme nous nous en souvenons, lorsque vous utilisez <strong>EPOLLET</strong> , le traitement des sockets doit continuer jusqu'à ce qu'il revienne avec le <strong>code d'</strong> erreur <strong>EAGAIN</strong> , il y a donc une chance que tous <strong>accept ()</strong> soient traités par un seul thread et que les autres ne fonctionnent pas. </p><br><p>  Et cela nous conduit à nouveau à une situation où le ruisseau voisin a été réveillé en vain. </p><br><p>  Nous pouvons également obtenir un autre type de famine - nous n'aurons qu'un seul thread chargé, et le reste ne recevra pas de connexions pour le traitement. </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p>  Avant la version 4.5, la seule façon correcte de traiter le <strong>epoll</strong> distribué en un descripteur <strong>listen ()</strong> non bloquant avec le prochain appel <strong>accept ()</strong> était de définir l'indicateur <strong>EPOLLONESHOT</strong> , ce qui nous a conduit à nouveau à <strong>accepter ()</strong> uniquement en cours de traitement dans un thread à la fois. </p><br><p>  En bref - si <strong>EPOLLONESHOT est</strong> utilisé <strong>, l'</strong> événement associé à un descripteur particulier ne se déclenchera qu'une seule fois, après quoi il sera nécessaire de <strong>réarmer</strong> les drapeaux en utilisant <strong>epoll_ctl ()</strong> . </p><br><h1 id="epollexclusive">  EPOLLEXCLUSIVE </h1><br><p>  Ici <strong>EPOLLEXCLUSIVE</strong> et déclenché par niveau vient à notre aide. </p><br><p>  <strong>EPOLLEXCLUSIVE</strong> déverrouille un <strong>epoll_wait ()</strong> à la fois pour un événement. </p><br><p>  Le schéma est assez simple (en fait non): </p><br><ul><li>  Nous avons N threads en attente d'un événement de connexion </li><li>  Le premier client se connecte à nous </li><li>  Le thread 0 sera dispersé et commencera le traitement, les autres threads resteront bloqués </li><li>  Un deuxième client se connecte à nous, si le thread 0 est toujours occupé par le traitement, alors le thread 1 est déverrouillé </li><li>  Nous continuons jusqu'à ce que le pool de threads soit épuisé (personne ne s'attend à un événement sur <strong>epoll_wait ()</strong> ) </li><li>  Un autre client se connecte à nous </li><li>  Et son traitement recevra le premier thread, qui appellera <strong>epoll_wait ()</strong> </li><li>  Le deuxième thread recevra le deuxième client, qui appellera <strong>epoll_wait ()</strong> </li></ul><br><p>  Ainsi, toute la maintenance est répartie uniformément sur les flux. </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p>  exemple de code: <a href="">epollexclusive.c</a> (ne fonctionnera qu'avec la version du noyau à partir de 4.5) </p><br><p>  Nous obtenons un modèle de pré-fourche sur epoll.  Ce schéma est bien applicable pour les connexions TCP de <strong>courte durée</strong> . </p><br><h1 id="read">  lire </h1><br><p>  Mais avec <strong>read ()</strong> dans le cas du streaming d'octets, <strong>EPOLLEXCLUSIVE</strong> , comme <strong>EPOLLET,</strong> ne nous aidera pas. </p><br><p>  Pour des raisons évidentes, sans <strong>EPOLLEXCLUSIVE,</strong> nous ne pouvons pas utiliser du tout déclenché par niveau.  Avec <strong>EPOLLEXCLUSIVE,</strong> tout ne va pas mieux, car nous pouvons obtenir un package réparti sur les flux, en plus avec un ordre inconnu d'octets arrivés. </p><br><p>  Avec <strong>EPOLLET, la</strong> situation est la même. </p><br><p>  Et ici, <strong>EPOLLONESHOT</strong> avec réinitialisation à la fin des travaux sera la <strong>solution</strong> .  Ainsi, dès qu'un thread fonctionnera avec ce descripteur de fichier et ce tampon: </p><br><ul><li>  poignée ajoutée à <strong>epoll</strong> avec les drapeaux <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li><li>  en attente sur <strong>epoll_wait ()</strong> </li><li>  lire du socket au tampon jusqu'à ce que <strong>read ()</strong> renvoie <strong>EAGAIN</strong> </li><li>  réinitialiser avec les drapeaux <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p>  Cet article est peut-être le seul dans mon article mon IMHO personnel.  La possibilité d'utiliser un pointeur ou un nombre est utile.  Par exemple, l'utilisation d'un pointeur lors de l'utilisation d'epoll vous permet de faire une astuce comme celle-ci: </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p>  Je pense que tout le monde sait d'où vient cette technique. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  J'espère que nous avons pu ouvrir le sujet d' <strong>epoll</strong> .  Ceux qui veulent utiliser ce mécanisme consciemment, ont juste besoin de lire les articles de la liste de références [1, 2, 3, 5]. </p><br><p>  Sur la base de ce matériel (ou, mieux encore, en lisant attentivement les matériaux des références), vous pouvez créer un serveur pré-fork multi-thread (génération avancée du processus) sans verrouillage (sans blocage) ou réviser les stratégies existantes en fonction des propriétés spéciales d' <strong>epoll ()</strong> ). </p><br><p>  <strong>epoll est l'</strong> un des mécanismes uniques que les gens qui ont choisi leurs chemins de programmation Linux doivent connaître, car ils donnent un sérieux avantage sur les autres systèmes d'exploitation), et, peut-être, refuseront la multiplateforme pour un cas particulier (laissez-le fonctionner uniquement sous Linux mais le fera bien). </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi">  Raisonnement sur la "spécificité" du problème </h2><br><p>  Avant que quelqu'un ne parle de la spécificité de ces indicateurs et modèles d'utilisation, je veux poser une question: </p><br><p>  "Mais n'est-ce rien que nous essayons de discuter de la spécificité du mécanisme qui a été créé initialement pour des tâches spécifiques [9, 11]? Ou est-ce que nous entretenons même des connexions 1k est une tâche quotidienne pour un programmeur?" </p><br><p>  Je ne comprends pas le concept de «spécificité des tâches», cela me rappelle toutes sortes de cris sur l'utilité et la futilité des différentes disciplines enseignées.  En nous laissant ainsi raisonner, nous nous réservons le droit de décider pour autrui quelles informations leur sont utiles et lesquelles sont inutiles, tout en ne participant pas au processus éducatif dans son ensemble. </p><br><p>  Pour les sceptiques, quelques liens: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Augmentation des performances avec SO_REUSEPORT dans NGINX 1.9.1 - VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprendre de la licorne: le troupeau tonnerre accepte () sans problème - Chris Siebenmann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sérialisation accepter (), AKA Thundering Herd, AKA le problème Zeeg - Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment le mode EPOLLEXCLUSIVE d'epoll interagit-il avec le déclenchement de niveau?</a> </p><br><h1 id="spisok-literatury">  Les références </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Select est fondamentalement cassé - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Epoll est fondamentalement cassé 1/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Epoll est fondamentalement brisé 2/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le problème du C10K - Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Poll vs Epoll, encore une fois - Jacques Mattheij</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">epoll - Fonction de notification d'événements d'E / S - The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La méthode de la folie d'Epoll - Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks">  Repères </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://mvitolin.wordpress.com/2015/12/05/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  L'évolution d'Epoll </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum">  Postscript </h1><br><p>  Un grand merci à Sergey ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">dlinyj</a> ) et Peter Ovchenkov pour leurs précieuses discussions, commentaires et aide! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416669/">https://habr.com/ru/post/fr416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416657/index.html">Les deux tiers des cartes mémoire utilisées contiennent des données personnelles d'anciens propriétaires</a></li>
<li><a href="../fr416659/index.html">En raison de ce que le volume des paiements numériques pour l'économie des concerts atteindra 1,2 billion de dollars</a></li>
<li><a href="../fr416661/index.html">Quelles tendances devraient être prises en compte par les utilisateurs et les fournisseurs de services bancaires mobiles</a></li>
<li><a href="../fr416665/index.html">Réutilisation des bibliothèques Android privées avec Sonatype Nexus Repository OSS</a></li>
<li><a href="../fr416667/index.html">Insonoriser la poussière et le bruit de l'ancienne unité centrale</a></li>
<li><a href="../fr416673/index.html">Solution analytique pour manager</a></li>
<li><a href="../fr416677/index.html">Lunettes cyberpunk et miroir: reflets de la mode et de la culture</a></li>
<li><a href="../fr416679/index.html">Informatique périphérique: une concordance amicale du «brouillard» avec les «nuages»</a></li>
<li><a href="../fr416681/index.html">Comment de PostgreSQL et ClickHouse en Python beaucoup, rapidement et immédiatement en numpy</a></li>
<li><a href="../fr416683/index.html">Et ensuite? Ou comment choisir les fonctionnalités à développer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>