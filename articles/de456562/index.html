<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏼 🥥 💇🏼 Das Buch "Probabilistische Programmierung in Python: Bayesianische Inferenz und Algorithmen" 🗄️ 🤦🏾 👨‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Bayesianische Methoden erschrecken die Formeln vieler IT-Spezialisten, aber jetzt können Sie nicht mehr auf die Analyse von Statis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Probabilistische Programmierung in Python: Bayesianische Inferenz und Algorithmen"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456562/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/38/cw/he38cwwp66fmz66fhaixur-fogs.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Bayesianische Methoden erschrecken die Formeln vieler IT-Spezialisten, aber jetzt können Sie nicht mehr auf die Analyse von Statistiken und Wahrscheinlichkeiten verzichten.  Cameron Davidson-Pylon spricht über die Bayes'sche Methode aus der Sicht eines praktischen Programmierers, der mit der multifunktionalen PyMC-Sprache und den Bibliotheken NumPy, SciPy und Matplotlib arbeitet.  Wenn Sie die Rolle der Bayes'schen Schlussfolgerungen bei A / B-Tests aufdecken, Betrug und andere dringende Aufgaben identifizieren, werden Sie dieses nicht triviale Thema nicht nur leicht verstehen, sondern auch beginnen, das erworbene Wissen anzuwenden, um Ihre Ziele zu erreichen. <br><br><h3>  Auszug: 4.3.3.  Beispiel: Sortieren von Kommentaren zu Reddit </h3><br>  Vielleicht stimmen Sie nicht zu, dass das Gesetz der großen Zahlen von allen angewendet wird, wenn auch nur implizit, bei unbewussten Entscheidungen.  Betrachten Sie das Beispiel von Online-Produktbewertungen.  Vertrauen Sie oft einer durchschnittlichen Bewertung von fünf Punkten basierend auf einer Bewertung?  Zwei Bewertungen?  Drei Bewertungen?  Sie verstehen unbewusst, dass bei einer so geringen Anzahl von Bewertungen die durchschnittliche Bewertung nicht gut widerspiegelt, wie gut oder schlecht das Produkt ist. <br><a name="habracut"></a><br><br>  Infolgedessen gibt es Auslassungen beim Sortieren und im Allgemeinen beim Vergleichen von Waren.  Für viele Käufer ist es klar, dass das Sortieren der Ergebnisse einer interaktiven Suche nach Bewertungen nicht sehr objektiv ist. Es spielt keine Rolle, ob es sich um Bücher, Videos oder Kommentare im Internet handelt.  Oft erhalten Filme oder Kommentare an erster Stelle nur aufgrund einer geringen Anzahl begeisterter Fans gute Noten, und wirklich gute Filme oder Kommentare werden auf nachfolgenden Seiten mit angeblich unvollständigen Bewertungen von etwa 4,8 versteckt.  Was tun? <br><br>  Betrachten Sie die beliebte Website Reddit (ich biete absichtlich keine Links dazu an, da Reddit dafür berüchtigt ist, Benutzer anzulocken, und ich befürchte, dass Sie nie wieder zu meinem Buch zurückkehren werden).  Auf dieser Seite gibt es viele Links zu verschiedenen Geschichten und Bildern, und Kommentare zu diesen Links sind ebenfalls sehr beliebt.  Benutzer der Site (die normalerweise als das Wort redditor1 bezeichnet wird) können für oder gegen jeden Kommentar stimmen (die sogenannten Upvotes und Downvotes).  Reddit sortiert Kommentare standardmäßig in absteigender Reihenfolge.  Wie kann man feststellen, welche Kommentare die besten sind?  Sie konzentrieren sich normalerweise auf die folgenden verschiedenen Indikatoren. <br><br>  1. <i>Popularität</i> .  Ein Kommentar gilt als gut, wenn viele Stimmen abgegeben werden.  Probleme bei der Verwendung dieses Modells beginnen bei einem Kommentar mit Hunderten von Stimmen für und Tausenden von Gegenstimmen.  Obwohl dieser Kommentar sehr beliebt ist, scheint er zu vieldeutig, um als "bester" angesehen zu werden. <br><br>  2. <i>Der Unterschied</i> .  Sie können den Unterschied zwischen der Anzahl der Stimmen dafür und dagegen ausnutzen.  Dies löst das Problem, das bei der Verwendung der Metrik "Beliebtheit" auftritt, berücksichtigt jedoch nicht den temporären Charakter der Kommentare.  Kommentare können viele Stunden nach Veröffentlichung des ursprünglichen Links gesendet werden.  Gleichzeitig entsteht eine Voreingenommenheit, aufgrund derer die besten Kommentare überhaupt nicht die höchste Bewertung erhalten, sondern die ältesten, denen es gelungen ist, mehr Stimmen als neuere zu sammeln. <br><br>  3. <i>Korrektur für die Zeit</i> .  Stellen Sie sich eine Methode vor, bei der der Unterschied zwischen Vor- und Nachteilen durch das Alter des Kommentars geteilt wird und eine Häufigkeit ermittelt wird, z. B. der Unterschied pro Sekunde oder pro Minute.  Ein Gegenbeispiel fällt sofort ein: Wenn Sie die Option "pro Sekunde" verwenden, ist ein Kommentar, der vor einer Sekunde mit einer "Ja" -Stimme hinterlassen wurde, besser als vor 100 Sekunden mit 99 "Ja" -Stimmen.  Dieses Problem kann vermieden werden, wenn Sie nur Kommentare berücksichtigen, die vor mindestens t Sekunden hinterlassen wurden.  Aber wie wählt man einen guten Wert von t?  Bedeutet dies, dass alle Kommentare, die später als vor t Sekunden veröffentlicht wurden, schlecht sind?  Der Fall endet mit einem Vergleich instabiler Werte mit stabilen (neue und alte Kommentare). <br><br>  4. <i>Wert</i> .  Die Rangfolge der Kommentare zum Verhältnis der Anzahl der Stimmen zur Gesamtstimmenzahl.  Dieser Ansatz beseitigt das Problem mit der zeitlichen Natur von Kommentaren, sodass kürzlich veröffentlichte Kommentare mit guten Noten eine hohe Bewertung mit der gleichen Wahrscheinlichkeit erhalten wie die vor langer Zeit hinterlassenen, vorausgesetzt, sie haben ein relativ hohes Stimmenverhältnis zur Gesamtzahl der Stimmen.  Das Problem bei dieser Methode ist, dass ein Kommentar mit einer Stimme (Verhältnis = 1,0) besser ist als ein Kommentar mit 999 Stimmen und einer Gegenstimme (Verhältnis = 0,999), obwohl es offensichtlich ist, dass der zweite von diesen Kommentaren ist wahrscheinlich der beste. <br><br>  Ich habe aus einem bestimmten Grund <i>„eher“ geschrieben</i> .  Es kann sich herausstellen, dass der erste Kommentar mit einer einzigen Ja-Stimme mit 999 Ja-Stimmen wirklich besser ist als der zweite.  Es ist schwierig, dieser Aussage zuzustimmen, da wir nicht wissen, welche 999 potenziellen nächsten Stimmen für den ersten Kommentar vorliegen könnten.  Sagen wir, er könnte als Ergebnis von weiteren 999 Stimmen dafür und nicht eine einzige Gegenstimme erhalten und besser sein als die zweite, obwohl ein solches Szenario nicht sehr wahrscheinlich ist. <br><br>  Tatsächlich müssen wir das tatsächliche Stimmenverhältnis bewerten.  Ich stelle fest, dass dies keineswegs mit der beobachteten Korrelation der Stimmen dafür übereinstimmt;  Das tatsächliche Stimmenverhältnis ist ausgeblendet. Wir beobachten nur die Anzahl der Stimmen im Vergleich zu den Gegenstimmen (das tatsächliche Stimmenverhältnis kann als die Wahrscheinlichkeit angesehen werden, dass dieser Kommentar eine Ja-Stimme erhält, nicht eine Gegenstimme).  Dank des Gesetzes der großen Zahlen kann man mit Sicherheit sagen, dass in einem Kommentar mit 999 Ja-Stimmen und einer Gegenstimme das tatsächliche Stimmenverhältnis wahrscheinlich nahe bei 1 liegt. Andererseits sind wir viel weniger zuversichtlich, wie es ausgeht Das tatsächliche Stimmenverhältnis für den Kommentar mit einer Stimme dafür.  Dies scheint ein Bayes'sches Problem zu sein. <br><br>  Eine Möglichkeit, die a priori Verteilung der Ja-Stimmen zu bestimmen, besteht darin, die Geschichte der Verteilung der Ja-Stimmen zu untersuchen.  Dies kann erreicht werden, indem Reddit-Kommentare gelöscht und anschließend die Verteilung definiert werden.  Dieses Verfahren weist jedoch mehrere Nachteile auf. <br><br>  1. <i>Asymmetrische Daten</i> .  Die absolute Mehrheit der Kommentare hat eine sehr geringe Anzahl von Stimmen, wodurch die Verhältnisse vieler Kommentare nahezu extrem sind (siehe das „dreieckige“ Diagramm im Beispiel mit dem Kaggle-Datensatz in Abb. 4.4) und die Verteilung stark „verzerrt“ ist.  Sie können versuchen, nur Kommentare zu berücksichtigen, deren Stimmenzahl einen bestimmten Schwellenwert überschreitet.  Aber hier entstehen Schwierigkeiten.  Man muss nach einem Gleichgewicht zwischen der Anzahl der verfügbaren Kommentare einerseits und einem höheren Schwellenwert mit der entsprechenden Genauigkeit des Verhältnisses andererseits suchen. <br><br>  2. <i>Voreingenommene Daten (mit systematischen Fehlern)</i> .  Reddit besteht aus vielen Unterforen (Subreddits).  Zwei Beispiele: r / aww mit Bildern von lustigen Tieren und r / Politik.  Es ist mehr als wahrscheinlich, dass sich das Verhalten der Benutzer beim Kommentieren dieser beiden Reddit-Unterforen radikal unterscheidet: In dem ersten von ihnen werden Besucher höchstwahrscheinlich berührt und verhalten sich freundlich, was zu einer größeren Anzahl von Stimmen im Vergleich zum zweiten führt, in dem Meinungen abgegeben werden in den Kommentaren sind wahrscheinlich abweichend. <br><br>  In Anbetracht des Vorstehenden erscheint es mir sinnvoll, eine einheitliche A-priori-Verteilung zu verwenden. <br><br>  Jetzt können wir die hintere Verteilung des tatsächlichen Stimmenverhältnisses berechnen.  Das Skript comment_for_top_reddit_pic.py wird verwendet, um Kommentare aus dem derzeit beliebtesten Reddit-Bild zu entfernen.  Im folgenden Code haben wir Reddit-Kommentare zum Bild [3] <a href="">gelöscht</a> : <a href="">http://i.imgur.com/OYsHKlH.jpg.</a> <br><br><pre><code class="plaintext hljs">from IPython.core.display import Image #       %run #   i-   . %run top_pic_comments.py 2</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: Title of submission: Frozen mining truck http://i.imgur.com/OYsHKlH.jpg</code> </pre> </blockquote><br><pre> <code class="plaintext hljs">""" Contents:       Votes:   NumPy  ""  ""    """ n_comments = len(contents) comments = np.random.randint(n_comments, size=4) print "  (    %d) \n -----------"%n_comments for i in comments: print '"' + contents[i] + '"' print " ""/"": ",votes[i,:] print</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]:   (   77) ----------- "Do these trucks remind anyone else of Sly Cooper?"  ""/"": [2 0] "Dammit Elsa I told you not to drink and drive."  ""/"": [7 0] "I've seen this picture before in a Duratray (the dump box supplier) brochure..."  ""/"": [2 0] "Actually it does not look frozen just covered in a layer of wind packed snow."  ""/"": [120 18]</code> </pre> </blockquote><br>  Mit N Stimmen und einem gegebenen tatsächlichen Stimmenverhältnis „für“ p ähnelt die Anzahl der Stimmen „für“ einer binomischen Zufallsvariablen mit den Parametern p und N (Tatsache ist, dass das tatsächliche Stimmenverhältnis „für“ der Wahrscheinlichkeit entspricht, eine Stimme für „im Vergleich zur Stimme“ abzugeben. gegen ”mit N möglichen Stimmen / Versuchen).  Wir erstellen eine Funktion für die Bayes'sche Ableitung von p in Bezug auf die Stimmenmenge "für" / "gegen" einen bestimmten Kommentar. <br><br><pre> <code class="plaintext hljs">import pymc as pm def posterior_upvote_ratio(upvotes, downvotes, samples=20000): """         ""  "",   ,    ,    . ,    . """ N = upvotes + downvotes upvote_ratio = pm.Uniform("upvote_ratio", 0, 1) observations = pm.Binomial("obs", N, upvote_ratio, value=upvotes, observed=True) # ;    MAP,     #       . map_ = pm.MAP([upvote_ratio, observations]).fit() mcmc = pm.MCMC([upvote_ratio, observations]) mcmc.sample(samples, samples/4) return mcmc.trace("upvote_ratio")[:]</code> </pre> <br>  Das Folgende sind die resultierenden posterioren Verteilungen. <br><br><pre> <code class="plaintext hljs">figsize(11., 8) posteriors = [] colors = ["#348ABD", "#A60628", "#7A68A6", "#467821", "#CF4457"] for i in range(len(comments)): j = comments[i] label = u'(%d :%d )\n%s...'%(votes[j, 0], votes[j,1], contents[j][:50]) posteriors.append(posterior_upvote_ratio(votes[j, 0], votes[j,1])) plt.hist(posteriors[i], bins=18, normed=True, alpha=.9, histtype="step", color=colors[i%5], lw=3, label=label) plt.hist(posteriors[i], bins=18, normed=True, alpha=.2, histtype="stepfilled", color=colors[i], lw=3) plt.legend(loc="upper left") plt.xlim(0, 1) plt.ylabel(u"") plt.xlabel(u"  ''") plt.title(u"    '' \   ");</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: [****************100%******************] 20000 of 20000 complete</code> </pre> </blockquote><br>  Wie aus Abb.  4.5, einige Verteilungen sind stark "gequetscht", während andere relativ lange "Schwänze" haben, was zum Ausdruck bringt, dass wir nicht genau wissen, wofür das tatsächliche Stimmenverhältnis ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/vm/4v/_ovm4vt7lqlq9m7ikb6hrrfdjtm.png" alt="Bild"></div><br><h3>  4.3.4.  Sortieren </h3><br>  Bisher haben wir das Hauptziel unseres Beispiels ignoriert: Kommentare vom Besten zum Schlechtesten zu sortieren.  Natürlich ist es unmöglich, die Verteilungen zu sortieren;  Sortieren benötigen skalare Werte.  Es gibt viele Möglichkeiten, die Essenz der Verteilung in Form eines Skalars zu extrahieren.  Zum Beispiel kann das Wesen einer Verteilung in Form ihrer mathematischen Erwartung oder ihres Durchschnittswerts ausgedrückt werden.  Der Durchschnittswert hierfür ist jedoch nicht geeignet, da dieser Indikator die Unsicherheit der Verteilungen nicht berücksichtigt. <br><br>  Ich würde empfehlen, einen am wenigsten plausiblen Wert von 95% zu verwenden, der als Wert mit einer Wahrscheinlichkeit von nur 5% definiert ist, dass der tatsächliche Wert des Parameters darunter liegt (vgl. Die Untergrenze des Bayes'schen Konfidenzintervalls).  Als nächstes zeichnen wir die posterioren Verteilungen mit dem angegebenen Wert von 95% am wenigsten wahrscheinlich auf (Abb. 4.6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/t-/-5/fut--5kk2z6ddywqyx-efnblbxo.png" alt="Bild"></div><br><pre> <code class="plaintext hljs">N = posteriors[0].shape[0] lower_limits = [] for i in range(len(comments)): j = comments[i] label = '(%d :%d )\n%s…'%(votes[j, 0], votes[j,1], contents[j][:50]) plt.hist(posteriors[i], bins=20, normed=True, alpha=.9, histtype="step", color=colors[i], lw=3, label=label) plt.hist(posteriors[i], bins=20, normed=True, alpha=.2, histtype="stepfilled", color=colors[i], lw=3) v = np.sort(posteriors[i])[int(0.05*N)] plt.vlines(v, 0, 10 , color=colors[i], linestyles="—", linewidths=3) lower_limits.append(v) plt.legend(loc="upper left") plt.ylabel(u"") plt.xlabel(u"  ''") plt.title(u"    '' \   "); order = np.argsort(-np.array(lower_limits)) print order, lower_limits</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: [3 1 2 0] [0.36980613417267094, 0.68407203257290061, 0.37551825562169117, 0.8177566237850703]</code> </pre> </blockquote><br>  Das Beste sind nach unserem Verfahren diejenigen Kommentare, für die die höchste Wahrscheinlichkeit besteht, einen hohen Prozentsatz an Ja-Stimmen zu erhalten.  Visuell sind dies Kommentare, deren Wert dem zu 95% am wenigsten plausiblen Wert am nächsten kommt.  In Abb.  4.6 Der am wenigsten plausible Wert von 95% wird mit vertikalen Linien dargestellt. <br><br>  Warum ist das Sortieren nach dieser Metrik eine so gute Idee?  Das Sortieren nach dem zu 95% am wenigsten plausiblen Wert bedeutet maximale Vorsicht bei der Erklärung von Kommentaren als die besten.  Das heißt, selbst im schlimmsten Fall, wenn wir das Stimmenverhältnis stark überschätzen, ist garantiert, dass die besten Kommentare an der Spitze stehen.  Mit dieser Bestellung werden die folgenden sehr natürlichen Eigenschaften bereitgestellt. <br><br>  1. Von den beiden Kommentaren mit dem gleichen beobachteten Stimmenverhältnis „für“ wird der Kommentar mit der höheren Stimmenzahl als der beste anerkannt (da das Vertrauen in das höhere Stimmenverhältnis für ihn höher ist). <br><br>  2. Von den beiden Kommentaren mit der gleichen Anzahl von Stimmen gilt der beste als der Kommentar mit einer größeren Anzahl von Stimmen. <br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein für Händler - <b>JavaScript</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456562/">https://habr.com/ru/post/de456562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456542/index.html">Emoji in der iOS-App-Oberfläche und Apple-Anforderungen</a></li>
<li><a href="../de456544/index.html">Top 10 JavaScript Hack für optimierte Leistung</a></li>
<li><a href="../de456554/index.html">Tag der offenen Tür in der Netrologie „Profession Data Science“</a></li>
<li><a href="../de456556/index.html">Nginx-Rezepte: Grundautorisierung mit Captcha</a></li>
<li><a href="../de456558/index.html">Port-Scanner im persönlichen Konto von Rostelecom</a></li>
<li><a href="../de456564/index.html">Liste der Benutzer mit schwachen Passwörtern in MS SQL</a></li>
<li><a href="../de456568/index.html">Entwickler werden jetzt in Ansichten und Abonnenten gemessen - und das ist falsch</a></li>
<li><a href="../de456570/index.html">Diesen Freitag, den 21. Juni, jährt sich DevConfX, der 22. Juni, zum exklusiven Meisterkurs</a></li>
<li><a href="../de456574/index.html">Kabelfernsehnetze für die Kleinsten. Teil 10: Fehlerbehebung bei KTV-Netzwerken</a></li>
<li><a href="../de456578/index.html">VueJS-Konzepte für Backend-Entwickler - Meisterklasse 22. Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>