<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤢 🀄️ 👨‍💻 Die mathematischen Grundlagen des automatischen Layouts 👩🏼‍⚕️ 🤽🏼 ☸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Entwickler glauben, dass Auto Layout eine Bremse und ein Problem ist, und es ist äußerst schwierig, es zu debuggen. Und es ist gut, wenn diese S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die mathematischen Grundlagen des automatischen Layouts</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437584/">  Viele Entwickler glauben, dass Auto Layout eine Bremse und ein Problem ist, und es ist äußerst schwierig, es zu debuggen.  Und es ist gut, wenn diese Schlussfolgerung auf der Grundlage meiner eigenen Erfahrung gezogen wird, ansonsten ist es nur "Ich habe gehört, ich werde nicht einmal versuchen, mich mit ihm anzufreunden". <br><br>  Aber vielleicht liegt der Grund nicht draußen, sondern drinnen.  Zum Beispiel werden die gefährlichsten Vögel in der Welt des Kasuars Menschen nicht ohne Grund angreifen, sondern nur zur Selbstverteidigung.  Versuchen Sie daher für eine Sekunde anzunehmen, dass dies kein schlechtes automatisches Layout ist und Sie es nicht gut genug verstehen und nicht wissen, wie man kocht.  Dies hat Anton Sergejew getan und sich mit der Theorie befasst, um alles genau zu verstehen.  Wir erhalten einen vorgefertigten Überblick über die mathematischen Grundlagen des automatischen Layouts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xm/53/dw/xm53dwqnl0lczpswansphdrgbpi.png" width="360"></div><br><br><a name="habracut"></a><br>  Auto Layout ist ein <strong>Layoutsystem</strong> .  Bevor wir uns damit befassen, lassen Sie uns über den modernen Satz im Allgemeinen sprechen.  Dann beschäftigen wir uns mit dem <strong>automatischen Layout</strong> - wir werden herausfinden, <strong>welche Aufgabe es löst</strong> und wie es es macht.  Berücksichtigen Sie die <strong>Funktionen bei der Implementierung von Auto Layout in iOS</strong> und versuchen Sie, <strong>praktische Tipps</strong> zu entwickeln, die Ihnen bei der Arbeit helfen können. <br><br>  Diese Geschichte wird einem mathematischen Artikel sehr nahe kommen, daher einigen wir uns zunächst auf die Notation, um dieselbe Sprache zu sprechen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-eGciYD9i3I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Über den Sprecher:</strong> Anton Sergeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">antonsergeev88</a> ) arbeitet im Yandex.Mart-Team und befasst sich mit dem mobilen Client für Maps unter iOS.  Vor der mobilen Entwicklung beschäftigte er sich mit Kraftwerkssteuerungssystemen, bei denen die Kosten für Fehler im Code zu hoch sind, um toleriert zu werden. <br><br><h2>  Bezeichnungen <br></h2><br>  Die linearen Gleichungssysteme sind uns seit der Schule bekannt - sie sind durch eine geschweifte Klammer gekennzeichnet und ihre Lösung ist bereits ohne.  Außerdem haben lineare Gleichungssysteme Entitäten, die mit Einschränkungen für das automatische Layout arbeiten.  Sie sind durch eine gerade Linie gekennzeichnet. <br><br><img src="https://habrastorage.org/webt/ql/qb/sa/qlqbsasmt7hb37gbgal6han6-4c.png"><br><br>  Der seltsame und, wie wir bereits wissen, gefährliche Vogel wird nicht versehentlich in die obere Ecke der Rutsche gemalt.  Zu Ehren des Kasuars (lat. Cassowary), der natürlich in Australien lebt, ist in allen unseren iPhones ein Algorithmus benannt. <br><br>  Das automatische Layout hat seine eigenen Einschränkungen. Wir werden sie mit Farben in der Reihenfolge ihrer Priorität kennzeichnen: Rot - erforderlich;  gelb - hoch;  blau - niedrig. <br><br><h2>  Layout <br></h2><br>  Als ich die Präsentation zusammenstellte, platzierte ich verschiedene Elemente auf dem Bildschirm, zum Beispiel einen Kasuar.  Dazu habe ich festgestellt, dass der Kasuar ein rechteckiges Bild ist.  Sie müssen es auf einem Blatt anordnen, das Achsen und ein eigenes Koordinatensystem hat, und dafür habe ich die Koordinaten der oberen linken Ecke, Breite und Höhe bestimmt. <br><br><img src="https://habrastorage.org/webt/5s/rq/ci/5srqci-zsre1tg_nbnn3grczdno.png"><br><br>  Die Kenntnis dieser vier Werte reicht aus, um jede Ansicht darzustellen. <br><br><h3>  Algorithmus Nr. 1 <br></h3><br>  Während wir den Kasuar auf das Blatt legten, haben wir den ersten Layout-Algorithmus unauffällig beschrieben: <br><br><ul><li>  Bestimmen Sie die Koordinaten und Größen; </li><li>  Wenden Sie sie auf UIView an. </li></ul><br>  Der Algorithmus funktioniert, ist aber ziemlich schwierig zu verwenden, daher werden wir ihn weiter vereinfachen. <br><br>  Angenommen, unten ist eine Lösung für ein lineares Gleichungssystem. <br><br><img src="https://habrastorage.org/webt/ca/6i/ab/ca6iabqohj0bqr1rmujisor9fv4.png"><br><br>  Das System der linearen Gleichungen ist insofern besonders, als viele Operationen darüber definiert sind: Falten von Linien, Multiplizieren mit Konstanten usw.  Diese Operationen werden lineare Transformationen genannt, und mit ihrer Hilfe wird das System auf eine beliebige Form reduziert. <br><br>  Das Schöne an linearen Transformationen ist, dass sie reversibel sind.  Dies bringt uns zu einer interessanten und eher subtilen Idee, mit der das gesamte moderne Layout beginnt. <br><br>  Es soll eine Ansicht geben - ein Rechteck mit seinen Koordinaten und seiner Größe.  Wir wollen es so anordnen, dass das Zentrum mit dem gegebenen Punkt übereinstimmt.  Wir modellieren das Zentrum mit linearen Transformationen - der <strong>Koordinate der oberen linken Ecke + der halben Breite</strong> . <br><br><img src="https://habrastorage.org/webt/yg/el/ic/ygelic6e5xa6orhvnaz7g5p_cki.png"><br><br>  Wir haben das Zentrum durch lineare Transformation modelliert, es war nicht so: Es gab nur die Koordinaten des oberen linken Punktes, der Breite und der Höhe. <br><br>  Ebenso können Sie jede andere Einrückung simulieren, z. B. 20 Punkte von der rechten Ecke. <br><br><blockquote>  Es ist die Idee linearer Transformationen, die es uns ermöglicht, verschiedene Satzsysteme zu erstellen. <br></blockquote><br>  Betrachten Sie ein elementares Beispiel.  Wir schreiben ein System auf, mit dem wir die Koordinaten der mittleren und rechten Seite, die Breite und das Verhältnis zwischen Breite und Höhe festlegen.  Wir lösen das System und bekommen die Antwort. <br><br><img src="https://habrastorage.org/webt/hc/xc/hu/hcxchuyy2qvuvati_laj8afryig.png"><br><br>  Wir kommen also zum zweiten Algorithmus. <br><br><h3>  Algorithmus Nr. 2 <br></h3><br>  Die zweite Iteration des Algorithmus besteht aus folgenden Elementen: <br><br><ul><li>  ein lineares Gleichungssystem bilden; </li><li>  wir lösen es; </li><li>  Wenden Sie die Lösung auf UIView an. </li></ul><br>  Stellen Sie sich vor, wir befanden uns im 20. Jahrhundert, zu einer Zeit, als die Computerausrüstung noch in den Kinderschuhen steckte, und wir waren die ersten, die unser eigenes Layoutsystem entwickelten.  Erfunden, verpackt, dem Benutzer übergeben und er beginnt, es zu verwenden - füllt die Anfangsparameter aus und überträgt es auf unser System. <br><br><img src="https://habrastorage.org/webt/8b/np/wk/8bnpwkt2ufktqh1wa7dtumctozs.png"><br><br>  Es gibt ein Problem - dieses System hat keine einzige Lösung.  Das Problem ist nicht außergewöhnlich, absolut alle Layout-Systeme stoßen darauf und wird als <strong>Fehlen einer Lösung bezeichnet</strong> . <br><br>  Es gibt nicht so viele Auswege aus dieser Situation: <br><br><ul><li>  Sie können <strong>fallen</strong> - dies ist eine sehr häufige Methode.  Diejenigen, die mit MacOS arbeiten, wissen, dass NSLayoutConstraintManager genau das tut. </li><li>  <strong>Gibt den Standardwert zurück</strong> .  Im Kontext des Layouts können wir immer alle Nullen zurückgeben. </li><li>  Eine bekanntere und heikelere Methode besteht <strong>darin, falsche Eingaben zu verhindern</strong> .  Diese Methode wird von gängigen Layoutsystemen verwendet, z. B. <strong>Yoga</strong> , bekannt als <strong>Flex Layout</strong> .  Solche Systeme versuchen, eine Schnittstelle zu erstellen, die keine falschen Eingaben zulässt. </li><li>  Es gibt einen anderen Weg, um absolut alle Probleme zu lösen - <strong>alles von Anfang an</strong> zu <strong>überdenken</strong> und zunächst <strong>das Auftreten dieses Problems zu verhindern</strong> .  Auto Layout ging diesen Weg. </li></ul><br><h2>  Automatisches Layout  Erklärung und Lösung des Problems <br></h2><br>  Wir haben ein rechteckiges Bild und um es eindeutig zu identifizieren, benötigen wir 4 Parameter: <br><br><ul><li>  Koordinaten der oberen linken Ecke; </li><li>  Breite und Höhe. </li></ul><br><img src="https://habrastorage.org/webt/9k/m4/mn/9km4mnazc-bszyeglny7jgury1k.png"><br><br>  Auto Layout ist sehr ausführlich.  Im Vergleich zu einem linearen Gleichungssystem ist es viel schwieriger, alles damit auf dem Bildschirm zu platzieren.  Daher werden wir den eindimensionalen Fall ohne Verlust der Allgemeinheit betrachten. <br><br><img src="https://habrastorage.org/webt/yy/g-/bz/yyg-bzfkdyhagrqn28bj7ruydg8.png"><br><br>  Alles ist sehr einfach: Der Raum ist eine gerade Linie, und alle Objekte, die darin platziert werden können, sind Punkte auf einer geraden Linie.  Ein Wert: <strong>X = X <sub>P</sub></strong> reicht aus, um die Position des Punktes zu bestimmen. <br><br>  Betrachten Sie den Ansatz des automatischen Layouts.  Es gibt einen Bereich, in dem Einschränkungen festgelegt werden.  Die Lösung, die wir bekommen wollen, ist <strong>X = X <sub>0</sub></strong> und keine andere. <br><br>  Es gibt ein Problem - wir haben keine Operationen mit Einschränkungen definiert.  Wir können nicht direkt aus dem Datensatz schließen, dass <strong>X = X <sub>0 ist</sub></strong> , wir können nichts multiplizieren oder irgendetwas hinzufügen.  Dazu müssen wir die Einschränkung in das umwandeln, mit dem wir arbeiten können - in ein System von Gleichungen und Ungleichungen. <br><br><img src="https://habrastorage.org/webt/dc/ru/gr/dcrugrl3rwq6esfcnrlz89ora8o.png"><br><br>  Auto Layout transformiert ein System von Gleichungen und Ungleichungen wie folgt. <br><br><ul><li>  Zunächst werden zwei zusätzliche Variablen eingeführt, die <strong>nicht negativ sind</strong> und <strong>voneinander abhängen</strong> .  Mindestens einer von ihnen ist gleich Null. </li><li>  Die Einschränkung selbst wird in die Notation <strong>X = X <sub>0</sub> + a <sup>+</sup> - a <sup>-</sup></strong> konvertiert. </li></ul><br>  Punkt <strong>X <sub>0</sub></strong> <sub>&nbsp;</sub>  - Lösung des Systems: Wenn <strong>a <sup>+</sup></strong> und <strong>a <sup>-</sup></strong> gleich Null sind, ist dies wahr.  Aber <strong>jeder andere Punkt</strong> auf dieser Linie wird eine Lösung sein. <br><br>  Daher ist es notwendig, das Beste aus der ganzen Reihe von Lösungen zu finden.  Zu diesem Zweck führen wir eine Funktion ein - eine gewöhnliche Funktion, die eine Zahl zurückgibt, und wir können Zahlen vergleichen.  Wir zeichnen ein Diagramm und stellen fest, dass die Lösung, die wir ursprünglich erhalten wollten, ein Minimum ist. <br><br>  Ich habe <strong>ein lineares Programmierproblem</strong> .  Genau das macht Auto Layout mit Einschränkungen, die nicht nur in Form von Gleichheiten, sondern auch in Form von Ungleichungen vorliegen. <br><br><h3>  Ungleichheitsbeschränkungen <br></h3><br>  Bei Ungleichheitsbeschränkungen erfolgt die Transformation auf die gleiche Weise wie bei Gleichheiten: Zwei zusätzliche Variablen werden eingeführt und all dies wird im System gesammelt.  Nur die Funktion ist unterschiedlich und gleich <strong>a <sup>-</sup></strong> . <br><br><img src="https://habrastorage.org/webt/su/lp/db/sulpdbiqpzdvnd2s23qwo3zg3p0.png"><br><br>  Die obige Grafik zeigt, warum dies so ist - jeder Wert von <strong>a <sup>+</sup></strong> mit <strong>a <sup>-</sup> = 0</strong> (von <strong>X <sub>0</sub></strong> bis <strong>+ ∞</strong> ) ist die optimale Lösung für das Problem. <br><br>  Versuchen wir, diese beiden Einschränkungen von Gleichungen und Ungleichungen zu einer zu kombinieren. Da die Einschränkungen nicht isoliert leben, werden sie zusammen auf das gesamte System angewendet. <br><br><img src="https://habrastorage.org/webt/kv/p4/ed/kvp4ed32qay13--nhn6neefffd0.png"><br><br>  Für jede Einschränkung wird ein zusätzliches Variablenpaar eingeführt und die Funktion kompiliert.  Da wir möchten, dass alle diese Einschränkungen gleichzeitig erfüllt werden, ist die <strong>Funktion gleich der Summe aller Funktionen aus jeder Einschränkung</strong> . <br><br>  Wir sammeln die Funktion f und sehen, dass die Lösung <strong>X <sub>1 ist</sub></strong> .  Wie wir erwartet hatten, Einschränkungen.  Wir kommen also zum dritten Algorithmus. <br><br><h3>  Algorithmus Nr. 3 <br></h3><br>  Um etwas zu tun, brauchen Sie: <br><br><ul><li>  ein System linearer Einschränkungen erstellen; </li><li>  verwandeln Sie es in ein lineares Programmierproblem; </li><li>  Lösen Sie das Problem auf eine bekannte Weise, z. B. die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simplex-Methode</a> , die im automatischen Layout verwendet wird. </li><li>  Wenden Sie die Lösung auf UIView an. </li></ul><br>  Dieser Algorithmus scheint ausreichend zu sein, aber betrachten Sie den folgenden Fall: Wir ändern den anfänglichen Satz von Einschränkungen so, dass die zweite Einschränkung jetzt <strong>X ≥ X</strong> <strong><sub>2 ist</sub></strong> . <br><br><img src="https://habrastorage.org/webt/li/dd/at/liddathmoov5umsnhvnoevax6jy.png"><br><br>  Welche Lösung erwarten wir? <br><br><ul><li>  <strong>X <sub>1</sub></strong> ?  In der Tat wird in der ersten Einschränkung so geschrieben: <strong>X = X <sub>1</sub></strong> , und diese Lösung widerspricht der zweiten Einschränkung. </li><li>  <strong>X <sub>2</sub></strong> ?  Es wird bereits einen Konflikt mit der ersten Einschränkung geben. </li></ul><br>  Um aus der Situation herauszukommen, werden wir Transformationen durchführen, die wir bereits zu tun wissen. <br><br>  Das Diagramm der neuen Funktionalität sieht anders aus: Jeder Punkt aus dem Intervall von <strong>X <sub>1</sub></strong> bis <strong>X <sub>2</sub></strong> ist die richtige gültige Lösung des Systems.  Dies nennt man <strong>Unsicherheit</strong> . <br><br><h3>  Unsicherheit <br></h3><br>  Auto Layout verfügt über einen Mechanismus zur Lösung solcher Probleme - <strong>Prioritäten</strong> .  Ich erinnere Sie daran, dass Gelb eine hohe Priorität und Blau eine niedrige Priorität anzeigt. <br><br><img src="https://habrastorage.org/webt/7e/go/is/7egoisncevkoitvo8fdxkvcdg7g.png"><br><br>  Einschränkungen konvertieren.  Bitte beachten Sie, dass das resultierende System nur schwarz ist.  Wir wissen, wie man damit arbeitet, und es gibt keine Informationen über Einschränkungen.  Es liegt in den Funktionen, von denen es zwei geben wird.  Das automatische Layout minimiert zuerst das erste und dann das zweite. <br><br>  Bei linearen Programmierproblemen suchen wir nicht nach der Lösung selbst, sondern nach einer Reihe praktikabler Lösungen.  Natürlich soll dieser Bereich nur ein Punkt sein, und das automatische Layout verhält sich genauso.  Erstens minimiert es die Funktion mit der höchsten Priorität für ( <strong>-</strong> <strong>∞,</strong> <strong>+ ∞)</strong> und erhält am Ausgang eine Domäne möglicher Lösungen.  Das automatische Layout löst das zweite lineare Programmierproblem bereits im erhaltenen Bereich zulässiger Werte.  Ein solcher Mechanismus wird als <strong>Hierarchie von Einschränkungen</strong> bezeichnet und ergibt in diesem Problem den Punkt <strong>X <sub>2</sub></strong> . <br><br><h3>  Algorithmus Nr. 4 <br></h3><br><ul><li>  Erstellen Sie eine Hierarchie linearer Einschränkungen. </li><li>  verwandeln Sie es in eine lineare Programmieraufgabe; </li><li>  Lösen Sie nacheinander das Problem der linearen Programmierung - von der höchsten zur niedrigsten Priorität. </li><li>  Wenden Sie die Lösung auf UlView an. </li></ul><br>  Schauen wir uns noch einmal die vorherige Aufgabe an.  Wir sind keine Mathematiker, sondern Ingenieure, und jeder Ingenieur sollte hier verwirrt sein. <br><br>  Hier gibt es ein ernstes Problem - <strong>Unendlichkeit</strong> , und ich weiß nicht, was es ist. <br><br>  Der Cassowary-Algorithmus unter der Haube von Auto Layout war kein vorhandener Mechanismus, der bequemerweise auf die Aufgabe Auto Layout fiel, sondern als Layout-Tool gedacht war, und er bot zu Beginn spezielle Mechanismen, um der Unendlichkeit zu entkommen.  Hierzu wurden verschiedene Arten von Beschränkungen erfunden: <br><br><ul><li>  <strong>Parameter</strong> sind die Einschränkungen, mit denen wir gearbeitet haben.  Sie werden im Original als <strong>Einstellungen bezeichnet,</strong> manchmal in der Apple-Dokumentation - <strong>optionale Einschränkungen</strong> . </li><li>  <strong>Anforderungen</strong> oder Anforderungen - Einschränkungen mit Priorität <strong>erforderlich</strong> . </li></ul><br>  Lassen Sie uns sehen, wie Anforderungen mit solchen Prioritäten aus mathematischer Sicht transformiert werden. <br><br><img src="https://habrastorage.org/webt/hm/mn/my/hmmnmycwgdfq9vuip1xeylz4caq.png"><br><br>  Wir haben wieder eine gerade Linie mit zwei Punkten und die erste Einschränkung ist <strong>X = X <sub>1</sub></strong> .  Auf der Folie ist es rot, dh diese Einschränkung mit der erforderlichen Priorität - wir nennen es eine Anforderung. <br><br>  Auto Layout konvertiert es in ein System linearer Gleichungen, das eine Gleichung <strong>X = X <sub>1 enthält</sub></strong> .  Nichts mehr - keine linearen Programmieraufgaben, keine Optimierungen. <br><br>  Ähnlich verhält es sich mit Ungleichungen, die jedoch etwas komplizierter sind. Es wird <strong>eine zusätzliche Variable</strong> angezeigt, die Werte größer als 0 annehmen kann. Für Werte größer als 0 wird diese Einschränkung erfüllt.  Bitte beachten Sie, dass hier keine linearen Programmieraufgaben und Optimierungen vorhanden sind. <br><br>  Versuchen wir, all dies zu kombinieren, zwei Anforderungen zusammenzustellen und sie in ein System umzuwandeln.  Ein aufmerksamer Leser stellte fest, dass wir zu demselben Thema gekommen sind, mit dem wir begonnen haben - die <strong>Anforderungen sollten konsistent sein</strong> . <br><br><img src="https://habrastorage.org/webt/lj/fu/wx/ljfuwxbedffz_agc5ydwoxiv0os.png"><br><br>  Erforderliche Einschränkungen oder Anforderungen sind ein <strong>sehr leistungsfähiges Werkzeug,</strong> aber nicht das Hauptwerkzeug, sondern das Hilfswerkzeug.  Es wurde speziell in Auto Layout eingeführt, um das Problem der unendlichen Intervalle zu lösen. Es muss sorgfältig verwendet werden. <br><br>  Versuchen wir, alle Arten von Einschränkungen, die wir getroffen haben, in einem System zu kombinieren.  Angenommen, wir möchten das Problem nicht auf der gesamten Linie lösen, sondern nur zwischen <strong>X <sub>0</sub></strong> und <strong>X <sub>3</sub> .</strong>  Wenn wir all dies in ein System linearer Gleichungen und Ungleichungen umwandeln, erhalten wir Folgendes. <br><br><img src="https://habrastorage.org/webt/nl/3k/lw/nl3klwil0nepuuqyjq-nmxxo0rs.png"><br><br>  Im Vergleich zum vorherigen System wurden zwei zusätzliche Variablen hinzugefügt - <strong>c</strong> und <strong>d</strong> , die jedoch nicht in die Funktionale eingehen, da Einschränkungen des erforderlichen Typs die Funktion in ihrer ursprünglichen Form nicht beeinflussen. <br><br>  Es scheint, dass sich die Aufgabe nicht wesentlich geändert hat - wir minimieren das gleiche wie zuvor, aber der anfängliche Bereich akzeptabler Werte ändert sich, jetzt ist er von <strong>X <sub>0</sub></strong> bis <strong>X <sub>3</sub></strong> . <br><br><blockquote>  Aus mathematischer Sicht sind Anforderungen - Einschränkungen des erforderlichen Typs - die Fähigkeit, zusätzliche Gleichungen in das System einzuführen, ohne dessen Funktionen zu ändern. <br></blockquote><br>  Sie müssen dabei sehr vorsichtig sein, da ein übermäßiger Missbrauch der erforderlichen Einschränkungen zu einem <strong>Problem ohne Lösungen</strong> führt und das automatische Layout damit nicht fertig wird. <br><br>  Wir kommen zum letzten fünften Algorithmus. <br><br><h3>  Algorithmus Nr. 5 <br></h3><br><ul><li>  Definieren Sie die erforderlichen Einschränkungen - Layoutanforderungen; </li><li>  Erstellen Sie eine Hierarchie linearer Einschränkungen. </li><li>  alle Einschränkungen in ein lineares Programmierproblem umwandeln; </li><li>  das Problem der linearen Programmierung lösen; </li><li>  Wenden Sie die Lösung auf UlView an. </li></ul><br>  Wir haben Cassowary untersucht - einen Algorithmus, der sich innerhalb des automatischen Layouts befindet. Bei seiner Implementierung ergeben sich jedoch verschiedene Funktionen. <br><br><h3>  IOS-Funktionen <br></h3><br>  <strong>In layoutSubviews () gibt es keine Berechnungen</strong> . <br><br>  Wann werden sie produziert?  Antwort: Immer und jederzeit wird das automatische Layout gezählt.  Die Berechnung erfolgt genau dann, wenn wir unserer Ansicht Einschränkungen hinzufügen oder diese mithilfe moderner API-Methoden zum Arbeiten mit Einschränkungen aktivieren. <br><br><img src="https://habrastorage.org/webt/rf/rf/ca/rfrfca8zmtb5ukabvarjdfygbii.png"><br><br>  Unsere Ansichten sind Rechtecke, aber das Problem ist, dass diese Informationen nicht im Cassowary enthalten sind, sondern zusätzlich dort eingebettet werden müssen.  Wir haben einen Mechanismus zur Einführung zusätzlicher Einschränkungen.  Wenn wir für jede Ansicht eine Reihe von Einschränkungen mit positiver Breite und Höhe einführen, erhalten wir am Ausgang immer Rechtecke.  Aus diesem Grund können wir die automatische Layoutansicht mit negativen Abmessungen nicht nachholen. <br><br>  Die zweite Funktion ist <strong>intrinsicContentSize</strong> - die intrinsische Größe, die für jede Ansicht festgelegt werden kann. <br><br><img src="https://habrastorage.org/webt/of/dx/dr/ofdxdrma4ob54homy7amohpvove.png"><br><br>  Dies ist eine einfache Schnittstelle zum Erstellen von 4 zusätzlichen Ungleichheitsbeschränkungen, die in das System eingefügt werden.  Dieser Mechanismus ist sehr praktisch und ermöglicht es Ihnen, die Anzahl der expliziten Einschränkungen zu reduzieren, was die Verwendung des automatischen Layouts vereinfacht.  Der letzte und dünnste Punkt, der oft vergessen wird, ist <strong>TranslateAutoresizingMaskIntoConstraints.</strong> <br><br><img src="https://habrastorage.org/webt/xz/pz/su/xzpzsulxwqohzm-ehd5rz2kg148.png"><br><br>  Dies ist eine <strong>Krücke,</strong> die in den Tagen von iOS 5 eingeführt wurde, damit der alte Code nach dem Erscheinen von Auto Layout nicht kaputt geht. <br><br>  Stellen Sie sich eine Situation vor: Wir legen Einschränkungen fest.  Innerhalb der Ansicht verwenden wir die Ansicht, die nichts über Einschränkungen weiß, alles, was auf Frames gesetzt ist, aber innerhalb der Ansicht die Ansicht, die seit langem in Einschränkungen übersetzt wurde. <br><br><blockquote>  Ich erinnere Sie daran, dass in der Auto-Layout-Aufgabe von Cassowary keine Frames enthalten sind, sondern nur Einschränkungen. <br></blockquote><br>  Die Größe und Position der Ansicht, die in den Frames reduziert wurde, wird durch Einschränkungen nicht vollständig bestimmt.  Bei der Berechnung der Größe und Position aller anderen Ansichten werden falsche Größen berücksichtigt, obwohl wir nach dem automatischen Layout dort die richtigen Rahmen anwenden. <br><br>  Um diese Situation zu vermeiden, wird für jede Ansicht, die im Frame angeordnet ist, eine zusätzliche Einschränkung angewendet, wenn der Wert der Variablen TranslateAutoresizingMaskIntoConstraints true ist.  Diese Einschränkungen können von Lauf zu Lauf variieren.  Über dieses Set ist nur eines bekannt - sein Rahmen wird derjenige sein, der übertragen wurde. <br><br>  Die Kompatibilität zwischen altem Code ohne Einschränkungen und neuem Code mit Einschränkungen kann häufig durch den Missbrauch dieser Eigenschaft beeinträchtigt werden.  Diese Einschränkungen haben notwendigerweise die Priorität von Anforderungen. Wenn wir also einer solchen Ansicht, die eine sehr hohe Priorität hat, beispielsweise einer Anforderung, plötzlich Einschränkungen auferlegen, können wir versehentlich ein nicht konsistentes System erstellen, das keine Lösungen hat. <br><br>  <strong>Es ist wichtig zu wissen:</strong> <br><br><ul><li>  Wenn wir eine Ansicht aus dem <strong>Interface Builder</strong> erstellen, ist der Standardwert für diese Eigenschaft <strong>false</strong> . </li><li>  Wenn wir eine Ansicht direkt aus dem Code erstellen, ist dies der <strong>Fall</strong> . </li></ul><br>  Die Idee ist sehr einfach: Der alte Code, in dem die Ansicht erstellt wurde, wusste nichts über das automatische Layout, und es musste so gestaltet werden, dass es funktioniert, wenn die Ansicht irgendwo an einem neuen Ort verwendet wird. <br><br><h2>  Praktische Tipps <br></h2><br>  Insgesamt wird es drei Räte geben, die mit den wichtigsten beginnen. <br><br><h3>  Optimierung <br></h3><br><blockquote>  Es ist wichtig, das Problem zu lokalisieren. <br></blockquote><br>  Haben Sie jemals das Problem der Optimierung des Bildschirms gehabt, der im automatischen Layout dargestellt ist?  Höchstwahrscheinlich nicht, häufiger hatten Sie das Problem, das Layout von Zellen in einer Tabelle oder einer <strong>Sammlungsansicht zu</strong> optimieren. <br><br>  Das automatische Layout ist so optimiert, dass jeder Bildschirm und jede Benutzeroberfläche erstellt werden kann. Es ist jedoch ein Problem, 50 oder 100 gleichzeitig zu erstellen.  Schauen wir uns das Experiment an, um es zu lokalisieren und zu optimieren.  Die Zahlen stammen aus einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel,</a> in dem Cassowary erstmals beschrieben wurde. <br><img src="https://habrastorage.org/webt/jl/cb/qo/jlcbqo-0y685wxkbkniflmjlwli.png"><br><br>  Die Aufgabe ist folgende: Wir erstellen nacheinander eine Ansichtskette und verbinden jede nachfolgende mit der vorherigen.  So wurde eine Folge von 1000 Elementen erstellt.  Nach dem Messen verschiedener Operationen wird die Zeit in Millisekunden angezeigt.  Die Werte sind ziemlich groß, da Auto Layout an der Kreuzung der 80er und 90er Jahre erfunden wurde. <br><br>  Durch das Sammeln einer solchen Kette können Sie wie folgt vorgehen: <br><br><ul><li>  <strong>Fügen Sie nacheinander eine Einschränkung hinzu</strong> und entscheiden Sie jedes Mal.  Dies dauert 38 Sekunden. </li><li>  Sie können <strong>alle Einschränkungen auf einmal hinzufügen</strong> und erst dann das System lösen.  Diese Lösung ist effizienter.  Nach alten Daten steigt der Wirkungsgrad um 70%, bei der derzeitigen Implementierung auf modernen Geräten werden es jedoch nur 20% sein.  Eine qualitativ einmalige Hinzufügung von Beschränkungen wird jedoch immer effektiver sein. </li><li>  Wenn die gesamte Kette zusammengebaut ist, können <strong>Sie eine weitere Einschränkung hinzufügen</strong> .  Wie aus der Tabelle ersichtlich ist, ist diese Operation ziemlich billig. </li><li>  Das Interessanteste: <strong>Wenn wir keine neuen Einschränkungen hinzufügen, sondern eine Konstante in einer der vorhandenen ändern,</strong> ist dies eine Größenordnung effektiver als das Löschen oder Erstellen einer neuen Einschränkung. </li></ul><br>  Die ersten beiden Punkte können als primäre Berechnung der Schnittstellen beschrieben werden, die letzten beiden - als nächste. <br><br><h4>  Berechnung der primären Schnittstelle <br></h4><br>  Hier können Sie die Methoden zum Hinzufügen von Masseneinschränkungen zur Optimierung verwenden: <br><br><ul><li>  <strong>NSLayoutConstraints.activate (_ :)</strong> - Sammeln Sie beim Erstellen einer Ansicht alle Einschränkungen nacheinander in einem Array, zwischenspeichern Sie sie und fügen Sie sie erst dann hinzu. </li><li>  Oder erstellen Sie Zellen im <strong>Interface Builder.</strong>  Er wird alles für uns tun und zusätzliche Optimierungen durchführen, was oft bequem ist. </li></ul><br><h4>  Nachfolgende Schnittstellenberechnungen <br></h4><br>  Das Hinzufügen oder Ändern von Einschränkungen ist eine komplexe Operation. Es ist daher besser <strong>, die Einschränkungen nicht zu ändern, sondern nur die Konstanten</strong> in vorhandenen Einschränkungen zu <strong>ändern</strong> .     : <br><br><ul><li> <strong> UIView</strong> —     .   view   ,     Auto Layout.     ,    ,      view,     . </li><li> <strong>   </strong> <strong>— IntrinsicContentSize.</strong>  ,      ,     . </li><li> <strong>   </strong> .         , ,   . </li></ul><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWDC 2018S220 High Performance Auto Layout</a> .   — Apple         ,     . <br><br><h2>   <br></h2><br>      ,       constraints. <br><br><h3>    <br></h3><br>   required ,  —   ,       ,     .    . <br><br><blockquote>      ,    . <br></blockquote><br>     : <br><br><ul><li> <strong>  ,   </strong> .      (  loader) —     . </li><li> <strong>  ,   </strong> .     ,     . </li></ul><br><br><h3>   <br></h3><br>   ,          ,   . <br><br>   <strong>constraint   required,     </strong> .    , ,    ,       .    ,      . <br><br>   — <strong>  ,    </strong> .     ,        —     .   -    ,        ,      . Auto Layout      ,      . <br><br> <strong>     </strong> ,       .      .  ,       ,    ,   .        layout,  ,    ,      .        . <br><br><h3>   <br></h3><br> <strong> —   </strong> ,    Auto Layout,          ,     . <br><br>  ,  required,  ,    <strong>   </strong> .   : <br><br><ul><li>   ,     . </li><li>  ,   ,     . </li></ul><br>  ,       ,  <strong> ,     </strong> . <br><br>            ,      . ,     ,          ,    .  , <strong> —   </strong> .      . <br><br> <strong>   —    .</strong>      ,       ,     ,   —     ,     —   required      -. <br><br>  <b>Nützliche Links:</b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solving Linear Arithmetic Constraints for User Interface Applications</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Cassowary Linear Constraint Solving Algorithm</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Constraints as s Design Pattern</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auto Layout Guide by Apple</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WWDC 2018 Session 220 High Performance Auto Layout</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> UILabel   API Auto Layout —  </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> .  Medium</a> <br><br><blockquote> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf 2019</a> . ,   AppsConf    ,          22  23 . -       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,           . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437584/">https://habr.com/ru/post/de437584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437574/index.html">Das WhatsApp-Backend, Facebook Messenger und Instagram vereinen und fügen End-to-End-Verschlüsselung hinzu</a></li>
<li><a href="../de437576/index.html">DEFCON-Konferenz 17. Meine Fehler. Teil 1</a></li>
<li><a href="../de437578/index.html">DEFCON-Konferenz 17. Meine Fehler. Teil 2</a></li>
<li><a href="../de437580/index.html">Wie man sich in 5 Tagen an ein JavaScript-Lehrbuch oder an den „Palast der Erinnerung“ im Alltag eines Programmierers erinnert</a></li>
<li><a href="../de437582/index.html">Übersicht über Vue.js 2.6</a></li>
<li><a href="../de437586/index.html">Wir erstellen eine Sprachanwendung am Beispiel von Google Assistant</a></li>
<li><a href="../de437588/index.html">Macht es mehr Spaß, für Mobiltelefone als für das Internet zu entwickeln?</a></li>
<li><a href="../de437590/index.html">Latenzzahlen auf dem iPhone</a></li>
<li><a href="../de437592/index.html">Asynchrone Task Execution Layer-Architektur</a></li>
<li><a href="../de437594/index.html">Wie ich die Ursache für Stottern und Frame-Skipping in allen Spielen beseitigt und versehentlich die Temperatur um 15 Grad gesenkt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>