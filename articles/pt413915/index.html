<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíß üßìüèΩ üë¥üèº Fazendo da Defesa da Torre um Jogo de Unidade - Parte 2 ü§Æ üë©‚Äçüíº üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte do tutorial "Criando um jogo de Tower Defense no Unity" . Estamos criando um jogo de g√™nero de defesa de torre no Unity, e at√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazendo da Defesa da Torre um Jogo de Unidade - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413915/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png" alt="imagem"></div><br>  Esta √© a segunda parte do tutorial <i>"Criando um jogo de Tower Defense no Unity"</i> .  Estamos criando um jogo de g√™nero de defesa de torre no Unity, e at√© o final da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> , aprendemos como colocar e atualizar monstros.  Tamb√©m temos um inimigo atacando cookies. <br><br>  No entanto, o inimigo ainda n√£o sabe para onde olhar!  Al√©m disso, um ataque sozinho parece estranho.  Nesta parte do tutorial, adicionaremos ondas de inimigos e monstros de bra√ßo para que eles possam defender um biscoito precioso. <br><a name="habracut"></a><br><h2>  Come√ßando a trabalhar </h2><br>  Abra o projeto no Unity, que paramos na √∫ltima parte.  Se voc√™ se juntou a n√≥s agora, fa√ßa o download do <a href="">projeto preliminar</a> e abra o <em>TowerDefense-Part2-Starter</em> . <br><br>  Abra o <em>GameScene</em> na pasta <em>Cenas</em> . <br><br><h2>  Vire inimigos </h2><br>  No final do tutorial anterior, o inimigo aprendeu a se mover pela estrada, mas parece que ele n√£o tem id√©ia de onde procurar. <br><br>  Abra o script <em>MoveEnemy.cs</em> no IDE e adicione o seguinte m√©todo para corrigir a situa√ß√£o. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateIntoMoveDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 newStartPosition = waypoints [currentWaypoint].transform.position; Vector3 newEndPosition = waypoints [currentWaypoint + 1].transform.position; Vector3 newDirection = (newEndPosition - newStartPosition); //2 float x = newDirection.x; float y = newDirection.y; float rotationAngle = Mathf.Atan2 (y, x) * 180 / Mathf.PI; //3 GameObject sprite = gameObject.transform.Find("Sprite").gameObject; sprite.transform.rotation = Quaternion.AngleAxis(rotationAngle, Vector3.forward); }</span></span></code> </pre> <br>  <code>RotateIntoMoveDirection</code> gira o inimigo para que ele sempre <code>RotateIntoMoveDirection</code> para a frente.  Ele faz o seguinte: <br><br><ol><li>  Calcula a dire√ß√£o atual do bug, subtraindo a posi√ß√£o do waypoint atual da posi√ß√£o do pr√≥ximo ponto. </li><li>  Usa <code>Mathf.Atan2</code> para determinar o √¢ngulo em radianos para o qual <code>newDirection</code> direcionado (o ponto zero est√° √† direita).  Multiplica o resultado por <code>180 / Mathf.PI</code> , convertendo o √¢ngulo em graus. </li><li>  Por fim, ele obt√©m o filho <em>Sprite</em> e gira o eixo de <code>rotationAngle</code> √¢ngulo.  Observe que rotacionamos a <i>crian√ßa</i> , n√£o o pai, de modo que a faixa de energia que adicionamos posteriormente permane√ßa horizontal. </li></ol><br>  Em <code>Update()</code> , substitua o coment√°rio <code>// TODO:    </code> pr√≥xima chamada para <code>RotateIntoMoveDirection</code> : <br><br><pre> <code class="cs hljs">RotateIntoMoveDirection();</code> </pre> <br>  Salve o arquivo e retorne ao Unity.  Execute a cena;  agora o inimigo sabe para onde est√° se movendo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/7f4/9e5/73d7f49e5fec3785e2ac3376c3774f27.gif"></div><br>  Agora o bug sabe para onde est√° indo. <br><br>  O √∫nico inimigo n√£o parece muito impressionante.  Precisamos de hordas!  E, como em qualquer jogo de defesa de torre, hordas correm em ondas! <br><br><h2>  Informar jogador </h2><br>  Antes de come√ßarmos a mover as hordas, precisamos alertar o jogador sobre a batalha iminente.  Al√©m disso, vale a pena exibir o n√∫mero da onda atual na parte superior da tela. <br><br>  <em>As</em> informa√ß√µes de <em>onda</em> s√£o exigidas por v√°rios GameObjects, portanto, as adicionaremos ao componente <em>GameManagerBehavior</em> do <em>GameManager</em> . <br><br>  Abra o <em>GameManagerBehavior.cs</em> no IDE e adicione as duas vari√°veis ‚Äã‚Äãa seguir: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text waveLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] nextWaveLabels;</code> </pre> <br>  <code>waveLabel</code> armazena um link para a etiqueta de sa√≠da do n√∫mero da onda no canto superior direito da tela.  <code>nextWaveLabels</code> armazena dois GameObjects que criam uma combina√ß√£o de anima√ß√£o que mostraremos no in√≠cio de uma nova onda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/650/8f0/e7c6508f018c4382e490a4f6bee31e1f.gif"></div><br>  Salve o arquivo e retorne ao Unity.  Selecione <em>GameManager</em> na <em>Hierarquia</em> .  Clique no c√≠rculo √† direita do <em>r√≥tulo</em> da <em>onda</em> e, na caixa de di√°logo <em>Selecionar texto</em> , selecione <em>WaveLabel</em> na guia <em>Cena</em> . <br><br>  Agora defina o <em>tamanho</em> para <em>etiquetas da pr√≥xima onda</em> como <em>2</em> .  Agora defina o <em>Elemento 0</em> como <em>NextWaveBottomLabel</em> e, para o <em>Elemento 1,</em> <em>NextWaveTopLabel</em> √© o mesmo que fizemos com o Wave Label. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/725/1f8/d197251f821c7262c638df487fb752cd.png"></div><br>  <i>√â assim que o Comportamento do Game Manager deve ser agora</i> <br><br>  Se o jogador perder, ele n√£o ver√° uma mensagem sobre a pr√≥xima onda.  Para lidar com essa situa√ß√£o, retorne ao <em>GameManagerBehavior.cs</em> e adicione outra vari√°vel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> gameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  No <code>gameOver</code> armazenaremos o valor da perda do jogador. <br><br>  Aqui, novamente usamos a propriedade para sincronizar os elementos do jogo com a onda atual.  Adicione o seguinte c√≥digo ao <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wave; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Wave { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wave; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { wave = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nextWaveLabels.Length; i++) { nextWaveLabels[i].GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string"><span class="hljs-string">"nextWave"</span></span>); } } waveLabel.text = <span class="hljs-string"><span class="hljs-string">"WAVE: "</span></span> + (wave + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>  Criar uma vari√°vel privada, propriedade e getter j√° deve ser uma coisa familiar para voc√™.  Mas com o levantador, novamente, tudo √© um pouco mais interessante. <br><br>  Atribu√≠mos a <code>wave</code> novo <code>value</code> . <br><br>  Depois, verificamos se o jogo terminou.  Caso contr√°rio, percorra todos os r√≥tulos <em>nextWaveLabels</em> - esses r√≥tulos t√™m um componente <em>Animator</em> .  Para ativar a anima√ß√£o do <em>Animator</em> , <em>definimos</em> um gatilho <em>nextWave</em> . <br><br>  Por fim, definimos o <code>text</code> de <code>waveLabel</code> como <code>wave + 1</code> .  Por que <code>+1</code> ?  As pessoas comuns n√£o come√ßam a contar do zero (sim, isso √© estranho). <br><br>  Em <code>Start()</code> definimos o valor dessa propriedade: <br><br><pre> <code class="cs hljs">Wave = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Come√ßamos a contagem com o n√∫mero <em>0</em> <code>Wave</code> . <br><br>  Salve o arquivo e execute a cena no Unity.  O r√≥tulo do Wave mostrar√° corretamente 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0d/edf/546/b0dedf546c1b6ad9b0d0b91c5021212d.png"></div><br>  <i>Para um jogador, tudo come√ßa com a onda 1.</i> <br><br><h2>  Ondas: crie montes de inimigos </h2><br>  Pode parecer √≥bvio, mas, para atacar com uma horda, √© necess√°rio criar mais inimigos - enquanto n√£o sabemos como fazer isso.  Al√©m disso, n√£o devemos criar a pr√≥xima onda at√© que a atual seja destru√≠da. <br><br>  Ou seja, o jogo deve ser capaz de reconhecer a presen√ßa de inimigos na cena, e as <em>tags</em> s√£o uma boa maneira de identificar os objetos do jogo aqui. <br><br><h3>  Marca√ß√£o inimiga </h3><br>  Selecione a pr√©-fabricada <em>Inimigo</em> no Project Browser.  Na parte superior do <em>Inspetor,</em> clique na lista suspensa <em>Marca</em> e selecione <em>Adicionar marca</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be0/7ea/b29/be07eab29a25c69751add67ce4faa283.png"></div><br>  Crie uma <em>tag</em> chamada <em>Inimigo</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/c66/d02/df1c66d02e0c29a7a6ec0b615dbbd2fc.png"></div><br>  Selecione o <em>inimigo</em> pr√©-fabricado.  No <em>Inspetor,</em> defina <em>a tag</em> <em>Inimigo</em> para ele. <br><br><h3>  Definindo ondas de inimigos </h3><br>  Agora precisamos definir a onda de inimigos.  Abra o <em>SpawnEnemy.cs</em> no IDE e adicione a seguinte implementa√ß√£o de classe antes do <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject enemyPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnInterval = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEnemies = <span class="hljs-number"><span class="hljs-number">20</span></span>; }</code> </pre> <br>  <em>Wave</em> cont√©m <code>enemyPrefab</code> - a base para criar inst√¢ncias de todos os inimigos nessa onda, <code>spawnInterval</code> - tempo entre os inimigos na onda em segundos e <code>maxEnemies</code> - o n√∫mero de inimigos criados nessa onda. <br><br>  A classe √© <em>serializ√°vel</em> , ou seja, podemos alterar seus valores no Inspetor. <br><br>  Adicione as seguintes vari√°veis ‚Äã‚Äã√† classe <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Wave[] waves; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeBetweenWaves = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastSpawnTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemiesSpawned = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Aqui, definimos as vari√°veis ‚Äã‚Äãpara gerar inimigos, o que √© muito semelhante √† forma como movemos os inimigos entre os pontos da rota. <br><br>  Definimos as ondas de inimigos individuais em <code>waves</code> e rastreamos o n√∫mero de inimigos criados e a hora em que foram criados em <code>enemiesSpawned</code> e <code>lastSpawnTime</code> . <br><br>  Depois de todas essas mortes, os jogadores precisam de tempo para respirar, ent√£o defina <code>timeBetweenWaves</code> para 5 segundos. <br><br>  Substitua o conte√∫do de <code>Start()</code> seguinte c√≥digo. <br><br><pre> <code class="cs hljs">lastSpawnTime = Time.time; gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Aqui atribu√≠mos <code>lastSpawnTime</code> valor do hor√°rio atual, ou seja, o hor√°rio em que o script foi iniciado ap√≥s o carregamento da cena.  Em seguida, obtemos o j√° conhecido <code>GameManagerBehavior</code> . <br><br>  Adicione o seguinte c√≥digo ao <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 int currentWave = gameManager.Wave; if (currentWave &lt; waves.Length) { // 2 float timeInterval = Time.time - lastSpawnTime; float spawnInterval = waves[currentWave].spawnInterval; if (((enemiesSpawned == 0 &amp;&amp; timeInterval &gt; timeBetweenWaves) || timeInterval &gt; spawnInterval) &amp;&amp; enemiesSpawned &lt; waves[currentWave].maxEnemies) { // 3 lastSpawnTime = Time.time; GameObject newEnemy = (GameObject) Instantiate(waves[currentWave].enemyPrefab); newEnemy.GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints; enemiesSpawned++; } // 4 if (enemiesSpawned == waves[currentWave].maxEnemies &amp;&amp; GameObject.FindGameObjectWithTag("Enemy") == null) { gameManager.Wave++; gameManager.Gold = Mathf.RoundToInt(gameManager.Gold * 1.1f); enemiesSpawned = 0; lastSpawnTime = Time.time; } // 5 } else { gameManager.gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag ("GameWon"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); }</span></span></code> </pre> <br>  Vamos analis√°-lo passo a passo: <br><br><ol><li>  Obtemos o √≠ndice da onda atual e verificamos se √© a √∫ltima. </li><li>  Nesse caso, calculamos o tempo decorrido ap√≥s a gera√ß√£o anterior do inimigo e verificamos se √© hora de criar um inimigo.  Aqui levamos em conta dois casos.  Se este √© o primeiro inimigo na onda, verificamos se o <code>timeInterval</code> √© <code>timeInterval</code> que o <code>timeBetweenWaves</code> .  Caso contr√°rio, verificamos se <code>timeInterval</code> √© <code>timeInterval</code> que <code>spawnInterval</code> ondas <code>spawnInterval</code> .  De qualquer forma, verificamos que n√£o criamos todos os inimigos nesta onda. </li><li>  Se necess√°rio, crie o inimigo, criando uma inst√¢ncia de <code>enemyPrefab</code> .  Aumente tamb√©m o valor dos <code>enemiesSpawned</code> . </li><li>  Verifique o n√∫mero de inimigos na tela.  Se eles n√£o est√£o l√°, e este foi o √∫ltimo inimigo na onda, criamos a pr√≥xima onda.  Tamb√©m no final da onda, damos ao jogador 10% de todo o ouro restante. </li><li>  Depois de derrotar a √∫ltima onda, uma anima√ß√£o de vit√≥ria no jogo √© jogada aqui. </li></ol><br><h3>  Definir intervalos de reprodu√ß√£o </h3><br>  Salve o arquivo e retorne ao Unity.  Selecione o objeto <em>Estrada</em> na <em>Hierarquia</em> .  No <em>Inspetor,</em> defina o objeto <em>Tamanho</em> das <em>ondas</em> como <em>4</em> . <br><br>  Por enquanto, selecione um objeto <em>Inimigo</em> para todos os quatro elementos como <em>Pr√©-fabricado Inimigo</em> .  Configure os campos <em>Intervalo de gera√ß√£o</em> e <em>Inimigos</em> m√°ximos da seguinte maneira: <br><br><ul><li>  <em>Elemento 0</em> : Spawn Intervalo: <em>2,5</em> , M√°ximo Inimigos: <em>5</em> </li><li>  <em>Elemento 1</em> : Spawn Intervalo: <em>2</em> , M√°x. Inimigos: <em>10</em> </li><li>  <em>Elemento 2</em> : Spawn Intervalo: <em>2</em> , M√°x. Inimigos: <em>15</em> </li><li>  <em>Elemento 3</em> : Spawn Intervalo: <em>1</em> , M√°x. Inimigos: <em>5</em> </li></ul><br>  O esquema final deve ficar assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/0fa/954/ff70fa95476112b51dfb83505f9a785b.png"></div><br>  Obviamente, voc√™ pode experimentar esses valores para aumentar ou diminuir a complexidade. <br><br>  Inicie o jogo.  Sim!  Os besouros come√ßaram a jornada para o seu biscoito! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/097/4d3/a7f0974d36a188b5575a3e70a8488a4a.gif" alt="insetos"></div><br><h3>  Tarefa adicional: adicione diferentes tipos de inimigos </h3><br>  Nenhum jogo de defesa de torre pode ser considerado completo com apenas um tipo de inimigo.  Felizmente, tamb√©m <em>existe</em> o <em>Enemy2 na</em> pasta <em>Prefabs</em> . <br><br>  No <em>Inspetor,</em> selecione <em>Prefabs \ Enemy2</em> e adicione o script <em>MoveEnemy</em> a ele.  Defina <em>Speed</em> como <em>3</em> e defina <em>a tag</em> <em>Enemy</em> .  Agora voc√™ pode usar esse inimigo r√°pido para que o jogador n√£o relaxe! <br><br><h2>  Atualiza√ß√£o da vida do jogador </h2><br>  Mesmo que hordas de inimigos atacem o cookie, o jogador n√£o sofre dano.  Mas em breve vamos consertar.  O jogador deve sofrer se permitir que o inimigo se esgueire. <br><br>  Abra o <em>GameManagerBehavior.cs</em> no IDE e adicione as duas vari√°veis ‚Äã‚Äãa seguir: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text healthLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] healthIndicator;</code> </pre> <br>  Usamos <code>healthLabel</code> para acessar o valor da vida do jogador e <code>healthIndicator</code> para acessar os cinco monstrinhos verdes que mastigam cookies - eles simplesmente simbolizam a sa√∫de do jogador;  √© mais engra√ßado que um indicador de sa√∫de padr√£o. <br><br><h3>  Gest√£o em sa√∫de </h3><br>  Agora adicione uma propriedade que armazena a sa√∫de do jogador no <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> health; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (value &lt; health) { Camera.main.GetComponent&lt;CameraShake&gt;().Shake(); } // 2 health = value; healthLabel.text = "HEALTH: " + health; // 3 if (health &lt;= 0 &amp;&amp; !gameOver) { gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag("GameOver"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); } // 4 for (int i = 0; i &lt; healthIndicator.Length; i++) { if (i &lt; Health) { healthIndicator[i].SetActive(true); } else { healthIndicator[i].SetActive(false); } } } }</span></span></code> </pre> <br>  √â assim que gerenciamos a sa√∫de do jogador.  E, novamente, a parte principal do c√≥digo est√° localizada no setter: <br><br><ol><li>  Se reduzirmos a sa√∫de do jogador, usamos o componente <code>CameraShake</code> para criar um belo efeito de trepida√ß√£o.  Esse script est√° inclu√≠do no projeto para download e n√£o ser√° considerado aqui. </li><li>  Atualizamos a vari√°vel privada e o r√≥tulo de integridade no canto superior esquerdo da tela. </li><li>  Se a sa√∫de caiu para 0 e o final do jogo ainda n√£o chegou, <code>gameOver</code> como <code>true</code> e inicie a anima√ß√£o <code>gameOver</code> . </li><li>  Removemos um dos monstros dos cookies.  Se simplesmente desativ√°-los, essa parte pode ser escrita mais facilmente, mas aqui apoiamos a re-inclus√£o caso a integridade seja adicionada. </li></ol><br>  Inicializamos <code>Health</code> in <code>Start()</code> : <br><br><pre> <code class="cs hljs">Health = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br>  Definimos <code>Health</code> como <code>5</code> quando a cena come√ßa a ser reproduzida. <br><br>  Tendo feito tudo isso, agora podemos atualizar a sa√∫de do jogador quando o bug chegar ao cookie.  Salve o arquivo e acesse o IDE no script <em>MoveEnemy.cs</em> . <br><br><h3>  Mudan√ßa de sa√∫de </h3><br>  Para alterar sua sa√∫de, localize o coment√°rio em <code>Update()</code> com as palavras <code>// TODO:  </code> e substitua-o por este c√≥digo: <br><br><pre> <code class="cs hljs">GameManagerBehavior gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;(); gameManager.Health -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Portanto, obtemos o <code>GameManagerBehavior</code> e <code>GameManagerBehavior</code> a unidade de sua <code>Health</code> . <br><br>  Salve o arquivo e retorne ao Unity. <br><br>  Selecione um <em>GameManager</em> na <em>Hierarquia</em> e selecione <em>HealthLabel</em> para seu <em>R√≥tulo de</em> <em>Vida</em> . <br><br>  Expanda o objeto <em>Cookie</em> na <em>Hierarquia</em> e arraste seus cinco <em>HealthIndicators</em> filhos para a <em>matriz de indicadores de sa√∫de do GameManager</em> - os indicadores de sa√∫de ser√£o pequenos monstros verdes comendo biscoitos. <br><br>  Execute a cena e aguarde at√© que os insetos atinjam o cookie.  N√£o fa√ßa nada at√© perder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/f4a/ea4/8d8f4aea4cec500c3894d233f402b7ba.gif" alt="ataque de cookie"></div><br><h2>  Monster Revenge </h2><br>  Monstros no lugar?  Sim  Os inimigos atacam?  Sim, e eles parecem amea√ßadores!  √â hora de responder a esses animais! <br><br>  Para fazer isso, precisamos do seguinte: <br><br><ul><li>  Faixa de vida para que o jogador saiba quais inimigos s√£o fortes e quais s√£o fracos </li><li>  Detectando inimigos ao alcance de um monstro </li><li>  Tomar uma decis√£o - em qual inimigo atirar </li><li>  Um monte de conchas </li></ul><br><h3>  Barra de sa√∫de inimiga </h3><br>  Para implementar a faixa de sa√∫de, usamos duas imagens - uma para o fundo escuro e a segunda (a barra verde √© um pouco menor), escalaremos de acordo com a sa√∫de do inimigo. <br><br>  Arraste do <em>Project Browser</em> para a cena <em>Prefabs \ Enemy</em> . <br><br>  Em seguida, na <em>Hierarquia,</em> arraste e solte <em>Images \ Objects \ HealthBarBackground</em> no <em>Enemy</em> para adicion√°-lo como um filho. <br><br>  No <em>Inspetor,</em> defina a <em>Posi√ß√£o do</em> <em>HealthBarBackground</em> como <em>(0, 1, -4)</em> . <br><br>  Em seguida, no <em>Navegador de projeto,</em> selecione <em>Images \ Objects \ HealthBar</em> e verifique se o <em>Pivot</em> est√° √† <em>esquerda</em> .  Em seguida, adicione-o como filho do <em>Inimigo</em> na <em>Hierarquia</em> e defina seu valor de <em>Posi√ß√£o</em> <em>(-0,63, 1, -5)</em> .  Para <em>Escala</em> <em>X</em> <em>,</em> defina o valor como <em>125</em> . <br><br>  Adicione um novo script <em>C #</em> chamado <em>HealthBar ao</em> objeto de jogo <em>HealthBar</em> .  Mais tarde, vamos alter√°-lo para que ele altere o comprimento da barra de sa√∫de. <br><br>  Depois de selecionar um objeto <em>Inimigo</em> na <em>Hierarquia</em> , verifique se sua posi√ß√£o √© <em>(20, 0, 0)</em> . <br><br>  Clique em <em>Aplicar</em> na parte superior do <em>Inspetor</em> para salvar todas as altera√ß√µes como parte da pr√©-fabricada.  Por fim, exclua o objeto <em>Inimigo</em> na <em>Hierarquia</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b84/7d2/9e7b847d22d2fda1e146dbf9149f912e.png"></div><br>  Agora repita todas essas etapas para adicionar uma barra de <em>integridade</em> para <em>Prefabs \ Enemy2</em> . <br><br><h3>  Alterar o comprimento da barra de integridade </h3><br>  Abra o IDE <em>HealthBar.cs</em> e adicione as seguintes vari√°veis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currentHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originalScale;</code> </pre> <br>  No <code>maxHealth</code> a sa√∫de m√°xima do inimigo √© armazenada, e no <code>currentHealth</code> - o restante da sa√∫de.  Finalmente, em <code>originalScale</code> est√° o tamanho inicial da barra de integridade. <br><br>  Salve o objeto <code>originalScale</code> em <code>Start()</code> : <br><br><pre> <code class="cs hljs">originalScale = gameObject.transform.localScale.x;</code> </pre> <br>  Armazenamos o valor <code>x</code> da propriedade <code>localScale</code> . <br><br>  Defina a escala da barra de integridade adicionando o seguinte c√≥digo a <code>Update()</code> : <br><br><pre> <code class="cs hljs">Vector3 tmpScale = gameObject.transform.localScale; tmpScale.x = currentHealth / maxHealth * originalScale; gameObject.transform.localScale = tmpScale;</code> </pre> <br>  Podemos copiar <code>localScale</code> em uma vari√°vel tempor√°ria porque n√£o podemos alterar seu valor <i>x</i> separadamente.  Depois calculamos a nova escala <i>x com</i> base na sa√∫de atual do besouro e novamente atribu√≠mos o valor <code>localScale</code> a uma vari√°vel tempor√°ria. <br><br>  Salve o arquivo e inicie o jogo no Unity.  Sobre os inimigos, voc√™ ver√° faixas de sa√∫de. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png"></div><br>  Enquanto o jogo est√° em execu√ß√£o, expanda um dos objetos <em>Inimigo (Clone)</em> na <em>Hierarquia</em> e selecione sua <em>barra de sa√∫de</em> filho.  Altere seu valor de integridade <em>atual</em> e veja como a barra de integridade muda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ee/af7/22c/5eeaf722c2e6a6ee1d2799380cdcfead.gif"></div><br><h3>  Detec√ß√£o de inimigos dentro do alcance </h3><br>  Agora nossos monstros precisam descobrir quais inimigos apontar.  Mas antes que voc√™ perceba essa oportunidade, voc√™ precisa preparar Monster e Inemy. <br><br>  Selecione <em>Prefabs do</em> Project Browser <em>\ Monster</em> e adicione o componente <em>2D</em> do <em>Circle Collider</em> a ele no <em>Inspector</em> . <br><br>  Defina o par√¢metro <em>Radius</em> do colisor como <em>2.5</em> - isso indicar√° o raio de ataque dos monstros. <br><br>  Marque a caixa de sele√ß√£o <em>√â acionador</em> para que os objetos passem por essa √°rea em vez de colidir com ela. <br><br>  Finalmente, na parte superior do <em>Inspetor</em> , defina a <em>Camada</em> do monstro como <em>Ignorar Raycast</em> .  Na caixa de di√°logo, clique em <em>Sim, altere filhos</em> .  Se Ignorar Raycast n√£o estiver selecionado, o colisor responder√° aos eventos de clique do mouse.  Isso ser√° um problema, porque os monstros bloqueiam eventos destinados aos objetos Openspot abaixo deles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/302/cf2/e3e302cf21adee1433fe2183120c2ba1.png"></div><br>  Para garantir que o inimigo seja detectado na √°rea de gatilho, precisamos adicionar um colisor e um corpo r√≠gido a ele, porque o Unity envia apenas eventos de gatilho quando um corpo r√≠gido √© anexado a um dos colisores. <br><br>  No <em>Navegador de projeto,</em> selecione <em>Prefabs \ Enemy</em> .  Adicione o componente <em>Rigidbody 2D</em> e selecione <em>Kinematic</em> para <em>Body Type</em> .  Isso significa que o corpo n√£o ser√° afetado pela f√≠sica. <br><br>  Adicione <em>Circle Collider 2D</em> com um <em>raio</em> de <em>1</em> .  Repita essas etapas para <em>Prefabs \ Enemy 2</em> . <br><br>  Os gatilhos s√£o configurados para que os monstros entendam que os inimigos est√£o dentro do seu raio de a√ß√£o. <br><br>  Precisamos preparar mais uma coisa: um script dizendo aos monstros quando o inimigo √© destru√≠do, para que eles n√£o levantem uma exce√ß√£o enquanto continuam atirando. <br><br>  Crie um novo script <em>C #</em> chamado <em>EnemyDestructionDelegate</em> e adicione-o aos <em>prefabs</em> do <em>Enemy</em> e <em>Enemy2</em> . <br><br>  Abra <em>EnemyDestructionDelegate.cs</em> no IDE e adicione a seguinte declara√ß√£o de delega√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject enemy</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyDelegate enemyDelegate;</code> </pre> <br>  Aqui, criamos um <code>delegate</code> , ou seja, um cont√™iner para uma fun√ß√£o que pode ser passada como uma vari√°vel. <br><br><blockquote>  <em>Nota</em> : os delegados s√£o usados ‚Äã‚Äãquando um objeto do jogo deve notificar ativamente outros objetos do jogo sobre altera√ß√µes.  Leia mais sobre os delegados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="da documenta√ß√£o do Unity">documenta√ß√£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="da documenta√ß√£o do Unity">Unity</a> . </blockquote><br>  Adicione o seguinte m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyDelegate != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { enemyDelegate(gameObject); } }</code> </pre> <br>  Quando um objeto do jogo √© destru√≠do, o Unity chama automaticamente esse m√©todo e verifica o delegado quanto √† desigualdade <code>null</code> .  No nosso caso, chamamos isso de <code>gameObject</code> como par√¢metro.  Isso permite que todos os entrevistados registrados como delegados saibam que o inimigo est√° destru√≠do. <br><br>  Salve o arquivo e retorne ao Unity. <br><br><h3>  Damos aos monstros uma licen√ßa para matar </h3><br>  E agora os monstros podem detectar inimigos dentro do raio de sua a√ß√£o.  Adicione um novo script <em>C #</em> √† pr√©-fabricada <em>Monster</em> e <em>chame</em> -a de <em>ShootEnemies</em> . <br><br>  Abra <em>ShootEnemies.cs</em> no IDE e adicione o seguinte <code>using</code> constru√ß√£o para acessar os <code>Generics</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Adicione uma vari√°vel para rastrear todos os inimigos dentro do alcance: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;GameObject&gt; enemiesInRange;</code> </pre> <br>  Em <code>enemiesInRange</code> , armazenaremos todos os inimigos dentro do alcance. <br><br>  Inicialize o campo em <code>Start()</code> . <br><br><pre> <code class="cs hljs">enemiesInRange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameObject&gt;();</code> </pre> <br>  No come√ßo, n√£o h√° inimigos no raio de a√ß√£o, por isso criamos uma lista vazia. <br><br>  Preencha a lista de <code>enemiesInRange</code> !  Adicione o seguinte c√≥digo ao script: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 void OnEnemyDestroy(GameObject enemy) { enemiesInRange.Remove (enemy); } void OnTriggerEnter2D (Collider2D other) { // 2 if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Add(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate += OnEnemyDestroy; } } // 3 void OnTriggerExit2D (Collider2D other) { if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Remove(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate -= OnEnemyDestroy; } }</span></span></code> </pre> <br><ol><li>  No <code>OnEnemyDestroy</code> removemos o inimigo de <code>enemiesInRange</code> .  Quando um inimigo pisa em um gatilho em torno de um monstro, <code>OnTriggerEnter2D</code> √© <code>OnTriggerEnter2D</code> . </li><li>  Em seguida, adicionamos o inimigo √† lista <code>enemiesInRange</code> e adicionamos o evento <code>OnEnemyDestroy</code> .  Portanto, garantimos que, ap√≥s a destrui√ß√£o do inimigo, o <code>OnEnemyDestroy</code> ser√° chamado.  N√£o queremos que os monstros gastem muni√ß√£o em inimigos mortos, certo? </li><li>  No <code>OnTriggerExit2D</code> removemos o inimigo da lista e cancelamos o registro do delegado.  Agora sabemos quais inimigos est√£o ao alcance. </li></ol><br>  Salve o arquivo e inicie o jogo no Unity.  Para garantir que tudo esteja funcionando, posicione o monstro, selecione-o e siga as altera√ß√µes na lista <code>enemiesInRange</code> no <code>enemiesInRange</code> . <br><br><h3>  Sele√ß√£o de alvo </h3><br>  Os monstros agora sabem qual inimigo est√° ao alcance.  Mas o que eles far√£o quando houver v√°rios inimigos no raio? <br><br>  Claro, eles atacar√£o o mais pr√≥ximo do f√≠gado! <br><br>  Abra o script IDE <em>MoveEnemy.cs</em> e adicione um novo m√©todo que calcula esse monstro: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceToGoal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; distance += Vector2.Distance( gameObject.transform.position, waypoints [currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; waypoints.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { Vector3 startPosition = waypoints [i].transform.position; Vector3 endPosition = waypoints [i + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position; distance += Vector2.Distance(startPosition, endPosition); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; }</code> </pre> <br>  O c√≥digo calcula o comprimento do caminho ainda n√£o percorrido pelo inimigo.  Para fazer isso, ele usa <code>Distance</code> , calculado como a dist√¢ncia entre duas inst√¢ncias do <code>Vector3</code> . <br><br>  Usaremos esse m√©todo posteriormente para descobrir qual alvo atacar.  No entanto, enquanto nossos monstros n√£o est√£o armados e desamparados, primeiro faremos isso. <br><br>  Salve o arquivo e retorne ao Unity para come√ßar a configurar seus shells. <br><br><h3>  Vamos dar conchas aos monstros.  Muitas conchas! </h3><br>  Arraste do Project Browser para a <em>cena Images / Objects / Bullet1</em> .  Defina a posi√ß√£o em <em>z</em> como <em>-2</em> - as posi√ß√µes em xey n√£o s√£o importantes, porque as definimos sempre que criamos uma nova inst√¢ncia do proj√©til durante a execu√ß√£o do programa. <br><br>  Adicione um novo script <em>C #</em> chamado <em>BulletBehavior</em> e, no IDE, adicione as seguintes vari√°veis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 startPosition; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 targetPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  <code>speed</code> determina a velocidade dos proj√©teis;  o <code>damage</code> claro no nome. <br><br>  <code>target</code> , <code>targetPosition</code> e <code>targetPosition</code> determinam a dire√ß√£o do proj√©til. <br><br>  <code>distance</code> e <code>startTime</code> rastreiam a posi√ß√£o atual do proj√©til.  <code>gameManager</code> recompensa o jogador quando ele mata o inimigo. <br><br>  Atribua os valores dessas vari√°veis ‚Äã‚Äãem <code>Start()</code> : <br><br><pre> <code class="cs hljs">startTime = Time.time; distance = Vector2.Distance (startPosition, targetPosition); GameObject gm = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>); gameManager = gm.GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> <code>startTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos o valor do tempo atual e calculamos a dist√¢ncia entre as posi√ß√µes inicial e de destino. </font><font style="vertical-align: inherit;">Al√©m disso, como sempre, conseguimos </font></font><code>GameManagerBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para controlar o movimento do proj√©til, adicione o </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte c√≥digo:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 float timeInterval = Time.time - startTime; gameObject.transform.position = Vector3.Lerp(startPosition, targetPosition, timeInterval * speed / distance); // 2 if (gameObject.transform.position.Equals(targetPosition)) { if (target != null) { // 3 Transform healthBarTransform = target.transform.Find("HealthBar"); HealthBar healthBar = healthBarTransform.gameObject.GetComponent&lt;HealthBar&gt;(); healthBar.currentHealth -= Mathf.Max(damage, 0); // 4 if (healthBar.currentHealth &lt;= 0) { Destroy(target); AudioSource audioSource = target.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); gameManager.Gold += 50; } } Destroy(gameObject); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos a nova posi√ß√£o do proj√©til, usando </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para interpola√ß√£o entre as posi√ß√µes inicial e final.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o proj√©til chegar </font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verificaremos se ele ainda existe </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtemos o componente do </font></font><code>HealthBar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alvo e reduzimos sua sa√∫de pelo tamanho do </font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proj√©til.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se a sa√∫de do inimigo for reduzida a zero, n√≥s a destru√≠mos, reproduzimos o efeito sonoro e recompensamos o jogador pela precis√£o. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salve o arquivo e retorne ao Unity. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fazemos conchas grandes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o seria √≥timo se o monstro come√ßasse a disparar mais proj√©teis em n√≠veis altos? Felizmente, isso √© f√°cil de implementar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arraste o objeto de jogo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierarquia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a guia </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projeto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para criar uma pr√©-fabricada de proj√©til. Remova o objeto original da cena - n√£o ser√° mais necess√°rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duplique o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pref1 Bullet1 duas vezes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nomeie as c√≥pias de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecione </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspetor,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defina o campo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> componente </font><em><font style="vertical-align: inherit;">Sprite </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ent√£o, tornaremos o Bullet2 um pouco mais que o Bullet1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repita o procedimento para alterar o sprite pr√©-fabricada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagens relacionadas / Objetos / bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, em </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamento de balas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ajustaremos a quantidade de danos causados ‚Äã‚Äãpor proj√©teis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecione o </font><em><font style="vertical-align: inherit;">marcador</font></em><font style="vertical-align: inherit;"> pr√© </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">fabricado </font><em><font style="vertical-align: inherit;">Bullet1</font></em><font style="vertical-align: inherit;"> na guia </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projeto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No </font><em><font style="vertical-align: inherit;">Inspetor,</font></em><font style="vertical-align: inherit;"> voc√™ ver√° </font><em><font style="vertical-align: inherit;">Comportamento do marcador (Script)</font></em><font style="vertical-align: inherit;"> , no qual √© poss√≠vel definir </font><em><font style="vertical-align: inherit;">Dano</font></em><font style="vertical-align: inherit;"> para </font><em><font style="vertical-align: inherit;">10</font></em><font style="vertical-align: inherit;"> no </font><em><font style="vertical-align: inherit;">marcador1</font></em><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">15</font></em><font style="vertical-align: inherit;"> no </font><em><font style="vertical-align: inherit;">marcador2</font></em><font style="vertical-align: inherit;"> e </font><em><font style="vertical-align: inherit;">20</font></em><font style="vertical-align: inherit;"> no </font><em><font style="vertical-align: inherit;">marcador3</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ou quaisquer outros valores que voc√™ desejar. </font></font><br><br><blockquote> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alterei os valores para que, em n√≠veis mais altos, o pre√ßo do dano se torne mais alto. </font><font style="vertical-align: inherit;">Isso impede que a atualiza√ß√£o permita que o jogador atualize monstros nos melhores pontos.</font></font></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/e2d/da2/c0ae2dda288d44bc380864dd1e85f3b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cascas pr√©-fabricadas - o tamanho aumenta com o n√≠vel</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterando o n√≠vel de conchas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribua conchas diferentes para diferentes n√≠veis de monstros, para que monstros mais fortes destruam os inimigos mais rapidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abra </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonsterData.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no IDE </font><font style="vertical-align: inherit;">e adicione √†s </font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguintes vari√°veis:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject bullet; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fireRate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, definimos o pr√©-fabricado do proj√©til e a frequ√™ncia de tiro para cada n√≠vel de monstros. </font><font style="vertical-align: inherit;">Salve o arquivo e retorne ao Unity para concluir a configura√ß√£o do monstro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecione a pr√©-fabricada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no Project Browser </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspetor,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expanda </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≠veis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster Data (Script)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Defina a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taxa de inc√™ndio de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada item como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Em seguida, defina o par√¢metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do elemento 0, 1 e 2 como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os n√≠veis de monstro devem ser definidos da seguinte forma:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c0/7d0/fd9/8c07d0fd96492f9e0e6c6e1737791c11.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conchas matam inimigos? </font><font style="vertical-align: inherit;">Sim </font><font style="vertical-align: inherit;">Vamos abrir o fogo!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fogo aberto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abra </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no IDE </font><font style="vertical-align: inherit;">e adicione as seguintes vari√°veis:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastShotTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterData monsterData;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o nome indica, essas vari√°veis ‚Äã‚Äãrastreiam o tempo do √∫ltimo tiro do monstro, bem como a estrutura </font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cont√©m informa√ß√µes sobre o tipo de proj√©til de monstro, a frequ√™ncia do disparo e assim por diante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina os valores desses campos em </font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">lastShotTime = Time.time; monsterData = gameObject.GetComponentInChildren&lt;MonsterData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, atribu√≠mos o </font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor da hora atual e obtemos acesso ao componente </font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deste objeto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione o seguinte m√©todo para implementar o disparo:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D target</span></span></span><span class="hljs-function">)</span></span> { GameObject bulletPrefab = monsterData.CurrentLevel.bullet; <span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = gameObject.transform.position; Vector3 targetPosition = target.transform.position; startPosition.z = bulletPrefab.transform.position.z; targetPosition.z = bulletPrefab.transform.position.z; // 2 GameObject newBullet = (GameObject)Instantiate (bulletPrefab); newBullet.transform.position = startPosition; BulletBehavior bulletComp = newBullet.GetComponent&lt;BulletBehavior&gt;(); bulletComp.target = target.gameObject; bulletComp.startPosition = startPosition; bulletComp.targetPosition = targetPosition; // 3 Animator animator = monsterData.CurrentLevel.visualization.GetComponent&lt;Animator&gt;(); animator.SetTrigger("fireShot"); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos as posi√ß√µes inicial e alvo da bala. </font><font style="vertical-align: inherit;">Defina a posi√ß√£o z igual a z </font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anteriormente, definimos a posi√ß√£o pr√©-fabricada do proj√©til em z, para que o proj√©til apare√ßa sob o monstro atirador, mas acima dos inimigos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos uma inst√¢ncia de um novo shell usando o </font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apropriado </font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Designe </font></font><code>startPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projete.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tornamos o jogo mais interessante: quando o monstro disparar, inicie a anima√ß√£o do disparo e toque o som do laser. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juntando tudo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â hora de juntar tudo. </font><font style="vertical-align: inherit;">Defina o alvo e fa√ßa o monstro olhar para ele.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c5/934/9a7/3c59349a719669c9508c38f155bf25dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No script </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicione a </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este c√≥digo:</font></font><br><br><pre> <code class="cs hljs">GameObject target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 float minimalEnemyDistance = float.MaxValue; foreach (GameObject enemy in enemiesInRange) { float distanceToGoal = enemy.GetComponent&lt;MoveEnemy&gt;().DistanceToGoal(); if (distanceToGoal &lt; minimalEnemyDistance) { target = enemy; minimalEnemyDistance = distanceToGoal; } } // 2 if (target != null) { if (Time.time - lastShotTime &gt; monsterData.CurrentLevel.fireRate) { Shoot(target.GetComponent&lt;Collider2D&gt;()); lastShotTime = Time.time; } // 3 Vector3 direction = gameObject.transform.position - target.transform.position; gameObject.transform.rotation = Quaternion.AngleAxis( Mathf.Atan2 (direction.y, direction.x) * 180 / Mathf.PI, new Vector3 (0, 0, 1)); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere este c√≥digo passo a passo. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determine o prop√≥sito do monstro. </font><font style="vertical-align: inherit;">Come√ßamos na dist√¢ncia m√°xima poss√≠vel em </font></font><code>minimalEnemyDistance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Percorremos um ciclo de todos os inimigos dentro do alcance e transformamos o inimigo em um novo alvo, se a dist√¢ncia dele para o biscoito for menor que a menor atual.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamamos </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se o tempo decorrido √© maior que a frequ√™ncia de disparo do monstro e definimos o </font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor do tempo atual.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos o √¢ngulo de rota√ß√£o entre o monstro e seu alvo. </font><font style="vertical-align: inherit;">N√≥s giramos o monstro para esse √¢ngulo. </font><font style="vertical-align: inherit;">Agora ele sempre olha para o alvo.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salve o arquivo e inicie o jogo no Unity. </font><font style="vertical-align: inherit;">Monstros come√ßar√£o a proteger desesperadamente os cookies. </font><font style="vertical-align: inherit;">Finalmente terminamos!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para onde ir a seguir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O projeto finalizado pode ser baixado </font></font><a href="" title="aqui"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fizemos um √≥timo trabalho neste tutorial e agora temos um √≥timo jogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√£o algumas id√©ias para um maior desenvolvimento do projeto:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais tipos de inimigos e monstros </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diferentes rotas de inimigos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≠veis de jogo diferentes </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada um desses aspectos exigir√° mudan√ßas m√≠nimas e pode tornar o jogo mais divertido. </font><font style="vertical-align: inherit;">Se voc√™ criar um novo jogo com base neste tutorial, ser√° um prazer jog√°-lo, ent√£o compartilhe um link para ele. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pensamentos interessantes sobre a cria√ß√£o de um jogo de sucesso de defesa de torre podem ser encontrados nesta </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Criando um jogo de Tower Defense: uma entrevista com os principais aplicativos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrevista</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413915/">https://habr.com/ru/post/pt413915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413901/index.html">Controlar o rob√¥ de auto balanceamento EduMip usando o joystick do PS4 Dualshock 4 via ROS</a></li>
<li><a href="../pt413903/index.html">Como o Cambridge Analytica transforma cliques em vozes</a></li>
<li><a href="../pt413907/index.html">O resumo de materiais interessantes para o desenvolvedor de dispositivos m√≥veis # 256 (4 a 12 de junho)</a></li>
<li><a href="../pt413909/index.html">Foi a√≠ que suas mem√≥rias de inf√¢ncia foram</a></li>
<li><a href="../pt413913/index.html">Familiaridade com as exposi√ß√µes de equipamentos de √°udio e v√≠deo: brevemente sobre os maiores eventos - parte um</a></li>
<li><a href="../pt413917/index.html">Os detentores de direitos autorais acreditam que o Yandex contribui para o crescimento da pirataria no pa√≠s</a></li>
<li><a href="../pt413921/index.html">Como salvar o projeto de libras extras</a></li>
<li><a href="../pt413923/index.html">Talvez a atmosfera ainda possa ser limpa de di√≥xido de carbono</a></li>
<li><a href="../pt413925/index.html">CVT para Moskvich</a></li>
<li><a href="../pt413927/index.html">Digispark no Attiny85 - Conectando no Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>