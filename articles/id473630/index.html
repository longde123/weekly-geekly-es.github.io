<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥫 🧒🏾 💲 Praktik dan alat terbaik untuk mengembangkan aplikasi iOS 👨🏽‍🚀 👃🏿 🤗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika mengembangkan aplikasi seluler, saya harus membuat proyek dari awal lebih dari sekali. Pada saat yang sama, tim saya dan saya selalu menghabisk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktik dan alat terbaik untuk mengembangkan aplikasi iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473630/"> Ketika mengembangkan aplikasi seluler, saya harus membuat proyek dari awal lebih dari sekali.  Pada saat yang sama, tim saya dan saya selalu menghabiskan banyak waktu untuk pengaturan dasar proyek, seperti mengintegrasikan alat pihak ketiga, menyiapkan struktur proyek, menulis kelas dasar, mengintegrasikan perpustakaan eksternal, dll. <br><br>  Saya memutuskan bahwa waktu yang dibutuhkan untuk meluncurkan proyek dapat dikurangi, dan bagian utama dari proses dapat otomatis.  Pada saat yang sama, saya mengumpulkan praktik terbaik dan alat yang kami gunakan, dan menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat proyek</a> yang kami gunakan saat memulai proyek baru.  Template seperti itu akan menghemat waktu pengembang untuk mengonfigurasi proyek baru, serta menyediakan struktur proyek bersama, yang akan digunakan oleh setiap anggota tim, sehingga Anda tidak lagi harus berpikir dan mempelajari struktur proyek baru untuknya.  Sekarang selalu sama. <br><br>  Setiap alat atau pendekatan yang ditambahkan ke templat layak mendapatkan artikel terpisah, tetapi saya ingin mencoba merangkum setiap paragraf dan memberikan penjelasan singkat mengapa saya memasukkannya ke dalam artikel ini. <br><a name="habracut"></a><br><h3>  Cocoapods </h3><br>  Saya tidak berpikir Cocoapods membutuhkan pengiriman.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> perpustakaan untuk mengelola dependensi eksternal untuk proyek iOS.  Sudah ada sejak lama dan dapat diandalkan dan terbukti di lapangan dalam ribuan (jika tidak jutaan) proyek.  Ada juga manajer dependensi alternatif, misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Carthage</a> , tetapi saya memutuskan untuk melanjutkan dengan Cocoapods, karena ia memiliki jangkauan terluas dari proyek open source yang didukung.  Menggunakan Cocoapods sangat sederhana dan dilengkapi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks pencarian</a> yang membuatnya mudah untuk menemukan paket yang dapat berguna kapan saja. <br><br>  Proyek templat disediakan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Podfile</a> sederhana yang berisi Swiftlint dan R.swift.  Templat ini juga menyertakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gemfile</a> untuk mengelola versi Cocoapods yang digunakan untuk manajemen ketergantungan.  Solusi ini sering diabaikan oleh pengembang, tetapi mencegah masalah yang terjadi ketika pengembang tim Anda menginstal dependensi menggunakan versi berbeda dari Cocoapods.  Gemfile secara paksa menggunakan versi yang sama dari Cocoapods untuk seluruh tim. <br><br><h3>  Swiftlint </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swiftlint</a> adalah alat yang sangat berguna untuk menegakkan aturan dan gaya penulisan tertentu untuk setiap pengembang di tim yang sama.  Sistem ini dapat dianggap sebagai sistem verifikasi kode otomatis yang memperingatkan pengembang tentang saat-saat berbahaya, seperti, misalnya, gips paksa, uji coba paksa, dll., Selain itu, sistem ini menerapkan gaya umum penulisan kode, pemantauan sehingga semua pengembang mengikuti aturan yang sama dengan "gaya kode", misalnya: indentasi atau interval.  Pendekatan ini memiliki keuntungan besar, tidak hanya menghemat waktu pada verifikasi kode, tetapi juga membuat file proyek dikenali, yang meningkatkan keterbacaan mereka dan, sebagai hasilnya, pemahaman mereka oleh semua anggota tim pengembangan.  <a href="">Tautan</a> ini menyediakan daftar semua aturan.  Dalam template Swiftlint, ia diinstal menggunakan Cocoapods dan termasuk dalam langkah “Tahap Kompilasi”, sehingga ia akan menampilkan peringatan kepada pengembang setiap kali proyek dikompilasi. <br><br><h3>  R. cepat </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R.swift</a> adalah alat untuk memperoleh sumber daya yang sangat diketik secara otomatis, seperti gambar, segmen font, dan pelokalan.  Itu melakukan semua tindakan di atas dengan memindai proyek dan membuat kelas yang diperlukan untuk mendapatkan sumber daya.  Keuntungan terbesar dari perpustakaan ini adalah ketika menggunakan sumber daya, itu membuat kode program: <br><br><ul><li>  <b>Diketik sepenuhnya</b> - lebih sedikit gips dan asumsi tentang metode mana yang akan dikembalikan </li><li>  <b>Waktu kompilasi dicentang</b> - tidak ada lagi garis tidak valid yang menghentikan aplikasi agar tidak berjalan selama eksekusi kode </li><li>  <b>Selesai otomatis</b> - tidak perlu menebak nama <i>gambar / nib / storyboard</i> lagi </li></ul><br>  Pertimbangkan kode berikut menggunakan API string resmi: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> icon = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: “custom-icon”)</code> </pre> <br>  Jika Anda membuat kesalahan dalam nama gambar, Anda akan mendapatkan nol.  Jika ada anggota tim Anda yang mengubah nama sumber daya gambar, kode ini akan mengembalikan nol atau eksekusi akan dihentikan jika Anda memaksa gambar untuk berkembang.  Saat menggunakan R.swift, tampilannya seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> icon = <span class="hljs-type"><span class="hljs-type">R</span></span>.image.customIcon()</code> </pre><br>  Sekarang Anda dapat memastikan bahwa ikon tersebut benar-benar ada (kompiler akan memperingatkan Anda jika tidak, terima kasih atas kompilasi waktu pemeriksaan), dan Anda akan yakin bahwa Anda tidak akan membuat kesalahan ketik atas nama ikon, karena Anda akan menggunakan pelengkapan otomatis. <br><br>  R.swift diinstal menggunakan Cocoapods dan diintegrasikan ke dalam template di Tahap Kompilasi dan akan menghasilkan kelas-kelas shell Swift untuk setiap kompilasi.  Ini berarti bahwa jika Anda menambahkan file / gambar / lokalisasi / font / warna / pena, dll., Semua ini akan tersedia melalui R.swift setelah mengkompilasi proyek. <br><br><h3>  Pisahkan file AppDelegate untuk pengujian </h3><br>  Sangat sering mereka lupa tentang praktik baik menggunakan kelas TestAppDelegate terpisah saat menjalankan tes.  Mengapa ini ide yang bagus?  Biasanya, kelas AppDelegate melakukan banyak pekerjaan ketika aplikasi dimulai.  Itu dapat memiliki logika konfigurasi jendela, mengkonfigurasi tampilan dasar antarmuka pengguna aplikasi, menjalankan logika pendaftaran untuk menerima pemberitahuan, memiliki kode pengaturan koneksi database, dan bahkan kadang-kadang membuat panggilan API server.  Tes unit seharusnya tidak memiliki efek samping.  Anda benar-benar tidak ingin membuat panggilan API acak dan menyesuaikan seluruh struktur antarmuka pengguna aplikasi Anda hanya untuk menjalankan tes unit? <br><br>  TestAppDelegate juga merupakan pilihan yang tepat untuk mendapatkan kode yang ingin Anda jalankan hanya satu kali selama pelaksanaan test suite.  Ini mungkin berisi kode yang menghasilkan objek tiruan, selokan permintaan jaringan, dll. <br><br>  Templat berisi file main.swift, yang merupakan titik masuk utama untuk aplikasi.  Ada metode dalam file ini yang menguji lingkungan aplikasi, dan jika itu adalah lingkungan uji, mereka memanggil TestAppDelegate. <br><br><h3>  Bendera profil kinerja penyusun </h3><br>  Swift adalah bahasa yang hebat, lebih mudah digunakan dan lebih aman daripada Objective-C (IMO).  Tetapi ketika pertama kali diperkenalkan, itu memiliki satu waktu kompilasi besar cacat.  Kembali pada hari-hari ketika saya sedang mengerjakan sebuah proyek di Swift, yang memiliki sekitar 40 ribu baris kode Swift (proyek berukuran sedang).  Kode itu sangat berat, dengan pengaturan dan jenis inferensi, dan menyusun rakitan yang bersih membutuhkan waktu hampir 5 menit.  Jika Anda membuat perubahan kecil, proyek ini dikompilasi ulang dan dibutuhkan sekitar 2 menit untuk melihat perubahannya.  Ini adalah salah satu pengalaman terburuk yang pernah saya alami, dan karena ini, saya hampir berhenti menggunakan Swift. <br><br>  Maka satu-satunya solusi adalah mencoba membuat profil waktu kompilasi proyek dan mengubah kode Anda sehingga kompiler bekerja lebih cepat.  Untuk membantu memecahkan masalah seperti itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple memperkenalkan beberapa flag kompiler tidak resmi</a> yang memperingatkan pengembang bahwa terlalu lama untuk mengkompilasi body metode atau menentukan jenis ekspresi.  Saya menambahkan tanda-tanda ini ke proyek template untuk memperingatkan tentang waktu kompilasi aplikasi Anda yang lama. <br><br>  Saat ini, waktu kompilasi telah menurun secara signifikan, dan pengembang sangat jarang harus mengoptimalkan kode mereka hanya untuk mengurangi waktu kompilasi.  Tetapi tetap lebih baik untuk mengetahui semuanya terlebih dahulu daripada mencoba menyelesaikan masalah ini ketika proyek menjadi terlalu besar. <br><br><h3>  Konfigurasi Dev / Staging / Produksi </h3><br>  Pendekatan lain yang baik (atau, bisa dikatakan, suatu keharusan) adalah memiliki variabel konfigurasi dan lingkungan yang terpisah untuk lingkungan pengembangan, pengujian akhir, dan penerbitan aplikasi.  Saat ini, hampir setiap aplikasi harus bekerja dengan server, dan biasanya server ini digunakan di beberapa lingkungan.  Lingkungan pengembangan digunakan untuk penyebaran harian oleh pengembang untuk menguji kode mereka.  Lingkungan pengujian akhir digunakan untuk membuat rilis stabil atau untuk pengujian oleh penguji dan pelanggan. <br><br>  Salah satu cara untuk mendukung beberapa lingkungan dalam proyek iOS adalah dengan menambahkan konfigurasi di tingkat proyek. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c43/dfd/1e9/c43dfd1e9219cb12b1a7a64c8753a1d0.png" alt="gambar"><br>  <i>Konfigurasi Tingkat Proyek</i> <br><br>  Setelah menetapkan konfigurasi, Anda dapat membuat file Configuration.plist yang berisi variabel untuk setiap lingkungan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/c6a/01a/07ec6a01adefb9cd9ead37330a0f971b.png" alt="gambar"><br>  <i>Configuration.plist</i> <br><br>  Saat memulai proyek, dimungkinkan untuk menunjukkan konfigurasi mana yang harus digunakan.  Anda dapat melakukan ini dalam diagram rakitan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a7/4e1/76d/0a74e176d5bf9a23e631c1b79d1a0f28.png" alt="gambar"><br><br>  Maka Anda perlu menambahkan properti lain ke file proyek Info.plist.  Nilai properti ini akan secara dinamis diganti pada saat runtime atas nama konfigurasi saat ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ff/c1b/672/1ffc1b67277e5872652b294be87ce310.png" alt="gambar"><br>  <i>Semua ini sudah dipra-konfigurasi dalam templat.</i> <br><br>  Tetap hanya untuk menulis kelas yang dapat mengekstrak variabel-variabel ini pada waktu berjalan, tergantung pada konfigurasi yang dipilih dalam skema perakitan.  Templat berisi kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConfigurationManager</a> , yang dapat mengambil variabel untuk lingkungan saat ini.  Anda juga dapat memeriksa implementasi kelas ini di Github untuk melihat cara kerjanya. <br><br><h3>  Readme </h3><br>  Setiap proyek harus berisi file Readme, yang setidaknya berisi instruksi untuk menginstal dependensi dan memulai proyek.  Ini juga harus berisi deskripsi arsitektur dan modul proyek.  Sayangnya, pengembang tidak suka menulis dokumentasi (file readme adalah bagian dari pekerjaan ini), dan saya melihat proyek yang telah dikembangkan selama berbulan-bulan, dan bahkan memiliki file Readme.  Untuk menghapus beban penulisan file readme, templat berisi <a href="">file readme standar</a> yang mencakup instalasi dan struktur proyek.  Saat menyiapkan proyek baru menggunakan templat, Anda secara otomatis menyertakan file Readme. <br><br><h3>  Gitignore </h3><br>  Saat ini, sebagian besar proyek menggunakan GIT sebagai sistem kontrol versi.  Saat menggunakan GIT, pengembang tidak ingin mengabaikan beberapa file atau folder dalam proyek, seperti folder build atau folder data yang diturunkan.  Untuk menyelamatkan pengembang dari keharusan menemukan file gitignore yang cocok untuk proyek iOS-nya, templat tersebut berisi gitignore standar yang disediakan oleh anggota Github. <br><br><h3>  Kelas dasar untuk menangani tautan dan pemberitahuan eksternal </h3><br>  Saat ini, hampir setiap aplikasi harus menangani tautan dan pemberitahuan eksternal.  Untuk melakukan ini, pengembang harus menulis beberapa kode standar di kelas AppDelegate.  Template ini berisi deskripsi tentang bagaimana melakukan ini, itu juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengandung kelas dasar</a> yang memfasilitasi bekerja dengan tautan dan pemberitahuan eksternal. <br><br><h3>  Kesimpulan </h3><br>  Untuk meringkas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">template yang</a> dijelaskan berisi pendekatan terbaik dan mengintegrasikan alat pihak ketiga yang berguna.  Semua ini harus menghemat waktu pengembangan tim Anda untuk menyiapkan proyek baru, serta memberikan fondasi yang umum dan solid untuk sisa proyek.  <i>Biarkan templat ini melayani Anda dan tim Anda untuk keuntungan!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473630/">https://habr.com/ru/post/id473630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473610/index.html">Mem-parsing konsol web Plesk Obsidian yang baru</a></li>
<li><a href="../id473612/index.html">Risalah tentang Pin. Pikiran tentang mengkonfigurasi dan bekerja dengan pin di C ++ untuk mikrokontroler (menggunakan CortexM sebagai contoh)</a></li>
<li><a href="../id473614/index.html">Buku “Head First. Kotlin »</a></li>
<li><a href="../id473626/index.html">“Pengembang ingin membeli pesawat dalam tiga tahun. Tugas saya adalah membantunya ”- Denis Pushkin tentang motivasi Skyeng</a></li>
<li><a href="../id473628/index.html">C ++ dalam layanan ortodontik: wawancara dengan Mikhail Matrosov, pengembang CAD di Align Technology</a></li>
<li><a href="../id473632/index.html">Kami melihat sebuah artikel tentang Habr</a></li>
<li><a href="../id473634/index.html">Lobb Comcast melarang enkripsi DNS</a></li>
<li><a href="../id473636/index.html">Unduh torrent 16GB via tablet dengan ruang kosong 4GB</a></li>
<li><a href="../id473638/index.html">Shader bukanlah sihir. Menulis shader di Unity. Pendahuluan</a></li>
<li><a href="../id473640/index.html">Sunset Data Besar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>