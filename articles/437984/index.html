<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£ ü§¥üèΩ üßò Subprocesamiento en Node.js: m√≥dulo trabajador_procesos üîÄ üìû ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El 18 de enero, se anunci√≥ la plataforma Node.js versi√≥n 11.7.0 . Entre los cambios notables en esta versi√≥n, se puede observar la conclusi√≥n de la ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Subprocesamiento en Node.js: m√≥dulo trabajador_procesos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  El 18 de enero, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se anunci√≥</a> la plataforma Node.js versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">11.7.0</a> .  Entre los cambios notables en esta versi√≥n, se puede observar la conclusi√≥n de la categor√≠a de m√≥dulos experimentales worker_threads, que apareci√≥ en Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">10.5.0</a> .  Ahora no se necesita la bandera --experimental-worker para usarlo.  Este m√≥dulo, desde su inicio, se ha mantenido bastante estable y, por lo tanto, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tom√≥</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decisi√≥n</a> , reflejada en Node.js 11.7.0. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  El autor del material, cuya traducci√≥n estamos publicando, ofrece discutir las capacidades del m√≥dulo worker_threads, en particular, quiere hablar sobre por qu√© se necesita este m√≥dulo y c√≥mo se implementa el subprocesamiento m√∫ltiple en JavaScript y Node.js por razones hist√≥ricas.  Aqu√≠ hablaremos sobre qu√© problemas est√°n asociados con la escritura de aplicaciones JS multiproceso, sobre las formas existentes de resolverlos y sobre el futuro del procesamiento de datos en paralelo utilizando los llamados "hilos de trabajo", que a veces se llaman "hilos de trabajo" o simplemente "trabajadores". <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La vida en un mundo de un solo hilo.</font> </h2><br>  JavaScript fue concebido como un lenguaje de programaci√≥n de un solo hilo que se ejecuta en un navegador.  "Single-thread" significa que en el mismo proceso (en los navegadores modernos estamos hablando de pesta√±as separadas del navegador), solo se puede ejecutar un conjunto de instrucciones a la vez. <br><br>  Esto simplifica el desarrollo de aplicaciones, facilita el trabajo de los programadores.  Inicialmente, JavaScript era un lenguaje adecuado solo para agregar algunas caracter√≠sticas interactivas a las p√°ginas web, por ejemplo, algo as√≠ como la validaci√≥n de formularios.  Entre las tareas para las que JS fue dise√±ado, no hab√≠a nada particularmente complicado que requiera subprocesamiento m√∫ltiple. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ryan Dahl</a> , creador de Node.js, vio una oportunidad interesante en esta restricci√≥n de idioma.  Quer√≠a implementar una plataforma de servidor basada en un subsistema de E / S as√≠ncrono.  Esto significaba que el programador no necesitaba trabajar con hilos, lo que simplifica enormemente el desarrollo para una plataforma similar.  Al desarrollar programas dise√±ados para la ejecuci√≥n de c√≥digo paralelo, pueden surgir problemas que son muy dif√≠ciles de resolver.  Supongamos que si varios subprocesos intentan acceder a la misma √°rea de memoria, esto puede conducir al llamado "estado de carrera de proceso" que interrumpe el programa.  Tales errores son dif√≠ciles de reproducir y corregir. <br><br><h2>  <font color="#3AC1EF">¬øLa plataforma Node.js tiene un solo subproceso?</font> </h2><br>  ¬øLas aplicaciones Node.js tienen un solo subproceso?  S√≠, en cierto modo lo es.  De hecho, Node.js le permite realizar ciertas acciones en paralelo, pero para esto, el programador no necesita crear hilos o sincronizarlos.  La plataforma Node.js y el sistema operativo realizan operaciones paralelas de entrada / salida utilizando sus propios medios, y cuando llega el momento del procesamiento de datos utilizando nuestro c√≥digo JavaScript, funciona en modo de subproceso √∫nico. <br><br>  En otras palabras, todo excepto nuestro c√≥digo JS funciona en paralelo.  En bloques s√≠ncronos de c√≥digo JavaScript, los comandos siempre se ejecutan uno a la vez, en el orden en que se presentan en el c√≥digo fuente: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  Todo esto es excelente, si todo nuestro c√≥digo est√° ocupado con E / S asincr√≥nicas.  El programa consta de peque√±os bloques de c√≥digo s√≠ncrono que operan r√°pidamente en los datos, por ejemplo, enviados a archivos y transmisiones.  El c√≥digo de los fragmentos del programa es tan r√°pido que no bloquea la ejecuci√≥n del c√≥digo de sus otros fragmentos.  Mucho m√°s tiempo que la ejecuci√≥n del c√≥digo para esperar los resultados de las E / S as√≠ncronas.  Considere un peque√±o ejemplo: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Es posible que la consulta a la base de datos que se muestra aqu√≠ demore aproximadamente un minuto, pero el mensaje de <code>Running query</code> se enviar√° a la consola inmediatamente despu√©s de que se inicie esta consulta.  En este caso, el mensaje <code>Hey there</code> se mostrar√° un segundo despu√©s de que se ejecute la solicitud, independientemente de si su ejecuci√≥n se ha completado o no.  Nuestra aplicaci√≥n Node.js simplemente llama a la funci√≥n que inicia la solicitud, mientras que la ejecuci√≥n de su otro c√≥digo no est√° bloqueada.  Una vez completada la solicitud, se informar√° a la aplicaci√≥n acerca de esto mediante la funci√≥n de devoluci√≥n de llamada, y luego recibir√° una respuesta a esta solicitud. <br><br><h2>  <font color="#3AC1EF">Tareas intensivas de CPU</font> </h2><br>  ¬øQu√© sucede si nosotros, a trav√©s de JavaScript, necesitamos hacer computaci√≥n pesada?  Por ejemplo, ¬øpara procesar un gran conjunto de datos almacenados en la memoria?  Esto puede llevar al hecho de que el programa contendr√° un fragmento de c√≥digo s√≠ncrono, cuya ejecuci√≥n lleva mucho tiempo y bloquea la ejecuci√≥n de otro c√≥digo.  Imagine que estos c√°lculos tardan 10 segundos.  Si estamos hablando de un servidor web que procesa una determinada solicitud, esto significar√° que no podr√° procesar otras solicitudes durante al menos 10 segundos.  Este es un gran problema.  De hecho, los c√°lculos que son m√°s largos que 100 milisegundos ya pueden causar este problema. <br><br>  JavaScript y la plataforma Node.js no se dise√±aron originalmente para resolver tareas que utilizan los recursos del procesador de forma intensiva.  En el caso de JS ejecut√°ndose en el navegador, realizar tales tareas significa "frenos" en la interfaz de usuario.  En Node.js, esto puede limitar la capacidad de solicitar a la plataforma que realice nuevas tareas de E / S asincr√≥nicas y la capacidad de responder a eventos asociados con su finalizaci√≥n. <br><br>  Volvamos a nuestro ejemplo anterior.  Imagine que, en respuesta a una consulta a la base de datos, llegaron varios miles de registros cifrados que, en c√≥digo JS sincr√≥nico, deben descifrarse: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Los resultados, despu√©s de recibirlos, est√°n en la funci√≥n de devoluci√≥n de llamada.  Despu√©s de eso, hasta el final de su procesamiento, no se puede ejecutar ning√∫n otro c√≥digo JS.  Por lo general, como ya se mencion√≥, la carga en el sistema creada por dicho c√≥digo es m√≠nima, realiza r√°pidamente las tareas que se le asignan.  Pero en este caso, el programa recibi√≥ los resultados de la consulta, que tienen una cantidad considerable, y a√∫n necesitamos procesarlos.  Algo como esto puede tomar unos segundos.  Si estamos hablando de un servidor con el que trabajan muchos usuarios, esto significar√° que pueden continuar trabajando solo despu√©s de la finalizaci√≥n de una operaci√≥n de uso intensivo de recursos. <br><br><h2>  <font color="#3AC1EF">¬øPor qu√© JavaScript nunca tendr√° hilos?</font> </h2><br>  Dado lo anterior, puede parecer que para resolver problemas inform√°ticos pesados ‚Äã‚Äãen Node.js necesita agregar un nuevo m√≥dulo que le permitir√° crear hilos y administrarlos.  ¬øC√≥mo puedes prescindir de algo as√≠?  Es muy triste que aquellos que usan una plataforma de servidor madura, como Node.js, no tengan los medios para resolver los problemas asociados con el procesamiento de grandes cantidades de datos. <br><br>  Todo esto es cierto, pero si agrega la capacidad de trabajar con secuencias en JavaScript, esto conducir√° a un cambio en la naturaleza misma de este lenguaje.  En JS, no puede simplemente agregar la capacidad de trabajar con hilos, por ejemplo, en forma de un nuevo conjunto de clases o funciones.  Para hacer esto, debe cambiar el idioma en s√≠.  En lenguajes que admiten subprocesos m√∫ltiples, el concepto de sincronizaci√≥n es ampliamente utilizado.  Por ejemplo, en Java, incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunos tipos num√©ricos</a> no son at√≥micos.  Esto significa que si no se utilizan mecanismos de sincronizaci√≥n para trabajar con ellos desde diferentes subprocesos, todo esto puede resultar, por ejemplo, despu√©s de que un par de subprocesos intenten simult√°neamente cambiar el valor de la misma variable, varios bytes de dicha variable se establecer√°n en uno flujo, y algunos otros.  Como resultado, dicha variable contendr√° algo incompatible con el funcionamiento normal del programa. <br><br><h2>  <font color="#3AC1EF">Soluci√≥n primitiva al problema: iteraci√≥n del bucle de eventos</font> </h2><br>  Node.js no ejecutar√° el siguiente bloque de c√≥digo en la cola de eventos hasta que se complete el bloque anterior.  Esto significa que para resolver nuestro problema, podemos <code>setImmediate(callback)</code> en partes representadas por fragmentos de c√≥digo s√≠ncrono y luego usar una construcci√≥n del formulario <code>setImmediate(callback)</code> para planificar la ejecuci√≥n de estos fragmentos.  El c√≥digo especificado por la funci√≥n de <code>callback</code> en esta construcci√≥n se ejecutar√° despu√©s de que se completen las tareas de la iteraci√≥n actual (tick) del bucle de eventos.  Despu√©s de eso, se usa el mismo dise√±o para poner en cola el siguiente lote de c√°lculos.  Esto permite no bloquear el ciclo de eventos y, al mismo tiempo, resolver problemas volum√©tricos. <br><br>  Imagine que tenemos una gran matriz que necesita ser procesada, mientras que el procesamiento de cada elemento de dicha matriz requiere c√°lculos complejos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Como ya se mencion√≥, si decidimos procesar toda la matriz en una llamada, tomar√° demasiado tiempo y evitar√° que se ejecute otro c√≥digo de aplicaci√≥n.  Por lo tanto, <code>setImmediate(callback)</code> esta gran tarea en partes y usaremos la <code>setImmediate(callback)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Ahora, de una vez, procesamos diez elementos de la matriz, despu√©s de lo cual, usando <code>setImmediate()</code> , planificamos el pr√≥ximo lote de c√°lculos.  Y esto significa que si necesita ejecutar m√°s c√≥digo en el programa, puede ejecutarse entre operaciones en el procesamiento de fragmentos de la matriz.  Para esto, aqu√≠, al final del ejemplo, hay un c√≥digo que usa <code>setInterval()</code> . <br><br>  Como puede ver, dicho c√≥digo parece mucho m√°s complicado que su versi√≥n original.  Y, a menudo, el algoritmo puede ser mucho m√°s complejo que el nuestro, lo que significa que, cuando se implementa, no ser√° f√°cil dividir los c√°lculos en pedazos y comprender d√≥nde, para lograr el equilibrio correcto, debe establecer <code>setImmediate()</code> , planeando el siguiente c√°lculo.  Adem√°s, el c√≥digo ahora result√≥ ser as√≠ncrono, y si nuestro proyecto depende de bibliotecas de terceros, es posible que no podamos dividir el proceso de resolver una tarea dif√≠cil en partes. <br><br><h2>  <font color="#3AC1EF">Procesos de fondo</font> </h2><br>  Quiz√°s el enfoque anterior con <code>setImmediate()</code> funcionar√° bien para casos simples, pero est√° lejos de ser ideal.  Adem√°s, los hilos no se usan aqu√≠ (por razones obvias) y tampoco tenemos la intenci√≥n de cambiar el idioma para esto.  ¬øEs posible hacer un procesamiento paralelo de datos sin usar hilos?  S√≠, es posible, y para esto necesitamos alg√∫n tipo de mecanismo para el procesamiento de datos en segundo plano.  Se trata de comenzar una determinada tarea, pasarle datos, y para que esta tarea, sin interferir con el c√≥digo principal, use todo lo que necesita, pase todo el tiempo que necesita y luego devuelva los resultados a c√≥digo principal  Necesitamos algo similar al siguiente fragmento de c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  La realidad es que en Node.js puedes usar procesos en segundo plano.  El punto es que es posible crear una bifurcaci√≥n del proceso e implementar el esquema de trabajo descrito anteriormente utilizando el mecanismo de mensajer√≠a entre los procesos hijo y padre.  El proceso principal puede interactuar con el proceso descendiente, envi√°ndole eventos y recibi√©ndolos.  La memoria compartida no se usa con este enfoque.  Todos los datos intercambiados por los procesos son "clonados", es decir, cuando un proceso realiza cambios en una instancia de estos datos, estos cambios no son visibles para otro proceso.  Esto es similar a una solicitud HTTP: cuando un cliente la env√≠a al servidor, el servidor recibe solo una copia de la misma.  Si los procesos no usan memoria compartida, esto significa que con su operaci√≥n simult√°nea es imposible crear un "estado de carrera", y que no necesitamos cargarnos con el trabajo con hilos.  Parece que nuestro problema ha sido resuelto. <br><br>  Es cierto, en realidad esto no es as√≠.  S√≠, frente a nosotros est√° una de las soluciones a la tarea de realizar c√°lculos intensivos, pero, una vez m√°s, es imperfecta.  Crear una bifurcaci√≥n de un proceso es una operaci√≥n que requiere muchos recursos.  Lleva tiempo completarlo.  De hecho, estamos hablando de crear una nueva m√°quina virtual desde cero y de aumentar la cantidad de memoria consumida por el programa, debido a que los procesos no usan memoria compartida.  Dado lo anterior, es apropiado preguntar si es posible, despu√©s de completar una tarea, reutilizar la bifurcaci√≥n del proceso.  Puede dar una respuesta positiva a esta pregunta, pero aqu√≠ debe recordar que est√° previsto transferir la bifurcaci√≥n del proceso a varias tareas intensivas en recursos que se realizar√°n en √©l de forma sincronizada.  Se pueden ver dos problemas aqu√≠: <br><br><ul><li>  Aunque con este enfoque, el proceso principal no se bloquea, el proceso descendiente puede realizar las tareas que se le transfieren solo secuencialmente.  Si tenemos dos tareas, una de las cuales toma 10 segundos, y la segunda toma 1 segundo, y las vamos a completar en este orden, entonces es poco probable que nos guste la necesidad de esperar a que se complete la primera antes de la segunda.  Dado que estamos creando horquillas de proceso, nos gustar√≠a usar las capacidades del sistema operativo para planificar tareas y usar los recursos inform√°ticos de todos los n√∫cleos de nuestro procesador.  Necesitamos algo que se parezca a trabajar en una computadora para una persona que escucha m√∫sica y viaja a trav√©s de p√°ginas web.  Para hacer esto, puede crear dos procesos fork y organizar la ejecuci√≥n paralela de tareas con su ayuda. </li><li>  Adem√°s, si una de las tareas lleva al final del proceso con un error, todas las tareas enviadas a dicho proceso no se procesar√°n. </li></ul><br>  Para resolver estos problemas, necesitamos varios procesos de fork, no uno, pero tendremos que limitar su n√∫mero, ya que cada uno de ellos requiere recursos del sistema y lleva tiempo crearlos.  Como resultado, siguiendo el patr√≥n de sistemas que admiten conexiones de bases de datos, necesitamos algo as√≠ como un conjunto de procesos listos para usar.  El sistema de gesti√≥n de agrupaci√≥n de procesos, al recibir nuevas tareas, utilizar√° procesos libres para ejecutarlas, y cuando un determinado proceso haga frente a la tarea, podr√° asignarle una nueva.  Existe la sensaci√≥n de que dicho esquema de trabajo no es f√°cil de implementar y, de hecho, lo es.  Usaremos el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajador-granja</a> para implementar este esquema: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">M√≥dulo de hilos de trabajo</font> </h2><br>  Entonces, ¬øest√° resuelto nuestro problema?  S√≠, podemos decir que est√° resuelto, pero con este enfoque, se requiere mucha m√°s memoria de la que ser√≠a necesaria si tuvi√©ramos una soluci√≥n multiproceso.  Los subprocesos consumen muchos menos recursos en comparaci√≥n con las horquillas de proceso.  Es por eso que el m√≥dulo <code>worker_threads</code> apareci√≥ en <code>worker_threads</code> <br><br>  Los subprocesos de trabajo se ejecutan en un contexto aislado.  Intercambian informaci√≥n con el proceso principal utilizando mensajes.  Esto nos salva del problema de "condici√≥n de carrera" al que est√°n sujetos los entornos de subprocesos m√∫ltiples.  Al mismo tiempo, existen flujos de trabajadores en el mismo proceso que el programa principal, es decir, con este enfoque, en comparaci√≥n con el uso de horquillas de proceso, se usa mucha menos memoria. <br><br>  Adem√°s, al trabajar con trabajadores, puede usar la memoria compartida.  Entonces, espec√≠ficamente para este prop√≥sito, se <code>SharedArrayBuffer</code> objetos del tipo <code>SharedArrayBuffer</code> .  Deben usarse solo en aquellos casos en que el programa necesita realizar un procesamiento complejo de grandes cantidades de datos.  Le permiten guardar los recursos necesarios para serializar y deserializar datos al organizar el intercambio de datos entre los trabajadores y el programa principal a trav√©s de mensajes. <br><br><h2>  <font color="#3AC1EF">Trabajador Flujos de trabajadores</font> </h2><br>  Si usa la plataforma Node.js antes de la versi√≥n 11.7.0, para habilitar el trabajo con el m√≥dulo <code>worker_threads</code> , debe usar el <code>--experimental-worker</code> al iniciar <code>--experimental-worker</code> <br><br>  Adem√°s, vale la pena recordar que crear un trabajador (as√≠ como crear una secuencia en cualquier idioma), aunque requiere muchos menos recursos que crear una bifurcaci√≥n de un proceso, tambi√©n crea una cierta carga en el sistema.  Quiz√°s en su caso, incluso esta carga puede ser demasiado.  En tales casos, la documentaci√≥n recomienda crear un grupo de trabajadores.  Si necesita esto, por supuesto, puede crear su propia implementaci√≥n de dicho mecanismo, pero tal vez deber√≠a buscar algo adecuado en el registro de NPM. <br><br>  Considere un ejemplo de trabajo con hilos de trabajo.  Tendremos un archivo principal, <code>index.js</code> , en el que crearemos un subproceso de trabajo y le pasaremos algunos datos para su procesamiento.  La API correspondiente est√° basada en eventos, pero voy a usar una promesa aqu√≠ que se resuelve cuando llega el primer mensaje del trabajador: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Como puede ver, usar el mecanismo de flujo de flujo de trabajo es bastante simple.  Es decir, al crear un trabajador, debe pasar la ruta al archivo con el c√≥digo y los datos del <code>Worker</code> dise√±ador del <code>Worker</code> .  Recuerde que estos datos est√°n clonados, no almacenados en la memoria compartida.  Despu√©s de comenzar el trabajador, esperamos un mensaje de √©l, escuchando el evento del <code>message</code> . <br><br>  Arriba, al crear un objeto de tipo <code>Worker</code> , le pasamos al constructor el nombre del archivo con el c√≥digo de trabajador: <code>service.js</code> .  Aqu√≠ est√° el c√≥digo para este archivo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  Hay dos cosas que nos interesan en el c√≥digo del trabajador.  Primero, necesitamos los datos transmitidos por la aplicaci√≥n principal.  En nuestro caso, est√°n representados por la variable <code>workerData</code> .  En segundo lugar, necesitamos un mecanismo para transmitir informaci√≥n a la aplicaci√≥n principal.  Este mecanismo est√° representado por el objeto <code>parentPort</code> , que tiene el m√©todo <code>postMessage()</code> , mediante el cual pasamos los resultados del procesamiento de datos a la aplicaci√≥n principal.  As√≠ es como funciona todo. <br><br>  Aqu√≠ hay un ejemplo muy simple, pero usando los mismos mecanismos puedes construir estructuras mucho m√°s complejas.  Por ejemplo, desde la transmisi√≥n de un trabajador, puede enviar muchos mensajes a la transmisi√≥n principal que contienen informaci√≥n sobre el estado del procesamiento de datos en caso de que nuestra aplicaci√≥n necesite un mecanismo similar.  Incluso del trabajador, los resultados del procesamiento de datos se pueden devolver en partes.  Por ejemplo, algo como esto puede ser √∫til en una situaci√≥n en la que un trabajador est√° ocupado, por ejemplo, procesando miles de im√°genes, y usted, sin esperar a que se procesen todas, desea notificar a la aplicaci√≥n principal la finalizaci√≥n del procesamiento de cada una de ellas. <br><br>  Los detalles sobre el m√≥dulo <code>worker_threads</code> se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  <font color="#3AC1EF">Trabajadores web</font> </h2><br>  Es posible que haya o√≠do hablar de los trabajadores web.  Est√°n dise√±ados para su uso en un entorno de cliente, esta tecnolog√≠a ha existido durante mucho tiempo y goza de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen soporte para</a> los navegadores modernos.  La API para trabajar con trabajadores web es diferente de la que nos proporciona el m√≥dulo Node.js <code>worker_threads</code> , se trata de las diferencias en los entornos en los que trabajan.  Sin embargo, estas tecnolog√≠as pueden resolver problemas similares.  Por ejemplo, los trabajadores web pueden usarse en aplicaciones cliente para realizar cifrado y descifrado de datos, su compresi√≥n y descompresi√≥n.  Con su ayuda, puede procesar im√°genes, implementar sistemas de visi√≥n por computadora (por ejemplo, estamos hablando de reconocimiento facial) y resolver otros problemas similares en un navegador. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  <code>worker_threads</code> ‚Äî     Node.js.    ,    ,   .       , ,       ,         ¬´ ¬ª.   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Estimados lectores!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437984/">https://habr.com/ru/post/437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437974/index.html">¬øC√≥mo ganar WorldSkills digitales? En un ejemplo pr√°ctico</a></li>
<li><a href="../437976/index.html">"Vkontakte" permiti√≥ ocultar registros individuales de la polic√≠a</a></li>
<li><a href="../437978/index.html">Bienvenido a SphinxSearch-meetup SuperJob</a></li>
<li><a href="../437980/index.html">Abrir el seminario web "M√©todo de prueba por pares en la prueba de recuadro negro"</a></li>
<li><a href="../437982/index.html">El nuevo ataque de cifrado de Shade apunta a usuarios comerciales rusos</a></li>
<li><a href="../437986/index.html">¬øPor qu√© TypeScript es el coraz√≥n de cada nueva aplicaci√≥n web de PayPal?</a></li>
<li><a href="../437988/index.html">Tutorial de React, Parte 12: Taller, Fase 3 Aplicaci√≥n TODO</a></li>
<li><a href="../437990/index.html">Tutorial React Parte 13: Componentes basados ‚Äã‚Äãen clases</a></li>
<li><a href="../437992/index.html">Microservicios Versiones en sistemas de integraci√≥n continua y despliegue Estudio de caso de CI / CD usando TFS</a></li>
<li><a href="../437994/index.html">Orde√±o autom√°tico e invernaderos autom√°ticos: c√≥mo funciona una peque√±a granja de alta tecnolog√≠a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>