<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏼 🌙 🚬 Analizador de código estático PVS-Studio como protección contra vulnerabilidades de día cero 📟 😗 🤖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zero Day Threat es un término para las vulnerabilidades de desarrollo que aún no se han descubierto. Dichas vulnerabilidades pueden ser explotadas por...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizador de código estático PVS-Studio como protección contra vulnerabilidades de día cero</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477840/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/wn/yg/mo/wnygmobm1xqfcuxn4cmsqzay8lg.png" alt="Analizador de código estático PVS-Studio como protección contra vulnerabilidades de día cero"></div><br>  Zero Day Threat es un término para las vulnerabilidades de desarrollo que aún no se han descubierto.  Dichas vulnerabilidades pueden ser explotadas por los ciberdelincuentes, lo que finalmente afectará la reputación de la empresa.  Los desarrolladores se enfrentan a la tarea de minimizar la cantidad de defectos en el código que podrían causar tal vulnerabilidad.  Una de las herramientas para ayudar a identificar fallas de seguridad es el analizador de código estático PVS-Studio para C, C ++, C #, Java. <br><a name="habracut"></a><br><h2>  Amenaza de día cero </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%258F%25D0%25B7%25D0%25B2%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BD%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B4%25D0%25BD%25D1%258F">Amenaza de día cero</a> es un término que identifica brechas y vulnerabilidades permitidas por los desarrolladores, pero que aún no se han descubierto.  Hasta que se corrija la vulnerabilidad, se puede usar para acceder a redes, controlar remotamente una computadora, manipular datos, etc.  Este nombre del término está bien establecido debido al hecho de que los desarrolladores no tienen un día para arreglar el defecto, ya que nadie lo sabe aún.  A su debido tiempo, grandes empresas y software como <a href="https://www.anti-malware.ru/news/2010-10-28/3192">Adobe</a> , <a href="https://threatpost.ru/windows-deletebug-zero-day-allows-privilege-escalation-destruction/28888/">Windows</a> , el <a href="https://www.make-info.com/zero-day-vulnerability-in-tor/">navegador Tor</a> y muchos otros sufrieron tales vulnerabilidades. <br><br>  Algunas organizaciones tuvieron suerte, su vulnerabilidad fue encontrada por personas que no iban a usarla, y simplemente proporcionaron información sobre el problema.  Por ejemplo, esto fue con <a href="https://securityaffairs.co/wordpress/86543/hacking/synthetic-clicks-macos-0day.html">MacOS</a> .  O hubo una actualización que, además de las nuevas características, también reparó accidentalmente la amenaza de día cero. <br><br>  Sin embargo, hubo otras situaciones.  Por ejemplo, Google Chrome tuvo que corregir urgentemente una <a href="https://3dnews.ru/996818">vulnerabilidad</a> que permitía a un atacante ejecutar remotamente código arbitrario en el dispositivo de la víctima. <br><br>  El problema con esta amenaza es que es imposible defenderse al 100%, ya que es difícil defenderse contra lo que aún no sabe.  Sin embargo, hay formas de reducir la probabilidad de tal amenaza en su proyecto, y las discutiremos más adelante, pero para comenzar con una pequeña teoría. <br><br><h2>  Análisis estático </h2><br>  El análisis de código estático es el proceso de verificar el código del programa por el analizador sin iniciar el programa en sí.  El análisis estático se puede considerar como un proceso de revisión de código automatizado.  En algunos casos, la efectividad del análisis estático es superior a la revisión de código, pero varios programadores no pueden considerarla como una alternativa completa a la revisión de código.  A continuación, intenté describir brevemente los pros y los contras de la revisión de código y el análisis de código estático entre sí. <br><div class="scrollable-table"><table><tbody><tr><th>  Revisión de código <br></th><th>  Análisis estático <br></th></tr><tr><td>  La capacidad de identificar no solo errores simples, sino también de alto nivel <br></td><td>  Puede encontrar errores sin siquiera saber acerca de este patrón de defectos o vulnerabilidades <br></td></tr><tr><td>  La arquitectura de la aplicación mejora y se desarrolla un estilo de codificación unificado. <br></td><td>  Puede encontrar errores que son difíciles de buscar durante la revisión del código (por ejemplo, errores tipográficos) <br></td></tr><tr><td>  Alto precio <br></td><td>  Precio más bajo que la revisión de código <br></td></tr><tr><td> A los programadores les lleva mucho tiempo.  Es necesario tomar descansos, ya que la atención se atenúa rápidamente <br></td><td>  Inevitables falsos positivos y la necesidad de sintonizar el analizador <br></td></tr></tbody></table></div><h2>  CVE y CWE </h2><br>  Common Vulnerabilities and Exposures (CVE) es una base de datos de errores de software que pueden ser utilizados por ciberdelincuentes.  CVE fue creado para optimizar defectos de software conocidos.  La mayoría de las herramientas de seguridad de la información usaban sus propias bases de datos y nombres, y para eliminar este caos y agregar compatibilidad con varias herramientas, MITRE en 1999 creó CVE.  Sin embargo, CVE no fue suficiente para evaluar la seguridad del código.  Esto requiere algo más preciso, con una descripción detallada de los problemas y menos burda que ella.  Por lo tanto, se creó la base de Enumeración de Debilidad Común (CWE) que cumple con estos requisitos.  Si el error está en la lista CWE, entonces es probable que conduzca a una vulnerabilidad que podría ser explotada por el atacante y entrar en la lista CVE.  Para mayor claridad, puede mirar el diagrama de Euler a continuación. <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/02/l7/ec02l74mwthliqvd97vw2cqmblq.png" alt="CVE, CWE"></div><br>  Algunos analizadores estáticos pueden decirle al desarrollador que, por ejemplo, el proyecto usa la biblioteca en la que se encuentra la vulnerabilidad.  Esto le permite elegir una versión más nueva de la biblioteca en la que ya se ha solucionado la vulnerabilidad y reducir la probabilidad de que surjan problemas con las amenazas derivadas del código de otra persona. <br><br>  Con el advenimiento del desarrollo de las listas CVE y CWE, muchas herramientas de seguridad de la información se han encargado de su soporte, incluidos los analizadores estáticos.  Dichos analizadores pueden considerarse como una solución SAST.  SAST (Static Application Security Testing) permite a los desarrolladores encontrar vulnerabilidades en el código fuente de la aplicación ya en las primeras etapas del ciclo de vida del desarrollo de software. <br><br>  Usar SAST en el desarrollo es otra opción para minimizar la probabilidad de una amenaza de día cero.  El analizador, al clasificar sus errores de acuerdo con el CWE, puede determinar dónde se esconde una posible vulnerabilidad.  Y al corregir estos errores, el desarrollador hace que su aplicación sea más confiable y reduce la probabilidad de una amenaza de 0 días. <br><br>  Existen varias herramientas para las pruebas de seguridad estática.  Para demostrar las capacidades en el manejo de vulnerabilidades, analicemos la herramienta <a href="https://www.viva64.com/ru/sast/">PVS-Studio</a> .  Las advertencias de este analizador se pueden clasificar como CWE.  Veamos algunos ejemplos. <br><br>  Advertencia PVS-Studio: <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> : Código muerto ( <a href="https://www.viva64.com/ru/w/v3021/">V3021</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncodeImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"inputPath"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"outputPath"</span></span>); } .... }</code> </pre> <br>  Este código inadvertidamente hizo un error tipográfico.  En dos condiciones <i>si</i> , se verifica la misma variable.  A juzgar por la excepción generada, en la segunda condición se debe verificar la variable <i>outputPath</i> .  Como resultado, parte del código es inalcanzable. <br><br>  Tales errores parecen inofensivos a primera vista.  Sin embargo, esta impresión puede ser muy engañosa.  Considere un error muy simple e inofensivo a primera vista relacionado con la duplicación del operador <i>goto</i> . <br><br>  En un momento, este error causó una vulnerabilidad en el sistema operativo iOS. <br><br>  Descripción de la vulnerabilidad <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-1266">CVE-2014-1266</a> : La función SSLVerifySignedServerKeyExchange en libsecurity_ssl / lib / sslKeyExchange.c en la función de transporte seguro en el componente de seguridad de datos en Apple iOS 6.x antes de 6.1.6 y 7.x antes de 7.0.6, Apple TV 6.x antes de 6.0.2, y Apple OS X 10.9.x antes de 10.9.2 no verifica la firma en un mensaje de intercambio de claves del servidor TLS, que permite a los atacantes intermedios falsificar servidores SSL mediante el uso de un arbitrario clave privada para el paso de firma u omitir el paso de firma. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OSStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSLVerifySignedServerKeyExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSLContext *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isRsa, SSLBuffer signedParams, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *signature, UInt16 signatureLen)</span></span></span><span class="hljs-function"> </span></span>{ OSStatus err; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; .... fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br>  Debido al doble <i>goto</i> , también surge una situación con código inalcanzable.  Independientemente de las condiciones, la segunda <i>instrucción</i> goto se ejecutará en las instrucciones <i>if</i> .  Esto lleva al hecho de que no se verifica la firma.  La función devuelve 0, lo que significa que todo está bien con la firma, y ​​luego el programa recibe la clave del servidor, incluso si hay un problema con la firma.  Esta clave es necesaria para cifrar datos durante la transmisión. <br><br>  Las consecuencias de un error tan simple fueron muy graves.  Por lo tanto, no tiene sentido argumentar cuán peligroso se clasifica este o aquel error como CWE.  Solo necesita ser reparado, lo que hace que el código sea más seguro. <br><br>  Por cierto, el error descrito podría ser fácilmente detectado por el analizador PVS-Studio.  Daría dos advertencias de CWE aquí de inmediato: <br><br><ul><li>  <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> ( <a href="https://www.viva64.com/ru/w/v779/">V779</a> ): Código muerto </li><li>  <a href="https://cwe.mitre.org/data/definitions/483.html">CWE-483</a> ( <a href="https://www.viva64.com/ru/w/v640/">V640</a> ): Delimitación de bloque incorrecta </li></ul><br>  Veamos otro ejemplo.  En 2012, se supo sobre el problema de seguridad en MySQL, en el que un atacante podía ingresar a la base de datos MySQL.  Proporcionaré un fragmento de código que sirvió como razón para esto. <br><br>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2012-2122">Descripción de CVE-2012-2122</a> : sql / password.c en Oracle MySQL 5.1.x antes de 5.1.63, 5.5.x antes de 5.5.24 y 5.6.x antes de 5.6.6, y MariaDB 5.1.x antes de 5.1.62, 5.2.x antes de 5.2.12, 5.3.x antes de 5.3.6 y 5.5.x antes de 5.5.23, cuando se ejecuta en ciertos entornos con ciertas implementaciones de la función memcmp, permite a los atacantes remotos omitir la autenticación autenticándose repetidamente con el mismo contraseña incorrecta, que eventualmente hace que una comparación de tokens tenga éxito debido a un valor de retorno incorrectamente verificado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> my_bool; <span class="hljs-function"><span class="hljs-function">my_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_scramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scramble_arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  El tipo de retorno de la función <i>memcmp es int</i> , y el tipo de retorno de la función <i>check_scramble es my_bool</i> , de hecho, <i>char</i> .  Como resultado, un <i>int se</i> convierte en un <i>char</i> , en el que se descartan los bits de orden superior.  Esto llevó al hecho de que en aproximadamente 1 de cada 256 casos, era posible conectarse con cualquier contraseña, conociendo el nombre de usuario. <br><br>  Nuevamente, este error CWE podría neutralizarse y evitar que se convierta en un CVE incluso en la etapa de escritura del código.  Por ejemplo, el analizador estático PVS-Studio genera la siguiente advertencia: <a href="https://cwe.mitre.org/data/definitions/197.html">CWE-197</a> ( <a href="https://www.viva64.com/ru/w/v642/">V642</a> ): Error de truncamiento numérico. <br><br>  A continuación de este tema, propongo consultar el artículo " <a href="https://www.viva64.com/ru/b/0514/">¿Cómo puede ayudar PVS-Studio a buscar vulnerabilidades?</a> ". <br><br><h2>  Conclusión </h2><br>  Vulnerabilidades de 0 días: algo de lo que no hay protección garantizada.  Pero la probabilidad de que ocurran puede reducirse significativamente.  Para esto, se pueden utilizar soluciones SAST especializadas como PVS-Studio.  Si su proyecto detecta errores que pueden clasificarse como CWE, entonces debe prestarles atención y corregirlos.  A pesar de que solo una pequeña cantidad de CWE llenará la lista de CVE al eliminar los errores de CWE, protege su aplicación de muchas amenazas potenciales. <br><br><h2>  Enlaces de sitio </h2><br><ol><li>  <a href="https://www.viva64.com/ru/pvs-studio-download/">Descargue y pruebe PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0592/">Tecnologías utilizadas en el analizador de código PVS-Studio para buscar errores y vulnerabilidades potenciales</a> </li><li>  <a href="https://www.viva64.com/ru/cwe/">Clasificación de advertencia de PVS-Studio según la enumeración de debilidad común (CWE)</a> </li><li>  <a href="https://www.viva64.com/ru/cert/">Clasificación de advertencia de PVS-Studio según el estándar de codificación SEI CERT</a> </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477838/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si desea compartir este artículo con una audiencia de habla inglesa, utilice el enlace a la traducción: Ekaterina Nikiforova.  <a href="https://habr.com/en/company/pvs-studio/blog/477838/">PVS-Studio Static Analyzer como herramienta para la protección contra vulnerabilidades de día cero</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477840/">https://habr.com/ru/post/477840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477824/index.html">Vivamos hasta el lunes o cómo sobrevivir el viernes negro</a></li>
<li><a href="../477826/index.html">Descripción general y comparación de las tecnologías V2X</a></li>
<li><a href="../477834/index.html">Principios para construir sistemas de análisis de transmisión</a></li>
<li><a href="../477836/index.html">Cómo probamos el WD ActiveScale P100 para nuestro almacenamiento S3</a></li>
<li><a href="../477838/index.html">PVS-Studio Static Analyzer como herramienta para la protección contra vulnerabilidades de día cero</a></li>
<li><a href="../477842/index.html">Historias de Gennady Zelenko y Sergey Popov - divulgadores de tecnología en la URSS</a></li>
<li><a href="../477844/index.html">5 pasos desde la idea hasta la aplicación práctica del aprendizaje automático con SAP Data Intelligence</a></li>
<li><a href="../477846/index.html">El resumen de eventos para profesionales de recursos humanos en TI para diciembre de 2019</a></li>
<li><a href="../477848/index.html">El pequeño secreto de un gran corazón: el primer cardiograma de ballena azul de la historia</a></li>
<li><a href="../477850/index.html">React Native: ¿una bala de plata para todos los problemas? Cómo elegimos una herramienta multiplataforma para Profi.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>