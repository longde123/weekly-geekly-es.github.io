<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😣 📊 ⭐️ Index de couverture pour GiST 👧 🚞 👇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'indice de couverture n'est pas seulement une autre fonctionnalité qui peut être utile. Cette chose est purement pratique. Sans eux, Index Only Scan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index de couverture pour GiST</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/474166/"> L'indice de couverture n'est pas seulement une autre fonctionnalité qui peut être utile.  Cette chose est purement pratique.  Sans eux, Index Only Scan ne peut pas gagner.  Bien que l'indice de couverture dans différentes situations soit efficace de différentes manières. <br><br>  Il ne s'agit pas vraiment de couvrir les index: à proprement parler, les soi-disant index inclusifs sont apparus dans Postgres.  Mais, dans l'ordre: un index de couverture est un index qui contient toutes les valeurs de colonne requises par la requête;  cependant, l'accès à la table elle-même n'est plus nécessaire.  Presque.  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lire</a> sur «presque» et d'autres nuances dans un article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yegor Rogov</a> , inclus dans sa série d'index de 10 (!) Parties.  Et l' <b>index inclus</b> est créé spécifiquement pour la recherche sur des requêtes typiques: les valeurs des champs qui ne peuvent pas être recherchés sont ajoutées à l'index de recherche, elles sont nécessaires uniquement pour ne plus se référer à la table.  Ces index sont formés avec le mot clé INCLUDE. <br><br>  Anastasia Lubennikova (Postgres Professional) a finalisé la méthode btree afin que des colonnes supplémentaires puissent être incluses dans l'index.  Ce correctif était inclus dans PostgreSQL 11. Mais les correctifs pour les méthodes d'accès GiST / SP-GiST n'avaient pas eu le temps de mûrir avant la sortie de cette version.  Le 12 GiST a mûri. <br><a name="habracut"></a><br>  Un désir constructif d'avoir des index inclusifs pour GiST est né il y a longtemps: un patch de test d'Andrey Borodin a été <a href="">offert à la</a> communauté à la mi-avril 2018.  Il a fait tout le travail de base, très difficile. <br><br>  Début août 2019, Alexander Korotkov a ajouté des améliorations cosmétiques et a validé le patch. <br><br>  À des fins de démonstration et de recherche, nous allons générer un ensemble de 3 millions de rectangles.  Dans le même temps, quelques mots sur le type de boîte, car toutes les manipulations avec lui ne sont pas intuitives. <br><br>  Le type de boîte - c'est-à-dire le rectangle - a longtemps été dans Postgres, il est défini par 2 points (le point de type géométrique) - les sommets opposés du rectangle (c'est-à-dire que le rectangle ne peut pas être oblique, jonché sur le côté).  Nous lisons dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> : «les valeurs de type box sont écrites sous l'une des formes suivantes: <br><br><pre><code class="plaintext hljs">( ( x1 , y1 ) , ( x2 , y2 ) ) ( x1 , y1 ) , ( x2 , y2 ) x1 , y1 , x2 , y2</code> </pre> <br>  En pratique, vous devez écrire, par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'1,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (3,4),(1,2) (1 row)</span></span></code> </pre> <br>  Tout d'abord, Postgres nous montre le sommet supérieur droit, puis le coin inférieur gauche.  Si on écrit comme ça, <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box(<span class="hljs-string"><span class="hljs-string">'5,2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3,4'</span></span>); <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-comment"><span class="hljs-comment">------------- (5,4),(3,2) (1 row)</span></span></code> </pre> <br>  alors nous nous assurerons que Postgres n'a pas donné les pics qu'ils lui ont donnés.  Il a calculé le coin supérieur droit et inférieur gauche à partir de notre coin supérieur gauche et inférieur droit.  Il s'agit d'une propriété pratique lorsque l'emplacement des sommets n'est pas connu à l'avance - en cas de génération aléatoire, par exemple.  La notation «1,2», «3,4» équivaut au point (1,2), au point (3,4).  Ce formulaire est parfois plus pratique. <br><br><br><h3>  Pour les entreprises: recherchez dans 3 millions de rectangles </h3><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> boxes(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, thebox <span class="hljs-type"><span class="hljs-type">box</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre><br>  Nous générerons 3 millions de rectangles aléatoires.  Nous voulons une distribution normale, mais pour ne pas utiliser l'extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tablefunc</a> , nous utilisons l'approche «pauvre»: nous utilisons random () - random (), qui donne également une belle image (voir la figure) avec des rectangles, plus ils sont grands, plus ils sont proches du centre.  Leurs centres de gravité sont également aléatoires.  De telles distributions sont caractéristiques de certains types de données réelles sur les villes.  Et ceux qui veulent se plonger dans les lois de la statistique ou rafraîchir la mémoire peuvent lire ici la différence des variables aléatoires. <br><br><img src="https://habrastorage.org/webt/2p/df/j4/2pdfj4sxnjja1ztiikvrkzrdniw.jpeg"><br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> boxes(thebox, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> box( <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ), <span class="hljs-type"><span class="hljs-type">point</span></span>( random()-random(), random()-random() ) ), <span class="hljs-string"><span class="hljs-string">'box no.'</span></span> || x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br><br>  La taille de la table qui affiche <code>\dt+</code> est de 242 Mo.  Vous pouvez maintenant lancer la recherche. <br><br>  Nous recherchons sans index: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------- Gather (cost=1000.00..47853.00 rows=3000 width=46) (actual time=0.140..246.998 rows=139189 loops=1) Workers Planned: 2 Workers Launched: 2 -&gt; Parallel Seq Scan on boxes (cost=0.00..46553.00 rows=1250 width=46) (actual time=0.011..106.708 rows=46396 loops=3) Filter: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Rows Removed by Filter: 953604 Planning Time: 0.040 ms Execution Time: 259.262 ms (8 rows)</span></span></code> </pre> <br>  Nous voyons qu'il y a un Parallel Seq Scan - balayage séquentiel (bien que parallélisé). <br><br>  Créez un index régulier et non inclusif: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(thebox);</code> </pre> <br>  La taille de l'index <code>boxes_thebox_idx</code> , qui affiche <code>\di+</code> , 262 Mo.  En réponse à la même demande, nous obtenons: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on boxes (cost=159.66..9033.30 rows=3000 width=46) (actual time=29.101..80.283 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_idx (cost=0.00..158.91 rows=3000 width=0) (actual time=25.029..25.029 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 0.053 ms Execution Time: 86.206 ms (7 rows)</span></span></code> </pre><br>  Le temps de recherche a été réduit d'un facteur trois, et au lieu de Parallel Seq Scan, ils ont reçu un Bitmap Index Scan.  Il ne se parallélise pas, mais il fonctionne plus rapidement. <br><br>  Maintenant, tuez l'ancien index et créez-en un: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  Index de <code>boxes_thebox_name_idx</code> plus gros: 356MB.  C'est parti: <br><br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------ Bitmap Heap Scan on boxes (cost=207.66..9081.30 rows=3000 width=46) (actual time=86.822..152.014 rows=139189 loops=1) Recheck Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Blocks: exact=30629 -&gt; Bitmap Index Scan on boxes_thebox_name_idx (cost=0.00..206.91 rows=3000 width=0) (actual time=83.044..83.044 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Planning Time: 3.807 ms Execution Time: 157.997 ms (7 rows)</span></span></code> </pre> <br><br>  Index Only Scan est utilisé, mais l'image est triste: le temps est presque 2 fois plus long que sans lui.  Nous lisons le manuel du créateur d'indices, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie I</a> : <br><br>  ‹Les index PostgreSQL rang ne contiennent pas d'informations permettant de juger de la visibilité des lignes.  Par conséquent, la méthode d'accès renvoie toutes les versions des lignes qui relèvent de la condition de recherche, qu'elles soient visibles ou non pour la transaction en cours.  Cependant, si le mécanisme d'indexation devait examiner la table à chaque fois pour déterminer la visibilité, cette méthode d'analyse ne serait pas différente de l'analyse d'index ordinaire.  Le problème est résolu par le fait que PostgreSQL prend en charge la soi-disant carte de visibilité des tables, dans laquelle le processus de vide marque les pages dans lesquelles les données n'ont pas changé suffisamment longtemps pour que toutes les transactions puissent les voir, quels que soient l'heure de début et le niveau d'isolement.  Si l'identifiant de la ligne renvoyée par l'index fait référence à une telle page, alors la visibilité ne peut pas être vérifiée. ›› <br><br>  Nous faisons le VIDE.  Répétez: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thebox, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> thebox @&gt; box(<span class="hljs-string"><span class="hljs-string">'0.5, 0.4'</span></span>,<span class="hljs-string"><span class="hljs-string">'0.3, 0.2'</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Index Only Scan using boxes_thebox_name_idx on boxes (cost=0.41..236.91 rows=3000 width=46) (actual time=0.104..38.651 rows=139189 loops=1) Index Cond: (thebox @&gt; '(0.5,0.4),(0.3,0.2)'::box) Heap Fetches: 0 Planning Time: 0.052 ms Execution Time: 44.337 ms (5 rows)</span></span></code> </pre> <br>  Une toute autre affaire!  Deux fois le gain par rapport à l'indice non inclus. <br><br><br><h3>  Sélectivité et gain </h3><br>  Les performances des index inclusifs dépendent fortement de la sélectivité des conditions dans les requêtes.  Pour étudier un peu cette dépendance, nous allons résoudre le problème inverse: nous allons générer une étiquette avec un index de type point et nous chercherons combien de points tomberont dans la case donnée.  Répartissez les points de manière uniforme au carré. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>);</code> </pre> <br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x);</code> </pre> <br>  La taille de la table est de 211 Mo. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka);</code> </pre> <br>  Taille 213 Mo. <br><br>  Nous allons évidemment mettre tous les points disponibles dans un carré: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1087.964..1864.059 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared read=54287 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1084.949..1084.949 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared read=27262 Planning Time: 0.102 ms Execution Time: 2029.501 ms (9 rows)</span></span></code> </pre> <br>  Nous avons demandé à EXPLAIN de montrer les tampons.  Cela vous sera utile.  Maintenant, le temps d'exécution de la demande est supérieur à 2 secondes, on peut voir que Buffers: shared read = 54287.  Dans une autre situation, nous pourrions voir un mélange de lecture partagée et de hit partagé - c'est-à-dire que certains tampons sont lus à partir du disque (ou du cache du système d'exploitation), et certains à partir du cache de tampon.  Nous connaissons la taille approximative de la table et des index, nous nous protégerons donc en définissant des tampons partagés pour que tout rentre - redémarrez Postgres avec l'option <br><br><pre> <code class="plaintext hljs">-o "-c shared_buffers=1GB"</code> </pre> <br>  Maintenant: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=231.032..613.326 rows=3000000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27025 Buffers: shared hit=54248 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=228.068..228.068 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=27223 Planning Time: 0.070 ms Execution Time: 755.915 ms (9 rows)</span></span></code> </pre> <br>  Autrement dit, la lecture partagée est devenue un succès partagé et le temps a été réduit trois fois. <br><br>  Un autre détail important dans EXPLAIN: 3 millions de points sont retournés, et la prévision du nombre retourné d'enregistrements est de 3 000. Spoiler: ce nombre ne changera avec aucune sélectivité.  L'optimiseur ne sait pas comment évaluer la cardinalité lors de l'utilisation de types de boîtes ou de points.  Et le plan ne changera pas: pour toute taille de rectangle, il y aura un scan d'index bitmap sur test_covergist_tochka_idx. <br><br>  Voici deux autres mesures avec le nombre d'enregistrements émis, différents par ordre de grandeur: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=27.889..134.054 rows=269882 loops=1) Recheck Cond: ('(300000,300000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=27024 Buffers: shared hit=29534 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=24.847..24.847 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Buffers: shared hit=2510 Planning Time: 0.074 ms Execution Time: 151.269 ms (9 rows)</span></span></code> </pre> <br>  Il renvoie 10 fois moins d'enregistrements (réels ... lignes = 269882), le temps a diminué d'environ 5 fois. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'30000,30000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist (cost=135.66..8778.83 rows=3000 width=32) (actual time=1.882..16.095 rows=2780 loops=1) Recheck Cond: ('(30000,30000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2624 Buffers: shared hit=2655 -&gt; Bitmap Index Scan on test_covergist_tochka_idx (cost=0.00..134.91 rows=3000 width=0) (actual time=1.035..1.035 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Buffers: shared hit=31 Planning Time: 0.154 ms Execution Time: 16.702 ms (9 rows)</span></span></code> </pre> <br>  Le contenu d'un carré de 30K × 30K (2780) est compté en seulement 16 ms.  Et quand il y a des dizaines d'enregistrements, ils sont déjà extraits en fractions de ms, et de telles mesures ne sont pas très fiables. <br><br>  Enfin, mesurez la même chose avec l'indice inclusif: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre> <br>  Taille 316 Mo. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.160..568.707 rows=3000000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=40492 Planning Time: 0.090 ms Execution Time: 709.837 ms (6 rows)</span></span></code> </pre> <br>  Le temps est presque le même qu'avec un index conventionnel, bien qu'Index Only Scan. <br><br>  Mais: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.083..53.277 rows=269882 loops=1) Index Cond: (tochka &lt;@ '(300000,300000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=3735 Planning Time: 0.077 ms Execution Time: 66.162 ms (6 rows)</span></span></code> </pre> <br>  Et c'était 151 ms.  Et, en conséquence: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'300000,300000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------- Index Only Scan using test_covergist_tochka_name_idx on test_covergist (cost=0.41..216.91 rows=3000 width=32) (actual time=0.043..0.639 rows=2780 loops=1) Index Cond: (tochka &lt;@ '(30000,30000),(0,0)'::box) Heap Fetches: 0 Buffers: shared hit=52 Planning Time: 0.053 ms Execution Time: 0.791 ms (6 rows)</span></span></code> </pre><br>  C'est déjà une fraction de ms pour les mêmes enregistrements de 2780 points. <br><br><h3>  Des tampons comme des fusils </h3><br>  Une explication peut être recherchée et trouvée dans un fusil de chasse qui n'a pas encore tiré mais qui était accroché au mur: le nombre de blocs lus.  Dans le cas d'un index inclusif, seuls les blocs de l'index lui-même sont lus (Heap Fetches: 0).  Dans trois cas, il s'agissait des numéros 40492, 3735 et 52. Mais lors de l'utilisation de l'index normal, les blocs lus consistent en la somme des bits lus dans l'index Bitmap Heap Scan (54248 avec 3 millions d'enregistrements) et ceux qui ont dû être lus à partir du tas (27223). , car le champ de nom ne peut pas être extrait d'un index standard.  54248 + 27223 = 81471.  L'exclusivité était 40492. Pour deux autres cas: 29534 + 2510 = 31044 et 2655 + 31 = 2686.  Dans le cas d'un index régulier, plus de blocs sont lus de toute façon, mais avec une amélioration de la sélectivité, le nombre de blocs lus commence à différer par des ordres de grandeur plutôt que 2 fois en raison du fait que le nombre de blocs nécessaires d'un tas diminue plus lentement que la lecture de blocs d'index. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Nombre total d'enregistrements retournés</b> (en milliers) </td><td>  <b>3000</b> </td><td>  <b>270</b> </td><td>  <b>2.7</b> </td></tr><tr><td>  <b>Lire les blocs</b> (Normal / Inclus) </td><td>  81471/40492 </td><td>  31044/3735 </td><td>  2686/52 </td></tr><tr><td>  <b>Le temps</b> </td><td>  755/710 </td><td>  151/66 </td><td>  16 / 0,7 </td></tr></tbody></table></div><br><br>  Mais peut-être que le point n'est pas du tout la sélectivité, mais simplement la taille de la table?  Juste au cas où, nous répétons les mêmes étapes, générant une table avec 300 000, et non 3 millions d'enregistrements: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test_covergist_small(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, tochka <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">text</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> test_covergist_small(tochka, <span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span>(trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random()), trunc(<span class="hljs-number"><span class="hljs-number">1000000</span></span>*random())), <span class="hljs-string"><span class="hljs-string">'point no.'</span></span> || gx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">300000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(x); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gist(tochka); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tochka, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test_covergist_small <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> box(<span class="hljs-string"><span class="hljs-string">'0,0'</span></span>,<span class="hljs-string"><span class="hljs-string">'3000000,3000000'</span></span>) @&gt; tochka; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------- Bitmap Heap Scan on test_covergist_small (cost=14.61..867.19 rows=300 width=31) (actual time=36.115..130.435 rows=300000 loops=1) Recheck Cond: ('(3000000,3000000),(0,0)'::box @&gt; tochka) Heap Blocks: exact=2500 Buffers: shared hit=5225 -&gt; Bitmap Index Scan on test_covergist_small_tochka_idx (cost=0.00..14.53 rows=300 width=0) (actual time=35.894..35.895 rows=300000 loops=1) Index Cond: (tochka &lt;@ '(3000000,3000000),(0,0)'::box) Buffers: shared hit=2725 Planning Time: 0.060 ms Execution Time: 158.580 (9 rows)</span></span></code> </pre><br>  Ensuite, répétez la même chose pour l'index inclusif.  Voici les résultats: <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Nombre total d'enregistrements retournés</b> (en milliers) </td><td>  <b>300</b> </td><td>  <b>27</b> </td><td>  <b>0,25</b> </td></tr><tr><td>  <b>Lire les blocs</b> (Normal / Inclus) </td><td>  5225/3726 </td><td>  3026/352 </td><td>  270/8 </td></tr><tr><td>  <b>Le temps</b> </td><td>  158/178 </td><td>  20/13 </td><td>  0,4 / 0,2 </td></tr></tbody></table></div><br><br>  Dans le cas d'une couverture à 100% des points, la requête était même un peu plus lente qu'avec l'index habituel.  De plus, comme dans le cas de 3 millions, tout s'est mis en place.  Autrement dit, la sélectivité est importante. <br><br>  Notre société a testé des indices GiST inclusifs sur des données réelles - un ensemble de plusieurs millions de rectangles sur une carte de Moscou.  La conclusion est la même: dans de nombreuses situations, de tels index accélèrent sensiblement les requêtes.  Mais l'article ne peut pas être illustré par des images et des nombres de tests: ces données ne sont pas du domaine public. <br><br><h3>  Au lieu d'une conclusion </h3><br>  Revenons un instant aux rectangles aléatoires.  Essayons de faire de même avec spgist.  Vous pouvez vous rappeler ou découvrir ce que c'est que de comprendre les différences entre SP-GiST et GiST en lisant l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Indexes dans PostgreSQL - 6</a> .  Créez un index inclusif: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> boxes <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> spgist(thebox) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>); ERROR: <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> "spgist" does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support included <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span></code> </pre> <br>  Hélas, pour SP-GiST, les index inclusifs ne sont pas encore implémentés. <br>  Il y a donc place à amélioration! <br><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474166/">https://habr.com/ru/post/fr474166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474144/index.html">Comment créer une startup: projet IoT de l'idée à la production</a></li>
<li><a href="../fr474146/index.html">Augmentation de la vitesse de sauvegarde et possibilité de choisir le taux de compression dans la nouvelle version de Zextras Backup</a></li>
<li><a href="../fr474150/index.html">Dérivation d'un modèle d'un système dynamique d'un filtre de Kalman discret pour un système linéaire arbitraire</a></li>
<li><a href="../fr474154/index.html">Vitrectomie - nous labourons les espaces ouverts du monde délimités par la cavité oculaire</a></li>
<li><a href="../fr474164/index.html">Zimbra est notre tout</a></li>
<li><a href="../fr474170/index.html">Design Confession - 15 novembre, Moscou, DI Telegraph</a></li>
<li><a href="../fr474172/index.html">Une amende de 30 mille euros pour l'utilisation illégale de cookies</a></li>
<li><a href="../fr474176/index.html">11 vidéos du premier jour du DevFest 2019 à Kaliningrad</a></li>
<li><a href="../fr474178/index.html">IVR sur Webhook</a></li>
<li><a href="../fr474180/index.html">Comment l'architecture Web à tolérance de pannes est implémentée dans la plate-forme Mail.ru Cloud Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>