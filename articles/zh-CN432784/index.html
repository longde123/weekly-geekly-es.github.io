<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🥄 👂🏽 恶魔城机器人 🐛 💤 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是什么 
 CastlevaniaBot是在Castlevania中播放的NES Nintaco模拟器的插件。 如果您在启动屏幕上运行它，该插件将从头到尾经历整个游戏。 或者，您可以在游戏中的任何位置运行它，以使其通过其中的一部分。 


 在本文中，我将告诉您如何创建能够传递恶魔城的机器人，以及...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>恶魔城机器人</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432784/"><h1> 这是什么 </h1><br>  CastlevaniaBot是在Castlevania中播放<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的NES Nintaco模拟器</a>的插件。 如果您在启动屏幕上运行它，该插件将从头到尾经历整个游戏。 或者，您可以在游戏中的任何位置运行它，以使其通过其中的一部分。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UrtgTGmv1GQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 在本文中，我将告诉您如何创建能够传递恶魔城的机器人，以及如何为NES上的任何游戏创建类似的东西。 <br><a name="habracut"></a><br><hr><br><h1> 基于知识的结构 </h1><br> 该项目未使用机器学习。 相反，开发可以称为“机器学习”。 我知道如何通过恶魔城。 困难在于将我的知识写到计算机程序中。 结果就是一个系统，该系统模拟了我手中拿着控制器执行的相同决策过程。 要创建它，必须清楚说明控制西蒙·贝尔蒙特（Simon Belmont）钻头世界的物理学的详细细节，以及经验丰富的吸血鬼猎人所需的所有战术。 <br><br>  CastlevaniaBot可以使用一系列策略来处理各种情况。 它们中的大多数旨在与特定类型的游戏对象一起使用。 例如，有一个骨架控制策略，另一个是针对鱼类的策略，用于打破蜡烛，采集心脏等。 <br><br>  CastlevaniaBot不断监视游戏状态，并在必要时在不同策略之间切换。 在决策过程中，将使用适应度函数，在屏幕上对所有游戏对象进行排名。 列表的顶部是主要目标，当它改变时，该机器人会改变其策略。 例如，当蝙蝠飞进架子时，CastlevaniaBot可能准备打蜡烛。 根据与蝙蝠的距离，CastlevaniaBot可能会做出反应，即从蜡烛策略切换为蝙蝠策略。 销毁蝙蝠后，他将继续使用蜡烛工作。 <br><br> 在决定转换之前，CastlevaniaBot会回顾其当前的目标和策略。 如果他没有成功，他可能会陷入一个无休止的循环，以相等或几乎相等的优先级在两个目标之间来回切换。 为避免这种情况，当出现一个新的主要目标时，该目标的优先级仅略高于当前目标，CastlevaniaBot可以决定继续执行当前策略。 <br><br> 当某些策略落入某个区域时，它们会自动启动。 通常，它们旨在同时处理多个游戏对象。 例如，在走廊上有一堆会飞的水母头，最好只是继续前进，而不要单独瞄准每个头。 <br><br> 某些策略可能会有所不同，具体取决于当前的辅助武器和收集到的内心数量，尤其是在上司战斗中。  CastlevaniaBot试图根据其拥有的工具和当前状况做出最佳决策。 <br><br><hr><br><h1> 规划8位世界 </h1><br> 在进行此类项目时，我主要是试图简化任务。 我想像过如果没有敌人，蜡烛或物品需要收集时，恶魔城会是什么样子。 在这种情况下，所需要做的只是从关卡的开始到结束。 我想知道-如果我能教机器人该怎么做，一路上消灭几个敌人有多困难？ <br><br> 要教机器人如何移动，我需要平铺背景图并了解关卡的组织方式。 游戏包含六个级别，每个级别以一个老板结尾。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09b/644/665/09b644665551ebb424b3813af0205173.png"></div><br> 每个级别分为3或4个阶段。 舞台通常由木门隔开，木门在玩家的背后开有吱吱作响的声音。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/207/5fb/a46/2075fba46c9ef8ccd9a496df6aadcf07.png"></div><br> 门是控制点（检查点）。 如果玩家被杀死，那么他将回到阶段的开始，但前提是他尚未结束生命。 如果您在“游戏结束”之后继续游戏，则玩家将被带到关卡的最开始。 <br><br> 阶段号表示自游戏开始以来完成的检查点总数。 最后一个阶段是18号。但是，如果您杀死了德古拉，游戏将从困难模式的最开始开始，阶段数继续增加到19个甚至更多。 如果您经过困难模式，那么游戏的第三周期不会变得更加困难，但是阶段数仍会继续增加。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/447/6a5/3c5/4476a53c571dc062a4bc2287f5e02587.png"></div><br> 每个阶段都由一个或多个背景水平滚动条组成，我称之为“子步骤”。 如果沿着向上或向下的楼梯退出屏幕，则游戏将从一个子阶段移至另一子阶段，并且不会垂直滚动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/751/5d8/7607515d8da99df95877d7eef8214f3f.png"></div><br> 游戏使用3个字节来跟踪游戏周期号，阶段号和子阶段号。 正常模式（Normal Mode）下的游戏周期值为0； 大于或等于1的值表示“困难模式”。 不论游戏周期如何，这些步骤始终具有从0到18的编号。子步骤始终具有0或1的值，因为这些步骤永远不会包含超过2个水平条纹。  CastlevaniaBot跟踪这些字节以了解其位置。 <br><br> 为了方便起见，我将每个子阶段的背景条记录在一个单独的图形文件中。 如果需要找出对象的确切坐标，则可以使用图形编辑器快速找出它们。 我使用Nintaco内置的Map Maker工具记录了文件。 我打开了它，然后浏览了整个游戏。 一些生成的图像包含几个连接在一起的子步骤，这些子步骤很容易分解。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/3de/57e/a533de57e49c26f55eea024465dd3cf6.png" alt="Nintaco的地图制作工具"></div><br> 检查背景图像后，我意识到唯一重要的瓷砖是平台和楼梯。 其他所有内容都可以视为空白空间。 楼梯有两种类型：向前或向后（它们可以表示为等腰三角形的左边缘和右边缘）。 有时，楼梯会以玩家可以在其上行走的平台结束。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6e/6fa/76b/c6e6fa76bcd6d6c3457060763eb6f993.png"></div><br> 只有5种重要类型的图块，并且在每个级别上它们都有不同的外观。 我将它们复制并粘贴到单独的16×16图像文件中。 然后，我编写了一个程序，将每个子步骤中的每个图块与相应的图像集进行比较。 因此，我得到了所有子步骤的图块的矩阵类型。 <br><br> 可以直接从ROM中提取矩阵，但是找不到关于如何以及在何处存储数据的文档。 由于ROM空间有限，因此级别数据通常以类似于矢量图形格式的压缩形式呈现。 每个游戏都使用自己的格式，因此我没有进行研究的必要，因为我拥有Map Maker。 另外，我仍然需要这些子步骤的图形图像。 如果没有捕获背景条纹，则必须编写一个从矩阵生成图像的程序。 <br><br><hr><br><h1> 寻路 </h1><br> 创建矩阵之后，我想应用路径搜索算法，即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Floyd-Warshall算法</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法</a>给出了输出表，其中包含有向图的带权重边的每对顶点之间的最短路径。 这个想法是预先计算表格并将它们写入文件，然后在游戏期间加载它们。 该机器人将表存储在内存中，可以搜索并立即找出任何两个平台图块之间的最短路径。 <br><br> 该图由边和顶点组成。 如果平台图块是顶点，则边缘仅是Simon可以执行的操作，以便从一个平台移动到另一个平台。 禁止仅在一个图块内执行操作。 例如，在从图块开始的平面上，Simon只能向左移动一个图块或向右移动一个图块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe2/fa3/03d/fe2fa303d199d5c1cb826da8003acd3a.png"></div><br> 同样，如果Simon在楼梯上，那么他可以在两个可能的方向之一上移动一个图块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/f17/502/a68f175026f789811cf3c7b032f76898.png"></div><br> 这些是有效的操作。 但是诸如从图块的中点移动到图块的边缘之类的动作过于零碎，因为它们不对应于从图形的一个顶点到另一顶点的过渡。 <br><br> 除了左右走动，下降和爬楼梯外，Simon还可跳至另一块瓷砖。 他可以从瓷砖表面的16个像素中的任意一个开始向左或向右跳转。 为了减少图形中的边数（以及查找表的大小），我只考虑了五个可能的排斥点： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/37d/aab/01237daabc08e79e6ccd6de83b6a1c0e.png"></div><br> 添加操作“什么都不做”，我得到了15个操作。 所有这些操作都非常简单，因此机器人可以在游戏执行期间轻松确定执行它们所需的按钮按下的顺序。 <br><br> 为了构建完整的图形，我创建了一个非常简单的Simmon世界物理模拟。 在此仿真中，从每个平台图块开始执行所有15个操作。 该图是通过简单地观察Simon的位置来构建的。 更具体地说，当指定初始坐标和操作时，模拟将在输出中给出最终坐标。 例如，如果没有最终坐标，则当Simon尝试进入墙壁或孔中时，程序将返回该操作无效且该边不属于图形的部分。 <br><br> 要创建此模拟，需要对Simon Belmont进行深入研究。 与其他经典平台游戏（玩家可以从行走到跑步加速）不同，Simon在水平移动时，每帧始终精确移动1像素。 对于步行，跳跃，爬楼梯，甚至在攻击敌人时返回时都是如此。 <br><br> 限制水平速度会大大简化障碍的识别。 游戏检查角色前方一个像素中是否有墙，并在必要时停止移动。 该测试是在头部水平以下进行的，这可以使头部在不影响水平移动的情况下通过低矮的天花板。 <br><br> 垂直运动稍微复杂一些。 如果Simon离开平台边缘，而不是逐渐加速，他将立即以每帧8像素的速度掉落。 由于每个图块的高度为16像素（是8的倍数），因此简化了地面识别。 同时，播放器在跌倒之前获得的方向上保持每帧1像素的水平速度。 <br><br>  Simon的sprite宽度为16像素，但它可以从中点悬停在该块上方最多±4像素。 如果再移动一点，它将跌至下方。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/b2a/0a4/fd8b2a0a48035271fc78e7209d980dd5.png"></div><br> 有趣的是，如果他离开平台并以每帧1个水平像素和8个垂直像素的速度恰好落在1个图块上，那么他着陆时将不会完全站在该块上。 他的一只脚将留在墙内2像素深。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da0/a27/458/da0a274588a45b4e448fbe46ef9e48ca.png"></div><br> 之后，他将能够退出隔离墙，但不能进入隔离墙。 <br><br> 西蒙在跳跃过程中无法改变方向。 按下按钮A之后，他沿着抛物线进行固定的移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/041/db3/a4a/041db3a4afa0f0f93e0533f0ee1dbd48.png"></div><br> 在顶部，Simon上升了36个像素，这使他可以跳到2格高的平台上。 而且“抛物线”的顶部令人惊讶地平坦。 似乎它冻结了9个完整帧的空间，可能是为了简化空中的鞭打。 如果西蒙没什么可落地的，那么抛物线运动会一直持续到他回到原来的高度为止。 此后，它开始以每帧8像素的速度下降，也就是说，以相同的恒定速度从平台下降。 <br><br> 如果角色的头顶上方有平台，则不允许跳跃。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/358/0ba/e063580bac81a0ec963336e2886c0e2a.png"></div><br> 否则，他会部分“跳入”平台砖。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/56a/f41/65156af41893e3c9008a4836d67efca1.png"></div><br> 如前所述，如果Simon的触碰超过他的头顶，他将停止水平移动。 在第4级第一阶段结束时，这很烦人，此时玩家正试图离开洞穴。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/d41/331/1c6d413312f17f67d6247f9a33000499.png"></div><br> 楼梯使您可以在平台之间自由垂直移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05c/5e1/2fc/05c5e12fc0bd66681054052354e13a14.png"></div><br> 在一种情况下，西蒙上楼梯，穿过平台砖。 在楼梯上，他可以自由穿过墙壁。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/522/872/438/5228724383d3d908b5298c62dc73e015.png"></div><br> 在4级移动平台上，玩家通常蹲在低垂的钟乳石下面。 但是，您可以站起来反对他们。 在这种情况下，游戏会限制水平移动，从而将Simon迅速拖入集水器中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/dcd/85f/febdcd85f8f47c08806d00343a74fc02.png"></div><br> 生成定向图的物理模拟器将Simon视为矩形。 该矩形的移动受到上述移动规则的限制。 为了使漫游器不会像兔子一样从一个地方跳到另一个地方，伯爵跳数的边缘被分配了比步行和沿着楼梯移动的边缘更高的成本。 <br><br> 路径搜索算法生成的表格包含每个开始和结束磁贴的最短距离（路径的总成本）以及路径第一步的说明。 此描述包括必须在此路径上执行的第一个操作，以及完成字符后将在其上运行的图块。 可以通过在表中重复搜索来重新创建整个路径，每个路径都朝着最终图块的方向进行下一步。 <br><br> 在某些子步骤中，这些列未完全连接。 例如，在第4级，平台是穿越深渊的唯一途径。 在这些子步骤中，该表包含用于在每个岛上移动但不在它们之间移动的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/098/f72/e0f098f72ffb3a91bb86d2cf5fa1921b.png"></div><br> 一些可破坏的块包含隐藏的对象。 并且块的破坏改变了该图。 为了解决这个问题，将用于查找具有和不具有拆分块的路径的算法应用于子步骤。 在运行时，CastlevaniaBot监视要拆分的块的状态并使用适当的查找表。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aca/ac4/8a1/acaac48a1c7f4acd0849f06dab3a9d0a.png"></div><br><hr><br><h1> 游戏状态 </h1><br>  CastlevaniaBot通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其API</a>集成到Nintaco中。 它注册<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>FrameListener</code></a>的实现以在每个帧中接收返回。 由于仿真器以每秒约60帧的速度运行，因此该侦听器需要按时返回。 漫长的计算或停机时间将减慢或阻塞模拟器。 在短时间内，CastlevaniaBot会读取游戏的状态，确定其主要目标，并在目标改变后切换策略并实现当前策略。 <br><br>  CastlevaniaBot直接从处理器的RAM中读取Simon Belmont的当前状态。 但是我无法确定其他游戏对象如何在内存中表示。 因此，CastlevaniaBot直接从对象属性的内存（对象属性内存，OAM）中读取-该区域存储显示的精灵列表。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/296/b58/46a/296b5846a26530aa657294d619e5ad63.png"></div><br> 该技术有效并且通常适用于其他游戏，但是存在许多缺点。  OAM中子画面的顺序不断变化。 如果屏幕上同时存在多个相同类型敌人的实例，那么跟踪它们的唯一方法就是确定它们的接近度，将子画面的最后一个坐标与前一帧的坐标进行比较。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/236/258/46d23625808baf3abb91916e4f80baed.png"></div><br> 一些游戏对象包括重复的精灵，例如骨塔。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/49a/dcb/1b749adcb05680e5a22247c783d8bac2.png"></div><br> 移动平台由一个精灵重复4次组成。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e0/f85/ea8/7e0f85ea889b5e824a010d04e26f03d2.png"></div><br> 对这两种情况进行分类都需要附加的逻辑，该逻辑易于实现。 辅助武器升级和某些类型的辅助武器本身使用相同的精灵。 更糟的是，在5级时，骑士们借用了西蒙的次要武器精灵。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44c/cd1/08e/44ccd108ea9b25c442a5653d79f0c49e.png"></div><br> 幸运的是，除了圣水之外，CastlevaniaBot仅使用通常无法进行升级的辅助武器，例如在老板战斗中。 而且圣水升级精灵与施放时使用的精灵不同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/014/1d2/faf/0141d2faf5e0168ae8d4046cdbfbe278.png"></div><br> 一些游戏对象在创建过程中会闪烁，例如，boss战斗结束时的水晶球，死亡辫子和德古拉的尸体。 闪烁的精灵会从OAM中出现或消失，因此需要附加逻辑来跟踪这些对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/5f1/f8b/b805f1f8bf89efb9c021b716a0d39e25.png"></div><br> 还值得注意的是，由于硬件限制，NES每条光栅行只能显示8个精灵。 由于子画面的优先级部分取决于它们在OAM中的索引，因此将随机混合每一帧的顺序，以避免移动使一个子画面始终不可见。 几个精灵依次闪烁，逐渐更改其优先级。 此闪烁不会影响从OAM读取图片。 数据仍然保留在那里，但是模拟硬件不会显示它。 这与上述创建精灵时闪烁的情况不同。 此外，Nintaco还提供了可以大大减少硬件闪烁的选件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b9/527/fe6/6b9527fe61e614012f1fd50d1ad0625e.png"></div><br> 最后，从PPU名称表中读取游戏状态的一小部分-包含所有背景数据的存储区。 这包括检查可破坏块并跟踪第2级“粉碎”的位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/f3c/378/d35f3c378b284474c8d2b5386a78fb57.png"></div><br><hr><br><h1> 启发式状态机 </h1><br> 策略是状态机。  CastlevaniaBot将它们定义为具有<code>init</code>和<code>step</code>方法的抽象类。 当CastlevaniaBot切换到适当的策略时，将调用<code>init</code>方法，从而允许状态机重置。 然后， <code>step</code>方法执行该策略。 例如，针对鱼类的<code>step</code>策略方法检查鱼类是否在鞭子的范围内，如果是，则机器人用鞭子击中。 否则，它会检查是否可以通过跳跃达到打击距离，如果可以，则机器人会跳跃。 最后，如果机器人离敌人太近，它就会远离它。 通过这些简单的规则，CastlevaniaBot击败了人类的鱼类。 <br><br> 为了尽可能简化编写策略，我创建了一个可能执行的动作的库。 例如，机器人没有按下并释放按钮A进行跳转，而只是从库中调用jump方法。 在此之前，他问图书馆西蒙是否在平台上并且可以跳跃。 <br><br> 接近目标并远离目标是使用路径搜索算法创建的表中的操作执行的标准动作。 例如，烛形策略使用库方法<code>routeAndFace</code> ，该方法不仅将Simon定向到某些指定的坐标，而且在将它们击中后向左或向右旋转。 另外，根据蜡烛的高度，该策略会在击打鞭子之前执行跳跃或下蹲动作。 从蜡烛掉落的物体会在空中产生，并会掉落或缓慢掉落到地面。 取货策略会在物品接触地面之前将Simon引导到他正下方最近的瓷砖。 <br><br> 为了远离敌人，图书馆需要知道如何向左或向右移动而不掉入坑中。 通常，这是通过搜索到子级左边缘或右边缘的路径来完成的。 但是在某些区域，最短的左边缘路径最初需要向右移动，反之亦然。 当出现此类问题时，我为子阶段专门添加了逻辑，将Simon引导到当前平台的左右边缘。 <br><br><hr><br><h1> 演练 </h1><br> 在本节中，我将在整个演练中进行评论，详细描述CastlevaniaBot使用的策略。 <br><br> 游戏从城堡前的庭院开始。 框架中的对象被布置为选择主要目标，在这种情况下，主要目标是带有火焰的圆柱。 专栏策略会告诉漫游器接近专栏并在伸手可及的距离内使用鞭子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14c/647/750/14c6477507cee1d822e6cadbcafbda5a.png"></div><br> 敲打鞭子并销毁色谱柱后，将创建一个项目。 所有项目的优先级都高于火焰列的优先级。 因此，CastlevaniaBot使用一种策略来对此做出反应，该策略将收集出现在继续下一列之前的项目。 <br><br> 在对对象进行排名时，CastlevaniaBot始终考虑长期目标-在时间用完之前完成关卡。 创建潜在目标列表时，始终会向其添加下一个门。 门的优先级较低，但是在销毁所有列并收集所有对象之后，它将成为优先级。 除了一个例外：CastlevaniaBot知道如何发现所有隐藏的宝藏，并且跳过城堡的入口以创建一个眨眼的钱袋子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/7f5/eaa/2007f5eaa4405bd611bd8711017fbe24.png"></div><br> 进入城堡后，CastlevaniaBot看到鬼魂和蜡烛。 蜡烛和手工制作的物品优先，直到鬼魂靠近。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a7/9ab/843/8a79ab84345e6a16a9231c5a7f45ceae.png"></div><br> 鞭子似乎经常摧毁敌人而不碰他们。 我在游戏的ROM中找到了一个碰撞矩形表，因此CastlevaniaBot可以准确知道什么时候在鞭子的范围内。 而且由于碰撞矩形通常会略微超出精灵的边界，因此鞭子会撞到“不可见的部分”。 <br><br> 在大多数情况下，销毁蜡烛时，CastlevaniaBot会垂直跳跃，而不是向前跳跃。 这是一种规避风险的策略。 由于处于空中，因此无法改变运动方向，一群接近的敌人会使安全着陆复杂化，甚至使其不可能。 另外，通过垂直跳跃，CastlevaniaBot会停留在同一块上。 他不需要检查跳跃是否会导致跌落在下平台或坑底。 <br><br> 当没有蜡烛要销毁或没有要收集的物体时，CastlevaniaBot开始追逐幽灵。 但是“黑豹战略”命令他站着不动，等待敌人落入鞭打的范围之内。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/9a0/bd5/4349a0bd58a7078c6b0d1951845bfea2.png"></div><br> 蜡烛不仅可以作为心脏和其他物体的来源，还可以引导玩家逐步穿越舞台。 例如，在下面的图像中，右上角的蜡烛“邀请”玩家爬楼梯。 但是，要爬上楼梯，玩家最初需要向左走，这就是蜡烛从屏幕上消失的原因。 由于CastlevaniaBot解决方案基于屏幕上可见对象的优先级，因此这种情况可能导致无休止的循环，其中机器人会交替选择到达蜡烛的最短路径（向左）或到出口门的最短路径（向右）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/d1a/8e7/309d1a8e7f1f5a39a8b34411108b94b8.png"></div><br> 类似的问题可以通过几种方式解决。 例如，CastlevaniaBot可以配备存储对象，即使对象不可见，也要知道它们仍然存在。 但是为此，从一开始它们都是一样的，需要加以观察。 如果蜡烛更靠右，那么在检测到蜡烛之后，有必要再往回走。 <br><br> 考虑到这一点，我添加了激励因素，促使CastlevaniaBot探索他通常会忽略的舞台区域。 这些激励措施与退出大门类似，将CastlevaniaBot吸引到需要的地方。 此外，我添加了一些规则，使他忽略蜡烛和距离太远的物体（就行进距离而言，不是直线）。 <br><br> 在爬楼梯并销毁蜡烛后，就产生了圣水-所有辅助武器中最有价值的。  CastlevaniaBot通过交换匕首来选择它。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c5/575/00a/4c557500adad3a899c43ea80b983d6fb.png"></div><br> 与游戏开始时的钱袋一样，CastlevaniaBot知道所有带有隐藏对象的可破坏块，并使用鞭子破坏块，它使用的策略类似于蜡烛策略。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1eb/007/d43/1eb007d4384996127451979738a3c6ea.png"></div><br> 随着CastlevaniaBot的进一步移动，您会注意到它开始使用圣水来摧毁幽灵和蜡烛。 这似乎是多余的，但起着重要的作用。 恶魔城奖励使用双重和三重曝光辅助武器的玩家。 换句话说，CastlevaniaBot <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">磨碎了</a>辅助武器的升级。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a7/186/be0/6a7186be0588f46012a241cc9745d586.png"></div><br> 按下按钮B后，在打鞭子之前会有16帧的延迟。 鞭子将继续保持额外的10帧，但仅在这10帧中的第一个有效。  CastlevaniaBot利用这一事实来改善瞄准。 特别是，它假设主要目标将继续沿线性路径移动，从而跟踪帧中所有对象的速度。 然后，他在目标必须用鞭子碰到16帧之前按下按钮B。 在这16帧中，敌人总是可以改变方向，但是通常这种简单的启发式工作即可。 <br><br> 但是，穿过门后，CastlevaniaBot遇到了红色蝙蝠。 就像水母的头一样，红色的蝙蝠在屏幕上飞来飞去，穿过平台和楼梯穿过正弦曲线。 为了预测16帧后红色蝙蝠的位置，我在一张桌子上记录了其中之一的运动。 在游戏执行期间，CastlevaniaBot跟踪蝙蝠并等待轨迹的最高点或最低点，垂直速度会改变其符号。 然后，他可以将坐标与预先创建的表中的值进行比较。 这允许采取适当的策略用鞭子击打红色蝙蝠，弯腰或反弹。 <br><br> 在恶魔城（Passervania）的传球过程中，玩家会进行一些动作，使游戏尽可能地具有确定性。 例如，他们发现，如果在第1级末尾破坏方块并按一定的时间顺序进行武器升级，则上司将按照所需的模式行事，从而使他迅速击败。 <br><br> 不管经验丰富的人如何，他们都无法完全驯服随机数生成器。 尽管如此，由于CastlevaniaBot可以逐帧精确地控制按钮按下，因此每次通过游戏时都以完全相同的方式将速度传递的概念发挥到极致。 如果他做到了，那将比通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TAS</a>更好。 因此，CastlevaniaBot使用外部随机数生成器任意添加错误和延迟，以防止其确定性的游戏玩法。 例如，当他用鞭子敲打一根高高的蜡烛时，他故意在跳跃和打击中增加了随机帧数的延迟。 这些微小的变化会极大地影响游戏的进度。 <br><br> 尽管CastlevaniaBot试图避免确定性，但他还是从Speedrunning中借鉴了一个概念： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">损害赔偿</a> 。 在50％的情况下，CastlevaniaBot跳回红色蝙蝠，将其扔到否则无法到达的平台上，从而完全避免了人类鱼类的地牢通道。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/733/1ed/3757331edfa439d3ed9eb1ef3be8443e.png"></div><br> 在另一半情况下，CastlevaniaBot选择与人类鱼类作斗争。 他们的火球具有较高的优先级，CastlevaniaBot会根据情况用鞭子，闪躲或弹跳击打他们。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/f51/077/6e4f51077f42c471bc0484e64aaa14b6.png"></div><br> 由于制造敌人及其火球的不可预测性，大多数玩家通常会使用人类的鱼来奔跑。 但是，CastlevaniaBot花时间在它们上面，收集所有的心，甚至在最右边收集隐藏的宝藏。 该机器人确切地知道每个蜡烛中包含哪些物品，并且由于他更喜欢使用圣水，因此他跳过了隐藏有计时器的蜡烛。 但是，如果您停留在这一部分并与鱼群争斗，有时您不可避免地会拿起天文钟。 <br><br> 舞台通常以十字架结束，摧毁屏幕上的所有敌人。 万一您好奇，我会说十字架不会在关卡结束时杀死Boss。 实际上，有时甚至在老板打架时也会产生十字架。 例如，在与美杜莎的战斗中，杀死蛇时有时会出现十字架。 但是这些十字架只能杀死其他蛇。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3e/328/e31/c3e328e311c90509ffc2450e4b991436.png"></div><br> 穿过门后，恶魔城再次遇到了幽灵。 在下面的屏幕截图中，他想跳到较低的平台，但是幽灵阻止了他移动。 当通过路径搜索算法创建的表告诉CastlevaniaBot跳转时，它将检查目标平台周围的空间。 如果事实证明他降落在敌人身上，则不会执行跳跃。 在这种情况下，这种机制使CastlevaniaBot等待鬼魂释放它的位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/2ef/817/c3b2ef81726485f94f1f391efa1ab2e6.png"></div><br> 该“跳前检查敌人”规则说明了CastlevaniaBot结构的原理之一：应遵循简单，尽可能通用的规则。 在游戏的某些部分，有必要使用一次性策略来解决非常具体的问题。 但是在大多数游戏中，机器人动作是由可重用的启发式驱动的。 我没有写一个让他停在那个特定地点并等待鬼魂挡开他们的队伍。 这种行为是启发式的结果。 <br><br>  CastlevaniaBot通过用三重圣水杀死幻影蝙蝠来完成关卡。 但是他的进攻策略是由他的辅助武器决定的。 实际上，如果他没有辅助武器，他准备用一根鞭子杀死老板。 一个特别有趣的案例是用斧头杀死了幻影蝙蝠。 与红色蝙蝠的情况类似，我在桌子上记录了斧头沿着抛物线的运动。 在游戏执行期间，CastlevaniaBot通过将其与每个地砖匹配来执行桌子偏移。 这使您可以计算出用斧头杀死BOSS的最佳点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/480/2de/d0c4802de26d9629ca4376a67513106f.png"></div><br> 就在拿起水晶球之前，CastlevaniaBot会向不同方向投掷辅助武器，因为它会在接触到球后冻结在空中。 然后，他反复随机跳跃并用鞭子击打，希望冻结在一个奇怪的姿势中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/83b/d56/f9083bd561d92261d581128157bdf205.png"></div><br> 在第2级开始时，CastlevaniaBot避开了回旋镖隐藏的第一支蜡烛。 与骑士长矛手合作的策略是反对鬼魂或鱼人策略的运动，但这是第一个杀死需要两次命中的敌人。 黑色蝙蝠会打，直到靠近它为止，然后它起飞并线性移动，足以使用上述简单的试探法用鞭子杀死。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3e/d23/01e/a3ed2301ee4a6689ef64648439eb1939.png"></div><br> 在50％的情况下，CastlevaniaBot破坏了墙的砖块，似乎离开了房间而没有抬起冠冕。 但是是这样吗？ 实际上，在这种情况下，他利用游戏中的错误拿到了桂冠。 由于上梯子的末端与树冠的位置在水平方向上重合，因此玩家在屏幕上方和后面经过时会暂时下降。 如果您听声音或看眼镜，您会看到机器人实际上获得了表冠。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/348/459/ef8/348459ef8dc72330b2d1bf99c63eb07d.png"></div><br> 在等级2上，当玩家处于移动平台上时，敌人不会攻击玩家。  CastlevaniaBot只需等待平台接近，进入平台，等待其到达另一侧，然后下车。 另一方面，不接触图块的平台也略有不同。 在这种情况下，CastlevaniaBot不会下降，但会跳下平台。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/161/7e3/f4c/1617e3f4c2b0f50832dba59992438aa7.png"></div><br> 一扇门通向充满飞扬头的走廊，CastlevaniaBot通过向前移动对此做出反应。 与移动平台一样，CastlevaniaBot知道需要根据其位置应用此策略，而不是对屏幕上的游戏对象进行优先排序。 但是，一旦海all的所有头部飞过，他就会切换回该技术以选择将被进一步使用的策略。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/0ce/dd8/c330cedd8cdb3748b08988787e1b58df.png"></div><br> 根据位置的不同，在爬下通往水母头满满的下一个梯子后，将触发另一种策略。 在50％的情况下，CastlevaniaBot故意跳到水母的头上以获得伤害加成，将其推到门旁的上层平台，通向下一阶段。 这是CastlevaniaBot知道的仅有的两种伤害提升方法。 与速度赛跑者不同，它不会执行以节省时间，这只是对段落不确定性的另一贡献。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ea/e45/c5c/0eae45c5c564301aa03fa376b85f43f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过暗恋是一种有趣的基于位置的策略，重复了三遍。</font><font style="vertical-align: inherit;">CastlevaniaBot一直等到它左侧最接近的“粉碎”到达所需位置，然后运行通过它。</font><font style="vertical-align: inherit;">经过它之后，他停下来，转身，用鞭子敲打蜡烛，捡起所创建的对象，并在随后的“粉碎”过程中重复该操作。</font><font style="vertical-align: inherit;">其中一个物体可能是圣水，因此它总是会破坏这些蜡烛。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/2b4/303/7d22b4303c14e5f460b4b090918ef1fb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“粉碎”之后，鬼魂和骨头塔首先出现。</font><font style="vertical-align: inherit;">幽灵很容易瞄准，但是要杀死它们，你需要击中几下。</font><font style="vertical-align: inherit;">瞄准骨塔更容易，因为它们不会移动。</font><font style="vertical-align: inherit;">他们的火球和鱼人球使用相同的策略。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b1/0ad/931/7b10ad9316ab8e0ef3f53007740ffd4a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2级通常以CastlevaniaBot结尾，并用无尽的圣水立即杀死美杜莎。</font><font style="vertical-align: inherit;">但是，他准备使用任何其他类型的辅助武器。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46a/02c/a28/46a02ca28233821148bd64afcf43ef65.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第3级，出现跳线。</font><font style="vertical-align: inherit;">CastlevaniaBot通过等待他们跳入鞭子的极限来对他们做出反应。</font><font style="vertical-align: inherit;">如果跳线使运动员跳下，则CastlevaniaBot朝相反的方向移动并用鞭子击打他们，然后再接触地面。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/ec4/58e/863ec458ebc43b8c3959750018c9952e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后出现白色骨架。</font><font style="vertical-align: inherit;">它们具有非常随机的模式。</font><font style="vertical-align: inherit;">另外，他们扔骨头。</font><font style="vertical-align: inherit;">在3级，CastlevaniaBot尝试避免被击中。</font><font style="vertical-align: inherit;">但是我发现，在随后的层次上，骨骼只会分散注意力，而忽略它们会更有效。</font><font style="vertical-align: inherit;">CastlevaniaBot对白色骨骼的策略是简单地击败它们。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/eaf/9e4/c4deaf9e44458c08487d89d22b5a9618.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot等待乌鸦飞起来。</font><font style="vertical-align: inherit;">然后，根据乌鸦相对于玩家的高度，他准确地计算出跳跃后何时用鞭子击打。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0b/7ce/78c/d0b7ce78cf8ea65a6001ca63a0a1d087.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入下一个阶段后，CastlevaniaBot独立击打计时码表出现的蜡烛，然后等待直到其消失。</font><font style="vertical-align: inherit;">在屏幕的前方和后方有个乌鸦。</font><font style="vertical-align: inherit;">该机器人会在乌鸦战斗前销毁蜡烛，以减少意外击中蜡烛并获得不需要的辅助武器的风​​险。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb3/a6a/c85/fb3a6ac852c7633a530ea2666f3cf3c0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在木乃伊位置的正前方，CastlevaniaBot左转到平台上，以触发隐藏的钱袋子的出现。</font><font style="vertical-align: inherit;">他这样做仅仅是出于兴趣，因为他无法以任何方式举起它。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/62d/ebe/2f462debef355d502ee9969489c0fa9b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，CastlevaniaBot故意击中匕首掉落的蜡烛。</font><font style="vertical-align: inherit;">像天文钟一样，他这样做是为了在随后的动作中不会偶然拿起它。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/094/9c7/0fa/0949c70faa3fcc414107b04ae8e1be68.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后，木乃伊被圣水的雨打败。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/0a6/75a/ee40a675a2432df6a4a3c24d2681c682.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot准备使用任何辅助武器与所有首领作战。</font><font style="vertical-align: inherit;">实际上，如果由于某种原因摧毁了一块装有猪肉的块，使用辅助武器的策略就会完全改变。</font><font style="vertical-align: inherit;">没有这个障碍，就不可能爬上较高的平台，这就是为什么您必须在较低级别上战斗。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第4级，移动平台正在回归。</font><font style="vertical-align: inherit;">这次，有机会在途中出现红色蝙蝠。</font><font style="vertical-align: inherit;">为了减少攻击的可能性，他希望平台的到来与红色蝙蝠的毁灭相吻合。</font><font style="vertical-align: inherit;">由于红色的老鼠以固定的间隔出现，因此，CastlevaniaBot有足够的时间在没有蝙蝠的情况下穿越水坑。</font><font style="vertical-align: inherit;">他随时准备在平台上与蝙蝠和随机出现的鱼人打交道，但这使从平台上跳下来非常危险。</font><font style="vertical-align: inherit;">CastlevaniaBot使用的策略增加了其成功的可能性。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/cb3/35b/f4acb335ba2cf17e29d42dfffe51d689.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在阶段的中间重复相同的策略。</font><font style="vertical-align: inherit;">这次，跳转到移动平台的时间更长，因此在跳转之前销毁红色蝙蝠至关重要。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b0/42c/e0d/6b042ce0d1ee7845c83d5ff1ea5c65cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上面的屏幕截图所示，蜡烛始终位于彼此相距64像素的位置。可能是由于以下事实的结果：水平数据以类似于矢量图形的格式显示在ROM中，从而节省了空间。但是由于某种原因，设计人员决定将蜡烛的位置与瓷砖的边缘而不是中心对齐。在这种情况下，蜡烛与平台的两端对齐。因此，在碰到它们之后，出现的物体可能会直接掉入它们下面的深渊中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为设计师在某个阶段就意识到了这个问题。但是到那时，将整个系列的蜡烛移至所有完成的高度以使其与瓷砖中心对齐可能会引起其他问题。相反，他们决定将蜡烛随机移动到创建位置的右侧或左侧一个像素。因此，点击屏幕截图右侧的蜡烛后，其中包含的圣水有50％的机会会落在平台上。在剩下的一半情况下，它掉入水中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot通常会完全避免使用这些蜡烛，因为它可以成功保存圣水。但是，如果他需要它，那么他会非常靠近这些蜡烛，以确保选择从中掉出的圣水。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个CastlevaniaBot遇到了一堆跳线。</font><font style="vertical-align: inherit;">在该区域，杀死跳线后，经常会出现斧子。</font><font style="vertical-align: inherit;">CastlevaniaBot避免使用它们，因为在与上司战斗时圣水特别有用。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/182/f5f/50e182f5fe39bc3e3145bb68aae819d7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当移动到关卡的最后一个阶段时，CastlevaniaBot完全忽略了骨龙。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/093/45e/a6c/09345ea6ca0024888d7be0f8d25785f6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是他用快速的鞭打摆脱了接下来的两个。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5f/0e5/d57/d5f0e5d5706307c36d5d9dd9c19052e7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学怪人的怪物和伊戈尔被鞭子和圣水持续不断的击打摧毁。</font><font style="vertical-align: inherit;">与其他老板一样，CastlevaniaBot也可以处理其他辅助武器，也可以完全不用。</font><font style="vertical-align: inherit;">但是，没有圣水的生存机会就减少了。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23f/606/220/23f6062203ce695c2a38c9d2d170926e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在5级，CastlevaniaBot再次处理白色骨骼。</font><font style="vertical-align: inherit;">但是这一次，他使用的策略变化在3级上很少见。根据其出现的位置，CastlevaniaBot抛出圣水，然后退后一步，将骨骼拉成火焰。</font><font style="vertical-align: inherit;">在楼梯附近，他经过骨骼下面，将它们定向到应有的位置。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64e/c6c/610/64ec6c6100a72265aab1f024c6561718.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第5级，重生的红色骨骼首先出现。</font><font style="vertical-align: inherit;">CastlevaniaBot跟踪最后一次击中它们的时间，以便知道何时安全通过红色骨骼。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/628/54c/8b662854cf5582b93cf299b0852964c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第14阶段的第一个房间由一个巨大的策略完全处理。 CastlevaniaBot首先杀死了跳投者。然后他等待下级骑士扔斧头，用鞭子击中斧头，然后慢慢爬下楼梯。这将下位骑士推到屏幕后方，导致他失踪。然后，他等到上部区域没有轴，击中蜡烛并收集出现的物体。然后他走近通往上层骑士的楼梯底部。当顶级骑士将斧头高高举起时，CastlevaniaBot追随他。这会将上层骑士推向左侧，几乎完全从屏幕上移开，但不会破坏它。 CastlevaniaBot在返回的斧头下方弯曲，并且可能在第二个废弃的斧头下方弯曲，然后最终走上楼梯进入下一个子阶段。</font></font>万岁！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/727/488/93a727488c3cd37cd381668415c1261b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经过几个台阶后，CastlevaniaBot再次与斧头骑士见面。</font><font style="vertical-align: inherit;">他用圣水使他昏迷，然后用鞭子使他完蛋。</font><font style="vertical-align: inherit;">如果没有圣水，他会继续用鞭子殴打，追逐骑士直到死。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81c/992/8d6/81c9928d6a77554910fb989df1fd4932.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上移5级楼梯时，CastlevaniaBot通常必须等待红色骨架从楼梯的顶部或底部移开。</font><font style="vertical-align: inherit;">在关卡接近尾声时，骨头塔使这项任务更加困难。</font><font style="vertical-align: inherit;">根据骨骼决定移动的方式，CastlevaniaBot上下楼梯直到可以通过为止。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65a/cd8/ed8/65acd8ed8ae89e882702cb9387b8c432.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要处理红色骨骼组，需要附加逻辑，以使漫游器不会陷入无限循环。如果CastlevaniaBot会用鞭子分别击败他们，以便第一击有时间恢复，那么它将陷入一个循环，在那里它将继续摧毁无休止的复活骨骼。为避免这种情况，CastlevaniaBot不会用一堆站在红色骨头旁边的红色骷髅鞭打中。此规则使红色骨骼可以在仍然存活的红色骨骼旁边重生，从而可以同时击中它们。如果销毁之间没有间隔，则不会创建周期。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/446/82b/18d/44682b18de7a81b58d01dd734e4f57f3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免在导致死亡的长走廊中出现水母，机器人不会停止，使通常出现在路途中的骑士惊艳。</font><font style="vertical-align: inherit;">他利用了这样一个事实，即玩家可以穿过被圣水击晕的敌人而不会受到伤害。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/d68/587/cabd685876fb241b8362a9f2f83482d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果没有圣水，那么在CastlevaniaBot走廊的正前方可以乘坐飞旋镖。</font><font style="vertical-align: inherit;">在成功的情况下，他用它摧毁了骑士，并获得了武器升级。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/738/a60/444738a60282b741af01e775ebfe70b2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot在开始编织辫子之前先用圣水使死亡晕眩，然后迅速杀死她。</font><font style="vertical-align: inherit;">他也可以用三重回旋镖击败死亡，但这通常需要进行几次尝试。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72a/fdb/57a/72afdb57a40c4f9613a71c6edd5beb17.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot在6级开始时通过桥梁的主要策略是继续前进。</font><font style="vertical-align: inherit;">他从上方击打了一下大蝙蝠以使其昏迷，然后从下方出现的巨大蝙蝠弹起。</font><font style="vertical-align: inherit;">此外，他还需要不时躲避蝙蝠扔出的火球，或用鞭子殴打它们。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/507/fa3/c82/507fa3c822d5a767e6b6a4916d1d2857.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能保证通过桥梁。</font><font style="vertical-align: inherit;">这完全取决于巨型蝙蝠的友好程度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在接下来的子步骤中，CastlevaniaBot使用桥梁的计时表两次或更多次来查看鹰和跳线。</font><font style="vertical-align: inherit;">没有计时器，他试图用鞭子走自己的路。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d06/4fd/3f3/d064fd3f3b249a76112632c100b34ccd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当CastlevaniaBot到达德古拉的塔楼时，它可以攀登和降下楼梯数次以再次产生蜡烛，这使您可以收集至少20颗心。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/338/cf3/525/338cf3525c8b5c0361cb98c23681f8b3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">德古拉房间中最右边的蜡烛会给圣水，这是对抗德古拉第二种形式所必需的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">击败德古拉的第一种形式需要对头部进行16次打击。</font><font style="vertical-align: inherit;">CastlevaniaBot数次接近德古拉，等待他用火球射击，然后跳过去，用鞭子击打德古拉的头。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ad/47e/af9/8ad47eaf9a2a962288480bbf49b844fc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该机器人的第二种形式的吸血鬼被称为Cookie Monster，被机器人用圣水击晕，并用鞭子多次击中头部。</font><font style="vertical-align: inherit;">Cookie Monster有时不时跳向玩家，而CastlevaniaBot躲闪。</font><font style="vertical-align: inherit;">Cookie Monster还会抛出火球，通常可以用圣水和鞭子将其摧毁。</font><font style="vertical-align: inherit;">有时您可以升级武器。</font><font style="vertical-align: inherit;">而且，双圣水会在持续的眩晕周期中抓住Cookie怪物，从而迅速取得胜利。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/05b/266/bdf05b2661aff44a2b0804865013b95b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot无法通过“困难模式”，该模式在获得最终学分后开始。</font><font style="vertical-align: inherit;">但是，在城堡庭院中重新启动游戏后，它将游戏周期字节重置为零，并将其切换到普通模式。</font><font style="vertical-align: inherit;">这使得CastlevaniaBot可以无休止地比赛。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/3a6/c4a/4c63a6c4ad709d26e0256a6ecdf07a61.png"></div><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 档案 </font></font></h1><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CastlevaniaBot_2018-12-09.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该文件</font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含：</font></font><br><br><ul><li> <code>src</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -源代码树。 </font></font></li><li> <code>CastlevaniaBot.jar</code> —   . </li><li> <code>lgpl-2.1.txt</code> —    . </li></ul><br><hr><br><h1> 发射 </h1><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nintaco</a> —  NES. </li><li> <code>Castlevania (U) (PRG1) [!].nes</code> — ROM . </li></ul><br><h2>   </h2><br><ol><li>  Nintaco   <code>Castlevania (U) (PRG1) [!].nes</code> . </li><li>  <code>CastlevaniaBot.jar</code>   <code>.zip</code> . </li><li>   Run Program,  Tools | Run Program... </li><li>       JAR   ,    Find JAR.... </li><li>  Load JAR,   . </li><li>  Run. </li></ol><hr><table><tbody><tr><td> Copyright © 2018 meatfighter.com <br><br>      .     /      LGPLv2.1. </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432784/">https://habr.com/ru/post/zh-CN432784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432774/index.html">前端开发日。 报告记录</a></li>
<li><a href="../zh-CN432776/index.html">《行动中的反应》一书</a></li>
<li><a href="../zh-CN432778/index.html">在STM32F334上开发降压转换器：工作原理，计算，原型设计</a></li>
<li><a href="../zh-CN432780/index.html">为什么在科技界需要同理心</a></li>
<li><a href="../zh-CN432782/index.html">Zimbra Collaboration Suite多服务器安装</a></li>
<li><a href="../zh-CN432786/index.html">.NET-轻松进行本地化。 （N）gettext + poedit</a></li>
<li><a href="../zh-CN432788/index.html">原型：如何创建成功的产品并保存</a></li>
<li><a href="../zh-CN432790/index.html">超导体+铁磁体：三重态库珀对的研究</a></li>
<li><a href="../zh-CN432794/index.html">布雷特·维克托（Bret Victor）：关于道格拉斯·恩格尔巴特（Douglas Engelbart）的一些话</a></li>
<li><a href="../zh-CN432796/index.html">计算模块，2019年款</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>