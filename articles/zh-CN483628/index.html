<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏾 ⏳ 🤯 从OpenAPI v3（aka Swagger 3）到TypeScript的代码生成 👟 🛌🏿 📍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="两年前，我开始开发  还有一个  从OpenAPI Specification v3到TypeScript的免费代码生成器（ 可在Github上获得 ）。 最初，我开始考虑使用各种JSON Schema功能，例如oneOf / anyOf / allOf等，在TypeScript中高效地生成原始数据...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从OpenAPI v3（aka Swagger 3）到TypeScript的代码生成</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483628/"><p> 两年前，我开始开发 <del> 还有一个 </del> 从<a href="https://swagger.io/docs/specification/about/">OpenAPI Specification</a> v3到TypeScript的免费代码生成器（ <a href="https://github.com/koshevy/codegena">可在Github上获得</a> ）。 最初，我开始考虑使用各种<a href="https://json-schema.org/">JSON Schema</a>功能，例如<a href="https://json-schema.org/understanding-json-schema/reference/combining.html">oneOf / anyOf / allOf</a>等，在TypeScript中高效地生成原始数据和复杂数据类型。  （Swagger的<a href="https://github.com/swagger-api/swagger-codegen">本机解决方案</a>对此存在一些问题）。 另一个想法是使用规范中的模式在系统的正面，背面和其他部分进行验证。 </p><br><p><img src="https://habrastorage.org/webt/hz/cd/u4/hzcdu47rcjbutgqbe6pdb2k46x8.png"></p><a name="habracut"></a><br><p> 现在代码生成器已经准备就绪-处于<a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE_%25D0%25B6%25D0%25B8%25D0%25B7%25D0%25BD%25D0%25B5%25D1%2581%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BE%25D0%25B1%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BA%25D1%2582">MVP</a>阶段。 它在生成数据类型方面有很多需求，还有一个用于生成前端服务的实验库（到目前为止，对于Angular）。 在本文中，我想展示这些开发，并告诉您使用TypeScript和OpenAPI v3时它们如何提供帮助。 在此过程中，我想分享一些在我的工作过程中出现的想法和考虑。 好吧，如果您有兴趣，可以阅读我藏在扰流板中的背景故事，以免使技术部分的阅读复杂化。 </p><br><h2 id="soderzhanie"> 目录内容 </h2><br><ol><li>  <a href="https://habr.com/ru/post/483628/">背景知识</a> </li><li>  <a href="https://habr.com/ru/post/483628/">内容描述</a> </li><li>  <a href="https://habr.com/ru/post/483628/">安装及使用</a> </li><li>  <a href="https://habr.com/ru/post/483628/">练习使用代码生成器</a> </li><li>  <a href="https://habr.com/ru/post/483628/">在应用程序中使用生成的数据类型</a> </li><li>  <a href="https://habr.com/ru/post/483628/">分解符合OAS规范的电路</a> </li><li>  <a href="https://habr.com/ru/post/483628/">嵌套分解</a> </li><li>  <a href="https://habr.com/ru/post/483628/">自动生成的用于REST API的服务</a> <br><ol><li>  <a href="https://habr.com/ru/post/483628/">为什么需要这个？</a> </li><li>  <a href="https://habr.com/ru/post/483628/">服务生成</a> </li><li>  <a href="https://habr.com/ru/post/483628/">使用生成的服务</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/483628/">而不是后记</a> </li></ol><br><a name="Foreword"></a><br><h2 id="predystoriya"> 背景知识 </h2><br><div class="spoiler">  <b class="spoiler_title">展开阅读（跳过）</b> <div class="spoiler_text"><p> 一切都始于两年前-然后我在一家开发数据挖掘平台的公司工作，负责前端（主要是TypeScript + Angular）。 项目功能是具有大量参数（30个或更多）的复杂数据结构，并且它们之间并不总是显而易见的业务关系。 公司发展壮大，软件环境不断变化。 前端必须精通细微差别，因为在前端和后端重复了一些计算。 就是说，当使用OpenAPI超出适当范围时就是这种情况。 我在公司工作了一段时间，几个月后，开发团队就获得了一个规范，这成为后端，前端乃至核心部门（隐藏在Web后端的背后）的通用知识库。 选择OpenAPI版本是为了“增长”-那时v3.0还很年轻 </p><br><p> 这不再是一个或多个静态YML / JSON文件中的规范，而不再是<a href="https://github.com/zircote/swagger-php">注释器</a>的结果，而是一个按照平台DDD概念组织的组件，方法，模板和属性的完整库。 该库分为目录和文件，专门安排了一个收集者，为每个主题领域制作了OAS文档。 建立了实验性的工作流程，可以将其描述为“设计优先”。 </p><br><blockquote>  Yandex.Money公司的博客上有一篇<a href="https://habr.com/ru/company/yamoney/blog/347390/">很好的文章</a> ，内容涉及Design First </blockquote><p>  “设计优先”和通用规范有助于减少知识的使用，但是一个新问题变得很明显-保持了代码的相关性。 该规范描述了数十种方法和数十种（以及后来的数百种）实体。 但是代码必须手动编写：数据类型，用于REST的服务等。 一两个带有平行故事的冲刺极大地改变了局面。 为多个故事和人为因素的合并增加了复杂性。 该例程可能非常重要，解决方案似乎很明显-您需要代码生成。 毕竟，OAS规范已经包含了所有必要的内容，以免手动输入。 但这不是那么简单。 </p><br><p> 前端处于生产周期的最后，因此与其他部门的同事相比，我感到更加痛苦的变化。 在设计REST API时，后端环境是决定性的，即使在“设计优先”获得批准后，惯性仍然存在。 对于前端，一切似乎都不那么明显。 实际上，我从一开始就了解这一点，并开始提前探究土壤-当谈论“通用”规范才刚刚开始时。 没有人谈论编写自己的代码生成器。 我只是想找到准备好的东西。 </p><br><p> 我很失望。 有两个问题：OAS版本3.0，似乎没有人提供支持，而且解决方案本身的质量也很不错-当时（我记得是两年前），我设法找到了两个相对现成的解决方案： <a href="https://github.com/swagger-api/swagger-codegen">Swagger</a>和Microsoft （似乎<a href="https://github.com/Azure/autorest">是</a> ）。 首先，对OAS 3.0的支持处于深度测试阶段。 第二个仅适用于2.x版，但没有明确的预测。 顺便说一句，即使在Swagger 2.0格式的测试文档上，我也无法启动Microsoft代码生成器。  Swagger的解决方案有效，但是带有$ ref链接的或多或少复杂的方案变成了难以理解的“ ERROR！”，并且递归依赖性将其发送到了无限循环中。  <a href="">原始类型</a>存在问题。 另外，我不太了解如何使用自动生成的服务-它们似乎是为展示而制作的，并且它们的实际使用产生了比其解决的问题更多（我认为）。 最后，将JAR文件集成到面向NPM的CI / CD中很不方便：我不得不手动下载<a href="https://oss.sonatype.org/content/repositories/snapshots/io/swagger/codegen/v3/swagger-codegen-cli/3.0.15-SNAPSHOT/">必要的快照</a> （似乎重13兆字节），并对其进行处理。 总的来说，我休息了一会，决定观察接下来会发生什么。 </p><br><p> 大约五个月后，再次出现了代码生成问题。 我不得不重写和扩展Web应用程序的一部分，与此同时，我想重构用于使用REST API和数据类型的旧服务。 但是对复杂性的评估并不乐观：从一个人周到两个星期-但这仅用于REST服务和类型描述。 我不会说这让我非常沮丧，但仍然如此。 另一方面，我从未找到用于代码生成的解决方案，也没有等待，并且其实现几乎不需要花费更多时间。 也就是说，毫无疑问：收益是可疑的，风险是巨大的。 没有人会支持这个想法，我没有提出。 同时，五月假期临近，公司“欠”我几天时间在周末工作。 有两个星期，我从所有的工作经历中逃到了佐治亚州，在那里我曾经住了将近一年。 </p><br><p> 在聚会和宴会之间，我需要做一些事情，于是我决定写下自己的决定。 在Vake Park附近的夏季咖啡馆工作令人惊讶，工作效率很高，我带着现成的用于数据类型的代码生成器回到Peter。 然后又一个月，我在他准备上班之前的周末“完成”了服务。 </p><br><p> 从一开始，我就打开了代码生成器，并在业余时间使用它。 尽管实际上他是为工作草案而写的。 我不会说修订/磨合没有任何问题； 我不会说它们很重要。 但是到了某个时候，我注意到我停止使用Redoc / Swagger文档：只要代码始终是最新的并带有注释，浏览代码就会更加方便。 很快，我“得分”我的成就，而根本没有发展，直到一位同事（现在是六个月前我去另一家公司）建议我更认真地对待他们（他也想出了这个名字）。 </p><br><blockquote> 我没有足够的空闲时间，因此花了几个月的时间我才能在后台完成工作： <a href="https://stackblitz.com/edit/codegena-playground">操场</a> ，测试应用程序，项目重组。 现在，我准备接收反馈。 </blockquote></div></div><br><a name="Description"></a><br><h2 id="opisanie"> 内容描述 </h2><br><p>目前，用于代码生成的解决方案包括三个NPM库，它们集成在@codegena <code>@codegena</code>并位于一个公共的<a href="https://github.com/koshevy/codegena">单色存储库中</a> ： </p><br><div class="scrollable-table"><table><thead><tr><th> 图书馆 </th><th> 内容描述 </th></tr></thead><tbody><tr><td>  @ codegena / oapi3ts </td><td> 基础库是从OAS3到数据类型描述的转换器（现在仅支持TypeScript） </td></tr><tr><td>  @ codegena / ng-api-service </td><td> 扩展角度服务 </td></tr><tr><td>  @ codegena / oapi3ts-cli </td><td>  Shell，可在CLI脚本中方便使用 </td></tr></tbody></table></div><br><a name="SetupAndUsing"></a><br><h3 id="ustanovka-i-ispolzovanie"> 安装及使用 </h3><br><p> 最实用的选择是在从CLI运行的NodeJS脚本中使用。 首先，您需要安装依赖项： </p><br><pre> <code class="plaintext hljs">npm i @codegena/oapi3ts, @codegena/ng-api-service, @codegena/oapi3ts-cli</code> </pre> <br><p> 然后，使用以下代码创建一个js文件（例如<code>update-typings.js</code> ）： </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); <span class="hljs-comment"><span class="hljs-comment">// cliApp.createServices('angular'); // optional</span></span></code> </pre> <br><p> 并通过传递三个参数启动它： </p><br><pre> <code class="plaintext hljs">node ./update-typings.js --srcPath ./specs/todo-app-spec.json --destPath ./src/lib --separatedFiles true</code> </pre> <br><p> 在<code>destPath</code>将生成文件，实际上， <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib">该目录</a>在项目存储库中的内容是以相同的方式创建的。  <a href="">这是生成脚本</a> ， <a href="">这就是</a>它在NPM脚本中的运行方式。 但是，如果您愿意，甚至可以在浏览器中使用它，就像在<a href="https://codegena-playground.stackblitz.io/">Playground中一样</a> 。 </p><br><a name="CodegenerationUsingPractice"></a><br><h2 id="praktika-ispolzovanie-kodogeneratora"> 练习使用代码生成器 </h2><br><p> 接下来，我想谈谈我们将得到的结果：这将如何帮助我们。 视觉辅助将是演示应用程序的代码。 它由两部分组成：一个后端（在<a href="https://nestjs.com/">NestJS</a>框架上）和一个前端（在<a href="https://angular.io/">Angular上</a> ）。 如果愿意，您甚至<a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877">可以在本地运行它</a> 。 </p><br><blockquote> 即使您不熟悉Angular和/或NestJS，也不会引起问题：大多数TypeScript开发人员应理解将提供的代码示例。 </blockquote><p> 尽管应用程序已尽可能简化（例如，后端将数据存储在会话中，而不是数据库中），但我还是尝试重新创建真实应用程序中固有的数据流和数据类型层次结构的功能。 大约80-85％已经准备好了，但是“完成”可能会延迟，但是现在更重要的是谈论已经存在的东西。 </p><br><a name="UsingGeneratedDataTypes"></a><br><h2 id="ispolzovanie-generiruemyh-tipov-dannyh-v-prilozheniyah"> 在应用程序中使用生成的数据类型 </h2><br><p> 假设我们有一个必须使用的OpenAPI规范（例如， <a href="">此</a>规范）。 不管是从头开始创建东西还是获得支持，我们最有可能从一开始就着手做一件事-输入。 我们将开始描述基本数据类型或对其进行更改。 大多数程序员这样做是为了促进他们将来的开发。 因此，您不必再次查看文档，请记住参数列表； 并且您可以确保IDE和/或编译器会注意到输入错误。 </p><br><p> 我们的规范可能包括也可能不包括<a href="">components.schem的</a>部分。 但无论如何，它将描述参数，请求和答案的集合-我们可以使用它。 考虑一个例子： </p><br><pre> <code class="javascript hljs">@Controller(<span class="hljs-string"><span class="hljs-string">'group'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Put(':groupId') rewriteGroup( @Param(ParseQueryPipe) { groupId }: RewriteGroupParameters, @Body() body: RewriteGroupRequest, @Session() session ): RewriteGroupResponse&lt;HttpStatus.OK&gt; { return this.appService .setSession(session) .rewriteGroup(groupId, body); } // ... }</span></span></code> </pre> <br><p> 这是NestJS框架的<a href="">控制器</a>片段，其中键入了参数（ <code>RewriteGroupParameters</code> ），请求正文（ <code>RewriteGroupRequest</code> ）和响应正文（ <code>RewriteGroupResponse&lt;T&gt;</code> ）。 在此代码片段中，我们已经看到了键入的好处： </p><br><ul><li> 如果混淆被破坏的参数<code>groupId</code>的名称，而改为指定<code>groupId</code> ， <code>groupId</code>立即在编辑器中出现错误。 <br><img src="https://habrastorage.org/webt/1z/2q/0c/1z2q0cstw2lv3vncwmgi8gkxfa0.png"></li><li> 如果<a href="">this.appService.rewriteGroup（groupId，body）</a>方法具有类型化的参数，则我们可以控制传递的<code>body</code>参数的正确性。 如果控制器方法或服务方法的输入数据格式发生更改，我们将立即知道。 展望未来，我注意到service方法的输入方法的数据类型不同于<code>RewriteGroupRequest</code> ，但是在我们的例子中，它们将彼此相同。 但是，如果突然改变了服务方法，并开始接受<code>ToDoGroup</code>而不是<code>ToDoGroupBlank</code> ，则IDE和编译器将立即显示差异的位置： <br><img src="https://habrastorage.org/webt/wo/cq/rr/wocqrrks2gtcthaq_wghrhlbbta.png"></li><li> 同样，我们可以控制返回结果的符合性。 如果成功响应的状态在规范中突然改变，从<code>202</code>变为<code>200</code> ，而不是<code>200</code> ，我们也会发现它，因为<code>RewriteGroupResponse</code>是<a href="">具有枚举类型的泛型</a> ： <br><img src="https://habrastorage.org/webt/pt/io/ss/ptiossjjfhihchrlwdlydrrkft4.png"></li></ul><br><p> 现在，让我们看一下<a href="">前端应用程序</a>中与<a href="">另一个API方法</a>一起使用<a href="">的示例</a> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSelectedGroupData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(truth: ComponentTruth)</span></span></span><span class="hljs-function">: Observable&lt;ComponentTruth&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getGroupsService.request(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, { isComplete: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, withItems: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;<span class="hljs-number"><span class="hljs-number">200</span></span>&gt;&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadItemsOfSelectedGroups({ ...truth, groups }) ) ); }</code> </pre> <br><p> 让我们不要超越自己，解析自定义RxJS运算符<code>pickResponseBody</code> ，而是让我们集中精力优化<code>pickResponseBody</code>类型。 我们在RxJS运算符链中使用它，其后的运算符具有<code>ToDoGroup[]</code>的输入细化。 如果该代码有效，则指示的数据类型彼此对应。 在这里，我们还可以控制类型匹配，如果API中的响应格式突然发生变化，这将不会引起我们的注意： </p><br><p><img src="https://habrastorage.org/webt/ci/hr/7c/cihr7csbo5kqn9fqkreoij7kuxk.png"></p><br><p> 当然，还会键入<code>this.getGroupsService.request</code>的调用参数。 但这是生成服务的主题。 </p><br><blockquote> 在以上示例中，我们看到可以在系统的各个部分（前端，后端等）中使用请求，响应和参数的类型。 如果后端和前端在同一个单一存储库中，并且具有兼容的生态环境，则它们可以对生成的代码使用相同的<a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877/libs/todo-app-scheme">共享库</a> 。 但是，即使后端和前端由不同的团队支持，并且除了公共OAS规范外没有其他共同点，对于他们来说，同步代码仍然更加容易。 </blockquote><br><a name="DecompositionInOAS"></a><br><h2 id="dekompoziciya-shem-vnutri-oas-specifikacii"> 分解符合OAS规范的电路 </h2><br><p> 可能在前面的示例中，您关注了<code>ToDoGroupBlank</code>和<code>ToDoGroup</code> ，它们与<code>RewriteGroupResponse</code>和<code>RewriteGroupResponse</code> <code>GetGroupsResponse</code> 。 实际上， <code>RewriteGroupResponse</code>只是<code>ToDoGroup</code> ， <code>HttpErrorBadRequest</code>等的通用别名。 很容易猜到<a href="">ToDoGroup</a>和<a href="">HttpErrorBadRequest</a>都是<a href="">rewriteGroup端点</a> （直接或通过<a href="">中介</a> ）引用的<a href="">components.schem</a>规范部分中的方案： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"200"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Todo group saved"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"application/json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoGroup"</span></span> } } } }, <span class="hljs-attr"><span class="hljs-attr">"400"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorBadRequest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"404"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorGroupNotFound"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"409"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorConflict"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"500"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorServer"</span></span> } }</code> </pre><br><p> 这是数据结构的常见分解，其原理与其他编程语言相同。 组件也可以分解：引用其他组件（包括递归），使用组合和其他JSON Schema功能。 但是，无论复杂度如何，都应将其正确转换为数据类型的描述。 我想展示如何在OpenAPI中使用分解，以及生成的代码的外观。 </p><br><blockquote> 精心设计的OAS规范中的组件将与使用它的应用程序的DDD模型重叠。 但是，即使规范不完善，您也可以依靠它来构建自己的数据模型。 这将使您可以更好地控制数据类型与可集成子系统的数据类型之间的对应关系。 </blockquote><p> 由于我们的应用程序是任务列表，因此主要的本质是任务。 首先将其放入组件是合乎逻辑的，因为 其他实体和端点将以某种方式与其连接。 但是在此之前，您需要了解两件事： </p><br><ul><li> 我们不仅描述抽象，而且描述验证的规则，并且它们越准确和明确，就越好。 </li><li> 像数据库中存储的任何实体一样，任务具有两种类型的属性：服务和用户输入。 </li></ul><br><p> 事实证明，根据使用情况，我们有两个数据结构：用户刚创建的Task和已经存储在数据库中的Task。 在第二种情况下，它具有唯一的UID，创建日期，更改等，并且必须在后端分配此数据。 我描述了两个实体（ <code>ToDoTaskBlank</code>和<code>ToDoTask</code> ），第一个是第二个的子集： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ToDoTaskBlank"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Base part of data of item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Data about group item needed for creation of it"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"groupUid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of group that item belongs to"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Short brief of task to be done"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Detailed description and context of the task. Allowed using of Common Markdown."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: [<span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"null"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">1024</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Status of task: is done or not"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Position of a task in group. Allows to track changing of state of a concrete item, including changing od position."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"min"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span>: <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"attachments"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Any material attached to the task: may be screenshots, photos, pdf- or doc- documents on something else"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMeta"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"maxItems"</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: [] } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"isDone"</span></span>, <span class="hljs-string"><span class="hljs-string">"title"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Book soccer field"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The complainant agreed and recruited more members to play soccer."</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ToDoTask"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Describe data structure of an item in group of tasks"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"allOf"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoTaskBlank"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of task"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateCreated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was created"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateChanged"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was changed last time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dateChanged"</span></span>, <span class="hljs-string"><span class="hljs-string">"dateCreated"</span></span>, <span class="hljs-string"><span class="hljs-string">"position"</span></span>, <span class="hljs-string"><span class="hljs-string">"uid"</span></span> ] } ] } }</code> </pre> <br><p> 在输出中，我们得到两个TypeScript接口，第<a href="">一个</a>将被<a href="">第二个</a>继承： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of item in todo's group * Data about group item needed for creation of it */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... imagine there are ToDoTaskBlank properties } /** * ## Item in todo's group * Describe data structure of an item in group of tasks */ export interface ToDoTask extends ToDoTaskBlank { /** * ## UID of element * An unique id of task */ readonly uid: string; /** * Date/time (ISO) when task was created */ readonly dateCreated: string; /** * Date/time (ISO) when task was changed last time */ readonly dateChanged: string; // ... imagine there are ToDoTaskBlank properties }</span></span></code> </pre> <br><p> 现在，我们有了Task实体的基本描述，并且像在<a href="">演示应用程序中</a>所做的那样，在<strong>我们的应用程序代码中</strong>引用了它们： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask, ToDoTaskBlank, } from <span class="hljs-string"><span class="hljs-string">'@our-npm-scope/our-generated-lib'</span></span>; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ isInvalid?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task just created, has temporary uid * and not saved yet. */</span></span> isJustCreated?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task is saving now. */</span></span> isPending?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Previous uid of task temporary assigned until * it gets saved and gets new UID from backend. */</span></span> prevTempUid?: string; }</code> </pre> <br><p> 在此示例中，我们描述了一个新实体，向<code>ToDoTask</code>添加了前端应用程序端缺少的那些属性。 也就是说，实际上，我们在考虑到本地细节的情况下扩展了结果数据模型。 围绕此模型，一组<a href="">本地工具</a>以及诸如原始DTO之类的东西逐渐增长： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = { ...taskTeaser }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!task.description || !task.description.trim()) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.description; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task.description = task.description.trim(); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isJustCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isPending; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.prevTempUid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTaskBlank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = downgradeTeaserToTask(taskTeaser) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateChanged; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.uid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">有人更喜欢使数据模型更完整并使用类。</b> <div class="spoiler_text"><pre> <code class="java hljs">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// … imagine, definitions from ToDoTask are here constructor( task: ToDoTask, public isInvalid?: boolean, public isJustCreated?: boolean, public isPending?: boolean, public prevTempUid?: string ) { Object.assign(this, task); } downgradeTeaserToTask(): ToDoTask { const task = {...this}; if (!task.description || !task.description.trim()) { delete task.description; } else { task.description = task.description.trim(); } delete task.isJustCreated; delete task.isPending; delete task.prevTempUid; return task; } downgradeTeaserToTaskBlank(): ToDoTaskBlank { // … some code } }</span></span></code> </pre> </div></div><br><p> 但这是样式，适当性以及应用程序体系结构将如何开发的问题。 通常，无论采用哪种方法，我们都可以依靠基本的数据模型并更好地控制键入的一致性。 因此，如果由于某种原因<code>ToDoTask</code>的<code>uid</code>变成了数字，我们将了解需要更新的代码的所有部分： </p><br><p><img src="https://habrastorage.org/webt/cc/7g/yz/cc7gyzy0tc4oh5zpomvjy09endw.png"></p><br><a name="NestedDecomposition"></a><br><h2 id="vlozhennaya-dekompoziciya"> 嵌套分解 </h2><br><p> 所以现在我们有了<code>ToDoTask</code>接口，我们可以引用它。 同样，我们将描述<a href="">ToDoTaskGroup</a>和<a href="">ToDoTaskGroupBlank</a> ，它们将分别包含<code>ToDoTask</code>和<code>ToDoTaskBlank</code>类型的属性。 但是现在我们将“任务组”分为两个部分，而不是三个部分：为清楚起见，我们将在<a href="">ToDoGroupExtendedData中</a>描述增量。 因此，我想演示一种方法，其中一个组件是由其他两个组件创建的： </p><br><pre> <code class="plaintext hljs">"ToDoGroup": { "allOf": [ { "$ref": "#/components/schemas/ToDoGroupBlank" }, { "$ref": "#/components/schemas/ToDoGroupExtendedData" } ] }</code> </pre> <br><p> 开始生成代码后，我们得到了稍微不同的TypeScript构造： </p><br><pre> <code class="java hljs">export type ToDoGroup = ToDoGroupBlank &amp; <span class="hljs-comment"><span class="hljs-comment">// Data needed for group creation ToDoGroupExtendedData; // Extended data has to be obtained after first save</span></span></code> </pre> <br><p> 由于<code>ToDoGroup</code>没有自己的“主体”，因此代码生成器倾向于将其转换为接口的并集。 但是，如果您使用自己的（匿名）方案添加第三部分，则结果将是具有两个祖先的接口（但最好不要这样做）。 并且请注意， <code>ToDoGroupBlank</code>接口的<code>items</code>属性键入为<code>ToDoTaskBlank</code>的数组，并在<code>ToDoGroupBlank</code>的<code>ToDoTask</code>重新定义。 因此，代码生成器能够将相当复杂的分解细节从JSON模式传递到TypeScipt。 </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTaskBlank } from <span class="hljs-string"><span class="hljs-string">'./to-do-task-blank'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of group * Data needed for group creation */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items?: Array&lt;ToDoTaskBlank&gt;; // ... }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask } from <span class="hljs-string"><span class="hljs-string">'./to-do-task'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Extended data of group * Extended data has to be obtained after first save */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupExtendedData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items: Array&lt;ToDoTask&gt;; }</span></span></code> </pre><br><p> 好吧，当然，在<code>ToDoTask</code> / <code>ToDoTaskBlank</code>我们也可以使用分解。 您可能已经注意到， <code>attachments</code>属性描述为<a href="">AttachmentMeta</a>类型的元素数组。 并且此组件描述如下： </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">"AttachmentMeta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Common meta data model of any type of attachment"</span></span>, <span class="hljs-string"><span class="hljs-string">"oneOf"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaImage"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaDocument"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ExternalResource"</span></span>} ] }</code> </pre> <br><p> 即，该组件是指其他组件。 由于它没有自己的方案，因此代码生成器不会将其设置为单独的数据类型，以免与实体相乘，而是将其枚举类型设为匿名描述： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Any material attached to the task: may be screenshots, photos, pdf- or doc- * documents on something else */</span></span> attachments?: Array&lt; | AttachmentMetaImage <span class="hljs-comment"><span class="hljs-comment">// Meta data of image attached to task | AttachmentMetaDocument // Meta data of document attached to task | string // Link to any external resource &gt;;</span></span></code> </pre> <br><p> 同时，对于<code>AttachmentMetaImage</code>和<code>AttachmentMetaDocument</code>组件，描述了使用它们导入文件的非匿名接口： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaDocument } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-document'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaImage } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-image'</span></span>;</code> </pre> <br><p> 但是即使在<a href="">AttachmentMetaImage中，</a>我们也可以找到另一个渲染的<a href="">ImageOptions</a>接口的链接，该接口被使用了两次，包括在一个匿名接口内部（从<a href="">AdditionalProperties</a>转换的结果）： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ImageOptions } from <span class="hljs-string"><span class="hljs-string">'./image-options'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Meta data of image attached to task */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttachmentMetaImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * Possible thumbnails of uploaded image */ thumbs?: { [key: string]: { /** * Link to any external resource */ url?: string; imageOptions?: ImageOptions; }; }; // ... imageOptions: ImageOptions; }</span></span></code> </pre> <br><p> 因此，基于<code>ToDoTask</code>或<code>ToDoGroup</code> ，我们实际上将几个实体及其业务连接链集成到我们的代码中，这使我们可以更好地控制超出代码范围的整个系统中的更改。 当然，这并非在所有情况下都有意义。 但是，如果您使用的是OpenAPI，那么除了实际的文档外，您可能还会获得一笔额外的红利。 </p><br><a name="ServiceGeneration"></a><br><h2 id="avtogeneraciya-servisov-dlya-raboty-s-rest-api"> 自动生成的用于REST API的服务 </h2><br><a name="WhyItNeccessary"></a><br><h3 id="zachem-eto-nuzhno"> 为什么需要这个？ </h3><br><p> 如果我们采用一个普通的统计前端应用程序，该应用程序可以使用或多或少复杂的REST API，则其代码的相当一部分将是用于访问API的服务（或仅仅是函数）。 它们将包括： </p><br><ul><li>  URL和参数映射 </li><li> 验证参数，请求和响应 </li><li> 数据提取和紧急处理 </li></ul><br><p> 令人不快的是，这在许多方面都是典型的，并且不包含任何唯一逻辑。 让我们假设一些示例-作为一般概述，可以构建使用API​​的方法： </p><br><div class="spoiler">  <b class="spoiler_title">使用REST API的简化原理图示例</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, fromFetch, throwError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { switchMap } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Definitions const URLS = { 'getTasksOfGroup': `${env.REST_API_BASE_URL}/tasks/\${groupId}`, // ... other urls ... }; const URL_TEMPLATES = _.mapValues(urls, url =&gt; _.template(url)); interface GetTaskConditions { isDone?: true | false; offset?: number; limit?: number; } interface ErrorReponse { error: boolean; message?: string; } // Helpers // I taken this snippet from StackOverflow only for example function encodeData(data) { return Object.keys(data).map(function(key) { return [key, data[key]].map(encodeURIComponent).join("="); }).join("&amp;"); } // REST API functions // our REST API working function example function getTasksFromServer(groupUid: string, conditions: GetTaskConditions = {}): Observable&lt;Response&gt; { if (!groupUid) { return throwError(new Error('You should specify "groupUid"!')); } if (!_.isString(groupUid)) { return throwError(new Error('`groupUid` should be string!')); } if (_.isBoolean(conditions.isDone)) { // ... applying of conditions.isDone } else if (conditions.isDone !== undefined) { return throwError(new Error('`isDone` should be "true", "false" or should\'t be set!'!)); } if (offset) { // ... check of `offset` and applying or error throwing } if (limit) { // ... check of `limit` and applying or error throwing } const url = [ URL_TEMPLATES['getTasksOfGroup']({groupUid}), ...(conditions ? [encodeData(conditions)] : []) ]; return fromFetch(url); } // Using of REST API working functions function getRemainedTasks(groupUid: number): Observable&lt;ToDoTask[] | ErrorReponse&gt; { return getTasksFromServer(groupUid, {isDone: false}).pipe( switchMap(response =&gt; { if (response.ok) { // OK return data return response.json(); } else { // Server is returning a status requiring the client to try something else. return of({ error: true, message: `Error ${response.status}` }); } }), catchError(err =&gt; { // Network or other error, handle appropriately console.error(err); return of({ error: true, message: err.message }) }) ); }</span></span></code> </pre> </div></div><br><p> 您可以使用高级抽象来使用REST-根据所使用的堆栈，它可以是： <a href="https://github.com/axios/axios">Axios</a> ， <a href="http">Angular HttpClient</a>或任何其他类似的解决方案。 但最有可能的是，基本上您的代码将与此示例一致。 几乎可以肯定的是，它将包括： </p><br><ul><li> 用于访问特定端点的服务或函数（在我们的示例中为<code>getTasksFromServer</code>函数） </li><li> 处理结果的代码段（ <code>getRemainedTasks</code>函数） </li></ul><br><p> 在来自现实世界的应用程序中，此代码将更加复杂：演示应用程序的规范<a href="">描述了5-6个答案选项</a> 。 通常，REST API的设计方式是必须相应处理服务器的每个响应状态。 但是，即使在应用程序开发过程中，即使检查输入数据也往往变得更加困难：支持和处理错误检查所花费的时间越多，您就越想知道应用程序中数据流通的瓶颈。 </p><br><blockquote> 在软件部件对接的每个节点上可能会发生错误，对其进行不及时的检测（以及对难以诊断的问题的搜索）对于企业而言可能是非常昂贵的。 因此，将进行其他澄清检查。 随着代码库的增长和涵盖的案例数的增加，进行更改的复杂性也随之增加。 但是业务是不断变化的，因此无法克服。 因此，我们应该在意如何预先进行更改。 </blockquote><p> 回到OpenAPI主题，我们注意到在OAS规范中可能有足够的信息来： </p><br><ul><li>    -      </li><li>       </li><li>   URL      </li><li>         </li></ul><br><p>         — <strong></strong> .    ,     ,     /  — 5, 10  200,            .  ,      ,   : , , , RxJS- <a href="">pickResponseBody</a> ,            ,     - ;  <a href="">tapResponse</a> ,    side-effect (tap)   HTTP-.     ,     -   .    ,       ,    . </p><br><blockquote> ,     —   -,      .      ,       ,  ,   ""  /     API     "-"  "" .    -   ,        "" (    ),     . </blockquote><p>   ,          REST API   Angular.         ,      ,        /.      . ,      ,    .  ,      , ..      . </p><br><a name="HowToGenerateServices"></a><br><h3 id="generaciya-servisov">   </h3><br><p>   " <a href="https://habr.com/ru/post/483628/">  </a> "      .   Angular-,       <code>update-typings.js</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); cliApp.createServices(<span class="hljs-string"><span class="hljs-string">'angular'</span></span>);</code> </pre> <br><p>             ,   Angular-    API   .    , -   - ,     <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib/services"> </a> .     ,    <a href="">RewriteGroupService</a> .    <a href="">ApiService</a> ,        ,   ,   -: </p><br><div class="spoiler"> <b class="spoiler_title">-  </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Typings for this API method import { RewriteGroupParameters, RewriteGroupResponse, RewriteGroupRequest } from '../typings'; // Schemas import { schema as domainSchema } from './schema.b4c655ec1635af1be28bd6'; /** * Service for angular based on ApiAgent solution. * Provides assured request to API method with implicit * validation and common errors handling scheme. */ @Injectable() export class RewriteGroupService extends ApiService&lt; RewriteGroupResponse, RewriteGroupRequest, RewriteGroupParameters &gt; { protected get method(): 'PUT' { return 'PUT'; } /** * Path template, example: `/some/path/{id}`. */ protected get pathTemplate(): string { return '/group/{groupId}'; } /** * Parameters in a query. */ protected get queryParams(): string[] { return ['forceSave']; } // ... }</span></span></code> </pre> </div></div><br><p> , <a href="">   JSON Schema</a>  ,   .    <a href=""> </a> ,        ,       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schema as domainSchema } from <span class="hljs-string"><span class="hljs-string">'./schema.b4c655ec1635af1be28bd6'</span></span>;</code> </pre> <br><blockquote> ,     <code>schema.b4c655ec1635af1be28bd6.ts</code>       ,  <a href="">  </a>  ,  . </blockquote><br><a name="UsingOfGeneratedServices"></a><br><h3 id="ispolzovanie-generiruemyh-servisov">    </h3><br><p>       ,   Angular-. </p><br><div class="spoiler"> <b class="spoiler_title">    Angular-</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，只需导入模块</font></font><code>ApiModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在提供程序中指定我们需要的服务即可：</font></font></p><br><pre> <code class="plaintext hljs">import { ApiModule, API_ERROR_HANDLER } from '@codegena/ng-api-service'; import { CreateGroupItemService, GetGroupsService, GetGroupItemsService, UpdateFewItemsService } from '@codegena/todo-app-scheme'; @NgModule({ imports: [ ApiModule, // ... ], providers: [ RewriteGroupService, { provide: API_ERROR_HANDLER, useClass: ApiErrorHandlerService }, // ... ], // ... }) export class TodoAppModule { }</code> </pre> </div></div><br><p>    ,     [])( <a href="https://angular.io/guide/dependency-injection">https://angular.io/guide/dependency-injection</a> ): </p><br><pre> <code class="plaintext hljs">@Injectable() export class TodoTasksStore { constructor( protected createGroupItemService: CreateGroupItemService, protected getGroupsService: GetGroupsService, protected getGroupItemsService: GetGroupItemsService, protected updateFewItemsService: UpdateFewItemsService ) {} }</code> </pre> <br><p>         —  ,       <a href="">request</a> ,        : </p><br><pre> <code class="plaintext hljs">return this.getGroupsService.request(null, { isComplete: null, withItems: false }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;200&gt;&gt;(200, null, true), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; this.loadItemsOfSelectedGroups({ ...truth, groups }) ) );</code> </pre> <br><p>  <code>request</code>   <code>Observable&lt;HttpResponse&lt;R&gt; | HttpEvent&lt;R&gt;&gt;</code> ,   ,        . ,     ,      . ,  ,      ,     .     RxJS- <code>pickResponseBody</code> . </p><br><p>  ,    ,    ,   .         API,    .        .   ,     : </p><br><p><img src="https://habrastorage.org/webt/3y/xe/dy/3yxedy51z7su99butzrk2dvunnq.png"></p><br><p>      .   JSON Schema     .       ,   ""      - .   ,      <a href="https://sentry.io/welcome/">Sentry</a>  <a href="https://www.elastic.co/products/kibana">Kibana</a> ,   .       .  ,      ,      . </p><br><blockquote>  ,             .  ,      :) </blockquote><br><a name="AfterWord"></a><br><h2 id="vmesto-poslesloviya"> 而不是后记 </h2><br><p>   ,       .       -,   "    "    —   .  ,  ,   ,   . </p><br><p>     —    ,  - /    (   ).      ,  —   . </p><br><p>   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483628/">https://habr.com/ru/post/zh-CN483628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483608/index.html">可视化基于图像的分类器解决方案的边界</a></li>
<li><a href="../zh-CN483612/index.html">特斯拉司机因在自动驾驶仪上刷牙而被罚款</a></li>
<li><a href="../zh-CN483614/index.html">防止机器人俱乐部盗窃的方法</a></li>
<li><a href="../zh-CN483616/index.html">Lacmus项目：计算机视觉如何帮助挽救失去的人们</a></li>
<li><a href="../zh-CN483624/index.html">Yandex.Taxi比赛：编程冠军赛的后端赛道分析</a></li>
<li><a href="../zh-CN483630/index.html">灰烬时代-第130期</a></li>
<li><a href="../zh-CN483634/index.html">CSS中的最小和最大宽度/高度属性</a></li>
<li><a href="../zh-CN483646/index.html">哈克盒子-Bitlab演练。 弱JS混淆，GIT和反向Windows应用程序</a></li>
<li><a href="../zh-CN483648/index.html">佐治亚州IT业务的离岸市场：生活中的小事和陷阱</a></li>
<li><a href="../zh-CN483650/index.html">天体更接近赤道-文昌热带天体</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>