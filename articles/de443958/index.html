<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèæ ü§òüèæ üîè Einwegmuster (Prinzip des Einwegdesigns) Punkt 1 üë®‚Äçüë¶ üåÅ üë©üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einwegmuster (Prinzip des Einwegdesigns) 


 Ich denke, fast jeder Programmierer, der .NET verwendet, wird jetzt sagen, dass dieses Muster ein Kinders...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einwegmuster (Prinzip des Einwegdesigns) Punkt 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443958/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h1 id="disposable-pattern-disposable-design-principle">  Einwegmuster (Prinzip des Einwegdesigns) </h1><br><p>  Ich denke, fast jeder Programmierer, der .NET verwendet, wird jetzt sagen, dass dieses Muster ein Kinderspiel ist.  Dass es das bekannteste Muster ist, das auf der Plattform verwendet wird.  Selbst die einfachste und bekannteste Problemdom√§ne verf√ºgt jedoch √ºber geheime Bereiche, die Sie noch nie angesehen haben.  Beschreiben wir also das Ganze von Anfang an f√ºr die Anf√§nger und alle anderen (damit sich jeder von Ihnen an die Grundlagen erinnern kann).  √úberspringen Sie diese Abs√§tze nicht - ich beobachte Sie! </p><br><p>  Wenn ich frage, was IDisposable ist, werden Sie sicherlich sagen, dass es ist </p><br><pre><code class="plaintext hljs">public interface IDisposable { void Dispose(); }</code> </pre> <br><p>  Was ist der Zweck der Schnittstelle?  Ich meine, warum m√ºssen wir √ºberhaupt Speicher l√∂schen, wenn wir einen intelligenten Garbage Collector haben, der den Speicher anstelle von uns l√∂scht, sodass wir nicht einmal dar√ºber nachdenken m√ºssen.  Es gibt jedoch einige kleine Details. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Es besteht ein Missverst√§ndnis, dass <code>IDisposable</code> dient, nicht verwaltete Ressourcen freizugeben.  Dies ist nur teilweise richtig und um es zu verstehen, m√ºssen Sie sich nur an die Beispiele f√ºr nicht verwaltete Ressourcen erinnern.  Ist die <code>File</code> eine nicht verwaltete Ressource?  Nein, nein.  Vielleicht ist <code>DbContext</code> eine nicht verwaltete Ressource?  Nein, schon wieder.  Eine nicht verwaltete Ressource geh√∂rt nicht zum System vom Typ .NET.  Etwas, das die Plattform nicht geschaffen hat, etwas, das au√üerhalb ihres Anwendungsbereichs existiert.  Ein einfaches Beispiel ist ein ge√∂ffnetes Dateihandle in einem Betriebssystem.  Ein Handle ist eine Nummer, die eine Datei eindeutig identifiziert, die von einem Betriebssystem ge√∂ffnet wurde - nein, nicht von Ihnen.  Das hei√üt, alle Kontrollstrukturen (z. B. die Position einer Datei in einem Dateisystem, Dateifragmente im Falle einer Fragmentierung und andere Serviceinformationen, die Nummern eines Zylinders, eines Kopfes oder eines Sektors einer Festplatte) befinden sich innerhalb eines Betriebssystems, jedoch nicht .NET-Plattform.  Die einzige nicht verwaltete Ressource, die an die .NET-Plattform √ºbergeben wird, ist die IntPtr-Nummer.  Diese Nummer wird von FileSafeHandle umschlossen, das wiederum von der File-Klasse umschlossen wird.  Dies bedeutet, dass die File-Klasse keine eigenst√§ndige nicht verwaltete Ressource ist, sondern eine zus√§tzliche Ebene in Form von IntPtr verwendet, um eine nicht verwaltete Ressource einzuschlie√üen - das Handle einer ge√∂ffneten Datei.  Wie liest du diese Datei?  Verwenden einer Reihe von Methoden unter WinAPI oder Linux. </p><br><p>  Synchronisationsprimitive in Multithread- oder Multiprozessorprogrammen sind das zweite Beispiel f√ºr nicht verwaltete Ressourcen.  Hierher geh√∂ren Datenarrays, die √ºber P / Invoke geleitet werden, sowie Mutexe oder Semaphoren. </p><br><blockquote>  Beachten Sie, dass das Betriebssystem das Handle einer nicht verwalteten Ressource nicht einfach an eine Anwendung √ºbergibt.  Au√üerdem wird dieses Handle in der Tabelle der vom Prozess ge√∂ffneten Handles gespeichert.  Somit kann das Betriebssystem die Ressourcen nach Beendigung der Anwendung korrekt schlie√üen.  Dadurch wird sichergestellt, dass die Ressourcen nach dem Beenden der Anwendung trotzdem geschlossen werden.  Die Laufzeit einer Anwendung kann jedoch unterschiedlich sein, was zu einer langen Ressourcensperrung f√ºhren kann. </blockquote><p>  Ok  Jetzt haben wir nicht verwaltete Ressourcen behandelt.  Warum m√ºssen wir in diesen F√§llen IDisposable verwenden?  Weil .NET Framework keine Ahnung hat, was au√üerhalb seines Territoriums vor sich geht.  Wenn Sie eine Datei mit der OS-API √∂ffnen, wei√ü .NET nichts dar√ºber.  Wenn Sie einen Speicherbereich f√ºr Ihre eigenen Anforderungen zuweisen (z. B. mithilfe von VirtualAlloc), wei√ü .NET auch nichts.  Wenn es nicht wei√ü, wird der von einem VirtualAlloc-Aufruf belegte Speicher nicht freigegeben.  Oder es wird keine Datei geschlossen, die direkt √ºber einen OS-API-Aufruf ge√∂ffnet wurde.  Diese k√∂nnen unterschiedliche und unerwartete Folgen haben.  Sie k√∂nnen OutOfMemory erhalten, wenn Sie zu viel Speicher zuweisen, ohne ihn freizugeben (z. B. indem Sie einen Zeiger auf null setzen).  Wenn Sie eine Datei auf einer Dateifreigabe √ºber das Betriebssystem √∂ffnen, ohne sie zu schlie√üen, wird die Datei auf dieser Dateifreigabe f√ºr lange Zeit gesperrt.  Das Beispiel f√ºr die Dateifreigabe ist besonders gut, da die Sperre auch nach dem Schlie√üen einer Verbindung mit einem Server auf der IIS-Seite verbleibt.  Sie haben keine Rechte zum <code>iisreset</code> der Sperre und m√ºssen Administratoren <code>iisreset</code> , <code>iisreset</code> durchzuf√ºhren oder Ressourcen manuell mit einer speziellen Software zu schlie√üen. <br>  Dieses Problem auf einem Remote-Server kann zu einer komplexen Aufgabe werden. </p><br><p>  Alle diese F√§lle ben√∂tigen ein universelles und bekanntes <em>Protokoll f√ºr die Interaktion</em> zwischen einem Typsystem und einem Programmierer.  Es sollte eindeutig die Typen identifizieren, die ein erzwungenes Schlie√üen erfordern.  Die IDisposable-Schnittstelle dient genau diesem Zweck.  Es funktioniert folgenderma√üen: Wenn ein Typ die Implementierung der IDisposable-Schnittstelle enth√§lt, m√ºssen Sie Dispose () aufrufen, nachdem Sie die Arbeit mit einer Instanz dieses Typs beendet haben. </p><br><p>  Es gibt also zwei Standardmethoden, um es zu nennen.  Normalerweise erstellen Sie eine Entit√§tsinstanz, um sie innerhalb einer Methode oder innerhalb der Lebensdauer der Entit√§tsinstanz schnell zu verwenden. </p><br><p>  Die erste M√∂glichkeit besteht darin, eine Instanz in <code>using(...){ ... }</code> zu verpacken.  Dies bedeutet, dass Sie anweisen, ein Objekt zu zerst√∂ren, nachdem der verwendungsbezogene Block beendet ist, dh Dispose () aufzurufen.  Die zweite M√∂glichkeit besteht darin, das Objekt nach Ablauf seiner Lebensdauer mit einem Verweis auf das Objekt zu zerst√∂ren, das wir freigeben m√∂chten.  Aber .NET hat nichts als eine Finalisierungsmethode, die die automatische Zerst√∂rung eines Objekts impliziert, oder?  Die Finalisierung ist jedoch √ºberhaupt nicht geeignet, da wir nicht wissen, wann sie aufgerufen wird.  In der Zwischenzeit m√ºssen wir ein Objekt zu einem bestimmten Zeitpunkt freigeben, beispielsweise kurz nachdem wir die Arbeit mit einer ge√∂ffneten Datei beendet haben.  Aus diesem Grund m√ºssen wir auch IDisposable implementieren und Dispose aufrufen, um alle Ressourcen freizugeben, die wir besa√üen.  Daher folgen wir dem <em>Protokoll</em> und es ist sehr wichtig.  Denn wenn jemand ihm folgt, sollten alle Teilnehmer dasselbe tun, um Probleme zu vermeiden. </p><br><h2 id="different-ways-to-implement-idisposable">  Verschiedene M√∂glichkeiten zur Implementierung von IDisposable </h2><br><p>  Schauen wir uns die Implementierungen von IDisposable von einfach bis kompliziert an.  Das erste und einfachste ist die Verwendung von IDisposable wie es ist: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { DisposableResource _anotherResource = new DisposableResource(); public void Dispose() { _anotherResource.Dispose(); } }</code> </pre> <br><p>  Hier erstellen wir eine Instanz einer Ressource, die von Dispose () weiter freigegeben wird.  Das einzige, was diese Implementierung inkonsistent macht, ist, dass Sie nach der Zerst√∂rung durch <code>Dispose()</code> immer noch mit der Instanz arbeiten k√∂nnen: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { private DisposableResource _anotherResource = new DisposableResource(); private bool _disposed; public void Dispose() { if(_disposed) return; _anotherResource.Dispose(); _disposed = true; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } }</code> </pre> <br><p>  CheckDisposed () muss in allen √∂ffentlichen Methoden einer Klasse als erster Ausdruck aufgerufen werden.  Die erhaltene <code>ResourceHolder</code> Klassenstruktur sieht gut aus, um eine nicht verwaltete Ressource zu zerst√∂ren, n√§mlich <code>DisposableResource</code> .  Diese Struktur ist jedoch nicht f√ºr eine eingebettete nicht verwaltete Ressource geeignet.  Schauen wir uns das Beispiel mit einer nicht verwalteten Ressource an. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { CloseHandle(_handle); } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern IntPtr CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError=true)] private static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Was ist der Unterschied im Verhalten der letzten beiden Beispiele?  Der erste beschreibt das Zusammenspiel zweier verwalteter Ressourcen.  Das hei√üt, wenn ein Programm korrekt funktioniert, wird die Ressource trotzdem freigegeben.  Da <code>DisposableResource</code> verwaltet wird, wei√ü .NET CLR davon und gibt den Speicher frei, wenn sein Verhalten falsch ist.  Beachten Sie, dass ich bewusst nicht davon <code>DisposableResource</code> , welchen <code>DisposableResource</code> Typ kapselt.  Es kann jede Art von Logik und Struktur geben.  Es kann sowohl verwaltete als auch nicht verwaltete Ressourcen enthalten.  <em>Das sollte uns √ºberhaupt nicht betreffen</em> .  Niemand fordert uns auf, die Bibliotheken von Drittanbietern jedes Mal zu dekompilieren und zu pr√ºfen, ob sie verwaltete oder nicht verwaltete Ressourcen verwenden.  Und wenn <em>unser Typ</em> eine nicht verwaltete Ressource verwendet, k√∂nnen wir uns dessen nicht bewusst sein.  Wir machen das in der <code>FileWrapper</code> Klasse.  Was passiert also in diesem Fall?  Wenn wir nicht verwaltete Ressourcen verwenden, gibt es zwei Szenarien.  Der erste ist, wenn alles in Ordnung ist und Dispose aufgerufen wird.  Der zweite ist, wenn etwas schief geht und Dispose fehlgeschlagen ist. </p><br><p>  Sagen wir gleich, warum dies schief gehen kann: </p><br><ul><li>  Wenn wir <code>using(obj) { ... }</code> , kann eine Ausnahme in einem inneren Codeblock auftreten.  Diese Ausnahme wird von <code>finally</code> block abgefangen, was wir nicht sehen k√∂nnen (dies ist syntaktischer Zucker von C #).  Dieser Block ruft implizit Dispose auf.  Es gibt jedoch F√§lle, in denen dies nicht der Fall ist.  Beispiel: <code>StackOverflowException</code> wird weder <code>catch</code> noch <code>finally</code> <code>StackOverflowException</code> .  Sie sollten sich immer daran erinnern.  Wenn ein Thread rekursiv wird und irgendwann eine <code>StackOverflowException</code> auftritt, vergisst .NET die Ressourcen, die verwendet, aber nicht freigegeben wurden.  Es kann keine nicht verwalteten Ressourcen freigeben.  Sie bleiben im Speicher, bis das Betriebssystem sie freigibt, d. H. Wenn Sie ein Programm beenden oder sogar einige Zeit nach dem Beenden einer Anwendung. </li><li>  Wenn wir Dispose () von einem anderen Dispose () aus aufrufen.  Auch hier kann es vorkommen, dass wir nicht dazu kommen.  Dies ist nicht der Fall eines abwesenden App-Entwicklers, der vergessen hat, Dispose () aufzurufen.  Es ist die Frage der Ausnahmen.  Dies sind jedoch nicht nur die Ausnahmen, die einen Thread einer Anwendung zum Absturz bringen.  Hier sprechen wir √ºber alle Ausnahmen, die verhindern, dass ein Algorithmus eine externe Dispose () aufruft, die unsere Dispose () aufruft. </li></ul><br><p>  In all diesen F√§llen werden angehaltene, nicht verwaltete Ressourcen erstellt.  Das liegt daran, dass Garbage Collector nicht wei√ü, dass er sie sammeln soll.  Bei der n√§chsten √úberpr√ºfung kann <code>FileWrapper</code> festgestellt werden, dass der letzte Verweis auf ein Objektdiagramm mit unserem <code>FileWrapper</code> Typ verloren geht.  In diesem Fall wird der Speicher f√ºr Objekte mit Referenzen neu zugewiesen.  Wie k√∂nnen wir das verhindern? </p><br><p>  Wir m√ºssen den Finalizer eines Objekts implementieren.  Der 'Finalizer' wird absichtlich so genannt.  Es ist kein Destruktor, wie es scheinen mag, weil Finalizer in C # und Destruktoren in C ++ auf √§hnliche Weise aufgerufen werden.  Der Unterschied besteht darin, dass ein Finalizer im Gegensatz zu einem Destruktor (sowie <code>Dispose()</code> ) <em>trotzdem</em> aufgerufen <em>wird</em> .  Ein Finalizer wird aufgerufen, wenn die Garbage Collection gestartet wird (jetzt reicht es aus, dies zu wissen, aber die Dinge sind etwas komplizierter).  Es wird f√ºr eine garantierte Freigabe von Ressourcen verwendet, wenn <em>etwas schief geht</em> .  Wir <em>m√ºssen</em> einen Finalizer implementieren, um nicht verwaltete Ressourcen freizugeben.  Da ein Finalizer aufgerufen wird, wenn GC gestartet wird, wissen wir nicht, wann dies im Allgemeinen geschieht. </p><br><p>  Lassen Sie uns unseren Code erweitern: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { InternalDispose(); GC.SuppressFinalize(this); } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Wir haben das Beispiel mit dem Wissen √ºber den Finalisierungsprozess erweitert und die Anwendung vor dem Verlust von Ressourceninformationen gesch√ºtzt, wenn Dispose () nicht aufgerufen wird.  Wir haben auch GC. SuppressFinalize aufgerufen, um die Finalisierung der Instanz des Typs zu deaktivieren, wenn Dispose () erfolgreich aufgerufen wird.  Es ist nicht n√∂tig, dieselbe Ressource zweimal freizugeben, oder?  Daher reduzieren wir auch die Finalisierungswarteschlange, indem wir einen zuf√§lligen Codebereich loslassen, der wahrscheinlich einige Zeit sp√§ter parallel mit der Finalisierung ausgef√ºhrt wird.  Lassen Sie uns das Beispiel noch weiter verbessern. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Unser Beispiel f√ºr einen Typ, der eine nicht verwaltete Ressource kapselt, sieht nun vollst√§ndig aus.  Leider ist das zweite <code>Dispose()</code> tats√§chlich ein Standard der Plattform und wir erlauben es, es aufzurufen.  Beachten Sie, dass Benutzer h√§ufig den zweiten Aufruf von <code>Dispose()</code> zulassen, um Probleme mit einem aufrufenden Code zu vermeiden, und dies ist falsch.  Ein Benutzer Ihrer Bibliothek, der sich die MS-Dokumentation ansieht, glaubt dies m√∂glicherweise nicht und l√§sst mehrere Aufrufe von Dispose () zu.  Das Aufrufen anderer √∂ffentlicher Methoden zerst√∂rt ohnehin die Integrit√§t eines Objekts.  Wenn wir das Objekt zerst√∂rt haben, k√∂nnen wir nicht mehr damit arbeiten.  Dies bedeutet, dass wir <code>CheckDisposed</code> zu Beginn jeder √∂ffentlichen Methode aufrufen m√ºssen. </p><br><p>  Dieser Code enth√§lt jedoch ein schwerwiegendes Problem, das verhindert, dass er wie beabsichtigt funktioniert.  Wenn wir uns daran erinnern, wie die Speicherbereinigung funktioniert, werden wir eine Funktion bemerken.  Beim Sammeln von M√ºll finalisiert GC in <em>erster Linie</em> alles, was direkt von <em>Object</em> geerbt wurde.  Als n√§chstes werden Objekte behandelt, die <em>CriticalFinalizerObject</em> implementieren.  Dies wird zu einem Problem, da beide von uns entworfenen Klassen Object erben.  Wir wissen nicht, in welcher Reihenfolge sie zur ‚Äûletzten Meile‚Äú kommen werden.  Ein √ºbergeordnetes Objekt kann jedoch seinen Finalizer verwenden, um ein Objekt mit einer nicht verwalteten Ressource abzuschlie√üen.  Das klingt allerdings nicht nach einer gro√üartigen Idee.  Die Reihenfolge der Fertigstellung w√§re hier sehr hilfreich.  Um dies festzulegen, muss der untergeordnete Typ mit einer gekapselten nicht verwalteten Ressource von <code>CriticalFinalizerObject</code> geerbt werden. </p><br><p>  Der zweite Grund ist tiefer.  Stellen Sie sich vor, Sie h√§tten es gewagt, eine Anwendung zu schreiben, die sich nicht viel um das Ged√§chtnis k√ºmmert.  Es reserviert Speicher in gro√üen Mengen, ohne Einl√∂sung und andere Feinheiten.  Eines Tages wird diese Anwendung mit OutOfMemoryException abst√ºrzen.  Wenn es auftritt, wird Code speziell ausgef√ºhrt.  Es kann nichts zugeordnet werden, da dies zu einer wiederholten Ausnahme f√ºhrt, selbst wenn die erste abgefangen wird.  Dies bedeutet nicht, dass wir keine neuen Instanzen von Objekten erstellen sollten.  Selbst ein einfacher Methodenaufruf kann diese Ausnahme ausl√∂sen, z. B. die der Finalisierung.  Ich erinnere Sie daran, dass Methoden kompiliert werden, wenn Sie sie zum ersten Mal aufrufen.  Dies ist √ºbliches Verhalten.  Wie k√∂nnen wir dieses Problem verhindern?  Ganz einfach.  Wenn Ihr Objekt von <em>CriticalFinalizerObject</em> geerbt wird, werden <em>alle</em> Methoden dieses Typs sofort beim Laden in den Speicher kompiliert.  Wenn Sie Methoden mit dem Attribut <em>[PrePrepareMethod]</em> markieren, werden diese au√üerdem vorkompiliert und k√∂nnen in Situationen mit geringen Ressourcen sicher aufgerufen werden. </p><br><p>  Warum ist das wichtig?  Warum zu viel M√ºhe auf diejenigen geben, die sterben?  Weil nicht verwaltete Ressourcen f√ºr lange Zeit in einem System ausgesetzt werden k√∂nnen.  Auch nach dem Neustart eines Computers.  Wenn ein Benutzer eine Datei √ºber eine Dateifreigabe in Ihrer Anwendung √∂ffnet, wird diese von einem Remote-Host gesperrt und beim Timeout oder beim Freigeben einer Ressource durch Schlie√üen der Datei freigegeben.  Wenn Ihre Anwendung beim √ñffnen der Datei abst√ºrzt, wird sie auch nach dem Neustart nicht freigegeben.  Sie m√ºssen lange warten, bis der Remote-Host es freigibt.  Au√üerdem sollten Sie in Finalisierern keine Ausnahmen zulassen.  Dies f√ºhrt zu einem beschleunigten Absturz der CLR und einer Anwendung, da Sie den Aufruf eines Finalizers nicht in <em>try ... catch</em> verpacken k√∂nnen.  Ich meine, wenn Sie versuchen, eine Ressource freizugeben, m√ºssen Sie sicher sein, dass sie freigegeben werden kann.  Die letzte, aber nicht weniger wichtige Tatsache: Wenn die CLR eine Dom√§ne abnormal entl√§dt, werden auch die von <em>CriticalFinalizerObject</em> abgeleiteten Finalisierer von Typen aufgerufen, im Gegensatz zu denen, die direkt von <em>Object</em> geerbt wurden. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieser Charper wurde von professionellen √úbersetzern aus dem Russischen wie aus der Sprache des Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der Erstellung einer √ºbersetzten Version dieses Textes in eine andere Sprache, einschlie√ülich Chinesisch oder Deutsch, unter Verwendung der russischen und englischen Textversion als Quelle helfen. <br><br>  Wenn Sie "Danke" sagen m√∂chten, k√∂nnen Sie uns am besten einen Stern auf Github oder Forking Repository geben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443958/">https://habr.com/ru/post/de443958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443948/index.html">Wettbewerb "Ich bin ein Intel Studio-Experte" mit Superpreisen f√ºr Entwickler</a></li>
<li><a href="../de443950/index.html">Vertrauen, beraten, vorschlagen - auf der Suche nach echten Software-Reviews</a></li>
<li><a href="../de443952/index.html">Souver√§nes Internet - f√ºr unser Geld</a></li>
<li><a href="../de443954/index.html">Technologische Singularit√§t: der moderne Mythos vom Ende der Welt unter dem Deckmantel der Hypothese des Fortschritts</a></li>
<li><a href="../de443956/index.html">Soziales Netzwerk im Jahr 2019: Yandex startete Aura</a></li>
<li><a href="../de443960/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 2</a></li>
<li><a href="../de443962/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 3</a></li>
<li><a href="../de443964/index.html">Kolesa Conf ist die gr√∂√üte IT-Konferenz in Kasachstan. Ank√ºndigung von Berichten</a></li>
<li><a href="../de443966/index.html">Google Text & Tabellen - ein beliebter Chat unter Studenten</a></li>
<li><a href="../de443968/index.html">Wie wir ein Haus mit Sonnenkollektoren gekauft haben und was daraus wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>