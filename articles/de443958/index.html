<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏾 🤘🏾 🔏 Einwegmuster (Prinzip des Einwegdesigns) Punkt 1 👨‍👦 🌁 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einwegmuster (Prinzip des Einwegdesigns) 


 Ich denke, fast jeder Programmierer, der .NET verwendet, wird jetzt sagen, dass dieses Muster ein Kinders...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einwegmuster (Prinzip des Einwegdesigns) Punkt 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443958/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h1 id="disposable-pattern-disposable-design-principle">  Einwegmuster (Prinzip des Einwegdesigns) </h1><br><p>  Ich denke, fast jeder Programmierer, der .NET verwendet, wird jetzt sagen, dass dieses Muster ein Kinderspiel ist.  Dass es das bekannteste Muster ist, das auf der Plattform verwendet wird.  Selbst die einfachste und bekannteste Problemdomäne verfügt jedoch über geheime Bereiche, die Sie noch nie angesehen haben.  Beschreiben wir also das Ganze von Anfang an für die Anfänger und alle anderen (damit sich jeder von Ihnen an die Grundlagen erinnern kann).  Überspringen Sie diese Absätze nicht - ich beobachte Sie! </p><br><p>  Wenn ich frage, was IDisposable ist, werden Sie sicherlich sagen, dass es ist </p><br><pre><code class="plaintext hljs">public interface IDisposable { void Dispose(); }</code> </pre> <br><p>  Was ist der Zweck der Schnittstelle?  Ich meine, warum müssen wir überhaupt Speicher löschen, wenn wir einen intelligenten Garbage Collector haben, der den Speicher anstelle von uns löscht, sodass wir nicht einmal darüber nachdenken müssen.  Es gibt jedoch einige kleine Details. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen Übersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">übersetzt</a> .  Sie können uns bei der Übersetzung von Russisch oder Englisch in eine andere Sprache helfen, hauptsächlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken möchten, können Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Es besteht ein Missverständnis, dass <code>IDisposable</code> dient, nicht verwaltete Ressourcen freizugeben.  Dies ist nur teilweise richtig und um es zu verstehen, müssen Sie sich nur an die Beispiele für nicht verwaltete Ressourcen erinnern.  Ist die <code>File</code> eine nicht verwaltete Ressource?  Nein, nein.  Vielleicht ist <code>DbContext</code> eine nicht verwaltete Ressource?  Nein, schon wieder.  Eine nicht verwaltete Ressource gehört nicht zum System vom Typ .NET.  Etwas, das die Plattform nicht geschaffen hat, etwas, das außerhalb ihres Anwendungsbereichs existiert.  Ein einfaches Beispiel ist ein geöffnetes Dateihandle in einem Betriebssystem.  Ein Handle ist eine Nummer, die eine Datei eindeutig identifiziert, die von einem Betriebssystem geöffnet wurde - nein, nicht von Ihnen.  Das heißt, alle Kontrollstrukturen (z. B. die Position einer Datei in einem Dateisystem, Dateifragmente im Falle einer Fragmentierung und andere Serviceinformationen, die Nummern eines Zylinders, eines Kopfes oder eines Sektors einer Festplatte) befinden sich innerhalb eines Betriebssystems, jedoch nicht .NET-Plattform.  Die einzige nicht verwaltete Ressource, die an die .NET-Plattform übergeben wird, ist die IntPtr-Nummer.  Diese Nummer wird von FileSafeHandle umschlossen, das wiederum von der File-Klasse umschlossen wird.  Dies bedeutet, dass die File-Klasse keine eigenständige nicht verwaltete Ressource ist, sondern eine zusätzliche Ebene in Form von IntPtr verwendet, um eine nicht verwaltete Ressource einzuschließen - das Handle einer geöffneten Datei.  Wie liest du diese Datei?  Verwenden einer Reihe von Methoden unter WinAPI oder Linux. </p><br><p>  Synchronisationsprimitive in Multithread- oder Multiprozessorprogrammen sind das zweite Beispiel für nicht verwaltete Ressourcen.  Hierher gehören Datenarrays, die über P / Invoke geleitet werden, sowie Mutexe oder Semaphoren. </p><br><blockquote>  Beachten Sie, dass das Betriebssystem das Handle einer nicht verwalteten Ressource nicht einfach an eine Anwendung übergibt.  Außerdem wird dieses Handle in der Tabelle der vom Prozess geöffneten Handles gespeichert.  Somit kann das Betriebssystem die Ressourcen nach Beendigung der Anwendung korrekt schließen.  Dadurch wird sichergestellt, dass die Ressourcen nach dem Beenden der Anwendung trotzdem geschlossen werden.  Die Laufzeit einer Anwendung kann jedoch unterschiedlich sein, was zu einer langen Ressourcensperrung führen kann. </blockquote><p>  Ok  Jetzt haben wir nicht verwaltete Ressourcen behandelt.  Warum müssen wir in diesen Fällen IDisposable verwenden?  Weil .NET Framework keine Ahnung hat, was außerhalb seines Territoriums vor sich geht.  Wenn Sie eine Datei mit der OS-API öffnen, weiß .NET nichts darüber.  Wenn Sie einen Speicherbereich für Ihre eigenen Anforderungen zuweisen (z. B. mithilfe von VirtualAlloc), weiß .NET auch nichts.  Wenn es nicht weiß, wird der von einem VirtualAlloc-Aufruf belegte Speicher nicht freigegeben.  Oder es wird keine Datei geschlossen, die direkt über einen OS-API-Aufruf geöffnet wurde.  Diese können unterschiedliche und unerwartete Folgen haben.  Sie können OutOfMemory erhalten, wenn Sie zu viel Speicher zuweisen, ohne ihn freizugeben (z. B. indem Sie einen Zeiger auf null setzen).  Wenn Sie eine Datei auf einer Dateifreigabe über das Betriebssystem öffnen, ohne sie zu schließen, wird die Datei auf dieser Dateifreigabe für lange Zeit gesperrt.  Das Beispiel für die Dateifreigabe ist besonders gut, da die Sperre auch nach dem Schließen einer Verbindung mit einem Server auf der IIS-Seite verbleibt.  Sie haben keine Rechte zum <code>iisreset</code> der Sperre und müssen Administratoren <code>iisreset</code> , <code>iisreset</code> durchzuführen oder Ressourcen manuell mit einer speziellen Software zu schließen. <br>  Dieses Problem auf einem Remote-Server kann zu einer komplexen Aufgabe werden. </p><br><p>  Alle diese Fälle benötigen ein universelles und bekanntes <em>Protokoll für die Interaktion</em> zwischen einem Typsystem und einem Programmierer.  Es sollte eindeutig die Typen identifizieren, die ein erzwungenes Schließen erfordern.  Die IDisposable-Schnittstelle dient genau diesem Zweck.  Es funktioniert folgendermaßen: Wenn ein Typ die Implementierung der IDisposable-Schnittstelle enthält, müssen Sie Dispose () aufrufen, nachdem Sie die Arbeit mit einer Instanz dieses Typs beendet haben. </p><br><p>  Es gibt also zwei Standardmethoden, um es zu nennen.  Normalerweise erstellen Sie eine Entitätsinstanz, um sie innerhalb einer Methode oder innerhalb der Lebensdauer der Entitätsinstanz schnell zu verwenden. </p><br><p>  Die erste Möglichkeit besteht darin, eine Instanz in <code>using(...){ ... }</code> zu verpacken.  Dies bedeutet, dass Sie anweisen, ein Objekt zu zerstören, nachdem der verwendungsbezogene Block beendet ist, dh Dispose () aufzurufen.  Die zweite Möglichkeit besteht darin, das Objekt nach Ablauf seiner Lebensdauer mit einem Verweis auf das Objekt zu zerstören, das wir freigeben möchten.  Aber .NET hat nichts als eine Finalisierungsmethode, die die automatische Zerstörung eines Objekts impliziert, oder?  Die Finalisierung ist jedoch überhaupt nicht geeignet, da wir nicht wissen, wann sie aufgerufen wird.  In der Zwischenzeit müssen wir ein Objekt zu einem bestimmten Zeitpunkt freigeben, beispielsweise kurz nachdem wir die Arbeit mit einer geöffneten Datei beendet haben.  Aus diesem Grund müssen wir auch IDisposable implementieren und Dispose aufrufen, um alle Ressourcen freizugeben, die wir besaßen.  Daher folgen wir dem <em>Protokoll</em> und es ist sehr wichtig.  Denn wenn jemand ihm folgt, sollten alle Teilnehmer dasselbe tun, um Probleme zu vermeiden. </p><br><h2 id="different-ways-to-implement-idisposable">  Verschiedene Möglichkeiten zur Implementierung von IDisposable </h2><br><p>  Schauen wir uns die Implementierungen von IDisposable von einfach bis kompliziert an.  Das erste und einfachste ist die Verwendung von IDisposable wie es ist: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { DisposableResource _anotherResource = new DisposableResource(); public void Dispose() { _anotherResource.Dispose(); } }</code> </pre> <br><p>  Hier erstellen wir eine Instanz einer Ressource, die von Dispose () weiter freigegeben wird.  Das einzige, was diese Implementierung inkonsistent macht, ist, dass Sie nach der Zerstörung durch <code>Dispose()</code> immer noch mit der Instanz arbeiten können: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { private DisposableResource _anotherResource = new DisposableResource(); private bool _disposed; public void Dispose() { if(_disposed) return; _anotherResource.Dispose(); _disposed = true; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } }</code> </pre> <br><p>  CheckDisposed () muss in allen öffentlichen Methoden einer Klasse als erster Ausdruck aufgerufen werden.  Die erhaltene <code>ResourceHolder</code> Klassenstruktur sieht gut aus, um eine nicht verwaltete Ressource zu zerstören, nämlich <code>DisposableResource</code> .  Diese Struktur ist jedoch nicht für eine eingebettete nicht verwaltete Ressource geeignet.  Schauen wir uns das Beispiel mit einer nicht verwalteten Ressource an. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { CloseHandle(_handle); } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern IntPtr CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError=true)] private static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Was ist der Unterschied im Verhalten der letzten beiden Beispiele?  Der erste beschreibt das Zusammenspiel zweier verwalteter Ressourcen.  Das heißt, wenn ein Programm korrekt funktioniert, wird die Ressource trotzdem freigegeben.  Da <code>DisposableResource</code> verwaltet wird, weiß .NET CLR davon und gibt den Speicher frei, wenn sein Verhalten falsch ist.  Beachten Sie, dass ich bewusst nicht davon <code>DisposableResource</code> , welchen <code>DisposableResource</code> Typ kapselt.  Es kann jede Art von Logik und Struktur geben.  Es kann sowohl verwaltete als auch nicht verwaltete Ressourcen enthalten.  <em>Das sollte uns überhaupt nicht betreffen</em> .  Niemand fordert uns auf, die Bibliotheken von Drittanbietern jedes Mal zu dekompilieren und zu prüfen, ob sie verwaltete oder nicht verwaltete Ressourcen verwenden.  Und wenn <em>unser Typ</em> eine nicht verwaltete Ressource verwendet, können wir uns dessen nicht bewusst sein.  Wir machen das in der <code>FileWrapper</code> Klasse.  Was passiert also in diesem Fall?  Wenn wir nicht verwaltete Ressourcen verwenden, gibt es zwei Szenarien.  Der erste ist, wenn alles in Ordnung ist und Dispose aufgerufen wird.  Der zweite ist, wenn etwas schief geht und Dispose fehlgeschlagen ist. </p><br><p>  Sagen wir gleich, warum dies schief gehen kann: </p><br><ul><li>  Wenn wir <code>using(obj) { ... }</code> , kann eine Ausnahme in einem inneren Codeblock auftreten.  Diese Ausnahme wird von <code>finally</code> block abgefangen, was wir nicht sehen können (dies ist syntaktischer Zucker von C #).  Dieser Block ruft implizit Dispose auf.  Es gibt jedoch Fälle, in denen dies nicht der Fall ist.  Beispiel: <code>StackOverflowException</code> wird weder <code>catch</code> noch <code>finally</code> <code>StackOverflowException</code> .  Sie sollten sich immer daran erinnern.  Wenn ein Thread rekursiv wird und irgendwann eine <code>StackOverflowException</code> auftritt, vergisst .NET die Ressourcen, die verwendet, aber nicht freigegeben wurden.  Es kann keine nicht verwalteten Ressourcen freigeben.  Sie bleiben im Speicher, bis das Betriebssystem sie freigibt, d. H. Wenn Sie ein Programm beenden oder sogar einige Zeit nach dem Beenden einer Anwendung. </li><li>  Wenn wir Dispose () von einem anderen Dispose () aus aufrufen.  Auch hier kann es vorkommen, dass wir nicht dazu kommen.  Dies ist nicht der Fall eines abwesenden App-Entwicklers, der vergessen hat, Dispose () aufzurufen.  Es ist die Frage der Ausnahmen.  Dies sind jedoch nicht nur die Ausnahmen, die einen Thread einer Anwendung zum Absturz bringen.  Hier sprechen wir über alle Ausnahmen, die verhindern, dass ein Algorithmus eine externe Dispose () aufruft, die unsere Dispose () aufruft. </li></ul><br><p>  In all diesen Fällen werden angehaltene, nicht verwaltete Ressourcen erstellt.  Das liegt daran, dass Garbage Collector nicht weiß, dass er sie sammeln soll.  Bei der nächsten Überprüfung kann <code>FileWrapper</code> festgestellt werden, dass der letzte Verweis auf ein Objektdiagramm mit unserem <code>FileWrapper</code> Typ verloren geht.  In diesem Fall wird der Speicher für Objekte mit Referenzen neu zugewiesen.  Wie können wir das verhindern? </p><br><p>  Wir müssen den Finalizer eines Objekts implementieren.  Der 'Finalizer' wird absichtlich so genannt.  Es ist kein Destruktor, wie es scheinen mag, weil Finalizer in C # und Destruktoren in C ++ auf ähnliche Weise aufgerufen werden.  Der Unterschied besteht darin, dass ein Finalizer im Gegensatz zu einem Destruktor (sowie <code>Dispose()</code> ) <em>trotzdem</em> aufgerufen <em>wird</em> .  Ein Finalizer wird aufgerufen, wenn die Garbage Collection gestartet wird (jetzt reicht es aus, dies zu wissen, aber die Dinge sind etwas komplizierter).  Es wird für eine garantierte Freigabe von Ressourcen verwendet, wenn <em>etwas schief geht</em> .  Wir <em>müssen</em> einen Finalizer implementieren, um nicht verwaltete Ressourcen freizugeben.  Da ein Finalizer aufgerufen wird, wenn GC gestartet wird, wissen wir nicht, wann dies im Allgemeinen geschieht. </p><br><p>  Lassen Sie uns unseren Code erweitern: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { InternalDispose(); GC.SuppressFinalize(this); } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Wir haben das Beispiel mit dem Wissen über den Finalisierungsprozess erweitert und die Anwendung vor dem Verlust von Ressourceninformationen geschützt, wenn Dispose () nicht aufgerufen wird.  Wir haben auch GC. SuppressFinalize aufgerufen, um die Finalisierung der Instanz des Typs zu deaktivieren, wenn Dispose () erfolgreich aufgerufen wird.  Es ist nicht nötig, dieselbe Ressource zweimal freizugeben, oder?  Daher reduzieren wir auch die Finalisierungswarteschlange, indem wir einen zufälligen Codebereich loslassen, der wahrscheinlich einige Zeit später parallel mit der Finalisierung ausgeführt wird.  Lassen Sie uns das Beispiel noch weiter verbessern. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Unser Beispiel für einen Typ, der eine nicht verwaltete Ressource kapselt, sieht nun vollständig aus.  Leider ist das zweite <code>Dispose()</code> tatsächlich ein Standard der Plattform und wir erlauben es, es aufzurufen.  Beachten Sie, dass Benutzer häufig den zweiten Aufruf von <code>Dispose()</code> zulassen, um Probleme mit einem aufrufenden Code zu vermeiden, und dies ist falsch.  Ein Benutzer Ihrer Bibliothek, der sich die MS-Dokumentation ansieht, glaubt dies möglicherweise nicht und lässt mehrere Aufrufe von Dispose () zu.  Das Aufrufen anderer öffentlicher Methoden zerstört ohnehin die Integrität eines Objekts.  Wenn wir das Objekt zerstört haben, können wir nicht mehr damit arbeiten.  Dies bedeutet, dass wir <code>CheckDisposed</code> zu Beginn jeder öffentlichen Methode aufrufen müssen. </p><br><p>  Dieser Code enthält jedoch ein schwerwiegendes Problem, das verhindert, dass er wie beabsichtigt funktioniert.  Wenn wir uns daran erinnern, wie die Speicherbereinigung funktioniert, werden wir eine Funktion bemerken.  Beim Sammeln von Müll finalisiert GC in <em>erster Linie</em> alles, was direkt von <em>Object</em> geerbt wurde.  Als nächstes werden Objekte behandelt, die <em>CriticalFinalizerObject</em> implementieren.  Dies wird zu einem Problem, da beide von uns entworfenen Klassen Object erben.  Wir wissen nicht, in welcher Reihenfolge sie zur „letzten Meile“ kommen werden.  Ein übergeordnetes Objekt kann jedoch seinen Finalizer verwenden, um ein Objekt mit einer nicht verwalteten Ressource abzuschließen.  Das klingt allerdings nicht nach einer großartigen Idee.  Die Reihenfolge der Fertigstellung wäre hier sehr hilfreich.  Um dies festzulegen, muss der untergeordnete Typ mit einer gekapselten nicht verwalteten Ressource von <code>CriticalFinalizerObject</code> geerbt werden. </p><br><p>  Der zweite Grund ist tiefer.  Stellen Sie sich vor, Sie hätten es gewagt, eine Anwendung zu schreiben, die sich nicht viel um das Gedächtnis kümmert.  Es reserviert Speicher in großen Mengen, ohne Einlösung und andere Feinheiten.  Eines Tages wird diese Anwendung mit OutOfMemoryException abstürzen.  Wenn es auftritt, wird Code speziell ausgeführt.  Es kann nichts zugeordnet werden, da dies zu einer wiederholten Ausnahme führt, selbst wenn die erste abgefangen wird.  Dies bedeutet nicht, dass wir keine neuen Instanzen von Objekten erstellen sollten.  Selbst ein einfacher Methodenaufruf kann diese Ausnahme auslösen, z. B. die der Finalisierung.  Ich erinnere Sie daran, dass Methoden kompiliert werden, wenn Sie sie zum ersten Mal aufrufen.  Dies ist übliches Verhalten.  Wie können wir dieses Problem verhindern?  Ganz einfach.  Wenn Ihr Objekt von <em>CriticalFinalizerObject</em> geerbt wird, werden <em>alle</em> Methoden dieses Typs sofort beim Laden in den Speicher kompiliert.  Wenn Sie Methoden mit dem Attribut <em>[PrePrepareMethod]</em> markieren, werden diese außerdem vorkompiliert und können in Situationen mit geringen Ressourcen sicher aufgerufen werden. </p><br><p>  Warum ist das wichtig?  Warum zu viel Mühe auf diejenigen geben, die sterben?  Weil nicht verwaltete Ressourcen für lange Zeit in einem System ausgesetzt werden können.  Auch nach dem Neustart eines Computers.  Wenn ein Benutzer eine Datei über eine Dateifreigabe in Ihrer Anwendung öffnet, wird diese von einem Remote-Host gesperrt und beim Timeout oder beim Freigeben einer Ressource durch Schließen der Datei freigegeben.  Wenn Ihre Anwendung beim Öffnen der Datei abstürzt, wird sie auch nach dem Neustart nicht freigegeben.  Sie müssen lange warten, bis der Remote-Host es freigibt.  Außerdem sollten Sie in Finalisierern keine Ausnahmen zulassen.  Dies führt zu einem beschleunigten Absturz der CLR und einer Anwendung, da Sie den Aufruf eines Finalizers nicht in <em>try ... catch</em> verpacken können.  Ich meine, wenn Sie versuchen, eine Ressource freizugeben, müssen Sie sicher sein, dass sie freigegeben werden kann.  Die letzte, aber nicht weniger wichtige Tatsache: Wenn die CLR eine Domäne abnormal entlädt, werden auch die von <em>CriticalFinalizerObject</em> abgeleiteten Finalisierer von Typen aufgerufen, im Gegensatz zu denen, die direkt von <em>Object</em> geerbt wurden. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieser Charper wurde von professionellen Übersetzern aus dem Russischen wie aus der Sprache des Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">übersetzt</a> .  Sie können uns bei der Erstellung einer übersetzten Version dieses Textes in eine andere Sprache, einschließlich Chinesisch oder Deutsch, unter Verwendung der russischen und englischen Textversion als Quelle helfen. <br><br>  Wenn Sie "Danke" sagen möchten, können Sie uns am besten einen Stern auf Github oder Forking Repository geben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443958/">https://habr.com/ru/post/de443958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443948/index.html">Wettbewerb "Ich bin ein Intel Studio-Experte" mit Superpreisen für Entwickler</a></li>
<li><a href="../de443950/index.html">Vertrauen, beraten, vorschlagen - auf der Suche nach echten Software-Reviews</a></li>
<li><a href="../de443952/index.html">Souveränes Internet - für unser Geld</a></li>
<li><a href="../de443954/index.html">Technologische Singularität: der moderne Mythos vom Ende der Welt unter dem Deckmantel der Hypothese des Fortschritts</a></li>
<li><a href="../de443956/index.html">Soziales Netzwerk im Jahr 2019: Yandex startete Aura</a></li>
<li><a href="../de443960/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 2</a></li>
<li><a href="../de443962/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 3</a></li>
<li><a href="../de443964/index.html">Kolesa Conf ist die größte IT-Konferenz in Kasachstan. Ankündigung von Berichten</a></li>
<li><a href="../de443966/index.html">Google Text & Tabellen - ein beliebter Chat unter Studenten</a></li>
<li><a href="../de443968/index.html">Wie wir ein Haus mit Sonnenkollektoren gekauft haben und was daraus wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>