<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 👰🏽 📧 Astuce de réseau de neurones pour les débutants 🔭 👨🏿‍🤝‍👨🏽 🧑🏼‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le cadre du concours annuel ZeroNights HackQuest 2018, les participants ont été invités à s'essayer à un certain nombre de tâches et de compétiti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Astuce de réseau de neurones pour les débutants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/443164/"><p><img src="https://habrastorage.org/webt/us/ri/cv/usricvbthwh4i_pyy50suyvx5mq.jpeg" alt="image"></p><br><p>  Dans le cadre du concours annuel ZeroNights HackQuest 2018, les participants ont été invités à s'essayer à un certain nombre de tâches et de compétitions non triviales.  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> d'entre elles était liée à la génération d'un exemple contradictoire pour un réseau neuronal.  Dans nos articles, nous avons déjà prêté attention aux méthodes d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attaque</a> et à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">défense</a> des algorithmes d'apprentissage automatique.  Dans le cadre de cette publication, nous analyserons un exemple de la façon dont il a été possible de résoudre la tâche avec ZeroNights Hackquest en utilisant la bibliothèque foolbox. </p><a name="habracut"></a><br><p>  Dans cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tâche, l'</a> attaquant était censé accéder au serveur.  Après avoir réussi, il a vu la structure de fichiers suivante dans son répertoire personnel: </p><br><pre><code class="plaintext hljs">| Home --| KerasModel.h5 --| Task.txt --| ZeroSource.bmp</code> </pre> <br><p>  Les informations suivantes se trouvaient dans le fichier Task.txt: </p><br><pre> <code class="plaintext hljs">Now it is time for a final boss! http://51.15.100.188:36491/predict You have a mode and an image. To get a ticket, you need to change an image so that it is identified as "1". curl -X POST -F image=@ZeroSource.bmp 'http://51.15.100.188:36491/predict'. (don't forget about normalization (/255) ^_^)</code> </pre> <br><p>  Pour obtenir le ticket convoité, l'attaquant a été invité à convertir ZeroSource.bmp: </p><br><p><img src="https://habrastorage.org/webt/f7/ef/tr/f7eftrhw6zevi-f_usxvu6ldce8.png" alt="image"></p><br><p>  de sorte qu'après l'envoi au serveur, le réseau neuronal interprète cette image comme 1. Si vous essayez d'envoyer cette image sans traitement, le résultat du réseau neuronal sera 0. </p><br><p>  Et, bien sûr, le principal indice de cette tâche est le fichier modèle KerasModel.h5 (ce fichier aide l'attaquant à transférer l'attaque vers le plan WhiteBox, car le réseau neuronal et toutes les données qui lui sont associées lui sont accessibles).  Le nom du fichier contient immédiatement un indice - le nom du cadre sur lequel le réseau neuronal est implémenté. </p><br><p>  C'est avec ces notes introductives que le participant a entrepris de résoudre la tâche: </p><br><ul><li>  Modèle de réseau neuronal écrit en Keras. </li><li>  La possibilité d'envoyer une image au serveur en utilisant curl. </li><li>  L'image d'origine qui devait être modifiée. </li></ul><br><p>  Côté serveur, la vérification a été aussi simple que possible: </p><br><ol><li>  L'image doit être de la bonne taille - 28x28 pixels. </li><li>  Dans cette image, le modèle doit renvoyer 1. </li><li>  La différence entre l'image initiale de ZeroSource.bmp et celle envoyée au serveur doit être inférieure au seuil k par la métrique MSE (erreur standard). </li></ol><br><p>  Commençons donc. </p><br><p>  Tout d'abord, le participant devait trouver des informations sur la façon de tromper le réseau neuronal.  Après un court instant sur Google, il a obtenu les mots clés "exemple contradictoire" et "attaque contradictoire".  Ensuite, il devait chercher des outils pour appliquer des attaques contradictoires.  Si vous lancez dans Google la requête "Attaques contradictoires sur Keras Neural Net", le premier lien sera vers le GitHub du projet FoolBox - une bibliothèque python pour générer des exemples contradictoires.  Bien sûr, il existe d'autres bibliothèques (nous en avons parlé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les articles précédents</a> ).  De plus, les attaques pourraient être écrites, comme on dit, à partir de zéro.  Mais nous nous concentrons toujours sur la bibliothèque la plus populaire, qu'une personne qui n'a pas déjà rencontré le sujet des attaques contradictoires peut trouver sur le tout premier lien sur Google. </p><br><p>  Vous devez maintenant écrire un script Python qui générera un exemple contradictoire. <br>  Nous allons bien sûr commencer par les importations. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foolbox</code> </pre> <br><p>  Que voyons-nous ici? </p><br><ol><li>  Keras est le cadre sur lequel le réseau neuronal est écrit, que nous allons tromper. </li><li>  NumPy est une bibliothèque qui nous permettra de travailler efficacement avec des vecteurs. </li><li>  PIL est un outil pour travailler avec des images. </li><li>  FoolBox est une bibliothèque pour générer des exemples contradictoires. </li></ol><br><p>  La première chose à faire est bien sûr de charger le modèle de réseau neuronal dans la mémoire de notre programme et de voir les informations du modèle. </p><br><pre> <code class="python hljs">model = keras.models.load_model(<span class="hljs-string"><span class="hljs-string">"KerasModel.h5"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   model.summary() #     model.input #    ,       </span></span></code> </pre> <br><p>  En sortie, nous obtenons ce qui suit: </p><br><pre> <code class="plaintext hljs">Layer (type) Output Shape Param # ================================================================= conv2d_1 (Conv2D) (None, 26, 26, 32) 320 _________________________________________________________________ conv2d_2 (Conv2D) (None, 26, 26, 64) 18496 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 13, 13, 64) 0 _________________________________________________________________ dropout_1 (Dropout) (None, 13, 13, 64) 0 _________________________________________________________________ conv2d_3 (Conv2D) (None, 13, 13, 64) 36928 _________________________________________________________________ conv2d_4 (Conv2D) (None, 13, 13, 128) 73856 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 6, 6, 128) 0 _________________________________________________________________ flatten_1 (Flatten) (None, 4608) 0 _________________________________________________________________ dense_1 (Dense) (None, 256) 1179904 _________________________________________________________________ dense_2 (Dense) (None, 10) 2570 ================================================================= Total params: 1,312,074 Trainable params: 1,312,074 Non-trainable params: 0 _________________________________________________________________ &lt;tf.Tensor 'conv2d_1_input_1:0' shape=(?, 28, 28, 1) dtype=float32&gt;</code> </pre> <br><p>  Quelles informations puis-je obtenir d'ici? </p><br><ol><li>  Le modèle d'entrée (couche conv2d_1) accepte un objet de dimension? X28x28x1, où "?"  - nombre d'objets;  si l'image est une, alors la dimension sera 1x28x28x1.  Et l'image est un tableau tridimensionnel, où une dimension est 1. Autrement dit, l'image est servie sous forme de tableau de valeurs de 0 à 255. </li><li>  En sortie du modèle (couche dense_2), un vecteur de dimension 10 est obtenu. </li></ol><br><p>  Nous chargeons l'image et n'oubliez pas de la convertir en type flottant (en outre, le réseau de neurones fonctionnera avec des nombres réels) et de la normaliser (divisez toutes les valeurs par 255).  Ici, il convient de préciser que la normalisation est l'une des astuces «obligatoires» lorsque vous travaillez avec des réseaux de neurones, mais l'attaquant peut ne pas le savoir, nous avons donc spécialement ajouté un petit indice dans la description de la tâche): </p><br><pre> <code class="python hljs">img = Image.open(<span class="hljs-string"><span class="hljs-string">"ZeroSource.bmp"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   img = np.array(img) #     numpy.array img = img.astype('float32') #      float img /= 255 # </span></span></code> </pre> <br><p>  Maintenant, nous pouvons envoyer l'image au modèle chargé et voir quel résultat elle produit: </p><br><pre> <code class="python hljs">model.predict(img.reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   predict           </span></span></code> </pre> <br><p>  En sortie, nous obtenons les informations suivantes </p><br><pre> <code class="plaintext hljs">array([[1.0000000e+00, 4.2309660e-19, 3.1170484e-15, 6.2545637e-18, 1.4199094e-16, 6.3990816e-13, 6.9493417e-10, 2.8936278e-12, 8.9440377e-14, 1.6340098e-12]], dtype=float32)</code> </pre> <br><p>  Il vaut la peine d'expliquer ce qu'est ce vecteur: en fait, il s'agit d'une distribution de probabilité, c'est-à-dire que chaque nombre représente une probabilité de la classe 0,1,2 ..., 9.  La somme de tous les nombres dans le vecteur est 1. Dans ce cas, on peut voir que le modèle est sûr que l'image d'entrée représente la classe 0 avec une probabilité de 100%. </p><br><p>  Si nous représentons cela sur un histogramme, nous obtenons ce qui suit: </p><br><p><img src="https://habrastorage.org/webt/_o/av/w9/_oavw9kqksofyiyjlg4z2jmf6_k.png" alt="image"></p><br><p>  Confiance absolue. </p><br><p>  Si le modèle ne pouvait pas déterminer la classe, le vecteur de probabilité tendrait vers une distribution uniforme, ce qui, à son tour, signifierait que le modèle attribue l'objet à toutes les classes simultanément avec la même probabilité.  Et l'histogramme ressemblerait à ceci: </p><br><p><img src="https://habrastorage.org/webt/v1/qs/ek/v1qsek8agqisjs8geiy0bvdfq2y.png" alt="image"></p><br><p>  Il est généralement admis que la classe d'un modèle est déterminée par l'indice du nombre maximum dans ce vecteur.  Autrement dit, le modèle pourrait théoriquement choisir une classe avec une probabilité de plus de 10%.  Mais cette logique peut varier en fonction de la logique de décision décrite par les développeurs. </p><br><p>  Passons maintenant à la partie la plus intéressante - les attaques contradictoires. </p><br><p>  Tout d'abord, pour travailler avec un modèle dans la bibliothèque FoolBox, vous devez traduire le modèle en notation Foolbox.  Vous pouvez le faire de cette façon: </p><br><pre> <code class="python hljs">fmodel = foolbox.models.KerasModel(model,bounds=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#  bounds ,       ,        255,        0-1.</span></span></code> </pre> <br><p>  Après cela, vous pouvez tester différentes attaques.  Commençons par le plus populaire - FGSM: </p><br><h5 id="fgsm">  Fgsm </h5><br><pre> <code class="python hljs">attack = foolbox.attacks.FGSM(fmodel) <span class="hljs-comment"><span class="hljs-comment">#    FGSM     adversarial = attack(img.reshape(28,28,1),0) #  ,  adversarial  probs = model.predict(adversarial.reshape(1,28,28,1)) #     print(probs) #    print(np.argmax(probs)) #     </span></span></code> </pre> <br><p>  La sortie du réseau neuronal sera la suivante </p><br><pre> <code class="plaintext hljs">[4.8592144e-01 2.5432981e-14 5.7048566e-13 1.6787202e-14 1.6875961e-11 1.2974949e-07 5.1407838e-01 3.9819957e-12 1.9827724e-09 5.7383300e-12] 6</code> </pre> <br><p>  Et l'image résultante: </p><br><p><img src="https://habrastorage.org/webt/m4/yc/yd/m4ycydwa2zhqfck-kelb3qlk2a8.png" alt="image"></p><br><p>  Donc, maintenant avec une probabilité de plus de 50% 0 a été reconnu comme 6. Déjà bon.  Cependant, nous voulons toujours obtenir 1, et le niveau de bruit n'est pas très impressionnant.  L'image semble vraiment peu plausible.  Plus d'informations à ce sujet plus tard.  En attendant, essayons de bafouer les attaques.  Soudain, nous obtenons toujours 1. </p><br><h5 id="l-bfgs-ataka">  Attaque L-BFGS </h5><br><pre> <code class="python hljs">attack = foolbox.attacks.LBFGSAttack(fmodel) adversarial = attack(img.reshape(<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>),<span class="hljs-number"><span class="hljs-number">0</span></span>) probs = model.predict(adversarial.reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) print(probs) print(np.argmax(probs))</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">[4.7782943e-01, 1.9682934e-10, 1.0285517e-06, 3.2558936e-10, 6.5797998e-05, 4.0495447e-06, 2.5545436e-04, 3.4730587e-02, 5.5223148e-07, 4.8711312e-01] 9</code> </pre> <br><p>  Image: </p><br><p><img src="https://habrastorage.org/webt/ax/oj/td/axojtdhkbk1ad1zlc7j-uv006i8.png" alt="image"></p><br><p>  Encore une fois par.  Nous avons maintenant 0 reconnu comme 9 avec une probabilité de ~ 49%.  Cependant, le bruit est beaucoup moins. </p><br><p>  Finissons avec un rythme aléatoire.  Un exemple a été choisi de telle manière qu'il serait très difficile d'obtenir le résultat au hasard.  Maintenant, nous n'avons indiqué nulle part que nous voulions obtenir 1. En conséquence, nous avons mené une attaque non ciblée et nous pensions que nous obtiendrions toujours la classe 1, mais cela ne s'est pas produit.  Par conséquent, cela vaut la peine de passer à des attaques ciblées.  Utilisons la documentation de la foolbox et y trouvons le module de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">critères</a> </p><br><p>  Dans ce module, vous pouvez sélectionner un critère pour une attaque, s'il le prend en charge.  Plus précisément, nous nous intéressons à deux critères: </p><br><ol><li>  TargetClass - fait en sorte que dans le vecteur de distributions de probabilité, l'élément avec le nombre k ait la probabilité maximale. </li><li>  TargetClassProbability - fait en sorte que dans le vecteur des distributions de probabilité, un élément avec le nombre k ait une probabilité d'au moins p. </li></ol><br><p>  Essayons les deux: </p><br><h5 id="l-bfgs--targetclass">  L-BFGS + TargetClass </h5><br><p>  L'essentiel des critères TargetClass est d'obtenir une probabilité de classe k supérieure à la probabilité de toute autre classe.  Ensuite, le réseau qui prend la décision simplement en regardant la probabilité maximale se trompe. </p><br><pre> <code class="python hljs">attack = foolbox.attacks.LBFGSAttack(fmodel,foolbox.criteria.TargetClass(<span class="hljs-number"><span class="hljs-number">1</span></span>))<span class="hljs-comment"><span class="hljs-comment">#    ,     ,    TargetClass,  ,      ,      adversarial = attack(img.reshape(28,28,1),0) probs = model.predict(adversarial.reshape(1,28,28,1)) print(probs) print(np.argmax(probs))</span></span></code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">[3.2620126e-01 3.2813528e-01 8.5446298e-02 8.1292394e-04 1.1273423e-03 2.4886258e-02 3.3904776e-02 1.9947644e-01 8.2347924e-07 8.5878673e-06] 1</code> </pre> <br><p>  Image: </p><br><p><img src="https://habrastorage.org/webt/ym/rp/pq/ymrppqvdtt7e_yfyinubsev03pm.png" alt="image"></p><br><p>  Comme le montre la conclusion, notre réseau de neurones prétend maintenant qu'il est 1 avec une probabilité de 32,8%, tandis que la probabilité de 0 est aussi proche de cette valeur que possible et est de 32,6%.  Nous l'avons fait!  En principe, cela suffit déjà pour terminer la tâche.  Mais nous irons plus loin et essayer d'obtenir une probabilité de 1 supérieure à 0,5. </p><br><h5 id="l-bfgs--targetclassprobability">  L-BFGS + TargetClassProbability </h5><br><p>  Nous utilisons maintenant le critère TargetClassProbability, qui vous permet d'obtenir la probabilité d'une classe dans un objet non inférieur à p.  Il n'a que deux paramètres: <br>  1) Le numéro de classe de l'objet. <br>  2) La probabilité de cette classe dans l'exemple contradictoire. <br>  De plus, s'il est impossible d'atteindre une telle probabilité, ou si le temps pour trouver un tel objet prend trop de temps, alors l'objet contradictoire sera égal à aucun.  Vous pouvez le vérifier vous-même en essayant de rendre la probabilité de, disons, 0,99.  La méthode risque alors de ne pas converger. </p><br><pre> <code class="python hljs">attack = foolbox.attacks.LBFGSAttack(fmodel,foolbox.criteria.TargetClassProbability(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>)) adversarial = attack(img.reshape(<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>),<span class="hljs-number"><span class="hljs-number">0</span></span>) probs = model.predict(adversarial.reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) print(probs) print(np.argmax(probs))</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">[4.2620126e-01 5.0013528e-01 9.5413298e-02 8.1292394e-04 1.1273423e-03 2.4886258e-02 3.3904776e-02 1.9947644e-01 8.2347924e-07 8.5878673e-06]</code> </pre> <br><p>  Hourra!  Nous avons réussi à obtenir un exemple contradictoire, dans lequel la probabilité 1 pour notre réseau de neurones est supérieure à 50%!  Super!  Maintenant, faisons la dénormalisation (remettons l'image au format 0-255) et sauvegardons-la. </p><br><p>  Le script final est le suivant: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foolbox <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> foolbox.criteria <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TargetClassProbability <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scipy.misc model = keras.models.load_model(<span class="hljs-string"><span class="hljs-string">"KerasModel.h5"</span></span>) img = Image.open(<span class="hljs-string"><span class="hljs-string">"ZeroSource.bmp"</span></span>) img = np.array(img.getdata()) img = img.astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) img = img /<span class="hljs-number"><span class="hljs-number">255.</span></span> img = img.reshape(<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) fmodel = foolbox.models.KerasModel(model,bounds=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) attack = foolbox.attacks.LBFGSAttack(fmodel,criterion=TargetClassProbability(<span class="hljs-number"><span class="hljs-number">1</span></span> ,p=<span class="hljs-number"><span class="hljs-number">.5</span></span>)) adversarial = attack(img[:,:,::<span class="hljs-number"><span class="hljs-number">-1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) adversarial = adversarial * <span class="hljs-number"><span class="hljs-number">255</span></span> adversarial = adversarial.astype(<span class="hljs-string"><span class="hljs-string">'int'</span></span>) scipy.misc.toimage(adversarial.reshape(<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>)).save(<span class="hljs-string"><span class="hljs-string">'AdversarialExampleZero.bmp'</span></span>)</code> </pre> <br><p>  Et l'image finale est la suivante: </p><br><p><img src="https://habrastorage.org/webt/1c/8i/ty/1c8ityrtcv46swzuc8yc545rw-4.png" alt="image">  . </p><br><h5 id="vyvody">  Conclusions </h5><br><p>  Ainsi, comme nous l'avons vu dans les exemples ci-dessus, tromper un réseau de neurones était assez simple.  Il existe également un grand nombre de méthodes capables de le faire.  Ouvrez simplement la liste des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attaques</a> disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans foolbox</a> et essayez de les appliquer.  Nous vous suggérons d'essayer de faire tourner le même vous-même, en prenant comme base le même réseau neuronal et la même image, disponibles par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référence</a> .  Vous pouvez laisser vos questions dans les commentaires.  Nous leur répondrons! </p><br><p>  Rappelez-vous toujours que, quelle que soit l'utilité des algorithmes et des modèles, ils peuvent être extrêmement instables pour de petits décalages pouvant entraîner de graves erreurs.  Par conséquent, nous vous recommandons de tester vos modèles, dans lesquels python et des outils comme foolbox peuvent vous aider. </p><br><p>  Merci de votre attention! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443164/">https://habr.com/ru/post/fr443164/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443152/index.html">Comment bloquer Microsoft Edge en arrière-plan sous Windows 10</a></li>
<li><a href="../fr443154/index.html">Rétroéclairage du clavier DasKeyboard basé sur la glycémie à l'aide de l'API REST</a></li>
<li><a href="../fr443158/index.html">Nostalgia for Half Life - création d'un décodeur pour une station de radio pour recevoir la voix et le son final dans le style des moissonneuses-batteuses</a></li>
<li><a href="../fr443160/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 289 (4 mars - 10 mars)</a></li>
<li><a href="../fr443162/index.html">Application de la matrice et des diagrammes de compétences</a></li>
<li><a href="../fr443166/index.html">Créer et mettre à jour des listes de diffusion dans Zimbra Collaboration OSE en fonction des groupes et des utilisateurs Active Directory</a></li>
<li><a href="../fr443174/index.html">hellOGL: OpenGL bonjour le monde</a></li>
<li><a href="../fr443176/index.html">7 extensions Chrome pour apprendre l'anglais</a></li>
<li><a href="../fr443178/index.html">Crystal Blockchain Analytics: enquête sur les cas de piratage et de vol</a></li>
<li><a href="../fr443180/index.html">Crew Dragon atterrissage et capture vidéo d'un astéroïde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>