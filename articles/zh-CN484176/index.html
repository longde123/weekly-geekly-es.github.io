<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📒 🤾🏾 👩🏼‍🔧 在Unity中实现状态模板 👩🏽‍⚕️ 🌋 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在对游戏中实体进行编程的过程中，会出现以下情况：它们必须在不同条件下以不同方式行动，这表明使用状态 。 

 但是，如果您决定使用蛮力，代码将很快变成混乱的混乱状态，其中包含许多嵌套的if-else语句。 

 为解决此问题，可以使用State设计模式。 我们将把本教程奉献给他！ 

 在本教程中，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中实现状态模板</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484176/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png" alt="图片"></div><br> 在对游戏中实体进行编程的过程中，会出现以下情况：它们必须在不同条件下以不同方式行动，这表明使用<i>状态</i> 。 <br><br> 但是，如果您决定使用蛮力，代码将很快变成混乱的混乱状态，其中包含许多嵌套的if-else语句。 <br><br> 为解决此问题，可以使用State设计模式。 我们将把本教程奉献给他！ <br><br> 在本教程中，您： <br><br><ul><li> 了解Unity中State模板的基础。 </li><li> 您将了解什么是状态机以及何时使用它。 </li><li> 了解如何使用这些概念来控制角色的动作。 </li></ul><br><blockquote>  <em>注意</em> ：本教程适用于高级用户； 假设您已经知道如何在Unity中工作，并且具有C＃的平均知识水平。 此外，本教程使用Unity 2019.2和C＃7。 </blockquote><a name="habracut"></a><br><h2> 开始工作 </h2><br> 下载<a href="">项目资料</a> 。 解压缩<em>zip文件，</em>然后在Unity中打开<em>starter</em>项目。 <br><br> 项目中有几个文件夹可以帮助您入门。  <em>Assets / RW</em>文件夹包含<em>Animations</em> ， <em>Materials</em> ， <em>Models</em> ， <em>Prefabs</em> ， <em>Resources</em> ， <em>Scenes</em> ， <em>Scripts</em>和<em>Sounds</em>文件夹，并根据它们包含的资源进行命名。 <br><br> 为了完成本教程，我们将仅使用<em>Scenes</em>和<em>Scripts</em> 。 <br><br> 转到<em>RW /场景</em>并打开<em>Main</em> 。 在游戏模式下，您将在中世纪城堡内的引擎盖中看到一个角色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/f1b/4e1/478f1b4e1ec3a2e8702e365e4082a605.png"></div><br> 单击<em>播放</em> ，注意<em>相机</em>如何移动以适合<em>角色</em>框。 目前，在我们的小游戏中没有交互，我们将在教程中进行处理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/62c/536/ba362c53682371294f90576b5fd5adc6.gif"></div><br><h2> 探索角色 </h2><br> 在<em>层次结构中，</em>选择<em>字符</em> 。 检查检查<em>器</em> 。 您将看到一个包含<em>Character</em>控制逻辑的同名<em>组件</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/ffd/2ba/957ffd2ba0299d4b509b75bedb094581.png"></div><br> 打开位于<em>RW /脚本中的</em> <em>Character.cs</em> 。 <br><br> 该脚本执行许多操作，但是其中大多数对我们并不重要。 现在，让我们注意以下方法。 <br><br><ul><li> <code>Move</code> ：它移动角色，接收float <code>speed</code>类型的值作为移动速度， <code>rotationSpeed</code>类型的值作为角速度。 </li><li>  <code>ResetMoveParams</code> ：此方法重置用于<i>动画化</i>角色<i>的运动</i>和角速度的参数。 它仅用于清洁。 </li><li>  <code>SetAnimationBool</code> ：将Bool类型的<code>param</code>动画参数设置为value。 </li><li>  <code>CheckCollisionOverlap</code> ：它接收一个<code>Vector3</code>类型的<code></code>并返回一个<code>bool</code> ，该<code>bool</code>确定从该<code></code>的指定半径内是否有任何碰撞体。 </li><li>  <code>TriggerAnimation</code> ： <code>TriggerAnimation</code>输入<code>param</code>动画参数。 </li><li>  <code>ApplyImpulse</code> ：对Character <code>ApplyImpulse</code>脉冲， <code>ApplyImpulse</code>脉冲等于<code>Vector3</code>类型的输入参数<code>force</code> 。 </li></ul><br> 在下面，您将看到这些方法。 在我们的教程中，它们的内容和内部工作并不重要。 <br><br><h2> 什么是状态机 </h2><br> 状态机是一个概念，其中容器在给定的时间存储东西的状态。 基于输入数据，它可以根据当前状态提供结论，并将此过程传递到新状态。 状态机可以表示为<a href="https://www.geeksforgeeks.org/unified-modeling-language-uml-state-diagrams/" rel="noopener">状态图</a> 。 准备状态图使您可以考虑系统的所有可能状态以及它们之间的过渡。 <br><br><h3> 状态机 </h3><br>  <em>有限状态机</em>或<em>FSM（有限状态机）</em>是四个主要的<em>机器</em>家族之一。 自动机是简单机器的抽象模型。 在<a href="https://cs.stanford.edu/people/eroberts/courses/soco/projects/2004-05/automata-theory/basics.html" rel="noopener"><em>自动机</em></a>理论（计算机科学的理论分支）的框架内研究它们。 <br><br> 简而言之： <br><br><ul><li>  FSM由有限数量的<em>条件组成</em> 。 在任何给定时间<em>，</em>这些状态中只有一个<em>处于活动状态</em> 。 </li><li> 每个状态根据收到的<em>传入信息</em>序列确定它将进入<em>输出</em>的状态。 </li><li> 输出状态变为新的活动状态。 换句话说， <em>状态之间</em>存在<em>过渡</em> 。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/111/f04/c43111f045f3727ab5f3b02c05c6ecc2.png"></div><br> 为了更好地理解这一点，请考虑地面平台游戏的特征。 角色处于<i>站立</i>状态。 这将是他的<em>活动状态，</em>直到玩家按下按钮以使角色跳跃为止。 <br><br>  <i>站立</i>状态将按钮的按下标识为重要<em>输入，</em>并且作为<em>输出</em> ，切换到<i>跳跃</i>状态。 <br><br> 假设存在一定数量的这种运动状态，并且角色一次只能处于一种状态。 这是FSM的示例。 <br><br><h3> 分层状态机 </h3><br> 考虑一个使用FSM的平台程序，其中几个状态共享一个共同的物理逻辑。 例如，您可以在<em>蹲伏</em>和<em>站立</em>状态下移动和跳跃。 在这种情况下，几个传入变量导致两种不同状态的相同行为和信息输出。 <br><br> 在这种情况下，将一般行为委派给其他状态是合乎逻辑的。 幸运的是，这可以使用<em>分层</em>状态机来实现。 <br><br> 在分层FSM中，有一些<em>子状态</em>将<i>原始的</i>传入信息委派给它们的<em>子状态</em> 。 反过来，这又使您可以在保持FSM逻辑的同时优雅地减小FSM的大小和复杂性。 <br><br><h2> 状态模板 </h2><br>  Erich Gamma，Richard Helm，Ralph Johnson和John Vlissidis在《 <i>设计模式：可重用的面向对象软件的元素》</i>一书中将State模板的<i>任务</i>定义如下： <br><br>  “他必须允许对象在其内部状态更改时更改其行为。 在这种情况下，似乎该对象已更改其类。” <br><br> 为了更好地理解这一点，请考虑以下示例： <br><br><ul><li> 接收用于运动逻辑的传入信息的脚本附加到游戏内实体。 </li><li> 此类存储<i>当前状态</i>变量，该<i>状态</i>变量仅引用<i>状态</i>类的实例。 </li><li> 传入信息被委派给该当前状态，该状态对其进行处理并在其内部创建行为。 它还处理所需的状态转换。 </li></ul><br> 因此，由于以下事实： <i>当前状态</i>变量在不同的时间引用了不同的状态，因此同一脚本类的行为似乎有所不同。 这是“状态”模板的本质。 <br><br> 在我们的项目中，前述的<em>Character</em>类将根据不同的状态表现不同。 但是我们需要他表现自己！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d8/d20/f59/3d8d20f5921bf342b2ac84b5677e9a3b.png"></div><br> 在一般情况下，每个状态类都有三个关键点，这些关键点允许整个状态运行： <br><br><ul><li>  <em>进入</em> ：这是实体进入状态并执行仅在进入状态时只需执行一次的操作的时刻。 </li><li>  <em>退出</em> ：类似于输入-此处将执行所有重置操作，必须仅在状态更改之前执行此操作。 </li><li>  <em>更新循环</em> ：这是在每个帧中运行的基本<i>更新逻辑</i> 。 它可以分为几个部分，例如，用于更新物理的循环和用于处理玩家输入的循环。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/847/8e6/a268478e6da2566cc58d1083fefed27f.png"></div><br><h3> 定义状态和状态机 </h3><br> 转到<em>RW / Scripts</em>并打开<em>StateMachine.cs</em> 。 <br><br> 您可能会猜到，状态机为状态机提供了一种抽象。 请注意， <code>CurrentState</code>正确位于此类内。 它将存储到当前活动状态机状态的链接。 <br><br> 现在，要定义<i>状态</i>的概念，让我们转到<em>RW / Scripts</em>并在IDE中打开<em>State.cs</em>脚本。 <br><br>  <em>状态</em>是一个抽象类，我们将使用它作为<i>模型</i> ，从中派生所有项目<i>状态类</i> 。 项目资料中的部分代码已准备就绪。 <br><br>  <code>DisplayOnUI</code>仅在屏幕UI中显示当前状态的名称。 您无需了解其内部结构，只需了解它接收到类型为<code>UIManager.Alignment</code>的枚举数作为输入参数，可以是<code>Left</code>或<code>Right</code> 。 状态名称在屏幕左下部或右下部的显示取决于此名称。 <br><br> 此外，还有两个受保护的变量<code>character</code>和<code>stateMachine</code> 。  <code>character</code>变量引用<em>Character</em>类的一个实例， <code>stateMachine</code>引用与<em>该状态</em>关联<em>的状态机的</em>一个实例。 <br><br> 创建状态实例时，构造函数会绑定<code>character</code>和<code>stateMachine</code> 。 <br><br> 场景中<code>Character</code>的许多实例中的每个实例都可以具有自己的一组状态和状态机。 <br><br> 现在，将以下方法添加到<em>State.cs</em>并保存文件： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DisplayOnUI(UIManager.Alignment.Left); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br> 这些虚拟方法定义了上述关键状态点。 当<em>状态机</em>在状态之间进行转换时，我们将上一个状态称为<code>Exit</code>并<code>Enter</code>新的<i>活动状态</i> 。 <br><br>  <code>HandleInput</code> ， <code>LogicUpdate</code>和<code>PhysicsUpdate</code>一起定义<i>了一个更新循环</i> 。  <code>HandleInput</code>处理玩家输入。  <code>LogicUpdate</code>处理基本逻辑，而<code>PhyiscsUpdate</code>处理逻辑和物理计算。 <br><br> 现在再次打开<em>StateMachine.cs</em> ，添加以下方法并保存文件： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State startingState</span></span></span><span class="hljs-function">)</span></span> { CurrentState = startingState; startingState.Enter(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State newState</span></span></span><span class="hljs-function">)</span></span> { CurrentState.Exit(); CurrentState = newState; newState.Enter(); }</code> </pre> <br>  <code>Initialize</code>通过将<code>CurrentState</code>设置为<code>startingState</code>并为其调用<code>Enter</code>来配置状态机。 这将初始化状态机，这是第一次设置活动状态。 <br><br>  <code>ChangeState</code>处理<em>状态</em>转换。 在将其引用替换为<code>newState</code>之前，它将为旧的<code>CurrentState</code>调用<code>Exit</code> 。 最后，它为<code>Enter</code>调用<code>newState</code> 。 <br><br> 因此，我们设置<em>状态</em>和<em>状态机</em> 。 <br><br><h3> 创建运动状态 </h3><br> 请看下面的状态图，其中显示<i>了</i>玩家游戏中本质的不同<i>运动状态</i> 。 在本节中，我们为<i>FSM</i>图中所示的<i>移动</i>实现“状态”模板： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fa/bf6/c19/4fabf6c19761d028d621903401a84746.png"></div><br> 注意运动状态，即<em>站立</em> ， <em>躲避</em>和<em>跳跃</em> ，以及输入数据如何引起状态之间的转换。 这是分层FSM，其中<em>Grounded</em>是<em>Ducking</em>和<em>Standing</em> <em>子状态的子状态</em> 。 <br><br> 返回Unity并转到<em>RW /脚本/状态</em> 。 在这里，您将找到几个名称以<i>State</i>结尾的C＃文件。 <br><br> 这些文件中的每个文件都定义一个类，每个类都从<code>State</code>继承。 因此，这些类定义了我们将在项目中使用的状态。 <br><br> 现在从<em>RW / Scripts</em>文件夹中打开<em>Character.cs</em> 。 <br><br> 滚动到<code>#region Variables</code>文件上方，并添加以下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StateMachine movementSM; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StandingState standing; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DuckingState ducking; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JumpingState jumping;</code> </pre> <br> 这个<code>movementSM</code>是指状态机，它处理<code>Character</code>实例的运动逻辑。 我们还添加了针对每种运动类型实现的三个状态的链接。 <br><br> 在同一文件中转到<code>#region MonoBehaviour Callbacks</code> 。 添加以下<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html" rel="noopener">MonoBehaviour</a>方法，然后保存 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateMachine(); standing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); ducking = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DuckingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); jumping = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JumpingState(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movementSM); movementSM.Initialize(standing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.HandleInput(); movementSM.CurrentState.LogicUpdate(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { movementSM.CurrentState.PhysicsUpdate(); }</code> </pre> <br><ul><li> 在“ <code>Start</code>代码创建<em>状态机</em>的实例并将其分配给<code>movementSM</code> ，还实例化各种运动状态。 在创建每个运动状态时，我们使用<code>this</code>以及<code>Character</code>实例将对<code>Character</code>实例的引用传递给<code>Character</code>实例。 最后，我们为<code>movementSM</code> <code>Initialize</code>调用<code>Initialize</code> ，并将<code>Standing</code>作为初始状态。 </li><li> 在<code>Update</code>方法中，我们为<code>HandleInput</code>机器的<code>CurrentState</code>调用<code>HandleInput</code>和<code>LogicUpdate</code> 。 同样，在<code>FixedUpdate</code>我们将<code>PhysicsUpdate</code>机器的<code>CurrentState</code>称为<code>PhysicsUpdate</code> 。 从本质上讲，这将任务委派为活动状态。 这就是“状态”模板的含义。 </li></ul><br> 现在我们需要在每个运动状态内设置行为。 振作起来，会有很多代码！ <br><br><h3> 常设公司 </h3><br> 在“项目”窗口中返回到<em>RW /脚本/状态</em> 。 <br><br> 打开<em>Grounded.cs</em> ，注意该类的构造函数与<code>State</code>构造函数匹配。 这是合乎逻辑的，因为此类从其继承。 您将在所有其他<i>状态</i>类中看到相同的内容。 <br><br> 添加以下代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); horizontalInput = verticalInput = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.ResetMoveParams(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); verticalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); horizontalInput = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); character.Move(verticalInput * speed, horizontalInput * rotationSpeed); }</code> </pre> <br> 这是这里发生的情况： <br><br><ul><li> 我们重新定义在父类中定义的虚拟方法之一。 为了保留父级中可能存在的所有功能，我们从每个重写的方法中调用具有相同名称的<code>base</code>方法。 这是我们将继续使用的重要模板。 </li><li> 下一行<code>Enter</code>将<code>horizontalInput</code>和<code>verticalInput</code>为其默认值。 </li><li> 如上所述，在<code>Exit</code>内部<code>Exit</code>我们调用<code></code> <code>ResetMoveParams</code>方法以在更改为其他状态时进行重置。 </li><li> 在<code>HandleInput</code>方法中， <code>horizontalInput</code>和<code>verticalInput</code>变量<code>HandleInput</code>水平和垂直输入轴的值。 因此，玩家可以使用键<em>W</em> ， <em>A</em> ， <em>S</em>和<em>D</em>控制角色<em>。</em> </li><li> 在<code>PhysicsUpdate</code>我们进行一次<code>Move</code>调用，将<code>horizontalInput</code>和<code>verticalInput</code>变量乘以相应的速度。 在<code>speed</code>存储移动<code>speed</code>在<code>rotationSpeed</code> ，存储角速度。 </li></ul><br> 现在打开<em>Standing.cs，</em>并注意它继承自<code>Grounded</code>的事实。 之所以发生这种情况，是因为如上所述， <em>站立</em>是<em>Grounded的</em>一个子状态。 有多种方法可以实现这种关系，但是在本教程中，我们使用继承。 <br><br> 添加以下<code>override</code>方法并保存脚本： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); speed = character.MovementSpeed; rotationSpeed = character.RotationSpeed; crouch = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; jump = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouch = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); jump = Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (crouch) { stateMachine.ChangeState(character.ducking); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jump) { stateMachine.ChangeState(character.jumping); } }</code> </pre> <br><ul><li> 在<code>Enter</code>我们配置从<code>Grounded</code>继承的变量。 将角色的<code>MovementSpeed</code>和<code>RotationSpeed</code>应用于<code>speed</code>和<code>rotationSpeed</code> 。 然后，它们分别与<i>正常</i>运动速度和角色本质所要达到的角速度有关。 <br><br> 此外，用于存储<code>crouch</code>和<code>jump</code>输入的变量将重置为false。 </li><li> 在<code>HandleInput</code>内部， <code>crouch</code>和<code>jump</code>变量存储下蹲和跳跃的玩家输入。 如果在主场景中玩家按下<em>Shift键，则</em>深蹲将设置为true。 同样，玩家可以使用<em>空格</em>键<code>jump</code> 。 </li><li> 在<code>LogicUpdate</code>我们检查类型为<code>bool</code>的<code>crouch</code>和<code>jump</code>变量。 如果<code>crouch</code>为true，则<code>movementSM.CurrentState</code>更改为<code>character.ducking</code> 。 如果<code>jump</code>为true，则状态更改为<code>character.jumping</code> 。 </li></ul><br> 保存并组装项目，然后单击“ <em>播放”</em> 。 您可以使用<em>W</em> ， <em>A</em> ， <em>S</em>和<em>D</em>键在场景中四处移动<em>。</em> 如果您尝试按<em>Shift</em>或<em>Space</em> ，则会发生意外行为，因为尚未实现相应的状态。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/89a/564/45089a5640a8d492b20ac5948e0fdf69.gif"></div><br> 尝试在表格对象下移动。 您会看到由于角色对撞机的高度，这是不可能的。 为了使角色做到这一点，您需要添加蹲行为。 <br><br><h3> 我们爬到桌子底下 </h3><br> 打开<em>Ducking.cs</em>脚本。 请注意， <code>Ducking</code>也出于与<code>Standing</code>相同的原因而继承自<code>Grounded</code>类。 添加以下<code>override</code>方法并保存脚本： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); speed = character.CrouchSpeed; rotationSpeed = character.CrouchRotationSpeed; character.ColliderSize = character.CrouchColliderHeight; belowCeiling = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Exit(); character.SetAnimationBool(character.crouchParam, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); character.ColliderSize = character.NormalColliderHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.HandleInput(); crouchHeld = Input.GetButton(<span class="hljs-string"><span class="hljs-string">"Fire3"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(crouchHeld || belowCeiling)) { stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); belowCeiling = character.CheckCollisionOverlap(character.transform.position + Vector3.up * character.NormalColliderHeight); }</code> </pre> <br><ul><li> 在<code>Enter</code>内部<code>Enter</code>导致下蹲动画切换<code>Enter</code>参数设置为“蹲下”，这将启用下蹲动画。 为<code>character.CrouchSpeed</code>和<code>character.CrouchRotationSpeed</code>属性分配了<code>speed</code>和<code>rotation</code>值，当它们<i>下蹲</i>时，它们返回角色的运动和角速度。 <br><br> 下一个<code>character.CrouchColliderHeight</code> 。CrouchColliderHeight设置角色的碰撞体的大小，蹲时返回所需的碰撞体高度。 最后，将<code>belowCeiling</code>重置为false。 </li><li> 在<code>Exit</code>内部<code>Exit</code>将蹲下动画参数设置为false。 这将禁用下蹲动画。 然后设置正常的对撞机高度，由<code>character.NormalColliderHeight</code>返回。 </li><li> 在<code>HandleInput</code>内部<code>HandleInput</code>变量<code>crouchHeld</code>设置播放器的输入值。 在<em>主</em>场景中，按住<em>Shift键可</em>将<code>crouchHeld</code>设置为true。 </li><li> 在<code>PhysicsUpdate</code>内部<code>PhysicsUpdate</code>通过将<code>Vector3</code>格式的一个点（带有角色的游戏对象的头部）传递给<code>PhysicsUpdate</code> <code>belowCeiling</code>变量分配了一个值。 如果在该点附近发生碰撞，则表示角色处于某种天花板之下。 </li><li> 在内部， <code>LogicUpdate</code>检查<code>crouchHeld</code>或<code>belowCeiling</code>是否为真。 如果它们都不是真实的，则<code>movementSM.CurrentState</code>更改为<code>character.standing</code> 。 </li></ul><br> 生成项目，然后单击“ <em>播放”</em> 。 现在您可以在场景中四处移动。 如果按<em>Shift键</em> ，角色将坐下，然后可以下蹲。 <br><br> 您也可以在平台下攀爬。 如果您在平台下释放<em>Shift</em> ，角色将一直处于下蹲状态，直到他离开庇护所。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee4/dce/657/ee4dce657ae6be49244106652a168a3a.gif"></div><br><h3> 快起来！ </h3><br> 打开<em>Jumping.cs</em> 。 您将看到一个名为<code>Jump</code>的方法。 不用担心它是如何工作的。 足以理解它的用法，以便角色可以在考虑物理和动画的情况下跳跃。 <br><br> 现在添加常用的<code>override</code>方法并保存脚本 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.Enter(); SoundManager.Instance.PlaySound(SoundManager.Instance.jumpSounds); grounded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Jump(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.LogicUpdate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grounded) { character.TriggerAnimation(landParam); SoundManager.Instance.PlaySound(SoundManager.Instance.landing); stateMachine.ChangeState(character.standing); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.PhysicsUpdate(); grounded = character.CheckCollisionOverlap(character.transform.position); }</code> </pre> <br><ul><li> 在<code>Enter</code>内部<code>Enter</code>单例<code>SoundManager</code>播放跳跃声。 然后将<code>grounded</code>重置为其默认值。 最后，将调用<code>Jump</code> 。 </li><li> 在<code>PhysicsUpdate</code>内部<code>PhysicsUpdate</code>角色腿部旁边<code>PhysicsUpdate</code>点发送到<code>CheckCollisionOverlap</code> ，这意味着当角色在地面上时， <code>grounded</code>将设置为true。 </li><li> 在<code>LogicUpdate</code> ，如果<code>LogicUpdate</code>为true，我们将调用<code>TriggerAnimation</code>启用触地动画，播放触地声音，并将<code>LogicUpdate</code>更改为<code>character.standing</code> 。 </li></ul><br> 因此，在此我们已使用<em>“状态”模板</em>完成了FSM位移的完整实现。 生成项目并运行它。 按<em>空格</em>键使角色跳转。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/e16/05d/ebde1605dc739588529c51509e19c0a8.gif"></div><br><h2> 接下来要去哪里？ </h2><br>  <a href="">项目材料</a>有一个项目草案和一个完成的项目。 <br><br> 尽管有用，状态机还是有局限性的。 并发状态机和下推自动机可以处理其中一些限制。 您可以在Robert Nystrom <a href="https://gameprogrammingpatterns.com/state.html" rel="noopener"><em>Game Programming Patterns</em></a>的书中阅读有关它们的信息。 <br><br> 此外，可以通过检查用于创建更复杂的游戏中实体的<a href="https://en.wikipedia.org/wiki/Behavior_tree_(artificial_intelligence,_robotics_and_control)" rel="noopener"><em>行为树</em></a>来更深入地探讨该主题。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484176/">https://habr.com/ru/post/zh-CN484176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484166/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../zh-CN484168/index.html">我们编写了从Angular CDK进行虚拟滚动的策略</a></li>
<li><a href="../zh-CN484170/index.html">将检查点从R77.30更新到80.20</a></li>
<li><a href="../zh-CN484172/index.html">与Unity的持续集成：如何减少组装时间并节省资源+支付线作为礼物</a></li>
<li><a href="../zh-CN484174/index.html">城堡在“极端”条件下饮酒或我们如何参加“ DOZOR”表演</a></li>
<li><a href="../zh-CN484178/index.html">用于地球的智能以太网交换机</a></li>
<li><a href="../zh-CN484180/index.html">Rostelecom虚拟PBX：可以通过API进行哪些操作以及如何完成</a></li>
<li><a href="../zh-CN484182/index.html">Xenobots：来自青蛙细胞的活的纳米机器人</a></li>
<li><a href="../zh-CN484186/index.html">LDAP-“身份验证”是一种反模式</a></li>
<li><a href="../zh-CN484188/index.html">数据库设计标准</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>