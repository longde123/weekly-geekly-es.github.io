<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏽 〽️ 👨🏽‍🏫 Teste de interface do usuário: verificando o sistema em diferentes resoluções 🏓 🆔 🛏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testar formulários da Web longos em vários navegadores e em resoluções não é apenas extremamente necessário, mas também pela terceira ou quarta vez - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teste de interface do usuário: verificando o sistema em diferentes resoluções</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/425647/">  Testar formulários da Web longos em vários navegadores e em resoluções não é apenas extremamente necessário, mas também pela terceira ou quarta vez - um processo extremamente chato e intensivo em concentração.  Portanto, essa é exatamente a área que pede automação.  Foi o que fizemos. <br><br>  Neste artigo sobre Habr, falaremos sobre nossa experiência em testar telas grandes com as ferramentas de grade Transferidor, Zalênio e Selênio.  Como gradualmente introduzimos essas ferramentas para o teste automático da interface do usuário e que dificuldades tivemos. <br><br><img src="https://habrastorage.org/webt/t0/ik/pi/t0ikpibqtt5stc-vmd8mm5ap7p0.jpeg"><br><a name="habracut"></a><br>  Criamos e mantemos um sistema no qual 7 mil usuários ativos.  Na maioria das vezes eles usam esses navegadores: <br><br><img src="https://habrastorage.org/webt/du/8h/qg/du8hqgm1ywysjlq_jnwovnu636m.png"><br><br>  E as seguintes resoluções de tela: <br><br><img src="https://habrastorage.org/webt/yh/qo/65/yhqo65fklkp6alt-rooirdebj0c.png"><br><br>  Cada vez após o lançamento de uma nova versão, você precisa verificar o desempenho nesses navegadores e permissões. <br><br>  Para entender melhor como os testes de interface do usuário geralmente funcionam no nosso caso, considere um caso simples: testando a funcionalidade de um aplicativo de recuperação de senha.  Consequentemente, existem duas páginas.  Em um deles, você precisa especificar um nome de usuário ou email onde uma carta virá com um link para uma alteração de senha.  Após o envio do aplicativo, o usuário acessa a página com a confirmação de que tudo correu bem. <br><br><img src="https://habrastorage.org/webt/ji/p2/1o/jip21ov8vewbempmrtgogko3lx4.png"><br>  <i>Formulário de recuperação de senha</i> <br><br><img src="https://habrastorage.org/webt/1d/ce/-e/1dce-e0_bdinsyr_hlwidjceo6k.png"><br>  <i>A página para a qual o redirecionamento ocorre após o envio bem-sucedido do aplicativo</i> <br><br>  Testar esse mecanismo de uma forma simplificada se parece com isso: <br><br><img src="https://habrastorage.org/webt/io/yh/zn/ioyhzno2ibl6ijdwxszbszy0qrk.png"><br><br>  O mesmo script que o código: <br><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'    '</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.get(browser.baseUrl); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> element(by.name(<span class="hljs-string"><span class="hljs-string">'EmailOrLogin'</span></span>)).sendKeys(userLogin); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> element(by.buttonText(<span class="hljs-string"><span class="hljs-string">''</span></span>)).click(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> screenshot = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.takeScreenshot(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canonicalScreenshotPath = <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name"></span></span></span></span><span class="xml"><span class="hljs-tag">   &gt;</span></span></span><span class="xml">; await compareScreenshot(screenshot, canonicalScreenshotPath); });</span></span></code> </pre> <br>  Como você pode ver, o código de teste parece bastante simples, literalmente repete o que foi mostrado no diagrama de blocos. <br><br>  Agora, mostramos quais ferramentas foram úteis para implementar esse esquema em diferentes resoluções de tela e que dificuldades encontramos. <br><br><h2>  Caixa de ferramentas selecionada </h2><br><h3>  Iniciado com chrome </h3><br>  Para automação de teste, escolhemos o Protractor, uma estrutura e2e para testar aplicativos Angular.  Nossa aplicação é apenas no Angular.  Com o transferidor, fizemos dois tipos de testes: <br><br><ol><li>  Sobre a funcionalidade geral: Um formulário de envio de aplicativo é aberto, preenchido com dados e um aplicativo é enviado, após o que verificamos que ocorreu um redirecionamento para o registro de todos os aplicativos. </li><li>  Testes de captura de tela: o transferidor permite tirar uma captura de tela a qualquer momento.  Usando uma biblioteca separada de colheita azul, comparamos duas capturas de tela: uma referência e uma real.  Se eles não corresponderem, uma captura de tela é criada imediatamente, na qual todas as diferenças são visíveis, assim como no Git. </li></ol><br>  Por exemplo, se você continuar analisando o exemplo descrito acima. <br><br><img src="https://habrastorage.org/webt/-k/op/c_/-kopc_riwo8xa6qsajn_ld-ynrk.png"><br>  <i>Captura de tela com mensagem de link inválida</i> <br><br><img src="https://habrastorage.org/webt/gb/lp/uh/gblpuhvntxizhca6g1i0dk5ciqs.png"><br>  <i>As diferenças (texto e layout do botão) nas capturas de tela de referência e atuais são destacadas em lilás</i> <br><br>  Se a página contiver dados alterados dinamicamente (por exemplo, a data ou o número do pedido), você precisará mascará-los - essa funcionalidade está na biblioteca de colheita azul.  Caso contrário, a comparação de capturas de tela produzirá um resultado negativo. <br><br><h3>  Adicione FF e permissões diferentes </h3><br>  Com o tempo, nossos requisitos para o sistema de teste de interface do usuário existente aumentaram: <br><br><ul><li>  execute testes não apenas no Chrome, mas também no FF, </li><li>  realize testes de captura de tela não em uma resolução, mas nas mais populares, </li><li>  executar testes em paralelo. </li></ul><br>  Então, vamos fazer nossos testes paralelos no Chrome e no FF. <br><br>  Para fazer isso, na configuração dos recursos Transferidor, substitua-o por: <br><br><pre> <code class="hljs powershell">multiCapabilities: [ { <span class="hljs-type"><span class="hljs-type">shardTestFiles</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">maxInstances</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-type"><span class="hljs-type">browserName</span></span>: <span class="hljs-string"><span class="hljs-string">'chrome'</span></span> }, { <span class="hljs-type"><span class="hljs-type">shardTestFiles</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">maxInstances</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-type"><span class="hljs-type">browserName</span></span>: <span class="hljs-string"><span class="hljs-string">'firefox'</span></span> } ]</code> </pre> <br>  Tudo é óbvio aqui, pelo qual cada configuração é responsável.  Só merece atenção <br> <code>shardTestFiles: true</code> <br> <code>/** * If this is set to be true, specs will be shared by file (ie all files to be run by this set of capabilities will run in parallel). * Default is false. */</code> <br> <br>  Com esse sinalizador, fornecemos o lançamento paralelo de todas as especificações em todos os navegadores especificados em multiCapabilities. <br><br>  O parâmetro specs está oculto sob a palavra specs, que determina por qual modelo procurar arquivos com testes. <br><br><pre> <code class="javascript hljs">exports.config = { ... specs: [<span class="hljs-string"><span class="hljs-string">'./e2e/**/*.spec.ts'</span></span>], ... }</code> </pre> <br>  A teoria de dividir todos os testes em vários arquivos de especificações parece bastante lógica.  a simultaneidade funciona neles (por exemplo, crie um arquivo de especificação para cada recurso do aplicativo). <br><br>  Além disso, em Transferidor, há a capacidade de destacar suítes. <br><br><pre> <code class="javascript hljs">exports.config = { ... suites: { <span class="hljs-attr"><span class="hljs-attr">suite01</span></span>: <span class="hljs-string"><span class="hljs-string">'./e2e/**/suite01.*.spec.ts'</span></span>, <span class="hljs-attr"><span class="hljs-attr">suite02</span></span>: <span class="hljs-string"><span class="hljs-string">'./e2e/**/suite02.spec.ts'</span></span>, <span class="hljs-attr"><span class="hljs-attr">suite03</span></span>: <span class="hljs-string"><span class="hljs-string">'./e2e/**/suite03.spec.ts'</span></span> }, ... }</code> </pre> <br>  Como você pode ver nesta parte da configuração, ao iniciar um conjunto, os testes são executados a partir de apenas um arquivo de especificação.  Isso provavelmente é útil se você deseja executar testes para apenas uma parte do aplicativo. <br><br>  Quanto ao teste do aplicativo em diferentes resoluções, seguimos o seguinte caminho.  Como permissões experimentais, foi selecionada uma das mais populares: 1920x1080, 1366x768, 1440x10900, 768x1024.  Quando você executa cada teste, todas as ações necessárias foram executadas inicialmente e, em seguida, uma série de verificações de captura de tela é executada. <br><br><img src="https://habrastorage.org/webt/ht/fe/w4/htfew43t0zeewg0cg-odih_s_yq.png"><br><br><h3>  Conectamos o IE e capturas de tela em tamanho real </h3><br>  Infelizmente, os testes de captura de tela que obtivemos funcionaram apenas com base na parte visível da página.  E se a rolagem estava presente na página, tudo abaixo permanecia inexplorado para o layout que foi. <br><br>  Além disso, também precisamos oferecer suporte ao IE, para o qual nossos testes ainda não foram projetados.  Começamos a procurar uma oportunidade adequada para executar testes no IE e fazer capturas de tela em tamanho real. <br><br><img src="https://habrastorage.org/webt/v7/ul/le/v7ulle2bbjnxzfyqc5vv_ps7due.png"><br><br>  Decidimos duas soluções: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zalenium</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selenium-Grid</a> .  Omitimos a descrição de qual deles se orgulha de quê e contamos o que encontraram / não encontraram em nenhuma das soluções. <br><br>  <b>Zalenium</b> : esta solução é executada em um contêiner do Docker e N outros contêineres sobem após o contêiner principal - para iniciar os navegadores.  Permite especificar screenWidth, screenHeight durante a <code>docker run</code> e obter o tamanho da tela, por exemplo, 1920x6000.  Não há suporte para o IE. <br><br><img src="https://habrastorage.org/webt/kz/wr/de/kzwrdeodk_9rbejq0srhhk5d3zq.png"><br>  <i>Dois navegadores com um tamanho de tela de 1920x6000</i> <br><br>  <b>Grade de selênio: os</b> testes no IE começaram com muita facilidade. <br>  Das desvantagens: não há como definir o tamanho da janela do navegador de qualquer tamanho. <br><br>  <b>Total: zalênio + grade de selênio</b> <br>  Nós decidimos por um monte de Zalenium + Selenium-grid: através do Zalenium, foi decidido executar testes no Chrome e FF, e através do Selenium-grid para verificar o desempenho mínimo do aplicativo no IE. <br><br><h2>  O que foi interessante encontrar no processo </h2><br>  <b>1. Usando formControlName como um localizador de elemento</b> <br><br>  Usando a pesquisa em formControlName, você pode pesquisar facilmente os campos obrigatórios no formulário e preenchê-los com dados de teste.  O localizador por formControlName não é interno, mas é fácil adicionar: <br><br><pre> <code class="javascript hljs">exports.config = { ... onPrepare() { <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ts-node'</span></span>).register({ <span class="hljs-attr"><span class="hljs-attr">project</span></span>: <span class="hljs-string"><span class="hljs-string">'e2e/tsconfig.e2e.json'</span></span> }); jasmine.getEnv().addReporter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> specReporter({ <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">displayStacktrace</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } })); addFormControlNameLocator(protractor); } ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addFormControlNameLocator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">protractor</span></span></span><span class="hljs-function">) </span></span>{ protractor.by.addLocator(<span class="hljs-string"><span class="hljs-string">'formControlName'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, optParentElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> using = optParentElement || <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> using.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'[formControlName="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'"]'</span></span>); }); }</code> </pre> <br>  <b>2. A diferença no trabalho do gerenciador de chaves da web instalado globalmente e localmente no Transferidor</b> <br><br>  Ao instalar o Transferidor no sistema (a documentação oficial aconselha a instalação global do Transferidor), além da própria estrutura de teste, obtemos o gerenciador de web instalado, que fornece drivers para os navegadores para executar testes com os quais um dos problemas foi detectado. <br><br>  Depois de ir para a pasta do projeto e executar a atualização do gerenciador de driver da web, os drivers do Chrome, FF, IE são baixados.  Depois disso, ao iniciar os testes, eles pegaram o erro: <br><br> <code>No update-config.json found. Run 'webdriver-manager update' to download binaries.</code> <br> <br>  Percebemos que o erro desaparece se empacotarmos a atualização do gerenciador de web em um script npm: <br><br><pre> <code class="hljs powershell">{ ... scripts:{ “webdriver<span class="hljs-literal"><span class="hljs-literal">-update</span></span>”: “webdriver<span class="hljs-literal"><span class="hljs-literal">-manager</span></span> update” } ... }</code> </pre> <br>  e, através do <code>npm run webdriver-update</code> , as fontes do driver e o update-config.json mencionado acima entram na pasta do projeto. <br><br>  <b>3. Executando o Zalenium através do docker-composite</b> <br><br>  A documentação do Zalenium é acompanhada de exemplos do comando <code>docker run</code> e do arquivo docker-compose.  Tudo decola quase como se por mágica.  O único problema que encontramos ocorreu ao iniciar o arquivo docker-compose <br>  <code>/var/run/docker.sock is not a valid windows path</code> .  A solução está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  <b>4. Visibilidade dos elementos pelo transferidor</b> <br><br>  No decorrer de nossas experiências, em um momento, fomos confrontados com a tarefa de perfurar algum menu da página, ou seja,  vá para cada página do menu e faça uma captura de tela. <br><br><img src="https://habrastorage.org/webt/6u/sy/ol/6usyoljearsoj0ok6kgburgd_7e.png"><br><br>  Após o processamento do primeiro elemento da lista, os testes começaram a cair, gerando um erro de que não havia nada para clicar em algumas coordenadas.  Como se viu, independentemente do fato de todos os elementos da lista terem sido selecionados inicialmente, depois de se tornarem realmente invisíveis aos nossos olhos, eles desapareceram aos olhos do transferidor. <br><br>  Resolvemos o problema configurando largura de tela suficiente para que o menu apareça novamente antes de clicar no próximo elemento. <br><br>  <b>5. Alteração da resolução no IE (Selenium-grid)</b> <br><br>  Como você se lembra, no Chrome e no FF, ajustamos a alteração na resolução da tela.  Quando se trata disso no IE, simplesmente capturamos o erro: <code>Failed: java.io.IOException: Server returned HTTP response code: 405 for URL: http://localhost:21800/session/8d14426d-6483-4bbf-90b3-2a3ed46ebe9b/window/size</code> . <br><br>  Após uma longa depuração, foi possível descobrir que o erro ocorre exatamente no momento em que o código está tentando executar: <code>browser.driver.manage().window().setSize(x, y)</code> .  Se você tentar executar o <code>browser.driver.manage().window().setPosition(x, y)</code> , em seguida, detectar o mesmo erro, apenas o tamanho será alterado para a posição.  Isso nos leva ao fato de que é impossível controlar a resolução da tela quando os testes são executados no IE.  A solução para o problema são muletas com as quais você precisa sobrepor seu código para não alterar a resolução \ posição quando o IE estiver em execução. <br><br>  <b>6. Zalenium e WebSocket</b> <br><br>  Depois de coletar todos os obstáculos localmente, foi decidido levar o Zalenium à infraestrutura corporativa.  O contêiner está aberto, o DNS está registrado, agora todos podem executar testes no Zalenium'e, simplesmente especificando o caminho para ele na configuração do Transferidor.  Beleza, hein?  Mas lá estava. <br><br>  Nesse caso, tudo já foi implantado na máquina Linux, o Nginx foi usado como servidor.  O contêiner com Zalenium subiu sem problemas, seguido por outros N contêineres para iniciar navegadores, mas ... não foi possível estabelecer conexões com eles.  Foi fácil descobrir que o contêiner pai estava tentando se comunicar com os contêineres dos navegadores por meio do protocolo WebSocket, e o Nginx não podia fazer isso por padrão.  O tratamento é muito simples. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> some_url; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Upgrade <span class="hljs-variable"><span class="hljs-variable">$http_upgrade</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Connection “upgrade”; }</code> </pre> <br>  <b>9. Lançamento da grade de selênio</b> <br><br>  Para executar o Selenium-Grid, precisamos: <br><br><ul><li>  <a href="">servidor de selênio</a> , </li><li>  Driver IE, que é fácil de obter através da atualização do gerenciador de driver da web --ie32. </li></ul><br>  inicialização do servidor: <br><br> <code>java -jar selenium-server-standalone.jar -role hub -hubConfig selenium-server-config.json</code> <br> <br><pre> <code class="hljs pgsql">selenium-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-config.json { "host": "127.0.0.1", "maxSessions": <span class="hljs-number"><span class="hljs-number">5</span></span>, "port": <span class="hljs-number"><span class="hljs-number">4445</span></span>, "cleanupCycle": <span class="hljs-number"><span class="hljs-number">5000</span></span>, "timeout": <span class="hljs-number"><span class="hljs-number">300000</span></span>, "newSessionWaitTimeout": <span class="hljs-number"><span class="hljs-number">-1</span></span>, "servlets": [], "prioritizer": <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, "capabilityMatcher": "org.openqa.grid.internal.utils.DefaultCapabilityMatcher", "throwOnCapabilityNotPresent": <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, "nodePolling": <span class="hljs-number"><span class="hljs-number">180000</span></span>, "platform": "WINDOWS" }</code> </pre> <br>  iniciando o driver IE: <br><br> <code>java -Dwebdriver.ie.driver=&lt;  &gt; -jar selenium-server-standalone.jar -role node -nodeConfig .\\ie-driver-config.json</code> <br> <br><pre> <code class="hljs powershell">ie<span class="hljs-literal"><span class="hljs-literal">-driver</span></span><span class="hljs-literal"><span class="hljs-literal">-config</span></span>.json { <span class="hljs-string"><span class="hljs-string">"capabilities"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"browserName"</span></span>: <span class="hljs-string"><span class="hljs-string">"internet explorer"</span></span>, <span class="hljs-string"><span class="hljs-string">"maxInstances"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"platform"</span></span>: <span class="hljs-string"><span class="hljs-string">"WINDOWS"</span></span>, <span class="hljs-string"><span class="hljs-string">"webdriver.ie.driver"</span></span>: <span class="hljs-string"><span class="hljs-string">"C:/Program Files (x86)/Internet Explorer/iexplore.exe"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"cleanUpCycle"</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-string"><span class="hljs-string">"timeout"</span></span>: <span class="hljs-number"><span class="hljs-number">30000</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"node"</span></span>, <span class="hljs-string"><span class="hljs-string">"hub"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:4445/grid/register/"</span></span>, <span class="hljs-string"><span class="hljs-string">"register"</span></span>: true, <span class="hljs-string"><span class="hljs-string">"maxSessions"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Preste atenção ao uso das mesmas portas ao iniciar o servidor e na URL do hub do driver.  Como seleniumAddress na configuração do transferidor, usamos <code>http://127.0.0.1:4445/wd/hub</code> . <br><br><h2>  Conclusões </h2><br>  Assim, resolvemos nossa tarefa e, após o lançamento de uma nova versão, podemos verificar o desempenho nesses navegadores e resoluções. <br><br><h3>  Como integrar testes em um fluxo de trabalho </h3><br>  É importante entender que não basta elevar toda a infraestrutura para executar testes e escrevê-los.  Você precisa pensar em como os usará em sua vida diária. <br><br>  Não implementamos testes de interface do usuário no IC, porque  eles são executados por tempo suficiente para permitir que eles aguardem sua execução para cada build. <br><br>  Para testar a versão local do aplicativo ou instalada em um dos ambientes de teste (interno ou cliente), basta alterar baseUrl na configuração do Transferidor.  Portanto, os testes podem ser executados pelo desenvolvedor e pelo testador. <br>  Desenvolvedor - quando é necessário executar testes, por exemplo, para a versão local do aplicativo no processo de desenvolvimento de um novo recurso.  Especialista em controle de qualidade - por exemplo, como teste de fumaça após uma implantação no produto ou como uma verificação no topo após várias refatorações. <br><br>  <b>Em conclusão, queremos enfatizar:</b> <br><br><ul><li>  Lembre-se de que os testes de interface do usuário não pouparão a necessidade de realizar testes manuais detalhados.  A automação ajuda apenas a cobrir áreas. </li><li>  Use a automação com sabedoria, principalmente para testes de fumaça.  Cobrir tudo e tudo não faz sentido - é caro e difícil manter-se atualizado </li><li>  Escreva simplesmente.  se seus testes de interface do usuário parecerem complicados, você estará fazendo algo errado.  Bata simples e use como indicado (consulte o ponto 2) </li></ul><br>  Acreditamos que a automação do teste da interface do usuário é boa quando feita com facilidade.  Então compartilhe conosco suas observações e ferramentas de sucesso nos comentários. <br><br><h2>  Links úteis nossos: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Prolongador: Uma Nova Esperança - Michael Giambalvo, Craig Nishina</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zalenium vs selenóide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caso de teste do transferidor em Selenium Gird no Docker</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425647/">https://habr.com/ru/post/pt425647/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425635/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 333 (1 a 7 de outubro de 2018)</a></li>
<li><a href="../pt425637/index.html">Algoritmo de estabelecimento de conexão SSH</a></li>
<li><a href="../pt425641/index.html">Moradores da cidade canadense desenvolveram um "serviço Uber" com ônibus, não carros</a></li>
<li><a href="../pt425643/index.html">Eventos digitais em Moscou, de 8 a 14 de outubro</a></li>
<li><a href="../pt425645/index.html">SpaceX e SAOCOM - 1A Nova Missão. Concluído</a></li>
<li><a href="../pt425649/index.html">BDSM, Gore e a busca do desenvolvedor Drupal</a></li>
<li><a href="../pt425653/index.html">Construindo uma arquitetura de microsserviço em Golang e gRPC, parte 1</a></li>
<li><a href="../pt425657/index.html">A inevitabilidade da punição, a eficácia de verificações repentinas</a></li>
<li><a href="../pt425659/index.html">O design interativo não precisa ser complicado.</a></li>
<li><a href="../pt425661/index.html">22 dicas para um desenvolvedor Angular. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>