<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéª üëçüèΩ üèóÔ∏è Los fundamentos de la programaci√≥n reactiva con RxJS üêé üìô üèµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1. Reactividad y flujos 
 Esta serie de art√≠culos se centra en la reactividad y su aplicaci√≥n en JS utilizando una biblioteca tan maravillosa co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los fundamentos de la programaci√≥n reactiva con RxJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438642/"><h3>  Parte 1. Reactividad y flujos </h3><br>  Esta serie de art√≠culos se centra en la reactividad y su aplicaci√≥n en JS utilizando una biblioteca tan maravillosa como RxJS. <br><br>  Serie de art√≠culos "Fundamentos de la programaci√≥n reactiva con RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Operadores y tuber√≠as.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3. Observables de orden superior</a> </li></ul><br><br>  <b>Para qui√©n es este art√≠culo</b> : b√°sicamente, aqu√≠ explicar√© los conceptos b√°sicos, por lo tanto, el art√≠culo est√° destinado principalmente a principiantes en esta tecnolog√≠a.  Al mismo tiempo, espero que los desarrolladores experimentados puedan aprender algo nuevo por s√≠ mismos.  La comprensi√≥n requerir√° conocimiento de js (es5 / es6). <br><br>  <b>Motivaci√≥n</b> : Primero encontr√© RxJS cuando comenc√© a trabajar con angular.  Fue entonces cuando tuve dificultades para comprender el mecanismo de reactividad.  El hecho de que en el momento del inicio de mi trabajo la mayor√≠a de los art√≠culos se dedicaba a la versi√≥n antigua de la biblioteca se sum√≥ a las dificultades.  Tuve que leer mucha documentaci√≥n, varios manuales para al menos entender algo.  Y solo despu√©s de un tiempo comenc√© a darme cuenta de c√≥mo "todo est√° organizado".  Para facilitarle la vida a los dem√°s, decid√≠ poner todo en los estantes. <br><a name="habracut"></a><br><h4>  ¬øQu√© es la reactividad? </h4><br>  Es dif√≠cil encontrar una respuesta a un t√©rmino aparentemente com√∫n.  En resumen: la reactividad es la capacidad de responder a cualquier cambio.  ¬øPero de qu√© cambios estamos hablando?  En primer lugar, sobre los cambios de datos.  Considere un ejemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 5 -   </span></span></code> </pre> <a name="push"></a><br>  Este ejemplo demuestra el conocido paradigma de programaci√≥n imperativa.  A diferencia del enfoque imperativo, el enfoque reactivo se basa en estrategias de propagaci√≥n de cambio de empuje.  La estrategia de inserci√≥n implica que, en caso de cambios en los datos, estos mismos cambios ser√°n "introducidos" y los datos que dependen de ellos se actualizar√°n autom√°ticamente.  As√≠ es como se comportar√≠a nuestro ejemplo si se aplicara una estrategia de inserci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 6 -   sum  </span></span></code> </pre><br>  Este ejemplo muestra un enfoque reactivo.  Vale la pena se√±alar que este ejemplo no tiene nada que ver con la realidad; lo di solo para mostrar la diferencia en los enfoques.  El c√≥digo reactivo en las aplicaciones del mundo real se ver√° muy diferente, y antes de pasar a la pr√°ctica, deber√≠amos hablar sobre otro componente importante de la reactividad. <br><br><h4>  Flujo de datos </h4><br>  Si observa el t√©rmino "programaci√≥n reactiva" en Wikipedia, el sitio nos dar√° la siguiente definici√≥n: "La programaci√≥n reactiva es un paradigma de programaci√≥n centrado en los flujos de datos y la propagaci√≥n de cambios".  A partir de esta definici√≥n, podemos concluir que la reactividad se basa en dos "ballenas" principales.  Mencion√© la distribuci√≥n de cambios arriba, as√≠ que no nos detendremos m√°s en esto.  Pero deber√≠amos hablar m√°s sobre los flujos de datos.  Veamos el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     const eventsArray = []; input.addEventListener('keyup', event =&gt; eventsArray.push(event) ); //      eventsArray</span></span></code> </pre><br>  Escuchamos el evento keyup y colocamos el objeto de evento en nuestra matriz.  Con el tiempo, nuestra matriz puede contener miles de objetos KeyboardEvent.  Vale la pena se√±alar que nuestra matriz est√° ordenada por tiempo: el √≠ndice de eventos posteriores es mayor que el √≠ndice de eventos anteriores.  Tal matriz es un modelo de flujo de datos simplificado.  ¬øPor qu√© simplificado?  Porque la matriz solo puede almacenar datos.  Tambi√©n podemos iterar la matriz y de alguna manera procesar sus elementos.  Pero la matriz no puede decirnos que se le ha agregado un nuevo elemento.  Para saber si se han agregado nuevos datos a la matriz, tendremos que repetirlos nuevamente. <br><br>  Pero, ¬øqu√© pasar√≠a si nuestra matriz supiera c√≥mo informarnos que llegaron nuevos datos?  Tal conjunto podr√≠a llamarse con certeza una secuencia.  Entonces, llegamos a la definici√≥n de flujo.  Una secuencia es una matriz de datos ordenados por tiempo que puede indicar que los datos han cambiado. <br><br><h4>  Observable </h4><br>  Ahora que sabemos qu√© son los flujos, trabajemos con ellos.  En RxJS, los flujos est√°n representados por la clase Observable.  Para crear su propia secuencia, simplemente llame al constructor de esta clase y pase la funci√≥n de suscripci√≥n como argumento: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); })</code> </pre><br>  Al llamar al constructor de la clase Observable, creamos un nuevo hilo.  Como argumento, pasamos la funci√≥n de suscripci√≥n al constructor.  La funci√≥n de suscripci√≥n es una funci√≥n regular que toma un observador como par√°metro.  El observador mismo es un objeto que tiene tres m√©todos: <br><br><ul><li>  siguiente: arroja un nuevo valor a la transmisi√≥n </li><li>  error: arroja un error en la secuencia, despu√©s de lo cual la secuencia termina </li><li>  complete - termina el hilo </li></ul><br>  Entonces creamos un hilo que emite dos valores y termina. <br><br><h4>  Suscripci√≥n </h4><br>  Si ejecutamos el c√≥digo anterior, no pasar√° nada.  Solo crearemos una nueva secuencia y guardaremos el enlace en la variable observable, pero la secuencia en s√≠ misma nunca emitir√° un solo valor.  Esto se debe a que los hilos son objetos "vagos" y no hacen nada por s√≠ mismos.  Para que nuestra transmisi√≥n comience a emitir valores y podamos procesar estos valores, debemos comenzar a "escuchar" la transmisi√≥n.  Puede hacer esto llamando al m√©todo de suscripci√≥n en el objeto observable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer = { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value), <span class="hljs-comment"><span class="hljs-comment">// 1, 2 error: error =&gt; console.error(error), // complete: () =&gt; console.log("completed") // completed }; observable.subscribe(observer);</span></span></code> </pre><br>  Identificamos a nuestro observador y le describimos tres m√©todos: a continuaci√≥n, error, completo.  Los m√©todos simplemente registran los datos que se pasan como par√°metros.  Luego llamamos al m√©todo de suscripci√≥n y le pasamos nuestro observador.  En el momento de llamar a subscribe, se llama a la funci√≥n de suscripci√≥n, la que pasamos al constructor en la etapa de declarar nuestra secuencia.  A continuaci√≥n, se ejecutar√° el c√≥digo de la funci√≥n de suscripci√≥n, que pasa dos valores a nuestro observador y luego finaliza la transmisi√≥n. <br><br>  Seguramente, muchos tienen una pregunta, ¬øqu√© suceder√° si nos suscribimos a la transmisi√≥n nuevamente?  Todo ser√° igual: la secuencia volver√° a pasar dos valores al observador y al final.  Cada vez que se llama al m√©todo de suscripci√≥n, se llamar√° a una funci√≥n de suscripci√≥n y se volver√° a ejecutar todo su c√≥digo.  De esto podemos concluir: no importa cu√°ntas veces nos suscribamos a la secuencia, nuestros observadores recibir√°n los mismos datos. <br><br><h4>  Darse de baja </h4><a name="timer"></a><br>  Ahora intentemos implementar un ejemplo m√°s complejo.  Escribiremos un temporizador que contar√° segundos desde el momento de la suscripci√≥n y los transmitir√° a los observadores. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  setInterval(() =&gt; { observer.next(counter++); //          }, 1000); }); timer.subscribe({ next: console.log //    });</span></span></code> </pre><br>  El c√≥digo es bastante simple.  Dentro de la funci√≥n de suscripci√≥n, declaramos una variable de contador.  Luego, usando el cierre, accedemos a la variable desde la funci√≥n de flecha en setInterval.  Y cada segundo pasamos la variable al observador, despu√©s de lo cual la incrementamos.  A continuaci√≥n, suscr√≠base a la secuencia, especifique solo un m√©todo: el siguiente.  No se preocupe que no hayamos anunciado otros m√©todos.  No se requiere ninguno de los m√©todos de observaci√≥n.  Incluso podemos pasar un objeto vac√≠o, pero en este caso el hilo se desperdiciar√°. <br><br>  Despu√©s del lanzamiento, veremos los codiciados registros que aparecer√°n cada segundo.  Si lo desea, puede experimentar y suscribirse a la transmisi√≥n varias veces.  Ver√° que cada uno de los hilos se ejecutar√° independientemente de los dem√°s. <br><br>  Si lo piensa, nuestro hilo se ejecutar√° durante toda la vida de la aplicaci√≥n, porque no tenemos ninguna l√≥gica para cancelar setInterval, y en la funci√≥n de suscripci√≥n no hay llamada al m√©todo completo.  Pero, ¬øy si necesitamos que el hilo termine? <br><br>  De hecho, todo es muy simple.  Si mira la documentaci√≥n, puede ver que el m√©todo de suscripci√≥n devuelve un objeto de suscripci√≥n.  Este objeto tiene un m√©todo para darse de baja.  Lo llamamos y nuestro observador dejar√° de recibir valores de la secuencia. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = timer.subscribe({<span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log}); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> subscription.unsubscribe(), <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   5 </span></span></code> </pre><br>  Despu√©s de comenzar, veremos que el contador se detiene en 4. Pero, aunque nos hemos dado de baja de la secuencia, nuestra funci√≥n setInterval contin√∫a funcionando.  Ella incrementa nuestro contador cada segundo y se lo pasa al observador ficticio.  Para evitar que esto suceda, debe escribir la l√≥gica para cancelar el intervalo.  Para hacer esto, debe devolver una nueva funci√≥n de la funci√≥n de suscripci√≥n en la que se implementar√° la l√≥gica de cancelaci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Ahora podemos respirar aliviados.  Despu√©s de llamar al m√©todo de cancelaci√≥n de suscripci√≥n, se llamar√° a nuestra funci√≥n de cancelaci√≥n de suscripci√≥n, que borrar√° el intervalo. <br><br><h4>  Conclusi√≥n </h4><br>  Este art√≠culo muestra las diferencias entre los enfoques imperativo y reactivo, as√≠ como ejemplos de c√≥mo crear sus propios flujos.  En la siguiente parte, hablar√© sobre qu√© otros m√©todos existen para crear hilos y c√≥mo aplicarlos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438642/">https://habr.com/ru/post/438642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, o "C√≥mo llegu√© aqu√≠"</a></li>
<li><a href="../438634/index.html">En las oficinas, hace demasiado calor o demasiado fr√≠o: ¬øhay una mejor manera de ajustar la temperatura?</a></li>
<li><a href="../438636/index.html">Incorporaci√≥n defectuosa de funciones en Go</a></li>
<li><a href="../438638/index.html">Analizamos el protocolo de mensajes de buscapersonas POCSAG, parte 2</a></li>
<li><a href="../438640/index.html">Moneda electr√≥nica abierta de alta velocidad</a></li>
<li><a href="../438644/index.html">La seguridad de los algoritmos de aprendizaje autom√°tico. Protecci√≥n y prueba de modelos con Python</a></li>
<li><a href="../438646/index.html">Acerca de la creaci√≥n de im√°genes est√©reo econ√≥micas en los dedos (estereograma, anaglifo, estereoscopio)</a></li>
<li><a href="../438648/index.html">Comparaci√≥n de sistemas de BI (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../438650/index.html">Cohete 9M729. Algunas palabras sobre el "infractor" del Tratado INF</a></li>
<li><a href="../438652/index.html">Portabelizaci√≥n IDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>