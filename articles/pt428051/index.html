<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏻 🌅 🎁 Como tornar ainda mais estados inválidos ainda mais indizíveis 📂 🈚️ 😯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há pouco tempo, um artigo foi traduzido na Habr sobre como usar tipos de dados algébricos para garantir que estados incorretos sejam inexprimíveis. Ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como tornar ainda mais estados inválidos ainda mais indizíveis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Há pouco tempo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo foi traduzido</a> na Habr sobre como usar tipos de dados algébricos para garantir que estados incorretos sejam inexprimíveis.  Hoje, olhamos para uma maneira um pouco mais generalizada, escalável e segura de expressar o inexprimível, e o Haskell nos ajudará nisso. </p><a name="habracut"></a><br><p> Em resumo, esse artigo discute alguma entidade com um endereço para correspondência e um endereço de email, além da condição adicional de que deve haver pelo menos um desses endereços.  Como é proposto expressar essa condição no nível de tipo?  Propõe-se escrever os endereços da seguinte maneira: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Que problemas essa abordagem tem? </p><br><p>  O mais óbvio (e observado várias vezes nos comentários sobre esse artigo) é que essa abordagem não é escalável.  Imagine que não temos dois tipos de endereços, mas três ou cinco, e a condição de correção parece "deve haver um endereço para correspondência, ou um endereço de e-mail e um endereço comercial, e não deve haver vários endereços do mesmo tipo".  Aqueles que desejam podem escrever o tipo apropriado como um exercício para autoteste.  A tarefa com um asterisco é reescrever esse tipo no caso em que a condição sobre a ausência de duplicatas desapareceu do TOR. </p><br><h3>  Compartilhar </h3><br><p>  Como resolver este problema?  Vamos tentar fantasiar.  Primeiro decompomos e separamos a classe de endereço (por exemplo, número de email / email / mesa no escritório) e o conteúdo correspondente a essa classe: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Ainda não pensamos no conteúdo, porque não há nada nos termos de referência para a validade da lista de endereços. </p><br><p>  Se verificássemos a condição correspondente no tempo de execução de algum construtor de alguma linguagem OOP comum, simplesmente escreveríamos uma função como </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  e lançaria alguma execução se retornar <code>False</code> . </p><br><p>  Em vez disso, podemos verificar uma condição semelhante com a ajuda de um cronômetro ao compilar?  Acontece que sim, podemos, se o sistema de tipos da linguagem for expressivo o suficiente, e no restante do artigo, escolheremos essa abordagem. </p><br><p>  Aqui os tipos dependentes nos ajudarão bastante, e como a maneira mais adequada de escrever um código validado no Haskell é escrevê-lo primeiro no Agde ou no Idris, trocaremos de sapatos e escreveremos no Idris.  A sintaxe idris está bem próxima do Haskell: por exemplo, com a função mencionada acima, você só precisa alterar ligeiramente a assinatura: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Agora lembre-se de que, além das classes de endereço, também precisamos do conteúdo e codificamos a dependência dos campos na classe de endereço como GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Ou seja, se <code>AddrFields t</code> um valor de <code>fields</code> tipo <code>AddrFields t</code> , saberemos que <code>t</code> é uma <code>AddrType</code> AddrType e que esses <code>fields</code> contêm um conjunto de campos correspondentes a essa classe específica. </p><br><div class="spoiler">  <b class="spoiler_title">Sobre esta publicação</b> <div class="spoiler_text"><p>  Essa não é a codificação mais segura para tipos, pois o GADT não precisa ser injetivo e seria mais correto declarar três tipos de dados separados: <code>PostFields</code> , <code>EmailFields</code> , <code>OfficeFields</code> e gravar uma função </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  mas isso é muita escrita, o que para o protótipo não proporciona um ganho significativo, e no Haskell para isso existem ainda mecanismos mais concisos e agradáveis. </p></div></div><br><p>  Qual é o endereço completo neste modelo?  Este é um par da classe de endereço e dos campos correspondentes: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Os fãs da teoria dos tipos dirão que este é um tipo dependente existencial: se <code>AddrType</code> algum valor do tipo <code>Addr</code> , isso significa que existe um valor <code>t</code> tipo <code>AddrType</code> e um conjunto correspondente de campos <code>AddrFields t</code> .  Naturalmente, endereços de uma classe diferente são do mesmo tipo: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Além disso, se <code>EmailFields</code> for fornecido, a única classe de endereço adequada é o <code>Email</code> , para que você possa omiti-lo, o timer o imprimirá você mesmo: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Escrevemos uma função auxiliar que fornece a lista correspondente de classes de endereço da lista de endereços e a generalizamos imediatamente para trabalhar em um functor arbitrário: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Aqui, o tipo <code>Addr</code> existencial se comporta como um casal familiar: em particular, você pode solicitar seu primeiro componente <code>AddrType</code> (tarefa com um asterisco: por que não posso solicitar o segundo componente?). </p><br><h4>  Aumentar </h4><br><p>  Agora passamos para uma parte essencial da nossa história.  Portanto, temos uma lista de endereços de <code>valid : List AddrType -&gt; Bool</code> <code>List Addr</code> e algum predicado <code>valid : List AddrType -&gt; Bool</code> , cuja execução dessa lista queremos garantir no nível dos tipos.  Como os combinamos?  Claro, outro tipo! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Agora vamos analisar o que escrevemos aqui. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> significa que o tipo <code>ValidatedAddrList</code> parametrizado, de fato, pela lista de endereços. </p><br><p>  Vejamos a assinatura do único construtor <code>MkValidatedAddrList</code> desse tipo: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Ou seja, é necessária uma lista de endereços <code>lst</code> e outro argumento <code>prf</code> do tipo <code>valid (types lst) = True</code> .  O que esse tipo significa?  Portanto, significa que o valor à esquerda de <code>=</code> é igual ao valor à direita de <code>=</code> , ou seja, <code>valid (types lst)</code> , de fato, é True. </p><br><p>  Como isso funciona?  Assinatura <code>=</code> parece <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Ou seja, <code>=</code> assume dois valores arbitrários <code>x</code> e <code>y</code> (possivelmente até de tipos diferentes <code>A</code> e <code>B</code> , o que significa que a desigualdade nos idris é heterogênea e que é um tanto ambígua do ponto de vista da teoria dos tipos, mas esse é um tópico para outra discussão).  O que então demonstra igualdade?  E devido ao fato de que o único construtor <code>=</code> - <code>Refl</code> com uma assinatura de <em>quase</em> <code>(x : A) -&gt; x = x</code> .  Ou seja, se tivermos um valor do tipo <code>x = y</code> , sabemos que ele foi construído usando <code>Refl</code> (porque não há outros construtores), o que significa que <code>x</code> é realmente igual a <code>y</code> . </p><br><p>  Observe que é por isso que, no Haskell, sempre fingimos que estamos provando alguma coisa, porque o Haskell <code>undefined</code> que habita qualquer tipo, de modo que o argumento acima não funciona lá: para qualquer <code>x</code> , <code>y</code> termo do tipo <code>x = y</code> pode ser criado via <code>undefined</code> (ou através de recursão infinita, digamos que em geral seja o mesmo em termos de teoria de tipos). </p><br><p>  Também observamos que a igualdade aqui não é significada no sentido de Haskell <code>Eq</code> ou algum <code>operator==</code> em C ++, mas muito mais rigorosa: estrutural, que, simplificando, significa que os dois valores têm a mesma <em>forma</em> .  Ou seja, enganá-lo de forma simples não funciona.  Mas questões de igualdade são tradicionalmente atraídas para um artigo separado. </p><br><p>  Para consolidar nossa compreensão da igualdade, escrevemos testes de unidade para a função <code>valid</code> : </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Esses testes são bons porque você nem precisa executá-los, basta que o taypcher os tenha verificado.  De fato, vamos substituir <code>True</code> por <code>False</code> , por exemplo, no primeiro deles e ver o que acontece: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher jura </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  como esperado.  Ótimo </p><br><h4>  Simplifique </h4><br><p>  Agora vamos refatorar nosso <code>ValidatedAddrList</code> pouco. </p><br><p>  Em primeiro lugar, o padrão de comparação de um determinado valor com <code>True</code> bastante comum; portanto, existe um tipo especial <code>So</code> nos idris: você pode usar <code>So x</code> como sinônimo de <code>x = True</code> .  Vamos corrigir a definição de <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Além disso, o <code>So</code> tem uma função auxiliar conveniente, que em essência eleva a verificação ao nível dos tipos: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Será útil quando escrevermos funções que modificam esse tipo. </p><br><p>  Em segundo lugar, algumas vezes (especialmente no desenvolvimento interativo) os idris podem encontrar o valor apropriado de <code>prf</code> conta própria.  Para que, nesses casos, não fosse necessário construí-lo manualmente, existe um açúcar sintático correspondente: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Aparelhos encaracolados significam que este é um argumento implícito que idris tentará sair do contexto, e <code>auto</code> significa que ele também tentará construí-lo. </p><br><p>  Então, o que esse novo <code>ValidatedAddrList</code> nos fornece?  E isso fornece uma cadeia de raciocínio: seja <code>val</code> um valor do tipo <code>ValidatedAddrList lst</code> .  Isso significa que <code>lst</code> é uma lista de endereços e, além disso, <code>val</code> foi criado usando o construtor <code>MkValidatedAddrList</code> , para o qual passamos esse muito <code>lst</code> e outro valor <code>prf</code> do tipo <code>So (valid $ types lst)</code> , que é quase <code>valid (types lst) = True</code> .  E para que possamos construir o <code>prf</code> , precisamos, de fato, provar que essa igualdade é válida. </p><br><p>  E o mais bonito é que tudo isso é verificado por um tympher.  Sim, a verificação de validade terá que ser feita em tempo de execução (porque os endereços podem ser lidos a partir de um arquivo ou da rede), mas o cronômetro garantirá que essa verificação seja feita: sem ela, você não pode criar um <code>ValidatedAddrList</code> .  Pelo menos em idris.  Em Haskell, infelizmente. </p><br><h4>  Inserir </h4><br><p>  Para verificar a inevitabilidade da verificação, tentaremos escrever uma função para adicionar um endereço à lista.  Primeira tentativa: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Não, o erro de digitação dá nos dedos (embora não seja muito legível, o custo da <code>valid</code> muito complicado): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Como conseguimos uma cópia deste <code>So</code> ?  Nada além da <code>choose</code> mencionada acima.  Segunda tentativa: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  É quase typechetsya.  "Quase" porque não está claro o que substituir por <code>rhs</code> .  Pelo contrário, é claro: neste caso, a função deve de alguma forma relatar um erro.  Portanto, você precisa alterar a assinatura e agrupar o valor de retorno, por exemplo, em <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Isso é lado a lado e funciona como deveria. </p><br><p>  Mas agora surge o seguinte problema não muito óbvio, que estava, de fato, no artigo original.  O tipo desta função não para de escrever essa implementação: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Ou seja, sempre dizemos que não conseguimos criar uma nova lista de endereços.  Typhechaetsya?  Sim  Está correto?  Bem, dificilmente.  Isso pode ser evitado? </p><br><p>  Acontece que é possível, e temos todas as ferramentas necessárias para isso.  Se for bem-sucedido, <code>insert</code> retorna um <code>ValidatedAddrList</code> , que contém evidências desse mesmo sucesso.  Portanto, adicione simetria elegante e peça à função que retorne também uma prova de falha! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Agora não podemos simplesmente pegar e sempre retornar <code>Nothing</code> . </p><br><p>  Você pode fazer o mesmo para funções de remoção de endereço e similares. </p><br><p>  Vamos ver como agora tudo parece no final. </p><br><p>  Vamos tentar criar uma lista de endereços vazia: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  É impossível, uma lista vazia não é válida. </p><br><p>  Que tal uma lista de apenas um endereço para correspondência? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  Ok, vamos tentar inserir o endereço para correspondência na lista que já possui o endereço para correspondência: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Vamos tentar inserir o email: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  No final, tudo funciona exatamente como o esperado. </p><br><p>  Ufa.  Eu pensei que seriam três linhas, mas acabou um pouco mais.  Para explorar até onde podemos chegar no Haskell, estaremos no próximo artigo.  Enquanto isso, um pouco </p><br><h4>  Ponderar </h4><br><p>  No final, qual é o lucro dessa decisão em comparação com o dado no artigo, a que nos referimos no início? </p><br><ol><li>  Novamente, é muito mais escalável.  Funções de validação complexas são mais fáceis de escrever. </li><li>  É mais isolado.  O código do cliente não precisa saber o que está dentro da função de validação, enquanto o formulário <code>ContactInfo</code> do artigo original exige que ele esteja vinculado. </li><li>  A lógica de validação é escrita na forma de funções comuns e familiares, para que possa ser verificada imediatamente com leitura cuidadosa e testada com testes de tempo de compilação, em vez de derivar o significado da validação de um formulário de tipo de dados que representa um resultado já verificado. </li><li>  Torna-se possível especificar com mais precisão o comportamento das funções que funcionam com o tipo de dados de seu interesse, principalmente no caso de falha na aprovação no teste.  Por exemplo, a <code>insert</code> gravada como resultado é simplesmente impossível escrever <em>incorretamente</em> .  Da mesma forma, pode-se escrever <code>insertOrReplace</code> , <code>insertOrIgnore</code> e similares, cujo comportamento é totalmente especificado no tipo. </li></ol><br><p>  Qual é o lucro comparado a uma solução de POO como essa? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  O código é mais modularizado e seguro.  No caso acima, uma verificação é uma <em>ação</em> que é verificada uma vez e sobre a qual eles se esqueceram posteriormente.  Tudo se baseia na honestidade e no entendimento de que, se você possui um <code>ValidatedAddrListClass</code> , sua implementação fez uma verificação lá.  O fato dessa verificação da classe não pode ser escolhido como um determinado valor.  No caso de um <em>valor de</em> algum tipo, esse valor pode ser transferido entre diferentes partes do programa, usado para criar valores mais complexos (por exemplo, novamente, negar essa verificação), investigar (consulte o próximo parágrafo) e geralmente fazer o mesmo que costumávamos fazer. com valores. </li><li>  Tais verificações podem ser usadas na correspondência de padrões (dependente).  É verdade que não no caso dessa função <code>valid</code> e nem no caso de idris, é dolorosamente complicado e idris é dolorosamente monótono para que informações úteis para padrões possam ser extraídas da estrutura <code>valid</code> .  No entanto, <code>valid</code> pode ser reescrito em um estilo de correspondência de padrões um pouco mais amigável, mas isso está além do escopo deste artigo e geralmente não é trivial por si só. </li></ol><br><p>  Quais são as desvantagens? </p><br><p>  Vejo apenas uma falha fundamental séria: <code>valid</code> é uma função estúpida demais.  Ele retorna apenas um bit de informação - se os dados passaram na validação ou não.  No caso de tipos mais inteligentes, poderíamos conseguir algo mais interessante. </p><br><p>  Por exemplo, imagine que o requisito de exclusividade de endereços desapareceu do TK.  Nesse caso, é óbvio que adicionar um novo endereço à lista de endereços existente não tornará a lista inválida; portanto, poderíamos <em>provar esse teorema</em> escrevendo uma função com o tipo <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> e use-o, por exemplo, para escrever com segurança de tipo sempre bem-sucedida </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Mas, infelizmente, teoremas como recursão e indução, e nosso problema não possui nenhuma estrutura indutiva elegante; portanto, na minha opinião, o código com o valor booleano de carvalho <code>valid</code> também <code>valid</code> bom. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428051/">https://habr.com/ru/post/pt428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428039/index.html">O governo não planeja defender a neutralidade da rede</a></li>
<li><a href="../pt428041/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 336 (22 a 28 de outubro de 2018)</a></li>
<li><a href="../pt428043/index.html">Esperando pelo sexto, Winamp 5.8: o "segredo" de origem, a possibilidade da versão oficial</a></li>
<li><a href="../pt428045/index.html">PHP Digest No. 142 (15 a 29 de outubro de 2018)</a></li>
<li><a href="../pt428047/index.html">Análise de desempenho de servidores WSGI: coloque o uWSGI de volta no lugar</a></li>
<li><a href="../pt428053/index.html">Como criar uma estratégia de teste: versão de engenheiros reais</a></li>
<li><a href="../pt428055/index.html">Retrospectiva de startups de tecnologia. Z3 - o primeiro computador de retransmissão</a></li>
<li><a href="../pt428057/index.html">Uma nova visão sobre a documentação da API e SDK no Yandex. Palestra sobre Hyperbaton</a></li>
<li><a href="../pt428059/index.html">Conectar armazenamento LUN de caminhos múltiplos ao VMware ESXi e Debian GNU / Linux</a></li>
<li><a href="../pt428061/index.html">Gerenciamento de custos de projetos com gerenciamento de valor agregado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>