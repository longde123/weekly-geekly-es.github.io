<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¶ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ¦ OpenGL Ultramodern. Bagian 2 ğŸš¤ ğŸˆ ğŸ™ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua suasana hati yang baik dan suhu yang lebih rendah di luar jendela. Seperti yang dijanjikan, saya menerbitkan kelanjutan artikel tentang super-du...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL Ultramodern. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457380/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  Semua suasana hati yang baik dan suhu yang lebih rendah di luar jendela.  Seperti yang dijanjikan, saya menerbitkan kelanjutan artikel tentang super-duper OpenGL modern.  Siapa yang belum membaca bagian pertama - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ultramodern OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> <br><br>  Mungkin Anda beruntung dan saya bisa memasukkan semua bahan yang tersisa ke dalam artikel ini, ini tidak pasti ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Tekstur array</font> </h3><br>  Array tekstur ditambahkan kembali di OpenGL 3.0, tetapi untuk beberapa alasan beberapa orang menulis tentang mereka (informasi disembunyikan oleh Freemason).  Anda semua sudah terbiasa dengan pemrograman dan tahu apa itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> , meskipun saya lebih baik "pendekatan" dari sisi lain. <br><br>  Untuk mengurangi jumlah peralihan di antara tekstur, dan sebagai hasilnya, untuk mengurangi operasi peralihan keadaan, orang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atlas tekstur</a> (tekstur yang menyimpan data untuk beberapa objek).  Tapi orang-orang pintar dari Khronos telah mengembangkan alternatif bagi kita - Tekstur array.  Sekarang kita dapat menyimpan tekstur sebagai lapisan dalam array ini, yaitu, itu adalah alternatif untuk atlas.  Wiki OpenGL memiliki deskripsi yang sedikit berbeda tentang mipmaps, dll, tetapi tampaknya terlalu rumit bagi saya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ). <br><br>  Keuntungan menggunakan pendekatan ini dibandingkan dengan atlas adalah bahwa setiap lapisan dianggap sebagai tekstur terpisah dalam hal pembungkus dan pemetaan. <br><br>  Tetapi kembali ke domba jantan kami ... Array tekstur memiliki tiga jenis target: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  Kode untuk membuat array tekstur: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  Yang paling penuh perhatian memperhatikan bahwa kami sedang membuat repositori untuk tekstur 2D, tetapi untuk beberapa alasan kami menggunakan array 3D, tidak ada kesalahan atau salah ketik di sini.  Kami menyimpan tekstur 2D, tetapi karena terletak di "lapisan", kami mendapatkan larik 3D (sebenarnya, data piksel disimpan, bukan tekstur. Larik 3D memiliki lapisan 2D dengan data piksel). <br><br>  Di sini mudah dipahami pada contoh tekstur 1D.  Setiap baris dalam array piksel 2D adalah layer 1D yang terpisah.  Tekstur mipmap juga dapat dibuat secara otomatis. <br><br>  Mengenai ini, semua kesulitan berakhir dan menambahkan gambar ke lapisan tertentu cukup sederhana: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  Saat menggunakan array, kita perlu sedikit mengubah shader <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  Opsi terbaik adalah menghitung layer yang diinginkan di luar shader, untuk ini kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UBO</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSBO</a> (ini juga digunakan untuk mentransfer matriks, dan banyak data lainnya, tetapi entah bagaimana lain kali).  Jika ada yang tidak bisa menunggu <a href="">tyk_1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tyk_2</a> , Anda dapat membaca. <br><br>  Adapun ukuran, yaitu GL_MAX_ARRAY_TEXTURE_LAYERS yang 256 di OpenGL 3.3 dan 2048 di OpenGL 4.5. <br><br>  Perlu diceritakan tentang Objek Sampler (tidak terkait dengan tekstur Array, tetapi hal yang bermanfaat) - ini adalah objek yang digunakan untuk menyesuaikan keadaan unit tekstur, terlepas dari objek mana yang saat ini melekat pada unit.  Ini membantu memisahkan status sampler dari objek tekstur tertentu, yang meningkatkan abstraksi. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  Saya baru saja membuat objek sampler, mengaktifkan penyaringan linier dan 16x penyaringan anisotropik untuk unit tekstur. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Di sini kita hanya mengikat sampler ke unit tekstur yang diinginkan, dan ketika itu berhenti menjadi bindim 0 yang diinginkan untuk unit ini. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Ketika kami menautkan sampler, pengaturannya lebih diutamakan daripada pengaturan unit tekstur.  Hasil: Tidak perlu memodifikasi basis kode yang ada untuk menambahkan objek sampler.  Anda dapat membiarkan pembuatan tekstur apa adanya (dengan status sampler sendiri) dan hanya menambahkan kode untuk mengontrol dan menggunakan objek sampler. <br><br>  Ketika tiba saatnya untuk menghapus objek, kita cukup memanggil fungsi ini: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Tampilan tekstur</font> </h3><br>  Saya akan menerjemahkan ini sebagai "penunjuk tekstur (mungkin lebih tepat daripada tautannya, saya xs)", karena saya tidak tahu terjemahan terbaik. <br><br>  Apa petunjuk dalam perspektif OpenGL? <br><br>  Semuanya sangat sederhana, ini adalah penunjuk ke data tekstur yang tidak dapat diubah (yaitu, bisa berubah), seperti yang kita lihat dalam gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  Sebenarnya, ini adalah objek yang membagikan data texel dari objek tekstur tertentu, untuk analogi kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: shared_ptr dari C ++</a> .  Selama setidaknya ada satu pointer tekstur, tekstur asli tidak akan dihapus oleh pengemudi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki</a> dijelaskan secara lebih rinci, serta layak dibaca tentang jenis tekstur dan target (mereka tidak harus cocok) <br><br>  Untuk membuat pointer, kita perlu mendapatkan deskriptor tekstur dengan memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glGenTexture</a> (tidak diperlukan inisialisasi) dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Pointer tekstur dapat menunjuk ke tingkat N dari mipmap, cukup berguna dan nyaman.  Pointer dapat berupa array tekstur, bagian array, lapisan tertentu dalam array ini, atau dapat berupa irisan tekstur 3D sebagai tekstur 2D. <br><br><h3>  <font color="#4682B4">Buffer tunggal untuk indeks dan vertex</font> </h3><br>  Yah, semuanya akan cepat dan mudah.  Sebelumnya, spesifikasi OpenGL untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vertex Buffer Object</a> merekomendasikan agar pengembang memecah data verteks dan indeks menjadi buffer yang berbeda, tetapi sekarang ini tidak diperlukan (sejarah panjang mengapa tidak). <br>  Yang kita butuhkan adalah menyimpan indeks di depan simpul dan memberi tahu di mana simpul dimulai (lebih tepatnya, offset), untuk ini ada perintah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glVertexArrayVertexBuffer</a> <br><br>  Inilah cara kami akan melakukannya: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Tessellation dan komputasi warna</font> </h3><br>  Saya tidak akan memberi tahu Anda tentang shading tessellation, karena ada banyak materi di Google tentang ini (dalam bahasa Rusia), berikut adalah beberapa pelajaran: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> .  Kami terus mempertimbangkan shader untuk perhitungan (bliiin, juga banyak materi, saya akan memberitahu Anda secara singkat). <br><br>  Keuntungan dari kartu video dalam jumlah inti yang sangat besar, kartu video dirancang untuk sejumlah besar tugas kecil yang dapat dilakukan secara paralel.  Shader kalkulasi, sesuai namanya, memungkinkan untuk menyelesaikan masalah yang tidak terkait dengan grafik (tidak perlu). <br><br>  Gambar, saya tidak tahu harus menyebutnya apa (seperti aliran dikelompokkan). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  Untuk apa kita bisa menggunakannya? <br><br><ul><li>  Pemrosesan gambar <ol><li>  Bloom </li><li>  Algoritma Berbasis Ubin (Shading Tertunda) </li></ol></li><li>  Simulasi <br><ol><li>  Partikel </li><li>  Air </li></ol></li></ul><br>  Lebih lanjut saya tidak melihat alasan untuk menulis, ada juga banyak informasi di Google, berikut adalah contoh sederhana penggunaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Berikut adalah contoh penghitung komputasi kosong: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Berikut adalah beberapa tautan untuk melihat lebih dalam pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4</a> . <br><br><h3>  <font color="#4682B4">Pembuatan jalur</font> </h3><br>  Ini adalah ekstensi baru (bukan baru) dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NVidia</a> , tujuan utamanya adalah rendering vektor 2D.  Kita dapat menggunakannya untuk teks atau UI, dan karena grafiknya vektor, itu tidak bergantung pada resolusi, yang tidak diragukan lagi merupakan nilai tambah yang besar dan UI kita akan terlihat hebat. <br><br>  Konsep dasarnya adalah stensil, kemudian penutup (penutup aslinya).  Atur path stencil, lalu visualisasikan pikselnya. <br><br>  Untuk manajemen, GLuint standar digunakan, dan fungsi create dan delete memiliki konvensi penamaan standar. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Ini sedikit tentang bagaimana kita bisa mendapatkan jalan: <br><ul><li>  SVG atau PostScript di string'e <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  berbagai perintah dengan koordinat yang sesuai <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  dan untuk memperbarui data <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  font <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  kombinasi linier dari jalur yang ada (interpolasi satu, dua atau lebih jalur) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  transformasi linear dari jalur yang ada <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  Daftar perintah standar: <br><br><ul><li>  pindah ke (x, y) </li><li>  jalur dekat </li><li>  line-to (x, y) </li><li>  kurva kuadratik (x1, y1, x2, y2) </li><li>  kurva kubik (x1, y1, x2, y2, x3, y3) </li><li>  kurva halus-kuadratik (x, y) </li><li>  kurva halus-kubik (x1, y1, x2, y2) </li><li>  elips-busur (rx, ry, rotasi sumbu-x, bendera busur-besar, bendera-sapu, x, y) </li></ul><br>  Inilah yang tampak seperti string path di PostScript: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepathâ€ // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepathâ€ <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Dan di sini di SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 zâ€ // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Zâ€ <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Masih ada segala macam roti dengan jenis isian, pinggiran, tikungan: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  Saya tidak akan menjelaskan semuanya di sini, karena ada banyak bahan dan itu akan membutuhkan seluruh artikel (jika menarik, saya akan menulisnya entah bagaimana). <br><br>  Berikut adalah daftar rendering primitif <br><br><ul><li>  Kurva kubik </li><li>  Kurva kuadratik </li><li>  Garis </li><li>  Mesin terbang font </li><li>  Arcs </li><li>  Dash &amp; Endcap Style </li></ul><br>  Berikut ini beberapa kode, dan kemudian ada banyak teks: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  Itu saja. <br><br>  Tampaknya bagi saya bahwa artikel ini kurang menarik dan informatif, sulit untuk memilih hal utama dalam materi.  Jika seseorang tertarik untuk mempelajari lebih detail, saya dapat membuang beberapa materi NVidia dan tautan ke spesifikasi (jika saya ingat di mana saya menyimpannya).  Saya juga senang atas bantuan dalam mengedit artikel. <br><br>  Seperti yang dijanjikan, saya akan menulis artikel berikut tentang mengoptimalkan dan mengurangi panggilan undian.  Saya ingin meminta Anda untuk menulis di komentar tentang apa lagi yang ingin Anda baca dan apa yang Anda minati: <br><ul><li>  Menulis game di cocos2d-x (Berlatih saja, tanpa air) </li><li>  Terjemahan Seri Artikel Vulkan </li><li>  Beberapa topik tentang OpenGL (angka empat, fungsionalitas baru) </li><li>  Algoritma grafis komputer (pencahayaan, oklusi ambien layar ruang, refleksi layar ruang) </li><li>  Opsi Anda </li></ul><br><br>  Terima kasih atas perhatiannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457380/">https://habr.com/ru/post/id457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457354/index.html">Kebingungan Data untuk Tes Kinerja</a></li>
<li><a href="../id457362/index.html">Promosi dari RUVDS: siapkan server di musim panas</a></li>
<li><a href="../id457366/index.html">Seorang fanatik, sepotong besi atau penonton - gamer seperti apa Anda?</a></li>
<li><a href="../id457374/index.html">Kurangi waktu pembangunan proyek Android Anda</a></li>
<li><a href="../id457378/index.html">Bagaimana id Software menciptakan Wolfenstein 3D berdasarkan teknologi dari Commander Keen</a></li>
<li><a href="../id457382/index.html">7 kebiasaan programmer berkinerja tinggi</a></li>
<li><a href="../id457386/index.html">Memperkenalkan Linux Virtual Interfaces: Tunnels</a></li>
<li><a href="../id457390/index.html">Madagaskar - pulau kontras</a></li>
<li><a href="../id457392/index.html">Penghematan pada Pengembangan Lintas-Platform Seluler: Studi Kasus Skyeng</a></li>
<li><a href="../id457396/index.html">Membuka kunci wadah LUKS root secara otomatis setelah boot panas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>