<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§šğŸ» ğŸ½ ğŸ‘£ Cadangkan untuk Linux, atau cara membuat snapshot ğŸ¤² ğŸ‰ ğŸ”ˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Saya bekerja di Veeam pada proyek Veeam untuk proyek Linux. Dengan produk ini, Anda dapat membuat cadangan mesin Linux. "Agen" dalam na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cadangkan untuk Linux, atau cara membuat snapshot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Halo semuanya!  Saya bekerja di Veeam pada proyek Veeam untuk proyek Linux.  Dengan produk ini, Anda dapat membuat cadangan mesin Linux.  "Agen" dalam namanya berarti bahwa program ini memungkinkan Anda untuk membuat cadangan mesin fisik.  Virtualalkans juga cadangan, tetapi terletak di OS tamu. <br><br>  Inspirasi untuk artikel ini adalah laporan saya di konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linux Piter</a> , yang saya putuskan untuk diterbitkan sebagai artikel untuk semua habragiteli yang tertarik. <br><br>  Dalam artikel itu, saya akan mengungkapkan topik membuat snapshot yang memungkinkan Anda untuk membuat cadangan dan berbicara tentang masalah yang kami temui saat membuat mekanisme kami sendiri untuk membuat snapshot dari perangkat blok. <br><br>  Semua yang berminat silakan meminta potongan! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Sedikit teori di awal </h2><br>  Secara historis, ada dua pendekatan untuk membuat cadangan: File cadangan dan Volume cadangan.  Dalam kasus pertama, kami menyalin setiap file sebagai objek yang terpisah, dalam yang kedua, kami menyalin seluruh konten volume sebagai jenis gambar. <br><br>  Kedua metode memiliki banyak kelebihan dan kekurangan, tetapi kami akan mempertimbangkannya melalui prisma pemulihan dari kegagalan: <br><br><ul><li>  Dalam hal File cadangan, untuk pemulihan penuh seluruh server, kita perlu menginstal OS terlebih dahulu, kemudian layanan yang diperlukan, dan hanya kemudian mengembalikan file dari cadangan. </li><li>  Dalam hal cadangan Volume, untuk pemulihan penuh cukup untuk mengembalikan semua volume mesin tanpa upaya yang tidak perlu dari orang tersebut. </li></ul><br>  Jelas, dalam hal cadangan Volume, Anda dapat memulihkan sistem lebih cepat, dan ini merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karakteristik</a> penting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sistem</a> .  Karenanya, untuk diri kami sendiri, kami mencatat cadangan volume sebagai opsi yang disukai. <br><br>  Bagaimana kita mengambil dan menyimpan seluruh volume?  Tentu saja, hanya menyalin kita tidak akan mencapai hal yang baik.  Selama penyalinan, beberapa aktivitas dengan data akan terjadi pada volume, sebagai akibatnya, data yang tidak konsisten akan muncul di cadangan.  Struktur sistem file akan dilanggar, file basis data akan rusak, serta file lain yang dengannya operasi akan dilakukan selama penyalinan. <br><br>  Untuk menghindari semua masalah ini, umat manusia progresif muncul dengan teknologi snapshot - snapshot.  Secara teori, semuanya sederhana: kami membuat salinan yang tidak berubah - potret - dan mencadangkan data darinya.  Saat cadangan selesai - kami menghancurkan snapshot.  Kedengarannya sederhana, tetapi, seperti biasa, ada nuansa. <br><br>  Karena mereka, banyak implementasi teknologi ini lahir.  Misalnya, solusi berdasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mapper perangkat</a> , seperti LVM dan Thin provisioning, memberikan snapshot volume penuh, tetapi memerlukan tata letak disk khusus pada tahap instalasi sistem, yang berarti bahwa secara umum mereka tidak cocok. <br><br>  BTRFS dan ZFS memungkinkan untuk membuat snapshot dari substruktur sistem file, yang sangat keren, tetapi saat ini bagian mereka pada server kecil, dan kami mencoba membuat solusi universal. <br><br>  Misalkan ada EXT dangkal pada perangkat blok kami.  Dalam hal ini, kita dapat menggunakan <a href="">dm-snap</a> (ngomong-ngomong, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dm-bow</a> sedang dikembangkan sekarang), tapi di sini ada nuansa tersendiri.  Anda harus memiliki perangkat blok gratis yang siap sehingga Anda dapat membuang data snapshot di mana. <br>  Memperhatikan solusi cadangan alternatif, kami memperhatikan bahwa, sebagai aturan, mereka menggunakan modul kernel untuk membuat snapshot perangkat blok.  Kami memutuskan untuk pergi dengan cara ini, menulis modul kami.  Diputuskan untuk mendistribusikannya di bawah lisensi GPL, sehingga tersedia untuk umum di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br><br><h2>  Cara kerjanya - secara teori </h2><br><h3>  Cuplikan mikroskop </h3><br>  Jadi, sekarang kita akan mempertimbangkan prinsip umum operasi modul dan membahas masalah-masalah utama secara lebih rinci. <br><br>  Sebenarnya, veeamsnap (seperti yang kami sebut modul kernel kami) adalah filter driver perangkat blok. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Tugasnya adalah mencegat permintaan untuk driver perangkat blok. <br><br>  Setelah mencegat permintaan tulis, modul menyalin data dari perangkat blok asli ke area data foto.  Kami menyebut area ini snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  Dan apa snapshot itu sendiri?  Ini adalah perangkat blok virtual, salinan perangkat asli pada titik waktu tertentu.  Saat mengakses blok data pada perangkat ini, mereka dapat dibaca dari snap-in, atau dari perangkat asli. <br><br>  Saya ingin mencatat bahwa snapshot itu persis perangkat blok yang sepenuhnya identik dengan aslinya pada saat snapshot dihapus.  Berkat ini, kita dapat memasang sistem file pada snapshot dan melakukan pra-pemrosesan yang diperlukan. <br><br>  Misalnya, kita bisa mendapatkan peta blok yang ditempati dari sistem file.  Cara termudah untuk melakukan ini adalah dengan menggunakan ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GETFSMAP</a> . <br>  Data pada blok sibuk memungkinkan Anda untuk hanya membaca data terbaru dari snapshot. <br><br>  Anda juga dapat mengecualikan beberapa file.  Nah, tindakan yang sepenuhnya opsional: indeks file yang masuk ke cadangan, untuk kemungkinan restoran granular di masa depan. <br><br><h3>  CoW vs RoW </h3><br>  Mari kita memikirkan sedikit tentang memilih algoritma snapshot.  Pilihan di sini tidak terlalu luas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Copy-on-Write atau Redirect-on-Write</a> . <br><br>  Redirect-on-Write ketika mencegat permintaan tulis akan mengarahkan ulang ke snap, setelah semua permintaan untuk membaca blok ini akan pergi ke sana juga.  Algoritme yang bagus untuk sistem penyimpanan yang dibangun berdasarkan pohon B +, seperti BTRFS, ZFS dan Thin Provisioning.  Teknologi ini setua dunia, tetapi memanifestasikan dirinya dengan sangat baik di hypervisors, di mana Anda dapat membuat file baru dan menulis blok baru di sana selama durasi snapshot.  Kinerja sangat baik dibandingkan dengan Kontrak Karya.  Tetapi ada minus lemak - struktur perangkat asli berubah, dan ketika menghapus snapshot, Anda perlu menyalin semua blok dari snap ke lokasi asli. <br><br>  Copy-on-Write, ketika mencegat permintaan, menyalin data ke snapstore yang harus mengalami perubahan, setelah itu memungkinkan mereka untuk ditimpa di tempat asli.  Digunakan untuk membuat snapshot untuk volume LVM dan salinan bayangan VSS.  Jelas, itu lebih cocok untuk membuat snapshot perangkat blok, karena  tidak mengubah struktur perangkat asli, dan ketika Anda menghapus (atau crash) snapshot hanya dapat dibuang tanpa risiko data.  Kelemahan dari pendekatan ini adalah penurunan kinerja, karena beberapa operasi baca / tulis ditambahkan ke setiap operasi penulisan. <br><br>  Karena keamanan data adalah prioritas utama kami, kami fokus pada Kontrak Karya. <br><br>  Sejauh ini, semuanya terlihat sederhana, jadi mari kita membahas masalah kehidupan nyata. <br><br><h2>  Cara kerjanya - dalam praktik </h2><br><h3>  Kondisi yang konsisten </h3><br>  Demi dia, semuanya dikandung. <br>  Misalnya, jika pada saat membuat snapshot (dalam perkiraan pertama, kita dapat mengasumsikan bahwa itu dibuat secara instan), file akan direkam, maka dalam snapshot file tersebut tidak lengkap, yang berarti akan rusak dan tidak berarti.  Situasinya mirip dengan file database dan sistem file itu sendiri. <br><br>  Tapi kita hidup di abad ke-21!  Ada mekanisme logging yang melindungi dari masalah seperti itu!  Benar, kenyataannya adalah, ada "tetapi" yang penting: perlindungan ini bukan dari kegagalan, tetapi dari konsekuensinya.  Ketika mengembalikan ke kondisi yang konsisten menurut log, operasi yang tidak lengkap akan dibuang, yang berarti bahwa mereka akan hilang.  Karena itu, penting untuk menggeser prioritas perlindungan dari penyebabnya, daripada mengobati konsekuensinya. <br><br>  Sistem dapat diperingatkan bahwa snapshot sekarang akan dibuat.  Untuk ini, kernel memiliki fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freeze_bdev</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thaw_bdev</a> .  Mereka menarik fungsi filesystem freeze_fs dan unfreeze_fs.  Saat Anda memanggil yang pertama, sistem harus mengatur ulang cache, menangguhkan pembuatan permintaan baru ke perangkat blokir dan menunggu penyelesaian semua permintaan yang dihasilkan sebelumnya.  Dan ketika unfreeze_fs dipanggil, sistem file mengembalikan fungsi normalnya. <br><br>  Ternyata kita bisa memperingatkan sistem file.  Bagaimana dengan aplikasi?  Di sini, sayangnya, semuanya buruk.  Sementara di Windows ada mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VSS</a> yang, dengan bantuan Penulis, menyediakan interaksi dengan produk lain, di Linux masing-masing berjalan dengan caranya sendiri.  Saat ini, ini telah menyebabkan situasi yang tugas administrator sistem untuk menulis (menyalin, <s>mencuri</s> , membeli, dll) pra-membekukan dan skrip post-thaw sendiri, yang akan mempersiapkan aplikasi mereka untuk snapshot.  Untuk bagian kami, dalam rilis berikutnya kami akan memperkenalkan dukungan untuk Pemrosesan Aplikasi Oracle, sebagai fitur yang paling sering diminta oleh pelanggan kami.  Kemudian, aplikasi lain mungkin didukung, tetapi secara keseluruhan situasinya agak menyedihkan. <br><br><h3>  Di mana menempatkan snap? </h3><br>  Ini adalah masalah kedua yang menghalangi kita.  Sepintas, masalahnya tidak jelas, tetapi setelah sedikit pemahaman, kita melihat bahwa ini masih sempalan. <br><br>  Tentu saja, solusi termudah adalah menempatkan snap di RAM.  Untuk pengembang, opsinya luar biasa!  Semuanya cepat, sangat nyaman untuk melakukan debugging, tetapi ada jamb: RAM adalah sumber daya yang berharga, dan tidak ada yang akan memberi kita kesempatan besar di sana. <br><br>  OK, mari kita jadikan snap-file sebagai file biasa.  Tetapi masalah lain muncul - Anda tidak dapat membuat cadangan volume di mana snapstop berada.  Alasannya sederhana: kami mencegat permintaan rekaman, yang berarti kami akan mencegat permintaan rekaman kami sendiri di snap-in.  Kuda berlarian secara ilmiah - jalan buntu.  Lalu ada keinginan akut untuk menggunakan disk terpisah untuk ini, tetapi tidak ada yang akan menambahkan disk ke server kami demi kami.  Anda harus bisa mengerjakan apa yang ada. <br><br>  Untuk memosisikan snap-in dari jarak jauh adalah ide yang bagus, tetapi ini dapat diimplementasikan dalam lingkaran jaringan yang sangat sempit dengan bandwidth tinggi dan latensi mikroskopis.  Jika tidak, sambil memegang snapshot pada mesin akan ada strategi berbasis giliran. <br><br>  Jadi, Anda perlu memasang snap pada disk lokal.  Tetapi, sebagai aturan, semua ruang pada disk lokal sudah didistribusikan di antara sistem file, dan pada saat yang sama Anda harus berpikir keras bagaimana mengatasi masalah kebuntuan. <br><br>  Arah untuk refleksi, pada prinsipnya, adalah satu: Anda perlu entah bagaimana mengalokasikan ruang dalam sistem file, tetapi bekerja secara langsung dengan perangkat blok.  Solusi untuk masalah ini diimplementasikan dalam kode ruang pengguna, dalam layanan. <br><br>  Ada panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fallocate</a> yang memungkinkan Anda membuat file kosong dengan ukuran yang diinginkan.  Namun, pada kenyataannya, hanya metadata yang dibuat pada sistem file yang menjelaskan lokasi file pada volume.  Dan ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FIEMAP</a> memungkinkan kita untuk mendapatkan peta lokasi blok file. <br><br>  Dan voila: kami membuat file di bawah snap menggunakan fallocate, FIEMAP memberi kami peta lokasi blok file ini, yang dapat kami transfer untuk bekerja di modul veeamsnap kami.  Lebih lanjut, ketika mengakses snapstor, modul membuat permintaan langsung ke perangkat blok di blok yang kita kenal, dan tidak ada deadlock. <br><br>  Namun ada nuansa.  Panggilan sistem fallocate hanya didukung oleh XFS, EXT4, dan BTRFS.  Untuk sistem file lain seperti EXT3, Anda harus menulisnya sepenuhnya untuk mengalokasikan file.  Fungsionalitas dipengaruhi oleh peningkatan waktu untuk menyiapkan snappads, tetapi tidak ada pilihan.  Sekali lagi, Anda harus bisa mengerjakan apa yang ada. <br><br>  Bagaimana jika ioctl FIEMAP juga tidak didukung?  Ini adalah realitas NTFS dan FAT32, di mana bahkan tidak ada dukungan untuk FIBMAP kuno.  Saya harus mengimplementasikan algoritma generik tertentu, yang operasinya tidak bergantung pada fitur-fitur sistem file.  Singkatnya, algoritma ini adalah: <br><br><ol><li>  Layanan membuat file dan mulai menulis pola tertentu. </li><li>  Modul memotong permintaan tulis, memeriksa data yang sedang ditulis. </li><li>  Jika data blok cocok dengan pola yang diberikan, maka blok ditandai sebagai milik snapstop. </li></ol><br>  Ya, sulit, ya, lambat, tetapi lebih baik daripada tidak sama sekali.  Ini digunakan dalam kasus yang jarang terjadi untuk sistem file tanpa dukungan FIEMAP dan FIBMAP. <br><br><h3>  Snapshot Overflow </h3><br>  Alih-alih, tempat yang kami sediakan di bawah snapstore berakhir.  Inti dari masalahnya adalah tidak ada tempat untuk membuang data baru, yang berarti snapshot menjadi tidak dapat digunakan. <br>  Apa yang harus dilakukan <br><br>  Jelas, Anda perlu menambah ukuran snappants.  Berapa banyak  Cara termudah untuk mengatur ukuran snappants adalah dengan menentukan persentase ruang kosong pada volume (seperti yang dilakukan untuk VSS).  Untuk volume 20 TB, 10% akan menjadi 2TB - yang merupakan jumlah yang banyak untuk server yang dibongkar.  Untuk volume 200 GB, 10% adalah 20GB, yang mungkin terlalu sedikit untuk server yang memperbarui datanya secara intensif.  Dan masih ada volume tipis ... <br><br>  Secara umum, hanya administrator sistem server yang dapat mengetahui ukuran optimal dari snap-in yang diperlukan, yaitu, Anda harus membuat orang tersebut berpikir dan memberikan pendapat ahli.  Ini tidak sesuai dengan prinsip "Itu hanya berhasil". <br><br>  Untuk mengatasi masalah ini, kami mengembangkan algoritma stretch snapshot.  Idenya adalah untuk memecah snap menjadi beberapa bagian.  Pada saat yang sama, bagian-bagian baru dibuat setelah pembuatan foto yang diperlukan. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Sekali lagi, singkat algoritme: <br><br><ol><li>  Sebelum membuat snapshot, bagian pertama dari snapshot dibuat dan diberikan ke modul. </li><li>  Ketika snapshot dibuat, porsi akan mulai terisi. </li><li>  Segera setelah setengah dari porsi penuh, permintaan dikirim ke layanan untuk membuat yang baru. </li><li>  Layanan menciptakannya, memberikan data ke modul. </li><li>  Modul mulai mengisi kumpulan berikutnya. </li><li>  Algoritme diulang sampai cadangan selesai, atau sampai kita mencapai batas pada penggunaan ruang disk kosong. </li></ol><br>  Penting untuk dicatat bahwa modul harus memiliki waktu untuk membuat bagian-bagian baru dari snapposts sesuai kebutuhan, jika tidak - meluap, mengatur ulang snapshot dan tanpa cadangan.  Oleh karena itu, pengoperasian algoritma semacam itu hanya dimungkinkan pada sistem file dengan dukungan fallocate, di mana Anda dapat dengan cepat membuat file kosong. <br><br>  Apa yang harus dilakukan dalam kasus lain?  Kami mencoba menebak ukuran yang diperlukan dan membuat keseluruhan snappast sepenuhnya.  Tetapi menurut statistik kami, sebagian besar server Linux sekarang menggunakan EXT4 dan XFS.  EXT3 ditemukan pada mesin yang lebih tua.  Tetapi dalam SLES / openSUSE Anda dapat menemukan BTRFS. <br><br><h3>  Ubah Pelacakan Blok (CBT) </h3><br>  Cadangan tambahan atau diferensial (omong-omong, lobak lobak lebih manis atau tidak, saya sarankan baca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) - tanpa itu, Anda tidak dapat membayangkan produk cadangan dewasa.  Dan agar ini berfungsi, Anda membutuhkan CBT.  Jika seseorang tidak terjawab: CBT memungkinkan Anda melacak perubahan dan menulis ke cadangan, hanya data yang berubah dari cadangan terakhir. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Banyak yang memiliki pengalaman sendiri di bidang ini.  Misalnya, dalam VMware vSphere, fitur ini telah tersedia sejak versi 4 pada 2009.  Di Hyper-V, dukungan diperkenalkan dengan Windows Server 2016, dan untuk mendukung rilis sebelumnya, driver VeeamFCT-nya dikembangkan kembali pada tahun 2012.  Karenanya, untuk modul kami, kami tidak menjadi yang asli dan menggunakan algoritme yang sudah berfungsi. <br>  Tentang cara kerjanya. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  Seluruh volume yang dilacak dipecah menjadi blok-blok.  Modul hanya melacak semua permintaan tulis, menandai blok yang diubah di tabel.  Faktanya, tabel CBT adalah array byte, di mana setiap byte berhubungan dengan blok dan berisi jumlah snapshot yang diubah. <br>  Selama pencadangan, nomor foto direkam dalam metadata cadangan.  Dengan demikian, mengetahui jumlah snapshot saat ini dan yang dari mana backup sebelumnya berhasil dibuat, Anda dapat menghitung peta lokasi blok yang diubah. <br><br>  Ada dua nuansa. <br><br>  Seperti yang saya katakan, satu byte dialokasikan untuk nomor snapshot dalam tabel CBT, yang berarti bahwa panjang maksimum rantai tambahan tidak boleh lebih dari 255. Ketika ambang ini tercapai, tabel diatur ulang dan terjadi pencadangan penuh.  Ini mungkin tampak tidak nyaman, tetapi pada kenyataannya, rantai kenaikan 255 jauh dari solusi terbaik saat membuat rencana cadangan. <br>  Fitur kedua adalah penyimpanan tabel CBT hanya dalam RAM.  Jadi, ketika Anda me-reboot mesin target atau membongkar modul, itu akan diatur ulang, dan sekali lagi, Anda harus membuat cadangan penuh.  Solusi semacam itu memungkinkan untuk tidak memecahkan masalah start-up modul saat startup sistem.  Selain itu, tidak perlu menyimpan tabel CBT saat Anda mematikan sistem. <br><br><h3>  Masalah kinerja </h3><br>  Cadangan selalu menjadi beban yang baik pada IO peralatan Anda.  Jika sudah ada cukup tugas aktif di dalamnya, maka proses pencadangan dapat mengubah sistem Anda menjadi semacam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemalasan</a> . <br>  Mari kita lihat mengapa. <br><br>  Bayangkan server secara linear menulis beberapa data.  Kecepatan perekaman dalam hal ini adalah maksimum, semua penundaan diminimalkan, kinerja cenderung ke maksimum.  Sekarang kami menambahkan proses pencadangan di sini, yang pada setiap penulisan masih perlu menyelesaikan algoritme Copy-on-Write, dan ini merupakan operasi baca tambahan dengan penulisan selanjutnya.  Dan jangan lupa bahwa untuk cadangan Anda masih perlu membaca data dari volume yang sama.  Singkatnya, akses linear Anda yang indah berubah menjadi akses acak tanpa ampun dengan semua konsekuensinya. <br><br>  Kami jelas perlu melakukan sesuatu dengan ini, dan kami menerapkan saluran pipa untuk memproses permintaan tidak satu per satu, tetapi di seluruh bundel.  Ini berfungsi seperti ini. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Saat mencegat permintaan, mereka ditempatkan dalam antrian, di mana aliran khusus membawanya dalam porsi.  Saat ini, permintaan Kontrak Karya dibuat, yang juga diproses dalam batch.  Saat memproses permintaan Kontrak Karya, pertama semua operasi baca dilakukan untuk seluruh bagian, setelah itu operasi tulis dilakukan.  Hanya setelah pemrosesan seluruh bagian dari permintaan KK diselesaikan, permintaan yang dicegat dieksekusi.  Konveyor semacam itu menyediakan akses ke disk dalam potongan besar data, yang meminimalkan kehilangan waktu. <br><br><h3>  Pelambatan </h3><br>  Sudah pada tahap debugging, nuansa lain muncul.  Selama pencadangan, sistem menjadi tidak responsif, mis.  permintaan I / O sistem mulai berjalan dengan penundaan yang lama.  Tetapi, permintaan untuk membaca data dari snapshot dilakukan dengan kecepatan mendekati maksimum. <br>  Saya harus mencekik proses pencadangan sedikit dengan menerapkan mekanisme pelambatan.  Untuk melakukan ini, proses membaca dari gambar snapshot dimasukkan ke dalam keadaan menunggu jika antrian permintaan dicegat tidak kosong.  Diharapkan, sistem menjadi hidup. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Akibatnya, jika beban pada sistem I / O meningkat tajam, maka proses pembacaan dari foto akan menunggu.  Di sini kami memutuskan untuk dipandu oleh prinsip bahwa lebih baik kita mengakhiri cadangan dengan kesalahan daripada mengganggu server. <br><br><h3>  Jalan buntu </h3><br>  Saya pikir kita perlu menjelaskan secara lebih rinci apa itu. <br><br>  Sudah pada tahap pengujian, kami mulai menghadapi situasi-situasi sistem yang lengkap dengan diagnosis tujuh masalah - satu reset. <br><br>  Mereka mulai mengerti.  Ternyata situasi ini dapat diamati jika, misalnya, Anda membuat snapshot dari perangkat blok di mana volume LVM berada, dan menempatkan snap-shot pada volume LVM yang sama.  Biarkan saya mengingatkan Anda bahwa LVM menggunakan modul kernel mapper perangkat. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  Dalam situasi ini, ketika mencegat permintaan tulis, modul, menyalin data ke snap-in, akan mengirim permintaan menulis ke volume LVM.  Device mapper akan mengarahkan permintaan ini ke perangkat blokir.  Permintaan dari device mapper akan kembali dicegat oleh modul.  Tetapi permintaan baru tidak dapat diproses sampai yang sebelumnya telah diproses.  Akibatnya, pemrosesan permintaan diblokir, Anda disambut oleh jalan buntu. <br><br>  Untuk mencegah situasi ini, modul kernel itu sendiri memberikan batas waktu untuk operasi menyalin data ke snap-in.  Ini memungkinkan Anda untuk mendeteksi cadangan macet dan macet.  Logikanya di sini sama: lebih baik tidak membuat cadangan daripada menangguhkan server. <br><br><h3>  Database round robin </h3><br>  Ini sudah merupakan masalah yang dilemparkan oleh pengguna setelah rilis versi pertama. <br>  Ternyata ada layanan seperti itu yang hanya terlibat dalam terus-menerus menimpa blok yang sama.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang mencolok adalah layanan pemantauan, yang terus-menerus menghasilkan data tentang keadaan sistem dan menimpanya dalam lingkaran. </font><font style="vertical-align: inherit;">Untuk tugas-tugas seperti itu gunakan basis data siklik khusus ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata dengan cadangan basis-basis seperti itu, snapshot dijamin akan meluap. </font><font style="vertical-align: inherit;">Dalam studi rinci tentang masalah ini, kami menemukan kelemahan dalam implementasi algoritma CoW. </font><font style="vertical-align: inherit;">Jika blok yang sama ditimpa, maka data disalin ke snap-in setiap waktu. </font><font style="vertical-align: inherit;">Hasil: duplikasi data dalam sekejap. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara alami, kami mengubah algoritme. </font><font style="vertical-align: inherit;">Sekarang volume dibagi menjadi blok, dan data disalin ke blok jepret. </font><font style="vertical-align: inherit;">Jika blok sudah disalin sekali, maka proses ini tidak berulang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pilihan ukuran blok </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika snapstrap dipecah menjadi balok, muncul pertanyaan: apa, sebenarnya, ukuran balok yang harus dibuat untuk memecahkan snapplug? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya ada dua. Jika blok dibuat besar, lebih mudah bagi mereka untuk beroperasi, tetapi jika setidaknya satu sektor berubah, Anda harus mengirim seluruh blok ke rig dan, sebagai akibatnya, kemungkinan kelebihan pengisian rig meningkat. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, semakin kecil ukuran blok, semakin besar persentase data berguna yang dikirim ke snapstore, tetapi bagaimana hal itu akan mencapai kinerja? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka mencari kebenaran secara empiris dan menghasilkan 16KiB. Perhatikan juga bahwa Windows VSS juga menggunakan 16 blok KiB.</font></font><br><br><h2>  Alih-alih sebuah kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu saja untuk saat ini. </font><font style="vertical-align: inherit;">Saya akan meninggalkan banyak masalah lain, yang tidak kalah menarik, seperti ketergantungan pada versi kernel, pilihan opsi distribusi modul, kompatibilitas kABI, bekerja dalam kondisi backport, dll. </font><font style="vertical-align: inherit;">Artikel itu ternyata sangat banyak, jadi saya memutuskan untuk memikirkan masalah yang paling menarik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami sedang bersiap untuk rilis versi 3.0, kode modul ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan siapa pun dapat menggunakannya di bawah lisensi GPL.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430770/">https://habr.com/ru/post/id430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430754/index.html">Tambahkan kedalaman ke sprite 2D menggunakan peta normal yang digambar tangan</a></li>
<li><a href="../id430756/index.html">Membuat WX-Mouse di Nova Slider 600</a></li>
<li><a href="../id430762/index.html">Bagaimana memilih UPS untuk mengoptimalkan biaya</a></li>
<li><a href="../id430766/index.html">Ini Semua Tentang Agile 1: Mitos Agenda Populer</a></li>
<li><a href="../id430768/index.html">Wawancara dengan pencipta ADOM Thomas Biscap</a></li>
<li><a href="../id430774/index.html">Apakah Anda siap untuk AI di papan reklame?</a></li>
<li><a href="../id430776/index.html">Membuat IP adalah satu-satunya cara</a></li>
<li><a href="../id430778/index.html">3DEXPERIENCE proses desain sistem kelistrikan end-to-end</a></li>
<li><a href="../id430780/index.html">Sequence-to-Sequence Bagian 1 Model</a></li>
<li><a href="../id430782/index.html">Berapa banyak programmer yang Anda butuhkan untuk mendukung kode yang ditulis sebelumnya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>