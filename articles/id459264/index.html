<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎒 🖱️ 👽 Keluar dari jaringan Tarantool. Sinkronisasi simpul saat memfilter lalu lintas 💃🏾 🙅🏽 ⚗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Variti berspesialisasi dalam perlindungan terhadap serangan bot dan DDoS, dan juga melakukan pengujian tegangan dan beban. Karena kami bekerja sebagai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keluar dari jaringan Tarantool. Sinkronisasi simpul saat memfilter lalu lintas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/variti/blog/459264/"><img src="https://habrastorage.org/getpro/habr/post_images/479/4d3/c95/4794d3c95e7b9d2fe9155a3083f674eb.jpg" alt="gambar"><br><br>  <i>Variti berspesialisasi dalam perlindungan terhadap serangan bot dan DDoS, dan juga melakukan pengujian tegangan dan beban.</i>  <i>Karena kami bekerja sebagai layanan internasional, sangat penting bagi kami untuk memastikan pertukaran informasi yang tidak terputus antara server dan cluster secara real time.</i>  <i>Pada konferensi Saint HighLoad ++ 2019, pengembang Variti Anton Barabanov mengatakan bagaimana kami menggunakan UDP dan Tarantool, mengapa kami mengambil banyak, dan bagaimana kami harus menulis ulang modul Tarantool dari Lua ke C.</i> <br><br>  Anda juga dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">abstrak</a> laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melalui</a> tautan, dan melihat video di bawah ini di spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Laporkan video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/R0-POaXC0lI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Ketika kami mulai membuat layanan penyaringan lalu lintas, kami segera memutuskan untuk tidak berurusan dengan transit IP, tetapi untuk melindungi HTTP, API, dan layanan game.  Dengan demikian, kami menghentikan lalu lintas di tingkat L7 dalam protokol TCP dan meneruskannya.  Perlindungan pada L3 &amp; 4 pada saat yang sama terjadi secara otomatis.  Diagram di bawah ini menunjukkan diagram layanan: permintaan dari orang-orang melalui sebuah cluster, yaitu, server dan peralatan jaringan, dan bot (ditampilkan sebagai hantu) difilter. <br><br><img src="https://habrastorage.org/webt/g0/eg/qd/g0egqdye_eghswvgjsdpkek9cda.jpeg"><br><br>  Untuk memfilter, perlu untuk memecah lalu lintas menjadi permintaan yang terpisah, menganalisis sesi secara akurat dan cepat, dan karena kita tidak memblokir berdasarkan alamat IP, tentukan bot dan orang-orang di dalam koneksi dari alamat IP yang sama. <a name="habracut"></a><br><br><h4>  Apa yang terjadi di dalam cluster </h4><br>  Di dalam cluster, kami memiliki node filter independen, yaitu, setiap node bekerja sendiri dan hanya dengan sepotong lalu lintas sendiri.  Lalu lintas didistribusikan secara acak di antara node: jika, misalnya, 10 koneksi diterima dari satu pengguna, maka mereka semua berbeda di server yang berbeda. <br><br>  Kami memiliki persyaratan kinerja yang sangat ketat karena pelanggan kami berada di berbagai negara.  Dan jika, misalnya, pengguna dari Swiss mengunjungi situs Prancis, maka ia sudah dihadapkan dengan 15 milidetik keterlambatan jaringan karena peningkatan rute lalu lintas.  Oleh karena itu, kami tidak berhak menambahkan 15-20 milidetik lagi di dalam pusat pemrosesan kami - permintaan akan berlangsung lama sekali.  Selain itu, jika kami memproses setiap permintaan HTTP selama 15-20 milidetik, maka serangan sederhana sebesar 20 ribu RPS akan menambah seluruh cluster.  Ini, tentu saja, tidak dapat diterima. <br><br>  Persyaratan lain bagi kami adalah tidak hanya melacak permintaan, tetapi juga memahami konteksnya.  Misalkan pengguna membuka halaman web dan mengirimkan permintaan garis miring.  Setelah itu, halaman dimuat, dan jika itu HTTP / 1.1, maka browser membuka 10 koneksi ke backend dan dalam 10 stream permintaan statika dan dinamika, buat permintaan dan subqueries ajax.  Jika, alih-alih membuat proxy subquery, dalam proses mengembalikan halaman, Anda mulai berinteraksi dengan browser dan mencoba memberikannya, katakanlah, JS Challenge untuk subquery, maka kemungkinan besar Anda akan merusak halaman tersebut.  Pada permintaan pertama, Anda dapat memberikan CAPTCHA (meskipun ini buruk) atau tantangan JS, melakukan pengalihan, dan kemudian browser apa pun akan memproses semuanya dengan benar.  Setelah pengujian, perlu untuk menyebarluaskan informasi tentang semua cluster bahwa sesi tersebut sah.  Jika tidak ada pertukaran informasi antar cluster, maka node lain akan menerima sesi dari tengah dan tidak akan tahu apakah akan melewatkannya atau tidak. <br><br>  Penting juga untuk merespons dengan cepat semua lonjakan beban dan perubahan lalu lintas.  Jika sesuatu melompat pada satu simpul, maka, setelah 50-100 milidetik, lompatan akan terjadi pada semua simpul lainnya.  Oleh karena itu, lebih baik jika node tahu tentang perubahan sebelumnya dan mengatur parameter perlindungan terlebih dahulu sehingga tidak ada lompatan terjadi pada semua node lainnya. <br>  Layanan tambahan untuk melindungi dari bot adalah layanan pasca-markup: kami menempatkan piksel di situs, menulis informasi bot / orang dan mengirim data ini melalui API.  Putusan-putusan ini harus disimpan di suatu tempat.  Artinya, jika sebelumnya kita berbicara tentang sinkronisasi dalam sebuah cluster, sekarang kita juga menambahkan sinkronisasi informasi antar cluster.  Di bawah ini kami menunjukkan skema layanan di tingkat L7. <br><br><img src="https://habrastorage.org/webt/_t/lj/ah/_tljahe28yfpufxw6suxf9ay14y.jpeg"><br><br><h4>  Antar cluster </h4><br>  Setelah kami membuat cluster, kami mulai meningkatkan skala.  Kami bekerja melalui siaran BGP, yaitu, subnet kami diumumkan dari semua cluster dan lalu lintas sampai ke yang terdekat.  Sederhananya, permintaan dikirim dari Perancis ke sebuah cluster di Frankfurt, dan dari St. Petersburg ke sebuah cluster di Moskow.  Cluster harus independen.  Aliran jaringan diizinkan independen. <br><br>  Mengapa ini penting?  Misalkan seseorang mengendarai mobil, bekerja dengan situs web dari internet seluler dan melintasi Rubicon tertentu, setelah itu lalu lintas tiba-tiba beralih ke kluster lain.  Atau kasus lain: rute lalu lintas dibangun kembali karena di suatu tempat saklar atau router terbakar, sesuatu jatuh, segmen jaringan terputus.  Dalam hal ini, kami memberikan informasi yang memadai kepada browser (misalnya, dalam cookie) sehingga ketika beralih ke cluster lain, dimungkinkan untuk menginformasikan parameter yang diperlukan tentang tes yang lulus atau gagal. <br>  Selain itu, Anda harus menyinkronkan mode perlindungan antar kluster.  Ini penting dalam kasus serangan volume rendah, yang paling sering dilakukan di bawah naungan banjir.  Karena serangan berjalan secara paralel, orang berpikir bahwa situs mereka menghancurkan banjir dan tidak melihat serangan volume rendah.  Untuk kasus ketika volume rendah datang ke satu cluster, dan banjir ke yang lain, sinkronisasi mode perlindungan diperlukan. <br><br>  Dan seperti yang telah disebutkan, kami mensinkronkan antara kluster dengan putusan yang mengakumulasi dan diberikan oleh API.  Dalam hal ini, mungkin ada banyak putusan dan harus disinkronkan dengan andal.  Dalam mode perlindungan, Anda bisa kehilangan sesuatu di dalam cluster, tetapi tidak di antara cluster. <br><br>  Perlu dicatat bahwa ada latensi besar antara cluster: dalam kasus Moskow dan Frankfurt, ini adalah 20 milidetik.  Permintaan sinkron tidak dapat dibuat di sini, semua interaksi harus dilakukan dalam mode asinkron. <br><br>  Di bawah ini kami menunjukkan interaksi antara cluster.  M, l, p adalah beberapa parameter teknis untuk pertukaran.  U1, u2 adalah markup pengguna sebagai tidak sah dan sah. <br><br><img src="https://habrastorage.org/webt/a1/xl/si/a1xlsi20avhzuiv_s1uljdmubic.jpeg"><br><br><h4>  Interaksi internal antar node </h4><br>  Awalnya, ketika kami membuat layanan, pemfilteran di level L7 dimulai hanya pada satu simpul.  Ini bekerja dengan baik untuk dua klien, tetapi tidak lebih.  Saat melakukan penskalaan, kami ingin mencapai respons maksimum dan latensi minimum. <br><br>  Penting untuk meminimalkan sumber daya CPU yang dihabiskan untuk memproses paket, sehingga interaksi melalui, misalnya, HTTP tidak akan sesuai.  Itu juga perlu untuk memastikan konsumsi overhead minimum tidak hanya sumber daya komputasi, tetapi juga tingkat paket.  Namun demikian, kita berbicara tentang penyaringan serangan, dan ini adalah situasi di mana jelas tidak ada kinerja yang cukup.  Biasanya, ketika membangun proyek web, x3 atau x4 sudah cukup untuk memuat, tetapi kami selalu memiliki x1, karena serangan skala besar selalu bisa datang. <br><br>  Persyaratan lain untuk antarmuka interaksi adalah keberadaan tempat di mana kita akan menulis informasi dan dari mana kita dapat menghitung keadaan kita sekarang.  Bukan rahasia lagi bahwa C ++ sering digunakan untuk mengembangkan sistem penyaringan.  Namun sayangnya, program yang ditulis dalam C ++ terkadang macet.  Terkadang program seperti itu perlu di-restart untuk memperbarui, atau, misalnya, karena konfigurasi tidak dibaca kembali.  Dan jika kita me-restart node yang sedang diserang, maka kita perlu mengambil suatu konteks di mana node ini ada.  Artinya, layanan tidak boleh stateless, harus diingat bahwa ada sejumlah orang yang kami blokir, yang kami periksa.  Harus ada komunikasi internal yang sama sehingga layanan dapat menerima serangkaian informasi utama.  Kami memiliki pemikiran untuk meletakkan di dekat database tertentu, misalnya, SQLite, tetapi kami dengan cepat membuang solusi seperti itu, karena aneh untuk menulis Input-Output pada setiap server, ini akan bekerja dengan buruk dalam memori. <br><br>  Faktanya, kami bekerja hanya dengan tiga operasi.  Fungsi pertama adalah "kirim" ke semua node.  Ini berlaku, misalnya, untuk pesan tentang sinkronisasi beban saat ini: setiap node harus mengetahui beban total pada sumber daya dalam gugus untuk melacak puncak.  Operasi kedua adalah untuk "menyelamatkan", ini menyangkut putusan verifikasi.  Dan operasi ketiga adalah kombinasi "kirim ke semua orang" dan "simpan".  Di sini kita berbicara tentang perubahan status pesan yang kami kirim ke semua node dan kemudian simpan untuk dapat mengurangi.  Di bawah ini adalah skema interaksi yang dihasilkan, di mana kita perlu menambahkan parameter untuk disimpan. <br><br><img src="https://habrastorage.org/webt/s7/__/8c/s7__8c-cnmitihkranlrso0ukza.jpeg"><br><br><h4>  Opsi dan Hasil </h4><br>  Pilihan apa untuk melestarikan vonis yang telah kita lihat?  Pertama, kami memikirkan klasik, RabbitMQ, RedisMQ dan layanan berbasis TCP kami sendiri.  Kami menolak keputusan ini karena mereka bekerja lambat.  TCP yang sama menambahkan x2 ke tingkat paket.  Selain itu, jika kita mengirim pesan dari satu simpul ke simpul lainnya, maka kita perlu memiliki banyak simpul pengirim, atau simpul ini dapat meracuni 1/16 dari pesan-pesan yang dapat dikirim oleh 16 mesin.  Jelas bahwa ini tidak dapat diterima. <br><br>  Sebagai hasilnya, kami mengambil multicast UDP, karena dalam hal ini pusat pengiriman adalah peralatan jaringan, yang tidak terbatas dalam kinerja dan memungkinkan Anda untuk sepenuhnya menyelesaikan masalah dengan kecepatan pengiriman dan penerimaan.  Jelas bahwa dalam kasus UDP, kami tidak berpikir tentang format teks, tetapi mengirim data biner. <br><br>  Selain itu, kami segera menambahkan pengemasan dan basis data.  Kami mengambil Tarantool, karena, pertama, ketiga pendiri perusahaan memiliki pengalaman bekerja dengan database ini, dan kedua, sefleksibel mungkin, yaitu, juga semacam layanan aplikasi.  Selain itu, Tarantool memiliki CAPI, dan kemampuan untuk menulis dalam C adalah masalah prinsip bagi kami karena perlindungan maksimum diperlukan untuk melindungi terhadap DDoS.  Tidak ada bahasa yang ditafsirkan dapat memberikan kinerja yang cukup, tidak seperti C. <br><br>  Dalam diagram di bawah ini, kami menambahkan database di dalam cluster, di mana status untuk komunikasi internal disimpan. <br><br><img src="https://habrastorage.org/webt/k3/py/60/k3py60c1-_z4uirabzit7-otlri.jpeg"><br><br><h4>  Tambahkan basis data </h4><br>  Dalam database, kami menyimpan negara dalam bentuk log panggilan.  Ketika kami menemukan cara menyimpan informasi, ada dua opsi.  Dimungkinkan untuk menyimpan beberapa keadaan dengan pembaruan dan perubahan yang konstan, tetapi agak sulit untuk diterapkan.  Karena itu, kami menggunakan pendekatan yang berbeda. <br><br>  Faktanya adalah bahwa struktur data yang dikirim melalui UDP disatukan: ada waktu, semacam kode, tiga atau empat bidang data.  Jadi kami mulai menulis struktur ini di ruang Tarantool dan menambahkan catatan TTL di sana, yang membuatnya jelas bahwa strukturnya sudah usang dan perlu dihapus.  Dengan demikian, log pesan diakumulasikan di Tarantool, yang kami hapus dengan waktu yang ditentukan.  Untuk menghapus data lama, kami awalnya mengambil kadaluwarsa.  Selanjutnya, kami harus meninggalkannya, karena itu menimbulkan masalah tertentu, yang akan kami bahas di bawah ini.  Sejauh ini, skema: di atasnya dua database ditambahkan ke struktur kami. <br><br><img src="https://habrastorage.org/webt/p-/li/-m/p-li-mkvdsa7ks9bxqz00ywlrey.jpeg"><br><br>  Seperti yang telah kami sebutkan, selain menyimpan status kluster, juga perlu untuk menyinkronkan putusan.  Putusan kami selaraskan interluster.  Oleh karena itu, perlu untuk menambahkan instalasi tambahan Tarantool.  Akan aneh untuk menggunakan solusi lain, karena Tarantool sudah ada dan sangat ideal untuk layanan kami.  Dalam instalasi baru, kami mulai menulis vonis dan mereplikasi mereka dengan cluster lain.  Dalam hal ini, kami menggunakan bukan master / slave, tetapi master / master.  Sekarang di Tarantool hanya ada master / master yang tidak sinkron, yang bagi banyak kasus tidak cocok, tetapi bagi kami model ini optimal.  Dengan latensi minimal antar cluster, replikasi sinkron akan menghalangi, sementara replikasi asinkron tidak menyebabkan masalah. <br><br><h4>  Masalahnya </h4><br>  Tapi kami punya banyak masalah.  <i>Blok kompleksitas pertama terkait dengan UDP</i> : bukan rahasia bahwa protokol dapat mengalahkan dan kehilangan paket.  Kami memecahkan masalah ini dengan metode burung unta, yaitu, kami hanya menyembunyikan kepala kami di pasir.  Namun demikian, kerusakan paket dan penataan kembali tempat mereka tidak mungkin terjadi pada kami, karena komunikasi terjadi dalam kerangka kerja sakelar tunggal, dan tidak ada koneksi yang tidak stabil dan peralatan jaringan yang tidak stabil. <br><br>  Mungkin ada masalah packet loss jika mesin macet, sebuah Input-Output terjadi di suatu tempat, atau sebuah node kelebihan beban.  Jika hang seperti itu terjadi untuk waktu yang singkat, katakanlah, 50 milidetik, maka ini mengerikan, tetapi diselesaikan dengan peningkatan antrian sysctl.  Yaitu, kita ambil sysctl, konfigurasikan ukuran antrian dan dapatkan buffer di mana semuanya terletak sampai node mulai bekerja kembali.  Jika pembekuan yang lebih lama terjadi, maka masalahnya bukan kehilangan konektivitas, tetapi bagian dari lalu lintas yang menuju ke node.  Sejauh ini, kami tidak punya kasus seperti itu. <br><br>  <i>Masalah replikasi asinkron Tarantool</i> jauh lebih kompleks.  Awalnya, kami tidak mengambil master / master, tetapi model yang lebih tradisional untuk mengoperasikan master / slave.  Dan semuanya bekerja persis sampai budak mengambil alih beban master untuk waktu yang lama.  Akibatnya, kedaluwarsa bekerja dan menghapus data pada master, tetapi pada slave tidak.  Karena itu, ketika kami beralih beberapa kali dari master ke slave dan back, begitu banyak data terakumulasi pada slave sehingga pada titik tertentu semuanya rusak.  Jadi untuk toleransi kesalahan penuh, saya harus beralih ke replikasi master / master asynchronous. <br><br>  Dan di sini lagi muncul kesulitan.  Pertama, kunci dapat berpotongan antara replika yang berbeda.  Misalkan, di dalam cluster, kami menulis data ke satu master, pada saat koneksi terputus, kami menulis semuanya ke master kedua, dan setelah kami melakukan replikasi asinkron, ternyata kunci primer yang sama dalam ruang dan replikasi hancur. <br><br>  Kami memecahkan masalah ini hanya: kami mengambil model di mana kunci utama harus berisi nama simpul Tarantool yang kami tulis.  Karena ini, konflik tidak lagi muncul, tetapi situasi menjadi mungkin ketika data pengguna digandakan.  Ini adalah kasus yang sangat langka, jadi kami kembali mengabaikannya.  Jika duplikasi sering terjadi, maka Tarantool memiliki banyak indeks berbeda, sehingga Anda selalu dapat melakukan deduplikasi. <br><br>  Masalah lain menyangkut pelestarian putusan dan muncul ketika data yang direkam pada satu master belum muncul pada yang lain, dan permintaan sudah sampai pada master pertama.  Sejujurnya, kami belum menyelesaikan masalah ini dan hanya menunda vonis.  Jika ini tidak dapat diterima, maka kami akan mengatur semacam dorongan tentang kesiapan data.  Itulah cara kami menangani replikasi master / master dan masalahnya. <br><br>  <i>Ada blok masalah yang terkait langsung dengan Tarantool</i> , driver dan modul kedaluwarsanya.  Beberapa waktu setelah peluncuran, serangan mulai datang kepada kami setiap hari, masing-masing, jumlah pesan yang kami simpan dalam basis data untuk sinkronisasi dan penyimpanan konteks telah menjadi sangat besar.  Dan selama pengupasan, begitu banyak data mulai dihapus sehingga pengumpul sampah berhenti mengatasinya.  Kami memecahkan masalah ini dengan menulis dalam C modul kedaluwarsa kita sendiri yang disebut IExpire. <br><br>  Namun, dengan expirationd ada satu kesulitan lagi yang belum kita atasi dan itu terletak pada kenyataan bahwa expirationd hanya bekerja pada satu master.  Dan jika node kedaluwarsa jatuh, cluster akan kehilangan fungsionalitas kritis.  Misalkan kita membersihkan semua data yang lebih lama dari satu jam - jelas bahwa jika sebuah simpul terletak, katakanlah, lima jam, maka jumlah data akan x5 seperti biasanya.  Dan jika pada saat itu serangan besar datang, yaitu, dua kasus buruk bertepatan, maka cluster akan jatuh.  Kami belum tahu bagaimana menghadapi ini. <br><br>  Akhirnya, masih ada kesulitan dengan driver Tarantool untuk C. Ketika kami mogok layanan (misalnya, karena kondisi balapan), butuh waktu lama untuk menemukan alasan dan men-debug.  Karena itu, kami baru saja menulis driver Tarantool kami.  Kami memerlukan waktu lima hari untuk mengimplementasikan protokol bersama dengan pengujian, debugging, dan peluncuran produksi, tetapi kami sudah memiliki kode kami sendiri untuk bekerja dengan jaringan. <br><br><h4>  Masalah di luar </h4><br>  Ingat bahwa kita sudah memiliki replikasi Tarantool yang siap, kita sudah tahu bagaimana cara menyinkronkan putusan, tetapi belum ada infrastruktur untuk mengirimkan pesan tentang serangan atau masalah antar cluster. <br>  Kami memiliki banyak pemikiran berbeda tentang infrastruktur, termasuk pemikiran untuk menulis layanan TCP kami sendiri.  Tapi masih ada modul Antrian Tarantool dari tim Tarantool.  Selain itu, kami sudah memiliki Tarantool dengan replikasi lintas-cluster, "lubang" diputar, yaitu, tidak perlu pergi ke admin dan meminta untuk membuka port atau mengarahkan lalu lintas.  Sekali lagi, integrasi ke dalam penyaringan perangkat lunak sudah siap. <br><br>  Ada kesulitan dengan simpul host.  Misalkan ada n node independen di dalam sebuah cluster dan Anda harus memilih yang akan berinteraksi dengan antrian tulis.  Karena kalau tidak 16 pesan akan dikirim atau 16 kali pesan yang sama akan dikurangi dari antrian.  Kami memecahkan masalah ini secara sederhana: kami mendaftarkan simpul yang bertanggung jawab di ruang Tarantool, dan jika simpul tersebut terbakar, maka kami cukup mengubah ruang tersebut jika kami tidak lupa.  Tetapi jika kita lupa, maka ini adalah masalah yang juga ingin kita selesaikan di masa depan. <br><br>  Di bawah ini adalah diagram cluster yang sudah terinci dengan antarmuka interaksi. <br><br><img src="https://habrastorage.org/webt/8f/f3/9o/8ff39og9opl3e4rjwydmtpdsola.jpeg"><br><br><h4>  Apa yang ingin saya tingkatkan dan tambahkan </h4><br>  Pertama, kami ingin memposting di IExpire open source.  Tampaknya bagi kami bahwa ini adalah modul yang berguna, karena memungkinkan Anda untuk melakukan semuanya sama seperti kadaluwarsa, tetapi dengan overhead hampir nol.  Di sana Anda harus menambahkan indeks penyortiran untuk menghapus hanya tupel tertua.  Sejauh ini, kami belum melakukan ini, karena operasi utama di Tarantool bagi kami adalah "menulis", dan indeks tambahan akan menyebabkan beban tambahan karena dukungannya.  Kami juga ingin menulis ulang sebagian besar metode di CAPI untuk menghindari melipat database. <br><br>  Pertanyaannya tetap dengan pilihan master logis, tetapi tampaknya masalah ini benar-benar mustahil untuk dipecahkan.  Yaitu, jika node dengan expirationd jatuh, tetap hanya untuk memilih secara manual node lain dan menjalankan expirationd di atasnya.  Ini tidak mungkin terjadi secara otomatis, karena replikasi asinkron.  Meskipun kami mungkin akan berkonsultasi tentang ini dengan tim Tarantool. <br><br>  Jika terjadi pertumbuhan cluster secara eksponensial, kami juga harus meminta bantuan tim Tarantool.  Faktanya adalah bahwa replikasi semua-untuk-semua digunakan untuk Antrian Tarantool dan penghematan putusan interluster.  Ini bekerja dengan baik, sementara ada tiga kelompok, misalnya, tetapi ketika ada 100 dari mereka, jumlah koneksi yang perlu dipantau akan sangat besar dan sesuatu akan terus-menerus terputus.  Kedua, bukan fakta bahwa Tarantool dapat menahan beban seperti itu. <br><br><h4>  Kesimpulan </h4><br>  Kesimpulan pertama menyangkut UDP multicast dan Tarantool.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast tidak perlu takut akan hal itu, penggunaannya di dalam cluster baik, benar dan cepat. Ada banyak kasus ketika ada sinkronisasi konstan negara, dan setelah 50 milidetik tidak peduli apa yang terjadi sebelumnya. Dan dalam hal ini, kemungkinan besar, hilangnya satu negara tidak akan menjadi masalah. Jadi menggunakan UDP multicast dibenarkan, karena Anda tidak membatasi kinerja dan mendapatkan tingkat paket yang optimal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin kedua adalah Tarantool. Jika Anda memiliki layanan saat bepergian, php dan sebagainya, maka kemungkinan besar Tarantool berlaku sebagaimana mestinya. Tetapi jika Anda memiliki banyak beban, Anda akan memerlukan file. Tapi jujur ​​saja, dalam hal ini, file diperlukan sama sekali untuk semuanya: baik untuk Oracle dan untuk PostgeSQL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, ada pendapat bahwa Anda tidak perlu menemukan kembali roda, dan jika Anda memiliki tim kecil, maka Anda harus mengambil solusi yang sudah jadi: Redis untuk sinkronisasi, standar go, python, dan sebagainya. </font><font style="vertical-align: inherit;">Ini tidak benar. </font><font style="vertical-align: inherit;">Jika Anda yakin bahwa Anda memerlukan solusi baru, jika Anda bekerja dengan open source, menemukan bahwa tidak ada yang cocok untuk Anda, atau Anda tahu sebelumnya bahwa tidak ada gunanya mencoba, maka melihat keputusan Anda bermanfaat. </font><font style="vertical-align: inherit;">Percakapan lain yang penting adalah berhenti tepat waktu. </font><font style="vertical-align: inherit;">Artinya, Anda tidak perlu menulis Tarantool Anda, Anda tidak perlu mengimplementasikan perpesanan Anda, dan jika Anda hanya membutuhkan broker, bawa Redis dan Anda akan senang.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459264/">https://habr.com/ru/post/id459264/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459252/index.html">Minggu Keamanan 28: meretas rumah pintar</a></li>
<li><a href="../id459254/index.html">Bom pos yang lebih baik</a></li>
<li><a href="../id459256/index.html">Bagaimana kami mengoptimalkan Rumah Sakit Tema kami untuk platform yang berbeda</a></li>
<li><a href="../id459258/index.html">14.000 mil tidak terhubung</a></li>
<li><a href="../id459262/index.html">Pensiun pada 22</a></li>
<li><a href="../id459272/index.html">Menulis API untuk komponen Bereaksi, bagian 1: jangan membuat alat peraga yang bertentangan</a></li>
<li><a href="../id459274/index.html">Kerentanan Kunci Layar di Astra Linux Edisi Khusus (Smolensk)</a></li>
<li><a href="../id459276/index.html">Epic fail resistance 2 atau mengapa Anda tidak boleh terlibat dalam privasi dengan plugin FireFox</a></li>
<li><a href="../id459280/index.html">Mengapa pengembang suka membangun aplikasi asli?</a></li>
<li><a href="../id459284/index.html">Pengantar Singkat Strategi Produk Dan Prioritas Fitur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>