<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍👨 👩🏿‍🍳 🚩 Dez anos de programação em Erlang 🖐🏻 👍🏾 👎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entrei para a comunidade Erlang há cerca de 10 anos, no meio da primeira fase do hype. Fomos informados de que Erlang é o futuro da concorrência e da ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dez anos de programação em Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460115/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/c35/07e/d08c3507ef04c305f0934e703b35bf53.png"></div><br>  Entrei para a comunidade Erlang há cerca de 10 anos, no meio da primeira fase do hype.  Fomos informados de que Erlang é o futuro da concorrência e da concorrência.  Implementá-los nesse idioma é o mais fácil e rápido, e você ainda recebe distribuição gratuita.  Naquela época, o futuro parecia inacreditável.  A máquina virtual recebeu recentemente o suporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SMP</a> , mas para realmente usar todos os processadores, era necessário executar várias máquinas virtuais no mesmo computador. <br><br>  Eu quero refletir sobre a década passada.  Neste artigo, falarei sobre as fases do hype em relação a Erlang, sobre a <i>escada de idéias</i> na linguagem e sobre seu possível impacto na distribuição da linguagem, sobre as mudanças pelas quais passei nesses 10 anos.  Concluindo, compartilharei meus pensamentos sobre o que Erlang ainda tem que trazer para a comunidade de programadores como um todo. <br><a name="habracut"></a><br><h3>  Fase de campanha publicitária </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ciclo de hype</a> consiste nas fases do ciclo de vida de um produto ou tecnologia.  Este é um conceito de marketing, não científico, mas muitas vezes ajuda a descrever a essência do que está acontecendo.  O que mais me interessa é <i>a fase do hype</i> , uma espécie de corrida do ouro que cobre a comunidade de programadores.  Talvez você tenha se deparado com isso mais de uma vez, e todas essas fases estejam conectadas a algum aplicativo matador que todos correm para usar. <br><br>  Os exemplos imediatamente vêm à mente são Ruby on Rails, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um mecanismo de blog em 15 minutos</a> (a frase <i>“Veja tudo o que eu não faço!”</i> Ainda <i>é</i> engraçado) ou Vá com o Kubernetes (eles trabalharam juntos antes disso, e houve um aumento direto).  Isso inclui Elixir e Phoenix. <br><br>  Durante a fase de campanha publicitária, há um incrível fluxo de recém-chegados que querem ver o motivo de toda essa confusão.  Alguém permanece, a maioria sai.  Você pode ficar por meses ou anos, em casos raros, encontra um lar por décadas.  No entanto, a grande maioria é um fluxo constante de pessoas em série que saltam de tecnologia em tecnologia, procurando oportunidades para se beneficiarem do fato de serem as primeiras a usar uma estrutura, linguagem ou kit de ferramentas. <br><br>  Então, na maioria das vezes, você precisa criar um "aplicativo matador" real, e as pessoas chegarão ao seu ecossistema.  O aplicativo matador gera excitação.  Se você escrever, eles virão até você.  E se você puder manter uma pequena fração deles e mantê-los ativos, terá uma comunidade vibrante no futuro próximo.  Isso lembra um pouco a idéia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>chuva após um arado</i></a> : <br><br>  <i>O Senhor dirige o arado ... Após essa adaptação maravilhosa, que é o único domínio do homem sobre a natureza, as nuvens derramam fortes chuvas ... [arado] é uma ferramenta que separa a civilização da barbárie, transforma o deserto em fazendas e jardins.</i>  <i>... Em suma, a chuva segue o arado.</i> <br><br>  A essência da teoria era que a habitação e a agricultura humanas têm um impacto irreversível no clima das regiões áridas e semi-áridas, tornando essas regiões mais úmidas.  Essa teoria se espalhou na década de 1870 como justificativa para o assentamento das Grandes Planícies, uma região anteriormente conhecida como o Grande Deserto Americano.  Naqueles anos, essa teoria foi usada para justificar a expansão das culturas de trigo nas terras marginais do sul da Austrália. <br><br>  Se conseguirmos lançar um projeto grande, os desenvolvedores aparecerão e ele se tornará auto-suficiente.  Eu acho que essa ideia é claramente errada, principalmente porque Erlang teve dezenas de aplicativos matadores durante a maior fase de hype, mas a comunidade ainda é pequena.  Aqui estão exemplos desses aplicativos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ejabberd</a> (2002, primeiro lançamento estável em 2005): foi um dos servidores de bate-papo mais, se não o mais escalável.  O Ejabberd alcançou grande sucesso e, até certo ponto, ainda é relevante.  Hoje, no StackOverflow, ainda existem dúvidas sobre os módulos para este servidor.  Por volta de 2011, ele entrou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MongooseIM</a> , e as duas soluções ainda são suportadas. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CouchDB</a> (2005): um dos bancos de dados mais populares escritos em Erlang, que foi baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teorema da CAP</a> .  Refere-se ao tempo do surgimento de repositórios multimaster.  Embora o MongoDB ocupasse a maior parte do mercado, o CouchDB tem sucessores espirituais entre os mecanismos de armazenamento como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BarrelDB</a> , que ainda é suportado. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RabbitMQ</a> (2007): um servidor de enfileiramento de mensagens que esmagou a maior parte do mercado AMQP.  Ele se desenvolve e geralmente compete com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kafka no</a> que diz respeito ao streaming de cargas, embora esses produtos tenham recursos e aplicativos diferentes. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chat no Facebook</a> (2008): A versão inicial do Facebook Chat foi escrita em Erlang.  Por várias razões internas (estabilidade, um grande número de programadores em C ++ e várias soluções estabelecidas), foi posteriormente reescrito em C ++. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WhatsApp</a> (2009, comprado em 2014): quando o Facebook se livrou do sistema de bate-papo Erlang, eles compraram o WhatsApp, que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exigia apenas 50 engenheiros para o</a> suporte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">900 milhões de usuários</a> .  Ele vive até hoje e, além do mais, a equipe do WhatsApp fortaleceu ainda mais os laços com as comunidades Erlang e Elixir. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Riak</a> (2009): Um dos melhores exemplos de demonstração de poder no mundo dos sistemas distribuídos.  Riak era um armazenamento distribuído confiável do tipo de valor-chave.  Este é um produto Basho que ainda funciona em sistemas de saúde e em outras partes críticas da infraestrutura.  Mais tarde, Basho faliu (em grande parte devido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">violações de deveres fiduciários</a> , que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"a toda velocidade levaram a empresa ao colapso"</a> ).  Então o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bet365</a> comprou todos os seus IPs, os abriu generosamente e, desde então, o banco de dados vive no mundo do código aberto, embora hoje esteja passando por momentos difíceis. <br></li></ul><br>  Muitos desses produtos foram lançados durante a primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">edição do</a> livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programming Erlang,</a> de Joe Armstrong.  Como resultado, surgiu uma explosão da popularidade do idioma, e Erlang ganhou muitos admiradores.  Um impacto significativo foi mesmo o fato de o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hacker News ter forçado todas as discussões sobre as entranhas de Erlang</a> .  No entanto, poucos permaneceram fiéis a esse idioma. <br><br>  Agora, acredito que aplicativos matadores são criados por pessoas que formam a fase inicial do hype, e não vice-versa.  Sempre há uma pequena parte das pessoas que procuram tecnologias interessantes antes dos outros, decidem se gostam delas, depois criam algo e, se você obtém um aplicativo matador, isso estimula o desenvolvimento de uma fase de hype ainda mais poderosa.  As pessoas se envolverão no culto à carga e projetos bem-sucedidos produzirão imitadores.  Além disso, a situação padrão é a fase da “invenção da roda”, quando todo mundo gasta seu tempo reinventando coisas existentes, e há uma onda de mensagens sobre a “implementação do <i>X,</i> mas na linguagem Y”. <br><br>  No entanto, apenas criar um aplicativo matador não é suficiente.  Curiosamente, todos esses produtos, como RabbitMQ e Ejabberd, apesar de sua popularidade, têm uma comunidade de usuários muito maior que a comunidade de desenvolvedores.  Milhares e milhares de empresas que usam esses produtos não necessariamente contribuem significativamente para a comunidade Erlang. <br><br>  Isso se deve em parte ao fato de a maioria dos aplicativos Erlang mais sofisticados serem usados ​​em infra-estruturas especializadas.  Você criou um componente altamente confiável na forma de uma caixa preta que todos usam e, se funcionar bem, ninguém procurará dentro.  Várias dezenas de desenvolvedores forneceram a base para milhares de outros produtos e serviços.  A infraestrutura especializada, por definição, não precisa de um grande número de pessoas para garantir seu impacto generalizado.  Ele sempre tem poucos desenvolvedores e uma pequena comunidade em comparação com tecnologias mais próximas do produto final, por exemplo, estruturas da web ou infraestruturas ainda mais generalizadas usadas em pequenos projetos de implantação adequados para qualquer empresa. <br><br>  Mas mesmo com tudo isso, é óbvio que Erlang perdeu muitas pessoas que passaram por isso durante a fase de hype. <br><br><h3>  Escadaria de idéias </h3><br>  Não vou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reclamar</a> sobre o que poderia ou deveria ter sido feito.  Em vez disso, quero falar sobre os padrões populares de aprendizado que encontrei na comunidade Erlang ao longo dos anos de ensino e programação desse idioma.  Hoje observo os mesmos padrões na comunidade Elixir, e isso pode indicar um futuro semelhante para ele. <br><br>  Eu tenho uma teoria de que um tópico técnico como uma linguagem de programação (e seu ecossistema) possui vários níveis de complexidade nos quais diferentes conceitos estão localizados.  Eu usei essa teoria no projeto <i>Learn You Some Erlang</i> .  É apresentado no diagrama, que chamei de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">círculos</a> dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nove Earl</a> . <br><br>  Claro, essa é uma ideia irônica, não acho que o estudo de uma tecnologia seja um sofrimento sem fim (pelo menos não deveria ser).  Eu apenas gostei do trocadilho.  Simplificando, sempre existe algum tipo de caminho ou sequência “principal” daqueles que você aprende quando estuda tecnologia - essa é a “escada de idéias”, e quanto mais alto o conceito estiver localizado nessa escada, mais valioso e mais difícil é alcançar, menos pessoas conhece ela. <br><br>  Como seria a escada de idéias em Erlang: <br><br><ol><li>  Programação funcional. <br></li><li>  Processos isolados e competitividade. <br></li><li>  Competitividade confiável (links, monitores, tempos limite). <br></li><li>  Princípios OTP e outras abstrações do sistema. <br></li><li>  Como estruturar sistemas de acordo com os princípios da OTP. <br></li><li>  Como coletar liberações e trabalhar com elas (implantação). <br></li><li>  Como evitar uma falha no sistema e trabalhar com ele. <br></li></ol><br>  Se você conhece Erlang e compra um livro para iniciantes, provavelmente passa os primeiros dias no primeiro passo da escada: familiarização com programação funcional, imutabilidade (imutabilidade), recursão e outros conceitos semelhantes.  Mais cedo ou mais tarde, você chegará à competitividade e ao paralelismo, processos e mensagens.  Imediatamente após eles, você começará a aprender sobre links e monitores, lidar com falhas e o que Erlang faz do que é.  Durante a grande fase de hype, os segundo e terceiro passos continham oportunidades que para a maioria dos observadores pareciam simplesmente inacreditáveis.  Se você precisar aprender algo que usará em todos os projetos futuros, poderá escolher um desses recursos do Erlang. <br><br>  Você pode avançar para outras etapas mais tarde, mas apenas se aderir ao programa de treinamento passo a passo.  Em particular, o OTP (quarta etapa) pode ser descrito como "do que se trata".  A competitividade e a programação funcional são boas, mas a estrutura geral apresentada com o OTP era realmente única e precisava ser usada.  Com o tempo, muitos vão trabalhar com ele, acham que podem criar abstrações interessantes, mas não gostam da abordagem de estruturação. <br><br>  De fato, para criar aplicativos como o Ejabberd, bastava superar o quarto passo.  Naqueles dias, o ecossistema se assemelhava ao Oeste Selvagem, e o conhecimento da OTP era de propriedade de especialistas que trabalhavam na Ericsson, bem como do autodidata mais motivado.  A maioria nunca chegou ao quinto estágio, a menos que enviasse algo para a produção e depois encontrasse problemas ou se não procurasse uma solução melhor.  A conquista da sexta etapa foi rara até 2015-2016 e, em seguida, apareceu o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relx</a> , o que simplificou a montagem de lançamentos e seu desenvolvimento.  Quase ninguém alcançou a sétima etapa, e muitas pessoas pensam que não devem executar uma atualização quente do nó Erlang e, idealmente, você nunca precisará usar o SSH para depuração na produção. <br><br>  Na prática, nem todo mundo sobe a escada de idéias na mesma ordem; seus passos em alguns livros são invertidos (por exemplo, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erlang e OTP em Ação</a> ).  Não há nada de errado nisso, a escada foi inventada apenas como ilustração. <br><br>  O tamanho das comunidades está mudando em ondas.  Durante as fases do hype, o tamanho por algum tempo pode aumentar em dezenas ou centenas de vezes, e todas essas pessoas ficarão curiosas e vão embora.  A maioria dos participantes se senta no primeiro degrau da escada e raramente o deixa para trás.  Alguns chegam ao segundo estágio, menos ainda ao terceiro, e assim por diante, até chegar a um círculo estreito de especialistas no mais alto nível. <br><br>  Eu acho que subir os três primeiros degraus de Erlang foi fácil.  Para subir para o quarto, foi necessário se desenvolver por vários anos e, de fato, sentir a necessidade de mais estudos.  No quinto passo já é muito difícil.  O kit de ferramentas e o ecossistema de Erlang eram pobres.  Os membros da comunidade suportaram esse ambiente árido e foram indiferentes à situação difícil dos recém-chegados.  Para tornar o artigo mais curto (bem, longo, mas não absurdamente longo), veja minha palestra sobre o ecossistema de idiomas na Erlang User Conference: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Z28SDd9bXcE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Se você escreve no Elixir, provavelmente vê em que degrau da escada em que está parado e já pode imaginar em que proporções a comunidade está distribuída por ela.  Muitos participantes são fluentes apenas em Phoenix, mas raramente se levantam acima do quarto passo, e muitos ficam presos no terceiro e mais baixo.  E muitas vezes isso é suficiente.  Não culpo, mas apenas compartilho a observação.  Como qualquer pessoa que tenha subido muitos degraus (e provavelmente há muitos outros passos à minha frente, como “consertar uma máquina virtual” ou outra coisa), vejo que essas pessoas não sabem muito.  Mas, honestamente, todas essas informações podem ser inúteis para eles.  E isso é bom. <br><br>  O que quero dizer: acredito que nós, como comunidade, provavelmente estamos vendo cadelas debaixo de nós, tornando muito difícil dominar a escada de idéias acima do nível básico.  Alguns tópicos precisam ser estudados lentamente e, em alguns, os cegos lideram os cegos, porque Erlang é tão pequeno que temos poucas pessoas que podem compartilhar toda a experiência necessária.  Hoje é mais simples e, se você não veio a Erlang na fase de hype, provavelmente receberá ajuda, pois muito menos pessoas estão pedindo por isso ao mesmo tempo. <br><br>  Gostaria de pensar que, se a segunda fase do hype começar no mundo de Erlang amanhã, poderemos aceitar os recém-chegados melhor do que durante a grande onda, quando eu vim.  E espero que essa experiência, juntamente com uma colaboração mais estreita entre as comunidades Erlang e Elixir, duplique nossas chances de expandir com sucesso o uso desses idiomas. <br><br><h3>  O que mudou </h3><br>  Erlang não nada no frasco, esperando que ele seja puxado para a luz.  Está em constante evolução.  Isso se deve em parte à concorrência e sugestões da comunidade Elixir, que, felizmente, espera muito mais de suas ferramentas do que o que os usuários do Erlang estão acostumados.  E em parte o desenvolvimento é determinado pelas necessidades urgentes da indústria e pelos desejos da comunidade acadêmica. <br><br>  Eu acho que alguém ficará satisfeito com essas mudanças que ocorreram desde 2009 ou mesmo antes: <br><br><ul><li>  O suporte multinúcleo agora funciona bem.  Anteriormente, se houvesse mais de 2 a 4 núcleos, o sistema repousava em todos os tipos de gargalos que não estavam sujeitos ao desenvolvedor do aplicativo.  Então tornou-se possível usar 12-16 núcleos.  Hoje, eu nem sei qual é o limite superior, mas escrevi e gerenciei pilhas que funcionavam em mais de 32 núcleos sem problemas. <br></li><li>  Rastreamentos de pilha agora têm números de linha.  É quase impensável voltar ao passado, antes que os números aparecessem.  Naqueles anos, “escrever pequenas funções auto-documentadas” não era uma questão de arquitetura, mas de sobrevivência.  Agora você pode depurar programas Erlang sem habilidades de depuração sobrenatural, apesar de nunca prejudicarem. <br></li><li>  Atualmente, a qualidade do suporte a Unicode é aceitável.  O módulo de strings contém os algoritmos mais importantes e o módulo unicode faz um excelente trabalho com a maioria dos tipos de transformações e normalizações.  Existem abordagens típicas para trabalhar com pontos de código, UTF-8, UTF-16 e UTF-32.  O suporte local ainda deixa muito a desejar, mas todo o resto está operacional.  Módulos como re (um módulo para trabalhar com expressões regulares) e todas as funções de alto nível para trabalhar com arquivos também não apresentam problemas ao trabalhar com Unicode. <br></li><li>  Mapas (implementados como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HAMT</a> ) com sintaxe explícita de correspondência de padrões são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suportados</a> .  Com a ajuda da análise do tipo Dialyzer, é aplicada a eles, o que permite que sejam usados ​​nos casos em que anteriormente o uso de registros exigia muito esforço. <br></li><li>  As máquinas virtuais agora usam excelentes mecanismos para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalhar com o tempo</a> , lidam com uma mudança na escala de tempo, com diferentes tipos de relógios e muito mais.  No entanto, trabalhar com fusos horários e formatar o horário é melhor com a ajuda de bibliotecas desenvolvidas pela comunidade. <br></li><li>  Ferramentas de alto desempenho, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atômica</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contadores</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">termos persistentes</a> foram adicionadas para ajudar a melhorar os vários mecanismos subjacentes às ferramentas de vigilância e bibliotecas básicas de baixo nível. <br></li><li>  Todo o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">processamento de sinais se tornou assíncrono</a> , incluindo o trabalho com <a href="">portas</a> , o que nos salvou de muitos gargalos. <br></li><li>  O compilador foi reescrito e ainda está sendo reescrito para aprimorar a análise e o desempenho de alto nível usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSA.</a> <br></li><li>  Havia um tipo especial de agendadores para uso no NIF - agendadores sujos, que simplificavam a integração com o código escrito em c ou até ferrugem, suportando processos intensivos de CPU e E / S.  Portanto, embora a linguagem em si não tenha se tornado muito mais rápida (embora haja progresso), ficou muito mais fácil conectar bibliotecas de alto desempenho sem afetar indevidamente a estabilidade da máquina virtual. <br></li><li>  Várias melhorias foram feitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no mecanismo para alocar e gerenciar memória.</a> <br></li><li>  A análise do programa tornou-se mais precisa e rápida, graças ao rastreamento e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contabilidade</a> mais rápidos e flexíveis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para microestados</a> . <br></li><li>  O comportamento OTP mais flexível do gen_statem permitiu a implementação de máquinas de estados finitos que podem processar dados de entrada seletivamente. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura de log</a> nova e aprimorada com suporte interno para logs estruturados. <br></li><li>  O módulo de criptografia é reescrito e usa NIF em vez dos drivers mais complexos (e geralmente atualizados mais lentamente). <br></li><li>  O driver do arquivo foi totalmente reescrito usando o NIF, o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">melhorou bastante o desempenho.</a> <br></li><li>  Para obter o mesmo desempenho, eles continuam a reescrever os drivers de rede usando o NIF. <br></li><li>  Redesenhado completamente o uso de SSL para processamento TLS.  Quando trabalhei na Heroku, tentamos tornar o produto comparável às soluções C ++ em termos de atraso (talvez 5% pior) e ultrapassar significativamente a previsibilidade (10 a 30 vezes menos que 99 percentis). <br></li><li>  Desempenho do ETS significativamente aprimorado. <br></li><li>  Escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guia para gerenciar e depurar sistemas de produção</a> em máquinas virtuais Erlang. <br></li><li>  Uma ferramenta de construção completamente nova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rebar3</a> ), integrada ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciador de pacotes</a> unificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para o ecossistema Erlang.</a> <br></li><li>        ,    .    Elixir, Efene, LFE, Luerl, Clojerl         Gleam  Alpaca. <br></li><li>          Erlang. <br></li></ul><br>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> .    ,     OTP  Ericsson   13-16     (   22!),      Erlang      . ,      Ericsson.  Erlang  Elixir,     Erlang VM    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erlang Ecosystem Foundation</a> ,   ,           ,   (observability —     ), ,  .. <br><br>  ,   ,      , ,    ,     ,         , ,  ,   Erlang  .      . <br><br><h3>   Erlang </h3><br>  ,      ,     2007-2009,    ,    . Erlang        ,          .   ,      ,     BEAM Conf.           (Property-Based Testing),   Erlang  Elixir       .     ,  <i></i>    .   , . <br><br>     ?  , ,   , .   ,      Elixir.     ,  ,     ,    .     ,  . ,    .      .    ,      .   Erlang,      ,      . <br><br>  ,       Erlang  .     ,      ,       Erlang-,       Erlang-:   ,  ,      .      ,      . <br><br>    Erlang       -,          Elixir-. <br><br> ,       ,      Erlang  .   ,        .   Erlang   ,    .        ,       . <br><br>      ,   .    ?       ?  ,   -    ?  ,    ,     ?     ?  ,   ?   « - »? <br><br>      ,      ,       «    ».  ,            Erlang     .  ,      .      junior   senior-,    ,     ,    ,    . <br><br>  ,      15      (  ,    ),             .  ,     <i></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistemas e sua criação e trazendo à condição de trabalho. </font><font style="vertical-align: inherit;">Todo mundo tem sua própria motivação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não consigo imaginar que conseguiria isso em outra comunidade. </font><font style="vertical-align: inherit;">Esses 10 anos foram incríveis. </font><font style="vertical-align: inherit;">É curioso que a comunidade Erlang ainda seja pequena e seu potencial não seja revelado. </font><font style="vertical-align: inherit;">Isso significa que há muitas oportunidades de participar de tudo, de se comunicar cara a cara com pessoas cheias de sabedoria e que desejam compartilhar isso e encontrar seu lugar. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS. </font><font style="vertical-align: inherit;">Obrigado por traduzir o e-mail do grupo; </font><font style="vertical-align: inherit;">Comunidade Erlang no Telegram (Evgeny M., Sergey Ivanov, Vladimir Sekisov, Greg)</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460115/">https://habr.com/ru/post/pt460115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460101/index.html">Operação XSS baseada em cookie | $ 2300 Bug Bounty story</a></li>
<li><a href="../pt460107/index.html">ISPsystem, perdoe e adeus! Por que e como escrevemos nosso painel de controle do servidor</a></li>
<li><a href="../pt460109/index.html">Angular: quando você precisa ver o aplicativo, mas o back-end ainda não está pronto</a></li>
<li><a href="../pt460111/index.html">Versão atualizada do SAP Business One 9.3: o que mudou</a></li>
<li><a href="../pt460113/index.html">Algumas histórias da vida do JSOC CERT, ou forense unbanal</a></li>
<li><a href="../pt460117/index.html">Os maiores clientes da Rússia são um grande jackpot ou uma dor de cabeça? Experiência AGIMA</a></li>
<li><a href="../pt460119/index.html">Erros que a análise de código estático não encontra porque não é usada</a></li>
<li><a href="../pt460121/index.html">Erros que a análise de código estático não encontra porque não é usada</a></li>
<li><a href="../pt460123/index.html">Um pipeline de processamento de dados declarativo em cima dos atores? Porque não</a></li>
<li><a href="../pt460125/index.html">Node.js ou Java: desempenho, recursos, controle de fluxo, popularidade e experiência pessoal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>