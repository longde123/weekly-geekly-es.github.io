<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÑ üñçÔ∏è ü§¶üèª Interpr√®tes DIY Bytecode üí≠ ü§≤üèº üåØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les machines virtuelles de langages de programmation sont devenues tr√®s r√©pandues au cours des derni√®res d√©cennies. Beaucoup de temps s'est √©coul√© dep...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interpr√®tes DIY Bytecode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Les machines virtuelles de langages de programmation sont devenues tr√®s r√©pandues au cours des derni√®res d√©cennies.  Beaucoup de temps s'est √©coul√© depuis la pr√©sentation de Java Virtual Machine dans la seconde moiti√© des ann√©es 90, et il est s√ªr de dire que les interpr√®tes de code octet ne sont pas l'avenir, mais le pr√©sent. </p><br><p>  Mais cette technique, √† mon avis, est presque universelle, et la compr√©hension des principes de base du d√©veloppement d'un interpr√®te est utile non seulement au cr√©ateur du prochain challenger pour le titre "Langue de l'ann√©e" selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TIOBE</a> , mais √† tout programmeur en g√©n√©ral. </p><br><p>  En un mot, si vous √™tes int√©ress√© √† savoir comment nos langages de programmation pr√©f√©r√©s additionnent les nombres, ce que les d√©veloppeurs de machines virtuelles discutent toujours et comment faire correspondre sans douleur les cha√Ænes et les expressions r√©guli√®res, je demande cat. </p><a name="habracut"></a><br><p>  Premi√®re partie, introduction (actuelle) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxi√®me partie, optimisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Troisi√®me partie, appliqu√©e</a> </p><br><h1 id="predystoriya">  Contexte </h1><br><p>  L'un des syst√®mes auto-√©crits du d√©partement Business Intelligence de notre entreprise poss√®de une interface sous la forme d'un langage de requ√™te simple.  Dans la premi√®re version du syst√®me, ce langage √©tait interpr√©t√© √† la vol√©e, sans compilation, directement depuis la ligne d'entr√©e avec la requ√™te.  La deuxi√®me version de l'analyseur fonctionnera d√©j√† avec le bytecode interm√©diaire, ce qui vous permettra de s√©parer le langage de requ√™te de son ex√©cution et de simplifier consid√©rablement le code. </p><br><p> Dans le processus de travail sur la deuxi√®me version du syst√®me, j'ai eu des vacances pendant lesquelles pendant une heure ou deux chaque jour, j'√©tais distrait des affaires familiales pour √©tudier des documents sur l'architecture et la performance des interpr√®tes de bytecode.  J'ai d√©cid√© de partager les notes et les exemples d'interpr√®tes qui en r√©sultent avec les lecteurs de Habr sous la forme d'une s√©rie d'articles. </p><br><p>  La premi√®re d'entre elles pr√©sente cinq petites machines virtuelles (jusqu'√† des centaines de lignes de code C simple), chacune r√©v√©lant un certain aspect du d√©veloppement de tels interpr√®tes. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  O√π sont pass√©s les codes d'octets dans les langages de programmation? </h1><br><p>  Un grand nombre de machines virtuelles, les jeux d'instructions virtuelles les plus diversifi√©s des derni√®res d√©cennies, ont √©t√© invent√©s.  Wikipedia affirme que les premiers langages de programmation ont commenc√© √† se compiler en diverses repr√©sentations interm√©diaires simplifi√©es dans les ann√©es 60 du si√®cle dernier.  Certains de ces premiers codes d'octet ont √©t√© convertis en codes machine et ex√©cut√©s par de vrais processeurs, tandis que d'autres ont √©t√© interpr√©t√©s √† la vol√©e par des processeurs virtuels. </p><br><p>  La popularit√© des ensembles d'instructions virtuelles en tant que repr√©sentation interm√©diaire du code est due √† trois raisons: </p><br><ol><li>  Les programmes de bytecode sont facilement port√©s sur de nouvelles plateformes. </li><li>  Les interpr√®tes de bytecode sont plus rapides que les interpr√®tes de l'arbre de syntaxe du code. </li><li>  Vous pouvez d√©velopper une machine virtuelle simple en quelques heures seulement. </li></ol><br><p>  Faisons quelques machines virtuelles C simples et utilisons ces exemples pour mettre en √©vidence les principaux aspects techniques de la mise en ≈ìuvre des machines virtuelles. </p><br><p>  Des exemples de codes complets sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Des exemples peuvent √™tre compil√©s avec n'importe quel GCC relativement r√©cent: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Tous les exemples ont la m√™me structure: vient d'abord le code de la machine virtuelle elle-m√™me, puis la fonction principale avec des assertions qui v√©rifient le fonctionnement du code.  J'ai essay√© de commenter clairement les opcodes et les endroits cl√©s des interpr√®tes.  J'esp√®re que cet article sera compr√©hensible m√™me pour les personnes qui n'√©crivent pas quotidiennement en C. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  L'interpr√®te de bytecode le plus simple au monde </h1><br><p>  Comme je l'ai dit, l'interpr√®te le plus simple est tr√®s facile √† faire.  Les commentaires sont juste derri√®re la liste, mais commen√ßons directement par le code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Il y a moins d'une centaine de lignes, mais tous les attributs caract√©ristiques d'une machine virtuelle sont repr√©sent√©s.  La machine a un seul registre ( <code>vm.accumulator</code> ), trois op√©rations (incr√©ment de registre, d√©cr√©ment de registre et ach√®vement de l'ex√©cution du programme) et un pointeur sur l'instruction en cours ( <code>vm.ip</code> ). </p><br><p>  Chaque op√©ration ( <em>code d'op√©ration</em> ou <em>code d'op√©ration</em> ) est cod√©e sur un octet et la planification est effectu√©e √† l'aide du <code>switch</code> habituel dans la fonction <code>vm_interpret</code> .  Les branches du <code>switch</code> contiennent la logique des op√©rations, c'est-√†-dire qu'elles changent l'√©tat du registre ou terminent l'ex√©cution du programme. </p><br><p>  Les op√©rations sont transf√©r√©es √† la fonction <code>vm_interpret</code> sous la forme d'un tableau d'octets - un bytecode (Eng. <em>Bytecode</em> ) - et sont ex√©cut√©es s√©quentiellement jusqu'√† ce que l'op√©ration d' <code>OP_DONE</code> machine virtuelle ( <code>OP_DONE</code> ) soit <code>OP_DONE</code> . </p><br><p>  Un aspect cl√© d'une machine virtuelle est la s√©mantique, c'est-√†-dire l'ensemble des op√©rations qui y sont possibles.  Dans ce cas, il n'y a que deux op√©rations et elles modifient la valeur d'un seul registre. </p><br><p>  Certains chercheurs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Virtual-machine Abstraction and Optimization Techniques</a> , 2009) proposent de diviser les machines virtuelles en machines de <em>haut niveau</em> et de <em>bas niveau</em> selon la proximit√© de la s√©mantique de la machine virtuelle avec la s√©mantique de la machine physique sur laquelle le bytecode sera ex√©cut√©. </p><br><p>  Dans le cas extr√™me, le bytecode des machines virtuelles de bas niveau peut r√©p√©ter compl√®tement le code machine de la machine physique avec de la RAM simul√©e, un ensemble complet de registres, des instructions pour travailler avec la pile, etc.  La machine virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bochs</a> , par exemple, r√©p√®te le jeu d'instructions d'architecture x86. </p><br><p>  Et vice versa: les op√©rations des machines virtuelles de haut niveau refl√®tent √©troitement la s√©mantique d'un langage de programmation sp√©cialis√© compil√© en bytecode.  Alors travaillez, par exemple, SQLite, Gawk et de nombreuses versions de Prolog. </p><br><p>  Les postes interm√©diaires sont occup√©s par des interpr√®tes de langages de programmation √† usage g√©n√©ral ayant des √©l√©ments de niveaux √©lev√© et faible.  La machine virtuelle Java la plus populaire a √† la fois des instructions de bas niveau pour travailler avec la pile et une prise en charge int√©gr√©e pour la programmation orient√©e objet avec allocation automatique de m√©moire. </p><br><p>  Le code ci-dessus est plus susceptible d'√™tre le plus primitif des machines virtuelles de bas niveau: chaque instruction virtuelle est un wrapper sur une ou deux instructions physiques, le registre virtuel est enti√®rement coh√©rent avec un registre du processeur "iron". </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Arguments de l'instruction Bytecode </h1><br><p>  Nous pouvons dire que le seul registre dans notre exemple de machine virtuelle est √† la fois un argument et la valeur de retour de toutes les instructions ex√©cut√©es.  Cependant, nous pouvons trouver utile de passer des arguments dans les instructions.  Une fa√ßon consiste √† les mettre directement en bytecode. </p><br><p>  Nous allons d√©velopper l'exemple en introduisant des instructions (OP_ADDI, OP_SUBI) qui prennent un argument sous la forme d'un octet suivant imm√©diatement l'opcode: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  De nouvelles instructions (voir la fonction <code>vm_interpret</code> ) lisent leur argument dans le bytecode et l'ajoutent au registre / le soustraient du registre. </p><br><p>  Un tel argument est appel√© un <em>argument imm√©diat</em> , car il se trouve directement dans le tableau d'opcode.  La principale limitation de notre impl√©mentation est que l'argument est un seul octet et ne peut prendre que 256 valeurs. </p><br><p>  Dans notre machine virtuelle, la plage de valeurs d'argument d'instructions possibles ne joue pas un grand r√¥le.  Mais si la machine virtuelle sera utilis√©e comme interpr√®te du vrai langage, alors il est logique de compliquer le bytecode en ajoutant une table de constantes distincte du tableau des opcodes et des instructions avec un argument direct correspondant √† l'adresse de cet argument dans la table des constantes. </p><br><h1 id="stekovaya-mashina">  Machine √† empiler </h1><br><p>  Les instructions de notre machine virtuelle simple fonctionnent toujours avec un seul registre et ne peuvent en aucun cas se transmettre des donn√©es.  De plus, l'argument de l'instruction ne peut √™tre qu'imm√©diat et, par exemple, l'op√©ration d'addition ou de multiplication prend deux arguments. </p><br><p>  Autrement dit, nous n'avons aucun moyen d'√©valuer des expressions complexes.  Pour r√©soudre ce probl√®me, une machine empil√©e est n√©cessaire, c'est-√†-dire une machine virtuelle avec une pile int√©gr√©e: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Dans cet exemple, il y a d√©j√† plus d'op√©rations et presque toutes ne fonctionnent qu'avec la pile.  OP_PUSHI pousse son argument imm√©diat sur la pile.  Les instructions OP_ADD, OP_SUB, OP_DIV, OP_MUL sont extraites d'une pile de valeurs, calculent le r√©sultat et le repoussent sur la pile.  OP_POP_RES supprime la valeur de la pile et la place dans le registre des r√©sultats, destin√© aux r√©sultats de la machine virtuelle. </p><br><p>  Pour l'op√©ration de division (OP_DIV), une erreur de division par z√©ro est intercept√©e, ce qui arr√™te la machine virtuelle. </p><br><p>  Les capacit√©s d'une telle machine sont beaucoup plus larges que la pr√©c√©dente avec un seul registre et permettent, par exemple, de calculer des expressions arithm√©tiques complexes.  Un autre (et important!) Avantage est la simplicit√© de compilation des langages de programmation dans le code octet de la machine de pile. </p><br><h1 id="registrovaya-mashina">  Enregistrer la machine </h1><br><p>  En raison de leur simplicit√©, les machines virtuelles empil√©es sont les plus utilis√©es parmi les d√©veloppeurs de langages de programmation;  les m√™mes JVM et VM Python les utilisent exactement. </p><br><p>  Cependant, ces machines ont des inconv√©nients: elles doivent ajouter des instructions sp√©ciales pour travailler avec la pile, lors du calcul des expressions, tous les arguments passent √† plusieurs reprises dans une seule structure de donn√©es, de nombreuses instructions suppl√©mentaires appara√Ætront in√©vitablement dans le code de la pile. </p><br><p>  Pendant ce temps, l'ex√©cution de chaque instruction suppl√©mentaire entra√Æne le co√ªt de l'ordonnancement, c'est-√†-dire le d√©codage de l'opcode et le passage au corps des instructions. </p><br><p>  Une alternative aux machines empil√©es consiste √† enregistrer les machines virtuelles.  Ils ont un bytecode plus complexe: le nombre d'arguments de registre et le num√©ro de r√©sultat de registre sont explicitement cod√©s dans chaque instruction.  Par cons√©quent, au lieu d'une pile, un ensemble √©tendu de registres est utilis√© comme stockage de valeurs interm√©diaires. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  L'exemple montre une machine √† registres avec 16 registres.  Les instructions occupent chacune 16 bits et sont cod√©es de trois mani√®res: </p><br><ol><li>  4 bits par opcode + 4 bits par nom de registre + 8 bits par argument. </li><li>  4 bits par opcode + trois fois 4 bits par nom de registre. </li><li>  4 bits par opcode + 4 bits par nom de registre unique + 8 bits inutilis√©s. </li></ol><br><p>  Notre petite machine virtuelle a tr√®s peu d'op√©rations, donc quatre bits (ou 16 op√©rations possibles) par opcode suffisent largement.  L'op√©ration d√©termine ce que repr√©sentent exactement les bits restants de l'instruction. </p><br><p>  Le premier type de codage (4 + 4 + 8) est n√©cessaire pour charger des donn√©es dans des registres avec l'op√©ration OP_LOADI.  Le deuxi√®me type (4 + 4 + 4 + 4) est utilis√© pour les op√©rations arithm√©tiques, qui devraient savoir o√π prendre une paire d'arguments et o√π ajouter le r√©sultat du calcul.  Et enfin, la derni√®re forme (4 + 4 + 8 bits inutiles) est utilis√©e pour les instructions avec un seul registre comme argument, dans notre cas c'est OP_MOV_RES. </p><br><p>  Pour encoder et d√©coder des instructions, nous avons maintenant besoin d'une logique sp√©ciale (fonction de <code>decode</code> ).  En revanche, la logique des instructions, gr√¢ce √† l'indication explicite de l'emplacement des arguments, devient plus facile - les op√©rations avec la pile disparaissent. </p><br><p>  Principales caract√©ristiques: dans le bytecode des machines √† registres, il y a moins d'instructions, les instructions individuelles sont plus larges, la compilation dans un tel bytecode est plus difficile - le compilateur doit d√©cider comment utiliser les registres disponibles. </p><br><p>  Il convient de noter qu'en pratique, dans les registres de machines virtuelles, il y a g√©n√©ralement une pile o√π, par exemple, les arguments de fonction sont plac√©s;  les registres sont utilis√©s pour calculer des expressions individuelles.  M√™me s'il n'y a pas de pile explicite, un tableau est utilis√© pour cr√©er la pile, jouant le m√™me r√¥le que la RAM dans les machines physiques. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Machines √† empiler et √† enregistrer, comparaison </h1><br><p>  Il existe une √©tude int√©ressante ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Virtual machine showdown: Stack versus registers</a> , 2008) qui a eu une grande influence sur tous les d√©veloppements ult√©rieurs dans le domaine des machines virtuelles pour les langages de programmation.  Ses auteurs ont propos√© une m√©thode de traduction directe du code de pile d'une machine virtuelle Java standard en un code de registre et compar√© les performances. </p><br><p>  La m√©thode n'est pas anodine: le code est d'abord traduit, puis optimis√© de mani√®re assez compliqu√©e.  Mais une comparaison ult√©rieure des performances du m√™me programme a montr√© que les cycles de processeur suppl√©mentaires consacr√©s aux instructions de d√©codage sont enti√®rement compens√©s par une diminution du nombre total d'instructions.  En g√©n√©ral, en bref, la machine √† registres √©tait plus efficace que la pile. </p><br><p>  Comme d√©j√† mentionn√© ci-dessus, cette efficacit√© a un prix assez tangible: le compilateur doit allouer les registres lui-m√™me et un optimiseur avanc√© est en outre souhaitable. </p><br><p>  Le d√©bat sur la meilleure architecture n'est pas termin√©.  Si nous parlons de compilateurs Java, le bytecode Dalvik VM, qui fonctionnait jusqu'√† r√©cemment sur tous les appareils Android, √©tait enregistr√©;  mais le titre JVM a conserv√© une pile d'instructions.  La machine virtuelle Lua utilise une machine d'enregistrement, mais la machine virtuelle Python est toujours empilable.  Et ainsi de suite. </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode dans les interpr√©teurs d'expressions r√©guli√®res </h1><br><p>  Enfin, pour nous distraire des machines virtuelles de bas niveau, regardons un interpr√©teur sp√©cialis√© qui v√©rifie les cha√Ænes pour la correspondance des expressions r√©guli√®res: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  L'instruction principale est OP_CHAR.  Elle prend son argument imm√©diat et le compare avec le caract√®re actuel de la cha√Æne ( <code>char *sp</code> ).  En cas de co√Øncidence des caract√®res attendus et actuels dans la ligne, la transition vers l'instruction suivante et le caract√®re suivant se produit. </p><br><p>  La machine comprend √©galement l'op√©ration de saut (OP_JUMP), qui prend un seul argument imm√©diat.  L'argument signifie le d√©calage absolu dans le bytecode, d'o√π continuer le calcul. </p><br><p>  La derni√®re op√©ration importante est OP_OR.  Elle prend deux d√©calages, essayant d'appliquer le code d'abord sur le premier, puis, en cas d'erreur, sur le second.  Elle le fait avec un appel r√©cursif, c'est-√†-dire que l'instruction fait un tour dans la profondeur de l'arbre de toutes les variantes possibles de l'expression r√©guli√®re. </p><br><p>  √âtonnamment, quatre opcodes et soixante-dix lignes de code suffisent pour exprimer des expressions r√©guli√®res comme "abc", "a? Bc", "(ab | bc) d", "a * bc".  Cette machine virtuelle n'a m√™me pas d'√©tat explicite, car tout ce dont vous avez besoin - pointeurs vers le d√©but du flux d'instructions, l'instruction en cours et le caract√®re en cours - est transmis en tant qu'arguments √† la fonction r√©cursive. </p><br><p>  Si vous √™tes int√©ress√© par les d√©tails du travail des moteurs d'expression r√©guli√®re, vous pouvez d'abord lire une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie d'articles de</a> Russ Cox, l'auteur du moteur d'expression r√©guli√®re de Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RE2</a> . </p><br><h1 id="itogi">  R√©sum√© </h1><br><p>  R√©sumons. </p><br><p>  Pour les langages de programmation √† usage g√©n√©ral, en r√®gle g√©n√©rale, deux architectures sont utilis√©es: empiler et enregistrer. </p><br><p>  Dans le mod√®le de pile, la structure de donn√©es principale et la m√©thode de transmission des arguments entre les instructions sont la pile.  Dans le mod√®le de registre, un ensemble de registres est utilis√© pour calculer les expressions, mais une pile explicite ou implicite est toujours utilis√©e pour stocker les arguments de fonction. </p><br><p>  La pr√©sence d'une pile explicite et d'un ensemble de registres rapproche ces machines des machines de bas niveau et m√™me physiques.  L'abondance d'instructions de bas niveau dans un tel bytecode signifie qu'une d√©pense importante de ressources du processeur physique tombe sur le d√©codage et l'ordonnancement des instructions virtuelles. </p><br><p>  D'un autre c√¥t√©, les instructions de haut niveau jouent un grand r√¥le dans les machines virtuelles populaires.  En Java, par exemple, ce sont des instructions pour les appels de fonctions polymorphes, l'allocation d'objets et le garbage collection. </p><br><p>  Des machines virtuelles de haut niveau - par exemple, des interpr√®tes de codes d'octets de langages avec une s√©mantique d√©velopp√©e et loin de fer - la plupart du temps ne passent pas dans le r√©partiteur ou le d√©codeur, mais dans le corps des instructions et, par cons√©quent, sont relativement efficaces. </p><br><p>  Recommandations pratiques: </p><br><ol><li>  Si vous avez besoin d'ex√©cuter un bytecode et de le faire dans un d√©lai raisonnable, essayez alors d'utiliser les instructions les plus proches de votre t√¢che;  plus le niveau s√©mantique est √©lev√©, mieux c'est.  Cela r√©duira les co√ªts de planification et simplifiera la g√©n√©ration de code. </li><li>  Si vous avez besoin de plus de flexibilit√© et d'une s√©mantique h√©t√©rog√®ne, vous devez au moins essayer de mettre en √©vidence le d√©nominateur commun dans le bytecode afin que les instructions r√©sultantes soient √† un niveau moyen conditionnel. </li><li>  Si √† l'avenir, il peut √™tre n√©cessaire de calculer des expressions, de cr√©er une machine empil√©e, cela r√©duira les maux de t√™te lors de la compilation de code d'octets. </li><li>  Si aucune expression n'est attendue, cr√©ez une machine √† registres triviale, ce qui √©vitera le co√ªt de la pile et simplifiera les instructions elles-m√™mes. </li></ol><br><p>  Dans les articles suivants, je vais discuter des impl√©mentations pratiques des machines virtuelles dans les langages de programmation populaires et expliquer pourquoi le d√©partement Business Intelligence Badoo avait besoin d'un bytecode. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425325/">https://habr.com/ru/post/fr425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425313/index.html">Les 10 meilleures extensions VS Code de 2018 pour les d√©veloppeurs front-end</a></li>
<li><a href="../fr425315/index.html">Organiser le stockage de code dans GitLab et int√©grer la r√©vision de code dans GitFlow</a></li>
<li><a href="../fr425317/index.html">Comment √ßa se passe: on √©crit "D√©mineur" en 4 minutes</a></li>
<li><a href="../fr425321/index.html">La programmation est la mat√©rialisation des id√©es.</a></li>
<li><a href="../fr425323/index.html">"Trou de lapin." Designer UX dans l'√©quipe produit</a></li>
<li><a href="../fr425327/index.html">Programmation fonctionnelle: mesure sept fois, coupe une fois</a></li>
<li><a href="../fr425329/index.html">Quelques conseils aux mill√©niaux des "oldies". Comment r√©ussir dans notre monde num√©rique</a></li>
<li><a href="../fr425331/index.html">Alice aidera les d√©veloppeurs √† trouver des objets dans les demandes des utilisateurs. NER dans les dialogues</a></li>
<li><a href="../fr425333/index.html">D√©marrez-vous, le printemps arrive (partie 2)</a></li>
<li><a href="../fr425335/index.html">Armada Garmin invaincu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>