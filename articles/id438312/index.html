<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔎 🙏 👩🏿‍🎨 Otomasi Jaringan dengan Ansible: command module 👶🏽 🥣 🐬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berbicara tentang skenario khas otomatisasi jaringan, seseorang tidak dapat melakukannya tanpa satu set modul perintah. Berkat modul-modul ini, Ansibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomasi Jaringan dengan Ansible: command module</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/438312/">  Berbicara tentang skenario khas otomatisasi jaringan, seseorang tidak dapat melakukannya tanpa satu set modul perintah.  Berkat modul-modul ini, Ansible memungkinkan Anda untuk menjalankan perintah pada peralatan jaringan seolah-olah Anda memasukkannya langsung dari konsol.  Pada saat yang sama, output dari perintah tidak hanya tergelincir di jendela terminal untuk tenggelam, tetapi dapat disimpan dan digunakan di masa depan.  Itu dapat ditulis ke dalam variabel, diuraikan untuk digunakan dalam tugas-tugas berikutnya, atau disimpan untuk masa depan dalam variabel host. <br><br><img src="https://habrastorage.org/webt/ga/bs/bh/gabsbhxuxhvjzjvvizswbdkkq2o.png" width="100%"><br><br>  Tujuan dari posting ini adalah untuk menunjukkan bahwa tugas manajemen jaringan yang berulang dapat diotomatisasi, dan Ansible tidak hanya memungkinkan Anda untuk mengelola konfigurasi, tetapi juga membantu menyingkirkan rutinitas dan menghemat waktu. <br><a name="habracut"></a><br>  Mari kita menganalisis cara-cara dasar untuk menggunakan modul perintah jaringan, termasuk menyimpan output dari perintah menggunakan parameter register.  Kami juga mempertimbangkan bagaimana skala ke beberapa perangkat jaringan menggunakan hostvars dan bagaimana mengatur eksekusi bersyarat menggunakan parameter wait_for dan tiga parameter terkait lainnya: interval, coba lagi dan cocok. <br><br>  Platform jaringan yang berbeda memiliki modul perintah mereka sendiri, yang semuanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">didukung</a> di tingkat ekstensi Pengaya Jaringan Mesin Red Hat Ansible: <br><br><table><tbody><tr><td>  <b>Platform jaringan</b> </td><td>  <b>Modul * os_command</b> </td></tr><tr><td>  Arista eos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah eos_</a> </td></tr><tr><td>  Cisco IOS / IOS-XE </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah ios_</a> </td></tr><tr><td>  Cisco IOS-XR </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iosxr_command</a> </td></tr><tr><td>  Cisco NX-OS </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nxos_command</a> </td></tr><tr><td>  Juniper Junos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah junos_</a> </td></tr><tr><td>  Vyos </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah vyos_</a> </td></tr></tbody></table><br><h3>  Dasar-dasar modul perintah </h3><br>  Pertimbangkan buku pedoman yang hanya menjalankan perintah show show menggunakan modul eos_command: <br><br><pre><code class="plaintext hljs">--- - name: COMMAND MODULE PLAYBOOK hosts: eos connection: network_cli tasks: - name: EXECUTE ARISTA EOS COMMAND eos_command: commands: show version register: output - name: PRINT OUT THE OUTPUT VARIABLE debug: var: output</code> </pre> <br>  Di sini kita memiliki dua tugas dan yang pertama menggunakan modul eos_command dengan parameter perintah tunggal.  Karena kita hanya menjalankan satu perintah - tampilkan versi - ini dapat ditentukan pada baris yang sama dengan parameter perintah itu sendiri.  Jika ada dua tim atau lebih, maka masing-masing dari mereka harus ditempatkan pada baris terpisah setelah perintah:.  Dalam contoh ini, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kata kunci register</a> untuk menyimpan output dari perintah show version.  Parameter register (dapat digunakan dalam tugas Ansible) menetapkan variabel di mana output dari tugas kami akan disimpan sehingga dapat digunakan nanti.  Dalam contoh kami, variabel ini disebut output. <br><br>  Tugas kedua dalam contoh kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul debug</a> untuk menampilkan isi dari variabel keluaran yang baru dibuat.  Artinya, ini adalah data yang sama yang akan Anda lihat pada antarmuka baris perintah pada perangkat EOS jika Anda memasukkan "versi acara" di sana.  Perbedaannya adalah bahwa buku pedoman kami akan menunjukkannya di jendela terminal tempat Anda meluncurkannya.  Seperti yang Anda lihat, modul debug memudahkan untuk memeriksa variabel Ansible. <br><br>  Ini adalah output dari buku pedoman kami: <br><br><pre> <code class="plaintext hljs">PLAY [eos] ************************************************************************* TASK [execute Arista eos command] ************************************************** ok: [eos] TASK [print out the output variable] *********************************************** ok: [eos] =&gt; { "output": { "changed": false, "failed": false, "stdout": [ "Arista vEOS\nHardware version: \nSerial number: \nSystem MAC address: 0800.27ec.005e\n\nSoftware image version: 4.20.1F\nArchitecture: i386\nInternal build version: 4.20.1F-6820520.4201F\nInternal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91\n\nUptime: 1 day, 3 hours and 23 minutes\nTotal memory: 2017324 kB\nFree memory: 1111848 kB" ], "stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 3 hours and 23 minutes", "Total memory: 2017324 kB", "Free memory: 1111848 kB" ] ] } } PLAY RECAP ************************************************************************* eos : ok=2 changed=0 unreachable=0 failed=0</code> </pre><br>  Seperti yang dapat dilihat dari tangkapan layar, kedua tugas kami berhasil dengan sukses.  Karena tugas pertama menggunakan tingkat detail detail pesan, ia hanya mengatakan bahwa host eos menyelesaikan tugas dengan hasil yang baik, menyoroti keberhasilan eksekusi berwarna hijau.  Tugas kedua, dengan modul debug, mengembalikan output dari perintah yang dieksekusi, menampilkan informasi yang sama dalam dua format: <br><br><ul><li>  stdout </li><li>  stdout_lines </li></ul><br>  Bagian stdout menunjukkan hal yang sama dengan yang Anda lihat di antarmuka baris perintah pada perangkat, tetapi dalam bentuk satu garis panjang.  Dan bagian stdout_lines memecah output ini menjadi beberapa baris sehingga nyaman untuk dibaca.  Setiap item dalam daftar ini adalah baris terpisah dalam output dari perintah. <br><br>  Bandingkan output dari perintah di perangkat dan di Ansible: <br><br><table><tbody><tr><td>  <b>Output tim di Arista EOS</b> </td><td>  <b>stdout_lines dalam Ansible</b> </td></tr><tr><td>  eos&gt; tampilkan vers <br>  Arista vEOS <br>  Versi perangkat keras: <br>  Nomor seri: <br>  Alamat sistem MAC: 0800.27ec.005e <br><br>  Versi gambar perangkat lunak: 4.20.1F <br>  Arsitektur: i386 <br>  Versi build internal: 4.20.1F-6820520.4201F <br>  ID build internal: 790a11e8-5aaf-4be7-a11a-e61795d05b91 <br><br>  Waktu aktif: 1 hari, 3 jam, dan 56 menit <br>  Total memori: 2017324 kB <br>  Memori bebas: 1116624 kB </td><td>  "Stdout_lines": [ <br>  [ <br>  "Arista vEOS", <br>  "Versi perangkat keras:", <br>  "Nomor seri:", <br>  "Sistem alamat MAC: 0800.27ec.005e", <br>  "", <br>  "Versi gambar perangkat lunak: 4.20.1F", <br>  "Arsitektur: i386", <br>  "Versi internal build: <br>  4.20.1F-6820520.4201F ", <br>  "ID build internal: <br>  790a11e8-5aaf-4be7-a11a-e61795d05b91 ", <br>  "", <br>  "Waktu aktif: 1 hari, 3 jam dan 23 menit", <br>  "Total memori: 2017324 kB", <br>  "Memori bebas: 1111848 kB" <br>  ] </td></tr></tbody></table><br>  Jika Anda terbiasa dengan JSON dan YAML, maka Anda mungkin sudah memperhatikan satu keanehan: stdout_lines dimulai dengan dua tanda kurung: <br><br><pre> <code class="plaintext hljs">"stdout_lines": [ [</code> </pre><br>  Dua tanda kurung buka menunjukkan bahwa stdout_lines sebenarnya mengembalikan daftar daftar baris.  Jika Anda sedikit memodifikasi tugas debug kami, maka chip ini dapat digunakan untuk melihat hasil perintah secara selektif.  Karena hanya ada satu daftar baris dalam daftar kami, daftar ini disebut nol (pada kenyataannya, ini adalah yang pertama, tetapi hitungannya dari awal).  Sekarang mari kita lihat cara mengekstrak baris terpisah darinya, misalnya, Alamat Sistem MAC.  Dalam output perintah, baris ini adalah baris keempat berturut-turut, tetapi karena kita menghitung dari awal, kita akhirnya membutuhkan baris 3 dari daftar 0, dengan kata lain: output.stdout_lines [0] [3]. <br><br><pre> <code class="plaintext hljs"> - name: print out a single line of the output variable debug: var: output.stdout_lines[0][3]   debug-   : TASK [print out a single line of the output variable] ****************************** ok: [eos] =&gt; { "output.stdout_lines[0][3]": "System MAC address: 0800.27ec.005e" }</code> </pre><br>  Apa gunanya penomoran daftar dan mengapa itu diperlukan?  Faktanya adalah bahwa dalam tugas yang sama Anda dapat menjalankan beberapa tim, misalnya, seperti ini (di sini kami memiliki tiga tim): <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show version - show ip int br - show int status register: output - name: print out command debug: var: output.stdout_lines</code> </pre><br>  Seperti inilah hasilnya: <br><br><pre> <code class="plaintext hljs"> "output.stdout_lines": [ [ "Arista vEOS", "Hardware version: ", "Serial number: ", "System MAC address: 0800.27ec.005e", "", "Software image version: 4.20.1F", "Architecture: i386", "Internal build version: 4.20.1F-6820520.4201F", "Internal build ID: 790a11e8-5aaf-4be7-a11a-e61795d05b91", "", "Uptime: 1 day, 4 hours and 20 minutes", "Total memory: 2017324 kB", "Free memory: 1111104 kB" ], [ "Interface IP Address Status Protocol MTU", "Ethernet1 172.16.1.1/24 up up 1500", "Management1 192.168.2.10/24 up up 1500" ], [ "Port Name Status Vlan Duplex Speed Type Flags", "Et1 connected routed full unconf EbraTestPhyPort ", "Et2 connected 1 full unconf EbraTestPhyPort ", "Et3 connected 1 full unconf EbraTestPhyPort ", "Ma1 connected routed a-full a-1G 10/100/1000" ] ]</code> </pre><br>  Di sini, daftar nomor nol adalah output dari perintah show version, daftar nomor satu adalah show ip int br output, daftar nomor dua adalah show int status output.  Yaitu, nomor daftar ditentukan oleh urutan perintah dijalankan. <br><br><table><tbody><tr><td>  <b>Tim EOS Arista</b> </td><td>  <b>Mencocokkan Daftar Output</b> </td></tr><tr><td>  tampilkan versi </td><td>  output.stdout_lines [0] </td></tr><tr><td>  tampilkan ip int br </td><td>  output.stdout_lines [1] </td></tr><tr><td>  tampilkan status int </td><td>  output.stdout_lines [2] </td></tr></tbody></table><br><h3>  Penskalaan modul perintah: variabel host </h3><br>  Dan apa yang terjadi jika Anda menjalankan playbook pada beberapa perangkat secara bersamaan? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9g/e0/ap/9ge0apzkt1vioj3gtttw2eivili.png"></div><br><br>  Agar unik, variabel output disimpan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel host</a> untuk setiap host dalam inventaris.  Jika kita memiliki tiga switch, dan kita menjalankan playbook kita pada mereka, kita akan mendapatkan variabel output untuk setiap host yang unik.  Misalkan kita memerlukan alamat IP dari perintah show ip int br untuk port Ethernet1 pada switch03.  Karena show ip int br adalah perintah kedua yang berjalan sebagai bagian dari tugas, dan data Ethernet1 terkandung di baris kedua dari outputnya, kita perlu menulis stdout_lines [1] [1].  Untuk mengakses variabel host tertentu, kami menggunakan kata kunci hostvars dan mencari host yang kami butuhkan berdasarkan nama. <br><br>  Inilah cara melakukannya: <br><br><pre> <code class="plaintext hljs"> - name: debug hostvar debug: var: hostvars["switch03"].output.stdout_lines[1][1]</code> </pre><br>  Akibatnya, output berisi apa yang kita butuhkan: <br><br><pre> <code class="plaintext hljs">TASK [debug hostvar] *************************************************************** ok: [switch03] =&gt; { "hostvars[\"switch03\"].output.stdout_lines[1][1]": "Ethernet1 172.16.1.3/24 up up 1500" }</code> </pre><br>  Secara default, tugas menggunakan variabel host saat ini, tetapi hostvars memungkinkan Anda untuk secara langsung mengakses variabel host lain. <br><br><h3>  Kondisi dalam tugas dengan modul perintah: wait_for parameter </h3><br>  Parameter wait_for memungkinkan Anda untuk mengimplementasikan pemeriksaan kondisi segera setelah perintah dijalankan.  Misalnya, untuk membuat tugas dianggap berhasil diselesaikan hanya jika output dari perintah pemeriksaan status berisi teks tertentu.  Secara default, parameter wait_for tidak digunakan, sehingga tugas hanya berjalan sekali, seperti pada contoh di atas.  Tetapi jika Anda mengaturnya secara eksplisit, tugas akan dimulai kembali hingga kondisi terpenuhi atau batas upaya terlampaui (ada 10 secara default).  Jika Anda mengaktifkan pembuatan perintah, Anda dapat melihat bahwa di playbook di bawah ini (yang ditulis secara khusus sehingga kondisinya tidak berlaku), semuanya terjadi begitu saja. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: execute Arista eos command eos_command: commands: - show int status wait_for: - result[0] contains DURHAM</code> </pre><br>  Playbook ini akan menjalankan perintah show int status 10 kali, karena outputnya tidak akan pernah mengandung baris DURHAM. <br><br>  Anda dapat memverifikasi ini menggunakan perintah show logging: <br><br><pre> <code class="plaintext hljs">Mar 24 20:33:52 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=17 start_time=1521923632.5 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:53 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=18 start_time=1521923633.71 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:54 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=19 start_time=1521923634.81 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:55 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=20 start_time=1521923635.92 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:56 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=21 start_time=1521923636.99 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:58 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=22 start_time=1521923638.07 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:33:59 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=23 start_time=1521923639.22 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:00 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=24 start_time=1521923640.32 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:01 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=25 start_time=1521923641.4 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status Mar 24 20:34:02 eos Aaa: %ACCOUNTING-6-CMD: admin vty6 192.168.2.1 stop task_id=26 start_time=1521923642.47 timezone=UTC service=shell priv-lvl=15 cmd=show interfaces status</code> </pre><br>  Sekarang mari kita lihat contoh buku pedoman nyata di mana semuanya dikonfigurasi untuk membangun lingkungan OSPF (kedekatan) dengan perangkat selain perintah ip ospf area.  Kami akan menggunakan perintah ini dan kemudian menggunakan parameter wait_for untuk memeriksa keberadaan kata FULL di output: jika ada, maka lingkungan telah berhasil dibuat.  Jika FULL tidak muncul dalam 10 upaya, tugas akan gagal. <br><br><pre> <code class="plaintext hljs">--- - hosts: eos connection: network_cli tasks: - name: turn on OSPF for interface Ethernet1 eos_config: lines: - ip ospf area 0.0.0.0 parents: interface Ethernet1 - name: execute Arista eos command eos_command: commands: - show ip ospf neigh wait_for: - result[0] contains FULL</code> </pre><br>  Jalankan playbook ini menggunakan perintah ansible-playbook: <br><br><pre> <code class="plaintext hljs">➜ ansible-playbook ospf.yml PLAY [eos] ********************************************************************************************* TASK [turn on OSPF for interface Ethernet1] ******************************************************* changed: [eos] TASK [execute Arista eos command] **************************************************************** ok: [eos] PLAY RECAP ****************************************************************************************** eos : ok=2 changed=1 unreachable=0 failed=0</code> </pre><br>  Kami melihat baris perintah dan melihat bahwa playbook berhasil: <br><br><pre> <code class="plaintext hljs">eos#show ip ospf neigh Neighbor ID VRF Pri State Dead Time Address Interface 2.2.2.2 default 1 FULL/DR 00:00:33 172.16.1.2 Ethernet1</code> </pre><br>  Selain mengandung, Anda dapat menggunakan operator perbandingan berikut: <br><br><ul><li>  eq: - sama </li><li>  neq: - tidak sama </li><li>  gt: - lebih banyak </li><li>  ge: - lebih besar dari atau sama dengan </li><li>  lt: - kurang </li><li>  le: - kurang dari atau sama dengan </li></ul><br>  Selain itu, bersama dengan wait_for, Anda dapat menggunakan tiga parameter tambahan, (dijelaskan secara rinci dalam dokumentasi untuk modul): <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Deskripsi</b> </td></tr><tr><td>  interval </td><td>  Waktu antar repetisi tim. </td></tr><tr><td>  coba lagi </td><td>  Maks  jumlah pengulangan sebelum tugas selesai dengan kesalahan, atau kondisi terpenuhi. </td></tr><tr><td>  cocok </td><td>  Kebetulan dari semua kondisi atau setidaknya satu. </td></tr></tbody></table><br>  Mari kita membahas lebih detail tentang parameter kecocokan: <br><br><pre> <code class="plaintext hljs"> - name: execute Arista eos command eos_command: commands: - show ip ospf neigh match: any wait_for: - result[0] contains FULL - result[0] contains 172.16.1.2</code> </pre><br>  Ketika kecocokan: ada yang ditentukan, tugas dianggap berhasil jika hasilnya berisi FULL atau 172.16.1.2.  Jika cocok: semua ditentukan, maka hasilnya harus mengandung FULL dan 172.16.1.2.  Secara default, cocok: semua digunakan, karena jika Anda meresepkan beberapa kondisi, maka kemungkinan besar Anda ingin semuanya dieksekusi, dan bukan setidaknya satu. <br><br>  Kapan bisa cocok: ada yang berguna?  Misalkan Anda perlu memverifikasi bahwa pusat data memiliki koneksi dua arah ke Internet.  Dan pusat data terhubung ke lima penyedia Internet yang berbeda, masing-masing memiliki koneksi BGP sendiri.  Buku pedoman dapat memeriksa semua lima koneksi ini, dan jika setidaknya salah satu dari mereka berfungsi, dan tidak semua lima, melaporkan bahwa semuanya beres.  Ingatlah bahwa ada yang logis ATAU, dan semuanya adalah DAN logis. <br><br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>Deskripsi</b> </td></tr><tr><td>  cocok: apa saja </td><td>  Logis "atau" <br>  Setidaknya satu syarat diperlukan </td></tr><tr><td>  cocok: semua </td><td>  Logis "dan" <br>  Semua persyaratan diperlukan </td></tr></tbody></table><br><h3>  Kondisi negatif: membangun logika terbalik </h3><br>  Terkadang penting bukan apa yang ada di kesimpulan, tetapi apa yang tidak ada di sana.  Di sini, tentu saja, selalu tergoda untuk menggunakan operator perbandingan neq, tetapi untuk beberapa skenario dengan kondisi negatif ada opsi yang lebih baik.  Misalnya, jika Anda perlu membalikkan pernyataan berisi (tipe, "output dari perintah tidak boleh mengandung ini dan itu"), Anda dapat menggunakan kata kunci register untuk menyimpan output, dan kemudian memprosesnya di tugas berikutnya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi when</a> .  Atau, misalnya, ketika Anda harus menghentikan playbook jika kondisinya tidak terpenuhi, cukup gunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gagal</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfirmasi</a> untuk keluar secara khusus dengan kesalahan.  Adapun operator perbandingan neq, itu hanya berguna ketika Anda dapat mengekstraksi nilai yang tepat dari output (misalnya, dari pasangan nilai kunci atau dari JSON), dan bukan hanya string atau daftar string.  Jika tidak, perbandingan karakter dengan string akan dilakukan. <br><br><h3>  Apa selanjutnya </h3><br>  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> tentang bekerja dengan output perintah dalam modul jaringan.  Ini memberikan contoh berguna menggunakan ge, file, dan kondisi lainnya ketika bekerja dengan output format JSON pada platform jaringan tertentu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438312/">https://habr.com/ru/post/id438312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438298/index.html">Mengapa mengajar jika berkembang lebih menguntungkan. Percakapan dengan GeekBrains</a></li>
<li><a href="../id438302/index.html">Kreativitas luar biasa dari evolusi digital</a></li>
<li><a href="../id438304/index.html">Subkontrak? Keren, Anda memukul</a></li>
<li><a href="../id438306/index.html">Radiasi: Laboratorium radiokimia hari kerja</a></li>
<li><a href="../id438310/index.html">Instagram menggunakan pembelajaran mesin untuk menghapus pengikut palsu</a></li>
<li><a href="../id438314/index.html">1. Periksa Point Maestro Hyperscale Network Security - platform keamanan baru yang dapat diskalakan</a></li>
<li><a href="../id438316/index.html">Dasar-dasar Bidang Jarak yang Ditandatangani dalam 2D</a></li>
<li><a href="../id438318/index.html">Cara menguasai async / menunggu sintaks: contoh nyata</a></li>
<li><a href="../id438320/index.html">Mengajar anak-anak ke program</a></li>
<li><a href="../id438322/index.html">VSaaS 2025: Teknologi CCTV masa depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>