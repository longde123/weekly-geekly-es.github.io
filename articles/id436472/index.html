<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¬ ğŸ“Ÿ ğŸŒ Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows. Bagian 1 ğŸŒ† âš«ï¸ ğŸ¤¶ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, saya Zach Feysel, saya akan berbicara dengan cepat, jika terlalu cepat, Anda dapat memperlambat saya. Pada siang hari, saya seorang pentester, pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/436472/"> Hai, saya Zach Feysel, saya akan berbicara dengan cepat, jika terlalu cepat, Anda dapat memperlambat saya.  Pada siang hari, saya seorang pentester, pada malam hari saya seorang DJ dan fotografer, saya dapat ditemukan di Twitter menggunakan nama panggilan @zfazel.  Orang-orang selalu bertanya padaku tentang ijazah.  Saya bukan salah satu dari orang-orang yang mendaftar beberapa derajat, jadi sebaiknya Anda menilai saya berdasarkan presentasi ini, dan bukan berdasarkan jumlah sertifikat yang saya miliki. <br><br><img src="https://habrastorage.org/webt/l3/kp/2g/l3kp2gz0xpfmgdk12en8bqyi4yq.jpeg"><br><br>  Sebuah komentar tanpa malu-malu: kita memiliki sedikit kompetisi di sini, saat ini orang-orang dari Chicago berada di jalur 4, kita semua dari Chicago, dengan cepat angkat tangan yang ada di sini dari Chicago.  Jadi, saya pikir saya kehilangan taruhan.  Saya akan menjadi DJ malam ini di kolam renang, jadi jika Anda bebas, selamat datang ke pertempuran dengan Kate Myers, setelah itu saya akan kembali ke Chicago untuk konferensi hacker lain.  Tahun lalu, 500 orang hadir, tahun ini kami berharap akan ada lebih banyak tamu.  312 orang saya juga akan ada di sana, informasi lebih lanjut tentang konferensi ini dapat ditemukan di thotcon.org. <br><br>  Jadi, agar tidak membuang waktu: kita akan berbicara tentang alternatif untuk serangan Pass-the-hash yang disebut NTLM-Relay, tentang seperangkat alat baru untuk antar-protokol Cross Protocol Relaying transmisi untuk permintaan otentikasi NTLM, tentang metode baru otentikasi klien otomatis dan tentang baru tujuan yang dapat Anda gunakan Pass-the-hash. <br>  Mari kita mulai dengan NTLM, bagi mereka yang tidak tahu apa itu NTLM 101, keseluruhan poin dapat dinyatakan dalam waktu kurang dari 10 menit.  Jadi apa itu LM / NTLM?  Ini adalah repositori kata sandi dan protokol otentikasi jaringan yang dikembangkan oleh Microsoft untuk digunakan pada Windows.  Sial, slide-slide saya rusak!  Jadi, hash LM adalah format untuk menyimpan kata sandi pengguna yang panjangnya kurang dari 15 karakter, kata sandi dibagi menjadi 2 bagian dari 7 byte dan dikonversi ke huruf besar.  Saya harap Anda bisa melihat seperti apa hash LM dan NTLM.  Saya tidak akan membuang waktu untuk mengatakan betapa buruk dan lemahnya LM, Anda semua tahu ini, dan jika tidak, google saja. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/jl/rk/ge/jlrkge7x_ler-llqlbl4chy6jn8.jpeg"><br><br>  Hash NTLM biasanya case sensitif, memiliki panjang tidak terbatas, tidak dibagi menjadi kelompok karakter, dan sedikit lebih kuat dari LM, tetapi juga bukan tanpa masalah.  Sekarang saya akan berbicara tentang mereka.  Kerentanan pertama adalah kemungkinan serangan Pass-the-hash, yang memungkinkan hacker untuk masuk ke server jauh yang menggunakan otentikasi klien berdasarkan protokol NTLM / LM.  Maaf, teman-teman, saya mencampur slide, saya membuatnya 5 menit yang lalu, singkatnya, LM payah. <br><br>  Jadi apa otentikasi NTLM?  Ini adalah otentikasi jaringan untuk layanan jarak jauh.  Dia diperlukan untuk membuktikan bahwa Anda benar-benar panggilan Anda sendiri.  Layanan ini biasanya berjalan di komputer terpisah, di mana Anda ingin mengakses sumber daya yang ditawarkan oleh layanan, misalnya, file server adalah layanan, dan file adalah sumber daya.  Sebentar lagi kita akan melihat apa layanan ini. <br><br>  Kita dapat menjadi bingung ketika kita berbicara tentang NTLM v1, v2, NTLM 2, apakah ditandatangani atau tidak, jadi mari kita cepat pergi ke otentikasi NTLM.  Selama otentikasi, 3 jenis pesan dikirim. <br><br><img src="https://habrastorage.org/webt/xr/ub/mp/xrubmplrjtbebui7zomdfqkeuzu.jpeg"><br><br>  Tipe 1 adalah permintaan klien ke server untuk membuat kontak, sesuatu seperti "Saya ingin mengotentikasi".  Anda melihat paket diambil berkeping-keping, ditangkap oleh Wireshark, ada bendera untuk mendukung otentikasi, nama workstation dan nama domainnya. <br><br>  Pesan tipe 2 adalah respons server.  Jika Anda perhatikan dari pesan Tipe 1 yang belum kami ketahui siapa pengguna ini, ia hanya meminta untuk terhubung ke server dan ingin mencari tahu apakah permintaan tersebut didukung. <br><br><img src="https://habrastorage.org/webt/wl/j0/v0/wlj0v0bz-jkpsykoklolampo0x8.jpeg"><br><br>  Anda lihat di sini respons server NTML Challenge sebagai sekumpulan angka yang berubah setiap saat.  Tangkapan layar menunjukkan jawaban statis yang dapat digunakan untuk membuat "tabel pelangi".  Jadi, server merespons dengan pesan dari tipe kedua: "ini yang saya dukung, ini nama domain saya, ini nama server saya".  Jawaban ini digunakan untuk "memberi garam" hash kata sandi Anda, jadi setiap kali jawaban unik diperoleh, dan Anda tidak dapat mengulanginya lagi dan lagi dengan permintaan yang sama. <br><br>  Pesan Tipe 3 - ini adalah pesan otentikasi klien. <br><br><img src="https://habrastorage.org/webt/mg/of/a8/mgofa83tlvbkexds9ksby3d4osu.jpeg"><br><br>  Ini adalah respons dari server, yang di hash dengan hash kata sandi untuk hash NTML bersama dengan nama pengguna, nama workstation dan nama domain dan kunci sesi, jika Anda menandatangani sesi. <br><br>  Ini adalah apa itu NTML versi 1. NTML versi 2 sangat mirip dengan itu, tetapi ada menambahkan parameter tambahan dalam kata sandi respons dan memanggil klien untuk melindungi terhadap penggunaan "tabel pelangi", yaitu, klien menggunakan elemen keacakan terhadap mereka. <br><br>  Hal lain yang perlu kita bicarakan adalah otentikasi Windows terintegrasi.  Diperlukan agar setiap kali Anda tidak harus memasukkan kembali sistem dengan kata sandi untuk menggunakan sumber daya dan layanan.  Jika Anda terhubung ke server domain atau server web internal, Windows tidak meminta Anda untuk memasukkan kata sandi, itu hanya meminta API dan menerima informasi dari itu bahwa sistem harus digunakan untuk otentikasi. <br>  Dalam konteks keamanan lokal, HTTP melindungi dengan menggunakan zona keamanan tepercaya, situs tepercaya, atau situs lokal dengan hanya memeriksa nama domain satu kata.  Saya akan mencoba menyegarkan ingatan Anda dengan cepat.  Satu kata domain pertama mencari nama DNS di server DNS, kemudian memeriksa host atau nama host DNS dan mengembalikannya.  Ia memeriksa struktur nama lengkap Anda dan kemudian melakukan NBNS, yang merupakan permintaan siaran untuk nama domain ini.  Bahkan, ia bertanya kepada jaringan: "Hei, saya mencari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nama</a> , apakah Anda kenal seseorang dengan nama itu?", Mendistribusikan permintaan ini melalui jaringan lokal dalam mode siaran multimedia MBNS. <br><br>  Seperti yang saya katakan, karena kami menggunakan protokol SMB di mana-mana, tidak ada batasan, kami hanya memiliki autentikasi otomatis menggunakan SMB.  Ini menyebabkan beberapa masalah. <br><br>  Pertimbangkan metode Pass-the-hash.  Dapat dilihat dari protokol bahwa NTML tidak menggunakan kata sandi asli untuk otentikasi, jadi yang kita butuhkan adalah hash NTML itu sendiri.  Kita dapat mengakses hash NTML menggunakan berbagai alat Windows, yaitu, tarik hash ini dari penyimpanan lokal atau dari memori.  Semua ini dijelaskan dalam pidato lain, saya akan segera mengingatkan Anda tentang esensi masalah ini untuk menunjukkan perbedaan antara kedua metode. <br>  Faktanya adalah bahwa biasanya untuk Pass-the-hash ini Anda memerlukan akses di tingkat administrator sistem lokal, karena dengan akun tamu Anda tidak akan mendapatkan akses ke penyimpanan lokal atau memori lokal. <br><br>  Jadi, apa itu NTLM Relaying dan apa bedanya dengan metode Pass-the-hash?  Mereka terus-menerus memberi tahu saya: "Ah, Anda berbicara tentang Pass-the-hash!", Dan saya menjawab: "Tidak, saya berbicara tentang NTLM Relaying!".  Perbedaannya adalah bahwa NTLM Relaying tidak memerlukan hak administrator untuk mengakses jaringan atau sistem.  Bahkan, Anda terhubung ke jaringan dari dalam atau luar dan mulai bekerja sebagai tamu.  Tidak ada kredensial, tidak ada akses ke sistem, hanya permintaan yang dikonfirmasi jika Anda kembali ke jenis pesan 1,2,3 di atas.  Tidak ada verifikasi ketika tuan rumah menanggapi permintaan Anda dan memastikan bahwa Anda adalah Anda. <br>  Apa yang kami lakukan adalah membuat server penipuan untuk menerima permintaan otentikasi dan kemudian menyampaikannya ke server target. <br><br>  Mari kita dengarkan ceritanya sehingga Anda memahami inti dari masalah ini.  Kembali pada tahun 1996, ketika Dominic Brezinsky menemukan kerentanan dalam proses otentikasi menggunakan protokol akses CIFS, versi pertama dari protokol SMB.  Setelah itu, mereka pertama kali berbicara tentang kemungkinan menggunakan NTLM Relay.  Pada tahun 2001, NTLM berhasil menemukan lubang di SMB.  Pertama, karyawan Veracode Christian Ryu (alias Dildog) mengatakan ini di konferensi DefCon, dan kemudian peretas Josh Bushbinder (alias Sir Dystic) menerbitkan kode eksploit yang bekerja dengan kerentanan ini.  Kami menggunakan protokol Telnet dan kerentanan browser IE, di mana Anda bisa mengetikkan telnet: // ip dan secara otomatis mengautentikasi. <br><br><img src="https://habrastorage.org/webt/mn/z5/mc/mnz5mcfwjyklsnbgafwv6rkqtoq.jpeg"><br><br>  Setelah itu, metode NTLM Relaying mulai digunakan untuk mengarahkan permintaan SMB ke host lain atau ke host sendiri.  Ini berlanjut sampai November 2008, ketika Microsoft Windows menambal lubang di mana mereka bisa, mencegah permintaan otentikasi NTLM kembali dengan patch MS08-068. <br><br>  Jadi, kami kehilangan kemampuan untuk mengembalikan permintaan otentikasi ke host kami dan hanya bisa meneruskannya ke host lain karena fitur desain protokol.  Pada tahun 2008, seorang pria dengan nama panggilan Grutz membuat pernyataan tentang kematian DefLon NTLM.  Saya pikir ini adalah salah satu pertunjukan terbaik dalam beberapa tahun terakhir, karena memiliki dampak besar pada lingkungan perusahaan. <br><br><img src="https://habrastorage.org/webt/2a/3o/jt/2a3ojthljjqouilw7tkxdyhrkww.jpeg"><br><br>  Dia menyebut instrumennya nama Pokemon Squirtle, dan teknologi - "monyet di tengah" dengan analogi dengan "manusia di tengah".  Alat ini memungkinkan Relay NTLM untuk dieksekusi melalui HTTP dan juga bekerja dengan baik dengan SMB, menerima permintaan otentikasi. <br><br><img src="https://habrastorage.org/webt/zk/vw/0b/zkvw0bevvlrf-tkgcgofh2myqge.jpeg"><br><br>  Tangkapan layar ini diambil dua hari lalu, dan pengembangan aplikasi Squirtle-nya masih berlangsung.  Saya memutuskan bahwa Anda semua akrab dengan kerentanan ini, masalah yang sedang kita bicarakan berulang-ulang, karena mereka tidak dapat diperbaiki dengan cara apa pun dan memanifestasikan diri di mana-mana.  Saya termasuk dalam lingkungan perusahaan, oleh karena itu saya menyadari masalah yang terus saya keluhkan - bahwa situs tidak melakukan enkripsi SSL permintaan otentikasi, sama seperti mereka tidak mengenkripsi cookie mereka.  Pada 2010, ekstensi browser Firefox bernama Firesheep dirilis. <br><br>  Anda mungkin akrab dengan alat ini untuk mencegat cookie HTTP tidak terenkripsi dari situs web populer dan sesi lain dari bekerja dengan situs melalui Wi-Fi atau jaringan mengendus, menyamar sebagai pengguna lain. <br><br><img src="https://habrastorage.org/webt/bq/wp/fk/bqwpfk8n_ufmlqpudkkukju9iqc.jpeg"><br><br>  Saya bertanya pada diri sendiri, dari mana orang mendapat dorongan untuk membuat alat seperti itu.  Ternyata itu semua tentang kemudahan penggunaan.  Cukup mudah untuk membuat aplikasi yang memungkinkan Anda menyamar sebagai orang lain.  Jadi saya memutuskan untuk memulai dari yang sama dan membuat aplikasi yang akan memungkinkan menggunakan metode Relay NTLM untuk menunjukkan kepada orang-orang bahwa itu sesederhana Firesheep. <br><br><img src="https://habrastorage.org/webt/rk/we/3g/rkwe3gmeq7t-edqk0jno3qqzwyu.jpeg"><br><br>  Saya mulai mengerjakan Relay NTLM untuk melihat bagaimana dukungan multi-protokol dimungkinkan.  Banyak orang berbicara tentang kemungkinan teoretis dari dukungan semacam itu, tetapi tidak ada yang mempraktikkannya.  Jadi, tujuan saya adalah membuat Firesheep untuk NTLM. <br>  Saya memutuskan untuk mulai belajar Ruby karena pada awalnya saya akan mengintegrasikan exploit saya ke Metasploit.  Pada 2012, saya ingin membahas topik ini di konferensi Black Hat dan DefCon, tetapi laporan saya ditolak.  Pidato saya tidak hanya ditolak, saya menerima email palsu bahwa DefCon menerima laporan saya.  Seorang teman berpikir akan sangat lucu untuk menjebak saya, dia benar-benar idiot.  Dia punya teman di sini yang kinerjanya disetujui, dan teman saya mengambil dan mengirimi saya isi emailnya.  Saya tidak memperhatikan tajuk, yang bertuliskan "Dari Nikita" dan panik, menyadari bahwa saya harus berbicara di DefCon dalam satu setengah jam, tetapi kemudian saya menerima surat nyata dengan penolakan. <br><br>  Apakah Anda pikir ini mengakhiri ceritanya?  Tidak, tiga minggu kemudian Nikita memberi tahu saya: "hei, kita ada pembukaan pada hari Minggu, seseorang menolak untuk berpartisipasi, apakah Anda ingin berbicara di tempatnya?"  Saya pikir itu baik-baik saja, tetapi kemudian saya menyadari bahwa saya memiliki waktu yang sangat sedikit sebelum pertunjukan, dan mulai membuat kode seperti orang gila, mencoba menyelesaikan semuanya tepat waktu. <br><br>  Jadi apa masalah saya?  Pertama, alat asing tidak dapat melakukan pekerjaan Pentester yang saya butuhkan, mereka sangat kekurangan berbagai protokol yang dapat mengembalikan permintaan otentikasi.  Sebagian besar protokol terkait dengan penggunaan SMB dan HTTP, dan tidak ada satupun yang mendukung LDAP untuk otentikasi MySQL, atau setidaknya menguji remote desktop, VPN, dan sejenisnya. <br><br>  Masalah lain adalah mereka semua meneruskan setiap permintaan ke tujuan yang sama.  Artinya, kami menerima data pengguna, akun komputer, dan mengirim semua otentikasi ke satu tujuan, oleh karena itu, kami tidak dapat mengidentifikasi pengguna sebelum otentikasi, yaitu, sebelum menerima pesan Tipe 3.  Jika Anda mengingat pesan-pesan ini dari tipe 1,2,3, maka pesan dari Tipe 2 adalah respons dari server.  Ini unik untuk setiap sesi, dan saya tidak tahu siapa pengguna ini sampai mereka mengirim pesan Tipe 3 terakhir, dan saya tidak tahu jawaban mana dan dari server mana pengguna itu.  Saya tertarik pada mengapa tidak ada alat yang akan melakukan ini, jadi saya melihat lebih dekat pada protokol seperti SMB dan HTTP, nanti kita akan membicarakan hal ini lebih detail. <br><br>  Windows 8 dan Windows 2012 masih mendukung NTLM secara default.  Ini menakutkan karena kita tahu tentang kerentanan protokol-protokol ini, tetapi NTLM belum hilang.  Karena itu, kami, sebagai pentester, memberi tahu organisasi bahwa mereka harus melindungi diri dari serangan semacam itu. <br>  Jadi, saya ingin menyelesaikan masalah ini dan membuat alat bernama ZackAttack.  Saya tahu itu terlihat jelek, tapi kami melewati banyak nama, saya pribadi paling suka yang terakhir - â€œNTLMv2?  Jalang Tolong ... ". <br><br><img src="https://habrastorage.org/webt/m-/2t/ho/m-2tho0orjti9rj9ytmo0su1jv0.jpeg"><br><br>  Apa yang terkandung dalam alat ini?  Saya akan dengan cepat membahas slide ini, karena saya pikir Anda sudah cukup terhibur.  Zacktttt terdiri dari beberapa komponen yang berbeda, kita akan berbicara tentang masing-masing komponen dan bagaimana mereka terkait satu sama lain. <br><br>  Pertama-tama, ada server HTTP SMB - ini adalah server penipuan yang menerima permintaan otentikasi.  Jadi klien menargetkan server ini, mengautentikasi, dan server membuat mereka tetap diautentikasi.  Selanjutnya, kami memiliki seperangkat aturan untuk operasi otomatis. <br><br>  Kami memiliki klien untuk eksploitasi otomatis semacam itu, serta API yang dapat kami asosiasikan dengan aplikasi pihak ketiga mana pun yang mentransfer permintaan Relay NTLM. <br><br><img src="https://habrastorage.org/webt/1o/xt/om/1oxtompzqtshvinccoxpb1yfzwe.jpeg"><br><br>  Akhirnya, kami memiliki generasi muatan yang memaksa pelanggan untuk mengotentikasi kami secara otomatis. <br><br>  Apa itu server penipuan?  Pertama, mereka mengotentikasi pengguna dan menyimpannya untuk kami, kemudian saya akan memberi tahu Anda bagaimana kami menggunakannya. <br><br><img src="https://habrastorage.org/webt/c2/ik/io/c2ikiockvkztijbnn4e-kcqg6ke.jpeg"><br><br>  Kami membutuhkan semua orang ini untuk mempertahankan status otentikasi mereka.  Ada banyak alat yang menonaktifkan pengguna setelah otentikasi pertama yang berhasil, tetapi alat ZackAttack kami membuat pengguna diautentikasi selama mungkin.  Pada Windows LAN untuk SMB, ini sekitar 30 kali sebelum koneksi terputus.  Jadi, kita perlu mencari tahu siapa pengguna ini, sambil tetap mengotentikasi dia. <br><br>  Permintaan otentikasi pertama adalah panggilan statis tipe 112233. Anda yang terlibat dalam pentesting tahu bahwa ini adalah jenis tugas untuk "tabel pelangi".  Seperti yang saya katakan, kita perlu mencari tahu siapa pengguna ini, tetapi kita tidak mengetahuinya, sampai kita sampai pada pesan Tipe 3, jadi kami mengirim banyak panggilan.  Saya menyebutnya "elemen Alzheimer" ketika sistem lupa siapa pengguna itu dan memintanya untuk mengotentikasi setiap kali terhubung tanpa menutup sesi. <br><br>  Alasan mengapa kami melakukan ini adalah karena HTTP, WPAD, dan permintaan lainnya tidak selalu mendukung cookie, selain itu, identifikasi SMB melalui IP atau port sumber Source Port tidak berfungsi jika Anda mencoba melakukannya dari jarak jauh melalui Internet. <br><br>  Oleh karena itu, untuk server HTTP, kami menggunakan 302 redirect dengan parameter Keep-Alive, yang memungkinkan kami untuk menjaga sesi tetap terbuka saat soket ditutup, dan setelah kami mengautentikasi, kami tahu siapa mereka dan kami tahu ini sampai akhir sesi ini. <br><br>  Dengan SMB itu lebih sulit, saya harus menulis server SMB kustom, itu agak buggy, tetapi tetap bekerja.  Saya tidak akan menyelidiki mekanisme otentikasi protokol SMB, karena akan memakan waktu beberapa jam, jadi saya akan menjelaskan secara singkat.  Setelah server menerima permintaan otentikasi, sepertinya lupa siapa pengguna ini dan berkata: "Oh, halo, senang bertemu dengan Anda!"  "Keren, aku ingin terhubung!"  "Tunggu, dan siapa kamu?" Dan sekali lagi membutuhkan permintaan otentikasi. <br><br>  Jadi, kita perlu menerima permintaan otentikasi yang datang ke server HTTP dan SMB.  Banyak orang bertanya bagaimana kita melakukan serangan "pria di tengah".  Ada beberapa cara berbeda untuk membuat orang mengautentikasi dengan server kami, dan kemudian mengirim mereka untuk melakukan hal-hal lain.  Karena itu, pertimbangkan berapa muatan dalam alat kami. <br><br>  Pertama-tama, ini adalah WPAD - protokol untuk konfigurasi proxy otomatis, yang memungkinkan Anda untuk menentukan lokasi file konfigurasi.  Di Windows, ketika Anda mencoba untuk terhubung, seperti yang Anda tahu, sebuah jendela muncul dengan tanda centang kecil "secara otomatis menemukan pengaturan koneksi saya" yang mengaktifkan WPAD.  Protokol ini mengirimkan permintaan untuk memeriksa DNS dan siaran jaringan, sehingga Anda dapat memalsukan permintaan ini dan menanggapinya. <br><br>  Secara default, di Windows, komputer akan secara otomatis mengotentikasi server WPAD melalui HTTP dengan kredensial pengguna saat ini. <br><br>  18:00 mnt <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nHU3ujyw_sQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps hingga musim semi gratis</b> ketika membayar selama setengah tahun, Anda dapat memesan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436472/">https://habr.com/ru/post/id436472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436458/index.html">Kemajuan dan sensasi dalam penelitian ai</a></li>
<li><a href="../id436460/index.html">Pilihan teknologi, arsitektur, dan desain dalam proyek perangkat lunak - tanpa uang tunai</a></li>
<li><a href="../id436464/index.html">2. Periksa Log Analisis Titik: SmartEvent</a></li>
<li><a href="../id436466/index.html">Elektron: mengembangkan aplikasi desktop menggunakan HTML, CSS dan JavaScript</a></li>
<li><a href="../id436468/index.html">Eksperimen legislatif dengan inovasi digital</a></li>
<li><a href="../id436474/index.html">Konferensi DEFCON 20. Ambil dalam 60 detik: dari akun tamu hingga administrator domain Windows. Bagian 2</a></li>
<li><a href="../id436476/index.html">Cloud untuk perusahaan asuransi</a></li>
<li><a href="../id436480/index.html">Saya membuat bot yang berkomunikasi dengan perekrut untuk saya, dan saya suka</a></li>
<li><a href="../id436482/index.html">Lanjutan Three.js: bahan shader dan pasca-pemrosesan</a></li>
<li><a href="../id436484/index.html">Di mana menemukan pengaturan DNS pada MacOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>