<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üê§ üë®‚Äçüé§ MVCC-7. Automatische Reinigung üêØ üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üåî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich m√∂chte Sie daran erinnern, dass wir mit Problemen im Zusammenhang mit der Isolation begonnen haben , einen Exkurs √ºber das Organisieren von Daten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Automatische Reinigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Ich m√∂chte Sie daran erinnern, dass wir mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation begonnen haben</a> , einen Exkurs √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene gemacht haben</a> , ausf√ºhrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Zeilenversionen gesprochen haben</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  Dann haben wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Reinigung</a> (und die HOT-Updates) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelm√§√üige Reinigung angesehen</a> , aber heute haben wir uns die automatische Reinigung angesehen. <br><br><h1>  Automatische Reinigung (Autovakuum) </h1><br>  Wir haben bereits gesagt, dass die normale Reinigung unter normalen Bedingungen (wenn niemand lange den Transaktionshorizont h√§lt) mit seiner Arbeit fertig werden muss.  Die Frage ist, wie oft man es nennt. <br><br>  Wenn Sie einen Wickeltisch zu selten reinigen, wird er gr√∂√üer als Sie m√∂chten.  Dar√ºber hinaus kann es f√ºr die n√§chste Reinigung mehrere Durchg√§nge durch die Indizes dauern, wenn sich zu viele √Ñnderungen angesammelt haben. <br><br>  Wenn Sie die Tabelle zu oft r√§umen, wird der Server anstelle n√ºtzlicher Arbeit st√§ndig gewartet - auch nicht gut. <br><br>  Beachten Sie, dass das Starten einer regelm√§√üigen geplanten Reinigung das Problem nicht l√∂st, da sich die Last im Laufe der Zeit √§ndern kann.  Wenn die Tabelle aktiver aktualisiert wurde, sollte sie h√§ufiger gereinigt werden. <br><br>  Die automatische Reinigung ist genau der Mechanismus, mit dem Sie abh√§ngig von der Aktivit√§t der √Ñnderungen in den Tabellen mit der Reinigung beginnen k√∂nnen. <br><a name="habracut"></a><br>  Wenn die <em>automatische Reinigung</em> aktiviert ist ( <em>Autovakuum-</em> Konfigurationsparameter), ist der Autovakuum-Starterprozess immer in dem System vorhanden, das arbeiten soll, und Autovakuum-Arbeitsprozesse sind an der tats√§chlichen Reinigung beteiligt, von denen mehrere Instanzen parallel arbeiten k√∂nnen. <br><br>  Der Autovacuum Launcher-Prozess erstellt eine Liste von Datenbanken, in denen Aktivit√§ten vorhanden sind.  Die Aktivit√§t wird durch Statistiken bestimmt. Damit sie erfasst werden kann, muss der Parameter <em>track_counts</em> festgelegt werden.  <em>Schalten</em> <em>Sie</em> niemals <em>autovacuum</em> und <em>track_counts aus</em> , sonst <em>funktioniert die</em> <em>automatische</em> <em>Reinigung</em> nicht. <br><br>  In <em>autovacuum_naptime</em> startet der Autovacuum Launcher-Prozess (unter Verwendung des Postmaster-Prozesses) einen Workflow f√ºr jede Datenbank in der Liste.  Mit anderen Worten, wenn die Datenbank eine Aktivit√§t enth√§lt, werden Workflows mit einem Intervall von <em>autovacuum_naptime aufgerufen</em> .  Wenn dazu mehrere aktive Datenbanken (N Teile) vorhanden sind, werden die Arbeitsprozesse N-mal h√§ufiger gestartet als <em>autovacuum_naptime</em> .  Gleichzeitig wird die Gesamtzahl der gleichzeitig arbeitenden Workflows durch den Parameter <em>autovacuum_max_workers</em> begrenzt. <br><br>  Nach dem Start stellt der Workflow eine Verbindung zu der von ihm angegebenen Datenbank her und erstellt zun√§chst die Liste: <br><br><ul><li>  alle Tabellen, materialisierten Ansichten und Toasttabellen, die gel√∂scht werden m√ºssen, </li><li>  Alle Tabellen und materialisierten Darstellungen, die analysiert werden m√ºssen (Toasttabellen werden nicht analysiert, da immer √ºber den Index auf sie zugegriffen wird). </li></ul><br>  Ferner reinigt und / oder analysiert der Workflow die ausgew√§hlten Objekte und endet, wenn die Reinigung abgeschlossen ist. <br><br>  Wenn der Prozess nicht alle beabsichtigten Arbeiten f√ºr <em>autovacuum_naptime abgeschlossen hat</em> , <em>sendet</em> der Autovacuum Launcher-Prozess einen weiteren Workflow an dieselbe Datenbank und sie arbeiten zusammen.  "Zusammen" bedeutet einfach, dass der zweite Prozess seine Tabellenliste erstellt und dieser folgt.  Somit werden verschiedene Tabellen parallel verarbeitet, aber auf der Ebene einer Tabelle gibt es keine Parallelit√§t. Wenn einer der Arbeitsprozesse bereits an der Tabelle arbeitet, √ºberspringt der andere diese und f√§hrt fort. <br><br><blockquote>  Es wurde lange Zeit √ºber die Notwendigkeit einer parallelen Verarbeitung diskutiert, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> wurde noch nicht √ºbernommen. <br></blockquote><br>  Schauen wir uns nun genauer an, was "gereinigt werden muss" und "analysiert werden muss". <br><br><h1>  Welche Tische m√ºssen gereinigt werden? </h1><br>  Es wird angenommen, dass eine Reinigung erforderlich ist, wenn die Anzahl der "toten", dh irrelevanten Versionen von Zeichenfolgen einen festgelegten Schwellenwert √ºberschreitet.  Die Anzahl der toten Versionen wird vom Statistiksammler st√§ndig erfasst und in der Tabelle pg_stat_all_tables gespeichert.  Der Schwellenwert wird durch zwei Parameter festgelegt: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> definiert den absoluten Wert (in St√ºcken), </li><li>  <em>autovacuum_vacuum_scale_factor</em> bestimmt den Anteil der Zeilen in einer Tabelle. </li></ul><br>  Die endg√ºltige Formel lautet: Reinigung ist erforderlich, wenn pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * pg_class.reltupes. <br><br>  Die Standardeinstellungen setzen <em>autovacuum_vacuum_threshold</em> = 50 und <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  Der Hauptparameter hier ist nat√ºrlich <em>autovacuum_vacuum_scale_factor</em> - es ist wichtig f√ºr gro√üe Tabellen ( <em>dh</em> m√∂gliche Probleme sind damit verbunden).  Der Wert von 20% scheint stark √ºbersch√§tzt zu sein, h√∂chstwahrscheinlich muss er deutlich reduziert werden. <br><br>  Die optimalen Parameterwerte k√∂nnen f√ºr verschiedene Tabellen je nach Gr√∂√üe und Art der √Ñnderungen variieren.  Es ist sinnvoll, insgesamt angemessene Werte festzulegen und - falls erforderlich - die Parameter auf der Ebene einiger Tabellen mithilfe der Speicherparameter speziell zu konfigurieren: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> und <em>toast.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> und <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Um nicht verwirrt zu werden, sollte dies nur f√ºr eine kleine Anzahl von Tabellen durchgef√ºhrt werden, die sich unter anderem durch das Volumen oder die Intensit√§t der √Ñnderungen auszeichnen, und nur dann, wenn die global festgelegten Werte nicht geeignet sind. <br><br>  Dar√ºber hinaus kann die automatische Reinigung auf Tabellenebene deaktiviert werden (obwohl es schwierig ist, sich einen Grund vorzustellen, warum dies erforderlich w√§re): <br><br><ul><li>  <em>autovacuum_enabled</em> und <em>toast.autovacuum_enabled</em> . </li></ul><br>  Zum Beispiel haben wir das letzte Mal eine Vac-Tabelle mit deaktivierter automatischer Reinigung erstellt, um zu Demonstrationszwecken die manuelle Reinigung zu verwalten.  Der Speicherparameter kann wie folgt ge√§ndert werden: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Um all das zu formalisieren, erstellen wir eine Ansicht, die zeigt, welche Tabellen derzeit bereinigt werden m√ºssen.  Es wird eine Funktion verwendet, die den aktuellen Wert des Parameters zur√ºckgibt, da dieser auf Tabellenebene √ºberschrieben werden kann: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Und hier ist die Ansicht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Welche Tabellen m√ºssen analysiert werden? </h1><br>  Bei der automatischen Analyse ist die Situation ungef√§hr dieselbe.  Es wird angenommen, dass eine Analyse f√ºr diejenigen Tabellen erforderlich ist, f√ºr die die Anzahl der ge√§nderten (seit der letzten Analyse) Version der Zeilen den durch zwei √§hnliche Parameter angegebenen Schwellenwert √ºberschreitet: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * pg_class.reltupes. <br><br>  Die Standardeinstellungen f√ºr die automatische Analyse unterscheiden sich geringf√ºgig: <em>autovacuum_analyze_threshold</em> = 50 und <em>autovacuum_analyze_scale_factor</em> = 0.1.  Sie k√∂nnen auch auf der Ebene der Speicherparameter f√ºr einzelne Tabellen definiert werden: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Da Toasttabellen nicht analysiert werden, gibt es f√ºr sie keine entsprechenden Parameter. <br><br>  Erstellen wir eine Ansicht f√ºr die Analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Beispiel </h1><br>  F√ºr Experimente setzen wir folgende Parameterwerte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Erstellen Sie nun eine Tabelle √§hnlich der, die wir zuletzt verwendet haben, und f√ºgen Sie tausend Zeilen ein.  Die automatische Reinigung ist auf Tabellenebene deaktiviert und wird von uns selbst aktiviert.  Wenn dies nicht erfolgt, sind die Beispiele nicht reproduzierbar, da die automatische Reinigung m√∂glicherweise zur falschen Zeit funktioniert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  In unserer Bereinigungsansicht wird Folgendes angezeigt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Es gibt zwei Punkte, auf die Sie achten sollten.  Erstens ist max_dead_tup = 0, obwohl 3% von 1000 Zeilen 30 Zeilen sind.  Tatsache ist, dass wir noch keine Statistiken in der Tabelle haben, da INSERT selbst diese nicht aktualisiert.  Bis unsere Tabelle analysiert ist, bleiben die Nullen erhalten, da pg_class.reltuples = 0. Schauen wir uns jedoch die zweite Ansicht zur Analyse an: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Da die Tabelle 1000 Zeilen ge√§ndert (hinzugef√ºgt) hat und dies mehr als Null ist, sollte die automatische Analyse funktionieren.  √úberpr√ºfen Sie dies: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Nach einer kurzen Pause sehen wir, dass die Tabelle analysiert wird und anstelle von Nullen in max_mod_tup sehen wir die richtigen 20 Zeilen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Kehren wir zur automatischen Reinigung zur√ºck: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Wie wir sehen, wurde Max_dead_tup bereits behoben.  Der zweite Punkt, auf den Sie achten sollten, ist dead_tup = 0. Statistiken zeigen, dass die Tabelle keine toten Versionen von Zeilen enth√§lt ... und das ist wahr.  In unserem Tisch gibt es noch nichts zu reinigen.  Daher wird eine Tabelle, die nur im Nur-Anh√§ngen-Modus verwendet wird, nicht gel√∂scht, und daher wird die Sichtbarkeitskarte nicht daf√ºr aktualisiert.  Dies macht es unm√∂glich, ausschlie√ülich Index-Scannen (Nur-Index-Scan) zu verwenden. <br><br>  (Das n√§chste Mal werden wir sehen, dass die Reinigung fr√ºher oder sp√§ter zum Nur-Anh√§ngen-Tisch kommt, aber dies wird sehr selten vorkommen.) <br><br>  Praktische Schlussfolgerung: Wenn es wichtig ist, nur das Index-Scannen zu verwenden, m√ºssen Sie m√∂glicherweise eine manuelle Reinigung anfordern. <br><br>  Schalten Sie nun die automatische Reinigung wieder aus und aktualisieren Sie die Zeile 31 - eine mehr als der Schwellenwert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Jetzt ist die Bedingung zum Ausl√∂sen der automatischen Reinigung erf√ºllt.  Aktivieren Sie die automatische Reinigung und nach einer kurzen Pause sehen wir, dass die Tabelle verarbeitet wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Lastregelung </h1><br>  Die Bereinigung blockiert keine anderen Prozesse, da sie seitenweise arbeitet, das System jedoch belastet und die Leistung sp√ºrbar beeintr√§chtigt. <br><br><h2>  Regelung zur regelm√§√üigen Reinigung </h2><br>  Um die Intensit√§t der Reinigung und damit deren Auswirkung auf das System steuern zu k√∂nnen, wechselt der Prozess zwischen Arbeit und Erwartung.  Die Reinigung f√ºhrt ungef√§hr <em>vakuum_Kosten_Limit</em> konventionelle Arbeitseinheiten aus und schl√§ft dann bei <em>Vakuum_Kostenverz√∂gerung</em> ms ein. <br><br>  Die Standardeinstellungen setzen <em>vakuum_Kostenlimit</em> = 200, <em>Vakuum_Kostenverz√∂gerung</em> = 0. Die letzte Null bedeutet tats√§chlich, dass die (normale) Reinigung nicht einschl√§ft, sodass der spezifische Wert von <em>Vakuum_Kostenlimit</em> keine Rolle spielt.  Dies geschieht aus dem Grund, dass der Administrator, wenn er VACUUM manuell starten musste, die Bereinigung wahrscheinlich so schnell wie m√∂glich durchf√ºhren m√∂chte. <br><br>  Wenn Sie dennoch die <em>Ruhezeit festlegen</em> , besteht der in <em>vakuum_Kostenlimit</em> angegebene <em>Arbeitsaufwand</em> aus den Kosten f√ºr die Arbeit mit Seiten im <em>Puffercache</em> .  Jeder Seitenzugriff wird wie folgt bewertet: <br><br><ul><li>  Wenn die Seite im <em>Puffercache</em> gefunden wurde, ist <em>vacac_cost_page_hit</em> = 1; </li><li>  wenn nicht gefunden, dann <em>vacuum_cost_page_miss</em> = 10; </li><li>  Wenn Sie es nicht finden konnten und die verschmutzte Seite aus dem Puffer schieben mussten, ist <em>vacac_cost_page_dirty</em> = 20. </li></ul><br>  Das hei√üt, mit den Einstellungen f√ºr <em>vakuum_Kostenlimit</em> k√∂nnen standardm√§√üig 200 Seiten aus dem Cache oder 20 Seiten von der Festplatte oder 10 Seiten mit Extrusion in einer Sitzung verarbeitet werden.  Es ist klar, dass dies eher willk√ºrliche Zahlen sind, aber es macht keinen Sinn, sie genauer auszuw√§hlen. <br><br><h2>  Regelung zur automatischen Reinigung </h2><br>  Die Lastregelung w√§hrend der automatischen Reinigung funktioniert genauso wie bei der regul√§ren Reinigung.  Damit manuelle <em>Reinigung</em> und <em>automatische</em> Reinigung mit unterschiedlichen Intensit√§ten arbeiten k√∂nnen, haben Autoprozesse ihre eigenen Parameter: <em>autovacuum_vacuum_cost_limit</em> und <em>autovacuum_vacuum_cost_delay</em> .  Wenn diese Parameter den Wert -1 annehmen, wird der Wert von <em>vakuum_Kostenlimit</em> und / oder <em>Vakuumkostenverz√∂gerung verwendet</em> . <br><br>  Standardm√§√üig ist <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>dh</em> der Wert <em>vakuum_cost_limit</em> = 200 wird verwendet) und <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Bei modernen Ger√§ten mit diesen Nummern funktioniert die automatische Reinigung sehr, sehr langsam. <br><br>  In Version 12 wird der Wert von <em>autovacuum_vacuum_cost_delay</em> auf 2 ms reduziert, was als geeignetere erste Ann√§herung angesehen werden kann. <br><br>  Dar√ºber hinaus ist zu beachten, dass die durch diese Parameter festgelegte Grenze allen Arbeitsprozessen gemeinsam ist.  Mit anderen Worten, wenn sich die Anzahl der gleichzeitigen Arbeitsprozesse √§ndert, bleibt die Gesamtlast konstant.  Wenn die Aufgabe darin besteht, die Leistung der <em>automatischen Reinigung</em> zu erh√∂hen, lohnt es sich daher, beim Hinzuf√ºgen von Workflows das <em>autovacuum_vacuum_cost_limit</em> zu erh√∂hen. <br><br><h2>  Speichernutzung und √úberwachung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten Mal haben</a> wir uns angesehen, wie beim Bereinigen der RAM-Speicher der Gr√∂√üe <em>wartung_work_mem verwendet wird</em> , um die Versionskennungen der zu bereinigenden Zeilen zu speichern. <br><br>  Die automatische Reinigung funktioniert genauso.  Es kann jedoch viele gleichzeitige Prozesse geben, wenn Sie <em>autovacuum_max_workers</em> auf einen gro√üen Wert setzen.  Dar√ºber hinaus wird der gesamte Speicher sofort und vollst√§ndig und nicht notwendigerweise zugewiesen.  Daher k√∂nnen Sie f√ºr den Workflow f√ºr die <em>automatische Reinigung</em> mithilfe des Parameters <em>autovacuum_work_mem</em> Ihre eigene Einschr√§nkung <em>festlegen</em> .  Standardm√§√üig ist dieser Parameter -1, d. H. Er wird nicht verwendet. <br><br>  Wie bereits erw√§hnt, kann die Reinigung mit einem Minimum an Speicher ausgef√ºhrt werden.  Wenn jedoch Indizes f√ºr die Tabelle erstellt werden, kann ein kleiner Wert f√ºr "tenance_work_mem "zu wiederholten Indexpr√ºfungen f√ºhren.  Gleiches gilt f√ºr die automatische Reinigung.  Idealerweise sollten Sie einen Mindestwert f√ºr <em>autovacuum_work_mem ausw√§hlen,</em> bei dem keine wiederholten Scans auftreten. <br><br>  Wir haben gesehen, dass Sie zur √úberwachung der Reinigung den Parameter VERBOSE (der jedoch nicht f√ºr die automatische Reinigung angegeben werden kann) oder die Ansicht pg_stat_progress_vacuum verwenden k√∂nnen (es werden jedoch nur die aktuellen Informationen angezeigt).  Daher ist die Hauptmethode zur √úberwachung der <em>automatischen Bereinigung</em> der Parameter <em>log_autovacuum_min_duration</em> , mit dem Informationen im Nachrichtenprotokoll des Servers <em>angezeigt</em> werden.  Standardm√§√üig ist es ausgeschaltet (auf -1 eingestellt).  Es gibt einen Grund, diesen Parameter zu aktivieren (bei einem Wert von 0 werden Informationen zu allen Starts der automatischen Reinigung angezeigt) und die Zahlen zu beachten. <br><br>  So sieht die Ausgabe aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Alle notwendigen Informationen finden Sie hier. <br><br>  Denken Sie daran, dass Sie h√§ufig nicht den Speicher vergr√∂√üern, sondern den Schwellenwert f√ºr die Bereinigung verringern sollten, damit weniger Daten gleichzeitig verarbeitet werden. <br><br>  Es kann auch sinnvoll sein, die L√§nge der Liste der zu bereinigenden Tabellen mithilfe der obigen Ansichten zu √ºberwachen.  Eine Vergr√∂√üerung der Liste zeigt an, dass die automatische Reinigung keine Zeit hat, ihre Arbeit zu erledigen, und dass die Einstellungen ge√§ndert werden m√ºssen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452762/">https://habr.com/ru/post/de452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452750/index.html">Nextcloud innerhalb und au√üerhalb von OpenLiteSpeed: Reverse Proxy konfigurieren</a></li>
<li><a href="../de452752/index.html">Hausgemachte BigData. Teil 1. Spark-Streaming-Praxis in einem AWS-Cluster</a></li>
<li><a href="../de452754/index.html">19% der beliebtesten Docker-Images haben kein Root-Passwort</a></li>
<li><a href="../de452756/index.html">Turmverteidigung in Einheit schaffen: Feinde</a></li>
<li><a href="../de452760/index.html">Vitamin D. Trinken oder nicht trinken, das ist die Frage. (Oder eine Geschichte dar√ºber, wie ich eine Analyse bestanden habe, die mir nicht verschrieben wurde)</a></li>
<li><a href="../de452764/index.html">[Peter] Treffen von JUG.ru mit Sergei Melnikov - Profiling mit superluminaler Geschwindigkeit: Theorie und Praxis</a></li>
<li><a href="../de452766/index.html">Progressive Streaming-Technologie oder das Ansehen von 4k-Videos √ºber das Netzwerk ohne Friese</a></li>
<li><a href="../de452768/index.html">So gestalten Sie ein Produkt, wenn Sie sich f√ºr den Eintritt in den ausl√§ndischen Markt entscheiden</a></li>
<li><a href="../de452772/index.html">5 Fortgeschrittene Go-Testtechniken</a></li>
<li><a href="../de452774/index.html">Dell XPS 13 9380: zuverl√§ssiger und sehr kompakter Laptop f√ºr ernsthafte Gesch√§fte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>