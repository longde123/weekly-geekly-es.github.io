<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟 🐤 👨‍🎤 MVCC-7. Automatische Reinigung 🐯 👩🏾‍🤝‍👨🏽 🌔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte Sie daran erinnern, dass wir mit Problemen im Zusammenhang mit der Isolation begonnen haben , einen Exkurs über das Organisieren von Daten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Automatische Reinigung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Ich möchte Sie daran erinnern, dass wir mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation begonnen haben</a> , einen Exkurs über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene gemacht haben</a> , ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Zeilenversionen gesprochen haben</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  Dann haben wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Reinigung</a> (und die HOT-Updates) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelmäßige Reinigung angesehen</a> , aber heute haben wir uns die automatische Reinigung angesehen. <br><br><h1>  Automatische Reinigung (Autovakuum) </h1><br>  Wir haben bereits gesagt, dass die normale Reinigung unter normalen Bedingungen (wenn niemand lange den Transaktionshorizont hält) mit seiner Arbeit fertig werden muss.  Die Frage ist, wie oft man es nennt. <br><br>  Wenn Sie einen Wickeltisch zu selten reinigen, wird er größer als Sie möchten.  Darüber hinaus kann es für die nächste Reinigung mehrere Durchgänge durch die Indizes dauern, wenn sich zu viele Änderungen angesammelt haben. <br><br>  Wenn Sie die Tabelle zu oft räumen, wird der Server anstelle nützlicher Arbeit ständig gewartet - auch nicht gut. <br><br>  Beachten Sie, dass das Starten einer regelmäßigen geplanten Reinigung das Problem nicht löst, da sich die Last im Laufe der Zeit ändern kann.  Wenn die Tabelle aktiver aktualisiert wurde, sollte sie häufiger gereinigt werden. <br><br>  Die automatische Reinigung ist genau der Mechanismus, mit dem Sie abhängig von der Aktivität der Änderungen in den Tabellen mit der Reinigung beginnen können. <br><a name="habracut"></a><br>  Wenn die <em>automatische Reinigung</em> aktiviert ist ( <em>Autovakuum-</em> Konfigurationsparameter), ist der Autovakuum-Starterprozess immer in dem System vorhanden, das arbeiten soll, und Autovakuum-Arbeitsprozesse sind an der tatsächlichen Reinigung beteiligt, von denen mehrere Instanzen parallel arbeiten können. <br><br>  Der Autovacuum Launcher-Prozess erstellt eine Liste von Datenbanken, in denen Aktivitäten vorhanden sind.  Die Aktivität wird durch Statistiken bestimmt. Damit sie erfasst werden kann, muss der Parameter <em>track_counts</em> festgelegt werden.  <em>Schalten</em> <em>Sie</em> niemals <em>autovacuum</em> und <em>track_counts aus</em> , sonst <em>funktioniert die</em> <em>automatische</em> <em>Reinigung</em> nicht. <br><br>  In <em>autovacuum_naptime</em> startet der Autovacuum Launcher-Prozess (unter Verwendung des Postmaster-Prozesses) einen Workflow für jede Datenbank in der Liste.  Mit anderen Worten, wenn die Datenbank eine Aktivität enthält, werden Workflows mit einem Intervall von <em>autovacuum_naptime aufgerufen</em> .  Wenn dazu mehrere aktive Datenbanken (N Teile) vorhanden sind, werden die Arbeitsprozesse N-mal häufiger gestartet als <em>autovacuum_naptime</em> .  Gleichzeitig wird die Gesamtzahl der gleichzeitig arbeitenden Workflows durch den Parameter <em>autovacuum_max_workers</em> begrenzt. <br><br>  Nach dem Start stellt der Workflow eine Verbindung zu der von ihm angegebenen Datenbank her und erstellt zunächst die Liste: <br><br><ul><li>  alle Tabellen, materialisierten Ansichten und Toasttabellen, die gelöscht werden müssen, </li><li>  Alle Tabellen und materialisierten Darstellungen, die analysiert werden müssen (Toasttabellen werden nicht analysiert, da immer über den Index auf sie zugegriffen wird). </li></ul><br>  Ferner reinigt und / oder analysiert der Workflow die ausgewählten Objekte und endet, wenn die Reinigung abgeschlossen ist. <br><br>  Wenn der Prozess nicht alle beabsichtigten Arbeiten für <em>autovacuum_naptime abgeschlossen hat</em> , <em>sendet</em> der Autovacuum Launcher-Prozess einen weiteren Workflow an dieselbe Datenbank und sie arbeiten zusammen.  "Zusammen" bedeutet einfach, dass der zweite Prozess seine Tabellenliste erstellt und dieser folgt.  Somit werden verschiedene Tabellen parallel verarbeitet, aber auf der Ebene einer Tabelle gibt es keine Parallelität. Wenn einer der Arbeitsprozesse bereits an der Tabelle arbeitet, überspringt der andere diese und fährt fort. <br><br><blockquote>  Es wurde lange Zeit über die Notwendigkeit einer parallelen Verarbeitung diskutiert, aber der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> wurde noch nicht übernommen. <br></blockquote><br>  Schauen wir uns nun genauer an, was "gereinigt werden muss" und "analysiert werden muss". <br><br><h1>  Welche Tische müssen gereinigt werden? </h1><br>  Es wird angenommen, dass eine Reinigung erforderlich ist, wenn die Anzahl der "toten", dh irrelevanten Versionen von Zeichenfolgen einen festgelegten Schwellenwert überschreitet.  Die Anzahl der toten Versionen wird vom Statistiksammler ständig erfasst und in der Tabelle pg_stat_all_tables gespeichert.  Der Schwellenwert wird durch zwei Parameter festgelegt: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> definiert den absoluten Wert (in Stücken), </li><li>  <em>autovacuum_vacuum_scale_factor</em> bestimmt den Anteil der Zeilen in einer Tabelle. </li></ul><br>  Die endgültige Formel lautet: Reinigung ist erforderlich, wenn pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * pg_class.reltupes. <br><br>  Die Standardeinstellungen setzen <em>autovacuum_vacuum_threshold</em> = 50 und <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  Der Hauptparameter hier ist natürlich <em>autovacuum_vacuum_scale_factor</em> - es ist wichtig für große Tabellen ( <em>dh</em> mögliche Probleme sind damit verbunden).  Der Wert von 20% scheint stark überschätzt zu sein, höchstwahrscheinlich muss er deutlich reduziert werden. <br><br>  Die optimalen Parameterwerte können für verschiedene Tabellen je nach Größe und Art der Änderungen variieren.  Es ist sinnvoll, insgesamt angemessene Werte festzulegen und - falls erforderlich - die Parameter auf der Ebene einiger Tabellen mithilfe der Speicherparameter speziell zu konfigurieren: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> und <em>toast.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> und <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Um nicht verwirrt zu werden, sollte dies nur für eine kleine Anzahl von Tabellen durchgeführt werden, die sich unter anderem durch das Volumen oder die Intensität der Änderungen auszeichnen, und nur dann, wenn die global festgelegten Werte nicht geeignet sind. <br><br>  Darüber hinaus kann die automatische Reinigung auf Tabellenebene deaktiviert werden (obwohl es schwierig ist, sich einen Grund vorzustellen, warum dies erforderlich wäre): <br><br><ul><li>  <em>autovacuum_enabled</em> und <em>toast.autovacuum_enabled</em> . </li></ul><br>  Zum Beispiel haben wir das letzte Mal eine Vac-Tabelle mit deaktivierter automatischer Reinigung erstellt, um zu Demonstrationszwecken die manuelle Reinigung zu verwalten.  Der Speicherparameter kann wie folgt geändert werden: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Um all das zu formalisieren, erstellen wir eine Ansicht, die zeigt, welche Tabellen derzeit bereinigt werden müssen.  Es wird eine Funktion verwendet, die den aktuellen Wert des Parameters zurückgibt, da dieser auf Tabellenebene überschrieben werden kann: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Und hier ist die Ansicht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Welche Tabellen müssen analysiert werden? </h1><br>  Bei der automatischen Analyse ist die Situation ungefähr dieselbe.  Es wird angenommen, dass eine Analyse für diejenigen Tabellen erforderlich ist, für die die Anzahl der geänderten (seit der letzten Analyse) Version der Zeilen den durch zwei ähnliche Parameter angegebenen Schwellenwert überschreitet: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * pg_class.reltupes. <br><br>  Die Standardeinstellungen für die automatische Analyse unterscheiden sich geringfügig: <em>autovacuum_analyze_threshold</em> = 50 und <em>autovacuum_analyze_scale_factor</em> = 0.1.  Sie können auch auf der Ebene der Speicherparameter für einzelne Tabellen definiert werden: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Da Toasttabellen nicht analysiert werden, gibt es für sie keine entsprechenden Parameter. <br><br>  Erstellen wir eine Ansicht für die Analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Beispiel </h1><br>  Für Experimente setzen wir folgende Parameterwerte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Erstellen Sie nun eine Tabelle ähnlich der, die wir zuletzt verwendet haben, und fügen Sie tausend Zeilen ein.  Die automatische Reinigung ist auf Tabellenebene deaktiviert und wird von uns selbst aktiviert.  Wenn dies nicht erfolgt, sind die Beispiele nicht reproduzierbar, da die automatische Reinigung möglicherweise zur falschen Zeit funktioniert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  In unserer Bereinigungsansicht wird Folgendes angezeigt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Es gibt zwei Punkte, auf die Sie achten sollten.  Erstens ist max_dead_tup = 0, obwohl 3% von 1000 Zeilen 30 Zeilen sind.  Tatsache ist, dass wir noch keine Statistiken in der Tabelle haben, da INSERT selbst diese nicht aktualisiert.  Bis unsere Tabelle analysiert ist, bleiben die Nullen erhalten, da pg_class.reltuples = 0. Schauen wir uns jedoch die zweite Ansicht zur Analyse an: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Da die Tabelle 1000 Zeilen geändert (hinzugefügt) hat und dies mehr als Null ist, sollte die automatische Analyse funktionieren.  Überprüfen Sie dies: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Nach einer kurzen Pause sehen wir, dass die Tabelle analysiert wird und anstelle von Nullen in max_mod_tup sehen wir die richtigen 20 Zeilen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Kehren wir zur automatischen Reinigung zurück: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Wie wir sehen, wurde Max_dead_tup bereits behoben.  Der zweite Punkt, auf den Sie achten sollten, ist dead_tup = 0. Statistiken zeigen, dass die Tabelle keine toten Versionen von Zeilen enthält ... und das ist wahr.  In unserem Tisch gibt es noch nichts zu reinigen.  Daher wird eine Tabelle, die nur im Nur-Anhängen-Modus verwendet wird, nicht gelöscht, und daher wird die Sichtbarkeitskarte nicht dafür aktualisiert.  Dies macht es unmöglich, ausschließlich Index-Scannen (Nur-Index-Scan) zu verwenden. <br><br>  (Das nächste Mal werden wir sehen, dass die Reinigung früher oder später zum Nur-Anhängen-Tisch kommt, aber dies wird sehr selten vorkommen.) <br><br>  Praktische Schlussfolgerung: Wenn es wichtig ist, nur das Index-Scannen zu verwenden, müssen Sie möglicherweise eine manuelle Reinigung anfordern. <br><br>  Schalten Sie nun die automatische Reinigung wieder aus und aktualisieren Sie die Zeile 31 - eine mehr als der Schwellenwert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Jetzt ist die Bedingung zum Auslösen der automatischen Reinigung erfüllt.  Aktivieren Sie die automatische Reinigung und nach einer kurzen Pause sehen wir, dass die Tabelle verarbeitet wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Lastregelung </h1><br>  Die Bereinigung blockiert keine anderen Prozesse, da sie seitenweise arbeitet, das System jedoch belastet und die Leistung spürbar beeinträchtigt. <br><br><h2>  Regelung zur regelmäßigen Reinigung </h2><br>  Um die Intensität der Reinigung und damit deren Auswirkung auf das System steuern zu können, wechselt der Prozess zwischen Arbeit und Erwartung.  Die Reinigung führt ungefähr <em>vakuum_Kosten_Limit</em> konventionelle Arbeitseinheiten aus und schläft dann bei <em>Vakuum_Kostenverzögerung</em> ms ein. <br><br>  Die Standardeinstellungen setzen <em>vakuum_Kostenlimit</em> = 200, <em>Vakuum_Kostenverzögerung</em> = 0. Die letzte Null bedeutet tatsächlich, dass die (normale) Reinigung nicht einschläft, sodass der spezifische Wert von <em>Vakuum_Kostenlimit</em> keine Rolle spielt.  Dies geschieht aus dem Grund, dass der Administrator, wenn er VACUUM manuell starten musste, die Bereinigung wahrscheinlich so schnell wie möglich durchführen möchte. <br><br>  Wenn Sie dennoch die <em>Ruhezeit festlegen</em> , besteht der in <em>vakuum_Kostenlimit</em> angegebene <em>Arbeitsaufwand</em> aus den Kosten für die Arbeit mit Seiten im <em>Puffercache</em> .  Jeder Seitenzugriff wird wie folgt bewertet: <br><br><ul><li>  Wenn die Seite im <em>Puffercache</em> gefunden wurde, ist <em>vacac_cost_page_hit</em> = 1; </li><li>  wenn nicht gefunden, dann <em>vacuum_cost_page_miss</em> = 10; </li><li>  Wenn Sie es nicht finden konnten und die verschmutzte Seite aus dem Puffer schieben mussten, ist <em>vacac_cost_page_dirty</em> = 20. </li></ul><br>  Das heißt, mit den Einstellungen für <em>vakuum_Kostenlimit</em> können standardmäßig 200 Seiten aus dem Cache oder 20 Seiten von der Festplatte oder 10 Seiten mit Extrusion in einer Sitzung verarbeitet werden.  Es ist klar, dass dies eher willkürliche Zahlen sind, aber es macht keinen Sinn, sie genauer auszuwählen. <br><br><h2>  Regelung zur automatischen Reinigung </h2><br>  Die Lastregelung während der automatischen Reinigung funktioniert genauso wie bei der regulären Reinigung.  Damit manuelle <em>Reinigung</em> und <em>automatische</em> Reinigung mit unterschiedlichen Intensitäten arbeiten können, haben Autoprozesse ihre eigenen Parameter: <em>autovacuum_vacuum_cost_limit</em> und <em>autovacuum_vacuum_cost_delay</em> .  Wenn diese Parameter den Wert -1 annehmen, wird der Wert von <em>vakuum_Kostenlimit</em> und / oder <em>Vakuumkostenverzögerung verwendet</em> . <br><br>  Standardmäßig ist <em>autovacuum_vacuum_cost_limit</em> = -1 ( <em>dh</em> der Wert <em>vakuum_cost_limit</em> = 200 wird verwendet) und <em>autovacuum_vacuum_cost_delay</em> = 20 ms.  Bei modernen Geräten mit diesen Nummern funktioniert die automatische Reinigung sehr, sehr langsam. <br><br>  In Version 12 wird der Wert von <em>autovacuum_vacuum_cost_delay</em> auf 2 ms reduziert, was als geeignetere erste Annäherung angesehen werden kann. <br><br>  Darüber hinaus ist zu beachten, dass die durch diese Parameter festgelegte Grenze allen Arbeitsprozessen gemeinsam ist.  Mit anderen Worten, wenn sich die Anzahl der gleichzeitigen Arbeitsprozesse ändert, bleibt die Gesamtlast konstant.  Wenn die Aufgabe darin besteht, die Leistung der <em>automatischen Reinigung</em> zu erhöhen, lohnt es sich daher, beim Hinzufügen von Workflows das <em>autovacuum_vacuum_cost_limit</em> zu erhöhen. <br><br><h2>  Speichernutzung und Überwachung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten Mal haben</a> wir uns angesehen, wie beim Bereinigen der RAM-Speicher der Größe <em>wartung_work_mem verwendet wird</em> , um die Versionskennungen der zu bereinigenden Zeilen zu speichern. <br><br>  Die automatische Reinigung funktioniert genauso.  Es kann jedoch viele gleichzeitige Prozesse geben, wenn Sie <em>autovacuum_max_workers</em> auf einen großen Wert setzen.  Darüber hinaus wird der gesamte Speicher sofort und vollständig und nicht notwendigerweise zugewiesen.  Daher können Sie für den Workflow für die <em>automatische Reinigung</em> mithilfe des Parameters <em>autovacuum_work_mem</em> Ihre eigene Einschränkung <em>festlegen</em> .  Standardmäßig ist dieser Parameter -1, d. H. Er wird nicht verwendet. <br><br>  Wie bereits erwähnt, kann die Reinigung mit einem Minimum an Speicher ausgeführt werden.  Wenn jedoch Indizes für die Tabelle erstellt werden, kann ein kleiner Wert für "tenance_work_mem "zu wiederholten Indexprüfungen führen.  Gleiches gilt für die automatische Reinigung.  Idealerweise sollten Sie einen Mindestwert für <em>autovacuum_work_mem auswählen,</em> bei dem keine wiederholten Scans auftreten. <br><br>  Wir haben gesehen, dass Sie zur Überwachung der Reinigung den Parameter VERBOSE (der jedoch nicht für die automatische Reinigung angegeben werden kann) oder die Ansicht pg_stat_progress_vacuum verwenden können (es werden jedoch nur die aktuellen Informationen angezeigt).  Daher ist die Hauptmethode zur Überwachung der <em>automatischen Bereinigung</em> der Parameter <em>log_autovacuum_min_duration</em> , mit dem Informationen im Nachrichtenprotokoll des Servers <em>angezeigt</em> werden.  Standardmäßig ist es ausgeschaltet (auf -1 eingestellt).  Es gibt einen Grund, diesen Parameter zu aktivieren (bei einem Wert von 0 werden Informationen zu allen Starts der automatischen Reinigung angezeigt) und die Zahlen zu beachten. <br><br>  So sieht die Ausgabe aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Alle notwendigen Informationen finden Sie hier. <br><br>  Denken Sie daran, dass Sie häufig nicht den Speicher vergrößern, sondern den Schwellenwert für die Bereinigung verringern sollten, damit weniger Daten gleichzeitig verarbeitet werden. <br><br>  Es kann auch sinnvoll sein, die Länge der Liste der zu bereinigenden Tabellen mithilfe der obigen Ansichten zu überwachen.  Eine Vergrößerung der Liste zeigt an, dass die automatische Reinigung keine Zeit hat, ihre Arbeit zu erledigen, und dass die Einstellungen geändert werden müssen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452762/">https://habr.com/ru/post/de452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452750/index.html">Nextcloud innerhalb und außerhalb von OpenLiteSpeed: Reverse Proxy konfigurieren</a></li>
<li><a href="../de452752/index.html">Hausgemachte BigData. Teil 1. Spark-Streaming-Praxis in einem AWS-Cluster</a></li>
<li><a href="../de452754/index.html">19% der beliebtesten Docker-Images haben kein Root-Passwort</a></li>
<li><a href="../de452756/index.html">Turmverteidigung in Einheit schaffen: Feinde</a></li>
<li><a href="../de452760/index.html">Vitamin D. Trinken oder nicht trinken, das ist die Frage. (Oder eine Geschichte darüber, wie ich eine Analyse bestanden habe, die mir nicht verschrieben wurde)</a></li>
<li><a href="../de452764/index.html">[Peter] Treffen von JUG.ru mit Sergei Melnikov - Profiling mit superluminaler Geschwindigkeit: Theorie und Praxis</a></li>
<li><a href="../de452766/index.html">Progressive Streaming-Technologie oder das Ansehen von 4k-Videos über das Netzwerk ohne Friese</a></li>
<li><a href="../de452768/index.html">So gestalten Sie ein Produkt, wenn Sie sich für den Eintritt in den ausländischen Markt entscheiden</a></li>
<li><a href="../de452772/index.html">5 Fortgeschrittene Go-Testtechniken</a></li>
<li><a href="../de452774/index.html">Dell XPS 13 9380: zuverlässiger und sehr kompakter Laptop für ernsthafte Geschäfte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>