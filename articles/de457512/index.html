<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æüèæ üõ†Ô∏è üåÑ Logische Replikation zwischen PostgreSQL-Versionen ü§öüèø üõê üïµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt verschiedene Ans√§tze zum Aktualisieren von PostgreSQL, einige f√ºhren jedoch zu Ausfallzeiten. Wenn Sie Ausfallzeiten vermeiden m√∂chten, verwen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logische Replikation zwischen PostgreSQL-Versionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/457512/"><p><img src="https://habrastorage.org/webt/yl/pr/hs/ylprhs3ilpoukerjhyvwdnj6kmu.png"></p><br><p>  Es gibt verschiedene Ans√§tze zum Aktualisieren von PostgreSQL, einige f√ºhren jedoch zu Ausfallzeiten.  Wenn Sie Ausfallzeiten vermeiden m√∂chten, verwenden Sie die Replikation zum Aktualisieren - je nach Szenario logisch oder physisch (Streaming).  In diesem Artikel werden wir den Unterschied zwischen logischer und physischer Replikation in PostgreSQL untersuchen.  Anschlie√üend erfahren Sie ausf√ºhrlich, wie Sie die Version mithilfe der logischen Replikation aktualisieren und dabei Ausfallzeiten der Anwendung vermeiden.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Artikel wird</a> die physische Replikation erl√§utert. </p><br><p>  In fr√ºheren Artikeln haben wir bereits √ºber PostgreSQL-Upgrade-Methoden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL mit pg_dumpall</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrade von PostgreSQL mit pg_dump / pg_restore</a> ) als Teil der Serie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Upgrading or Migrating Old PostgreSQL Versions gesprochen</a> .  Beide Methoden schlie√üen jedoch Ausfallzeiten nicht aus. </p><a name="habracut"></a><br><h2 id="tipy-logicheskoy-replikacii">  Logische Replikationstypen </h2><br><p>  Hier diskutieren wir zwei Arten der Replikation: </p><br><ul><li>  Replikation zwischen PostgreSQL 10 und 11 mithilfe der integrierten logischen Replikation. </li><li>  Replikation zwischen PostgreSQL 9.4 (oder vor PG 11) und PostgreSQL 11 unter Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogischen</a> Erweiterung. </li></ul><br><p>  Um Ausfallzeiten zu minimieren, k√∂nnen Sie mithilfe der Replikation ein Upgrade durchf√ºhren.  Wenn alle relevanten Daten auf einen anderen neuesten PostgreSQL-Server repliziert werden, √ºbertragen Sie die Anwendung einfach mit minimalen Ausfallzeiten auf den neuen Server - obwohl dies nat√ºrlich alles von der Komplexit√§t des Anwendungsstapels abh√§ngt. </p><br><p>  <strong>Die logische Replikation</strong> in PostgreSQL erm√∂glicht es Benutzern, Tabellen selektiv zu replizieren und einen Sicherungsserver f√ºr Schreibvorg√§nge zu √∂ffnen.  <strong>Die physische Replikation</strong> in PostgreSQL erfolgt in Bl√∂cken.  In diesem Fall wird jede Datenbank im Assistenten auf den Sicherungsserver repliziert, auf den keine Schreibvorg√§nge zugreifen k√∂nnen.  Als N√§chstes werden wir das physische Replikations- <strong>Streaming</strong> aufrufen. </p><br><p> Wenn Sie die logische Replikation auf einem Standby-Server verwenden, k√∂nnen Sie die Replikation von mehreren Mastern aktivieren.  Dies ist in Situationen n√ºtzlich, in denen Sie Daten aus mehreren PostgreSQL-Datenbanken (OLTP) auf einen einzelnen PostgreSQL-Server replizieren m√ºssen, um Berichte zu erstellen und Daten zu speichern. </p><br><p>  Der Hauptvorteil der logischen Replikation gegen√ºber dem Streaming besteht darin, dass Sie mit der logischen Replikation √Ñnderungen von der alten Version von PostgreSQL auf die neue Version replizieren k√∂nnen.  Die Stream-Replikation funktioniert nur, wenn der Master und der Sicherungsserver dieselbe Hauptversion haben.  Im Idealfall sollten auch zus√§tzliche Versionen √ºbereinstimmen. </p><br><h3 id="replikaciya-mezhdu-versiyami-postgresql-10-i-11">  Replikation zwischen PostgreSQL 10 und 11 </h3><br><p>  Ab PostgreSQL 10 ist standardm√§√üig die logische Replikation verf√ºgbar.  Daher k√∂nnen Sie die PostgreSQL 10-Datenbank in PostgreSQL 11 problemlos replizieren. Die logische Replikation verwendet das Publish- und Subscribe-Modell.  Der Knoten, der die √Ñnderungen √ºbermittelt, wird zum Herausgeber.  Und der Knoten, der diese √Ñnderungen abonniert, wird ein Abonnent.  Pro Ver√∂ffentlichung k√∂nnen mehrere Abonnements vorhanden sein. </p><br><h3 id="publikaciya">  Posting </h3><br><p>  Eine Publikation ist ein Array von √Ñnderungen, die von einer Gruppe von Tabellen erstellt wurden.  Es wird als <strong>√Ñnderungssatz</strong> oder <strong>Replikationssatz bezeichnet</strong> .  Ver√∂ffentlichungen k√∂nnen nur Tabellen enthalten, aber keine anderen Objekte.  DML in diesen Tabellen kann repliziert werden, DDL jedoch nicht. </p><br><p>  In der Publikation k√∂nnen Sie ausw√§hlen, welcher DML-Typ repliziert werden soll: INSERT, DELETE, UPDATE oder ALL.  Standardm√§√üig ist ALL ausgew√§hlt.  Die Tabelle muss eine Replikatkennung haben, um UPDATE- und DELETE-Operationen auf den Abonnenten zu replizieren.  Mithilfe von Replikatkennungen k√∂nnen Sie Zeilen finden, die aktualisiert oder gel√∂scht werden. </p><br><p>  Der Prim√§rschl√ºssel der Tabelle ist die Standardreplikatkennung.  Oder Sie k√∂nnen den Bezeichner zu einem eindeutigen Index mit NOT NULL-Werten machen.  Wenn Sie keinen Prim√§rschl√ºssel oder keinen eindeutigen Index mit NO NULL-Werten haben, setzen Sie replica_identity auf FULL.  In diesem Fall verwendet Postgres die gesamte Zeichenfolge als Schl√ºssel.  Das ist aber nicht sehr rational. </p><br><p>  Wenn der Ver√∂ffentlichung nach einer UPDATE- oder DELETE-Operation standardm√§√üig eine Tabelle ohne Prim√§rschl√ºssel und Replikat-ID hinzugef√ºgt wird, k√∂nnen Fehler auftreten. </p><br><h3 id="podpiska">  Abonnement </h3><br><p>  Ein Abonnent kann eine oder mehrere Ver√∂ffentlichungen abonnieren.  Stellen Sie vor dem Hinzuf√ºgen eines Abonnements sicher, dass die replizierten Tabellen auf dem Abonnentenknoten erstellt wurden.  Speichern Sie dazu nur die Schemata des Herausgebers an den Abonnenten. </p><br><h3 id="primer-logicheskoy-replikacii">  Beispiel f√ºr eine logische Replikation </h3><br><p>  <strong>Das folgende Beispiel beschreibt die logische Replikation nur zwischen den PostgreSQL-Versionen 10 und 11.</strong> </p><br><p>  Erstellen Sie eine Publikation auf der Publisher-Site.  F√ºgen Sie der Publikation alle oder nur einige Tabellen hinzu. </p><br><pre><code class="plaintext hljs">-- For adding ALL Tables in Database CREATE PUBLICATION percpub FOR ALL TABLES; -- For adding Selected Tables in Database CREATE PUBLICATION percpub FOR TABLE scott.employee scott.departments;</code> </pre> <br><p>  Erstellen Sie auf der Abonnentenseite ein Abonnement f√ºr diese Publikation.  F√ºhren Sie einen DDL-Speicherauszug der Tabellen f√ºr den Abonnenten durch, bevor Sie das Abonnement erstellen, wie oben erw√§hnt. </p><br><pre> <code class="plaintext hljs">$ pg_dump -h publisher_server_ip -p 5432 -d percona -Fc -s -U postgres | pg_restore -d percona -h subscriber_node_ip -p 5432 -U postgres CREATE SUBSCRIPTION percsub CONNECTION 'host=publisher_server_ip dbname=percona user=postgres password=secret port=5432' PUBLICATION percpub;</code> </pre> <br><p>  Dieser Befehl kopiert auch vorhandene Daten in die Tabellen.  Wenn Sie das Kopieren vorhandener Daten deaktivieren m√∂chten, verwenden Sie den folgenden Befehl. Es werden nur die √Ñnderungen am Herausgeber kopiert. </p><br><pre> <code class="plaintext hljs">CREATE SUBSCRIPTION percsub CONNECTION 'host=publisher_server_ip dbname=percona user=postgres password=oracle port=5432' PUBLICATION percpub WITH (copy_data = false);</code> </pre> <br><p>  Verfolgen Sie die Replikation mit dem folgenden Befehl im Herausgeberknoten: </p><br><pre> <code class="plaintext hljs">$ psql \x select * from pg_stat_replication;</code> </pre> <br><h3 id="replikaciya-mezhdu-postgresql-94-i-postgresql-11">  Replikation zwischen PostgreSQL 9.4 und PostgreSQL 11 </h3><br><p>  Was tun mit Versionen vor PostgreSQL 10?  F√ºr die Versionen 9.4 bis 11 gibt es eine spezielle Erweiterung - <code>pglogical</code> .  Mit pglogical k√∂nnen Sie PostgreSQL 9.4 auf zwei Arten auf PostgreSQL 11 replizieren. </p><br><p>  Im Folgenden finden Sie allgemeine Anweisungen zum Einrichten der Replikation zwischen PG 9.4 und PG 11 mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pglogischen</a> Erweiterung. </p><br><p>  <strong>Schritt 1.</strong> Betrachten Sie pgserver_94 als Quellserver mit der Datenbank percona_94 unter PostgreSQL 9.4.  Erstellen Sie die folgende Erweiterung. <br>  Code </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $psql -d percona_94 -c "CREATE EXTENSION pglogical_origin" CREATE EXTENSION [pgserver_94:] $psql -d percona_94 -c "CREATE EXTENSION pglogical" CREATE EXTENSION</code> </pre> <br><p>  <strong>Schritt 2.</strong> F√ºgen Sie nun alle oder einige der Tabellen zum Schema oder zu mehreren Schemas zur Replikation hinzu.  Im folgenden Beispiel wird ein Fehler angezeigt, da eine der Tabellen keinen Prim√§rschl√ºssel hat. </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $psql -d percona_94 psql (9.4.21) Type "help" for help. percona_94=# SELECT pglogical.create_node(node_name := 'provider1',dsn := 'host=192.168.0.24 port=5432 dbname=percona_94'); create_node ------------- 2976894835 (1 row) percona_94=# SELECT pglogical.replication_set_add_all_tables('default', ARRAY['public']); ERROR: table pgbench_history cannot be added to replication set default DETAIL: table does not have PRIMARY KEY and given replication set is configured to replicate UPDATEs and/or DELETEs HINT: Add a PRIMARY KEY to the table percona_94=# ALTER TABLE pgbench_history ADD PRIMARY KEY (tid,aid,delta); ALTER TABLE percona_94=# SELECT pglogical.replication_set_add_all_tables('default', ARRAY['public']); replication_set_add_all_tables -------------------------------- t (1 row)</code> </pre> <br><p>  <strong>Schritt 3.</strong> F√ºhren Sie auf dem Abonnentenknoten, dh in der PostgreSQL 11-Datenbank, die folgenden Befehle aus. </p><br><pre> <code class="plaintext hljs">[pgserver_11:] $psql -d percona_11 psql (11.2) Type "help" for help. percona_11=# SELECT pglogical.create_node(node_name := 'subscriber1',dsn := 'host=127.0.0.1 port=5432 dbname=percona_11 password=secret'); create_node ------------- 330520249 (1 row) percona_11=# SELECT pglogical.create_subscription(subscription_name := 'subscription1',provider_dsn := 'host=192.168.0.24 port=5432 dbname=percona_94 password=secret'); create_subscription --------------------- 1763399739 (1 row)</code> </pre> <br><p>  <strong>Schritt 4.</strong> √úberpr√ºfen Sie anschlie√üend den Replikationsstatus, indem Sie eine Anforderung an mehrere Tabellen senden, die pglogical immer aktualisiert: </p><br><pre> <code class="plaintext hljs">percona_11=# select * from pglogical.local_sync_status; sync_kind | sync_subid | sync_nspname | sync_relname | sync_status | sync_statuslsn -----------+------------+--------------+------------------+-------------+---------------- f | 1763399739 | public | pgbench_accounts | r | 0/2EB7D48 f | 1763399739 | public | pgbench_history | r | 0/2EB7D48 f | 1763399739 | public | pgbench_tellers | r | 0/2EB7D48 f | 1763399739 | public | pgbench_branches | r | 0/2EB7D48 d | 1763399739 | | | r | 0/0 (5 rows) percona_11=# select * from pglogical.subscription; sub_id | sub_name | sub_origin | sub_target | sub_origin_if | sub_target_if | sub_enabled | sub_slot_name | sub_rep lication_sets | sub_forward_origins | sub_apply_delay ------------+---------------+------------+------------+---------------+---------------+-------------+----------------------------------------+---------------- -----------------------+---------------------+----------------- 1763399739 | subscription1 | 2976894835 | 330520249 | 2402836775 | 2049915666 | t | pgl_percona_11_provider1_subscription1 | {default,defaul t_insert_only,ddl_sql} | {all} | 00:00:00 (1 row)</code> </pre> <br><h3 id="vybor-pervichnogo-klyucha">  Prim√§rschl√ºsselauswahl </h3><br><p>  Im zweiten Schritt haben Sie gesehen, wie alle Tabellen im √∂ffentlichen Schema zum Replikationssatz hinzugef√ºgt wurden, indem Sie einen Prim√§rschl√ºssel f√ºr eine Tabelle ohne einen erstellt haben.  Ich habe m√∂glicherweise den falschen Prim√§rschl√ºssel f√ºr diese Tabelle ausgew√§hlt, dies dient jedoch nur zur Demonstration.  Stellen Sie bei der Auswahl eines Prim√§rschl√ºssels sicher, dass dieser korrekt ist.  Es muss eindeutig sein und Spalten verwenden, die keine NULL-Werte enthalten.  Wenn Sie nicht den richtigen Prim√§rschl√ºssel finden, kann dies zu Ausfallzeiten der Anwendung f√ºhren.  Hier ist ein Beispiel f√ºr einen Fehler, der auftreten kann: </p><br><pre> <code class="plaintext hljs">[pgserver_94:] $pgbench -c 10 -T 300 -n percona_94 Client 7 aborted in state 12: ERROR: duplicate key value violates unique constraint "pgbench_history_pkey" DETAIL: Key (tid, aid, delta)=(7, 63268, 2491) already exists.</code> </pre> <br><p>  Hier erfahren Sie, wie Sie mit pglogical eine Replikation zwischen der alten und der neuen Version von PostgreSQL erstellen.  Wechseln Sie nach dem Einrichten der Replikation einfach die Anwendungen auf die neueste Version, damit die Ausfallzeit minimal ist. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457512/">https://habr.com/ru/post/de457512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457494/index.html">"Und wenn ich Mathe nicht kenne, bin ich dann hoffnungslos?" - Spezialisten beantworten h√§ufig gestellte Fragen zu Berufen in Data Science</a></li>
<li><a href="../de457496/index.html">"Finde die f√ºnf Unterschiede." Skalierbarer und Generierungsunterschied - Neue Testreihe</a></li>
<li><a href="../de457504/index.html">Warum sollten Sie Ihr React Data Grid im Jahr 2019 schreiben?</a></li>
<li><a href="../de457508/index.html">Elternschaft gegen maschinelles Lernen: Vergleicht eine junge Mutter</a></li>
<li><a href="../de457510/index.html">Verwenden Sie mcrouter, um memcached horizontal zu skalieren</a></li>
<li><a href="../de457514/index.html">Nevanger</a></li>
<li><a href="../de457516/index.html">Schreiben eines Bedrohungsmodells</a></li>
<li><a href="../de457518/index.html">Plasma Cash Chain als L√∂sung f√ºr das Blockchain-Skalierbarkeitstrilemma</a></li>
<li><a href="../de457522/index.html">Erh√∂hen Sie Ihren Mailinglistendienst oder verwenden Sie vorgefertigte L√∂sungen? Was ich √ºber 5 Jahre bei UniSender gelernt habe</a></li>
<li><a href="../de457524/index.html">Tiefenkameras - stille Revolution (wenn Roboter sehen) Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>