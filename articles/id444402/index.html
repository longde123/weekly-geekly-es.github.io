<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¶ğŸ» ğŸ”¨ ğŸ˜± Bereaksi Pemecahan Kode pada 2019 ğŸ›€ ğŸš  ğŸ“’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini tahun 2019! Semua orang berpikir mereka tahu pemecahan kode. Jadi - mari kita periksa! 



 Apa artinya pemisahan kode? 


 Singkatnya pemecahan k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi Pemecahan Kode pada 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444402/"><p>  Ini tahun 2019!  Semua orang berpikir mereka tahu pemecahan kode.  Jadi - mari kita periksa! </p><br><p><img src="https://habrastorage.org/webt/da/lx/0b/dalx0bnbenxiqebdymmcrp8in68.png"></p><br><h2 id="what-does-code-splitting-stand-for">  Apa artinya pemisahan kode? </h2><br><p>  Singkatnya pemecahan kode hanya tentang tidak memuat semuanya.  Maka Anda membaca halaman ini Anda tidak perlu memuat seluruh situs.  Saat Anda memilih satu baris dari basis data - Anda tidak harus mengambil semuanya. <br>  Jelas?  Pemecahan kode juga cukup jelas, tidak hanya tentang data Anda, tetapi kode Anda. </p><a name="habracut"></a><br><h2 id="whowhat-is-making-code-splitting">  Siapa (Apa?) Apakah membuat pemisahan kode? </h2><br><p> <code>React.lazy</code> ?  Tidak - hanya menggunakannya.  Pemecahan kode sedang dilakukan pada tingkat bundler - paket web, paket, atau hanya sistem file Anda jika ada modul ESM "asli".  Pemecahan kode hanyalah file, file yang dapat Anda muat di suatu tempat "nanti".  Jadi - untuk pertanyaan " <strong>Apa yang memecah kode powering?</strong> " - jawabannya adalah - "bundler". </p><br><h2 id="whowhat-is-using-code-splitting">  Siapa (Apa) yang menggunakan pemisahan kode? </h2><br><p>  <code>React.lazy</code> sedang menggunakan.  Hanya menggunakan pemecahan kode bundler Anda.  Hanya menelepon impor saat diberikan.  Dan itu saja. </p><br><h2 id="whats-about-react-loadable">  Bagaimana dengan React-loadable? </h2><br><p>  <code>React.lazy</code> menggantikannya.  Dan menyediakan lebih banyak fitur, seperti <code>Suspense</code> untuk mengontrol status pemuatan.  Jadi - gunakan <code>React.Lazy</code> sebagai gantinya. </p><br><blockquote>  Yap, itu saja.  Terima kasih sudah membaca dan semoga harimu menyenangkan. </blockquote><br><h2 id="why-article-is-not-finished">  Mengapa artikel belum selesai? </h2><br><p>  Baik.  Ada beberapa zona abu-abu tentang <code>React.lazy</code> dan pemecahan kode yang saya lupa sebutkan. </p><br><h3 id="grey-zone-1--testing">  Gray Zone 1 - pengujian </h3><br><p>  Tidak mudah untuk menguji <code>React.lazy</code> karena <em>asinkroninya</em> .  Itu hanya akan "kosong", asalkan itu belum dimuat (bahkan jika itu) - <code>Promises</code> dan <code>import</code> kembali, dan malas menerima, <strong>janji</strong> , yang selalu dieksekusi di <strong>centang berikutnya</strong> . </p><br><p>  Solusi yang diajukan?  Anda tidak akan percaya, tetapi solusi yang diusulkan adalah menggunakan <em>kabel</em> sinkron - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat permintaan tarik</a> .  Jadi - mari kita buat <code>imports</code> kami SYNCHRONOUS !!!  <em>(untuk memperbaiki masalah malas untuk tes, atau kasus sisi server lain)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LazyText = lazy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ then(cb) { cb({<span class="hljs-attr"><span class="hljs-attr">default</span></span>: Text}); <span class="hljs-comment"><span class="hljs-comment">// this is "sync" thenable }, })); const root = ReactTestRenderer.create( &lt;Suspense fallback={&lt;Text text="Loading..." /&gt;}&gt; &lt;LazyText text="Hi" /&gt; // this lazy is not very lazy &lt;/Suspense&gt;, );</span></span></code> </pre> <br><p>  Tidak sulit untuk mengonversi fungsi impor ke memo yang sinkron. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> syncImport = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importFn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> preloaded = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = importFn().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> preloaded = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ^ "auto" import and "cache" promise return () =&gt; preloaded ? { then: () =&gt; preloaded } : promise; // ^ return sync thenable then possible } const lazyImport = isNode ? syncImport : a =&gt; a; // ^ sync for node, async for browser const LazyComponent = React.lazy(lazyImport(() =&gt; import('./file'));</span></span></code> </pre> <br><h3 id="grey-zone-2--ssr">  Zona abu-abu 2 - SSR </h3><br><blockquote>  Jika Anda TIDAK membutuhkan SSR - silakan lanjutkan membaca artikel! </blockquote><p>  <code>React.lazy</code> ramah terhadap SSR.  Tetapi membutuhkan <code>Suspense</code> untuk bekerja, dan Suspense <strong>BUKAN ramah sisi server</strong> . </p><br><p>  Ada 2 solusi: </p><br><ul><li>  Ganti Suspense dengan Fragment, misalnya dengan mengejek.  Kemudian, gunakan versi <code>import</code> diubah dengan sinkron <code>then</code> untuk membuat malas juga berperilaku sinkron. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realLazy = React.lazy; React.lazy = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importer</span></span></span><span class="hljs-function"> =&gt;</span></span> realLazy(syncImport(importer)); React.Suspense = React.Fragment; <span class="hljs-comment"><span class="hljs-comment">// :P // ^ React SSR just got fixed :D</span></span></code> </pre> </li></ul><br><p>  Ini adalah pilihan yang baik, tetapi tidak akan cukup ramah dari sisi klien.  Mengapa  Mari kita tentukan solusi ke-2 yang mungkin: </p><br><ul><li>  Gunakan <strong>perpustakaan khusus</strong> untuk melacak skrip, potongan dan gaya yang digunakan, dan memuatnya di sisi klien (terutama gaya!) Sebelum Bereaksi hidrasi.  Atau yang lain - Anda akan membuat lubang kosong alih-alih komponen yang Anda pisahkan dengan kode.  Sekali lagi - Anda tidak memuat kode yang baru saja Anda pisahkan, sehingga Anda tidak dapat membuat apa pun yang Anda inginkan. </li></ul><br><h3 id="behold-code-splitting-libraries">  Lihatlah perpustakaan yang memecah kode </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Universal-component</a> - perpustakaan tertua, dan masih dapat dikelola.  Ini "menemukan" pemecahan kode dalam hal Webpack yang diajarkan untuk pemecahan kode. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React-loadable</a> - sangat populer, tetapi perpustakaan yang tidak dirawat.  Membuat kode meludah hal yang populer.  Masalah ditutup, jadi tidak ada komunitas di sekitarnya. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Loadable-components</a> - perpustakaan lengkap fitur, senang digunakan, dengan komunitas paling aktif di sekitarnya. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komponen yang diimpor</a> - pustaka tunggal, tidak terikat ke Webpack, mis. Mampu menangani paket atau ESM. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React-async-component</a> - sudah mati perpustakaan (belum populer), yang membuat dampak signifikan pada segala sesuatu di sekitar pemecahan kode, kustom React tree traversal dan SSR. </li><li>  <em>Perpustakaan lain - ada banyak perpustakaan, banyak yang tidak selamat dari evolusi Webpack atau Bereaksi 16 - Saya belum mendaftar di sini, tetapi jika Anda tahu kandidat yang baik - hanya DM saya.</em> </li></ul><br><h3 id="which-library-to-pick">  Perpustakaan mana yang akan dipilih? </h3><br><p>  Mudah - <strong>tidak dapat di-load-re</strong> - berat dan tidak terpelihara, bahkan jika itu masih sangat populer.  (dan terima kasih telah mempopulerkan pemecahan kode, lagi) </p><br><p>  <em>Loadable-components</em> - mungkin merupakan pilihan yang sangat baik.  Itu ditulis dengan sangat baik, dipelihara secara aktif dan mendukung semuanya di luar kotak.  Mendukung "impor dinamis penuh", memungkinkan Anda untuk mengimpor file tergantung pada alat peraga yang diberikan, tetapi dengan demikian tidak dapat diketik.  Mendukung Suspense, jadi bisa menggantikan React.lazy. </p><br><p>  <em>Komponen universal</em> - sebenarnya "penemu" impor dinamis penuh - mereka menerapkannya di Webpack.  Dan banyak hal lain di level rendah - mereka melakukannya.  Saya akan mengatakan - perpustakaan ini agak hardcore, dan sedikit kurang ramah pengguna.  Dokumentasi komponen yang dapat dimuat tidak terkalahkan.  Layak jika tidak menggunakan perpustakaan ini, kemudian membaca dokumentasi - ada begitu banyak detail yang harus Anda ketahui ... </p><br><p>  <em>Bereaksi-impor-komponen</em> - agak aneh.  Ini bundler independen, jadi tidak akan pernah putus (tidak ada yang bisa dipatahkan), akan bekerja dengan Webpack 5 dan 55, tetapi itu harus dibayar.  Sementara pustaka sebelumnya selama SSR akan menambahkan semua skrip yang digunakan ke badan laman, dan Anda akan dapat memuat semua skrip secara paralel - yang diimpor tidak tahu nama file, dan akan memanggil yang asli "impor" (itu sebabnya bundel independen) untuk memuat potongan yang digunakan, tetapi hanya dapat melakukan panggilan dari dalam bundel utama - sehingga semua skrip tambahan akan dimuat hanya setelah yang utama diunduh dan dieksekusi.  Tidak mendukung impor dinamis penuh, seperti React.lazy, dan, sebagai hasilnya, dapat diketik.  Juga mendukung Suspense.  Menggunakan <em>kabel</em> sinkron pada SSR.  Ini juga memiliki pendekatan yang sangat berbeda untuk CSS, dan dukungan aliran rendering sempurna. </p><br><p>  Tidak ada perbedaan dalam kualitas atau popularitas antara perpustakaan yang terdaftar, dan kami semua adalah teman baik - jadi pilihlah sepenuh hati. </p><br><h2 id="grey-zone-3--hybrid-render">  Gray zone 3 - render hybrid </h2><br><p>  SSR adalah hal yang baik, tetapi, Anda tahu, sulit.  Proyek kecil mungkin ingin memiliki SSR - ada banyak alasan untuk memilikinya - tetapi mereka mungkin tidak ingin mengatur dan mempertahankannya. </p><br><blockquote>  SSR bisa benar-benar, SANGAT sulit.  Coba razzle atau lanjutkan dengan Next.js jika Anda ingin kemenangan cepat. </blockquote><p>  Jadi solusi termudah saya untuk SSR, terutama untuk SPA sederhana akan prerendering.  Seperti membuka SPA Anda di browser dan menekan tombol "Simpan".  Seperti: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi-jepret</a> - menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalang</a> (alias Chrome tanpa kepala) untuk merender halaman Anda di "browser" dan menyimpan hasilnya sebagai halaman HTML statis. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendertron</a> - yang melakukan hal yang sama, tetapi dengan cara ( <em>cloud</em> ) yang berbeda. </li></ul><br><p>  Prerender adalah "SSR" tanpa "Server".  SSR menggunakan Klien.  Ajaib!  Dan bekerja di luar kotak ... ... ... tetapi tidak untuk meludah kode. <br>  Jadi - Anda baru saja merender halaman Anda di browser, menyimpan HTML, dan meminta memuat hal yang sama.  Tetapi Kode Spesifik Sisi Server (untuk mengumpulkan semua potongan yang digunakan) tidak digunakan, karena <strong>TIDAK ADA SERVER</strong> ! </p><br><p><img src="https://habrastorage.org/webt/tr/sz/9i/trsz9i4ct8jc7cnwxtm-ljnepuq.png"></p><br><p>  Pada bagian sebelumnya, saya telah menunjuk ke perpustakaan yang terikat ke webpack dalam hal mengumpulkan informasi tentang bongkahan bekas - mereka tidak bisa menangani render hybrid sama sekali. </p><br><blockquote>  Komponen yang dapat dimuat versi 2 (tidak kompatibel dengan versi saat ini 5), sebagian didukung oleh reaksi-jepret.  Dukungan telah hilang. </blockquote><p>  Komponen react-diimpor dapat menangani kasus ini, selama tidak terikat pada bundler / sisi, sehingga tidak ada perbedaan untuk SSR atau Hybrid, tetapi hanya untuk snap reaksi, asalkan mendukung "keadaan hidrasi", sedangkan rendertron tidak. </p><br><blockquote>  Kemampuan komponen reaksi-impor ini ditemukan saat menulis artikel ini, tidak diketahui sebelumnya - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> .  Cukup mudah. </blockquote><p>  Dan di sini Anda harus menggunakan solusi lain, yang hanya tegak lurus dengan semua perpustakaan lain. </p><br><h3 id="react-prerendered-component">  Komponen reaksi-pra-ditangguhkan </h3><br><p>  Perpustakaan ini dibuat untuk sebagian hidrasi, dan sebagian bisa merehidrasi aplikasi Anda, menjaga sisanya tetap terhidrasi.  Dan itu berfungsi untuk perender SSR dan Hybrid tanpa perbedaan apa pun. <br>  Idenya sederhana: </p><br><ul><li>  selama SSR - render komponen, dibungkus dengan &lt;div /&gt; </li><li>  pada klien - temukan div itu, dan gunakan innerHTML hingga Component siap untuk mengganti HTML yang mati. </li><li>  Anda tidak perlu memuat, dan menunggu bongkahan dengan komponen yang terpecah sebelum <code>hydrate</code> untuk <em>TIDAK membuat lubang putih sebagai gantinya</em> - cukup gunakan HTML yang telah dirender sebelumnya, yang benar-benar sama dengan <em>komponen yang</em> akan dihasilkan oleh <em>komponen nyata</em> , dan yang sudah ada - ia datang dengan respons server (atau hidrida). </li></ul><br><blockquote>  Itu sebabnya kita harus menunggu semua bongkar untuk memuat sebelum hidrasi - untuk <strong>mencocokkan</strong> HTML yang diberikan server.  Itu sebabnya kami bisa menggunakan potongan-potongan HTML yang diberikan server sampai klien tidak siap - sama dengan yang hanya akan kami hasilkan. </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PrerenderedComponent} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-prerendered-component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importer = memoizeOne(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Component'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ^ it's very important to keep the "one" promise const Component = React.lazy(importer); // or use any other library with ".prefetch" support // all libraries has it (more or less) const App = () =&gt; ( &lt;PrerenderedComponent live={importer()}&gt; {/* ^ shall return the same promise */ } &lt;Component /&gt; {/* ^ would be rendered when a component goes "live" */ } &lt;/PrerenderedComponent&gt; );</span></span></code> </pre> <br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel lain tentang teknologi ini</a> , Anda mungkin membaca.  Tapi yang utama di sini - ia memecahkan "Flash Of Unloaded Content" di tempat lain, bukan cara yang umum untuk <em>pemecah kode perpustakaan</em> .  Terbuka untuk solusi baru. </p><br><h3 id="tldr">  TLDR? </h3><br><ul><li>  jangan gunakan react-loadable, itu tidak akan menambah nilai berharga </li><li>  React.lazy baik, tapi masih terlalu sederhana. </li><li>  SSR adalah hal yang sulit, dan Anda harus mengetahuinya </li><li>  Render yang digerakkan oleh dalang hybrid adalah suatu hal.  Kadang hal yang lebih sulit. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444402/">https://habr.com/ru/post/id444402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444392/index.html">Radiasi: risiko, keselamatan, perlindungan</a></li>
<li><a href="../id444394/index.html">Linux Foundation meluncurkan proyek DevOps baru dengan Jenkins dan Spinnaker</a></li>
<li><a href="../id444396/index.html">Gerai Epson di ISE 2019 - pameran telah berlalu, kesan tetap ada</a></li>
<li><a href="../id444398/index.html">Mengapa toko non-makanan membutuhkan organisasi swalayan?</a></li>
<li><a href="../id444400/index.html">Bagaimana saya menulis ulang mesin pencari penerbangan dari PHP ke NodeJS</a></li>
<li><a href="../id444404/index.html">Kenapa kita takut dengan robot?</a></li>
<li><a href="../id444406/index.html">Digital Italia. Apa dan bagaimana cara kerjanya</a></li>
<li><a href="../id444408/index.html">Apple merilis iPad baru kemarin dan ada pertanyaan.</a></li>
<li><a href="../id444410/index.html">Peta Jaringan. Tinjauan singkat perangkat lunak untuk membangun peta jaringan</a></li>
<li><a href="../id444414/index.html">Snapdragon 8cx: platform PC 7 nm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>