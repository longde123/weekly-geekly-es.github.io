<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéà üç† üèª C ++ vtables. Teil 1 (Grundlagen + Mehrfachvererbung) ‚úäüèæ üå™Ô∏è üöã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Die √úbersetzung des Artikels wurde speziell f√ºr Studierende des Kurses "C ++ Developer" erstellt . Ist es interessant, sich in diese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ vtables. Teil 1 (Grundlagen + Mehrfachvererbung)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/479802/"><p>  <em>Hallo allerseits!</em>  <em>Die √úbersetzung des Artikels wurde speziell f√ºr Studierende des Kurses <a href="https://otus.pw/d2qJ/">"C ++ Developer" erstellt</a> .</em>  <em>Ist es interessant, sich in diese Richtung zu entwickeln?</em>  <em>Kommen Sie am 13. Dezember um 20:00 Uhr Moskauer Zeit online.</em>  <em>zur Meisterklasse <a href="https://otus.pw/x79M/">"√úben mit dem Google Test Framework"</a> !</em> </p><br><p><img src="https://habrastorage.org/webt/eh/lh/ox/ehlhoxzs1sz7v7xtni9lizjefxq.png"></p><br><p>  In diesem Artikel werden wir uns ansehen, wie clang vtables (virtuelle Methodentabellen) und RTTI (Runtime Type Identification) implementiert.  Im ersten Teil beginnen wir mit den Basisklassen und betrachten dann die mehrfache und virtuelle Vererbung. <a name="habracut"></a></p><br><p>  Bitte beachten Sie, dass wir in diesem Artikel die Bin√§rdarstellung untersuchen m√ºssen, die mit gdb f√ºr verschiedene Teile unseres Codes generiert wurde.  Dies ist ein ziemlich niedriges Niveau, aber ich werde die ganze harte Arbeit f√ºr Sie tun.  Ich glaube nicht, dass die meisten zuk√ºnftigen Posts die Details eines so niedrigen Niveaus beschreiben werden. </p><br><blockquote>  <em>Haftungsausschluss</em> : Alles, was hier geschrieben wird, h√§ngt von der Implementierung ab und kann sich in zuk√ºnftigen Versionen √§ndern. Sie sollten sich also nicht darauf verlassen.  Wir betrachten dies nur zu Bildungszwecken. </blockquote><p><img src="https://habrastorage.org/webt/40/po/du/40podustjhxkcl7_keexd9uea2e.png"></p><br><p>  ausgezeichnet, dann lass uns anfangen. </p><br><h2 id="chast-1---vtables---osnovy">  Teil 1 - vtables - Grundlagen </h2><br><p>  Schauen wir uns den folgenden Code an: </p><br><pre><code class="plaintext hljs">#include &lt;iostream&gt; using namespace std; class NonVirtualClass { public: void foo() {} }; class VirtualClass { public: virtual void foo() {} }; int main() { cout &lt;&lt; "Size of NonVirtualClass: " &lt;&lt; sizeof(NonVirtualClass) &lt;&lt; endl; cout &lt;&lt; "Size of VirtualClass: " &lt;&lt; sizeof(VirtualClass) &lt;&lt; endl; }</code> </pre> <br><pre> <code class="plaintext hljs">$ #    main.cpp $ clang++ main.cpp &amp;&amp; ./a.out Size of NonVirtualClass: 1 Size of VirtualClass: 8</code> </pre> <br><p>  <code>NonVirtualClass</code> hat eine Gr√∂√üe von 1 Byte, da in C ++ Klassen keine Gr√∂√üe von Null haben k√∂nnen.  Dies ist jedoch jetzt nicht wichtig. </p><br><p>  <code>VirtualClass</code> ist 8 Byte auf einem 64-Bit-Computer.  Warum?  Weil sich im Inneren ein versteckter Zeiger befindet, der auf eine vtable zeigt.  vtables sind statische √úbersetzungstabellen, die f√ºr jede virtuelle Klasse erstellt werden.  Dieser Artikel spricht √ºber ihren Inhalt und wie sie verwendet werden. </p><br><p>  Sehen wir uns den folgenden Code mit gdb an, um herauszufinden, wie Speicher zugewiesen wird, um ein besseres Verst√§ndnis f√ºr die Darstellung von vtables zu erhalten: </p><br><pre> <code class="plaintext hljs">#include &lt;iostream&gt; class Parent { public: virtual void Foo() {} virtual void FooNotOverridden() {} }; class Derived : public Parent { public: void Foo() override {} }; int main() { Parent p1, p2; Derived d1, d2; std::cout &lt;&lt; "done" &lt;&lt; std::endl; }</code> </pre> <br><pre> <code class="plaintext hljs">$ #         ,  gdb $ clang++ -std=c++14 -stdlib=libc++ -g main.cpp &amp;&amp; gdb ./a.out ... (gdb) #  gdb  -  C++ (gdb) set print asm-demangle on (gdb) set print demangle on (gdb) #     main (gdb) b main Breakpoint 1 at 0x4009ac: file main.cpp, line 15. (gdb) run Starting program: /home/shmike/cpp/a.out Breakpoint 1, main () at main.cpp:15 15 Parent p1, p2; (gdb) #     (gdb) n 16 Derived d1, d2; (gdb) #     (gdb) n 18 std::cout &lt;&lt; "done" &lt;&lt; std::endl; (gdb) #  p1, p2, d1, d2 -     ,    (gdb) p p1 $1 = {_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;} (gdb) p p2 $2 = {_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;} (gdb) p d1 $3 = {&lt;Parent&gt; = {_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;}, &lt;No data fields&gt;} (gdb) p d2 $4 = {&lt;Parent&gt; = {_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;}, &lt;No data fields&gt;}</code> </pre> <br><p>  Folgendes haben wir daraus gelernt: <br>  - Obwohl Klassen keine Datenelemente haben, gibt es einen versteckten Zeiger auf vtable. <br>  - vTabelle f√ºr p1 und p2 ist gleich.  vtables sind statische Daten f√ºr jeden Typ. <br>  - d1 und d2 erben den vtable-Zeiger von Parent, der auf vtable Derived zeigt; <br>  - Alle vtables geben einen Versatz von 16 (0x10) Bytes in der vtable an.  Wir werden das sp√§ter noch besprechen. </p><br><p>  Setzen wir unsere gdb-Sitzung fort, um den Inhalt von vtables zu sehen.  Ich werde den Befehl x verwenden, der den Speicher auf dem Bildschirm anzeigt.  Wir werden 300 Bytes hexadezimal ausgeben, beginnend mit 0x400b40.  Warum genau diese Adresse?  Weil wir oben gesehen haben, dass der vtable-Zeiger auf 0x400b50 zeigt und das Symbol f√ºr diese Adresse <code>vtable for Derived+16 (16 == 0x10)</code> . </p><br><pre> <code class="plaintext hljs">(gdb) x/300xb 0x400b40 0x400b40 &lt;vtable for Derived&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b48 &lt;vtable for Derived+8&gt;: 0x90 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400b50 &lt;vtable for Derived+16&gt;: 0x80 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b58 &lt;vtable for Derived+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400b60 &lt;typeinfo name for Derived&gt;: 0x37 0x44 0x65 0x72 0x69 0x76 0x65 0x64 0x400b68 &lt;typeinfo name for Derived+8&gt;: 0x00 0x36 0x50 0x61 0x72 0x65 0x6e 0x74 0x400b70 &lt;typeinfo name for Parent+7&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b78 &lt;typeinfo for Parent&gt;: 0x90 0x20 0x60 0x00 0x00 0x00 0x00 0x00 0x400b80 &lt;typeinfo for Parent+8&gt;: 0x69 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400b88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400b90 &lt;typeinfo for Derived&gt;: 0x10 0x22 0x60 0x00 0x00 0x00 0x00 0x00 0x400b98 &lt;typeinfo for Derived+8&gt;: 0x60 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400ba0 &lt;typeinfo for Derived+16&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400ba8 &lt;vtable for Parent&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x400bb0 &lt;vtable for Parent+8&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x00 0x400bb8 &lt;vtable for Parent+16&gt;: 0xa0 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 0x400bc0 &lt;vtable for Parent+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x00 ...</code> </pre> <br><blockquote>  Hinweis: Wir betrachten dekorierte (entwirrte) Charaktere.  Wenn Sie wirklich interessiert sind, ist _ZTV das Pr√§fix f√ºr vtable, _ZTS das Pr√§fix f√ºr den Typ string (name) und _ZTI f√ºr typeinfo. </blockquote><br><hr><br><p>  Hier ist die <code>vtable Parent</code> Struktur von <code>vtable Parent</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x400ba8 </td><td>  0x0 </td><td>  top_offset (dazu sp√§ter mehr) </td></tr><tr><td>  0x400bb0 </td><td>  0x400b78 </td><td>  Zeiger auf TypInfo f√ºr Parent (ebenfalls Teil des obigen Speicherauszugs) </td></tr><tr><td>  0x400bb8 </td><td>  0x400aa0 </td><td>  Zeiger auf Parent :: Foo () <em>(1)</em> .  _vptr √úbergeordnete Punkte hier. </td></tr><tr><td>  0x400bc0 </td><td>  0x400a90 </td><td>  Zeiger auf Parent :: FooNotOverridden () <em>(2)</em> </td></tr></tbody></table></div><br><p>  Hier ist die von <code>vtable Derived</code> Struktur: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x400b40 </td><td>  0x0 </td><td>  top_offset (dazu sp√§ter mehr) </td></tr><tr><td>  0x400b48 </td><td>  0x400b90 </td><td>  Zeiger auf TypInfo f√ºr Abgeleitet (auch Teil des obigen Speicherauszugs) </td></tr><tr><td>  0x400b50 </td><td>  0x400a80 </td><td>  Zeiger auf Abgeleitet :: Foo () <em>(3)</em> ., _ Vptr Abgeleitete Punkte hier. </td></tr><tr><td>  0x400b58 </td><td>  0x400a90 </td><td>  Zeiger auf Parent :: FooNotOverridden () (wie Parent) </td></tr></tbody></table></div><br><p>  1: </p><br><pre> <code class="plaintext hljs">(gdb) # ,        0x400aa0 (gdb) info symbol 0x400aa0 Parent::Foo() in section .text of a.out</code> </pre> <br><p>  2: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x400a90 Parent::FooNotOverridden() in section .text of a.out</code> </pre> <br><p>  3: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x400a80 Derived::Foo() in section .text of a.out</code> </pre> <br><p>  Denken Sie daran, dass der vtable-Zeiger in Derived auf einen Versatz von +16 Bytes in der vtable zeigte?  Der dritte Zeiger ist die Adresse des Zeigers der ersten Methode.  Willst du eine dritte Methode?  Kein Problem - f√ºgen Sie dem vtable-Zeiger 2 <em>sizeof (void</em> ) hinzu.  M√∂chten Sie einen Typeinfo-Datensatz?  Gehe zum Zeiger davor. </p><br><p>  Weitermachen - wie sieht es mit der Typeinfo-Datensatzstruktur aus? </p><br><p>  <code>Parent</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x400b78 </td><td>  0x602090 </td><td>  Hilfsklasse f√ºr type_info <em>(1)</em> -Methoden </td></tr><tr><td>  0x400b80 </td><td>  0x400b69 </td><td>  Eine Zeichenfolge, die den Typnamen darstellt <em>(2)</em> </td></tr><tr><td>  0x400b88 </td><td>  0x0 </td><td>  0 bedeutet, dass kein √ºbergeordneter Typeinfo-Eintrag vorhanden ist </td></tr></tbody></table></div><br><p>  Und hier ist die <code>typeinfo Derived</code> Eintrag: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x400b90 </td><td>  0x602210 </td><td>  Hilfsklasse f√ºr type_info <em>(3)</em> -Methoden </td></tr><tr><td>  0x400b98 </td><td>  0x400b60 </td><td>  Zeichenfolge, die den Typnamen darstellt <em>(4)</em> </td></tr><tr><td>  0x400ba0 </td><td>  0x400b78 </td><td>  Zeiger auf einen TypInfo Parent-Eintrag </td></tr></tbody></table></div><br><p>  1: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x602090 vtable for __cxxabiv1::__class_type_info@@CXXABI_1.3 + 16 in section .bss of a.out</code> </pre> <br><p>  2: </p><br><pre> <code class="plaintext hljs">(gdb) x/s 0x400b69 0x400b69 &lt;typeinfo name for Parent&gt;: "6Parent"</code> </pre> <br><p>  3: </p><br><pre> <code class="plaintext hljs">(gdb) info symbol 0x602210 vtable for __cxxabiv1::__si_class_type_info@@CXXABI_1.3 + 16 in section .bss of a.out</code> </pre> <br><p>  4: </p><br><pre> <code class="plaintext hljs">(gdb) x/s 0x400b60 0x400b60 &lt;typeinfo name for Derived&gt;: "7Derived"</code> </pre> <br><p>  Wenn Sie mehr √ºber __si_class_type_info erfahren m√∂chten, finden Sie <a href="https://refspecs.linuxfoundation.org/LSB_4.0.0/LSB-CXX-generic/LSB-CXX-generic/baselib.html">hier</a> und <a href="https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc%2B%2B/api/a01094_source.html">hier</a> einige Informationen. </p><br><p>  Dies ersch√∂pft meine F√§higkeiten mit GDB und vervollst√§ndigt auch diesen Teil.  Ich schlage vor, dass einige Leute dies f√ºr zu niedrig oder einfach nicht von praktischem Wert halten.  In diesem Fall w√ºrde ich empfehlen, die Teile 2 und 3 zu √ºberspringen und direkt zu <a href="https://shaharmike.com/cpp/vtable-part4/">Teil 4 √ºberzugehen</a> . </p><br><h2 id="chast-2---mnozhestvennoe-nasledovanie">  Teil 2 - Mehrfachvererbung </h2><br><p>  Die Welt der einzelnen Vererbungshierarchien ist f√ºr den Compiler einfacher.  Wie wir im ersten Teil gesehen haben, erweitert jede untergeordnete Klasse die √ºbergeordnete vtable, indem Eintr√§ge f√ºr jede neue virtuelle Methode hinzugef√ºgt werden. </p><br><p>  Betrachten wir die Mehrfachvererbung, die die Situation kompliziert, selbst wenn die Vererbung nur √ºber Schnittstellen implementiert wird. </p><br><p>  Schauen wir uns den folgenden Codeausschnitt an: </p><br><pre> <code class="plaintext hljs">class Mother { public: virtual void MotherMethod() {} int mother_data; }; class Father { public: virtual void FatherMethod() {} int father_data; }; class Child : public Mother, public Father { public: virtual void ChildMethod() {} int child_data; };</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Kinderstruktur </th></tr></thead><tbody><tr><td>  _vptr $ Mutter </td></tr><tr><td>  Mutter_Daten (+ Auff√ºllen) </td></tr><tr><td>  Vater </td></tr><tr><td>  father_data </td></tr><tr><td>  child_data <em>(1)</em> </td></tr></tbody></table></div><br><p>  Beachten Sie, dass es 2 vtable-Zeiger gibt.  Intuitiv w√ºrde ich 1 oder 3 Zeiger erwarten (Mutter, Vater und Kind).  Tats√§chlich ist es unm√∂glich, einen Zeiger zu haben (dazu sp√§ter mehr), und der Compiler ist intelligent genug, um die Eintr√§ge der untergeordneten Tabelle Child als Fortsetzung der untergeordneten Tabelle Mother zu kombinieren, wodurch 1 Zeiger gespeichert wird. </p><br><p>  Warum kann ein Kind nicht einen vtable-Zeiger f√ºr alle drei Typen haben?  Denken Sie daran, dass ein untergeordneter Zeiger an eine Funktion √ºbergeben werden kann, die einen Mutter- oder Vaterzeiger akzeptiert, und beide erwarten, dass dieser Zeiger die richtigen Daten an den richtigen Offsets enth√§lt.  Diese Funktionen m√ºssen nichts √ºber Child wissen, und Sie sollten definitiv nicht davon ausgehen, dass Child wirklich das ist, was sich unter dem Mutter / Vater-Zeiger befindet, mit dem sie arbeiten. </p><br><p>  <em>(1) Es ist f√ºr dieses Thema nicht relevant, aber dennoch ist es interessant, dass child_data tats√§chlich in die F√ºllung von Father eingef√ºgt wird.</em>  <em>Dies wird als Schwanzpolsterung bezeichnet und ist m√∂glicherweise Gegenstand eines zuk√ºnftigen Beitrags.</em> </p><br><p>  Hier ist die <code>vtable</code> Struktur: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x4008b8 </td><td>  0 </td><td>  top_offset (dazu sp√§ter mehr) </td></tr><tr><td>  0x4008c0 </td><td>  0x400930 </td><td>  Zeiger auf TypInfo f√ºr Child </td></tr><tr><td>  0x4008c8 </td><td>  0x400800 </td><td>  Mother :: MotherMethod ().  _vptr $ Mutter zeigt hier. </td></tr><tr><td>  0x4008d0 </td><td>  0x400810 </td><td>  Child :: ChildMethod () </td></tr><tr><td>  0x4008d8 </td><td>  -16 </td><td>  top_offset (dazu sp√§ter mehr) </td></tr><tr><td>  0x4008e0 </td><td>  0x400930 </td><td>  Zeiger auf TypInfo f√ºr Child </td></tr><tr><td>  0x4008e8 </td><td>  0x400820 </td><td>  Father :: FatherMethod ().  _vptr $ Vater zeigt hier. </td></tr></tbody></table></div><br><p>  In diesem Beispiel hat die Child-Instanz denselben Zeiger, wenn sie auf den Mother-Zeiger umwandelt.  Beim Umwandeln in den Vater-Zeiger berechnet der Compiler den Versatz dieses Zeigers, um auf den _vptr $ Vater-Teil des Kindes zu verweisen (3. Feld in der Kind-Struktur, siehe obige Tabelle). </p><br><p>  Mit anderen Worten, f√ºr ein gegebenes Kind c: (nichtig <em>) &amp; c! = (Nichtig</em> ) static_cast &lt;Vater *&gt; (&amp; c).  Einige Leute erwarten dies nicht, und vielleicht sparen Sie eines Tages mit diesen Informationen einige Zeit beim Debuggen. </p><br><p>  Ich fand das mehr als einmal n√ºtzlich.  Aber warte, das ist noch nicht alles. </p><br><p>  Was ist, wenn das Kind beschlie√üt, eine der Methoden des Vaters au√üer Kraft zu setzen?  Betrachten Sie diesen Code: </p><br><pre> <code class="plaintext hljs">class Mother { public: virtual void MotherFoo() {} }; class Father { public: virtual void FatherFoo() {} }; class Child : public Mother, public Father { public: void FatherFoo() override {} };</code> </pre> <br><p>  Die Situation wird schwieriger.  Die Funktion kann das Argument Father * annehmen und FatherFoo () daf√ºr aufrufen.  Wenn Sie jedoch die Child-Instanz √ºbergeben, wird erwartet, dass die √ºberschriebene Child-Methode mit dem richtigen Zeiger aufgerufen wird.  Der Anrufer wei√ü jedoch nicht, dass er wirklich Child enth√§lt.  Es hat einen Zeiger auf den Child-Offset, an dem sich der Standort des Vaters befindet.  Jemand muss diesen Zeiger versetzen, aber wie geht das?  Welche Magie macht der Compiler, um diese Arbeit zu machen? </p><br><p>  <em>Beachten Sie, dass das √úberschreiben einer der Mother-Methoden nicht sehr schwierig ist, da dieser Zeiger derselbe ist, bevor wir darauf antworten.</em>  <em>Child wei√ü, was nach vtable Mother zu lesen ist, und erwartet, dass Child-Methoden direkt danach sind.</em> </p><br><p>  Hier ist die L√∂sung: Der Compiler erstellt eine Thunk-Methode, die diesen Zeiger korrigiert und dann die "echte" Methode aufruft.  Die Adresse der Adaptermethode befindet sich unter der vtable Father, w√§hrend sich die "echte" Methode unter der vtable Child befindet. </p><br><p>  Hier ist der <code>vtable Child</code> : </p><br><pre> <code class="plaintext hljs">0x4008e8 &lt;vtable for Child&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x4008f0 &lt;vtable for Child+8&gt;: 0x60 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x4008f8 &lt;vtable for Child+16&gt;: 0x00 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400900 &lt;vtable for Child+24&gt;: 0x10 0x08 0x40 0x00 0x00 0x00 0x00 0x00 0x400908 &lt;vtable for Child+32&gt;: 0xf8 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0x400910 &lt;vtable for Child+40&gt;: 0x60 0x09 0x40 0x00 0x00 0x00 0x00 0x00 0x400918 &lt;vtable for Child+48&gt;: 0x20 0x08 0x40 0x00 0x00 0x00 0x00 0x00</code> </pre> <br><p>  Was bedeutet: </p><br><div class="scrollable-table"><table><thead><tr><th>  Die Adresse </th><th>  Wert </th><th>  Inhalt </th></tr></thead><tbody><tr><td>  0x4008e8 </td><td>  0 </td><td>  top_offset (kommt bald!) </td></tr><tr><td>  0x4008f0 </td><td>  0x400960 </td><td>  typeinfo f√ºr kind </td></tr><tr><td>  0x4008f8 </td><td>  0x400800 </td><td>  Mutter :: MotherFoo () </td></tr><tr><td>  0x400900 </td><td>  0x400810 </td><td>  Kind :: FatherFoo () </td></tr><tr><td>  0x400908 </td><td>  -8 </td><td>  top_offset </td></tr><tr><td>  0x400910 </td><td>  0x400960 </td><td>  typeinfo f√ºr kind </td></tr><tr><td>  0x400918 </td><td>  0x400820 </td><td>  kein virtueller Adapter Child :: FatherFoo () </td></tr></tbody></table></div><br><p>  Erkl√§rung: Wie wir zuvor gesehen haben, hat Child 2 vtables - eine wird f√ºr Mutter und Kind und die andere f√ºr Vater verwendet.  In vtable Father verweist FatherFoo () auf einen ‚ÄûAdapter‚Äú und in vtable Child direkt auf Child :: FatherFoo (). </p><br><p>  Und was ist in diesem "Adapter", fragst du? </p><br><pre> <code class="plaintext hljs">(gdb) disas /m 0x400820, 0x400850 Dump of assembler code from 0x400820 to 0x400850: 15 void FatherFoo() override {} 0x0000000000400820 &lt;non-virtual thunk to Child::FatherFoo()+0&gt;: push %rbp 0x0000000000400821 &lt;non-virtual thunk to Child::FatherFoo()+1&gt;: mov %rsp,%rbp 0x0000000000400824 &lt;non-virtual thunk to Child::FatherFoo()+4&gt;: sub $0x10,%rsp 0x0000000000400828 &lt;non-virtual thunk to Child::FatherFoo()+8&gt;: mov %rdi,-0x8(%rbp) 0x000000000040082c &lt;non-virtual thunk to Child::FatherFoo()+12&gt;: mov -0x8(%rbp),%rdi 0x0000000000400830 &lt;non-virtual thunk to Child::FatherFoo()+16&gt;: add $0xfffffffffffffff8,%rdi 0x0000000000400837 &lt;non-virtual thunk to Child::FatherFoo()+23&gt;: callq 0x400810 &lt;Child::FatherFoo()&gt; 0x000000000040083c &lt;non-virtual thunk to Child::FatherFoo()+28&gt;: add $0x10,%rsp 0x0000000000400840 &lt;non-virtual thunk to Child::FatherFoo()+32&gt;: pop %rbp 0x0000000000400841 &lt;non-virtual thunk to Child::FatherFoo()+33&gt;: retq 0x0000000000400842: nopw %cs:0x0(%rax,%rax,1) 0x000000000040084c: nopl 0x0(%rax)</code> </pre> <br><p>  Wie wir bereits besprochen haben, handelt es sich um Offsets, und FatherFoo () wird aufgerufen.  Und um wie viel sollten wir das verschieben, um ein Kind zu bekommen?  top_offset! </p><br><p>  <em>Bitte beachten Sie, dass ich pers√∂nlich den nicht virtuellen Thunk-Namen als √§u√üerst verwirrend empfinde, da es sich um einen virtuellen Tabelleneintrag f√ºr eine virtuelle Funktion handelt.</em>  <em>Ich bin mir nicht sicher, ob es nicht virtuell ist, aber dies ist nur meine Meinung.</em> </p><br><hr><br><p>  <em>Das ist alles f√ºr jetzt, in naher Zukunft werden wir 3 und 4 Teile √ºbersetzen.</em>  <em>Befolgen Sie die Nachrichten!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479802/">https://habr.com/ru/post/de479802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479780/index.html">DevOps Moscow Meetup 17/12: Nehmen Sie an der Sendung teil</a></li>
<li><a href="../de479790/index.html">Drei Inkubatoren f√ºhrten Prototyping-Kurse f√ºr die erste Gruppe von Studenten durch</a></li>
<li><a href="../de479794/index.html">Wir kombinieren den "Kinder" Mikrocontroller und Brettspiele</a></li>
<li><a href="../de479796/index.html">Kingstons Thanos Level-Bedrohung</a></li>
<li><a href="../de479800/index.html">Ich schreibe in C #, damit das Front-End einfacher ist</a></li>
<li><a href="../de479810/index.html">Wie ich einen wissenschaftlichen Artikel in Nature ver√∂ffentlicht habe</a></li>
<li><a href="../de479814/index.html">Active Directory-Datenschutzproblem</a></li>
<li><a href="../de479816/index.html">Kombinatorik in Python</a></li>
<li><a href="../de479818/index.html">Wie beurteilen Sie Ihre Englischkenntnisse?</a></li>
<li><a href="../de479820/index.html">Was soll man unter einen IT-Baum stellen? Bin√§re Uhr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>