<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏽 🎎 🤹 Pemeriksaan kesehatan dan degradasi bertahap sistem terdistribusi 👩🏻‍🔧 🎤 👩🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti biasa, terima kasih kepada Fred Hebert dan Sargun Dhillon untuk membaca draf artikel ini dan menawarkan beberapa saran yang sangat berharga. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemeriksaan kesehatan dan degradasi bertahap sistem terdistribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/433462/"><img src="https://habrastorage.org/webt/nv/bv/x0/nvbvx0meh2jzpwpvwzgvtpni1jk.png"><br><p>  <i>Seperti biasa, terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fred Hebert</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sargun Dhillon</a> untuk membaca draf artikel ini dan menawarkan beberapa saran yang sangat berharga.</i> </p><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembicaraannya tentang kecepatan,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tamar Berkovichi</a> of Box menekankan pentingnya pemeriksaan kinerja untuk kegagalan basis data otomatis.  Secara khusus, ia mencatat bahwa pemantauan waktu eksekusi query end-to-end, sebagai metode untuk menentukan kesehatan database, lebih baik daripada ping sederhana (ping). </p><br><blockquote> ... mentransfer lalu lintas ke node lain (replika) untuk menghilangkan kelambanan, perlu untuk membangun perlindungan dari bouncing dan situasi perbatasan lainnya.  Itu tidak sulit.  Fokus dalam mengorganisasikan kerja yang efektif adalah untuk mengetahui <strong>kapan</strong> harus meletakkan basis data di posisi pertama, mis.  Anda harus dapat mengevaluasi kesehatan database dengan benar.  Sekarang, banyak parameter yang biasa kita perhatikan - misalnya, beban prosesor, latensi, tingkat kesalahan - adalah sinyal sekunder.  Tak satu pun dari parameter ini yang benar-benar berbicara tentang kemampuan basis data untuk memproses lalu lintas klien.  Karena itu, jika Anda menggunakannya untuk membuat keputusan tentang beralih, Anda bisa mendapatkan hasil positif palsu dan negatif palsu.  Pemeriksa kesehatan kami benar-benar melakukan kueri sederhana pada node basis data dan menggunakan data pada kueri yang lengkap dan gagal untuk menilai kesehatan basis data secara lebih akurat. </blockquote><p>  Saya membahas hal ini dengan seorang teman, dan dia menyarankan agar pemeriksaan kesehatan harus sangat sederhana, dan bahwa lalu lintas nyata adalah kriteria terbaik untuk mengevaluasi kesehatan suatu proses. </p><a name="habracut"></a><br><p>  Seringkali, diskusi yang terkait dengan pelaksanaan pemeriksaan kesehatan berputar di sekitar dua opsi yang berlawanan: komunikasi sederhana / tes sinyal atau tes ujung ke ujung yang kompleks.  Dalam artikel ini saya ingin menekankan masalah yang terkait dengan penggunaan bentuk pemeriksaan kesehatan yang disebutkan di atas untuk beberapa jenis solusi penyeimbangan beban, serta perlunya pendekatan yang lebih rinci untuk menilai kesehatan suatu proses. </p><br><h3 id="dva-tipa-proverok-rabotosposobnosti">  Dua jenis pemeriksaan kesehatan </h3><br><p>  Pemeriksaan kesehatan, bahkan dalam banyak sistem modern, pada umumnya, terbagi dalam dua kategori: pemeriksaan di tingkat simpul dan di tingkat layanan. </p><br><p> Misalnya, Kubernet mengimplementasikan validasi dengan menganalisis <em>kesiapan</em> dan <em>kemampuan bertahan</em> .  Pemeriksaan ketersediaan digunakan untuk menentukan kemampuan perapian untuk melayani lalu lintas.  Jika pemeriksaan kesiapan tidak dilakukan, itu dihapus dari titik akhir yang membentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan</a> , dan karena ini, di perapian, sampai pemeriksaan selesai, tidak ada lalu lintas yang diarahkan.  Di sisi lain, pemeriksaan kemampuan bertahan digunakan untuk menentukan apakah <em>suatu</em> layanan <em>merespons</em> hang atau terkunci.  Jika gagal, masing-masing wadah di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubelet dihidupkan ulang</a> .  Demikian pula, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsul</a> memungkinkan beberapa bentuk <code>checks</code> : berbasis <code>script</code> , <code>checks</code> berbasis HTTP diarahkan ke URL tertentu, pemeriksaan berbasis TTL, atau bahkan alias. </p><br><p>  Metode yang paling umum untuk menerapkan pemeriksaan kesehatan di tingkat <em>layanan</em> adalah menentukan titik akhir pemeriksaan kesehatan.  Misalnya, di gRPC, pemeriksaan kesehatan sendiri menjadi panggilan RPC.  gRPC juga memungkinkan untuk pemeriksaan kesehatan tingkat layanan dan <em>pemeriksaan kesehatan server gRPC</em> umum. </p><br><p>  Di masa lalu, pemeriksaan kesehatan tingkat inang digunakan sebagai sinyal untuk memicu peringatan.  Misalnya, peringatan dengan beban prosesor rata-rata (saat ini dianggap sebagai pola anti-desain).  Sekalipun pemeriksaan kesehatan tidak digunakan secara langsung untuk pemberitahuan, itu tetap berfungsi sebagai dasar untuk sejumlah keputusan infrastruktur otomatis lainnya, misalnya, mengenai keseimbangan beban dan (kadang-kadang) sirkuit terbuka.  Dalam skema data kisi-kisi layanan seperti Utusan, data <em>pemeriksaan kesehatan</em> , ketika harus menentukan perutean lalu lintas ke suatu instance, terus berjalan sehubungan dengan data penemuan layanan. </p><br><h3 id="rabotosposobnost--eto-spektr-a-ne-binarnaya-taksonomiya">  Efisiensi adalah spektrum, bukan taksonomi biner </h3><br><p>  Permintaan gema, atau ping, hanya dapat menetapkan apakah layanan <em>berfungsi</em> , sedangkan tes ujung ke ujung adalah proxy untuk menetapkan apakah sistem mampu melakukan <em>unit kerja tertentu</em> , di mana unit kerja dapat berupa <em>kueri basis data</em> atau <em>perhitungan tertentu</em> .  Terlepas dari bentuk pemeriksaan kesehatan, <em>hasilnya</em> dianggap sebagai biner murni: "lulus" atau "gagal". </p><br><p>  Dalam opsi infrastruktur yang dinamis dan sering kali "secara otomatis diskalakan", satu proses yang hanya "bekerja" tidak masalah jika tidak dapat melakukan unit kerja tertentu.  Ternyata pemeriksaan yang disederhanakan, seperti pengujian gema, hampir tidak berguna. </p><br><p>  Sangat mudah untuk menentukan kapan suatu layanan benar-benar <em>terputus</em> , tetapi untuk menetapkan tingkat <em>operabilitas dari</em> layanan yang berjalan jauh lebih sulit.  Sangat mungkin bahwa proses sedang berjalan (mis., Pemeriksaan kesehatan berlalu), dan lalu lintas dialihkan, tetapi untuk melakukan unit kerja tertentu, misalnya, selama periode keterlambatan layanan p99, ini tidak cukup. </p><br><p>  Seringkali, pekerjaan tidak dapat diselesaikan karena prosesnya kelebihan beban.  Dalam layanan yang sangat kompetitif, "kemacetan" berkorelasi rapi dengan jumlah permintaan bersamaan yang diproses hanya oleh satu proses dengan antrian berlebihan, yang dapat menyebabkan peningkatan penundaan untuk panggilan RPC (meskipun lebih sering, layanan tingkat bawah hanya menahan permintaan dan mencoba lagi pada batas waktu).  Ini terutama benar jika titik akhir pemeriksaan kesehatan dikonfigurasi untuk secara otomatis kembali ke kode status HTTP 200, sedangkan operasi aktual yang dilakukan oleh layanan melibatkan I / O jaringan atau perhitungan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/420/7bf/d6b/4207bfd6ba6f7c4afd6892c8f643112d.png" alt="gambar"></p><br><p>  Kinerja proses adalah sebuah spektrum.  Pertama-tama, kami tertarik pada <em>kualitas layanan</em> , misalnya, waktu yang diperlukan untuk proses mengembalikan hasil unit kerja tertentu, dan keakuratan hasilnya. </p><br><p>  Ada kemungkinan bahwa proses berfluktuasi antara berbagai tingkat <em>kapasitas kerja</em> selama masa kerjanya: dari <em>kapasitas kerja</em> penuh (misalnya, kemampuan untuk berfungsi pada tingkat paralelisme yang diharapkan) ke titik tidak dapat dioperasikannya (ketika antrian mulai terisi) dan titik di mana proses sepenuhnya masuk ke zona tidak beroperasi (dirasakan) mengurangi kualitas layanan).  Hanya layanan yang paling sepele yang dapat dibangun dengan asumsi bahwa tidak ada tingkat kegagalan parsial dalam periode di mana kegagalan parsial menyiratkan bahwa beberapa fungsi berfungsi dan yang lainnya dimatikan, dan tidak hanya "beberapa permintaan dieksekusi, beberapa tidak dieksekusi".  Jika arsitektur layanan tidak memungkinkan memperbaiki sebagian kegagalan dengan benar, maka <em>klien</em> secara otomatis memperbaiki tugas koreksi kesalahan. </p><br><p>  Infrastruktur penyembuhan diri yang adaptif harus dibangun dengan pemahaman bahwa fluktuasi seperti itu sangat <em>normal</em> .  Penting juga untuk diingat bahwa perbedaan ini hanya penting dalam kaitannya dengan penyeimbangan beban - untuk orkestra, misalnya, tidak masuk akal untuk memulai kembali proses hanya karena proses berada di ambang kelebihan beban. </p><br><p>  Dengan kata lain, untuk tingkat orkestrasi, cukup masuk akal untuk mempertimbangkan operabilitas proses sebagai keadaan biner dan memulai kembali proses hanya setelah kegagalan atau pembekuan.  Tetapi di lapisan <em>penyeimbangan beban</em> (apakah itu proxy eksternal, misalnya, Utusan, atau perpustakaan internal di sisi klien), sangat penting bahwa itu bertindak berdasarkan informasi yang lebih terperinci tentang pengoperasian proses - ketika membuat keputusan yang tepat tentang memutus rangkaian dan membuang muatan.  Degradasi bertahap layanan tidak mungkin jika tidak mungkin untuk secara akurat menentukan tingkat kinerja layanan setiap saat. </p><br><p>  Biarkan saya memberi tahu Anda dari pengalaman: konkurensi tak terbatas seringkali merupakan faktor utama yang menyebabkan penurunan layanan atau penurunan produktivitas secara permanen.  Penyeimbangan beban (dan, sebagai akibatnya, penumpahan beban) sering bermuara pada pengelolaan konkurensi secara efisien dan menerapkan tekanan balik, mencegah sistem dari kelebihan muatan. </p><br><h3 id="neobhodimost-obratnoy-svyazi-pri-primenenii-protivodavleniya">  Kebutuhan akan umpan balik saat menerapkan tekanan balik </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matt Ranney</a> menulis sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel fenomenal</a> tentang konkurensi tak terbatas dan kebutuhan akan tekanan balik di Node.js.  Seluruh artikel ini penasaran, tetapi kesimpulan utama (setidaknya bagi saya) adalah perlunya umpan balik antara proses dan unit outputnya (biasanya penyeimbang beban, tetapi terkadang layanan lain). </p><br><blockquote>  Kuncinya adalah ketika sumber daya habis, sesuatu harus diberikan di suatu tempat.  Permintaan tumbuh, dan produktivitas tidak dapat secara ajaib meningkat.  Untuk membatasi tugas yang masuk, hal pertama yang harus dilakukan adalah menetapkan batas kecepatan tertentu di tingkat situs, berdasarkan alamat IP, pengguna, sesi, atau, paling-paling, oleh beberapa elemen penting untuk aplikasi.  Banyak penyeimbang beban dapat membatasi kecepatan dengan cara yang lebih rumit daripada membatasi server Node.js yang masuk, tetapi biasanya mereka tidak melihat masalah sampai prosesnya dalam situasi yang sulit. </blockquote><p>  Batas kecepatan dan sirkuit terbuka berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ambang dan batas statis bisa tidak dapat diandalkan dan tidak stabil</a> dalam hal kebenaran dan skalabilitas.  Beberapa load balancers (khususnya, HAProxy) menyediakan banyak statistik tentang panjang antrian internal untuk <em>setiap server</em> dan <em>bagian server</em> .  Selain itu, HAProxy memungkinkan <code>agent-check</code> (pemeriksaan tambahan tidak tergantung pada pemeriksaan kesehatan normal), yang memungkinkan proses menyediakan server proxy dengan umpan balik kesehatan yang lebih akurat dan dinamis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke dokumen</a> : </p><br><blockquote>  Pemeriksaan kesehatan agen dilakukan oleh koneksi TCP ke port berdasarkan parameter <code>agent-port</code> ditentukan dan membaca string ASCII.  Baris terdiri dari serangkaian kata yang dipisahkan oleh spasi, tab atau koma dalam urutan apa pun, secara opsional berakhiran <code>/r</code> dan / atau <code>/n</code> dan termasuk elemen-elemen berikut: <br><br>  - Representasi nilai persentase integer positif ASCII, misalnya, <code>75%</code> .  Nilai-nilai dalam format ini menentukan bobot sebanding dengan yang awal <br>  Nilai server tertimbang yang dikonfigurasi saat memulai HAProxy.  Harap dicatat bahwa nilai nol bobot ditunjukkan pada halaman statistik sebagai <code>DRAIN</code> dari saat dampak yang serupa pada server (dihapus dari tambak LB). <br><br>  - <code>maxconn</code> parameter string: diikuti oleh integer (tanpa spasi).  Nilai dalam <br>  Format ini menentukan <code>maxconn</code> server <code>maxconn</code> .  Jumlah maksimum <br>  koneksi yang dideklarasikan harus dikalikan dengan jumlah penyeimbang beban dan berbagai bagian server menggunakan pemeriksaan kesehatan ini untuk mendapatkan jumlah total koneksi yang dapat dibuat server.  Sebagai contoh: <code>maxconn:30</code> <br><br>  - Kata <code>ready</code> .  Ini menerjemahkan keadaan administrasi server ke <br>  Mode <code>READY</code> , membatalkan status <code>DRAIN</code> atau <code>MAINT</code> . <br><br>  - Kata <code>drain</code> .  Ini menerjemahkan keadaan administrasi server ke <br>  Mode <code>DRAIN</code> ("tiriskan"), setelah itu server tidak akan menerima koneksi baru, dengan pengecualian koneksi yang diterima melalui database. <br><br>  - Kata <code>maint</code> .  Ini menerjemahkan keadaan administrasi server ke <br>  Mode <code>MAINT</code> ("maintenance"), setelah itu server tidak akan menerima koneksi baru, dan pemeriksaan kesehatan berhenti. <br><br>  - Kata-kata <code>down</code> , <code>failed</code> atau <code>stopped</code> , yang dapat diikuti oleh baris deskripsi setelah simbol tajam (#).  Semuanya menunjukkan status operasional server <code>DOWN</code> ("mati"), tetapi karena kata itu sendiri ditampilkan di halaman statistik, perbedaannya memungkinkan administrator untuk menentukan apakah situasinya diharapkan: layanan mungkin sengaja dihentikan, beberapa tes konfirmasi mungkin muncul, tetapi gagal lulus, atau dianggap dinonaktifkan (tidak ada proses, tidak ada respons dari port). <br><br>  - Kata di atas menunjukkan status operasional server <code>UP</code> ("on") jika pemeriksaan kesehatan juga mengkonfirmasi ketersediaan layanan. <br><br>  Parameter yang tidak diklaim oleh agen tidak diubah.  Misalnya, agen hanya dapat dirancang untuk memantau penggunaan prosesor dan hanya melaporkan nilai bobot relatif tanpa berinteraksi dengan kondisi pengoperasian.  Demikian pula, program agen dapat dirancang sebagai antarmuka pengguna akhir dengan 3 sakelar yang memungkinkan administrator untuk hanya mengubah status administratif. <br><br>  <strong>Namun, harus diingat bahwa hanya agen yang dapat membatalkan tindakannya sendiri, oleh karena itu, jika server diatur ke DRAIN atau DOWN menggunakan agen, agen harus melakukan tindakan lain yang setara untuk memulai kembali layanan.</strong> <br><br>  Kegagalan untuk terhubung ke agen tidak dianggap sebagai kesalahan, karena kemampuan untuk terhubung diuji dengan secara teratur melakukan pemeriksaan kesehatan, yang mulai menggunakan parameter cek.  Namun, jika pesan shutdown tiba, maka peringatan bukanlah ide yang baik untuk menghentikan agen, karena hanya agen yang melaporkan shutdown yang dapat mengaktifkan kembali server. </blockquote><p>  Skema komunikasi dinamis layanan ini dengan unit output sangat penting untuk menciptakan infrastruktur yang dapat beradaptasi sendiri.  Contohnya adalah arsitektur tempat saya bekerja di pekerjaan sebelumnya. </p><br><p>  Saya dulu bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">imgix</a> , perusahaan startup pemrosesan gambar real-time.  Menggunakan URL API sederhana, gambar diambil dan dikonversi secara waktu nyata dan kemudian digunakan di mana saja di dunia melalui CDN.  Tumpukan kami cukup rumit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti dijelaskan di atas</a> ), tetapi singkatnya, infrastruktur kami mencakup tingkat penyeimbangan dan penyeimbangan muatan (bersama-sama dengan tingkat penerimaan data dari sumber), tingkat penyimpanan sumber, tingkat pemrosesan gambar dan tingkat pengiriman konten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f58/98a/d1e/f5898ad1e33db764d7551e29d0a7e5dc.png" alt="gambar"></p><br><p>  Level load balancing didasarkan pada layanan Spillway, yang bertindak sebagai proxy terbalik dan broker permintaan.  Itu adalah layanan murni internal;  di ambang, kami mulai nginx dan HAProxy dan Spillway, jadi itu tidak dirancang untuk menyelesaikan TLS atau melakukan fungsi lain dari set yang tak terhitung jumlahnya yang biasanya dalam kompetensi proxy perbatasan. </p><br><p>  Spillway terdiri dari dua komponen: bagian klien (Spillway FE) dan broker.  Meskipun pada awalnya kedua komponen berada dalam file biner yang sama, pada beberapa titik kami memutuskan untuk memisahkannya menjadi file biner terpisah yang digunakan secara bersamaan pada host yang sama.  Terutama karena kedua komponen ini memiliki profil kinerja yang berbeda, dan bagian klien hampir sepenuhnya terhubung dengan prosesor.  Tugas dari bagian klien adalah untuk melakukan pemrosesan awal dari setiap permintaan, termasuk verifikasi awal di tingkat caching sumber, untuk memastikan bahwa gambar di-cache di pusat data kami sebelum mengirim permintaan untuk konversi gambar ke pelaksana. </p><br><p>  Pada waktu tertentu, kami memiliki kumpulan tetap (selusin atau lebih, jika ingatanku) dari seniman yang dapat dihubungkan ke broker Spillway yang sama.  Artis bertanggung jawab atas konversi gambar yang sebenarnya (memotong, mengubah ukuran, pemrosesan PDF, rendering GIF, dll.).  Mereka memproses semuanya mulai dari PDF ratusan halaman dan GIF dengan ratusan frame hingga file gambar sederhana.  Fitur lain dari kontraktor adalah bahwa, meskipun semua jaringan sama sekali tidak sinkron, tidak ada konversi sebenarnya pada GPU itu sendiri.  Karena kami bekerja secara real time, tidak mungkin untuk memprediksi seperti apa traffic kami pada titik waktu tertentu.  Infrastruktur kami harus menyesuaikan diri dengan berbagai bentuk lalu lintas masuk - tanpa intervensi operator manual. </p><br><p>  Mengingat pola lalu lintas yang berbeda dan heterogen yang sering kita temui, menjadi penting bagi para pelaku untuk menolak menerima permintaan yang masuk (bahkan ketika beroperasi penuh) jika menerima koneksi yang mengancam akan membebani pemain yang berlebih.  Setiap permintaan untuk pemain berisi set metadata tertentu tentang sifat permintaan, yang memungkinkan pemain untuk menentukan apakah dia dapat melayani permintaan ini.  Setiap pelaksana memiliki set data statistik sendiri tentang permintaan yang saat ini ia kerjakan.  Karyawan menggunakan statistik ini bersama dengan metadata permintaan dan data heuristik lainnya, seperti data ukuran buffer socket, untuk menentukan apakah ia menerima permintaan yang masuk dengan benar.  Jika karyawan tersebut memutuskan bahwa ia tidak dapat menerima permintaan tersebut, maka ia membuat respons yang tidak berbeda dari cek agen HAProxy yang memberitahukan Spillway tentang operabilitasnya. </p><br><p>  Spillway memantau kinerja semua artis kolam renang.  Pada awalnya saya mencoba mengirim permintaan tiga kali berturut-turut ke pelaksana yang berbeda (preferensi diberikan kepada mereka yang memiliki gambar asli di database lokal dan yang tidak kelebihan beban), dan jika ketiga pelaksana menolak untuk menerima permintaan, permintaan itu antri di broker di dalam memori.  Pialang mendukung tiga bentuk antrian: antrian LIFO, antrian FIFO, dan antrian prioritas.  Jika ketiga antrian dipenuhi, broker hanya menolak permintaan, memungkinkan klien (HAProxy) untuk mencoba lagi setelah periode penundaan.  Ketika permintaan ditempatkan di salah satu dari tiga antrian, setiap pelaksana gratis dapat menghapusnya dari sana dan memprosesnya.  Ada kesulitan tertentu yang terkait dengan menetapkan prioritas untuk permintaan dan memutuskan mana dari tiga antrian (LIFO, FIFO, antrian berdasarkan prioritas) yang harus ditempatkan, tetapi ini adalah topik untuk artikel terpisah. </p><br><p>  Untuk pengoperasian layanan yang efektif, kami tidak perlu membahas bentuk umpan balik dinamis ini.  Kami dengan hati-hati memantau ukuran antrian broker (ketiga antrian), dan Prometheus mengeluarkan salah satu peringatan utama ketika ukuran antrian melebihi batas tertentu (yang sangat jarang). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f83/768/88c/f8376888c479f9dbcbadbee1c3e9539e.png" alt="gambar"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar dari presentasi saya tentang sistem pemantauan Prometheus di Google NYC pada November 2016</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a19/7b7/57c/a197b757cbe5660023612137e3c780d4.png" alt="gambar"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringatan itu diambil dari presentasi saya tentang sistem pemantauan Prometheus di konferensi OSCON pada Mei 2017.</a> </p><br><p>  Pada awal tahun ini, Uber menerbitkan sebuah artikel yang menarik di mana ia menjelaskan pendekatannya dalam mengimplementasikan level pelepasan beban berdasarkan kualitas layanan. </p><br><blockquote>  Menganalisis kegagalan selama enam bulan terakhir, kami menemukan bahwa 28% dari mereka dapat dikurangi atau dicegah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">degradasi yang lancar</a> . <br><br>  Tiga jenis kegagalan yang paling umum dikaitkan dengan faktor-faktor berikut: <br><br>  - Perubahan skema permintaan masuk, termasuk kemacetan dan simpul operator yang buruk. <br>  - Menipisnya sumber daya seperti prosesor, memori, sirkuit input / output atau sumber daya jaringan. <br>  - Kegagalan ketergantungan, termasuk infrastruktur, gudang data, dan layanan hilir. <br><br>  Kami menerapkan detektor kelebihan berdasarkan pada algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoDel</a> .  Untuk setiap titik akhir yang diaktifkan, buffer permintaan yang ringan (diimplementasikan berdasarkan gourutin dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran</a> ) ditambahkan untuk melacak penundaan antara saat menerima permintaan dari sumber panggilan dan dimulainya pemrosesan permintaan dalam handler.         ,   ,      . </blockquote><p>   ,  ,         ,  -      .   2013  Google     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«The Tail at Scale»</a> ,               (   ),        (   )    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8ff/2b5/379/8ff2b5379239a40c0b193f483a85fa86.jpg" alt="gambar"></p><br><p>             ,           .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">      </a> ,         . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fd/068/1fb/6fd0681fb86c70cff833ae170f53ce5c.png" alt="gambar"></p><br><p> (       ) </p><br><p> ,              ,       : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> , QCon London 2018. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   :    -</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,  LISA 2017. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   –   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> , Strangeloop 2017. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  : ,    </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> , Strangeloop 2017. </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«   »</a> . </li></ol><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>           ,  TCP/IP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>    ), IP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ECN</a> ( IP     )  Ethernet,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p>        ,             .               .    ,           .             . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433462/">https://habr.com/ru/post/id433462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433442/index.html">Entity Framework Core 2.2 dirilis. Apa yang baru? (3 dari 3)</a></li>
<li><a href="../id433446/index.html">Security Week 51: bug di WordPress 5.0 dan perangkat lunak Logitech, kerentanan foto Facebook</a></li>
<li><a href="../id433448/index.html">Analisis komparatif dari pasar bekas Mobil Jerman dan Prancis di segmen B dan C</a></li>
<li><a href="../id433450/index.html">Tumbuhkan dan ajarkan. Bagaimana kami berteman dengan PEGA</a></li>
<li><a href="../id433456/index.html">Bagaimana meyakinkan pelanggan atau perusahaan untuk menggunakan Flutter</a></li>
<li><a href="../id433468/index.html">Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya</a></li>
<li><a href="../id433472/index.html">Unity 2018.3 dirilis</a></li>
<li><a href="../id433474/index.html">Pylint dari dalam ke luar. Bagaimana dia melakukannya?</a></li>
<li><a href="../id433478/index.html">Mengapa Django dipilih di Tinkoff Magazine</a></li>
<li><a href="../id433480/index.html">Kisah Holivarny tentang linter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>