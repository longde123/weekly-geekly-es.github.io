<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèº üíë üñêüèº Comment fonctionne zig? üèïÔ∏è üë©üèª‚Äçüîß üñïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De la part d'un traducteur: cet article a √©t√© publi√© sur le blog de l'auteur le 15 mars 2018. √Ä mesure qu'un langage √©volue, sa syntaxe peut √™tre diff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne zig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>De la part d'un traducteur: cet article a √©t√© publi√© sur le blog de l'auteur le 15 mars 2018.</i>  <i>√Ä mesure qu'un langage √©volue, sa syntaxe peut √™tre diff√©rente √† l'heure actuelle.</i>  <i>Tout ce qui est d√©crit concerne Zig 0.2.0, la version actuelle du langage est Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'ai contact√© l'auteur de l'article, et il a aimablement fourni un lien vers le r√©f√©rentiel avec la version actuelle des sources du projet sur Zig 0.3.0</a></i> <i><br></i> <br>  Bonjour  √âcrivons un interpr√®te Brainfuck!  "Pourquoi?"  "Vous pouvez demander, mais vous ne trouverez pas la r√©ponse ici." <br><br>  Je vais le faire sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig c'est ... </h3><br>  ... un nouveau langage de programmation.  Il est toujours en version b√™ta et se d√©veloppe rapidement.  Si vous avez d√©j√† vu le code Zig, le code dans ce post peut vous sembler un peu diff√©rent.  Il est vraiment diff√©rent!  Zig 0.2.0 vient de sortir, co√Øncidant avec la sortie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM 6 il y a</a> quelques semaines, et comprend de nombreux changements de syntaxe et am√©liorations g√©n√©rales du langage.  G√©n√©ralement, de nombreux ¬´sorts¬ª ont √©t√© remplac√©s par des mots cl√©s.  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> pour une explication plus approfondie de tous les changements! <br><br>  Zig est con√ßu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour √™tre lisible</a> et relativement intuitif pour ceux qui sont familiers avec les langages compil√©s et typ√©s tels que C, C ++ et, √† certains moments, Rust. <br><br>  Le code a √©t√© compil√© et test√© avec Zig 0.2.0, qui est disponible d√®s maintenant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">via diff√©rents canaux</a> , y compris homebrew, si vous √™tes sur OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Commen√ßons </h3><br>  Pour savoir comment fonctionne Brainfuck, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il n'y a presque rien √† y apprendre, mais c'est un langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complet de Turing</a> , ce qui signifie que vous pouvez √©crire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'importe quoi</a> dessus. <br><br>  J'ai post√© le code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , au cas o√π vous voudriez voir le produit final ou des validations anticip√©es. <br><br>  Zig est un langage compil√©.  Lorsque vous compilez un programme, le binaire r√©sultant (si vous compilez un binaire ex√©cutable, pas une biblioth√®que) doit avoir une fonction principale qui marque le point d'entr√©e. <br><br>  Alors ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... et commencez ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... donne ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main doit √™tre d√©clar√©e publique pour √™tre visible √† l'ext√©rieur du module ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Laissez le programme brainfuck utiliser un tableau de 30 000 octets comme m√©moire, je vais faire un tel tableau. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Je peux d√©clarer une constante (const) ou une variable (var).  Ici, j'ai d√©clar√© mem comme un tableau de 30 000 octets (u) non sign√©s (8 bits). <br><br>  Cela ne compile pas. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Un programme C √©quivalent compilerait normalement: je peux d√©clarer une variable sans initialisation, mais Zig m'oblige √† prendre une d√©cision maintenant, au moment o√π la variable est d√©clar√©e.  Peu m'importe ce qui y sera √©crit, mais je dois l'indiquer explicitement.  Je vais le faire en initialisant la variable avec une valeur non d√©finie (non d√©finie). <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  L'initialisation d'une variable avec une valeur non d√©finie ne donne aucune garantie sur la valeur de la variable en m√©moire.  C'est la m√™me chose qu'une d√©claration de variable non initialis√©e en C, sauf que vous devez l'indiquer explicitement. <br><br>  Mais peut-√™tre que je me fiche de comment initialiser cette m√©moire.  Peut-√™tre que je veux avoir la garantie que les z√©ros ou une valeur arbitraire y sont √©crits.  Dans ce cas, je devrais √©galement d√©clarer explicitement ceci: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Cela peut sembler √©trange, mais ** est l'op√©rateur utilis√© pour d√©velopper les tableaux.  Je d√©clare un tableau de 0 octet, puis je le d√©veloppe √† 30 000 et j'obtiens la valeur d'initialisation finale de 30 000 z√©ro octet.  Cette op√©ration se produit une fois, <i>au moment de la compilation</i> .  comptime est l'une des grandes id√©es de Zig, et j'y reviendrai dans l'un des articles suivants. <br><br>  √âcrivons maintenant un programme sur brainfuck qui ne fait qu'incr√©menter le premier slot m√©moire cinq fois! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  Dans Zig, les cha√Ænes sont des tableaux d'octets.  Je ne devrais pas d√©clarer src comme un tableau d'octets, car le compilateur l'implique.  C'est facultatif, mais si vous le souhaitez, c'est possible: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Cela compilera tr√®s bien.  Cependant, ceci: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  ne le sera pas. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Une derni√®re remarque: puisque les cha√Ænes ne sont que des tableaux, elles ne se terminent pas par z√©ro.  Cependant, vous pouvez d√©clarer une cha√Æne termin√©e par un caract√®re nul C. En tant que litt√©ral, il ressemblera √† ceci: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Pour le bien commun ... </h3><br>  Je veux faire <i>quelque chose</i> avec chaque caract√®re d'une cha√Æne.  Je peux le faire!  Au d√©but de main.zig, j'importe quelques fonctions de la biblioth√®que standard: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">import</a> , comme pratiquement tout ce qui commence par le signe @, est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction de compilation int√©gr√©e</a> .  Ces fonctionnalit√©s sont toujours disponibles dans le monde entier.  L'importation ici fonctionne de mani√®re similaire √† javascript - vous pouvez importer n'importe quoi en creusant dans l'espace de noms et en extraire toutes les fonctions ou variables accessibles au public.  Dans l'exemple ci-dessus, j'importe directement la fonction warn et l'affecte, tout d'un coup, √† la constante warn.  Maintenant, elle peut √™tre appel√©e.  Il s'agit d'un mod√®le courant: nous importons directement √† partir de l'espace de noms std, puis appelons std.debug.warn () ou l'affectons √† la variable warn.  Cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Pendant le d√©bogage, le d√©veloppement initial et les tests, je veux juste imprimer quelque chose √† l'√©cran.  Zig est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sujet aux erreurs</a> et stdout est √©galement sujet aux erreurs.  Je ne veux pas le faire pour le moment, et je peux imprimer directement sur stderr en utilisant warn, que nous avons import√© de la biblioth√®que standard. <br><br>  warn prend une cha√Æne format√©e, comme printf en C!  Le code ci-dessus imprimera: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 est le code de caract√®re ascii +.  Je peux aussi √©crire: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  et obtenez: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Nous avons donc initialis√© l'espace m√©moire et √©crit le programme.  Nous r√©alisons maintenant la langue elle-m√™me.  Je vais commencer par +, et remplacer le corps de la boucle for par switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Je re√ßois deux erreurs: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Bien s√ªr, je ne peux pas affecter une nouvelle valeur √† une variable, qui est une constante!  mem doit √™tre fait une variable ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  comme pour les autres erreurs, ma construction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commutateur</a> devrait savoir quoi faire si le caract√®re n'est pas +, m√™me si rien n'est √† faire.  Dans mon cas, c'est exactement ce que je veux.  Je remplis ce cas avec un bloc vide: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Maintenant, je peux compiler le programme.  Appelez avertir √† la fin et ex√©cutez: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Je re√ßois le num√©ro 5 imprim√© en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stderr</a> , comme je m'y attendais. <br><br><h3>  Continuons ... </h3><br>  De m√™me, nous soutenons. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Pour utiliser&gt; et &lt;, vous devez utiliser une variable suppl√©mentaire, qui sert de "pointeur" dans la m√©moire que j'ai allou√©e au programme brainfuck de l'utilisateur. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Puisqu'un 16 bits non sign√© peut √™tre au maximum de 65 535, il suffit amplement d'indexer 30 000 octets d'espace d'adressage. <br><br><blockquote>  <i>en fait, 15 bits nous suffiraient, ce qui nous permet d'adresser 32767 octets.</i>  <i>Zig autorise les types avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des largeurs diff√©rentes</a> , mais pas encore u15.</i> <i><br><br></i>  <i>vous pouvez r√©ellement faire u15 de cette fa√ßon:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il est propos√©</a> que tout type [iu] \ d + soit valide comme type entier. </blockquote><br>  Maintenant, au lieu d'utiliser mem [0], je peux utiliser cette variable. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;et&gt; simplement incr√©menter et d√©cr√©menter ce pointeur. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Super  Nous pouvons √©crire un vrai programme maintenant! <br><br><h3>  Ch√®que 1,2,3 </h3><br>  Zig a un moteur de test int√©gr√©.  N'importe o√π dans n'importe quel fichier, je peux √©crire un bloc de test: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  et ex√©cutez le test √† partir de la ligne de commande: zig test $ FILENAME.  Les autres blocs de test sont identiques au code normal. <br><br>  Regardons ceci: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Bien s√ªr, un test vide est inutile.  Je peux utiliser assert pour confirmer l'ex√©cution des tests. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  Le test est tomb√©.  Utilisez la commande suivante pour reproduire l'erreur: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La trace de pile sur le coquelicot est toujours en cours de d√©veloppement.</a> <br><br>  Pour tester cela efficacement, je dois le diviser en morceaux.  Commen√ßons par ceci: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Cela devrait sembler fonctionner, non? <br><br>  Mais ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  cela est d√©crit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig est strict √† ce sujet.  Les types complexes et tous les objets pouvant √™tre redimensionn√©s ne peuvent pas √™tre transmis par valeur.  Cela rend l'allocation de pile pr√©visible et logique et √©vite les copies inutiles.  Si vous souhaitez utiliser la s√©mantique du transfert par valeur dans votre programme, vous pouvez l'impl√©menter vous-m√™me en utilisant votre strat√©gie d'allocation, mais le langage lui-m√™me ne le prend pas en charge dans des circonstances ordinaires. <br><br>  Le moyen naturel de contourner cette limitation est de passer un pointeur au lieu d'une valeur (passer par r√©f√©rence).  Zig utilise une strat√©gie diff√©rente, les tranches.  Une tranche est un pointeur avec une longueur attach√©e et avec un contr√¥le pour tomber dans les bordures.  La syntaxe de la signature de fonction ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  et lors de l'appel de la fonction, cela ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Notez que j'ai d√©fini la limite sup√©rieure simplement en faisant r√©f√©rence √† la longueur du tableau.  Il existe une notation abr√©g√©e pour de tels cas: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Maintenant, je peux commencer √† √©crire des tests qui testent directement la fonction bf ().  Je vais ajouter des fonctions de test √† la fin du fichier pour l'instant ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Je prends le tableau mem d'un octet et v√©rifie ensuite ce qui doit arriver (l'octet est incr√©ment√© trois fois).  √áa marche! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" est coch√© de la m√™me mani√®re: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  √áa ne marche pas!  Lorsque j'essaie de soustraire 1 de 0, j'obtiens ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem est un tableau d'octets non sign√©s et la soustraction de 1 √† 0 provoque un d√©bordement.  Encore une fois, Zig me fait d√©clarer explicitement ce que je veux.  Dans ce cas, je n'ai pas √† me soucier du d√©bordement, en fait, je veux que cela se produise, car nous avons affaire √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'arithm√©tique modulaire</a> , conform√©ment √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification de brainfuck</a> .  Cela signifie que d√©cr√©menter une cellule avec le nombre 0 me donnera 255, et un incr√©ment de 255 me donnera 0. <br><br>  Zig poss√®de plusieurs op√©rations arithm√©tiques auxiliaires qui offrent la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©mantique du ¬´wrapping¬ª garanti</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Cela r√©sout tout le probl√®me de d√©bordement et fait ce que j'attendais. <br><br>  Pour tester &lt;et&gt;, je navigue dans un petit tableau et v√©rifie la valeur de la cellule incr√©ment√©e: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  et ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Dans ce dernier cas, je peux directement comparer le r√©sultat avec un tableau statique en utilisant ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Rappelons que j'ai d√©j√† import√© std.  Dans l'exemple ci-dessous, j'utilise mem.eql dans cet espace de noms: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... et rappelez-vous, les litt√©raux de cha√Æne, ce ne sont que des tableaux u8 en zig, et je peux y mettre des litt√©raux hexad√©cimaux, c'est-√†-dire  Le code suivant fonctionnera de la m√™me mani√®re! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Ajoutez le "."!  Il imprime simplement en tant que caract√®re la valeur d'octet dans la cellule vers laquelle pointe le pointeur.  J'utilise warn maintenant, mais plus tard je le remplacerai par stdout.  C'est facile √† faire conceptuellement, mais quelque peu confus dans la mise en ≈ìuvre.  Je le ferai plus tard! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Cycles <br>  [et] - la magie commence ici .... <br><br>  [- si la valeur de la cellule actuelle est z√©ro, ignorez les √©tapes jusqu'au crochet fermant sans ex√©cuter le code. <br>  ] - si la valeur de la cellule actuelle n'est pas nulle, revenez √† la parenth√®se ouvrante et ex√©cutez √† nouveau le code. <br><br>  Cette fois, je vais commencer par un test, je vais les tester ensemble (√©videmment, cela n'a aucun sens de les tester s√©par√©ment).  Le premier cas de test - la cellule de stockage [2] doit √™tre vide, bien que la boucle doit l'incr√©menter si elle d√©marre: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  et je vais cr√©er des blancs pour l'instruction switch: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Que faire maintenant?  Vous pouvez utiliser une approche na√Øve.  J'incr√©mente simplement le pointeur src jusqu'√† ce que je le trouve].  Mais je ne peux pas utiliser la boucle for en zig pour cela, elle a √©t√© cr√©√©e uniquement pour it√©rer dans les collections, sans manquer leurs √©l√©ments.  Une construction appropri√©e ici est tout: <br><br>  √©tait: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  est devenu ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Maintenant, je peux r√©affecter le pointeur srcptr au milieu du bloc, je vais le faire: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Cela satisfait le test "[] ignore l'ex√©cution du code et quitte" <br>  Cela satisfait le test ¬´[] ignore l'ex√©cution et quitte¬ª, bien qu'il ne soit pas enti√®rement fiable, comme nous le verrons. <br><br>  Qu'en est-il des crochets de fermeture?  Je pense que cela peut √™tre √©crit simplement par analogie: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Vous pouvez voir ce qui se passe ... Une solution na√Øve avec deux crochets a un d√©faut fatal et se casse compl√®tement sur les boucles imbriqu√©es.  Tenez compte des √©l√©ments suivants: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  Le r√©sultat devrait √™tre {2, 0}, mais le premier crochet ouvert se d√©place simplement b√™tement vers le premier crochet de fermeture, et tout devient compliqu√©.  Vous devez passer au support de fermeture suivant au m√™me niveau d'imbrication.  Il est facile d'ajouter un compteur de profondeur et de le suivre lorsque vous avancez le long de la ligne.  Nous le faisons dans les deux sens: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  et tests associ√©s: notez que src dans les deux tests inclut une boucle interne. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  S√©par√©ment, notez [-] - l'idiome de brainfuck, signifiant ¬´z√©ro cette cellule¬ª.  Vous pouvez voir que la valeur de la cellule au d√©but n'a pas d'importance, elle sera d√©cr√©ment√©e jusqu'√† ce qu'elle atteigne 0, puis l'ex√©cution se poursuivra. </blockquote><br><h3>  Chemin malchanceux </h3><br>  Je ne comptais pas sur la possibilit√© que le programme sur bf soit cass√©.  Que se passe-t-il si je soumets un programme de saisie incorrect √† mon interpr√®te?  Par exemple, simplement [sans parenth√®se fermante, ou &lt;, qui va imm√©diatement au-del√† du tableau de m√©moire?  (Je peux envelopper le pointeur de m√©moire, mais il vaut mieux consid√©rer cela comme une erreur). <br><br>  Je vais regarder un peu en avant et expliquer toutes les diff√©rences dans le code.  Je mettrai la fonction d'interpr√©teur bf dans un fichier s√©par√© et mettrai √©galement la fonctionnalit√© de recherche et de recherche dans mes propres petites fonctions. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Cela rend le commutateur beaucoup plus facile √† lire, √† mon avis, SeeForward et SeeBack fonctionnent et semblent tr√®s similaires, et j'ai √©t√© tent√© de les transformer en quelque chose de plus intelligent et plus compact, mais √† la fin ils font des choses diff√©rentes et g√®rent les erreurs √©galement de diff√©rentes mani√®res.  Plus facile √† copier et √† ajuster, ce sera donc plus clair.  J'ajusterai √©galement la fonction de recherche plus tard, √† un moment donn√©, peut-√™tre dans un article ult√©rieur. <br><br>  J'ai ajout√© des choses importantes!  Notez que les trois fonctions renvoient d√©sormais un type! .. Il s'agit de la nouvelle syntaxe pour ce qui √©tait auparavant le type% T (union d'erreur).  Cela signifie que la fonction peut renvoyer un certain type ou une erreur.  Lorsque j'essaie d'appeler une telle fonction, je dois utiliser try avant d'appeler la fonction, ce qui l√®ve l'erreur dans la pile des appels si l'erreur se produit, ou utiliser catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  O√π je g√®re les erreurs dans un bloc catch.  Comme √©crit, catch peut avaler toutes les erreurs.  C'est une mauvaise pratique, mais ici Zig nous oblige √† le faire explicitement.  Si j'attrape une erreur dans un bloc vide, je d√©clare soit que je ne pense pas qu'une erreur peut se produire, soit que je n'ai pas besoin de la g√©rer.  En pratique, cela peut √™tre quelque chose comme TODO, et en fait il est tr√®s facile de le rendre aussi explicite! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Rappelons qu'un tel cas ne se produira jamais dans le code de production.  J'informe le compilateur que je sais ce que je fais.  Si une erreur pouvait se produire, je devrais ajouter la gestion des erreurs. <br><br>  Alors, quelles erreurs dois-je renvoyer √† partir de SeeBack ou SeeForward? <br><br>  Dans SeeBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  J'ai remplac√© le pointeur de d√©cr√©mentation pour utiliser la sous-fonction de std lib, qui g√©n√®re une erreur de d√©bordement en cas de d√©bordement.  Je veux attraper cette erreur et retourner √† la place l'erreur OutOfBounds, que je cr√©e ici juste en l'utilisant. <br><br><blockquote>  <i>Erreurs Zig est essentiellement un tableau de codes d'erreur qui est g√©n√©r√© par le compilateur lorsque vous utilisez une erreur. Une sorte d'erreur.</i>  <i>Ils sont garantis uniques et peuvent √™tre utilis√©s comme valeurs dans un bloc de commutation.</i> </blockquote><br>  Je veux utiliser OutOfBounds ici parce que, s√©mantiquement, si le pointeur de m√©moire devient inf√©rieur √† z√©ro, je demande au runtime d'aller au-del√† de l'espace m√©moire que j'ai allou√©. <br><br>  de m√™me dans la fonction seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  Dans ce cas, si le pointeur est plus grand que src.len, j'attrape l'erreur ici et renvoie la m√™me erreur. <br><br>  lors de l'appel: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  J'essaie d'appeler ces fonctions.  S'ils sont appel√©s avec succ√®s, ils sont ex√©cut√©s correctement et essayez de renvoyer srcptr.  S'ils √©chouent, essayez de terminer la fonction et renvoie une erreur √† l'endroit de l'appel √† la fonction enti√®re bf. <br><br>  L'appel peut provenir du principal! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  J'avale cette erreur ici, et cela ne devrait pas √™tre fait, mais nous noterons un point important sur la facilit√© avec laquelle zig peut transmettre des erreurs dans la pile d'appels.  Il n'est pas de la responsabilit√© de la fonction appelante de v√©rifier chaque cas d'erreur, mais le compilateur force l'appel de chaque fonction qui peut √©chouer avec un essai.  Cela doit toujours √™tre fait, m√™me si les erreurs sont ignor√©es! <br><br><blockquote>  <i>La nouvelle syntaxe try / catch √©limine les nombreux sorts comme %% et% que les gens n'aiment pas tellement.</i> </blockquote><br>  Maintenant, j'ai impl√©ment√© 7 des 8 personnages de brainfuck, et cela suffit pour ex√©cuter un programme ¬´significatif¬ª. <br><br><h3>  Un programme significatif </h3><br>  Voici le programme: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Courons ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  le tour est jou√©! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Un souvenir me revient chaque fois que je pense √† une s√©rie de Fibonacci ... Je l'ai d√©couvert gr√¢ce au programme PBS (Public Broadcasting Service, un service am√©ricain de t√©l√©diffusion non commerciale) dans les ann√©es 80, et je m'en souviens toujours.</i>  <i>Je pensais que ce serait oubli√©, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Youtube est une bonne chose</a> .</i> </blockquote><br><h3>  Comment puis-je am√©liorer cela? </h3><br>  J'ai d√©j√† fait allusion √† quelques TODO.  Je n'aurais pas d√ª utiliser stderr pour la sortie.  Je veux utiliser stdout. <br><br>  Chaque fois que j'ouvre l'interpr√©teur, j'ouvre le flux dans stdout et j'imprime dedans: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  Que se passe-t-il ici?   io.getStdOut(),     (          catch unreachable ‚Äî     ,  !).   ,    ,      ,       print. print   ,   warn,     . print    ,      . <br><br>    ,         stdout,        stdout. Zig         ,   ,    . <br><br>  ,   ,        ?              ,      ,            ?  ,        ?  , Zig  ! <br><br>     ,  ! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br>  ,  bf   ,     !void.       ,   main.          ,      : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>    ! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br>      ,      bf   !   ,     ,  stdout,     bf.  ,   ,       ,  try. ,   ,  ,  catch,   try,      ,       . <br><br> , : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>      ,    ,  ! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig       ,       !   switch   ,  ,   ,  ,     . <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br>  -     ,  ,     ,   Zig,        !    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   !  ! <br><br><h3> Todo </h3><br>    ,     !         , ,     ",",   brainfuck-    getc,        .            ,      bf.    ,     ,      Zig.  ,       ,           ,       . <br><br><h3>  Conclusion </h3><br>  ,           ,     Zig       . Zig    ,       ,     ,  ,     ,          ++.        ,  ,   .     ,   ,   . Zig ,   ,       ,      . <br><br>         Zig,    ,      0.2.0  !  ,   ,   debug-,          ,    !   --release-fast  --release-safe,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>        Zig.     ,       1.0.0,      Zig,    ,    ,       ! <br><br> ,    #zig  freenode   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435574/">https://habr.com/ru/post/fr435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435560/index.html">Premier ordinateur quantique commercial - IBM</a></li>
<li><a href="../fr435562/index.html">Le chemin d'un fumeur: comment entrer dans le m√©tier de programmeur, si vous √™tes humaniste</a></li>
<li><a href="../fr435564/index.html">Utilisation de GtkApplication. Fonctions de rendu Librsvg</a></li>
<li><a href="../fr435568/index.html">Routeur VyOS OpenSource</a></li>
<li><a href="../fr435572/index.html">Anycubic i3 Mega: remake de qualit√© de Prusa i3</a></li>
<li><a href="../fr435576/index.html">1C, pas de douleur</a></li>
<li><a href="../fr435578/index.html">Sortie dans l'espace pour No√´l</a></li>
<li><a href="../fr435580/index.html">Java, Spring, Kurento et Media Services</a></li>
<li><a href="../fr435582/index.html">Comment ajouter un index sur un syst√®me charg√© 24/7 sans interruption?</a></li>
<li><a href="../fr435584/index.html">Slush 2018. Premier jour, deuxi√®me jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>