<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 💑 🖐🏼 Comment fonctionne zig? 🏕️ 👩🏻‍🔧 🖕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De la part d'un traducteur: cet article a été publié sur le blog de l'auteur le 15 mars 2018. À mesure qu'un langage évolue, sa syntaxe peut être diff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne zig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>De la part d'un traducteur: cet article a été publié sur le blog de l'auteur le 15 mars 2018.</i>  <i>À mesure qu'un langage évolue, sa syntaxe peut être différente à l'heure actuelle.</i>  <i>Tout ce qui est décrit concerne Zig 0.2.0, la version actuelle du langage est Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'ai contacté l'auteur de l'article, et il a aimablement fourni un lien vers le référentiel avec la version actuelle des sources du projet sur Zig 0.3.0</a></i> <i><br></i> <br>  Bonjour  Écrivons un interprète Brainfuck!  "Pourquoi?"  "Vous pouvez demander, mais vous ne trouverez pas la réponse ici." <br><br>  Je vais le faire sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig c'est ... </h3><br>  ... un nouveau langage de programmation.  Il est toujours en version bêta et se développe rapidement.  Si vous avez déjà vu le code Zig, le code dans ce post peut vous sembler un peu différent.  Il est vraiment différent!  Zig 0.2.0 vient de sortir, coïncidant avec la sortie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM 6 il y a</a> quelques semaines, et comprend de nombreux changements de syntaxe et améliorations générales du langage.  Généralement, de nombreux «sorts» ont été remplacés par des mots clés.  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> pour une explication plus approfondie de tous les changements! <br><br>  Zig est conçu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour être lisible</a> et relativement intuitif pour ceux qui sont familiers avec les langages compilés et typés tels que C, C ++ et, à certains moments, Rust. <br><br>  Le code a été compilé et testé avec Zig 0.2.0, qui est disponible dès maintenant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">via différents canaux</a> , y compris homebrew, si vous êtes sur OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Commençons </h3><br>  Pour savoir comment fonctionne Brainfuck, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il n'y a presque rien à y apprendre, mais c'est un langage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complet de Turing</a> , ce qui signifie que vous pouvez écrire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'importe quoi</a> dessus. <br><br>  J'ai posté le code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , au cas où vous voudriez voir le produit final ou des validations anticipées. <br><br>  Zig est un langage compilé.  Lorsque vous compilez un programme, le binaire résultant (si vous compilez un binaire exécutable, pas une bibliothèque) doit avoir une fonction principale qui marque le point d'entrée. <br><br>  Alors ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... et commencez ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... donne ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main doit être déclarée publique pour être visible à l'extérieur du module ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Laissez le programme brainfuck utiliser un tableau de 30 000 octets comme mémoire, je vais faire un tel tableau. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Je peux déclarer une constante (const) ou une variable (var).  Ici, j'ai déclaré mem comme un tableau de 30 000 octets (u) non signés (8 bits). <br><br>  Cela ne compile pas. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Un programme C équivalent compilerait normalement: je peux déclarer une variable sans initialisation, mais Zig m'oblige à prendre une décision maintenant, au moment où la variable est déclarée.  Peu m'importe ce qui y sera écrit, mais je dois l'indiquer explicitement.  Je vais le faire en initialisant la variable avec une valeur non définie (non définie). <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  L'initialisation d'une variable avec une valeur non définie ne donne aucune garantie sur la valeur de la variable en mémoire.  C'est la même chose qu'une déclaration de variable non initialisée en C, sauf que vous devez l'indiquer explicitement. <br><br>  Mais peut-être que je me fiche de comment initialiser cette mémoire.  Peut-être que je veux avoir la garantie que les zéros ou une valeur arbitraire y sont écrits.  Dans ce cas, je devrais également déclarer explicitement ceci: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Cela peut sembler étrange, mais ** est l'opérateur utilisé pour développer les tableaux.  Je déclare un tableau de 0 octet, puis je le développe à 30 000 et j'obtiens la valeur d'initialisation finale de 30 000 zéro octet.  Cette opération se produit une fois, <i>au moment de la compilation</i> .  comptime est l'une des grandes idées de Zig, et j'y reviendrai dans l'un des articles suivants. <br><br>  Écrivons maintenant un programme sur brainfuck qui ne fait qu'incrémenter le premier slot mémoire cinq fois! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  Dans Zig, les chaînes sont des tableaux d'octets.  Je ne devrais pas déclarer src comme un tableau d'octets, car le compilateur l'implique.  C'est facultatif, mais si vous le souhaitez, c'est possible: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Cela compilera très bien.  Cependant, ceci: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  ne le sera pas. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Une dernière remarque: puisque les chaînes ne sont que des tableaux, elles ne se terminent pas par zéro.  Cependant, vous pouvez déclarer une chaîne terminée par un caractère nul C. En tant que littéral, il ressemblera à ceci: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Pour le bien commun ... </h3><br>  Je veux faire <i>quelque chose</i> avec chaque caractère d'une chaîne.  Je peux le faire!  Au début de main.zig, j'importe quelques fonctions de la bibliothèque standard: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">import</a> , comme pratiquement tout ce qui commence par le signe @, est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction de compilation intégrée</a> .  Ces fonctionnalités sont toujours disponibles dans le monde entier.  L'importation ici fonctionne de manière similaire à javascript - vous pouvez importer n'importe quoi en creusant dans l'espace de noms et en extraire toutes les fonctions ou variables accessibles au public.  Dans l'exemple ci-dessus, j'importe directement la fonction warn et l'affecte, tout d'un coup, à la constante warn.  Maintenant, elle peut être appelée.  Il s'agit d'un modèle courant: nous importons directement à partir de l'espace de noms std, puis appelons std.debug.warn () ou l'affectons à la variable warn.  Cela ressemble à ceci: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Pendant le débogage, le développement initial et les tests, je veux juste imprimer quelque chose à l'écran.  Zig est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sujet aux erreurs</a> et stdout est également sujet aux erreurs.  Je ne veux pas le faire pour le moment, et je peux imprimer directement sur stderr en utilisant warn, que nous avons importé de la bibliothèque standard. <br><br>  warn prend une chaîne formatée, comme printf en C!  Le code ci-dessus imprimera: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 est le code de caractère ascii +.  Je peux aussi écrire: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  et obtenez: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Nous avons donc initialisé l'espace mémoire et écrit le programme.  Nous réalisons maintenant la langue elle-même.  Je vais commencer par +, et remplacer le corps de la boucle for par switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Je reçois deux erreurs: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Bien sûr, je ne peux pas affecter une nouvelle valeur à une variable, qui est une constante!  mem doit être fait une variable ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  comme pour les autres erreurs, ma construction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commutateur</a> devrait savoir quoi faire si le caractère n'est pas +, même si rien n'est à faire.  Dans mon cas, c'est exactement ce que je veux.  Je remplis ce cas avec un bloc vide: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Maintenant, je peux compiler le programme.  Appelez avertir à la fin et exécutez: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Je reçois le numéro 5 imprimé en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stderr</a> , comme je m'y attendais. <br><br><h3>  Continuons ... </h3><br>  De même, nous soutenons. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Pour utiliser&gt; et &lt;, vous devez utiliser une variable supplémentaire, qui sert de "pointeur" dans la mémoire que j'ai allouée au programme brainfuck de l'utilisateur. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Puisqu'un 16 bits non signé peut être au maximum de 65 535, il suffit amplement d'indexer 30 000 octets d'espace d'adressage. <br><br><blockquote>  <i>en fait, 15 bits nous suffiraient, ce qui nous permet d'adresser 32767 octets.</i>  <i>Zig autorise les types avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des largeurs différentes</a> , mais pas encore u15.</i> <i><br><br></i>  <i>vous pouvez réellement faire u15 de cette façon:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il est proposé</a> que tout type [iu] \ d + soit valide comme type entier. </blockquote><br>  Maintenant, au lieu d'utiliser mem [0], je peux utiliser cette variable. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;et&gt; simplement incrémenter et décrémenter ce pointeur. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Super  Nous pouvons écrire un vrai programme maintenant! <br><br><h3>  Chèque 1,2,3 </h3><br>  Zig a un moteur de test intégré.  N'importe où dans n'importe quel fichier, je peux écrire un bloc de test: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  et exécutez le test à partir de la ligne de commande: zig test $ FILENAME.  Les autres blocs de test sont identiques au code normal. <br><br>  Regardons ceci: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Bien sûr, un test vide est inutile.  Je peux utiliser assert pour confirmer l'exécution des tests. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  Le test est tombé.  Utilisez la commande suivante pour reproduire l'erreur: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La trace de pile sur le coquelicot est toujours en cours de développement.</a> <br><br>  Pour tester cela efficacement, je dois le diviser en morceaux.  Commençons par ceci: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Cela devrait sembler fonctionner, non? <br><br>  Mais ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  cela est décrit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig est strict à ce sujet.  Les types complexes et tous les objets pouvant être redimensionnés ne peuvent pas être transmis par valeur.  Cela rend l'allocation de pile prévisible et logique et évite les copies inutiles.  Si vous souhaitez utiliser la sémantique du transfert par valeur dans votre programme, vous pouvez l'implémenter vous-même en utilisant votre stratégie d'allocation, mais le langage lui-même ne le prend pas en charge dans des circonstances ordinaires. <br><br>  Le moyen naturel de contourner cette limitation est de passer un pointeur au lieu d'une valeur (passer par référence).  Zig utilise une stratégie différente, les tranches.  Une tranche est un pointeur avec une longueur attachée et avec un contrôle pour tomber dans les bordures.  La syntaxe de la signature de fonction ressemble à ceci: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  et lors de l'appel de la fonction, cela ressemble à ceci: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Notez que j'ai défini la limite supérieure simplement en faisant référence à la longueur du tableau.  Il existe une notation abrégée pour de tels cas: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Maintenant, je peux commencer à écrire des tests qui testent directement la fonction bf ().  Je vais ajouter des fonctions de test à la fin du fichier pour l'instant ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Je prends le tableau mem d'un octet et vérifie ensuite ce qui doit arriver (l'octet est incrémenté trois fois).  Ça marche! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" est coché de la même manière: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  Ça ne marche pas!  Lorsque j'essaie de soustraire 1 de 0, j'obtiens ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem est un tableau d'octets non signés et la soustraction de 1 à 0 provoque un débordement.  Encore une fois, Zig me fait déclarer explicitement ce que je veux.  Dans ce cas, je n'ai pas à me soucier du débordement, en fait, je veux que cela se produise, car nous avons affaire à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'arithmétique modulaire</a> , conformément à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification de brainfuck</a> .  Cela signifie que décrémenter une cellule avec le nombre 0 me donnera 255, et un incrément de 255 me donnera 0. <br><br>  Zig possède plusieurs opérations arithmétiques auxiliaires qui offrent la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sémantique du «wrapping» garanti</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Cela résout tout le problème de débordement et fait ce que j'attendais. <br><br>  Pour tester &lt;et&gt;, je navigue dans un petit tableau et vérifie la valeur de la cellule incrémentée: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  et ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Dans ce dernier cas, je peux directement comparer le résultat avec un tableau statique en utilisant ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Rappelons que j'ai déjà importé std.  Dans l'exemple ci-dessous, j'utilise mem.eql dans cet espace de noms: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... et rappelez-vous, les littéraux de chaîne, ce ne sont que des tableaux u8 en zig, et je peux y mettre des littéraux hexadécimaux, c'est-à-dire  Le code suivant fonctionnera de la même manière! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Ajoutez le "."!  Il imprime simplement en tant que caractère la valeur d'octet dans la cellule vers laquelle pointe le pointeur.  J'utilise warn maintenant, mais plus tard je le remplacerai par stdout.  C'est facile à faire conceptuellement, mais quelque peu confus dans la mise en œuvre.  Je le ferai plus tard! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Cycles <br>  [et] - la magie commence ici .... <br><br>  [- si la valeur de la cellule actuelle est zéro, ignorez les étapes jusqu'au crochet fermant sans exécuter le code. <br>  ] - si la valeur de la cellule actuelle n'est pas nulle, revenez à la parenthèse ouvrante et exécutez à nouveau le code. <br><br>  Cette fois, je vais commencer par un test, je vais les tester ensemble (évidemment, cela n'a aucun sens de les tester séparément).  Le premier cas de test - la cellule de stockage [2] doit être vide, bien que la boucle doit l'incrémenter si elle démarre: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  et je vais créer des blancs pour l'instruction switch: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Que faire maintenant?  Vous pouvez utiliser une approche naïve.  J'incrémente simplement le pointeur src jusqu'à ce que je le trouve].  Mais je ne peux pas utiliser la boucle for en zig pour cela, elle a été créée uniquement pour itérer dans les collections, sans manquer leurs éléments.  Une construction appropriée ici est tout: <br><br>  était: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  est devenu ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Maintenant, je peux réaffecter le pointeur srcptr au milieu du bloc, je vais le faire: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Cela satisfait le test "[] ignore l'exécution du code et quitte" <br>  Cela satisfait le test «[] ignore l'exécution et quitte», bien qu'il ne soit pas entièrement fiable, comme nous le verrons. <br><br>  Qu'en est-il des crochets de fermeture?  Je pense que cela peut être écrit simplement par analogie: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Vous pouvez voir ce qui se passe ... Une solution naïve avec deux crochets a un défaut fatal et se casse complètement sur les boucles imbriquées.  Tenez compte des éléments suivants: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  Le résultat devrait être {2, 0}, mais le premier crochet ouvert se déplace simplement bêtement vers le premier crochet de fermeture, et tout devient compliqué.  Vous devez passer au support de fermeture suivant au même niveau d'imbrication.  Il est facile d'ajouter un compteur de profondeur et de le suivre lorsque vous avancez le long de la ligne.  Nous le faisons dans les deux sens: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  et tests associés: notez que src dans les deux tests inclut une boucle interne. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Séparément, notez [-] - l'idiome de brainfuck, signifiant «zéro cette cellule».  Vous pouvez voir que la valeur de la cellule au début n'a pas d'importance, elle sera décrémentée jusqu'à ce qu'elle atteigne 0, puis l'exécution se poursuivra. </blockquote><br><h3>  Chemin malchanceux </h3><br>  Je ne comptais pas sur la possibilité que le programme sur bf soit cassé.  Que se passe-t-il si je soumets un programme de saisie incorrect à mon interprète?  Par exemple, simplement [sans parenthèse fermante, ou &lt;, qui va immédiatement au-delà du tableau de mémoire?  (Je peux envelopper le pointeur de mémoire, mais il vaut mieux considérer cela comme une erreur). <br><br>  Je vais regarder un peu en avant et expliquer toutes les différences dans le code.  Je mettrai la fonction d'interpréteur bf dans un fichier séparé et mettrai également la fonctionnalité de recherche et de recherche dans mes propres petites fonctions. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Cela rend le commutateur beaucoup plus facile à lire, à mon avis, SeeForward et SeeBack fonctionnent et semblent très similaires, et j'ai été tenté de les transformer en quelque chose de plus intelligent et plus compact, mais à la fin ils font des choses différentes et gèrent les erreurs également de différentes manières.  Plus facile à copier et à ajuster, ce sera donc plus clair.  J'ajusterai également la fonction de recherche plus tard, à un moment donné, peut-être dans un article ultérieur. <br><br>  J'ai ajouté des choses importantes!  Notez que les trois fonctions renvoient désormais un type! .. Il s'agit de la nouvelle syntaxe pour ce qui était auparavant le type% T (union d'erreur).  Cela signifie que la fonction peut renvoyer un certain type ou une erreur.  Lorsque j'essaie d'appeler une telle fonction, je dois utiliser try avant d'appeler la fonction, ce qui lève l'erreur dans la pile des appels si l'erreur se produit, ou utiliser catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Où je gère les erreurs dans un bloc catch.  Comme écrit, catch peut avaler toutes les erreurs.  C'est une mauvaise pratique, mais ici Zig nous oblige à le faire explicitement.  Si j'attrape une erreur dans un bloc vide, je déclare soit que je ne pense pas qu'une erreur peut se produire, soit que je n'ai pas besoin de la gérer.  En pratique, cela peut être quelque chose comme TODO, et en fait il est très facile de le rendre aussi explicite! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Rappelons qu'un tel cas ne se produira jamais dans le code de production.  J'informe le compilateur que je sais ce que je fais.  Si une erreur pouvait se produire, je devrais ajouter la gestion des erreurs. <br><br>  Alors, quelles erreurs dois-je renvoyer à partir de SeeBack ou SeeForward? <br><br>  Dans SeeBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  J'ai remplacé le pointeur de décrémentation pour utiliser la sous-fonction de std lib, qui génère une erreur de débordement en cas de débordement.  Je veux attraper cette erreur et retourner à la place l'erreur OutOfBounds, que je crée ici juste en l'utilisant. <br><br><blockquote>  <i>Erreurs Zig est essentiellement un tableau de codes d'erreur qui est généré par le compilateur lorsque vous utilisez une erreur. Une sorte d'erreur.</i>  <i>Ils sont garantis uniques et peuvent être utilisés comme valeurs dans un bloc de commutation.</i> </blockquote><br>  Je veux utiliser OutOfBounds ici parce que, sémantiquement, si le pointeur de mémoire devient inférieur à zéro, je demande au runtime d'aller au-delà de l'espace mémoire que j'ai alloué. <br><br>  de même dans la fonction seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  Dans ce cas, si le pointeur est plus grand que src.len, j'attrape l'erreur ici et renvoie la même erreur. <br><br>  lors de l'appel: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  J'essaie d'appeler ces fonctions.  S'ils sont appelés avec succès, ils sont exécutés correctement et essayez de renvoyer srcptr.  S'ils échouent, essayez de terminer la fonction et renvoie une erreur à l'endroit de l'appel à la fonction entière bf. <br><br>  L'appel peut provenir du principal! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  J'avale cette erreur ici, et cela ne devrait pas être fait, mais nous noterons un point important sur la facilité avec laquelle zig peut transmettre des erreurs dans la pile d'appels.  Il n'est pas de la responsabilité de la fonction appelante de vérifier chaque cas d'erreur, mais le compilateur force l'appel de chaque fonction qui peut échouer avec un essai.  Cela doit toujours être fait, même si les erreurs sont ignorées! <br><br><blockquote>  <i>La nouvelle syntaxe try / catch élimine les nombreux sorts comme %% et% que les gens n'aiment pas tellement.</i> </blockquote><br>  Maintenant, j'ai implémenté 7 des 8 personnages de brainfuck, et cela suffit pour exécuter un programme «significatif». <br><br><h3>  Un programme significatif </h3><br>  Voici le programme: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Courons ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  le tour est joué! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Un souvenir me revient chaque fois que je pense à une série de Fibonacci ... Je l'ai découvert grâce au programme PBS (Public Broadcasting Service, un service américain de télédiffusion non commerciale) dans les années 80, et je m'en souviens toujours.</i>  <i>Je pensais que ce serait oublié, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Youtube est une bonne chose</a> .</i> </blockquote><br><h3>  Comment puis-je améliorer cela? </h3><br>  J'ai déjà fait allusion à quelques TODO.  Je n'aurais pas dû utiliser stderr pour la sortie.  Je veux utiliser stdout. <br><br>  Chaque fois que j'ouvre l'interpréteur, j'ouvre le flux dans stdout et j'imprime dedans: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  Que se passe-t-il ici?   io.getStdOut(),     (          catch unreachable —     ,  !).   ,    ,      ,       print. print   ,   warn,     . print    ,      . <br><br>    ,         stdout,        stdout. Zig         ,   ,    . <br><br>  ,   ,        ?              ,      ,            ?  ,        ?  , Zig  ! <br><br>     ,  ! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br>  ,  bf   ,     !void.       ,   main.          ,      : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>    ! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br>      ,      bf   !   ,     ,  stdout,     bf.  ,   ,       ,  try. ,   ,  ,  catch,   try,      ,       . <br><br> , : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>      ,    ,  ! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig       ,       !   switch   ,  ,   ,  ,     . <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br>  -     ,  ,     ,   Zig,        !    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   !  ! <br><br><h3> Todo </h3><br>    ,     !         , ,     ",",   brainfuck-    getc,        .            ,      bf.    ,     ,      Zig.  ,       ,           ,       . <br><br><h3>  Conclusion </h3><br>  ,           ,     Zig       . Zig    ,       ,     ,  ,     ,          ++.        ,  ,   .     ,   ,   . Zig ,   ,       ,      . <br><br>         Zig,    ,      0.2.0  !  ,   ,   debug-,          ,    !   --release-fast  --release-safe,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>        Zig.     ,       1.0.0,      Zig,    ,    ,       ! <br><br> ,    #zig  freenode   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435574/">https://habr.com/ru/post/fr435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435560/index.html">Premier ordinateur quantique commercial - IBM</a></li>
<li><a href="../fr435562/index.html">Le chemin d'un fumeur: comment entrer dans le métier de programmeur, si vous êtes humaniste</a></li>
<li><a href="../fr435564/index.html">Utilisation de GtkApplication. Fonctions de rendu Librsvg</a></li>
<li><a href="../fr435568/index.html">Routeur VyOS OpenSource</a></li>
<li><a href="../fr435572/index.html">Anycubic i3 Mega: remake de qualité de Prusa i3</a></li>
<li><a href="../fr435576/index.html">1C, pas de douleur</a></li>
<li><a href="../fr435578/index.html">Sortie dans l'espace pour Noël</a></li>
<li><a href="../fr435580/index.html">Java, Spring, Kurento et Media Services</a></li>
<li><a href="../fr435582/index.html">Comment ajouter un index sur un système chargé 24/7 sans interruption?</a></li>
<li><a href="../fr435584/index.html">Slush 2018. Premier jour, deuxième jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>