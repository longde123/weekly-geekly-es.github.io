<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛐 📨 🍍 Lösung algorithmischer Probleme: die Möglichkeit, ein Hotel zu buchen 🚷 🕋 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Übersetzung des Artikels wurde speziell für Studenten des Kurses "Algorithmen für Entwickler" vorbereitet. 



 Dieser Artikel ist Teil einer Reih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lösung algorithmischer Probleme: die Möglichkeit, ein Hotel zu buchen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/470676/">  <i><b>Die Übersetzung des Artikels wurde speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Algorithmen für Entwickler"</a> vorbereitet.</b></i> <br><br><img src="https://habrastorage.org/webt/--/ea/mq/--eamqk7ybfubuntwpzpxl7wk0e.png"><br><br>  <i>Dieser Artikel ist Teil einer Reihe zur Lösung algorithmischer Probleme.</i>  <i>Aufgrund meiner persönlichen Erfahrung stellte ich fest, dass die meisten Ressourcen die Lösung einfach im Detail beschreiben.</i>  <i>Eine Erklärung der Hauptargumentation, die es ermöglicht, eine wirksame Lösung zu finden, ist leider nicht sehr verbreitet.</i>  <i>Ziel dieser Reihe ist es daher, den möglichen Denkweg für die Lösung von Problemen von Grund auf zu beschreiben.</i> <br><br><hr><a name="habracut"></a><br><h3>  Herausforderung </h3><br><blockquote><ul><li>  Aufgabe: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InterviewBit</a> </li></ul><br>  Der Hotelmanager muss N Reservierungsaufträge für die nächste Saison bearbeiten.  Sein Hotel verfügt über K Zimmer.  Die Buchungsinformationen enthalten das Check-in-Datum und das Check-out-Datum.  Der Manager möchte herausfinden, ob im Hotel genügend Zimmer vorhanden sind, um die Nachfrage zu befriedigen. <br><br>  Eingabedaten: <br><br>  - Der erste, der eine Liste mit Informationen zur Ankunftszeit eingibt <br>  - Zweitens - eine Liste mit Informationen zum Zeitpunkt der Abreise <br>  - Dritter - K, der die Anzahl der Räume angibt <br><br>  Ausgabedaten: <br>  - Ein logischer Wert, der die Möglichkeit angibt, Zimmer zu buchen <br>  false bedeutet, dass das Hotel nicht genügend Zimmer für N Buchungen hat <br>  true bedeutet, dass das Hotel über genügend Zimmer für N Buchungen verfügt <br><br>  <b>Ein Beispiel:</b> <br><br>  Eingabedaten: <br>  - Check-in = [1, 3, 5] <br>  - Abfahrt = [2, 6, 10] <br>  - K = 1 <br><br>  Ausgabe: false.  Am Tag = 5 hat das Hotel 2 Gäste.  Wir haben aber nur eine Nummer. <br><br><ul><li>  Kategorie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arrays</a> </li></ul><br></blockquote><br><h3>  Entscheidungsprozess </h3><br>  Diese Aufgabe ist meiner Meinung nach interessant, da es viele verschiedene Möglichkeiten gibt, sie zu lösen.  Schauen wir uns die Optionen an. <br><br>  Eine Struktur, in der Zähler für jeden Tag gespeichert werden <br>  Die erste Idee könnte sein, dass wir eine Struktur benötigen, um die Anzahl der Bestellungen für jeden Tag zu speichern.  Diese Struktur kann ein Array mit einer festen Größe sein (bestimmt durch den maximalen Abreisetag). <br><blockquote>  Eingabedaten: <br>  - Einträge = [1, 3, 5] <br>  - Abfahrten = [2, 6, 10] <br>  - k = 1 <br></blockquote><br>  In diesem Beispiel beträgt die Größe des Arrays 10 (da der letzte Exit am 10. Tag erfolgt).  Um dieses Array zu füllen, gehen wir die Listen der Ein- und Ausgänge durch und erhöhen oder verringern den Zähler des entsprechenden Tages.  Pseudocode-Beispiel: <br><br><pre><code class="bash hljs">int[] counts = new int[maxDepartures(departures)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each arr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arrivals { counts[arr]++ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each dep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> departures { counts[dep]-- }</code> </pre> <br>  Als Ergebnis erhalten wir das folgende Array: <br><br> <code>: 1 0 1 1 2 1 1 1 1 0 <br> : 1 2 3 4 5 6 7 8 9 10</code> <br> <br>  Nachdem das Array voll ist, müssen Sie es nur noch durchgehen und prüfen, ob alle Elemente <code>k</code> (Anzahl der Räume) nicht überschreiten. <br><br>  Im vorherigen Beispiel war die maximale Anzahl von Zimmern 1. Da wir an Tag 5 2 Reservierungen haben, geben wir <code>false</code> . <br><br>  Die zeitliche Komplexität dieser Lösung ist O (n), wobei n die Anzahl der Reservierungen ist, und räumlich ist O (m), wobei m der maximale Abreisetag ist.  Theoretisch nicht schlecht, aber es wird wahrscheinlich viel Speicher für ein großes Array reserviert, obwohl das meiste davon nicht verwendet wird. <br><br>  Zum Beispiel: <br><blockquote>  Eingabedaten: <br>  - Einträge = [1, 3, 5] <br>  - Abfahrten = [2, 10000, 10] <br>  - k = 1 </blockquote><br>  In diesem Fall wird ein Array von 10 Tausend Ganzzahlen zugewiesen. <br><br>  Schauen wir uns andere Lösungen an. <br><br><h3>  Speicher für Ereignissammlungen </h3><br>  Welche anderen Möglichkeiten gibt es?  Schauen wir uns noch einmal an, was mit der vorherigen Struktur passiert ist: <br><br> <code>: 1 0 1 1 2 1 1 1 1 0 <br> : 1 2 3 4 5 6 7 8 9 10</code> <br> <br>  Wir sehen, dass einige Informationen dupliziert werden.  Beispielsweise ändert sich zwischen 6 und 9 Tagen die Anzahl der Buchungen nicht, da wir wissen, dass in diesem Zeitraum nichts passieren wird. <br><br>  Könnte es besser sein, wenn stattdessen Ereignisse gespeichert werden?  Nehmen wir noch einmal das gleiche Beispiel: <br><blockquote>  Eingabedaten: <br>  - Einträge = [1, 3, 5] <br>  - Abfahrten = [2, 6, 10] <br>  Tag 1: +1 Buchung <br>  Tag 2: -1 Buchung <br>  Tag 3: +1 Buchung <br>  Tag 6: -1 Buchung <br>  Tag 5: +1 Buchung <br>  Tag 10: -1 Buchung </blockquote><br>  Die Lösung besteht darin, diese Ereignisse zu durchlaufen, um den Zähler zu erhöhen oder zu verringern.  Wenn der Zähler irgendwann größer als <code>k</code> , geben wir <code>false</code> .  Zum Durchlaufen muss diese Sammlung von Ereignissen jedoch sortiert werden. <br><br>  Welche Struktur ist hier besser zu verwenden?  Fassen wir unsere Anforderungen zusammen: <br><br><ul><li>  Suchen Sie, um zu überprüfen, ob ein solcher Tag bereits existiert </li><li>  Einen neuen Tag hinzufügen, </li><li>  Struktur anzeigen, um über jeden sortierten Tag zu iterieren. </li></ul><br>  Wie wäre es mit einem binären Suchbaum (BST)? <br><br>  Jeder Knoten kann wie folgt dargestellt werden: <br><br><pre> <code class="plaintext hljs">class Node { int day int count Node left Node right }</code> </pre> <br>  Die Sortierung erfolgt im Tagesfeld. <br><br>  Betrachten wir die Konsequenzen in Bezug auf die zeitliche Komplexität: <br><br><ul><li>  Suchen Sie, um zu überprüfen, ob ein solcher Tag bereits existiert: O (log (n)) im Durchschnitt, O (n) im schlimmsten Fall, </li><li>  Hinzufügen eines neuen Tages: O (log (n)) im Durchschnitt, O (n) im schlimmsten Fall, </li><li>  Zeigen Sie die Struktur für die Iteration über jeden sortierten Tag an: O (n) mithilfe einer Tiefensuche. </li></ul><br>  Da wir jedes Element durchlaufen und in den Baum einfügen müssen, beträgt die Komplexität des Algorithmus im Durchschnitt O (n log (n)), im schlechtesten Fall O (n²). <br><br>  Eine andere Möglichkeit besteht darin, eine Hash-Tabelle zu verwenden und die Schlüssel zu sortieren, nachdem alle Ereignisse hinzugefügt wurden: <br><br><ul><li>  Suchen Sie, um zu überprüfen, ob ein solcher Tag bereits existiert: O (1) im Durchschnitt, O (n) im schlimmsten Fall (die Wahrscheinlichkeit hängt von der Kapazität des assoziativen Arrays ab), </li><li>  Hinzufügen eines neuen Tages: O (1) im Durchschnitt, O (n) im schlimmsten Fall, </li><li>  Zeigen Sie die Struktur für die Iteration über jeden sortierten Tag an: O (n log (n)) zum Sortieren von Schlüsseln und O (n) zum Sortieren. </li></ul><br>  Am Ende hat die Lösung im mittleren Fall (aufgrund der Sortieroperation) O (n log (n)) und im schlimmsten Fall O (n²).  Diese Lösung scheint dieselbe Komplexität zu haben wie eine baumbasierte Lösung. <br><br>  Schauen wir uns eine mögliche Implementierung in Java mit einem sortierten assoziativen Array an: <br><br><pre> <code class="bash hljs">public boolean hotel(ArrayList&lt;Integer&gt; arrivals, ArrayList&lt;Integer&gt; departures, int k) { //   Map&lt;Integer, Integer&gt; events = new HashMap&lt;&gt;(); //   int n = arrivals.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = 0; i &lt; n; i++) { int arrival = arrivals.get(i); int departure = departures.get(i); //      Integer current = events.get(arrival); events.put(arrival, current == null ? 1 : current + 1); //      current = events.get(departure); events.put(departure, current == null ? -1 : current - 1); } //    Map&lt;Integer, Integer&gt; sortedEvents = new TreeMap&lt;&gt;(events); int count = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Map.Entry&lt;Integer, Integer&gt; entry : sortedEvents.entrySet()) { count += entry.getValue(); //  count     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; k) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Konstante räumliche Komplexität </h3><br>  Wenn wir unseren Algorithmus optimieren wollen, müssen wir uns überlegen, ob es wirklich notwendig ist, alle diese Ereignisse zu speichern.  Können wir nicht einfach die Erfassungsdaten (Ein- und Ausgänge) sortieren und dabei das Reservierungslimit überprüfen? <br><br>  Eine Lösung ist möglich, aber dafür wäre es notwendig, die Eingabe durch vorheriges Sortieren zu vereinfachen. <br><br>  Wenn beide Sammlungen sortiert sind, können wir einfach mit zwei Zeigern (einer für Eingänge und einer für Ausgänge) über jedes Element iterieren und die Einschränkungen im laufenden Betrieb überprüfen. <br><br>  Wie Sie sehen, müssen wir bei jeder Iteration noch das Minimum zwischen <code>arrivals.get(indexArrival)  departures.get(indexDeparture)</code> , um herauszufinden, welcher Zeiger aktualisiert werden muss. <br><br>  Im Allgemeinen weist der Algorithmus aufgrund von Sortieroperationen eine konstante zeitliche und räumliche Komplexität O (n log (n)) auf. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470676/">https://habr.com/ru/post/de470676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470664/index.html">Intel stellte eine neue Reihe von Xeon-Prozessoren vor. Sie sind billiger als frühere Modelle, aber immer noch bei 14 nm</a></li>
<li><a href="../de470666/index.html">IT-Hogwarts: Schule der Programmierer hh.ru.</a></li>
<li><a href="../de470670/index.html">So erstellen Sie ein intelligentes Elektrofahrrad</a></li>
<li><a href="../de470672/index.html">Implementierung von Service Desk und CRM. 13 Hauptursachen für Fehler und wie kann man sie vermeiden?</a></li>
<li><a href="../de470674/index.html">Im JeMalloc. Kerndatenstrukturen: Pairing von Heap- und Bitmap-Baum</a></li>
<li><a href="../de470680/index.html">Beste Sprachen für die Spielelokalisierung</a></li>
<li><a href="../de470684/index.html">Was ist im Lebenslauf zu schreiben, wenn keine Berufserfahrung vorliegt?</a></li>
<li><a href="../de470686/index.html">Technologie für die Smart City. Wird St. Petersburg die erste Metropole für Blinde?</a></li>
<li><a href="../de470688/index.html">Was ist über VMworld 2019 bekannt?</a></li>
<li><a href="../de470692/index.html">Wie wir eine neue Rosbank-Website erstellt haben und was daraus wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>