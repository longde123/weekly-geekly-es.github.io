<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöé üßöüèª üìâ Enregistrement de donn√©es dans une EEPROM sur un Arduino de mani√®re transactionnelle ‚ùå üåõ üö£üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La pr√©sence d'EEPROM offre aux d√©veloppeurs un outil pratique pour enregistrer les param√®tres de configuration ou un √©tat changeant lentement qu'une p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enregistrement de donn√©es dans une EEPROM sur un Arduino de mani√®re transactionnelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482918/">  La pr√©sence d'EEPROM offre aux d√©veloppeurs un outil pratique pour enregistrer les param√®tres de configuration ou un √©tat changeant lentement qu'une panne de courant devrait survivre.  Dans cet article, nous verrons comment le faire de mani√®re aussi s√ªre et pratique que possible afin de ne rien oublier et de ne pas se souvenir de ce qui n'√©tait pas l√†. <br><a name="habracut"></a><br>  Supposons que nous ayons une variable et que nous voulons la stocker dans une EEPROM.  Il semblerait que tous les outils pour cela soient entre nos mains: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;EEPROM.h&gt; int my_var = DEFAULT_VALUE; EEPROM.get(MY_VAR_ADDR, my_var); my_var = NEW_VALUE; EEPROM.put(MY_VAR_ADDR, my_var);</span></span></span></span></code> </pre> <br>  Cependant, un examen plus approfondi r√©v√®le que cette approche cr√©e plus de probl√®mes qu'elle n'en r√©sout.  Nous en discuterons dans l'ordre. <br><br>  1. Comment s'assurer que nous lisons exactement ce que nous avons √©crit (pour garantir l' <b>int√©grit√©</b> )?  Imaginez l'image suivante.  Nous nous √©crivons une lettre en cas de mort subite due √† une panne de courant ou √† un signal de r√©initialisation et la mettons dans un tiroir de bureau.  Dans la prochaine vie, nous ouvrons le tiroir du bureau, sortons un morceau de papier, lisons le message et continuons notre mission.  Le probl√®me est que dans la bo√Æte il y a toujours des feuilles de papier gribouill√©es avec du texte al√©atoire.  Nous avons donc besoin d'un moyen de distinguer le message correct du message al√©atoire.  On pourrait l'assurer d'un notaire public, mais dans le cas le plus simple, sa signature suffirait si nous avons un moyen de v√©rifier son exactitude.  Par exemple, nous pouvons utiliser le r√©sultat d'une expression math√©matique en fonction du texte comme signature, de sorte que la probabilit√© de co√Øncidence al√©atoire soit suffisamment petite.  Dans le cas le plus simple, il s'agit d'un CRC ou d'une somme de contr√¥le.  Cela nous prot√©gera non seulement de la lecture de ce que nous n'avons pas √©crit, mais aussi de la lecture d'un message endommag√©.  Apr√®s tout, le texte s'estompe avec le temps et les √©lectrons dans l'obturateur isol√© sont encore moins durables - une particule volera de l'espace avec suffisamment d'√©nergie et le bit changera.  Mais il existe un autre moyen d'obtenir un message endommag√© - ce n'est pas de l'ajouter √† la fin.  Ce n'est pas si exotique, car au moment de l'enregistrement, la consommation actuelle augmente fortement, ce qui peut provoquer une mort pr√©matur√©e de l'√©crivain. <br><br>  2. Supposons que nous soyons convaincus de l'exactitude du message, mais comment puis-je m'assurer que c'est moi qui l'ai √©crit (pour garantir l' <b>authenticit√©</b> ).  Comme dit le proverbe, je suis diff√©rent.  Soudain, quelqu'un d'autre √©tait assis √† cette table avant ma r√©incarnation, et il avait une mission diff√©rente, et pour quelle raison vais-je maintenant √™tre guid√© par ses messages?  Si nous fournissions √† nos notes une certaine √©tiquette, il nous serait plus facile de distinguer les n√¥tres des √©trangers.  Par exemple, une telle √©tiquette pourrait √™tre le nom de la variable que nous enregistrons.  Le seul probl√®me est qu'il n'y a pas beaucoup d'espace dans l'EEPROM pour y mettre des noms de variables, et il n'est pas pratique de le faire, car ils sont de longueurs diff√©rentes.  Mais heureusement, il existe un moyen plus simple - vous pouvez calculer la somme de contr√¥le au nom de la variable et l'utiliser comme raccourci.  Dans le m√™me temps, il est utile d'ajouter la taille de la variable en octets √† cette somme de contr√¥le afin de ne pas lire accidentellement le mauvais montant.  Eh bien, par souci d'exhaustivit√©, nous y ajoutons un autre identifiant num√©rique, afin de garantir distinguer notre variable de quelqu'un d'autre, m√™me s'ils sont appel√©s les m√™mes.  Nous appelons ce num√©ro l'identificateur d'instance (inspir√© de la POO si le nom de la variable est consid√©r√© comme un champ d'objet).  Si jamais nous mettons √† jour notre mission vers une version radicalement nouvelle, de sorte que cette mise √† jour rend insens√© tout ce que l'ancien a enregistr√©, alors nous avons juste besoin de changer l'identifiant d'instance pour invalider tout ce qui a √©t√© enregistr√© par l'ancienne version. <br><br>  3. Comment puis-je faire en sorte qu'une op√©ration d'√©criture incompl√®te laisse inchang√©e l'ancienne valeur stock√©e?  Autrement dit, l'op√©ration de sauvegarde doit r√©ussir ou ne pas avoir d'effet observable du tout.  En d'autres termes, il devrait √™tre <b>atomique</b> ou transactionnel si nous parlons d'une transaction qui se r√©sume √† une mise √† jour inconditionnelle d'une valeur unique.  De toute √©vidence, nous ne pouvons pas garantir l'atomicit√© de l'enregistrement en r√©√©crivant la valeur pr√©c√©dente, nous devons √©crire dans un nouvel emplacement afin que l'ancienne valeur stock√©e reste intacte, au moins jusqu'√† la fin de l'enregistrement de la nouvelle.  Cette technique est souvent appel√©e ¬´copie sur √©criture¬ª si seule une partie de la valeur enregistr√©e est mise √† jour, mais la partie qui reste inchang√©e est toujours copi√©e et √©crite dans un nouvel emplacement.  En d√©veloppant notre analogie, nous nous √©crirons des lettres, en laissant les anciennes intactes, mais en fournissant √† chaque lettre un num√©ro de s√©rie croissant afin que dans notre prochaine vie, nous ayons la possibilit√© de trouver la derni√®re lettre que nous avons √©crite.  Cependant, un nouveau probl√®me se pose - la place dans la bo√Æte o√π nous mettons les lettres se terminera t√¥t ou tard si nous ne jetons pas les vieilles lettres qui ne sont plus pertinentes.  Il est facile de comprendre qu'il suffit de stocker seulement 2 lettres - une ancienne et une nouvelle, elle peut √™tre en cours d'√©criture.  Par cons√©quent, le num√©ro de lettre n'a √©galement pas besoin de beaucoup de bits. <br><br>  Curieusement, l'auteur n'a pas pu trouver une seule impl√©mentation qui permettrait l'organisation du stockage des donn√©es en EEPROM, tout en garantissant l'int√©grit√©, l'authenticit√© et l'atomicit√©.  J'ai d√ª √©crire √† <a href="https://github.com/olegv142/NvTx" rel="nofollow">github.com/olegv142/NvTx</a> moi-m√™me <br><br>  Pour enregistrer chaque variable dans l'EEPROM, 2 zones cons√©cutives sont utilis√©es - des cellules avec la m√™me structure.  L'identifiant de la variable calcul√© sur la base de sa taille, de son √©tiquette de texte et de son identifiant d'instance est √©crit dans les 2 premiers octets.  Ensuite, les donn√©es sont √©crites, suivies de 2 octets de la somme de contr√¥le.  Dans le tout premier octet, deux bits ont une fonction particuli√®re.  Le bit le plus significatif est l'indicateur de correction; lors de l'√©criture, il est toujours d√©fini sur un.  Le bit de poids faible est utilis√© comme un seul bit de l'√©poque, il est n√©cessaire pour trouver le dernier message.  L'enregistrement se fait dans des cellules ¬´en cercle¬ª.  Le num√©ro de l'√®re change chaque fois qu'un enregistrement est effectu√© dans la premi√®re cellule.  D'o√π l'algorithme de d√©termination de la derni√®re cellule enregistr√©e: si les √©poques des cellules sont les m√™mes, alors la seconde est √©crite en dernier, si diff√©rente - alors la premi√®re. <br><br>  Le bit de correction semble redondant, mais il a une fonction importante.  Tout d'abord, nous lisons les donn√©es stock√©es et v√©rifions l'exactitude des deux cellules.  Si la cellule ne r√©ussit pas la v√©rification de l'identifiant ou de la somme de contr√¥le correct, nous r√©initialisons le bit d'exactitude.  Les op√©rations d'√©criture suivantes peuvent ne pas v√©rifier l'exactitude des cellules, mais s'appuyer sur cet indicateur, ce qui r√©duit les frais g√©n√©raux d'environ 2 fois. <br><br>  Ceux qui veulent se plonger dans les d√©tails de l'impl√©mentation peuvent voir les images et le code dans le <a href="https://github.com/olegv142/NvTx" rel="nofollow">r√©f√©rentiel</a> .  Moi, pour ne pas ennuyer le lecteur, je passe √† l'usage.  Les fonctions d'√©criture / lecture de donn√©es re√ßoivent chacune 5 param√®tres, de sorte que la commodit√© de leur utilisation est sacrifi√©e au profit de la flexibilit√©.  Mais il est g√©n√©reusement compens√© par deux ensembles de macros, qui rendent l'utilisation de la biblioth√®que aussi simple que dans le cas d'EEPROM.get / put.  Le premier ensemble de macros est utilis√© si vous souhaitez simplement enregistrer la variable √† l'adresse donn√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; bool have_my_var = NvTxGetAt(my_var, MY_VAR_ADDR); my_var = NEW_VALUE; NvTxPutAt(my_var, MY_VAR_ADDR);</span></span></span></span></code> </pre><br>  S'il y a plusieurs variables √† enregistrer, chacune devra d√©terminer l'adresse et en m√™me temps consid√©rer correctement la taille afin que les zones de m√©moire o√π les variables sont stock√©es ne se chevauchent pas.  Pour simplifier la t√¢che, le deuxi√®me ensemble de macros impl√©mente l'allocation automatique d'adresses, et le fait <b>au moment de la compilation</b> .  Par exemple, la <a href="https://github.com/thijse/Arduino-EEPROMEx" rel="nofollow">biblioth√®que Arduino-EEPROMEx</a> peut allouer de la m√©moire au moment de l'ex√©cution, tandis qu'elle stocke l'adresse en RAM pour chaque variable stock√©e.  La biblioth√®que <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> alloue de l'espace dans l'EEPROM sans rien ajouter au code ex√©cutable ou au contenu de la RAM. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NvTx.h&gt; int my_var = DEFAULT_VALUE; char my_string[16] = ""; NvPlace(my_var, MY_START_ADDR, MY_INST_ID); NvAfter(my_string, my_var); bool have_my_var = NvTxGet(my_var); my_var = NEW_VALUE; NvTxPut(my_var);</span></span></span></span></code> </pre><br>  La macro NvPlace d√©finit l'adresse de d√©part de la zone EEPROM, o√π nous allons stocker les variables et l'identifiant d'instance.  La macro NvAfter r√©serve une r√©gion de m√©moire pour stocker son premier argument imm√©diatement apr√®s la r√©gion de m√©moire r√©serv√©e au second.  Lors de l'allocation de m√©moire, il est √©galement v√©rifi√© que nous n'avons pas d√©pass√© la taille EEPROM disponible, et que nous n'avons pas r√©serv√© de zones de m√©moire qui se chevauchent (cela peut se produire si deux macros NvAfter ont le m√™me deuxi√®me argument).  En cas de violation de l'une des deux conditions sp√©cifi√©es, le programme ne compile tout simplement pas.  Ceux qui veulent g√©rer le m√©canisme d'allocation de m√©moire le trouveront dans le fichier d'en-t√™te <a href="" rel="nofollow">NvTx.h.</a>  Toutes les macros NvPlace et NvAfter permettent de d√©finir les √©num√©rations, de former leurs noms en fonction des noms de variables, et d'utiliser √©galement la construction idiomatique tr√®s utile de l' <a href="" rel="nofollow">assertion de temps de compilation</a> . <br><br>  Esp√©rons que la biblioth√®que <a href="https://github.com/olegv142/NvTx" rel="nofollow">NvTx</a> aidera les lecteurs √† √©crire du code fiable de qualit√© industrielle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482918/">https://habr.com/ru/post/fr482918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482902/index.html">Non, l'intelligence artificielle ne peut pas nous vaincre</a></li>
<li><a href="../fr482904/index.html">Une br√®ve histoire des microprocesseurs spatiaux, premi√®re partie</a></li>
<li><a href="../fr482906/index.html">√Ä propos de la s√©curit√© du r√©seau</a></li>
<li><a href="../fr482908/index.html">La deuxi√®me partie de la traduction du livre Masters of Doom de David Kouchner. Chapitres 6-12</a></li>
<li><a href="../fr482912/index.html">L'id√©e d'un r√©seau social d√©centralis√© de nouvelle g√©n√©ration</a></li>
<li><a href="../fr482920/index.html">Comment le pilote automatique est entr√© dans nos vies, mais nous n'avons pas remarqu√©</a></li>
<li><a href="../fr482922/index.html">Drupal Digest - 2019 / d√©cembre</a></li>
<li><a href="../fr482926/index.html">Arc est un syst√®me de contr√¥le de version pour un monorepositaire. Rapport Yandex</a></li>
<li><a href="../fr482928/index.html">Predator Vision: effet de vision thermique</a></li>
<li><a href="../fr482930/index.html">Recherche g√©n√©alogique - livres m√©triques, recensements, archives, bases de donn√©es ouvertes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>