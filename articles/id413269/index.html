<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ ğŸ§€ ğŸš¦ Bagaimana mesin menganalisis data besar: pengantar algoritma pengelompokan ğŸ¤±ğŸ» ğŸ§–ğŸ¾ âœŒï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan dari Bagaimana Mesin Masuk Akal dengan Big Data: Pengantar Algoritma Clustering . 

 Lihatlah gambar di bawah ini. Ini adalah kumpulan sera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana mesin menganalisis data besar: pengantar algoritma pengelompokan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Mesin Masuk Akal dengan Big Data: Pengantar Algoritma Clustering</a> .</i> <br><br>  Lihatlah gambar di bawah ini.  Ini adalah kumpulan serangga (siput bukan serangga, tetapi kami tidak akan menemukan kesalahan) dari berbagai bentuk dan ukuran.  Sekarang bagilah mereka menjadi beberapa kelompok sesuai dengan tingkat kesamaannya.  Tanpa tangkapan.  Mulailah dengan mengelompokkan laba-laba. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Jadi?  Meskipun tidak ada solusi "benar" di sini, Anda harus membagi makhluk-makhluk ini menjadi empat <b>kelompok</b> .  Dalam satu kelompok terdapat laba-laba, di kelompok kedua - sepasang siput, di kelompok ketiga - kupu-kupu, dan di kelompok keempat - trio lebah dan tawon. <br><br>  Bagus, kan?  Anda mungkin bisa melakukan hal yang sama jika ada dua kali lebih banyak serangga dalam gambar.  Dan jika Anda punya banyak waktu - atau keinginan untuk entomologi - maka Anda mungkin akan mengelompokkan ratusan serangga. <br><br>  Namun, untuk sebuah mesin, pengelompokan sepuluh objek ke dalam kelompok yang berarti bukanlah tugas yang mudah.  Berkat cabang matematika yang rumit seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kombinatorik</a> , kita tahu bahwa 10 serangga dikelompokkan dalam 115.975 cara.  Dan jika ada 20 serangga, maka jumlah opsi pengelompokan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan melebihi 50 triliun</a> . <br><br>  Dengan seratus serangga, jumlah solusi yang mungkin akan lebih besar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jumlah partikel elementer di Alam Semesta yang diketahui</a> .  Berapa banyak lagi  Menurut perkiraan saya, sekitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lima ratus juta miliar miliar kali lebih</a> .  Ternyata lebih dari <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">empat juta miliar</a></b> solusi <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">google</a></b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa itu google?</a> ).  Dan ini hanya untuk ratusan objek. <br><br>  Hampir semua kombinasi ini tidak ada artinya.  Meskipun ada sejumlah solusi yang tak terbayangkan, Anda sendiri dengan cepat menemukan salah satu dari beberapa cara pengelompokan yang bermanfaat. <br><br>  Kami manusia menerima begitu saja kemampuan kami yang luar biasa untuk membuat katalog dan memahami sejumlah besar data.  Tidak masalah apakah itu teks, atau gambar di layar, atau urutan objek - orang, secara umum, secara efektif memahami data yang berasal dari dunia sekitarnya. <br><br>  Mengingat bahwa aspek kunci dari pengembangan AI dan pembelajaran mesin adalah bahwa mesin dapat dengan cepat memahami volume besar data input, bagaimana saya dapat meningkatkan efisiensi kerja?  Pada artikel ini, kami akan mempertimbangkan tiga algoritma pengelompokan dengan mesin yang dapat dengan cepat memahami sejumlah besar data.  Daftar ini jauh dari lengkap - ada algoritma lain - tetapi sudah sangat mungkin untuk memulainya. <br><br>  Untuk setiap algoritma, saya akan menjelaskan kapan itu dapat digunakan, cara kerjanya, dan saya juga akan memberikan contoh dengan analisis langkah demi langkah.  Saya percaya bahwa untuk memahami algoritma yang sebenarnya, Anda perlu mengulangi kerjanya sendiri.  Jika Anda <b>benar</b> - <b>benar tertarik</b> , Anda akan menyadari bahwa yang terbaik adalah menjalankan algoritma di atas kertas.  Bertindak, tidak ada yang akan menyalahkan Anda! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Tiga cluster yang mencurigakan rapi dengan k = 3</i> <br><br><h2>  K-means clustering </h2><br><h5>  Digunakan oleh: </h5><br>  Ketika Anda memahami berapa banyak kelompok dapat diperoleh untuk menemukan <b>yang telah ditentukan</b> (apriori). <br><br><h5>  Cara kerjanya: </h5><br>  Algoritma secara acak menetapkan setiap pengamatan ke salah satu kategori <b>k</b> , dan kemudian menghitung <b>rata</b> - <b>rata</b> untuk setiap kategori.  Kemudian ia menugaskan kembali setiap pengamatan ke kategori dengan rata-rata terdekat, dan kembali menghitung rata-rata.  Proses ini diulang sampai penugasan kembali diperlukan. <br><br><h5>  Contoh kerja: </h5><br>  Ambil grup yang terdiri dari 12 pemain dan jumlah gol yang dicetak oleh mereka masing-masing di musim ini (misalnya, dalam kisaran 3 hingga 30).  Kami membagi para pemain, katakanlah, menjadi tiga kelompok. <br><br>  <b>Langkah 1</b> : Anda perlu membagi pemain secara acak menjadi tiga kelompok dan menghitung rata-rata untuk masing-masing pemain. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Langkah 2</b> : menetapkan kembali setiap pemain ke grup dengan rata-rata terdekat.  Misalnya, pemain A (5 gol) masuk ke grup 2 (rata-rata = 9).  Kemudian kami menghitung rata-rata grup. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Ulangi</b> langkah 2 lagi dan lagi sampai para pemain berhenti berganti kelompok.  Dalam contoh buatan ini, ini akan terjadi pada iterasi berikutnya.  <b>Hentikan itu!</b>  Anda telah membentuk tiga kelompok dari set data! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Cluster harus sesuai dengan posisi pemain di lapangan - bek, bek tengah dan ke depan.  K-means berfungsi dalam contoh ini karena ada alasan untuk percaya bahwa data akan dibagi ke dalam tiga kategori ini. <br><br>  Dengan demikian, berdasarkan variasi statistik dalam kinerja, mesin dapat membenarkan lokasi pemain di lapangan untuk olahraga tim apa pun.  Ini berguna untuk analitik olahraga, juga untuk tugas-tugas lain di mana membagi dataset ke dalam kelompok yang telah ditentukan membantu untuk menarik kesimpulan yang tepat. <br><br>  Ada beberapa variasi dari algoritma yang dijelaskan.  Pembentukan awal cluster dapat dilakukan dengan berbagai cara.  Kami memeriksa klasifikasi acak pemain ke dalam kelompok, diikuti oleh perhitungan rata-rata.  Akibatnya, rata-rata kelompok awal dekat satu sama lain, yang meningkatkan pengulangan. <br><br>  Pendekatan alternatif adalah membentuk kelompok yang hanya terdiri dari satu pemain, dan kemudian mengelompokkan pemain ke dalam kelompok terdekat.  Cluster yang dihasilkan lebih tergantung pada tahap awal pembentukan, dan pengulangan dalam dataset dengan variabilitas tinggi menurun.  Tetapi dengan pendekatan ini, mungkin diperlukan lebih sedikit iterasi untuk menyelesaikan algoritme, karena lebih sedikit waktu akan dihabiskan untuk memisahkan grup. <br><br>  Kelemahan yang jelas dari pengelompokan k-means adalah bahwa Anda perlu menebak <b>sebelumnya</b> berapa banyak cluster yang Anda miliki.  Ada metode untuk menilai kesesuaian satu set cluster tertentu.  Sebagai contoh, Sum-of-Squares Dalam-Cluster adalah ukuran variabilitas dalam setiap cluster.  Semakin baik cluster, semakin rendah jumlah total intracluster kuadrat. <br><br><h2>  Pengelompokan hierarkis </h2><br><h5>  Digunakan oleh: </h5><br>  Saat Anda perlu mengungkap hubungan antara nilai-nilai (pengamatan). <br><br><h5>  Cara kerjanya: </h5><br>  Matriks jarak dihitung di mana nilai sel ( <i>i, j</i> ) adalah metrik jarak antara nilai-nilai <i>i</i> dan <i>j</i> .  Kemudian sepasang nilai terdekat diambil dan rata-rata dihitung.  Matriks jarak baru dibuat, nilai-nilai berpasangan digabungkan menjadi satu objek.  Kemudian sepasang nilai terdekat diambil dari matriks baru ini dan nilai rata-rata baru dihitung.  Siklus berulang sampai semua nilai dikelompokkan. <br><br><h5>  Contoh kerja: </h5><br>  Ambil dataset yang sangat sederhana dengan beberapa spesies paus dan lumba-lumba.  Saya seorang ahli biologi, dan saya dapat meyakinkan Anda bahwa lebih banyak properti digunakan untuk membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon filogenetik</a> .  Tetapi untuk contoh kita, kita membatasi diri pada panjang tubuh karakteristik enam spesies mamalia laut.  Akan ada dua tahap perhitungan. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Langkah 1</b> : matriks jarak antara semua tampilan dihitung.  Kami akan menggunakan metrik Euclidean yang menggambarkan seberapa jauh data kami satu sama lain, seperti pemukiman di peta.  Anda bisa mendapatkan perbedaan panjang tubuh masing-masing pasangan dengan membaca nilai di persimpangan kolom dan baris yang sesuai. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Langkah 2</b> : Ambil sepasang dua spesies yang paling dekat satu sama lain.  Dalam hal ini, itu adalah lumba-lumba hidung botol dan lumba-lumba abu-abu, di mana panjang tubuh rata-rata adalah 3,3 m. <br><br>  Kami ulangi langkah 1, sekali lagi menghitung matriks jarak, tetapi kali ini kami menggabungkan dolphin bottlenose dan gray dolphin menjadi satu objek dengan panjang tubuh 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Sekarang kita ulangi langkah 2, tetapi dengan matriks jarak baru.  Kali ini paus penggiling dan pembunuh akan menjadi yang terdekat, jadi mari kita taruh dalam pasangan dan hitung rata-rata - 7 m. <br><br>  Selanjutnya, ulangi langkah 1: sekali lagi, hitung matriks jarak, tetapi dengan paus penggiling dan pembunuh dalam bentuk objek tunggal dengan panjang tubuh 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Ulangi langkah 2 dengan matriks ini.  Jarak terkecil (3,7 m) akan berada di antara dua objek gabungan, jadi kami akan menggabungkannya menjadi objek yang lebih besar dan menghitung nilai rata-rata - 5,2 m. <br><br>  Kemudian ulangi langkah 1 dan hitung matriks baru dengan menggabungkan lumba-lumba hidung botol / lumba-lumba abu-abu dengan paus giling / pembunuh. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Ulangi langkah 2. Jarak terkecil (5 m) akan berada di antara humpback dan finwale, jadi kami menggabungkannya dan menghitung rata-rata - 17,5 m. <br><br>  Sekali lagi langkah 1: hitung matriksnya. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Terakhir, ulangi langkah 2 - hanya ada satu jarak yang tersisa (12,3 m), jadi kami akan menyatukan semua orang menjadi satu objek dan berhenti.  Inilah yang terjadi: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  Objek memiliki struktur hierarkis (ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> ), sehingga dapat ditampilkan sebagai grafik pohon, atau dendrogram.  Hasilnya mirip dengan silsilah keluarga.  Semakin dekat dua nilai pada pohon, semakin banyak kesamaan atau semakin erat hubungannya. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Program sederhana yang dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R-Fiddle.org</a></i> <br><br>  Struktur dendrogram memungkinkan Anda untuk memahami struktur dataset itu sendiri.  Dalam contoh kami, kami mendapat dua cabang utama - satu dengan humpback dan finwal, yang lain dengan lumba-lumba hidung botol / lumba-lumba abu-abu dan paus giling / pembunuh. <br><br>  Dalam biologi evolusi, kumpulan data yang jauh lebih besar dengan banyak spesies dan banyak karakter digunakan untuk mengidentifikasi hubungan taksonomi.  Di luar biologi, pengelompokan hierarkis diterapkan di bidang Penambangan Data dan pembelajaran mesin. <br><br>  Pendekatan ini tidak memerlukan prediksi jumlah cluster yang diperlukan.  Anda dapat membagi dendrogram yang dihasilkan menjadi kelompok-kelompok, â€œmemotongâ€ pohon pada ketinggian yang diinginkan.  Anda dapat memilih ketinggian dengan berbagai cara, tergantung pada resolusi pengelompokan data yang diinginkan. <br>  Misalnya, jika dendrogram di atas terputus pada ketinggian 10, maka kita akan memotong dua cabang utama, sehingga membagi dendrogram menjadi dua kolom.  Jika dipotong pada ketinggian 2, maka bagilah dendrogram menjadi tiga kelompok. <br><br>  Algoritma pengelompokan hierarkis lainnya mungkin berbeda dalam tiga aspek dari yang dijelaskan dalam artikel ini. <br><br>  Yang paling penting adalah pendekatannya.  Di sini kami menggunakan metode <b>aglomerasi</b> : kami mulai dengan nilai-nilai individual dan mengelompokkannya secara siklis hingga kami mendapatkan satu kelompok besar.  Pendekatan alternatif (dan lebih kompleks secara komputasional) menyiratkan urutan terbalik: pertama satu cluster besar dibuat, dan kemudian secara berurutan dibagi menjadi kelompok yang lebih kecil sampai nilai-nilai terpisah tetap. <br><br>  Ada juga beberapa metode untuk menghitung matriks jarak.  Metrik Euclidean cukup untuk sebagian besar tugas, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metrik lainnya</a> lebih cocok dalam beberapa situasi. <br><br>  Akhirnya, kriteria keterkaitan dapat bervariasi.  Hubungan antara cluster tergantung pada kedekatan mereka satu sama lain, tetapi definisi "kedekatan" bisa berbeda.  Dalam contoh kami, kami mengukur jarak antara nilai rata-rata (atau "centroid") dari masing-masing kelompok dan menggabungkan kelompok terdekat berpasangan.  Tetapi Anda dapat menggunakan definisi lain. <br><br>  Misalkan setiap cluster terdiri dari beberapa nilai diskrit.  Jarak antara dua cluster dapat didefinisikan sebagai jarak minimum (atau maksimum) antara salah satu nilainya, seperti yang ditunjukkan di bawah ini.  Untuk konteks yang berbeda, akan lebih mudah untuk menggunakan definisi kriteria join yang berbeda. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Merah / biru: kolam centroid;</i>  <i>merah / hijau: menggabungkan berdasarkan minima;</i>  <i>hijau / biru: penggabungan berdasarkan tertinggi.</i> <br><br><h2>  Definisi komunitas dalam grafik (Grafik Deteksi Komunitas) </h2><br><h5>  Digunakan oleh: </h5><br>  Ketika data Anda dapat disajikan dalam bentuk jaringan, atau "grafik". <br><br><h5>  Cara kerjanya: </h5><br>  <b>Komunitas dalam grafik</b> dapat secara kasar didefinisikan sebagai subset dari simpul yang lebih terhubung satu sama lain daripada ke seluruh jaringan.  Ada berbagai algoritma definisi komunitas berdasarkan definisi yang lebih spesifik, seperti Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Contoh kerja: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori grafik</a> adalah cabang matematika yang sangat menarik yang memungkinkan kita untuk memodelkan sistem yang kompleks dalam bentuk set abstrak "titik" (simpul, simpul) yang dihubungkan oleh "garis" (tepi). <br><br>  Mungkin aplikasi pertama dari grafik yang muncul di pikiran adalah studi tentang jejaring sosial.  Dalam hal ini, puncak mewakili orang-orang yang terhubung dengan tulang rusuk ke teman / pelanggan.  Tetapi Anda dapat membayangkan sistem apa pun dalam bentuk jaringan jika Anda dapat membenarkan metode koneksi komponen yang bermakna.  Aplikasi inovatif pengelompokan menggunakan teori grafik termasuk mengekstraksi properti dari data visual dan menganalisis jaringan regulasi genetik. <br><br>  Sebagai contoh sederhana, mari kita lihat grafik di bawah ini.  Ini menunjukkan delapan situs yang paling sering saya kunjungi.  Tautan di antara mereka didasarkan pada tautan dalam artikel Wikipedia.  Data semacam itu dapat dikumpulkan secara manual, tetapi untuk proyek besar jauh lebih cepat untuk menulis skrip Python.  Misalnya, ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>Grafik dibuat menggunakan paket igraph untuk R 3.3.3</i> <br><br>  Warna puncak tergantung pada partisipasi dalam masyarakat, dan ukurannya tergantung pada sentralitas.  Harap dicatat bahwa yang paling utama adalah Google dan Twitter. <br><br>  Juga, cluster yang dihasilkan sangat akurat mencerminkan tugas nyata (ini selalu merupakan indikator kinerja yang penting).  Vertikal yang mewakili situs tautan / pencarian disorot dengan warna kuning;  situs yang disorot biru untuk publikasi online (artikel, tweet, atau kode);  yang disorot dengan warna merah adalah PayPal dan YouTube, yang didirikan oleh mantan karyawan PayPal.  Pengurangan yang bagus untuk komputer! <br><br>  Selain memvisualisasikan sistem besar, kekuatan sebenarnya dari jaringan terletak pada analisis matematika.  Mari kita mulai dengan mengubah gambar jaringan menjadi format matematika.  Berikut <b>ini adalah</b> matriks <b>kedekatan</b> dari jaringan. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Nilai-nilai di persimpangan kolom dan baris menunjukkan apakah ada tepi antara pasangan simpul ini.  Misalnya, antara Medium dan Twitter, maka, di persimpangan baris dan kolom ini berdiri 1. Dan antara Medium dan PayPal tidak ada tepi, jadi di sel yang sesuai ada 0. <br><br>  Jika kami mewakili semua properti jaringan dalam bentuk matriks adjacency, ini akan memungkinkan kami untuk menarik semua jenis kesimpulan yang berguna.  Misalnya, jumlah nilai dalam kolom atau baris apa pun mencirikan <b>tingkat</b> setiap titik - yaitu, jumlah objek yang terhubung ke titik ini.  Biasanya ditunjukkan dengan huruf <i>k</i> . <br><br>  Jika kita menjumlahkan derajat semua simpul dan membaginya menjadi dua, kita mendapatkan L - jumlah tepi dalam jaringan.  Dan jumlah baris dan kolom sama dengan N - jumlah simpul dalam jaringan. <br><br>  Mengetahui hanya k, L, N dan nilai-nilai dalam semua sel dari matriks adjacency A, kita dapat menghitung modularitas dari setiap pengelompokan. <br><br>  Misalkan kita telah mengelompokkan jaringan ke sejumlah komunitas.  Kemudian Anda dapat menggunakan nilai modularitas untuk memprediksi "kualitas" pengelompokan.  Modularitas yang lebih tinggi menunjukkan bahwa kami membagi jaringan menjadi komunitas "tepat", dan modularitas yang lebih rendah menunjukkan bahwa cluster dibentuk lebih secara kebetulan daripada secara wajar.  Untuk membuatnya lebih jelas: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  Modularitas berfungsi sebagai tolok ukur â€œkualitasâ€ kelompok. <br><br>  Modularitas dapat dihitung menggunakan rumus berikut: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Mari kita lihat formula yang tampak luar biasa ini. <br><br>  <b>M</b> , seperti yang Anda tahu, ini adalah modularitas. <br><br>  Koefisien <b>1 / 2L</b> berarti bahwa kita membagi sisa "tubuh" rumus dengan 2L, yaitu, dengan jumlah ganda sisi dalam jaringan.  Dengan Python, orang bisa menulis: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  Apa itu <code>#stuff with i and j</code> ?  Bit dalam tanda kurung memberitahu kita untuk mengurangi (k_i k_j) / 2L dari A_ij, di mana A_ij adalah nilai dalam matriks di persimpangan baris i dan kolom j. <br><br>  Nilai k_i dan k_j adalah derajat masing-masing simpul.  Mereka dapat ditemukan dengan menjumlahkan nilai dalam baris i dan kolom j, masing-masing.  Jika kita mengalikannya dan membaginya dengan 2L, maka kita mendapatkan jumlah tepi yang diharapkan antara simpul i dan j jika jaringan dicampur secara acak. <br><br>  Isi kurung mencerminkan perbedaan antara struktur aktual jaringan dan yang diharapkan jika jaringan dibangun kembali secara acak.  Jika Anda bermain-main dengan nilai-nilai, maka modularitas tertinggi akan berada di A_ij = 1 dan rendah (k_i k_j) / 2L.  Yaitu, modularitas meningkat jika ada tepi â€œtak terdugaâ€ antara simpul i dan j. <br><br>  Akhirnya, kita mengalikan isi tanda kurung dengan apa yang ditunjukkan dalam rumus sebagai Î´c_i, c_j.  Ini adalah fungsi Kronecker-delta.  Berikut ini implementasinya dalam Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Ya, sangat sederhana.  Fungsi ini mengambil dua argumen, dan jika keduanya identik, ia mengembalikan 1, dan jika tidak, maka 0. <br><br>  Dengan kata lain, jika simpul i dan j jatuh ke satu cluster, maka Î´c_i, c_j = 1. Dan jika mereka berada di cluster yang berbeda, fungsi akan mengembalikan 0. <br><br>  Karena kita mengalikan isi tanda kurung dengan simbol Kronecker, hasil dari jumlah yang diinvestasikan <b>Î£</b> akan menjadi yang tertinggi ketika simpul di dalam satu kluster dihubungkan oleh sejumlah besar tepi "tak terduga".  Dengan demikian, modularitas adalah indikator seberapa baik grafik dikelompokkan ke dalam komunitas individu. <br><br>  Division by 2L membatasi modularitas atas menjadi satu.  Jika modularitas mendekati 0 atau negatif, ini berarti bahwa pengelompokan jaringan saat ini tidak masuk akal.  Dengan meningkatkan modularitas, kita dapat menemukan cara yang lebih baik untuk mengelompokkan jaringan. <br><br>  Harap perhatikan bahwa untuk mengevaluasi "kualitas" pengelompokan grafik, kita harus menentukan terlebih dahulu bagaimana pengelompokannya.  Sayangnya, kecuali sampelnya sangat kecil, karena kompleksitas komputasinya, secara fisik tidak mungkin untuk dengan bodohnya melewati semua metode pengelompokan grafik dengan membandingkan modularitasnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Combinatorics</a> menunjukkan bahwa untuk jaringan dengan 8 simpul, ada 4.140 metode pengelompokan.  Untuk jaringan dengan 16 simpul, sudah ada lebih dari 10 miliar cara, untuk jaringan dengan 32 simpul - 128 septillion, dan untuk jaringan dengan 80 simpul jumlah metode pengelompokan akan melebihi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jumlah atom di alam semesta yang dapat diamati</a> . <br><br>  Oleh karena itu, alih-alih pencacahan, kami akan menggunakan metode heuristik, yang akan membantu menghitung cluster dengan relatif mudah dengan modularitas maksimum.  Ini adalah suatu algoritma yang disebut <i>Fast-Greedy Modularity-Maximization</i> , semacam analog dengan algoritma pengelompokan hierarkis aglomeratif yang dijelaskan di atas.  Alih-alih menggabungkan berdasarkan kedekatan, Mod-Max menyatukan komunitas tergantung pada perubahan modularitas.  Cara kerjanya: <br><br>  <b>Pertama,</b> setiap simpul ditugaskan ke komunitasnya sendiri dan modularitas seluruh jaringan dihitung - M. <br><br>  <b>Langkah 1</b> : untuk setiap pasangan komunitas yang terhubung oleh setidaknya satu sisi, algoritma menghitung perubahan yang dihasilkan dalam modularitas Î”M dalam hal menggabungkan pasangan komunitas ini. <br><br>  <b>Langkah 2</b> : lalu pasangan diambil, saat dikombinasikan, Î”M akan maksimal, dan dikombinasikan.  Untuk pengelompokan ini, modularitas baru dihitung dan disimpan. <br><br>  Langkah 1 dan 2 <b>diulang</b> : setiap kali sepasang komunitas bergabung, yang memberikan Î”M terbesar, skema pengelompokan baru dan M. <br><br>  Iterasi <b>berhenti</b> ketika semua simpul dikelompokkan menjadi satu kelompok besar.  Sekarang algoritma memeriksa catatan yang disimpan dan menemukan skema pengelompokan dengan modularitas tertinggi.  Dialah yang kembali sebagai struktur komunitas. <br><br>  Secara komputasi itu sulit, setidaknya untuk manusia.  Teori grafik adalah sumber yang kaya akan masalah komputasi yang sulit dan masalah NP-hard.  Dengan menggunakan grafik, kita dapat menarik banyak kesimpulan yang berguna tentang sistem dan dataset yang kompleks.  Tanyakan Larry Page, yang algoritme PageRanknya - yang membantu Google mengubah dari permulaan menjadi dominan global dalam waktu kurang dari satu generasi - seluruhnya didasarkan pada teori grafik. <br><br>  Studi tentang teori grafik saat ini fokus pada identifikasi komunitas.  Ada banyak alternatif untuk algoritma Modularity-Maximization, yang, meskipun bermanfaat, bukan tanpa kekurangannya. <br><br>  Pertama, dengan pendekatan aglomerasi, komunitas kecil dan terdefinisi dengan baik sering digabungkan menjadi komunitas yang lebih besar.  Ini disebut batas resolusi - algoritma tidak mengalokasikan komunitas yang lebih kecil dari ukuran tertentu.  Kelemahan lain adalah bahwa alih-alih satu puncak global yang diucapkan dan mudah dicapai, algoritma Mod-Max berupaya menghasilkan "dataran tinggi" yang luas dari banyak nilai modularitas yang dekat.  Akibatnya, sulit untuk menentukan pemenang. <br><br>  Algoritme lain menggunakan metode yang berbeda untuk mendefinisikan komunitas.  Sebagai contoh, Edge-Betweenness adalah algoritma yang memecah (memecah) yang dimulai dengan mengelompokkan semua simpul menjadi satu kelompok besar.  Kemudian ujung-ujung "paling penting" dihilangkan secara iteratif sampai semua simpul diisolasi.  Hasilnya adalah struktur hierarkis di mana simpul lebih dekat satu sama lain, semakin mirip. <br><br>  Algoritma, Clique Percolation, memperhitungkan kemungkinan persimpangan antara komunitas.  Ada sekelompok algoritma berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">random walk</a> pada grafik, dan ada metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengelompokan spektral</a> yang berhubungan dengan dekomposisi spektral (eigendecomposition) dari matriks adjacency dan matriks lain yang diturunkan darinya.  Semua ide ini digunakan untuk menyorot fitur, misalnya, dalam visi mesin. <br><br>  Kami tidak akan menganalisis contoh kerja untuk setiap algoritma secara detail.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cukuplah untuk mengatakan bahwa penelitian aktif saat ini sedang dilakukan dalam arah ini dan teknik analisis data yang kuat sedang dibuat, yang sangat sulit untuk dihitung 20 tahun yang lalu. </font></font><br><br><h2>  Kesimpulan </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   â€”    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413269/">https://habr.com/ru/post/id413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413253/index.html">Richard Hamming: Bab 21. Serat Optik</a></li>
<li><a href="../id413255/index.html">Richard Hamming: Bab 27. Data Tidak Valid</a></li>
<li><a href="../id413261/index.html">Cara kerja pencarian</a></li>
<li><a href="../id413265/index.html">Ke pemandian dengan IT</a></li>
<li><a href="../id413267/index.html">10 kualitas yang harus dimiliki untuk diperhatikan bagi seorang manajer produk pemula</a></li>
<li><a href="../id413271/index.html">Tanpa kata sandi: cara kerja sistem otentikasi pada registri terdistribusi</a></li>
<li><a href="../id413273/index.html">Manajemen persyaratan produk TI dalam perusahaan</a></li>
<li><a href="../id413275/index.html">Pengujian komparatif dari pemanggang untuk mencapai hasil yang paling lezat</a></li>
<li><a href="../id413277/index.html">JSFiddle - versi baru</a></li>
<li><a href="../id413279/index.html">Aplikasi seluler menghitung konten kalori dari hidangan di restoran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>