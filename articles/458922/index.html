<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 👌🏿 🗾 Cómo pasar de ESXi a KVM / LXD y no perder la cabeza ♐️ 🏰 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante mucho tiempo, la compañía Maxnet Systems usó la versión gratuita de VMware - ESXi, comenzando con la versión 5.0, como hipervisor. La versión ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo pasar de ESXi a KVM / LXD y no perder la cabeza</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/458922/">  Durante mucho tiempo, la compañía Maxnet Systems usó la versión gratuita de VMware - ESXi, comenzando con la versión 5.0, como hipervisor.  La versión paga de vSphere ahuyentaba el modelo de licencia, mientras que la versión gratuita tenía una serie de inconvenientes que no estaban disponibles en la versión paga, pero podía soportarlos.  Pero cuando en las nuevas versiones de ESXi la nueva interfaz web se negó a funcionar con la anterior, y el monitoreo de los conjuntos RAID dejó de mostrar signos de vida, la compañía decidió buscar una solución más universal y abierta.  La compañía ya tenía una buena experiencia y una buena impresión de LXC - Contenedores Linux.  Por lo tanto, se hizo evidente que el hipervisor soñado será híbrido y combinará KVM y LXD para diferentes cargas, una continuación evolutiva de LXC.  Al buscar información sobre KVM, la empresa se enfrentó a conceptos erróneos, rastrillos y prácticas nocivas, pero las pruebas y el tiempo pusieron todo en su lugar. <br><br><img src="https://habrastorage.org/webt/s-/vc/6s/s-vc6shq5cfia5bjjcuhixbgukq.jpeg"><br><br>  Sobre cómo lidiar con el cambio de ESXi a KVM y no conducir una rueda en un rastrillo, le dirá a <strong>Lev Nikolaev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">maniaco</a> ), administrador y desarrollador de sistemas altamente cargados, entrenador de tecnología de la información.  Hablemos de la red, repositorios, contenedores, KVM, LXD, LXC, aprovisionamiento y máquinas virtuales convenientes. <br><a name="habracut"></a><br><h2>  Prologo </h2><br>  Identificaremos inmediatamente los pensamientos clave, y luego los analizaremos con más detalle. <br><br>  <strong>Red.</strong>  Si bien las velocidades de sus interfaces no superan los 1 Gb / s, el puente es suficiente para usted.  Tan pronto como quieras exprimir más, te limitará. <br><br>  <strong>Repositorio.</strong>  Crea un almacenamiento de red compartido.  Incluso si no está listo para usar 10 Gbit / s dentro de la red, incluso 1 Gbit / s le dará 125 MB / s de almacenamiento.  Para una serie de cargas, esto será suficiente con un margen, y la migración de máquinas virtuales será una cuestión elemental. <br><br>  <strong>Contenedor o KVM?</strong>  Pros, contras, trampas.  ¿Qué tipos de cargas se colocan mejor en un contenedor y cuáles se dejan mejor en un KVM? <br><br>  <strong>LXD o LXC</strong> .  Es LXD LXC?  U otra versión?  O un complemento?  ¿De qué se trata todo esto?  Disipemos los mitos y comprendamos las diferencias entre LXD y LXC. <br><br>  <strong>Aprovisionamiento conveniente</strong> .  ¿Qué es más conveniente: tomar la misma imagen o instalar el sistema desde cero siempre?  ¿Cómo hacerlo de forma rápida y precisa cada vez? <br><br>  <strong>Conveniente máquina virtual.</strong>  Habrá historias de miedo sobre cargadores de arranque, particiones, LVM. <br><br>  <strong>Varios</strong>  Muchas preguntas pequeñas: ¿cómo arrastrar rápidamente una máquina virtual de ESXi a KVM, cómo migrar bien, cómo virtualizar discos correctamente? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HqsxBkxGxqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Motivo de la reubicación </h2><br>  ¿De dónde surgió la loca idea de pasar de ESXi a KVM / LXD?  ESXi es popular entre las pequeñas y medianas empresas.  Este es un hipervisor bueno y barato.  Pero hay matices. <br><br>  Comenzamos con la versión 5.0, convenientemente, ¡todo funciona!  La próxima versión 5.5 es la misma. <br><br>  Desde la versión 6.0 ya es más difícil.  En ESXi, la interfaz web no quedó inmediatamente libre, solo a partir de la versión 6.5, antes de que se requiriera una utilidad para Windows.  Soportamos esto.  Quien ejecuta OS X compra Parallels e instala esta utilidad.  Este es un dolor bien conocido. <br><br>  Monitoreo periódicamente flasheado.  Era necesario reiniciar los servicios de administración en la consola del servidor, luego CIM Heartbeat apareció nuevamente.  Soportamos, ya que no siempre se cayó. <br><br>  Versión ESXi 6.5: basura, desperdicios y atrocidades.  Horrible hipervisor.  Y aquí está el por qué. <br><br><ul><li>  <strong>Angular se cae con una excepción en la entrada a la interfaz web.</strong>  Tan pronto como ingrese su nombre de usuario y contraseña, ¡inmediatamente una excepción! </li><li>  <strong>La capacidad de controlar de forma remota el estado de la matriz RAID no funciona,</strong> ya que es conveniente para nosotros.  Solía ​​ser conveniente, pero en la versión 6.5, todo está mal. </li><li>  <strong>Soporte débil para las tarjetas de red modernas de Intel</strong> .  Las tarjetas de red de Intel y ESXi causan dolor.  Hay un hilo de agonía en el foro de soporte de ESXi sobre esto.  VMware e Intel no son amigos y las relaciones no mejorarán en el futuro cercano.  Lo triste es que incluso los clientes de soluciones pagas experimentan problemas. </li><li>  <strong>No hay migración dentro de ESXi</strong> .  A menos que la migración se considere una pausa, copie y comience el procedimiento.  Ponemos el auto en pausa, lo copiamos rápidamente y lo arrancamos en otro lugar.  Pero es imposible llamarlo migración, todavía hay uno simple. </li></ul><br>  Después de ver todo esto, se nos ocurrió la loca idea de movernos con ESXi 6.5. <br><br><h2>  Lista de deseos </h2><br>  Para empezar, escribimos una lista de deseos para un futuro ideal al que vamos. <br><br>  <strong>Gestión desde debajo de SSH</strong> , y web y más opcional.  La interfaz web es excelente, pero en un viaje de negocios desde un iPhone, entrar en la interfaz web de ESXi y hacer algo allí es inconveniente y difícil.  Por lo tanto, la única forma de administrar todo es SSH, no habrá otra. <br><br>  <strong>Virtualización de Windows.</strong>  A veces los clientes piden cosas extrañas, y nuestra misión es ayudarlos. <br><br>  <strong>Siempre controladores nuevos y la capacidad de configurar una tarjeta de red</strong> .  Deseo adecuado, pero no realizado bajo ESXi puro. <br><br>  <strong>Migración en vivo, no agrupamiento</strong> .  Queremos la capacidad de arrastrar máquinas de un hipervisor a otro sin sentir ningún retraso, tiempo de inactividad o inconvenientes. <br><br>  La lista de deseos está lista, luego ha comenzado una búsqueda difícil. <br><br><h2>  Harina de elección </h2><br>  El mercado gira en torno a KVM o LXC con diferentes salsas.  A veces parece que Kubernetes está en algún lugar arriba, donde todo está bien, el sol y el paraíso, y en el nivel inferior hay Morlocks: KVM, Xen o algo así ... <br><br>  Por ejemplo, Proxmox VE es Debian, que fue extraído por el núcleo de Ubuntu.  Se ve raro, pero ¿lo trae a producción? <br><br>  Nuestros vecinos abajo son Alt Linux.  Se les ocurrió una solución hermosa: crearon Proxmox VE como un paquete.  Simplemente ponen el paquete en un comando.  Esto es conveniente, pero no incluimos Alt Linux en producción, por lo que no nos convenía. <br><br><h3>  Tomar KVM </h3><br>  Al final, elegimos KVM.  No lo tomaron, Xen, por ejemplo, debido a la comunidad: KVM tiene mucho más.  Parecía que siempre encontraríamos la respuesta a nuestra pregunta.  Más tarde descubrimos que el tamaño de una comunidad no afecta su calidad. <br><br>  Inicialmente, calculamos que tomaríamos una máquina Bare Metal, agregaríamos el Ubuntu con el que estamos trabajando y rodaríamos KVM / LXD desde arriba.  Contamos con la capacidad de ejecutar contenedores.  Ubuntu es un sistema bien conocido y no hay sorpresas en términos de resolver problemas de arranque / recuperación para nosotros.  Sabemos dónde patear si el hipervisor no se inicia.  Todo es claro y conveniente para nosotros. <br><br><h2>  Curso intensivo de KVM </h2><br>  Si eres del mundo de ESXi, encontrarás muchas cosas interesantes.  Aprende tres palabras: QEMU, KVM y libvirt. <br><br>  <strong>QEMU</strong> traduce los deseos de un SO virtualizado en los desafíos de un proceso regular.  Funciona muy bien en casi todas partes, pero lentamente.  QEMU es un producto independiente que virtualiza muchos otros dispositivos. <br><br>  Más adelante en la escena viene un montón de <strong>QEMU-KVM</strong> .  Este es el módulo del kernel de Linux para QEMU.  La virtualización de todas las instrucciones es costosa, por lo que tenemos un módulo de kernel KVM que <strong>traduce solo unas pocas instrucciones</strong> .  Como resultado, esto es significativamente más rápido, ya que solo se procesa un pequeño porcentaje de las instrucciones del conjunto general.  Estos son todos los costos de virtualización. <br><br>  Si solo tiene QEMU, el inicio de la máquina virtual sin enlace se ve así: <br><br><pre><code class="plaintext hljs">$ qemu &lt; &gt;</code> </pre> <br>  En los parámetros que describe la red, bloquee los dispositivos.  Todo es maravilloso, pero inconveniente.  Por lo tanto hay libvirt. <br><br>  <strong>El objetivo de libvirt es ser una herramienta única para todos los hipervisores</strong> .  Puede funcionar con cualquier cosa: con KVM, con LXD.  Parece que solo queda aprender la sintaxis de libvirt, pero en realidad funciona peor que en teoría. <br><br>  Estas tres palabras son todo lo que se necesita para generar la primera máquina virtual en KVM.  Pero de nuevo, hay matices ... <br><br>  Libvirt tiene una configuración donde se almacenan máquinas virtuales y otras configuraciones.  Almacena la configuración en archivos xml: elegantes, modernos y directamente de los años 90.  Si lo desea, se pueden editar a mano, pero por qué, si hay comandos convenientes.  También es conveniente que los cambios en los archivos xml estén maravillosamente versionados.  Usamos <strong>etckeeper</strong> - versión del directorio, etc.  Ya es posible usar etckeeper y ya es hora. <br><br><h2>  Curso intensivo de LXC </h2><br>  Hay muchos conceptos erróneos sobre LXC y LXD. <br><br><blockquote>  LXC es la capacidad del núcleo moderno de usar espacios de nombres, para pretender que no es en absoluto el núcleo original. </blockquote><br>  Puede crear estos espacios de nombres tantos como desee para cada contenedor.  Formalmente, el núcleo es uno, pero se comporta como muchos núcleos idénticos.  LXC le permite ejecutar contenedores, pero solo proporciona herramientas básicas. <br><br>  Canonical, que está detrás de Ubuntu y avanza agresivamente los contenedores, ha lanzado <strong>LXD, un análogo de libvirt</strong> .  Este es un enlace que facilita la ejecución de contenedores, pero en su interior sigue siendo LXC. <br><br><blockquote>  LXD es un hipervisor de contenedor basado en LXC. </blockquote><br>  Enterprise reina en LXD.  LXD almacena la configuración en su base de datos, en el directorio <code>/var/lib/lxd</code> .  Allí, LXD lleva su configuración a la configuración en SQlite.  Copiarlo no tiene sentido, pero puede escribir los comandos que utilizó para crear la configuración del contenedor. <br><br>  No hay descarga como tal, pero la mayoría de los cambios son automatizados por equipos.  Este es un análogo del archivo Docker, solo con control manual. <br><br><h2>  Producción </h2><br>  A lo que nos enfrentamos cuando todos navegamos en funcionamiento. <br><br><h3>  Red </h3><br>  ¡Cuánta basura y alboroto infernales en Internet sobre la red en KVM!  El 90% de los materiales dicen usar puente. <br><br><blockquote>  ¡Deja de usar el puente! </blockquote><br>  ¿Qué le pasa a él?  Últimamente, tengo la sensación de que la locura está sucediendo con los contenedores: coloque Docker encima de Docker para que pueda ejecutar Docker en Docker mientras mira Docker.  La mayoría no entiende lo que está haciendo el puente. <br><br>  Pone su controlador de red en <strong>modo promiscuo</strong> y recibe todo el tráfico porque no sabe cuál y cuál no.  Como resultado, todo el tráfico del puente pasa a través de una maravillosa y rápida pila Linux de red, y hay muchas copias.  Al final, todo es lento y malo.  Por lo tanto, no use bridge en producción. <br><br><h3>  SR-IOV </h3><br>  <strong>SR-IOV es la capacidad de virtualizar dentro de una tarjeta de red</strong> .  La tarjeta de red en sí misma puede asignar parte de sí misma para máquinas virtuales, lo que requiere cierto soporte de hardware.  Esto es lo que evitará la migración.  Migrar una máquina virtual donde falta SR-IOV es doloroso. <br><br>  SR-IOV debe usarse donde todos los hipervisores lo admitan como parte de la migración.  Si no, entonces macvtap es para ti. <br><br><h3>  macvtap </h3><br>  Esto es para aquellos cuya tarjeta de red no es compatible con SR-IOV.  Esta es la versión ligera del puente: se cuelgan diferentes direcciones MAC en una tarjeta de red, y <strong>se utiliza el filtrado de unidifusión</strong> : la tarjeta de red no acepta todo, pero estrictamente de acuerdo con la lista de direcciones MAC. <br><br>  Se pueden encontrar más detalles sangrientos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> gran charla de Toshiaki Makita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, Virtual Switching Technologies y Linux Bridge</a> .  Está lleno de dolor y sufrimiento. <br><br><blockquote>  El 90% de los materiales sobre cómo construir una red en KVM son inútiles. </blockquote><br>  Si alguien dice que el puente es increíble, no hables más con esa persona. <br><br>  Con macvtap, la <strong>CPU ahorra alrededor del 30%</strong> debido a menos copias.  Pero el modo promiscuo tiene sus propios matices.  No puede conectarse a la interfaz de red de la máquina invitada desde el propio hipervisor, desde el host.  Un informe de Toshiaki detalla esto.  Pero en resumen, no funcionará. <br><br>  Desde el propio hipervisor rara vez se pasa a SSH.  Es más conveniente iniciar una consola allí, por ejemplo, una consola Win.  Es posible "ver" el tráfico en la interfaz: no puede conectarse a través de TCP, pero el tráfico en el hipervisor es visible. <br><br><blockquote>  Si sus velocidades son superiores a 1 Gigabit, elija macvtap. </blockquote><br>  A velocidades de interfaz de hasta 1 Gigabit por segundo, el puente también se puede utilizar.  Pero si tiene una tarjeta de red de 10 Gb y desea deshacerse de ella de alguna manera, solo queda macvtap.  No hay otras opciones.  Excepto SR-IOV. <br><br><h3>  systemd-networkd </h3><br>  <strong>Esta es una excelente manera de almacenar la configuración de red en el propio hipervisor</strong> .  En nuestro caso, esto es Ubuntu, pero para otros sistemas, systemd funciona. <br><br>  Solíamos tener un archivo <code>/etc/network/interfaces</code> en el que todos guardamos.  Un archivo es incómodo de editar cada vez: systemd-networkd le permite dividir la configuración en una dispersión de archivos pequeños.  Esto es conveniente porque funciona con cualquier sistema de versiones: se envió a Git y verá cuándo y qué cambio sucedió. <br><br>  Hay una falla que descubrieron nuestros networkers.  Cuando necesita agregar una nueva VLAN en el hipervisor, voy y configuro.  Luego digo: "systemctl restart systemd-networkd".  En este momento, todo está bien conmigo, pero si las sesiones de BGP de esta máquina se generan, se rompen.  Nuestros networkers no aprueban esto. <br><br>  Para el hipervisor, no pasa nada malo.  Systemd-networkd no es adecuado para usuarios fronterizos, servidores con BGP elevado y para hipervisores: excelente. <br><br>  Systemd-networkd está lejos de ser final y nunca se completará.  Pero esto es más conveniente que editar un archivo enorme.  Una alternativa a systemd-networkd en Ubuntu 18.04 es Netplan.  Esta es una forma "genial" de configurar la red y pisar el rastrillo. <br><br><h3>  Dispositivo de red </h3><br>  Después de instalar KVM y LXD en el hipervisor, lo primero que verá son dos puentes.  Uno hizo KVM para sí mismo, y el segundo, LXD. <br><br><blockquote>  LXD y KVM están intentando desplegar su red. </blockquote><br>  Si todavía necesita un puente, para máquinas de prueba o para jugar, elimine el puente, que está activado de forma predeterminada y cree el suyo, el que desee.  KVM o LXD lo hacen terriblemente: desliza dnsmasq y comienza el horror. <br><br><h3>  Almacenamiento </h3><br><blockquote>  No importa qué implementaciones te gusten: usa el almacenamiento compartido. </blockquote><br>  Por ejemplo, iSCSI para máquinas virtuales.  No podrá deshacerse del "punto de falla", pero puede <strong>consolidar el almacenamiento en un punto</strong> .  Esto abre nuevas oportunidades interesantes. <br><br>  Para hacer esto, debe tener al menos 10 Gb / s de interfaces dentro del centro de datos.  Pero incluso si solo tiene 1 Gbit / s, no se preocupe.  Esto es aproximadamente 125 MB / s, bastante bueno para los hipervisores que no requieren una gran carga de disco. <br><br>  KVM puede migrar y arrastrar el almacenamiento.  Pero, por ejemplo, en el modo de carga de trabajo, transferir una máquina virtual a un par de terabytes es una molestia.  Para la migración con un almacenamiento común, solo RAM es suficiente, que es elemental.  Esto <strong>reduce el tiempo de migración</strong> . <br><br><h3>  Al final, ¿LXD o KVM? </h3><br>  Inicialmente, asumimos que para todas las máquinas virtuales donde el núcleo coincide con el sistema host, tomaremos LXD.  Y donde necesitamos tomar otro núcleo: tomar KVM. <br><br>  En realidad, los planes no despegaron.  Para entender por qué, eche un vistazo más de cerca a LXD. <br><br><h3>  Lxd </h3><br>  La ventaja principal es ahorrar memoria en el núcleo.  El núcleo es el mismo y cuando lanzamos nuevos contenedores el núcleo es el mismo.  En esto, los pros terminaron y comenzaron los contras. <br><br>  <strong>El dispositivo de bloque con rootfs debe estar montado.</strong>  Es más difícil de lo que parece. <br><br>  <strong>Realmente no hay migración</strong> .  Lo es, y se basa en el maravilloso instrumento sombrío que vieron nuestros compatriotas.  Estoy orgulloso de ellos, pero en casos simples criu no funciona. <br><br>  <strong>zabbix-agent se comporta de forma extraña en un contenedor</strong> .  Si lo ejecuta dentro del contenedor, verá una serie de datos del sistema host y no del contenedor.  Hasta ahora no se puede hacer nada. <br><br>  <strong>Al mirar la lista de procesos en el hipervisor, es imposible entender rápidamente de qué contenedor está creciendo un proceso en particular</strong> .  Lleva tiempo descubrir qué espacio de nombres hay, qué y dónde.  Si la carga en algún lugar saltó más de lo habitual, rápidamente no lo entiendo.  Este es el principal problema: la limitación en las capacidades de respuesta.  Se realiza una mini investigación para cada caso. <br><br><blockquote>  La única ventaja de LXD es ahorrar memoria central y reducir la sobrecarga. </blockquote><br>  Pero Kernel Shared Memory en KVM ya ahorra memoria. <br><br>  Hasta ahora no veo ninguna razón para presentar una producción seria y LXD.  A pesar de los mejores esfuerzos de Canonical en esta área, la producción de LXD trae más problemas que soluciones.  En un futuro cercano, la situación no cambiará. <br><br>  Pero, no se puede decir que LXD es malo.  Es bueno, pero en casos limitados, de lo que hablaré más adelante. <br><br><h3>  Criu </h3><br>  Criu es una utilidad sombría. <br><br>  Cree un contenedor vacío, llegará con un cliente DHCP y le dirá: "¡Suspenda!"  Obtenga el error porque hay un cliente DHCP: “¡Horror, horror!  Abre el zócalo con el letrero "crudo", ¡qué pesadilla! "  Peor en ninguna parte. <br><br><blockquote>  Impresiones de contenedores: sin migración, Criu funciona en cualquier otro momento. </blockquote><br>  Me gusta la recomendación del equipo de LXD sobre qué hacer con Criu para que no haya problemas: <br><br>  - ¡ <em>Toma una versión más fresca del repositorio!</em> <br><br>  ¿Y de alguna manera puedo ponerlo desde el paquete para que no se ejecute en el repositorio? <br><br><h3>  Conclusiones </h3><br>  <strong>LXD es maravilloso si desea crear una infraestructura de CI / CD.</strong>  Tomamos LVM - Logical Volume Manager, tomamos una instantánea de él e iniciamos el contenedor en él.  ¡Todo funciona muy bien!  En un segundo, se crea un nuevo contenedor limpio, que está configurado para probar y hacer rodar al chef; lo usamos activamente. <br><br>  <strong>LXD es débil para una producción seria</strong> .  No podemos saber qué hacer con LXD en producción si no funciona bien. <br><br>  <strong>¡Elija KVM y solo KVM!</strong> <br><br><h3>  La migracion </h3><br>  Diré esto brevemente.  Para nosotros, la migración resultó ser un maravilloso mundo nuevo que nos gusta.  Allí todo es simple: hay un equipo para la migración y dos opciones importantes: <br><br><pre> <code class="plaintext hljs">virsh migrate &lt;vm&gt; qemu+ssh://&lt;hypervisor&gt;/system --undefinesource -persistent</code> </pre> <br>  Si escribe "Migración KVM" en Google y abre el primer material, verá un comando para la migración, pero sin las dos últimas teclas.  No verá una mención de que son importantes: "¡Simplemente ejecute este comando!"  Ejecute el comando, y realmente migra, pero ¿cómo? <br><br>  Importantes opciones de migración. <br><br>  <strong>undefinesource: elimina la máquina virtual del hipervisor desde el que estamos migrando.</strong>  Si reinicia después de dicha migración, el hipervisor que dejó reiniciará esta máquina.  Te sorprenderás, pero esto es normal. <br><br>  <strong>Sin el segundo parámetro, persistente, el hipervisor al que se mudó no considera en absoluto que se trate de una migración permanente.</strong>  Después de reiniciar, el hipervisor no recordará nada. <br><br><pre> <code class="plaintext hljs">- virsh dominfo &lt;vm&gt; | grep persistent</code> </pre> <br>  Sin este parámetro, la máquina virtual es círculos en el agua.  Si el primer parámetro se especifica sin el segundo, adivine qué sucederá. <br><br>  Hay muchos de esos momentos con KVM. <br><br><ul><li>  Red: siempre te hablan sobre bridge, ¡es una pesadilla!  Usted lee y piensa: ¿cómo es eso? </li><li>  Migración: tampoco dirán nada inteligible, hasta que te golpees la cabeza contra esta pared. </li></ul><br><h2>  Por donde empezar </h2><br>  Para empezar tarde, estoy hablando de otra cosa. <br><br><h3>  Aprovisionamiento: cómo implementarlo </h3><br><blockquote>  Si está satisfecho con las opciones de instalación estándar, el mecanismo predeterminado es excelente. </blockquote><br>  Bajo ESXi, usamos virt-install.  Esta es una forma habitual de implementar una máquina virtual.  Es conveniente que cree un archivo preestablecido en el que describa la imagen de su Debian / Ubuntu.  Inicie una nueva máquina alimentándola con un kit de distribución ISO y un archivo preestablecido.  Entonces el auto rueda solo.  Te conectas a través de SSH, lo conectas a un chef, enrollas galletas, ¡eso es todo, apúrate a la producción! <br><br>  Pero si tienes suficiente virt-install, tengo malas noticias.  Esto significa que no ha llegado a la etapa en que desea hacer otra cosa.  Lo superamos y nos dimos cuenta de que virt-install no es suficiente.  Llegamos a una "imagen dorada", que clonamos y luego lanzamos máquinas virtuales. <br><br><h3>  ¿Y cómo organizar una máquina virtual? </h3><br>  ¿Por qué llegamos a esta imagen y por qué es importante el aprovisionamiento?  Debido a que todavía hay una comprensión débil en la comunidad de que hay grandes diferencias entre una máquina virtual y una máquina normal. <br><br>  <strong>Una máquina virtual no necesita un proceso de arranque complicado y un cargador de arranque inteligente</strong> .  Es mucho más fácil conectar los discos de una máquina virtual a una máquina que tiene un conjunto completo de herramientas que en modo de recuperación tratando de salir a alguna parte. <br><br>  <strong>Una máquina virtual necesita la simplicidad de un dispositivo</strong> .  ¿Por qué necesito particiones en un disco virtual?  ¿Por qué la gente toma un disco virtual y coloca particiones allí, no LVM? <br><br>  <strong>Una máquina virtual necesita la máxima extensibilidad</strong> .  Por lo general, las máquinas virtuales crecen.  Este es un proceso "genial": aumentar la partición en el MBR.  Lo borra, en ese momento se limpia el sudor de la frente y piensa: "¡Simplemente no escriba ahora, simplemente no escriba!"  - Y recrear con los nuevos parámetros. <br><br><h3>  LVM @ lilo </h3><br>  Como resultado, llegamos a LVM @ lilo.  Este es un gestor de arranque que le permite configurar desde un solo archivo.  Si para editar la configuración de GRUB está editando un archivo especial que controla el motor de plantillas y crea el monstruoso boot.cfg, luego con Lilo, un archivo y nada más. <br><br>  Partitionless LVM hace que el sistema sea perfecto y fácil.  El problema es que GRUB no puede vivir sin MBR o GPT y se está congelando.  Le decimos: "GRUB establecete aquí", pero no puede, porque no hay particiones. <br><br>  LVM le permite expandirse rápidamente y hacer copias de seguridad.  Diálogo estándar: <br><br>  <em>- Chicos, ¿cómo hacen copias de seguridad virtuales?</em> <br><br>  <em>- ... tomamos un dispositivo de bloque y copiamos.</em> <br><br>  <em>- ¿Has intentado desplegar de nuevo?</em> <br><br>  <em>- Bueno, no, ¡todo funciona para nosotros!</em> <br><br>  Puede lamer un dispositivo de bloque en una máquina virtual en cualquier momento, pero si hay un sistema de archivos, cualquier registro requiere tres movimientos; este procedimiento no es atómico. <br><br>  Si está haciendo una instantánea de la máquina virtual desde el interior, puede comunicarse con el sistema de archivos para que llegue al estado coherente deseado.  Pero esto no es adecuado para todo. <br><br><h2>  ¿Cómo construir un contenedor? </h2><br>  Para comenzar y crear un contenedor, hay herramientas regulares de las plantillas.  LXD ofrece la plantilla Ubuntu 16.04 o 18.04.  Pero si eres un luchador avanzado y no quieres una plantilla regular, pero tus rootfs personalizados, que puedes personalizar para ti, surge la pregunta: ¿cómo crear un contenedor desde cero en LXD? <br><br><h3>  Contenedor desde cero </h3><br>  <strong>Preparando rootfs</strong> .  Debootstrap ayudará con esto: explicamos qué paquetes son necesarios, cuáles no y los instalamos. <br><br>  <strong>Explique a LXD que queremos crear un contenedor a partir de rootfs específicos</strong> .  Pero primero, cree un contenedor vacío con un comando breve: <br><br><pre> <code class="plaintext hljs">curl --unix-socket /var/lib/lxd/unix.socket -X POST -d '{"name": "my-container", "source": {"type": "none"}}' lxd/1.0/containers</code> </pre> <br>  Incluso puede ser automatizado. <br><br>  Un lector atento dirá: ¿dónde está rootfs my-container?  ¿Dónde se indica en qué lugar?  ¡Pero no dije que eso es todo! <br><br>  <strong>Montamos rootfs del contenedor</strong> donde vivirá.  Luego indicamos que el contenedor rootfs vivirá aquí: <br><br><pre> <code class="plaintext hljs">lxc config set my-container raw.lxc "lxc.rootfs=/containers/my-container/rootfs"</code> </pre> <br>  De nuevo, esto está automatizado. <br><br><h3>  Vida del contenedor </h3><br>  <strong>El contenedor no tiene su propio núcleo</strong> , por lo que cargarlo es más fácil <strong>:</strong> systemd, init, y voló. <br><br>  Si no utiliza herramientas regulares para trabajar con LVM, entonces, en la mayoría de los casos, para iniciar el contenedor, deberá montar el rootfs del contenedor en el hipervisor. <br><br>  A veces encuentro artículos que aconsejan autofs.  No lo hagas.  Systemd tiene unidades de montaje automático que funcionan, pero autofs no.  Por lo tanto, las unidades systemd automount pueden y deben usarse, pero autofs no vale la pena. <br><br><h2>  Conclusiones </h2><br>  <strong>Nos gusta KVM con migración</strong> .  Con LXD, todavía no es el camino, aunque para probar y construir la infraestructura la usamos donde no hay carga de producción. <br><br>  <strong>Nos encanta el rendimiento de KVM</strong> .  Es más familiar mirar hacia arriba, ver allí un proceso que sea relevante para esta máquina virtual y comprender quién y qué estamos haciendo.  Esto es mejor que usar un conjunto de utilidades extrañas con contenedores para descubrir qué tipo de golpes bajo el agua hay. <br><br>  <strong>Estamos encantados con la migración.</strong>  Esto se debe en gran parte al almacenamiento compartido.  Si migramos arrastrando discos, no seríamos tan felices. <br><br><blockquote>  Si usted, como Leo, está listo para hablar sobre la superación de las dificultades de operación, integración o soporte, entonces es el momento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de enviar un informe</a> a la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevOpsConf de</a> otoño.  Y nosotros en el comité del programa ayudaremos a preparar la misma presentación inspiradora y útil que esta. <br><br>  No estamos esperando la fecha límite para la convocatoria de ponencias y ya hemos aceptado varios informes para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el programa de la</a> conferencia.  Suscríbase al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boletín</a> y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas</a> y manténgase actualizado sobre las noticias sobre los preparativos para DevOpsConf 2019 y no se pierda nuevos artículos y videos. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458922/">https://habr.com/ru/post/458922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458912/index.html">Migrar a Zimbra con imapsync</a></li>
<li><a href="../458914/index.html">Qué (no) necesitas saber para crear juegos en Unity</a></li>
<li><a href="../458916/index.html">Debajo del capó de React. Escribimos nuestra implementación desde cero</a></li>
<li><a href="../458918/index.html">Lo que puedes aprender del diseño de juegos hiper-casuales</a></li>
<li><a href="../458920/index.html">Conferencia para fanáticos de DevOps</a></li>
<li><a href="../458924/index.html">Los accidentes te ayudan a aprender</a></li>
<li><a href="../458926/index.html">La tragedia no viene sola</a></li>
<li><a href="../458928/index.html">XLNet vs BERT</a></li>
<li><a href="../458930/index.html">Cómo los estudiantes de Perm llegaron a la final del campeonato internacional de análisis de datos de Data Mining Cup 2019</a></li>
<li><a href="../458932/index.html">Yota, o cómo puedes averiguarlo todo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>