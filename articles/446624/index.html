<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥇 👧 💪🏿 Índices en PostgreSQL - 6 (SP-GiST) 👰🏻 🎻 🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hemos discutido el motor de indexación de PostgreSQL, la interfaz de los métodos de acceso y tres métodos: índice hash , árbol B y GiST . En este a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Índices en PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Ya hemos discutido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexación de</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la interfaz de los métodos de acceso</a> y tres métodos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">índice hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árbol B</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> .  En este artículo, describiremos SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Primero, algunas palabras sobre este nombre.  La parte "GiST" alude a alguna similitud con el método de acceso con el mismo nombre.  La similitud existe: ambos son árboles de búsqueda generalizados que proporcionan un marco para construir varios métodos de acceso. <br><br>  "SP" significa partición del espacio.  El espacio aquí es a menudo justo lo que estamos acostumbrados a llamar un espacio, por ejemplo, un plano bidimensional.  Pero veremos que se entiende cualquier espacio de búsqueda, es decir, en realidad cualquier dominio de valor. <br><br>  SP-GiST es adecuado para estructuras donde el espacio se puede dividir recursivamente en áreas que <em>no se cruzan</em> .  Esta clase comprende cuadrúteros, árboles k-dimensionales (árboles kD) y árboles radix. <br><a name="habracut"></a><br><h2>  Estructura </h2><br>  Entonces, la idea del método de acceso SP-GiST es dividir el dominio de valor en subdominios <em>no superpuestos,</em> cada uno de los cuales, a su vez, también se puede dividir.  Particionar de esta manera induce árboles <em>no balanceados</em> (a diferencia de los árboles B y GiST regular). <br><br>  El rasgo de no intersectarse simplifica la toma de decisiones durante la inserción y la búsqueda.  Por otro lado, como regla, los árboles inducidos son de baja ramificación.  Por ejemplo, un nodo de un quadtree generalmente tiene cuatro nodos secundarios (a diferencia de los árboles B, donde los nodos ascienden a cientos) y una profundidad mayor.  Los árboles como estos se adaptan bien al trabajo en RAM, pero el índice se almacena en un disco y, por lo tanto, para reducir el número de operaciones de E / S, los nodos deben estar empaquetados en páginas, y no es fácil hacerlo de manera eficiente.  Además, el tiempo que lleva encontrar diferentes valores en el índice puede variar debido a las diferencias en las profundidades de las ramas. <br><br>  Este método de acceso, al igual que GiST, se encarga de tareas de bajo nivel (acceso simultáneo y bloqueos, registro y un algoritmo de búsqueda puro) y proporciona una interfaz simplificada especializada para permitir agregar soporte para nuevos tipos de datos y nuevos algoritmos de partición. <br><br>  Un nodo interno del árbol SP-GiST almacena referencias a nodos secundarios;  Se puede definir una <em>etiqueta</em> para cada referencia.  Además, un nodo interno puede almacenar un valor llamado <em>prefijo</em> .  En realidad, este valor no es obligatorio un prefijo;  se puede considerar como un predicado arbitrario que se cumple para todos los nodos secundarios. <br><br>  Los nodos hoja de SP-GiST contienen un valor del tipo indexado y una referencia a una fila de tabla (TID).  Los datos indexados en sí (clave de búsqueda) se pueden usar como valor, pero no son obligatorios: se puede almacenar un valor acortado. <br><br>  Además, los nodos hoja se pueden agrupar en listas.  Por lo tanto, un nodo interno puede hacer referencia no solo a un valor, sino a una lista completa. <br><br>  Tenga en cuenta que los prefijos, las etiquetas y los valores en los nodos hoja tienen sus propios tipos de datos, independientes entre sí. <br><br>  De la misma manera que en GiST, la función principal para definir para la búsqueda es <em>la función de coherencia</em> .  Esta función se llama para un nodo de árbol y devuelve un conjunto de nodos secundarios cuyos valores "son consistentes" con el predicado de búsqueda (como de costumbre, en la forma " <em>expresión de operador de campo indexado</em> ").  Para un nodo hoja, la función de coherencia determina si el valor indexado en este nodo cumple con el predicado de búsqueda. <br><br>  La búsqueda comienza con el nodo raíz.  La función de coherencia permite descubrir qué nodos secundarios tiene sentido visitar.  El algoritmo se repite para cada uno de los nodos encontrados.  La búsqueda es profunda primero. <br><br>  A nivel físico, los nodos de índice se agrupan en páginas para que el trabajo con los nodos sea eficiente desde el punto de vista de las operaciones de E / S.  Tenga en cuenta que una página puede contener nodos internos o nodales, pero no ambos. <br><br><h2>  Ejemplo: quadtree </h2><br>  Un quadtree se usa para indexar puntos en un plano.  Una idea es dividir recursivamente áreas en cuatro partes (cuadrantes) con respecto al <em>punto central</em> .  La profundidad de las ramas en dicho árbol puede variar y depende de la densidad de los puntos en los cuadrantes apropiados. <br><br>  Así es como se ve en las cifras, por ejemplo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostración</a> aumentada por aeropuertos desde el sitio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openflights.org</a> .  Por cierto, recientemente lanzamos una nueva versión de la base de datos en la que, entre el resto, reemplazamos longitud y latitud con un campo de tipo "punto". <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Primero, dividimos el avión en cuatro cuadrantes ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Luego dividimos cada uno de los cuadrantes ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Y así sucesivamente hasta que obtengamos la partición final.</em> <br><br>  Proporcionemos más detalles de un ejemplo simple que ya consideramos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo relacionado con GiST</a> .  Vea cómo se verá la partición en este caso: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Los cuadrantes están numerados como se muestra en la primera figura.  En aras de la definición, ubiquemos los nodos secundarios de izquierda a derecha exactamente en la misma secuencia.  Una posible estructura de índice en este caso se muestra en la figura a continuación.  Cada nodo interno hace referencia a un máximo de cuatro nodos secundarios.  Cada referencia se puede etiquetar con el número del cuadrante, como en la figura.  Pero no hay una etiqueta en la implementación, ya que es más conveniente almacenar una matriz fija de cuatro referencias, algunas de las cuales pueden estar vacías. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Los puntos que se encuentran en los límites se relacionan con el cuadrante con el número más pequeño. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  En este caso, la clase de operador "quad_point_ops" se usa por defecto, que contiene los siguientes operadores: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Por ejemplo, veamos cómo la consulta <code>select * from points where p &gt;^ point '(2,7)'</code> (encuentre todos los puntos que se encuentran por encima del dado). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Comenzamos con el nodo raíz y usamos la función de consistencia para seleccionar a qué nodos secundarios descender.  Para el operador <code>&gt;^</code> , esta función compara el punto (2,7) con el punto central del nodo (4,4) y selecciona los cuadrantes que pueden contener los puntos buscados, en este caso, los cuadrantes primero y cuarto. <br><br>  En el nodo correspondiente al primer cuadrante, nuevamente determinamos los nodos secundarios utilizando la función de consistencia.  El punto central es (6,6), y nuevamente necesitamos mirar a través del primer y cuarto cuadrantes. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  La lista de nodos hoja (8.6) y (7.8) corresponde al primer cuadrante, del cual solo el punto (7.8) cumple la condición de consulta.  La referencia al cuarto cuadrante está vacía. <br><br>  En el nodo interno (4.4), la referencia al cuarto cuadrante también está vacía, lo que completa la búsqueda. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Internos </h3><br>  Podemos explorar la estructura interna de los índices SP-GiST utilizando la extensión " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gevel</a> ", que se mencionó anteriormente.  La mala noticia es que, debido a un error, esta extensión funciona incorrectamente con las versiones modernas de PostgreSQL.  La buena noticia es que planeamos aumentar "pageinspect" con la funcionalidad de "gevel" ( <a href="">discusión</a> ).  Y el error ya se ha solucionado en "pageinspect". <br><blockquote>  Una vez más, las malas noticias son que el parche se ha quedado sin progreso. <br></blockquote><br>  Por ejemplo, tomemos la base de datos de demostración extendida, que se usó para dibujar imágenes con el mapa mundial. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Primero, podemos obtener algunas estadísticas para el índice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Y segundo, podemos generar el árbol de índice en sí: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Pero tenga en cuenta que "spgist_print" genera no todos los valores de hoja, sino solo el primero de la lista, y por lo tanto muestra la estructura del índice en lugar de su contenido completo. <br><br><h2>  Ejemplo: árboles k-dimensionales </h2><br>  Para los mismos puntos en el plano, también podemos sugerir otra forma de particionar el espacio. <br><br>  Dibujemos <em>una línea horizontal a</em> través del primer punto que se indexa.  Se divide el avión en dos partes: superior e inferior.  El segundo punto a indexar cae en una de estas partes.  A través de este punto, dibujemos <em>una línea vertical</em> , que divide esta parte en dos: derecha e izquierda.  Nuevamente dibujamos una línea horizontal a través del siguiente punto y una línea vertical a través del siguiente punto, y así sucesivamente. <br><br>  Todos los nodos internos del árbol construido de esta manera tendrán solo dos nodos secundarios.  Cada una de las dos referencias puede conducir al nodo interno que sigue en la jerarquía o a la lista de nodos hoja. <br><br>  Este método puede generalizarse fácilmente para espacios k-dimensionales y, por lo tanto, los árboles también se denominan k-dimensionales (árboles kD) en la literatura. <br><br>  Explicando el método por ejemplo de aeropuertos: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Primero dividimos el avión en partes superior e inferior ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Luego dividimos cada parte en partes izquierda y derecha ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Y así sucesivamente hasta que obtengamos la partición final.</em> <br><br>  Para utilizar una partición como esta, debemos especificar explícitamente la clase de operador <strong>"kd_point_ops"</strong> al crear un índice. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Esta clase incluye exactamente los mismos operadores que la clase "predeterminada" "quad_point_ops". <br><br><h3>  Internos </h3><br>  Al mirar a través de la estructura de árbol, debemos tener en cuenta que el prefijo en este caso es solo una coordenada en lugar de un punto: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Ejemplo: árbol radix </h2><br>  También podemos usar SP-GiST para implementar un árbol de radix para cadenas.  La idea de un árbol de radix es que una cadena a indexar no se almacena completamente en un nodo hoja, sino que se obtiene concatenando los valores almacenados en los nodos por encima de este hasta la raíz. <br><br>  Supongamos que necesitamos indexar las URL del sitio: "postgrespro.ru", "postgrespro.com", "postgresql.org" y "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  El árbol se verá de la siguiente manera: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Los nodos internos del árbol almacenan prefijos comunes a todos los nodos secundarios.  Por ejemplo, en los nodos secundarios de "stgres", los valores comienzan con "p" + "o" + "stgres". <br><br>  A diferencia de los quadtrees, cada puntero a un nodo secundario se etiqueta adicionalmente con un carácter (más exactamente, con dos bytes, pero esto no es tan importante). <br><br>  La clase de operador "Text_ops" admite operadores tipo árbol B: "igual", "mayor" y "menor": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  La distinción de los operadores con tildes es que manipulan <em>bytes en</em> lugar de <em>caracteres</em> . <br><br>  A veces, una representación en forma de árbol de radix puede resultar mucho más compacta que el árbol B ya que los valores no se almacenan completamente, sino que se reconstruyen a medida que surge la necesidad al descender a través del árbol. <br><br>  Considere una consulta: <code>select * from sites where url like 'postgresp%ru'</code> .  Se puede realizar utilizando el índice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  En realidad, el índice se usa para buscar valores que sean mayores o iguales a "postgresp", pero menores que "postgresq" (Índice Cond), y luego se eligen los valores coincidentes del resultado (Filtro). <br><br>  Primero, la función de consistencia debe decidir a qué nodos hijos de la raíz "p" necesitamos descender.  Hay dos opciones disponibles: "p" + "l" (no es necesario descender, lo que está claro incluso sin sumergirse más profundo) y "p" + "o" + "stgres" (continuar el descenso). <br><br>  Para el nodo "stgres", se necesita nuevamente una llamada a la función de coherencia para verificar "postgres" + "p" + "ro".  (continuar el descenso) y "postgres" + "q" (no es necesario descender). <br><br>  Para "ro".  nodo y todos sus nodos hoja secundarios, la función de coherencia responderá "sí", por lo que el método de índice devolverá dos valores: "postgrespro.com" y "postgrespro.ru".  Se seleccionará un valor coincidente de ellos en la etapa de filtrado. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Internos </h3><br>  Al mirar a través de la estructura de árbol, debemos tener en cuenta los tipos de datos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Propiedades </h2><br>  Veamos las propiedades del método de acceso SP-GiST (las consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se proporcionaron anteriormente</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  Los índices SP-GiST no se pueden usar para ordenar y para soportar la restricción única.  Además, índices como este no se pueden crear en varias columnas (a diferencia de GiST).  Pero está permitido usar dichos índices para admitir restricciones de exclusión. <br><br>  Las siguientes propiedades de capa de índice están disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  La diferencia con GiST aquí es que la agrupación es imposible. <br><br>  Y, finalmente, las siguientes son propiedades de capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  La clasificación no es compatible, lo cual es predecible.  Los operadores de distancia para la búsqueda de vecinos más cercanos no están disponibles en SP-GiST hasta el momento.  Lo más probable es que esta característica sea compatible en el futuro. <br><blockquote>  Es compatible con el próximo PostgreSQL 12, el parche de Nikita Glukhov. <br></blockquote><br>  SP-GiST se puede usar para escaneo de solo índice, al menos para las clases de operador discutidas.  Como hemos visto, en algunos casos, los valores indexados se almacenan explícitamente en nodos de hoja, mientras que en los otros, los valores se reconstruyen parte por parte durante el descenso del árbol. <br><br><h3>  Nulos </h3><br>  Para no complicar la imagen, no hemos mencionado NULL hasta ahora.  De las propiedades del índice se desprende que los NULL son compatibles.  De verdad: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  Sin embargo, NULL es algo extraño para SP-GiST.  Todos los operadores de la clase de operador "spgist" deben ser estrictos: un operador debe devolver NULL siempre que cualquiera de sus parámetros sea NULL.  El método en sí mismo asegura esto: los NULL simplemente no se pasan a los operadores. <br><br>  Pero para usar el método de acceso para la exploración de solo índice, los NULL deben almacenarse en el índice de todos modos.  Y se almacenan, pero en un árbol separado con su propia raíz. <br><br><h2>  Otros tipos de datos </h2><br>  Además de los árboles de puntos y radix para cadenas, también se implementan otros métodos basados ​​en SP-GiST PostgreSQL: <br><br><ul><li>  La clase de operador Box_ops proporciona un quadtree para rectángulos. <br>  Cada <em>rectángulo</em> está representado por <em>un punto en un espacio de cuatro dimensiones</em> , por lo que el número de cuadrantes es igual a 16. Un índice como este puede vencer a GiST en el rendimiento cuando hay muchas intersecciones de los rectángulos: en GiST es imposible dibujar límites para separar los objetos que se cruzan entre sí, mientras que no hay tales problemas con los puntos (incluso en cuatro dimensiones). <br></li><li>  La clase de operador "Range_ops" proporciona un quadtree para intervalos. <br>  <em>Un intervalo</em> está representado por <em>un punto bidimensional</em> : el límite inferior se convierte en la abscisa y el límite superior se convierte en la ordenada. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446624/">https://habr.com/ru/post/446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446608/index.html">Superando la Tercera Ley de Gravedad Organizacional</a></li>
<li><a href="../446612/index.html">En el momento en que empezamos a creer en la innovación.</a></li>
<li><a href="../446616/index.html">Cómo creamos FaaS en la nube dentro de Kubernetes y ganamos en Tinkoff Hackathon</a></li>
<li><a href="../446620/index.html">DataGrip 2019.1: soporte para nuevas bases de datos, scripts de inicialización, nuevas inspecciones y más</a></li>
<li><a href="../446622/index.html">Noticias a las 11</a></li>
<li><a href="../446626/index.html">Kaspersky Mobile Talks # 1. Multi-modularidad</a></li>
<li><a href="../446628/index.html">Dar más HighLoad ++: desde el lunes en San Petersburgo</a></li>
<li><a href="../446630/index.html">Cómo elegir una impresora 3D o por qué necesita una mesa calefactora y una cámara cerrada</a></li>
<li><a href="../446632/index.html">De la ley al desarrollo de Big Data</a></li>
<li><a href="../446634/index.html">SDN Digest - Seis emuladores de código abierto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>