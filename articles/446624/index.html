<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•á üëß üí™üèø √çndices en PostgreSQL - 6 (SP-GiST) üë∞üèª üéª üè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hemos discutido el motor de indexaci√≥n de PostgreSQL, la interfaz de los m√©todos de acceso y tres m√©todos: √≠ndice hash , √°rbol B y GiST . En este a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Ya hemos discutido el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci√≥n de</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la interfaz de los m√©todos de acceso</a> y tres m√©todos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndice hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol B</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> .  En este art√≠culo, describiremos SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Primero, algunas palabras sobre este nombre.  La parte "GiST" alude a alguna similitud con el m√©todo de acceso con el mismo nombre.  La similitud existe: ambos son √°rboles de b√∫squeda generalizados que proporcionan un marco para construir varios m√©todos de acceso. <br><br>  "SP" significa partici√≥n del espacio.  El espacio aqu√≠ es a menudo justo lo que estamos acostumbrados a llamar un espacio, por ejemplo, un plano bidimensional.  Pero veremos que se entiende cualquier espacio de b√∫squeda, es decir, en realidad cualquier dominio de valor. <br><br>  SP-GiST es adecuado para estructuras donde el espacio se puede dividir recursivamente en √°reas que <em>no se cruzan</em> .  Esta clase comprende cuadr√∫teros, √°rboles k-dimensionales (√°rboles kD) y √°rboles radix. <br><a name="habracut"></a><br><h2>  Estructura </h2><br>  Entonces, la idea del m√©todo de acceso SP-GiST es dividir el dominio de valor en subdominios <em>no superpuestos,</em> cada uno de los cuales, a su vez, tambi√©n se puede dividir.  Particionar de esta manera induce √°rboles <em>no balanceados</em> (a diferencia de los √°rboles B y GiST regular). <br><br>  El rasgo de no intersectarse simplifica la toma de decisiones durante la inserci√≥n y la b√∫squeda.  Por otro lado, como regla, los √°rboles inducidos son de baja ramificaci√≥n.  Por ejemplo, un nodo de un quadtree generalmente tiene cuatro nodos secundarios (a diferencia de los √°rboles B, donde los nodos ascienden a cientos) y una profundidad mayor.  Los √°rboles como estos se adaptan bien al trabajo en RAM, pero el √≠ndice se almacena en un disco y, por lo tanto, para reducir el n√∫mero de operaciones de E / S, los nodos deben estar empaquetados en p√°ginas, y no es f√°cil hacerlo de manera eficiente.  Adem√°s, el tiempo que lleva encontrar diferentes valores en el √≠ndice puede variar debido a las diferencias en las profundidades de las ramas. <br><br>  Este m√©todo de acceso, al igual que GiST, se encarga de tareas de bajo nivel (acceso simult√°neo y bloqueos, registro y un algoritmo de b√∫squeda puro) y proporciona una interfaz simplificada especializada para permitir agregar soporte para nuevos tipos de datos y nuevos algoritmos de partici√≥n. <br><br>  Un nodo interno del √°rbol SP-GiST almacena referencias a nodos secundarios;  Se puede definir una <em>etiqueta</em> para cada referencia.  Adem√°s, un nodo interno puede almacenar un valor llamado <em>prefijo</em> .  En realidad, este valor no es obligatorio un prefijo;  se puede considerar como un predicado arbitrario que se cumple para todos los nodos secundarios. <br><br>  Los nodos hoja de SP-GiST contienen un valor del tipo indexado y una referencia a una fila de tabla (TID).  Los datos indexados en s√≠ (clave de b√∫squeda) se pueden usar como valor, pero no son obligatorios: se puede almacenar un valor acortado. <br><br>  Adem√°s, los nodos hoja se pueden agrupar en listas.  Por lo tanto, un nodo interno puede hacer referencia no solo a un valor, sino a una lista completa. <br><br>  Tenga en cuenta que los prefijos, las etiquetas y los valores en los nodos hoja tienen sus propios tipos de datos, independientes entre s√≠. <br><br>  De la misma manera que en GiST, la funci√≥n principal para definir para la b√∫squeda es <em>la funci√≥n de coherencia</em> .  Esta funci√≥n se llama para un nodo de √°rbol y devuelve un conjunto de nodos secundarios cuyos valores "son consistentes" con el predicado de b√∫squeda (como de costumbre, en la forma " <em>expresi√≥n de operador de campo indexado</em> ").  Para un nodo hoja, la funci√≥n de coherencia determina si el valor indexado en este nodo cumple con el predicado de b√∫squeda. <br><br>  La b√∫squeda comienza con el nodo ra√≠z.  La funci√≥n de coherencia permite descubrir qu√© nodos secundarios tiene sentido visitar.  El algoritmo se repite para cada uno de los nodos encontrados.  La b√∫squeda es profunda primero. <br><br>  A nivel f√≠sico, los nodos de √≠ndice se agrupan en p√°ginas para que el trabajo con los nodos sea eficiente desde el punto de vista de las operaciones de E / S.  Tenga en cuenta que una p√°gina puede contener nodos internos o nodales, pero no ambos. <br><br><h2>  Ejemplo: quadtree </h2><br>  Un quadtree se usa para indexar puntos en un plano.  Una idea es dividir recursivamente √°reas en cuatro partes (cuadrantes) con respecto al <em>punto central</em> .  La profundidad de las ramas en dicho √°rbol puede variar y depende de la densidad de los puntos en los cuadrantes apropiados. <br><br>  As√≠ es como se ve en las cifras, por ejemplo de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostraci√≥n</a> aumentada por aeropuertos desde el sitio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openflights.org</a> .  Por cierto, recientemente lanzamos una nueva versi√≥n de la base de datos en la que, entre el resto, reemplazamos longitud y latitud con un campo de tipo "punto". <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Primero, dividimos el avi√≥n en cuatro cuadrantes ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Luego dividimos cada uno de los cuadrantes ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Y as√≠ sucesivamente hasta que obtengamos la partici√≥n final.</em> <br><br>  Proporcionemos m√°s detalles de un ejemplo simple que ya consideramos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo relacionado con GiST</a> .  Vea c√≥mo se ver√° la partici√≥n en este caso: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Los cuadrantes est√°n numerados como se muestra en la primera figura.  En aras de la definici√≥n, ubiquemos los nodos secundarios de izquierda a derecha exactamente en la misma secuencia.  Una posible estructura de √≠ndice en este caso se muestra en la figura a continuaci√≥n.  Cada nodo interno hace referencia a un m√°ximo de cuatro nodos secundarios.  Cada referencia se puede etiquetar con el n√∫mero del cuadrante, como en la figura.  Pero no hay una etiqueta en la implementaci√≥n, ya que es m√°s conveniente almacenar una matriz fija de cuatro referencias, algunas de las cuales pueden estar vac√≠as. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Los puntos que se encuentran en los l√≠mites se relacionan con el cuadrante con el n√∫mero m√°s peque√±o. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  En este caso, la clase de operador "quad_point_ops" se usa por defecto, que contiene los siguientes operadores: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Por ejemplo, veamos c√≥mo la consulta <code>select * from points where p &gt;^ point '(2,7)'</code> (encuentre todos los puntos que se encuentran por encima del dado). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Comenzamos con el nodo ra√≠z y usamos la funci√≥n de consistencia para seleccionar a qu√© nodos secundarios descender.  Para el operador <code>&gt;^</code> , esta funci√≥n compara el punto (2,7) con el punto central del nodo (4,4) y selecciona los cuadrantes que pueden contener los puntos buscados, en este caso, los cuadrantes primero y cuarto. <br><br>  En el nodo correspondiente al primer cuadrante, nuevamente determinamos los nodos secundarios utilizando la funci√≥n de consistencia.  El punto central es (6,6), y nuevamente necesitamos mirar a trav√©s del primer y cuarto cuadrantes. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  La lista de nodos hoja (8.6) y (7.8) corresponde al primer cuadrante, del cual solo el punto (7.8) cumple la condici√≥n de consulta.  La referencia al cuarto cuadrante est√° vac√≠a. <br><br>  En el nodo interno (4.4), la referencia al cuarto cuadrante tambi√©n est√° vac√≠a, lo que completa la b√∫squeda. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Internos </h3><br>  Podemos explorar la estructura interna de los √≠ndices SP-GiST utilizando la extensi√≥n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gevel</a> ", que se mencion√≥ anteriormente.  La mala noticia es que, debido a un error, esta extensi√≥n funciona incorrectamente con las versiones modernas de PostgreSQL.  La buena noticia es que planeamos aumentar "pageinspect" con la funcionalidad de "gevel" ( <a href="">discusi√≥n</a> ).  Y el error ya se ha solucionado en "pageinspect". <br><blockquote>  Una vez m√°s, las malas noticias son que el parche se ha quedado sin progreso. <br></blockquote><br>  Por ejemplo, tomemos la base de datos de demostraci√≥n extendida, que se us√≥ para dibujar im√°genes con el mapa mundial. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Primero, podemos obtener algunas estad√≠sticas para el √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Y segundo, podemos generar el √°rbol de √≠ndice en s√≠: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Pero tenga en cuenta que "spgist_print" genera no todos los valores de hoja, sino solo el primero de la lista, y por lo tanto muestra la estructura del √≠ndice en lugar de su contenido completo. <br><br><h2>  Ejemplo: √°rboles k-dimensionales </h2><br>  Para los mismos puntos en el plano, tambi√©n podemos sugerir otra forma de particionar el espacio. <br><br>  Dibujemos <em>una l√≠nea horizontal a</em> trav√©s del primer punto que se indexa.  Se divide el avi√≥n en dos partes: superior e inferior.  El segundo punto a indexar cae en una de estas partes.  A trav√©s de este punto, dibujemos <em>una l√≠nea vertical</em> , que divide esta parte en dos: derecha e izquierda.  Nuevamente dibujamos una l√≠nea horizontal a trav√©s del siguiente punto y una l√≠nea vertical a trav√©s del siguiente punto, y as√≠ sucesivamente. <br><br>  Todos los nodos internos del √°rbol construido de esta manera tendr√°n solo dos nodos secundarios.  Cada una de las dos referencias puede conducir al nodo interno que sigue en la jerarqu√≠a o a la lista de nodos hoja. <br><br>  Este m√©todo puede generalizarse f√°cilmente para espacios k-dimensionales y, por lo tanto, los √°rboles tambi√©n se denominan k-dimensionales (√°rboles kD) en la literatura. <br><br>  Explicando el m√©todo por ejemplo de aeropuertos: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Primero dividimos el avi√≥n en partes superior e inferior ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Luego dividimos cada parte en partes izquierda y derecha ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Y as√≠ sucesivamente hasta que obtengamos la partici√≥n final.</em> <br><br>  Para utilizar una partici√≥n como esta, debemos especificar expl√≠citamente la clase de operador <strong>"kd_point_ops"</strong> al crear un √≠ndice. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Esta clase incluye exactamente los mismos operadores que la clase "predeterminada" "quad_point_ops". <br><br><h3>  Internos </h3><br>  Al mirar a trav√©s de la estructura de √°rbol, debemos tener en cuenta que el prefijo en este caso es solo una coordenada en lugar de un punto: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Ejemplo: √°rbol radix </h2><br>  Tambi√©n podemos usar SP-GiST para implementar un √°rbol de radix para cadenas.  La idea de un √°rbol de radix es que una cadena a indexar no se almacena completamente en un nodo hoja, sino que se obtiene concatenando los valores almacenados en los nodos por encima de este hasta la ra√≠z. <br><br>  Supongamos que necesitamos indexar las URL del sitio: "postgrespro.ru", "postgrespro.com", "postgresql.org" y "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  El √°rbol se ver√° de la siguiente manera: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Los nodos internos del √°rbol almacenan prefijos comunes a todos los nodos secundarios.  Por ejemplo, en los nodos secundarios de "stgres", los valores comienzan con "p" + "o" + "stgres". <br><br>  A diferencia de los quadtrees, cada puntero a un nodo secundario se etiqueta adicionalmente con un car√°cter (m√°s exactamente, con dos bytes, pero esto no es tan importante). <br><br>  La clase de operador "Text_ops" admite operadores tipo √°rbol B: "igual", "mayor" y "menor": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  La distinci√≥n de los operadores con tildes es que manipulan <em>bytes en</em> lugar de <em>caracteres</em> . <br><br>  A veces, una representaci√≥n en forma de √°rbol de radix puede resultar mucho m√°s compacta que el √°rbol B ya que los valores no se almacenan completamente, sino que se reconstruyen a medida que surge la necesidad al descender a trav√©s del √°rbol. <br><br>  Considere una consulta: <code>select * from sites where url like 'postgresp%ru'</code> .  Se puede realizar utilizando el √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  En realidad, el √≠ndice se usa para buscar valores que sean mayores o iguales a "postgresp", pero menores que "postgresq" (√çndice Cond), y luego se eligen los valores coincidentes del resultado (Filtro). <br><br>  Primero, la funci√≥n de consistencia debe decidir a qu√© nodos hijos de la ra√≠z "p" necesitamos descender.  Hay dos opciones disponibles: "p" + "l" (no es necesario descender, lo que est√° claro incluso sin sumergirse m√°s profundo) y "p" + "o" + "stgres" (continuar el descenso). <br><br>  Para el nodo "stgres", se necesita nuevamente una llamada a la funci√≥n de coherencia para verificar "postgres" + "p" + "ro".  (continuar el descenso) y "postgres" + "q" (no es necesario descender). <br><br>  Para "ro".  nodo y todos sus nodos hoja secundarios, la funci√≥n de coherencia responder√° "s√≠", por lo que el m√©todo de √≠ndice devolver√° dos valores: "postgrespro.com" y "postgrespro.ru".  Se seleccionar√° un valor coincidente de ellos en la etapa de filtrado. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Internos </h3><br>  Al mirar a trav√©s de la estructura de √°rbol, debemos tener en cuenta los tipos de datos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Propiedades </h2><br>  Veamos las propiedades del m√©todo de acceso SP-GiST (las consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se proporcionaron anteriormente</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  Los √≠ndices SP-GiST no se pueden usar para ordenar y para soportar la restricci√≥n √∫nica.  Adem√°s, √≠ndices como este no se pueden crear en varias columnas (a diferencia de GiST).  Pero est√° permitido usar dichos √≠ndices para admitir restricciones de exclusi√≥n. <br><br>  Las siguientes propiedades de capa de √≠ndice est√°n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  La diferencia con GiST aqu√≠ es que la agrupaci√≥n es imposible. <br><br>  Y, finalmente, las siguientes son propiedades de capa de columna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  La clasificaci√≥n no es compatible, lo cual es predecible.  Los operadores de distancia para la b√∫squeda de vecinos m√°s cercanos no est√°n disponibles en SP-GiST hasta el momento.  Lo m√°s probable es que esta caracter√≠stica sea compatible en el futuro. <br><blockquote>  Es compatible con el pr√≥ximo PostgreSQL 12, el parche de Nikita Glukhov. <br></blockquote><br>  SP-GiST se puede usar para escaneo de solo √≠ndice, al menos para las clases de operador discutidas.  Como hemos visto, en algunos casos, los valores indexados se almacenan expl√≠citamente en nodos de hoja, mientras que en los otros, los valores se reconstruyen parte por parte durante el descenso del √°rbol. <br><br><h3>  Nulos </h3><br>  Para no complicar la imagen, no hemos mencionado NULL hasta ahora.  De las propiedades del √≠ndice se desprende que los NULL son compatibles.  De verdad: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  Sin embargo, NULL es algo extra√±o para SP-GiST.  Todos los operadores de la clase de operador "spgist" deben ser estrictos: un operador debe devolver NULL siempre que cualquiera de sus par√°metros sea NULL.  El m√©todo en s√≠ mismo asegura esto: los NULL simplemente no se pasan a los operadores. <br><br>  Pero para usar el m√©todo de acceso para la exploraci√≥n de solo √≠ndice, los NULL deben almacenarse en el √≠ndice de todos modos.  Y se almacenan, pero en un √°rbol separado con su propia ra√≠z. <br><br><h2>  Otros tipos de datos </h2><br>  Adem√°s de los √°rboles de puntos y radix para cadenas, tambi√©n se implementan otros m√©todos basados ‚Äã‚Äãen SP-GiST PostgreSQL: <br><br><ul><li>  La clase de operador Box_ops proporciona un quadtree para rect√°ngulos. <br>  Cada <em>rect√°ngulo</em> est√° representado por <em>un punto en un espacio de cuatro dimensiones</em> , por lo que el n√∫mero de cuadrantes es igual a 16. Un √≠ndice como este puede vencer a GiST en el rendimiento cuando hay muchas intersecciones de los rect√°ngulos: en GiST es imposible dibujar l√≠mites para separar los objetos que se cruzan entre s√≠, mientras que no hay tales problemas con los puntos (incluso en cuatro dimensiones). <br></li><li>  La clase de operador "Range_ops" proporciona un quadtree para intervalos. <br>  <em>Un intervalo</em> est√° representado por <em>un punto bidimensional</em> : el l√≠mite inferior se convierte en la abscisa y el l√≠mite superior se convierte en la ordenada. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446624/">https://habr.com/ru/post/446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446608/index.html">Superando la Tercera Ley de Gravedad Organizacional</a></li>
<li><a href="../446612/index.html">En el momento en que empezamos a creer en la innovaci√≥n.</a></li>
<li><a href="../446616/index.html">C√≥mo creamos FaaS en la nube dentro de Kubernetes y ganamos en Tinkoff Hackathon</a></li>
<li><a href="../446620/index.html">DataGrip 2019.1: soporte para nuevas bases de datos, scripts de inicializaci√≥n, nuevas inspecciones y m√°s</a></li>
<li><a href="../446622/index.html">Noticias a las 11</a></li>
<li><a href="../446626/index.html">Kaspersky Mobile Talks # 1. Multi-modularidad</a></li>
<li><a href="../446628/index.html">Dar m√°s HighLoad ++: desde el lunes en San Petersburgo</a></li>
<li><a href="../446630/index.html">C√≥mo elegir una impresora 3D o por qu√© necesita una mesa calefactora y una c√°mara cerrada</a></li>
<li><a href="../446632/index.html">De la ley al desarrollo de Big Data</a></li>
<li><a href="../446634/index.html">SDN Digest - Seis emuladores de c√≥digo abierto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>