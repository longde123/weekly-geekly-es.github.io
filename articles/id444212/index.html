<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👩🏻 🙎 👨🏽‍🏫 Percakapan tentang pemrograman fungsional di C ++ Siberia 2019 🤽🏾 ✏️ 🛄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Baru-baru ini, C ++ Siberia 2019 berikutnya diadakan di Novosibirsk. Konferensi ini memiliki suasana yang nyaman dan banyak laporan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Percakapan tentang pemrograman fungsional di C ++ Siberia 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/444212/"><p>  Halo semuanya! </p><br><p>  Baru-baru ini, C ++ Siberia 2019 berikutnya diadakan di Novosibirsk. Konferensi ini memiliki suasana yang nyaman dan banyak laporan bagus.  Saya mengambil kesempatan ini untuk berbicara dengan dua pembicara kami, yang akan segera Anda temui di Moskow. </p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/yk/tc/m6/yktcm6h7qrfisa5rcudmirsl6ys.jpeg">  <strong>Ivan Chukic</strong> adalah salah satu pengembang KDE, seorang guru dan peneliti desain bahasa pemrograman di University of Belgrade. <br clear="all"></p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/21/vg/0y/21vg0ybouvc_hip9zys9-dkznew.jpeg">  <strong>Alexander Granin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">graninas</a> ) adalah seorang pembicara dan pengembang terkenal yang berspesialisasi dalam FP, penyelenggara komunitas FP Novosibirsk, LambdaNsk. <br clear="all"></p><br><p><img src="https://habrastorage.org/webt/fj/9f/nr/fj9fnrzzgxrmy9ur1vpzyjuyyau.png"></p><a name="habracut"></a><br><p>  <strong>Sergey:</strong> Halo semuanya, mari berkenalan.  Alexander adalah pembicara utama pada C ++ Siberia ini, dan Ivan adalah pembicara utama tahun lalu.  Mari kita bicara tentang pemrograman fungsional.  Sejauh yang saya ingat, FP dalam C ++ adalah tema dari keynote Anda sebelumnya, Ivan ... </p><br><p>  <strong>Ivan:</strong> Tidak sepenuhnya, tetapi sebagian - ya. </p><br><p>  <strong>Sergey:</strong> Dan topik laporan Alexander adalah tentang pemrograman fungsional.  Karena itu, saya menyiapkan beberapa pertanyaan, dan yang pertama - bagaimana Anda menentukan AF? </p><br><p>  <strong>Alexander:</strong> Saya tidak berpikir bahwa ada satu definisi AF yang "benar", tetapi berbicara tentang saya secara pribadi, AF adalah sesuatu dengan komposisi fungsional dan fungsi kelas satu. </p><br><p>  <strong>Ivan:</strong> Saya setuju, tetapi saya akan menambahkan lebih banyak fungsi dengan urutan lebih tinggi - fungsi yang dapat menggunakan fungsi lain sebagai argumen dan sebagai hasilnya kembali. </p><br><p>  <strong>Sergey</strong> : Tautan ke fungsi dalam C - apakah itu dipertimbangkan? </p><br><p>  <strong>Ivan:</strong> Tidak, C bukan bahasa pemrograman fungsional :-) </p><br><p>  <strong>Sergey:</strong> Katakan mengapa? </p><br><p>  <strong>Ivan:</strong> Karena Anda tidak dapat membuat fungsi baru dari kombinasi pointer fungsi, Anda hanya bisa menunjuk ke yang sudah ada.  Tentu saja, jika beberapa hack assembler tidak digunakan. </p><br><p>  <strong>Sergey:</strong> Luar biasa, sekarang saya punya jawaban resmi!  Orang-orang terus-menerus bertanya pertanyaan ini mengapa C bukan bahasa pemrograman fungsional, karena ada fungsi lengkap di sana.  Dan inilah mengapa C ++ adalah bahasa fungsional, lebih bisa dimengerti ... </p><br><p>  <strong>Alexander:</strong> Saya tidak akan mengatakan bahwa C ++ adalah bahasa pemrograman yang benar-benar fungsional, ia mendukung banyak paradigma yang dituangkan ke dalam satu bahasa. </p><br><p>  <strong>Sergey:</strong> Maksud <strong>saya</strong> - C ++ mendukung paradigma fungsional, tentu saja.  Ngomong-ngomong, mengapa?  Apakah dia mendukungnya karena Anda dapat memanipulasi fungsi tingkat tinggi? </p><br><p>  <strong>Ivan:</strong> Ya, menurut saya dia selalu seperti itu, karena bahkan di C ++ 98, fungsi tingkat tinggi sudah ada, bahkan di STL.  Ini bukan bahasa fungsional yang paling nyaman - ada bahasa yang mengimplementasikan FP dan lebih baik.  Tetapi untuk kebutuhan saya selalu cukup fungsional. </p><br><p>  <strong>Sergey:</strong> Tapi dari tempat ini lebih terinci.  Kebutuhan apa yang Anda miliki? </p><br><p> <strong>Ivan:</strong> Ini rumit.  Ayo, ceritakan sebuah kisah.  Ketika saya di universitas, kami melewati LISP, dan semua orang membenci LISP ini karena jelek.  Tapi yang saya pahami darinya adalah bagaimana mensimulasikan konstruksi C secara langsung dalam kode LISP.  Dan kemudian suatu hari versi baru Jawa keluar, yang dirilis untuk hal-hal seperti <code>foreach</code> , dan saya pikir: wow, Anda memerlukan kompiler baru, versi bahasa baru dan semua yang baru hanya untuk mengimplementasikan sesuatu yang saya lakukan di universitas pada LISP , yang umumnya bahkan tidak mendukung loop.  Pada saat itu, saya menyadari bahwa FP adalah hal yang cukup bagus untuk membangun abstraksi tingkat tinggi, dan itulah mengapa saya menggunakan fungsional C ++ pada tahun 2019. </p><br><p>  <strong>Sergey:</strong> Sebenarnya, Anda menggunakan FP untuk desain tingkat tinggi. </p><br><p>  <strong>Ivan:</strong> Tepat sekali. </p><br><p>  <strong>Alexander:</strong> Saat ini saya tidak bekerja di C ++, tapi saya tidak akan menolak untuk menggunakannya untuk memanipulasi data, ini jauh lebih menyenangkan daripada dalam pendekatan imperatif.  Bahkan jika dibandingkan dengan OOP, berbeda dengan itu, hanya transformasi yang dapat diterima di sini, dan ini nyaman. </p><br><p>  <strong>Sergey:</strong> Ya, Anda bisa menggunakan FP tidak hanya dengan C ++, bukan?  OK, lalu pertanyaan berikutnya: bagian C ++ apa yang Anda gunakan?  Jika hanya masalah desain yang penting, Anda hanya dapat memilih bagian yang cocok dengan FP, yang benar-benar Anda gunakan. </p><br><p>  <strong>Ivan:</strong> Ini pasti akan menjadi fungsi lambda.  Dan bahkan yang lebih penting - templat, karena memungkinkan Anda untuk melewati fungsi lain sebagai argumen dan yang lainnya, dan lambda hanyalah sintaks yang bagus untuk menulis objek fungsional. </p><br><p>  <strong>Sergey:</strong> Ya, kami sudah menyadari bahwa Anda benar-benar menyukai lambdas :-) </p><br><p>  <strong>Ivan:</strong> Bukannya mereka <em>benar</em> - <em>benar</em> menyukainya, tapi ini jelas merupakan hal terbaik yang kami miliki di C ++ 98, lebih nyaman untuk bekerja dengan mereka. </p><br><p>  <strong>Alexander:</strong> Ya, saya juga suka lambdas - fitur ini sangat universal sehingga Anda hanya bisa menulisnya saja.  Ini adalah sesuatu seperti kombinator universal yang memungkinkan Anda membangun logika apa pun - mungkin tidak seindah dalam bahasa lain, tetapi tidak kalah bermanfaat. </p><br><p>  <strong>Sergey:</strong> Ivan, Anda mencatat di sini bahwa ada standar sebelum C ++ 11, misalnya, C ++ 03, yang sangat umum, dan sudah ada fitur fungsional di sana.  Dan ada lebih banyak fitur fungsional dalam standar baru ... Apakah mungkin untuk mengatakan bahwa C ++ bergerak menuju FP?  Akankah gerakan ini berlanjut atau berhenti?  Lalu apa yang akan terjadi? </p><br><p>  <strong>Ivan:</strong> Ada laporan bagus oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simon Peython Jones</a> tentang bahasa pemrograman secara umum, dan di sana ia menggambar grafik yang menunjukkan banyak bahasa aman dan bahasa yang digunakan.  Haskell memulai ceritanya sebagai bahasa yang benar-benar aman yang dengannya tidak ada yang bisa dilakukan - karena tidak ada I / O, dan tidak ada sama sekali.  SPJ mengkategorikan bahasa C dan bahasa rakitan sebagai bahasa yang sangat berguna, tetapi pada saat yang sama sangat tidak aman.  Sejak itu, Haskell telah mulai bergerak ke arah keamanan yang lebih besar.  Di sisi lain, fitur-fitur yang muncul di C ++ - mereka muncul terutama untuk meningkatkan keamanan sehingga Anda dapat menulis program yang benar lebih sederhana.  Kebetulan sebagian besar dari hal-hal ini berasal dari bahasa pemrograman fungsional. </p><br><p>  <strong>Sergey:</strong> Mengapa menurut Anda begitu?  Karena sifat AF? </p><br><p>  <strong>Ivan:</strong> Ya, mungkin secara alami ... tapi saya tidak tahu pasti. </p><br><p>  <strong>Alexander:</strong> Saya pikir AF sangat memikat semua orang hanya karena kami lelah berjuang dengan templat, mengatur ulang byte, dengan semacam ampas tingkat rendah - kami ingin sesuatu yang layak untuk menerapkan kecerdasan kami sendiri. </p><br><p>  <strong>Sergey: Ya</strong> , bagi Anda ini semacam latihan intelektual? </p><br><p>  <strong>Alexander:</strong> Ya, seperti itu. </p><br><p>  <strong>Sergey:</strong> Saya mengerti.  Betapa jauh lebih menarik bagi pengembang untuk memikirkan abstraksi tingkat tinggi daripada menerapkan fitur standar yang bodoh - ini tidak menyenangkan.  Maka ini adalah pertanyaan <strong>C:</strong> apakah Anda memiliki pengalaman dengan aplikasi praktis FP di C ++?  Ada proyek produksi? </p><br><p>  <strong>Ivan:</strong> Tentu saja.  Salah satu proyek terbesar di dunia, KDE, memiliki beberapa bagian di dalamnya yang secara intensif menggunakan gaya fungsional.  Tentu saja, ini adalah campuran, jadi untuk berbicara, lebih berorientasi objek tradisional C ++ dengan serangkaian konsep fungsional.  Saya tidak akan pernah menjadi seorang purist atau sesuatu seperti itu.  Saya selalu mencoba menggabungkan yang terbaik dari dunia yang berbeda. </p><br><p>  <strong>Sergey:</strong> Bagaimana dengan Haskell atau Scala?  Bagaimanapun, mereka banyak digunakan dalam produksi.  Bagaimana Anda menyukai gagasan bahwa Haskell sekarang dianggap sebagai standar bahasa fungsional?  Ini terutama dicatat oleh para puritan. </p><br><p>  <strong>Ivan:</strong> Ya, saya setuju bahwa Haskell hari ini adalah sinonim untuk FP.  Bahkan, setiap fitur dari Haskell dianggap oleh orang sebagai sesuatu yang terkait dengan FP.  Ini belum tentu benar, tetapi saya pikir Haskell telah benar-benar menjadi bahasa pemrograman fungsional akademik yang paling populer.  Saya tahu bahwa beberapa bank di London dan Eropa Utara menggunakan Haskell secara ekstensif, tetapi Scala masih jauh lebih populer saat ini. </p><br><p>  <strong>Alexander:</strong> Saya setuju bahwa Scala lebih populer, tetapi Haskell tampaknya menjadi bahasa yang lebih fungsional, sebagian besar fiturnya diimplementasikan lebih benar.  Artinya, ketika Anda memiliki kari yang mudah dilakukan, ketika ada cara mudah untuk membuat komposisi, pemrograman menjadi mudah dan sederhana, itu seperti berjalan melalui hutan dan menikmati pemandangan. </p><br><p>  <strong>Ivan:</strong> Tapi terkadang ada beruang di hutan.  Jika Anda berada di Rusia. </p><br><p>  <strong>Sergey:</strong> Apakah menurut Anda C ++ terutama terinspirasi oleh Haskell?  Apakah itu sepadan? </p><br><p>  <strong>Ivan:</strong> Apakah Anda memberi petunjuk kepada anggota komite tertentu?  :-) Seseorang mengisyaratkan bahwa konsep muncul sebagai hasil dari memahami kelas kelas, tetapi Bjorn menghentikan rumor ini dan bahkan menulis beberapa dokumen tentang bagaimana konsep berbeda dari kelas kelas.  Dari sudut pandang saya, mereka berbeda dalam segala hal, tetapi melayani satu tujuan.  Hanya pendekatan yang berbeda. </p><br><p>  <strong>Sergey:</strong> Apakah masa depan / janji dengan cara apa pun terkait dengan FI?  Bartosh tampaknya berpendapat bahwa ini adalah monad yang diimplementasikan dengan buruk. </p><br><p>  <strong>Ivan:</strong> Ya, mereka diimplementasikan sebagai monad, mentransmisikan sekuel, tapi saya tidak yakin apa yang paling penting dalam masalah ini. </p><br><p>  <strong>Sergey:</strong> Apakah kita perlu meningkatkan dukungan monad di C ++? </p><br><p>  <strong>Alexander:</strong> Tentu saja, ini adalah fitur paling penting yang dapat mengubah C ++ menjadi bahasa yang sangat baik. </p><br><p>  <strong>Ivan:</strong> Ngomong-ngomong, karena kita ada di konferensi, izinkan saya mengajukan pertanyaan juga, Sergey.  Anda mengatakan bahwa konferensi adalah pekerjaan yang menyenangkan.  Bagikan apa yang begitu menarik tentang hal itu, dan maukah Anda menasihati saya atau Kamerad Granin untuk secara mandiri menyelenggarakan konferensi di bagian lain dunia? </p><br><p>  <strong>Sergey:</strong> Organisasi konferensi benar-benar keren, Anda bertemu banyak orang yang menarik, tetapi ini hanyalah puncak gunung es.  Dan di sana - banyak pekerjaan, semua persiapan aula ini, makanan untuk para peserta, belum lagi mencari pembicara.  C ++ Rusia masih bukan konferensi paling terkenal di dunia, dan para pembicara harus menjelaskan bahwa kita adalah konferensi baru, bahwa hal-hal menarik sedang terjadi di sini.  Anda perlu meyakinkan pembicara, terutama pembicara bintang terkenal yang tidak terlalu tertarik terbang ke Rusia hanya untuk melihat negara baru.  Pekerjaan organisasi itu sulit, terutama jika Anda bekerja di pekerjaan utama.  Tapi semuanya terbayar dengan berkomunikasi dengan orang-orang hebat ini.  Meskipun demikian, saya sekarang telah mencapai titik bahwa saya lebih suka menghadiri konferensi orang lain daripada saya akan melakukan konferensi saya sendiri. </p><br><p>  <strong>Ivan:</strong> Yaitu, Anda menyarankan untuk menghadiri konferensi, daripada melakukannya. </p><br><p>  <strong>Sergey:</strong> Ya, jika Anda dapat menghindari penyelenggaraan konferensi, Anda harus mengambil kesempatan.  Saat berorganisasi, beban besar akan jatuh pada Anda, ini adalah pekerjaan 8 jam lagi.  Secara pribadi, saya mulai bekerja tambahan 8 jam sehari sekitar 3 bulan sebelum konferensi.  Ini menyenangkan untuk dilakukan ... tapi saya harap keluarga saya juga menyenangkan.  Terima kasih sudah bertanya! </p><br><p>  Dan sekarang, kembali ke topik.  Kami berbicara tentang pemrograman fungsional, dan Anda hampir meyakinkan saya, dalam arti bahwa laporan Anda meyakinkan saya.  Ada kecurigaan bahwa pendekatan fungsional dalam C ++ akan membantu saya dengan multithreading ketika saya perlu menyinkronkan hal-hal yang berbeda.  Apakah ini akan sangat membantu? </p><br><p>  <strong>Ivan:</strong> Tentu saja. </p><br><p>  <strong>Alexander:</strong> Terlepas dari kenyataan bahwa saya memiliki pengalaman terbatas dengan multithreading fungsional khususnya dalam C ++, saya harus mengatakan bahwa ketika Anda memiliki dunia fungsi murni, jauh lebih mudah untuk membicarakannya di lingkungan multithreaded.  Jika Anda menulis logika, misalnya, kompetitif, Anda tidak perlu berpikir tentang menyinkronkan semua hal ini, tentang mutex, tentang bagian penting, tentang apa pun.  Semua ini hilang begitu saja, karena Anda menganggap kode tersebut sebagai kode berurutan biasa, dan semua multithreading dan sinkronisasi tersembunyi di suatu tempat di dalamnya.  Ada banyak pendekatan untuk pemrograman multithreaded, dan fungsional.  Saya tidak yakin bahwa ini benar-benar terjadi dalam semua pendekatan, tetapi misalnya, memori transaksional perangkat lunak adalah pendekatan yang bagus untuk mengurangi kompleksitas dalam aplikasi kompetitif.  Sayangnya, ini adalah masalah memilih kompromi yang tepat. </p><br><p>  <strong>Ivan:</strong> Ketika kompiler melakukan semua pekerjaan untuk Anda, Anda harus membayarnya dengan efisiensi. </p><br><p>  <strong>Alexander:</strong> Ya, ada berbagai masalah.  Pertama, Anda perlu memahami semua hal ini seperti STM, dan kemudian meneruskan pengetahuan rahasia ini kepada kolega Anda.  Dan kemudian ada kesalahan dalam implementasi tertentu dan tempat-tempat yang dapat bekerja lebih baik saat menggunakan kontrol utas manual.  Tetapi Anda dapat menulis lebih cepat dan lebih mudah daripada dengan kontrol manual seperti itu.  Akan lebih lambat untuk dieksekusi, tetapi kode akan lebih sedikit kesalahan.  Omong-omong, Ivan, apa pendapat Anda tentang seberapa baik masalah ini dibahas dengan baik di konferensi? </p><br><p>  <strong>Ivan:</strong> Topik ini sedang booming.  Dalam beberapa tahun terakhir, semua konferensi utama - CPPConf, C ++ Rusia, Rapat C ++, dll.  - Menerima laporan baik secara langsung di FP, atau pada struktur data aljabar, atau sesuatu seperti itu.  Kadang-kadang pembicara bahkan tidak curiga bahwa dalam laporan mereka, mereka berbicara tentang beberapa konsep dari FP.  Di C ++, banyak hal datang dari berbagai tempat ... Orang biasanya tidak menulis hanya dalam satu bahasa.  Bayangkan Ivan Ivanov mengerjakan proyek yang ditulis dalam bahasa Erlang dan C ++.  Kemudian Tatyana Petrovna tiba, dan dia sudah bekerja untuk Haskell dengan fungsi bersih dan semua itu, mereka mengambil mekanisme favorit mereka dan memindahkannya ke C ++, dan sebagai hasilnya, sejumlah besar orang dari berbagai komunitas membawa lebih banyak barang ke C ++.  Semua ini terjadi di depan mata kita.  Paling tidak, ini terjadi di komunitas pengembang C ++, tetapi untuk perusahaan C ++, saya tidak begitu yakin.  Namun, banyak orang di komunitas C ++ sekarang bekerja pada konsep fungsional. </p><br><p>  <strong>Alexander:</strong> Saya benar mengerti bahwa banyak pengembang C ++ teratas mempelajari Haskell hanya untuk memahami apa yang terjadi dengan C ++? </p><br><p>  <strong>Ivan:</strong> Saya tidak yakin mereka mengajar Haskell karena alasan ini.  Saya pikir pengembang C ++ sangat egois.  Mereka belajar C ++ dengan baik hanya karena itu rumit.  Dan jika Anda ingin mempelajari sesuatu yang benar-benar baru, jalur Anda jelas tidak terletak di Jawa, yang dibuat khusus untuk menjadi sederhana.  Anda perlu melihat di bidang bahasa yang tidak biasa dan aneh, yang paling aneh, dan Haskell secara otomatis akan menjadi jawaban yang paling populer.  Seseorang melihatnya, mengerti: oh, ini adalah sesuatu yang lebih kompleks daripada C ++, Anda perlu belajar.  Ketika saya mempelajari Haskell, itu sama dengan saya, dan saya punya teman-teman yang mengikuti alur pemikiran yang persis sama. </p><br><p>  <strong>Alexander:</strong> Ketika Eric Nibler ada bersama kami di Siberia dan menunjukkan perpustakaannya untuk jangkauan, ia sering ditanya apa sumber inspirasi.  Dia menjawab bahwa itu adalah Haskell.  Mungkin semua fitur berturut-turut tidak boleh diambil darinya, tetapi beberapa jelas dibutuhkan di komunitas. </p><br><p>  <strong>Ivan:</strong> Ini sedikit evolusi.  Bahan genetik.  Dan Haskell juga dapat ditingkatkan dengan mengambil sesuatu dari C ++.  Sebagian besar bahasa mengalami evolusi seperti itu.  Java mencoba untuk mengadaptasi LINQ dari C # ke dirinya sendiri, dan pencipta LINQ dari C # menarik inspirasi dari Haskell, dll.  Ternyata jaringan kusut yang indah dari pengaruh timbal balik antara berbagai bahasa. </p><br><p>  <strong>Alexander:</strong> Namun, apakah C ++ masih bahasa tingkat rendah? </p><br><p>  <strong>Ivan:</strong> Kebanyakan orang berpikir begitu. </p><br><p>  <strong>Sergey:</strong> "level rendah" seperti apa yang kamu bicarakan? </p><br><p>  <strong>Ivan:</strong> Dikompilasi ke kode tingkat rendah.  Tetapi ia bekerja dengan abstraksi tingkat tinggi.  Inti dan tujuannya adalah bahwa abstraksi semacam itu tidak mengarah pada overhead yang tidak perlu dalam hal kinerja.  C ++ harus menghasilkan kode dari abstraksi yang tidak lebih buruk dari tulisan tangan.  Setidaknya secara teoritis. </p><br><p>  <strong>Alexander:</strong> Apa yang terjadi jika seseorang melanggar aturan ini?  Misalnya, Ranges. </p><br><p>  <strong>Ivan:</strong> Kinerja kompilasi menderita - ya.  Semua fitur baru, terutama fitur yang disediakan di perpustakaan, menambah waktu kompilasi.  Tetapi tidak ada alasan mengapa rentang harus lambat.  Jika rentang melambat, maka satu-satunya hal yang dapat Anda salahkan di sini adalah kompiler yang tidak dioptimalkan untuk kasus khusus ini. </p><br><p>  <strong>Sergey:</strong> Ranges sendiri tidak mengerem, tetapi Ranges dalam mode debug - ini adalah inti dari seluruh diskusi.  Dalam mode rilis, mereka bekerja dengan baik. </p><br><p>  <strong>Ivan:</strong> Ini normal. </p><br><p>  <strong>Sergey:</strong> Tidak semua orang setuju dengan ini :-) </p><br><p>  <strong>Ivan:</strong> Ya, saya tahu dalam praktiknya.  Di satu perusahaan, di perpustakaan yang paling sering digunakan ... Saya tidak akan mengatakan jenis perusahaan dan perpustakaan itu ... ada algoritma yang secara asimptot secara signifikan lebih lambat dalam mode debug.  Dan siapa yang sekarang akan mengeluh bahwa rentang melakukan hal yang sama? </p><br><p>  <strong>Sergey:</strong> Dalam artikel yang sedang kita bahas, intinya bukan di  sendiri, mereka hanya contoh bagi seorang penulis yang marah karena situasi ini menjadi tren, dan produktivitas yang rendah dalam mode debug.  Di area subjeknya, mesin game, ini tidak bisa diterima. </p><br><p>  <strong>Alexander:</strong> Orang-orang ini sama sekali tidak menyukai STL, karena kerjanya lebih lambat dari yang mereka butuhkan.  Rentang hanya memperluas perpustakaan ke arah yang sama, dan bagi mereka sepertinya fitur lain yang tidak berguna yang tidak dapat mereka gunakan. </p><br><p>  <strong>Sergey:</strong> Pembenci akan membenci. </p><br><p>  <strong>Ivan:</strong> Tepat sekali.  Misalnya, semua orang menggunakan penyortiran.  Bayangkan saja tidak ada lagi penyortiran di perpustakaan standar.  Bagaimana Anda mengimplementasikannya? </p><br><p>  <strong>Sergey:</strong> Saya biasanya mengajukan pertanyaan seperti itu dalam sebuah wawancara :-) Ini adalah pertanyaan yang sangat umum. </p><br><p>  <strong>Ivan:</strong> Ya, pertanyaan yang sering muncul adalah bagaimana menerapkan penyortiran.  Dan kemudian Anda berbicara tentang beberapa versi dasar penyortiran cepat, yang sebenarnya tidak digunakan sama sekali di mana pun di dunia, karena itu bisa sangat lambat dalam kasus-kasus tertentu.  Pustaka standar tidak mengizinkannya untuk digunakan, karena membutuhkan N log yang dijamin N, dan pengurutan yang cepat tidak bisa.  Sebagian besar bisa, tetapi standar di tempat ini sangat ketat, dan tidak berarti akumulasi N log N, itu harus murni N log N, dan bagaimana Anda mengimplementasikan algoritma seperti itu?  Anda perlu melakukan penelitian, menemukan banyak optimasi berbeda untuk penyortiran cepat, dan menggabungkannya menjadi satu algoritma yang terdiri dari setidaknya tiga algoritma yang berbeda, seperti yang dilakukan di libstdc ++.  Ini adalah arti dari perpustakaan standar - Anda tidak perlu tahu semua hal ini untuk diprogram.  Tidak perlu mencari tahu bagaimana mengimplementasikan semuanya dengan cara yang paling efisien, orang lain sudah mengurus ini untuk Anda.  Karenanya, saya tidak suka pendekatan ini ketika orang berkata: "STL sangat rumit, jangan gunakan dan tulis semuanya dari awal secara manual." </p><br><p>  <strong>Sergey:</strong> Kami mendekati akhir wawancara, jadi pertanyaan terakhir: bagaimana Anda suka di Rusia? </p><br><p>  <strong>Alexander: Semakin</strong> dingin. </p><br><p>  <strong>Sergey:</strong> Bahkan untukmu?  Anda orang lokal! </p><br><p>  <strong>Ivan:</strong> Tapi bagi saya itu jauh lebih hangat dari yang diharapkan. </p><br><p>  <strong>Sergey:</strong> Sekarang sudah -16, dan kami sudah bilang -40. </p><br><p>  <strong>Ivan:</strong> Ya, Anda berjanji!  Saya khusus disiapkan untuk minus empat puluh.  Dan kemudian saya melihat termometer, dan di sana semuanya lebih hangat dan lebih hangat. </p><br><p>  <strong>Sergey:</strong> Nah, sekarang kita hanya akan bertemu di C ++ Russia 2019, itu akan di Moskow, dan akan ada suhu plus.  Terima kasih untuk wawancaranya dan sampai jumpa lagi! </p><br><blockquote>  Menit periklanan.  Pada 19-20 April, sebuah konferensi Rusia C ++ akan diadakan, di mana Ivan akan membuat presentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Desain C ++ yang hanya bergerak”</a> , dan Alexander akan berbicara tentang pengurai monadik.  Selain itu, Ivan akan mengadakan satu dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga pelatihan besar</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Pemrograman fungsional terapan dalam C ++”</a> .  Sebulan tersisa sebelum konferensi dan program terus disempurnakan.  Di situs web resmi Anda dapat melihat laporan mana yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah masuk ke program</a> dan membeli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket</a> .  Harap dicatat bahwa ada berbagai jenis tiket, dan memilih tiket yang tepat dapat menghemat banyak. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444212/">https://habr.com/ru/post/id444212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444198/index.html">Sinkronisasi batas Dropbox: sekarang hanya 3 perangkat</a></li>
<li><a href="../id444200/index.html">Sesi Pemecahan Masalah</a></li>
<li><a href="../id444204/index.html">Memperkenalkan Pengujian dengan Python. Bagian 3</a></li>
<li><a href="../id444206/index.html">27 Maret, Moskow - JavaScript MeetUP</a></li>
<li><a href="../id444208/index.html">Mengapa bisnis memerlukan kode yang baik?</a></li>
<li><a href="../id444214/index.html">Bagaimana Kiwi.com menguji 1000 proyek Python</a></li>
<li><a href="../id444216/index.html">Moscow Python Conf ++ dalam tiga hari: apa yang akan dibicarakan Bobuk dan siapa yang akan tampil di ruang paralel saat ini?</a></li>
<li><a href="../id444220/index.html">Bagaimana Kiwi menguji 1'000 proyek Python</a></li>
<li><a href="../id444222/index.html">Di sekitar musuh. Cara paranoid merencanakan pekerjaan Anda</a></li>
<li><a href="../id444226/index.html">@Pythonetc kompilasi februari 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>