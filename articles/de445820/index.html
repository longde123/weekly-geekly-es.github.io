<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë üë®üèø‚Äçüöí ‚úãüèº MVCC-3. Zeilenversionen üòù üìó ‚úçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns also mit Fragen im Zusammenhang mit der Isolation befasst und einen Exkurs √ºber die Organisation von Daten auf niedriger Ebene gemacht ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Zeilenversionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Wir haben uns also mit Fragen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation befasst</a> und einen Exkurs √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisation von Daten auf niedriger Ebene gemacht</a> .  Und schlie√ülich zum interessantesten - zur Version der Zeilen. <br><br><h1>  √úberschrift </h1><br>  Wie bereits erw√§hnt, kann jede Zeile in mehreren Versionen gleichzeitig in der Datenbank vorhanden sein.  Eine Version muss irgendwie von der anderen unterschieden werden. Zu diesem Zweck hat jede Version zwei Markierungen, die die "Zeit" der Aktion dieser Version bestimmen (xmin und xmax).  In Anf√ºhrungszeichen - weil nicht die Zeit als solche verwendet wird, sondern ein spezieller Inkrementierungsz√§hler.  Und dieser Z√§hler ist die Transaktionsnummer. <br><br>  (Wie √ºblich ist es tats√§chlich komplizierter: Die Transaktionsnummer kann aufgrund der begrenzten Bitkapazit√§t des Z√§hlers nicht st√§ndig erh√∂ht werden. Wir werden diese Details jedoch im Detail betrachten, wenn wir zum Einfrieren kommen.) <br><a name="habracut"></a><br>  Beim Erstellen der Zeile wird xmin auf die Nummer der Transaktion festgelegt, die den Befehl INSERT ausgef√ºhrt hat, und xmax wird nicht ausgef√ºllt. <br><br>  Wenn eine Zeile gel√∂scht wird, wird der xmax-Wert der aktuellen Version mit der Transaktionsnummer markiert, die DELETE ausgef√ºhrt hat. <br><br>  Wenn eine Zeile mit dem Befehl UPDATE ge√§ndert wird, werden tats√§chlich zwei Operationen ausgef√ºhrt: DELETE und INSERT.  In der aktuellen Version der Zeile wird xmax gleich der Nummer der Transaktion gesetzt, die UPDATE ausgef√ºhrt hat.  Dann wird eine neue Version derselben Zeile erstellt.  Der xmin-Wert entspricht dem xmax-Wert der vorherigen Version. <br><br>  Die Felder xmin und xmax sind im Zeilenversionsheader enthalten.  Zus√§tzlich zu diesen Feldern enth√§lt der Header weitere, zum Beispiel: <br><br><ul><li>  Infomask - Eine Reihe von Bits, die die Eigenschaften dieser Version definieren.  Es gibt ziemlich viele von ihnen;  Die wichtigsten werden wir nach und nach betrachten. </li><li>  ctid - ein Link zur n√§chsten, neueren Version derselben Zeile.  In der neuesten, aktuellsten Version der Zeichenfolge bezieht sich ctid auf diese Version selbst.  Die Nummer hat die Form (x, y), wobei x die Seitenzahl und y die Seriennummer des Zeigers im Array ist. </li><li>  Bitmap undefinierter Werte - Markiert die Spalten dieser Version, die einen undefinierten Wert (NULL) enthalten.  NULL ist nicht einer der √ºblichen Werte von Datentypen, daher muss das Attribut separat gespeichert werden. </li></ul><br>  Infolgedessen ist der Header ziemlich gro√ü - mindestens 23 Bytes pro Version der Zeichenfolge und normalerweise mehr aufgrund der NULL-Bitmap.  Wenn die Tabelle "eng" ist (dh nur wenige Spalten enth√§lt), kann der Overhead mehr als n√ºtzliche Informationen erfordern. <br><br><h1>  Einf√ºgen </h1><br>  Schauen wir uns genauer an, wie Zeichenfolgenoperationen auf niedriger Ebene ausgef√ºhrt werden, und beginnen wir mit dem Einf√ºgen. <br><br>  Erstellen Sie f√ºr Experimente eine neue Tabelle mit zwei Spalten und einem Index f√ºr eine davon: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  F√ºgen Sie nach dem Start der Transaktion eine Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Hier ist die Nummer unserer aktuellen Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Schauen Sie sich den Inhalt der Seite an  Die Funktion heap_page_items der Erweiterung pageinspect bietet Informationen zu Zeigern und Zeilenversionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Beachten Sie, dass sich das Wort Heap (Heap) in PostgreSQL auf Tabellen bezieht.  Dies ist eine weitere seltsame Verwendung des Begriffs - Heap ist eine bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenstruktur</a> , die nichts mit einer Tabelle zu tun hat.  Hier wird dieses Wort im Gegensatz zu geordneten Indizes im Sinne von "alles ist auf einem Haufen gestapelt" verwendet. <br><br>  Die Funktion zeigt Daten "wie sie sind" in einem schwer lesbaren Format an.  Um dies zu verstehen, lassen wir nur einen Teil der Informationen und entschl√ºsseln sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Folgendes haben wir getan: <br><br><ul><li>  Wir haben der Indexnummer eine Null hinzugef√ºgt, um sie in die gleiche Form wie t_ctid zu bringen: (Seitenzahl, Indexnummer). </li><li>  Entschl√ºsselt den Status des Zeigers lp_flags.  Hier ist es "normal" - das bedeutet, dass der Zeiger wirklich auf die Version der Zeichenfolge verweist.  Andere Werte werden sp√§ter ber√ºcksichtigt. </li><li>  Von allen Informationsbits wurden bisher nur zwei Paare zugeordnet.  Die Bits xmin_committed und xmin_aborted geben an, ob die Transaktion mit der xmin-Nummer festgeschrieben (abgebrochen) wird.  Zwei √§hnliche Bits beziehen sich auf die Transaktionsnummer xmax. </li></ul><br>  Was sehen wir?  Wenn Sie eine Zeile in die Tabellenseite einf√ºgen, wird ein Zeiger mit der Nummer 1 angezeigt, der auf die erste und einzige Version der Zeile verweist. <br><br>  In der Version der Zeile wird das Feld xmin mit der Nummer der aktuellen Transaktion gef√ºllt.  Die Transaktion ist noch aktiv, sodass beide Bits xmin_committed und xmin_aborted nicht gesetzt sind. <br><br>  Das Feld ctid der Zeilenversion bezieht sich auf dieselbe Zeile.  Dies bedeutet, dass keine neuere Version vorhanden ist. <br><br>  Das xmax-Feld wird mit einer Dummy-Nummer 0 gef√ºllt, da diese Version der Zeile nicht gel√∂scht wird und relevant ist.  Transaktionen ber√ºcksichtigen diese Nummer nicht, da das Bit xmax_aborted gesetzt ist. <br><br>  Machen wir noch einen Schritt, um die Lesbarkeit zu verbessern, indem wir den Transaktionsnummern Informationsbits hinzuf√ºgen.  Und wir werden eine Funktion erstellen, da wir die Anfrage mehr als einmal ben√∂tigen werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  In dieser Form ist viel klarer, was in der Kopfzeile der Version der Zeichenfolge passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  √Ñhnliche, aber wesentlich weniger detaillierte Informationen k√∂nnen aus der Tabelle selbst unter Verwendung der Pseudospalten xmin und xmax erhalten werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fixierung </h1><br>  Nach erfolgreichem Abschluss der Transaktion m√ºssen Sie sich ihren Status merken - beachten Sie, dass sie behoben ist.  Verwenden Sie dazu eine Struktur namens XACT (und vor Version 10 hie√ü sie CLOG (Commit Log) und dieser Name befindet sich immer noch an verschiedenen Stellen). <br><br>  XACT ist keine Systemkatalogtabelle.  Dies sind die Dateien im Verzeichnis PGDATA / pg_xact.  In ihnen werden f√ºr jede Transaktion zwei Bits zugewiesen: festgeschrieben und abgebrochen - genau wie im Header der Version der Zeile.  Diese Informationen sind nur der Einfachheit halber in mehrere Dateien unterteilt. Wir werden auf dieses Problem zur√ºckkommen, wenn wir das Einfrieren in Betracht ziehen.  Und die Arbeit mit diesen Dateien wird wie bei allen anderen Seite f√ºr Seite ausgef√ºhrt. <br><br>  Wenn Sie also eine Transaktion in XACT festschreiben, wird das festgeschriebene Bit f√ºr diese Transaktion gesetzt.  Und das ist alles, was w√§hrend des Commits passiert (obwohl wir noch nicht √ºber das Voraufzeichnungsjournal sprechen). <br><br>  Wenn eine andere Transaktion auf die gerade betrachtete Tabellenseite zugreift, muss sie einige Fragen beantworten. <br><br><ol><li>  Wurde die Transaktion xmin abgeschlossen?  Wenn nicht, sollte die generierte Version der Zeichenfolge nicht sichtbar sein. <br>  Eine solche √úberpr√ºfung wird durchgef√ºhrt, indem eine weitere Struktur betrachtet wird, die sich im gemeinsam genutzten Speicher der Instanz befindet und als ProcArray bezeichnet wird.  Es enth√§lt eine Liste aller aktiven Prozesse und f√ºr jeden wird die Nummer seiner aktuellen (aktiven) Transaktion angegeben. </li><li>  Wenn abgeschlossen, wie - durch Fixierung oder Stornierung?  Wenn abgebrochen, sollte auch die Version der Zeichenfolge nicht sichtbar sein. <br>  Genau daf√ºr ist XACT gedacht.  Obwohl die letzten XACT-Seiten in Puffern im RAM gespeichert sind, muss der XACT nicht jedes Mal √ºberpr√ºft werden.  Daher wird der Status einer einmal gekl√§rten Transaktion in den Bits xmin_committed und xmin_aborted der Zeilenversion aufgezeichnet.  Wenn eines dieser Bits gesetzt ist, wird der Status der Transaktion xmin als bekannt angesehen und die n√§chste Transaktion muss nicht mehr auf XACT zugreifen. </li></ol><br>  Warum werden diese Bits nicht von der Transaktion selbst gesetzt, die das Einf√ºgen durchf√ºhrt?  Wenn eine Einf√ºgung erfolgt, wei√ü die Transaktion noch nicht, ob sie erfolgreich abgeschlossen wird.  Und zum Zeitpunkt der Korrektur ist bereits nicht klar, welche Zeilen auf welchen Seiten ge√§ndert wurden.  Es kann viele solcher Seiten geben, und das Auswendiglernen ist nachteilig.  Au√üerdem kann ein Teil der Seiten aus dem Puffercache auf die Festplatte verschoben werden.  Ein erneutes Lesen, um die Bits zu √§ndern, w√ºrde bedeuten, dass das Festschreiben erheblich verlangsamt wird. <br><br>  Der Nachteil der Einsparungen besteht darin, dass nach den √Ñnderungen bei jeder Transaktion (auch beim einfachen Lesen - SELECT) die Datenseiten im Puffercache ge√§ndert werden k√∂nnen. <br><br>  Korrigieren Sie also die √Ñnderung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Auf der Seite hat sich nichts ge√§ndert (aber wir wissen, dass der Transaktionsstatus bereits in XACT aufgezeichnet wurde): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Jetzt muss die Transaktion, die zuerst auf die Seite zugreift, den Transaktionsstatus xmin ermitteln und in die Informationsbits schreiben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  L√∂schen </h1><br>  Wenn eine Zeile gel√∂scht wird, wird die Nummer der aktuellen L√∂schtransaktion im Feld xmax der aktuellen Version aufgezeichnet und das Bit xmax_aborted zur√ºckgesetzt. <br><br>  Beachten Sie, dass der festgelegte xmax-Wert, der der aktiven Transaktion entspricht, als Zeilensperre fungiert.  Wenn eine andere Transaktion diese Zeile aktualisieren oder l√∂schen soll, muss sie warten, bis die xmax-Transaktion abgeschlossen ist.  Wir werden sp√§ter mehr √ºber Schl√∂sser sprechen.  Im Moment stellen wir nur fest, dass die Anzahl der Zeilensperren unbegrenzt ist.  Sie nehmen keinen Platz im RAM ein und die Systemleistung leidet nicht unter ihrer Menge.  Zwar haben ‚Äûlange‚Äú Transaktionen andere Nachteile, aber dazu sp√§ter mehr. <br><br>  L√∂schen Sie die Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Wir sehen, dass die Transaktionsnummer im xmax-Feld aufgezeichnet ist, aber die Informationsbits nicht gesetzt sind: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abbrechen </h1><br>  Das Zur√ºcksetzen von √Ñnderungen funktioniert √§hnlich wie das Festschreiben, nur in XACT wird f√ºr die Transaktion das abgebrochene Bit gesetzt.  Die Stornierung erfolgt so schnell wie das Festschreiben.  Obwohl der Befehl ROLLBACK hei√üt, wird die √Ñnderung nicht zur√ºckgesetzt: Alles, was die Transaktion auf den Datenseiten √§ndern konnte, bleibt unver√§ndert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Beim Zugriff auf die Seite wird der Status √ºberpr√ºft und das Hinweisbit xmax_aborted in der Version der Zeile gesetzt.  Die xmax-Nummer selbst bleibt auf der Seite, aber niemand wird sie ansehen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Update </h1><br>  Das Update funktioniert so, als w√ºrde zuerst die aktuelle Version der Zeile gel√∂scht und dann eine neue eingef√ºgt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  Die Anfrage erzeugt eine Zeile (neue Version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Aber auf der Seite sehen wir beide Versionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Die Remote-Version ist mit der aktuellen Transaktionsnummer im Feld xmax gekennzeichnet.  Au√üerdem wird dieser Wert √ºber den alten geschrieben, da die vorherige Transaktion abgebrochen wurde.  Das Bit xmax_aborted wird zur√ºckgesetzt, da der Status der aktuellen Transaktion noch unbekannt ist. <br><br>  Die erste Version der Zeile bezieht sich jetzt auf die zweite (t_ctid-Feld) als neuere. <br><br>  Auf der Indexseite werden ein zweiter Zeiger und eine zweite Zeile angezeigt, die auf die zweite Version der Tabellenseite verweisen. <br><br>  Wie beim L√∂schen ist der xmax-Wert in der ersten Version der Zeichenfolge ein Zeichen daf√ºr, dass die Zeichenfolge gesperrt ist. <br><br>  Nun, schlie√üen Sie die Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indizes </h1><br>  Bisher haben wir nur √ºber Tabellenseiten gesprochen.  Und was passiert innerhalb der Indizes? <br><br>  Die Informationen auf den Indexseiten h√§ngen stark vom jeweiligen Indextyp ab.  Und selbst ein Indextyp hat unterschiedliche Seitentypen.  Zum Beispiel hat der B-Baum eine Seite mit Metadaten und "regul√§ren" Seiten. <br><br>  Eine Seite hat jedoch normalerweise ein Array von Zeigern auf die Zeilen und die Zeilen selbst (genau wie auf einer Tabellenseite).  Au√üerdem befindet sich am Ende der Seite ein Platz f√ºr spezielle Daten. <br><br>  Zeilen in Indizes k√∂nnen je nach Indextyp auch eine sehr unterschiedliche Struktur haben.  Bei einem B-Baum enthalten Zeilen, die sich auf Blattseiten beziehen, beispielsweise den Wert des Indexschl√ºssels und einen Link (ctid) zur entsprechenden Zeile der Tabelle.  Im Allgemeinen kann ein Index ganz anders angeordnet werden. <br><br>  Der wichtigste Punkt ist, dass es in keinem Indextyp Zeilenversionen gibt.  Nun, oder wir k√∂nnen davon ausgehen, dass jede Zeile durch genau eine Version dargestellt wird.  Mit anderen Worten, die Kopfzeile der Indexzeile enth√§lt keine xmin- und xmax-Felder.  Wir k√∂nnen davon ausgehen, dass die Links aus dem Index zu allen tabellarischen Versionen der Zeilen f√ºhren. Sie k√∂nnen also nur herausfinden, welche Version die Transaktion sehen wird, wenn Sie sich die Tabelle ansehen.  (Wie √ºblich ist dies nicht die ganze Wahrheit. In einigen F√§llen k√∂nnen Sie mit der Sichtbarkeitskarte den Prozess optimieren, wir werden dies jedoch sp√§ter genauer betrachten.) <br><br>  Gleichzeitig finden wir auf der Indexseite Zeiger auf beide Versionen, sowohl die aktuelle als auch die alte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Virtuelle Transaktionen </h1><br>  In der Praxis verwendet PostgreSQL Optimierungen, um Transaktionsnummern zu ‚Äûspeichern‚Äú. <br><br>  Wenn eine Transaktion nur Daten liest, hat dies keine Auswirkungen auf die Sichtbarkeit von Zeilenversionen.  Daher gibt der Serving-Prozess zun√§chst eine Transaktion mit einer virtuellen Nummer (Virtual XID) aus.  Die Nummer besteht aus einer Prozesskennung und einer fortlaufenden Nummer. <br><br>  Die Ausgabe dieser Nummer erfordert keine Synchronisation zwischen allen Prozessen und ist daher sehr schnell.  Wir werden einen weiteren Grund f√ºr die Verwendung virtueller Zahlen kennenlernen, wenn wir √ºber das Einfrieren sprechen. <br><br>  Virtuelle Nummern werden in Datenschnappsch√ºssen nicht ber√ºcksichtigt. <br><br>  Zu verschiedenen Zeitpunkten werden m√∂glicherweise virtuelle Transaktionen mit bereits verwendeten Nummern im System angezeigt, und dies ist normal.  Eine solche Nummer kann jedoch nicht auf Datenseiten geschrieben werden, da sie beim n√§chsten Zugriff auf die Seite m√∂glicherweise an Bedeutung verliert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Wenn die Transaktion beginnt, Daten zu √§ndern, erh√§lt sie eine echte, eindeutige Transaktionsnummer. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Verschachtelte Transaktionen </h1><br><h2>  Punkte speichern </h2><br>  SQL definiert Sicherungspunkte, mit denen Sie einen Teil einer Transaktion r√ºckg√§ngig machen k√∂nnen, ohne sie vollst√§ndig zu unterbrechen.  Dies passt jedoch nicht in das obige Schema, da der Status einer Transaktion f√ºr alle √Ñnderungen eins ist und physisch keine Daten zur√ºckgesetzt werden. <br><br>  Um eine solche Funktionalit√§t zu implementieren, wird eine Transaktion mit einem Speicherpunkt in mehrere separate <em>verschachtelte Transaktionen</em> (Subtransaktion) unterteilt, deren Status separat gesteuert werden kann. <br><br>  Verschachtelte Transaktionen haben eine eigene Nummer (h√∂her als die Haupttransaktionsnummer).  Der Status verschachtelter Transaktionen wird in XACT wie gewohnt aufgezeichnet. Der endg√ºltige Status h√§ngt jedoch vom Status der Haupttransaktion ab: Wenn diese abgebrochen wird, werden auch alle verschachtelten Transaktionen abgebrochen. <br><br>  Informationen zur Verschachtelung von Transaktionen werden in Dateien im Verzeichnis PGDATA / pg_subtrans gespeichert.  Der Zugriff auf Dateien erfolgt √ºber Puffer im gemeinsam genutzten Speicher der Instanz, die wie XACT-Puffer organisiert sind. <br><br>  Verwechseln Sie nicht verschachtelte Transaktionen und autonome Transaktionen.  Autonome Transaktionen sind in keiner Weise voneinander abh√§ngig, und verschachtelte Transaktionen sind abh√§ngig.  Es gibt keine autonomen Transaktionen im √ºblichen PostgreSQL, und vielleicht zum Besseren: Wenn sie sehr, sehr selten ben√∂tigt werden und ihre Anwesenheit in anderen DBMS Missbrauch hervorruft, unter dem dann jeder leidet. <br><br>  L√∂schen Sie die Tabelle, starten Sie die Transaktion und f√ºgen Sie die Zeile ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Setzen Sie nun einen Sicherungspunkt und f√ºgen Sie eine weitere Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Beachten Sie, dass die Funktion txid_current () die Nummer der nicht verschachtelten Haupttransaktion zur√ºckgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Wir rollen zur√ºck zum Speicherpunkt und f√ºgen die dritte Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Auf der Seite sehen wir weiterhin die Zeile, die durch die abgebrochene verschachtelte Transaktion hinzugef√ºgt wurde. <br><br>  Wir korrigieren die √Ñnderungen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Jetzt k√∂nnen Sie deutlich sehen, dass jede verschachtelte Transaktion ihren eigenen Status hat. <br><br>  Beachten Sie, dass verschachtelte Transaktionen in SQL nicht explizit verwendet werden k√∂nnen. Sie k√∂nnen also keine neue Transaktion starten, ohne die aktuelle abzuschlie√üen.  Dieser Mechanismus wird implizit bei der Verwendung von Sicherungspunkten sowie bei der Behandlung von PL / pgSQL-Ausnahmen und in einer Reihe anderer, exotischerer F√§lle verwendet. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Fehler und Atomizit√§t von Operationen </h2><br>  Was passiert, wenn w√§hrend des Vorgangs ein Fehler auftritt?  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Ein Fehler ist aufgetreten.  Jetzt wird die Transaktion als abgebrochen betrachtet und es ist keine einzige Operation darin zul√§ssig: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Und selbst wenn Sie versuchen, die √Ñnderungen zu √ºbernehmen, meldet PostgreSQL die Stornierung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Warum kann ich die Transaktion nach einem Fehler nicht fortsetzen?  Tatsache ist, dass ein Fehler auftreten kann, so dass wir Zugriff auf einen Teil der √Ñnderungen erhalten - die Atomizit√§t nicht einmal der Transaktion, aber der Operator w√ºrde verletzt.  Wie in unserem Beispiel, in dem es dem Bediener gelungen ist, eine Zeile vor dem Fehler zu aktualisieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Ich muss sagen, dass es in psql einen Modus gibt, in dem Sie die Transaktion nach einem Fehler weiterhin fortsetzen k√∂nnen, als ob die Aktionen des fehlerhaften Operators zur√ºckgesetzt w√ºrden. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Es ist leicht zu erraten, dass psql in diesem Modus tats√§chlich einen impliziten Speicherpunkt vor jedem Befehl setzt und im Fehlerfall einen Rollback darauf initiiert.  Dieser Modus wird standardm√§√üig nicht verwendet, da das Festlegen von Speicherpunkten (auch ohne ein Zur√ºcksetzen auf diese) mit einem erheblichen Overhead verbunden ist. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445820/">https://habr.com/ru/post/de445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445804/index.html">Kapselung f√ºr echte Samurai oder die Nuancen, die mit dem internen Schl√ºsselwort in C # verbunden sind</a></li>
<li><a href="../de445806/index.html">Wie k√ºnstliche Intelligenz die Wissenschaft ver√§ndert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gef√§hrliche Leben eines Virus-Crackers, der sich m√§chtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten ver√§ndert hat</a></li>
<li><a href="../de445816/index.html">Wie wir Server-Rendering gesehen haben und was daraus wurde</a></li>
<li><a href="../de445822/index.html">Warum Jaop? Warum Schl√§ger?</a></li>
<li><a href="../de445824/index.html">Codegenerierung in Dart. Teil 1. Grundlagen</a></li>
<li><a href="../de445826/index.html">Wir gehen mit Bedacht durch die Stadt - 2: Gehen wir mit dem genetischen Algorithmus im Kreis durch die Stadt</a></li>
<li><a href="../de445828/index.html">Chinesisches Sonnenspektrum</a></li>
<li><a href="../de445832/index.html">Strahlung: der unsichtbare M√∂rder und seine T√∂chter oder ein bisschen √ºber Radon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>