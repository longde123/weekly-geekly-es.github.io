<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 👨🏿‍🚒 ✋🏼 MVCC-3. Zeilenversionen 😝 📗 ✍️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns also mit Fragen im Zusammenhang mit der Isolation befasst und einen Exkurs über die Organisation von Daten auf niedriger Ebene gemacht ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Zeilenversionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Wir haben uns also mit Fragen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation befasst</a> und einen Exkurs über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisation von Daten auf niedriger Ebene gemacht</a> .  Und schließlich zum interessantesten - zur Version der Zeilen. <br><br><h1>  Überschrift </h1><br>  Wie bereits erwähnt, kann jede Zeile in mehreren Versionen gleichzeitig in der Datenbank vorhanden sein.  Eine Version muss irgendwie von der anderen unterschieden werden. Zu diesem Zweck hat jede Version zwei Markierungen, die die "Zeit" der Aktion dieser Version bestimmen (xmin und xmax).  In Anführungszeichen - weil nicht die Zeit als solche verwendet wird, sondern ein spezieller Inkrementierungszähler.  Und dieser Zähler ist die Transaktionsnummer. <br><br>  (Wie üblich ist es tatsächlich komplizierter: Die Transaktionsnummer kann aufgrund der begrenzten Bitkapazität des Zählers nicht ständig erhöht werden. Wir werden diese Details jedoch im Detail betrachten, wenn wir zum Einfrieren kommen.) <br><a name="habracut"></a><br>  Beim Erstellen der Zeile wird xmin auf die Nummer der Transaktion festgelegt, die den Befehl INSERT ausgeführt hat, und xmax wird nicht ausgefüllt. <br><br>  Wenn eine Zeile gelöscht wird, wird der xmax-Wert der aktuellen Version mit der Transaktionsnummer markiert, die DELETE ausgeführt hat. <br><br>  Wenn eine Zeile mit dem Befehl UPDATE geändert wird, werden tatsächlich zwei Operationen ausgeführt: DELETE und INSERT.  In der aktuellen Version der Zeile wird xmax gleich der Nummer der Transaktion gesetzt, die UPDATE ausgeführt hat.  Dann wird eine neue Version derselben Zeile erstellt.  Der xmin-Wert entspricht dem xmax-Wert der vorherigen Version. <br><br>  Die Felder xmin und xmax sind im Zeilenversionsheader enthalten.  Zusätzlich zu diesen Feldern enthält der Header weitere, zum Beispiel: <br><br><ul><li>  Infomask - Eine Reihe von Bits, die die Eigenschaften dieser Version definieren.  Es gibt ziemlich viele von ihnen;  Die wichtigsten werden wir nach und nach betrachten. </li><li>  ctid - ein Link zur nächsten, neueren Version derselben Zeile.  In der neuesten, aktuellsten Version der Zeichenfolge bezieht sich ctid auf diese Version selbst.  Die Nummer hat die Form (x, y), wobei x die Seitenzahl und y die Seriennummer des Zeigers im Array ist. </li><li>  Bitmap undefinierter Werte - Markiert die Spalten dieser Version, die einen undefinierten Wert (NULL) enthalten.  NULL ist nicht einer der üblichen Werte von Datentypen, daher muss das Attribut separat gespeichert werden. </li></ul><br>  Infolgedessen ist der Header ziemlich groß - mindestens 23 Bytes pro Version der Zeichenfolge und normalerweise mehr aufgrund der NULL-Bitmap.  Wenn die Tabelle "eng" ist (dh nur wenige Spalten enthält), kann der Overhead mehr als nützliche Informationen erfordern. <br><br><h1>  Einfügen </h1><br>  Schauen wir uns genauer an, wie Zeichenfolgenoperationen auf niedriger Ebene ausgeführt werden, und beginnen wir mit dem Einfügen. <br><br>  Erstellen Sie für Experimente eine neue Tabelle mit zwei Spalten und einem Index für eine davon: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  Fügen Sie nach dem Start der Transaktion eine Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Hier ist die Nummer unserer aktuellen Transaktion: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Schauen Sie sich den Inhalt der Seite an  Die Funktion heap_page_items der Erweiterung pageinspect bietet Informationen zu Zeigern und Zeilenversionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Beachten Sie, dass sich das Wort Heap (Heap) in PostgreSQL auf Tabellen bezieht.  Dies ist eine weitere seltsame Verwendung des Begriffs - Heap ist eine bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenstruktur</a> , die nichts mit einer Tabelle zu tun hat.  Hier wird dieses Wort im Gegensatz zu geordneten Indizes im Sinne von "alles ist auf einem Haufen gestapelt" verwendet. <br><br>  Die Funktion zeigt Daten "wie sie sind" in einem schwer lesbaren Format an.  Um dies zu verstehen, lassen wir nur einen Teil der Informationen und entschlüsseln sie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Folgendes haben wir getan: <br><br><ul><li>  Wir haben der Indexnummer eine Null hinzugefügt, um sie in die gleiche Form wie t_ctid zu bringen: (Seitenzahl, Indexnummer). </li><li>  Entschlüsselt den Status des Zeigers lp_flags.  Hier ist es "normal" - das bedeutet, dass der Zeiger wirklich auf die Version der Zeichenfolge verweist.  Andere Werte werden später berücksichtigt. </li><li>  Von allen Informationsbits wurden bisher nur zwei Paare zugeordnet.  Die Bits xmin_committed und xmin_aborted geben an, ob die Transaktion mit der xmin-Nummer festgeschrieben (abgebrochen) wird.  Zwei ähnliche Bits beziehen sich auf die Transaktionsnummer xmax. </li></ul><br>  Was sehen wir?  Wenn Sie eine Zeile in die Tabellenseite einfügen, wird ein Zeiger mit der Nummer 1 angezeigt, der auf die erste und einzige Version der Zeile verweist. <br><br>  In der Version der Zeile wird das Feld xmin mit der Nummer der aktuellen Transaktion gefüllt.  Die Transaktion ist noch aktiv, sodass beide Bits xmin_committed und xmin_aborted nicht gesetzt sind. <br><br>  Das Feld ctid der Zeilenversion bezieht sich auf dieselbe Zeile.  Dies bedeutet, dass keine neuere Version vorhanden ist. <br><br>  Das xmax-Feld wird mit einer Dummy-Nummer 0 gefüllt, da diese Version der Zeile nicht gelöscht wird und relevant ist.  Transaktionen berücksichtigen diese Nummer nicht, da das Bit xmax_aborted gesetzt ist. <br><br>  Machen wir noch einen Schritt, um die Lesbarkeit zu verbessern, indem wir den Transaktionsnummern Informationsbits hinzufügen.  Und wir werden eine Funktion erstellen, da wir die Anfrage mehr als einmal benötigen werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  In dieser Form ist viel klarer, was in der Kopfzeile der Version der Zeichenfolge passiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Ähnliche, aber wesentlich weniger detaillierte Informationen können aus der Tabelle selbst unter Verwendung der Pseudospalten xmin und xmax erhalten werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fixierung </h1><br>  Nach erfolgreichem Abschluss der Transaktion müssen Sie sich ihren Status merken - beachten Sie, dass sie behoben ist.  Verwenden Sie dazu eine Struktur namens XACT (und vor Version 10 hieß sie CLOG (Commit Log) und dieser Name befindet sich immer noch an verschiedenen Stellen). <br><br>  XACT ist keine Systemkatalogtabelle.  Dies sind die Dateien im Verzeichnis PGDATA / pg_xact.  In ihnen werden für jede Transaktion zwei Bits zugewiesen: festgeschrieben und abgebrochen - genau wie im Header der Version der Zeile.  Diese Informationen sind nur der Einfachheit halber in mehrere Dateien unterteilt. Wir werden auf dieses Problem zurückkommen, wenn wir das Einfrieren in Betracht ziehen.  Und die Arbeit mit diesen Dateien wird wie bei allen anderen Seite für Seite ausgeführt. <br><br>  Wenn Sie also eine Transaktion in XACT festschreiben, wird das festgeschriebene Bit für diese Transaktion gesetzt.  Und das ist alles, was während des Commits passiert (obwohl wir noch nicht über das Voraufzeichnungsjournal sprechen). <br><br>  Wenn eine andere Transaktion auf die gerade betrachtete Tabellenseite zugreift, muss sie einige Fragen beantworten. <br><br><ol><li>  Wurde die Transaktion xmin abgeschlossen?  Wenn nicht, sollte die generierte Version der Zeichenfolge nicht sichtbar sein. <br>  Eine solche Überprüfung wird durchgeführt, indem eine weitere Struktur betrachtet wird, die sich im gemeinsam genutzten Speicher der Instanz befindet und als ProcArray bezeichnet wird.  Es enthält eine Liste aller aktiven Prozesse und für jeden wird die Nummer seiner aktuellen (aktiven) Transaktion angegeben. </li><li>  Wenn abgeschlossen, wie - durch Fixierung oder Stornierung?  Wenn abgebrochen, sollte auch die Version der Zeichenfolge nicht sichtbar sein. <br>  Genau dafür ist XACT gedacht.  Obwohl die letzten XACT-Seiten in Puffern im RAM gespeichert sind, muss der XACT nicht jedes Mal überprüft werden.  Daher wird der Status einer einmal geklärten Transaktion in den Bits xmin_committed und xmin_aborted der Zeilenversion aufgezeichnet.  Wenn eines dieser Bits gesetzt ist, wird der Status der Transaktion xmin als bekannt angesehen und die nächste Transaktion muss nicht mehr auf XACT zugreifen. </li></ol><br>  Warum werden diese Bits nicht von der Transaktion selbst gesetzt, die das Einfügen durchführt?  Wenn eine Einfügung erfolgt, weiß die Transaktion noch nicht, ob sie erfolgreich abgeschlossen wird.  Und zum Zeitpunkt der Korrektur ist bereits nicht klar, welche Zeilen auf welchen Seiten geändert wurden.  Es kann viele solcher Seiten geben, und das Auswendiglernen ist nachteilig.  Außerdem kann ein Teil der Seiten aus dem Puffercache auf die Festplatte verschoben werden.  Ein erneutes Lesen, um die Bits zu ändern, würde bedeuten, dass das Festschreiben erheblich verlangsamt wird. <br><br>  Der Nachteil der Einsparungen besteht darin, dass nach den Änderungen bei jeder Transaktion (auch beim einfachen Lesen - SELECT) die Datenseiten im Puffercache geändert werden können. <br><br>  Korrigieren Sie also die Änderung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Auf der Seite hat sich nichts geändert (aber wir wissen, dass der Transaktionsstatus bereits in XACT aufgezeichnet wurde): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Jetzt muss die Transaktion, die zuerst auf die Seite zugreift, den Transaktionsstatus xmin ermitteln und in die Informationsbits schreiben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Löschen </h1><br>  Wenn eine Zeile gelöscht wird, wird die Nummer der aktuellen Löschtransaktion im Feld xmax der aktuellen Version aufgezeichnet und das Bit xmax_aborted zurückgesetzt. <br><br>  Beachten Sie, dass der festgelegte xmax-Wert, der der aktiven Transaktion entspricht, als Zeilensperre fungiert.  Wenn eine andere Transaktion diese Zeile aktualisieren oder löschen soll, muss sie warten, bis die xmax-Transaktion abgeschlossen ist.  Wir werden später mehr über Schlösser sprechen.  Im Moment stellen wir nur fest, dass die Anzahl der Zeilensperren unbegrenzt ist.  Sie nehmen keinen Platz im RAM ein und die Systemleistung leidet nicht unter ihrer Menge.  Zwar haben „lange“ Transaktionen andere Nachteile, aber dazu später mehr. <br><br>  Löschen Sie die Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Wir sehen, dass die Transaktionsnummer im xmax-Feld aufgezeichnet ist, aber die Informationsbits nicht gesetzt sind: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abbrechen </h1><br>  Das Zurücksetzen von Änderungen funktioniert ähnlich wie das Festschreiben, nur in XACT wird für die Transaktion das abgebrochene Bit gesetzt.  Die Stornierung erfolgt so schnell wie das Festschreiben.  Obwohl der Befehl ROLLBACK heißt, wird die Änderung nicht zurückgesetzt: Alles, was die Transaktion auf den Datenseiten ändern konnte, bleibt unverändert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Beim Zugriff auf die Seite wird der Status überprüft und das Hinweisbit xmax_aborted in der Version der Zeile gesetzt.  Die xmax-Nummer selbst bleibt auf der Seite, aber niemand wird sie ansehen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Update </h1><br>  Das Update funktioniert so, als würde zuerst die aktuelle Version der Zeile gelöscht und dann eine neue eingefügt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  Die Anfrage erzeugt eine Zeile (neue Version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Aber auf der Seite sehen wir beide Versionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Die Remote-Version ist mit der aktuellen Transaktionsnummer im Feld xmax gekennzeichnet.  Außerdem wird dieser Wert über den alten geschrieben, da die vorherige Transaktion abgebrochen wurde.  Das Bit xmax_aborted wird zurückgesetzt, da der Status der aktuellen Transaktion noch unbekannt ist. <br><br>  Die erste Version der Zeile bezieht sich jetzt auf die zweite (t_ctid-Feld) als neuere. <br><br>  Auf der Indexseite werden ein zweiter Zeiger und eine zweite Zeile angezeigt, die auf die zweite Version der Tabellenseite verweisen. <br><br>  Wie beim Löschen ist der xmax-Wert in der ersten Version der Zeichenfolge ein Zeichen dafür, dass die Zeichenfolge gesperrt ist. <br><br>  Nun, schließen Sie die Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indizes </h1><br>  Bisher haben wir nur über Tabellenseiten gesprochen.  Und was passiert innerhalb der Indizes? <br><br>  Die Informationen auf den Indexseiten hängen stark vom jeweiligen Indextyp ab.  Und selbst ein Indextyp hat unterschiedliche Seitentypen.  Zum Beispiel hat der B-Baum eine Seite mit Metadaten und "regulären" Seiten. <br><br>  Eine Seite hat jedoch normalerweise ein Array von Zeigern auf die Zeilen und die Zeilen selbst (genau wie auf einer Tabellenseite).  Außerdem befindet sich am Ende der Seite ein Platz für spezielle Daten. <br><br>  Zeilen in Indizes können je nach Indextyp auch eine sehr unterschiedliche Struktur haben.  Bei einem B-Baum enthalten Zeilen, die sich auf Blattseiten beziehen, beispielsweise den Wert des Indexschlüssels und einen Link (ctid) zur entsprechenden Zeile der Tabelle.  Im Allgemeinen kann ein Index ganz anders angeordnet werden. <br><br>  Der wichtigste Punkt ist, dass es in keinem Indextyp Zeilenversionen gibt.  Nun, oder wir können davon ausgehen, dass jede Zeile durch genau eine Version dargestellt wird.  Mit anderen Worten, die Kopfzeile der Indexzeile enthält keine xmin- und xmax-Felder.  Wir können davon ausgehen, dass die Links aus dem Index zu allen tabellarischen Versionen der Zeilen führen. Sie können also nur herausfinden, welche Version die Transaktion sehen wird, wenn Sie sich die Tabelle ansehen.  (Wie üblich ist dies nicht die ganze Wahrheit. In einigen Fällen können Sie mit der Sichtbarkeitskarte den Prozess optimieren, wir werden dies jedoch später genauer betrachten.) <br><br>  Gleichzeitig finden wir auf der Indexseite Zeiger auf beide Versionen, sowohl die aktuelle als auch die alte: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Virtuelle Transaktionen </h1><br>  In der Praxis verwendet PostgreSQL Optimierungen, um Transaktionsnummern zu „speichern“. <br><br>  Wenn eine Transaktion nur Daten liest, hat dies keine Auswirkungen auf die Sichtbarkeit von Zeilenversionen.  Daher gibt der Serving-Prozess zunächst eine Transaktion mit einer virtuellen Nummer (Virtual XID) aus.  Die Nummer besteht aus einer Prozesskennung und einer fortlaufenden Nummer. <br><br>  Die Ausgabe dieser Nummer erfordert keine Synchronisation zwischen allen Prozessen und ist daher sehr schnell.  Wir werden einen weiteren Grund für die Verwendung virtueller Zahlen kennenlernen, wenn wir über das Einfrieren sprechen. <br><br>  Virtuelle Nummern werden in Datenschnappschüssen nicht berücksichtigt. <br><br>  Zu verschiedenen Zeitpunkten werden möglicherweise virtuelle Transaktionen mit bereits verwendeten Nummern im System angezeigt, und dies ist normal.  Eine solche Nummer kann jedoch nicht auf Datenseiten geschrieben werden, da sie beim nächsten Zugriff auf die Seite möglicherweise an Bedeutung verliert. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Wenn die Transaktion beginnt, Daten zu ändern, erhält sie eine echte, eindeutige Transaktionsnummer. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Verschachtelte Transaktionen </h1><br><h2>  Punkte speichern </h2><br>  SQL definiert Sicherungspunkte, mit denen Sie einen Teil einer Transaktion rückgängig machen können, ohne sie vollständig zu unterbrechen.  Dies passt jedoch nicht in das obige Schema, da der Status einer Transaktion für alle Änderungen eins ist und physisch keine Daten zurückgesetzt werden. <br><br>  Um eine solche Funktionalität zu implementieren, wird eine Transaktion mit einem Speicherpunkt in mehrere separate <em>verschachtelte Transaktionen</em> (Subtransaktion) unterteilt, deren Status separat gesteuert werden kann. <br><br>  Verschachtelte Transaktionen haben eine eigene Nummer (höher als die Haupttransaktionsnummer).  Der Status verschachtelter Transaktionen wird in XACT wie gewohnt aufgezeichnet. Der endgültige Status hängt jedoch vom Status der Haupttransaktion ab: Wenn diese abgebrochen wird, werden auch alle verschachtelten Transaktionen abgebrochen. <br><br>  Informationen zur Verschachtelung von Transaktionen werden in Dateien im Verzeichnis PGDATA / pg_subtrans gespeichert.  Der Zugriff auf Dateien erfolgt über Puffer im gemeinsam genutzten Speicher der Instanz, die wie XACT-Puffer organisiert sind. <br><br>  Verwechseln Sie nicht verschachtelte Transaktionen und autonome Transaktionen.  Autonome Transaktionen sind in keiner Weise voneinander abhängig, und verschachtelte Transaktionen sind abhängig.  Es gibt keine autonomen Transaktionen im üblichen PostgreSQL, und vielleicht zum Besseren: Wenn sie sehr, sehr selten benötigt werden und ihre Anwesenheit in anderen DBMS Missbrauch hervorruft, unter dem dann jeder leidet. <br><br>  Löschen Sie die Tabelle, starten Sie die Transaktion und fügen Sie die Zeile ein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Setzen Sie nun einen Sicherungspunkt und fügen Sie eine weitere Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Beachten Sie, dass die Funktion txid_current () die Nummer der nicht verschachtelten Haupttransaktion zurückgibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Wir rollen zurück zum Speicherpunkt und fügen die dritte Zeile ein. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Auf der Seite sehen wir weiterhin die Zeile, die durch die abgebrochene verschachtelte Transaktion hinzugefügt wurde. <br><br>  Wir korrigieren die Änderungen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Jetzt können Sie deutlich sehen, dass jede verschachtelte Transaktion ihren eigenen Status hat. <br><br>  Beachten Sie, dass verschachtelte Transaktionen in SQL nicht explizit verwendet werden können. Sie können also keine neue Transaktion starten, ohne die aktuelle abzuschließen.  Dieser Mechanismus wird implizit bei der Verwendung von Sicherungspunkten sowie bei der Behandlung von PL / pgSQL-Ausnahmen und in einer Reihe anderer, exotischerer Fälle verwendet. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Fehler und Atomizität von Operationen </h2><br>  Was passiert, wenn während des Vorgangs ein Fehler auftritt?  Zum Beispiel so: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Ein Fehler ist aufgetreten.  Jetzt wird die Transaktion als abgebrochen betrachtet und es ist keine einzige Operation darin zulässig: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Und selbst wenn Sie versuchen, die Änderungen zu übernehmen, meldet PostgreSQL die Stornierung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Warum kann ich die Transaktion nach einem Fehler nicht fortsetzen?  Tatsache ist, dass ein Fehler auftreten kann, so dass wir Zugriff auf einen Teil der Änderungen erhalten - die Atomizität nicht einmal der Transaktion, aber der Operator würde verletzt.  Wie in unserem Beispiel, in dem es dem Bediener gelungen ist, eine Zeile vor dem Fehler zu aktualisieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Ich muss sagen, dass es in psql einen Modus gibt, in dem Sie die Transaktion nach einem Fehler weiterhin fortsetzen können, als ob die Aktionen des fehlerhaften Operators zurückgesetzt würden. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Es ist leicht zu erraten, dass psql in diesem Modus tatsächlich einen impliziten Speicherpunkt vor jedem Befehl setzt und im Fehlerfall einen Rollback darauf initiiert.  Dieser Modus wird standardmäßig nicht verwendet, da das Festlegen von Speicherpunkten (auch ohne ein Zurücksetzen auf diese) mit einem erheblichen Overhead verbunden ist. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445820/">https://habr.com/ru/post/de445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445804/index.html">Kapselung für echte Samurai oder die Nuancen, die mit dem internen Schlüsselwort in C # verbunden sind</a></li>
<li><a href="../de445806/index.html">Wie künstliche Intelligenz die Wissenschaft verändert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gefährliche Leben eines Virus-Crackers, der sich mächtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten verändert hat</a></li>
<li><a href="../de445816/index.html">Wie wir Server-Rendering gesehen haben und was daraus wurde</a></li>
<li><a href="../de445822/index.html">Warum Jaop? Warum Schläger?</a></li>
<li><a href="../de445824/index.html">Codegenerierung in Dart. Teil 1. Grundlagen</a></li>
<li><a href="../de445826/index.html">Wir gehen mit Bedacht durch die Stadt - 2: Gehen wir mit dem genetischen Algorithmus im Kreis durch die Stadt</a></li>
<li><a href="../de445828/index.html">Chinesisches Sonnenspektrum</a></li>
<li><a href="../de445832/index.html">Strahlung: der unsichtbare Mörder und seine Töchter oder ein bisschen über Radon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>