<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📖 👵 💌 Perselisihan yang tenang dan tenang ⏩ 🐓 🎽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tiga tahun lalu, saya menulis artikel tentang perpustakaan DI untuk bahasa Swift. Sejak saat itu, perpustakaan telah banyak berubah dan menjadi yang t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perselisihan yang tenang dan tenang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457188/"><img src="https://habrastorage.org/files/c6d/c89/5d0/c6dc895d02324b96bc679f41228ab6bf.png" align="right" width="140" alt="ikon perpustakaan">  Tiga tahun lalu, saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang perpustakaan DI untuk bahasa Swift.  Sejak saat itu, perpustakaan telah banyak berubah dan menjadi yang <s>terbaik dari</s> pesaing yang layak untuk Swinject, melampaui itu dalam banyak hal.  Artikel ini dikhususkan untuk kemampuan perpustakaan, tetapi juga memiliki pertimbangan teoretis.  Jadi, yang tertarik dengan topik DI, DIP, IoC, atau yang membuat pilihan antara Swinject dan Swinject, saya meminta potongan: <br clear="all"><a name="habracut"></a><br><br><h1>  Apa DIP, IoC dan apa yang dimakannya? </h1><br><h2>  Teori <abbr title="Prinsip Pembalikan Ketergantungan">DIP</abbr> dan <abbr title="Pembalikan kontrol">IoC</abbr> </h2><br>  Teori adalah salah satu komponen terpenting dalam pemrograman.  Ya, Anda dapat menulis kode tanpa pendidikan, tetapi meskipun demikian, programmer terus membaca artikel, tertarik pada berbagai praktik, dll.  Yaitu, satu atau lain cara saya mendapatkan pengetahuan teoritis untuk mempraktikkannya. <br><br>  Salah satu topik yang ingin ditanyakan orang adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOLID</a> .  Tidak ada artikel tentang dia sama sekali, jangan khawatir.  Tapi kami butuh satu surat, karena terkait erat dengan perpustakaan saya.  Ini adalah huruf `D` - Prinsip Ketergantungan Pembalikan. <br><br>  Prinsip Ketergantungan Inversi menyatakan: <br><br><ul><li>  Modul tingkat atas tidak harus bergantung pada modul tingkat bawah.  Kedua jenis modul harus bergantung pada abstraksi. </li><li>  Abstraksi tidak harus bergantung pada detail.  Rinciannya harus bergantung pada abstraksi. </li></ul><br>  Banyak orang secara keliru menganggap bahwa jika mereka menggunakan protokol / antarmuka, maka mereka secara otomatis mematuhi prinsip ini, tetapi ini tidak sepenuhnya benar. <br><br>  <abbr title="Modul tingkat atas tidak harus bergantung pada modul tingkat bawah. Kedua jenis modul harus bergantung pada abstraksi.">Pernyataan pertama</abbr> mengatakan sesuatu tentang dependensi antar modul - modul harus bergantung pada abstraksi.  Tunggu, apa itu abstraksi?  - Lebih baik bertanya pada diri sendiri bukan apa itu abstraksi, tapi apa abstraksi itu?  Artinya, Anda perlu memahami apa prosesnya, dan hasil dari proses ini akan menjadi abstraksi.  <b>Abstraksi</b> adalah gangguan dalam proses kognisi dari pihak-pihak yang tidak penting, properti, hubungan untuk menyoroti tanda-tanda penting dan teratur. <br><br>  Objek yang sama, tergantung pada tujuannya, dapat memiliki abstraksi yang berbeda.  Misalnya, mesin dari sudut pandang pemilik memiliki sifat-sifat penting berikut: warna, keanggunan, kenyamanan.  Tapi dari sudut pandang mekanik, semuanya agak berbeda: merek, model, modifikasi, jarak tempuh, partisipasi dalam suatu kecelakaan.  Dua abstraksi berbeda untuk satu objek baru saja dinamai - mesin. <br><br>  Perhatikan bahwa dalam Swift biasanya menggunakan protokol untuk abstraksi, tetapi ini bukan keharusan.  Tidak ada yang mengganggu untuk membuat kelas, mengalokasikan satu set metode publik dari itu, dan meninggalkan detail implementasi pribadi.  Dalam hal abstraksi, tidak ada yang rusak.  Kita harus ingat tesis penting - “abstraksi tidak terikat dengan bahasa” - ini adalah proses yang terjadi terus-menerus di kepala kita, dan bagaimana ini ditransfer ke kode tidak begitu penting.  Di sini kita juga bisa menyebutkan <abbr title="penggabungan dan penyembunyian data">enkapsulasi</abbr> , sebagai contoh dari apa yang terkait dengan bahasa.  Setiap bahasa memiliki caranya sendiri untuk menyediakannya.  Di Swift, ini adalah kelas, bidang akses, dan protokol;  pada antarmuka Obj-C, protokol dan pemisahan file h dan m. <br><br>  <abbr title="Abstraksi tidak harus bergantung pada detail. Detail harus bergantung pada abstraksi.">pernyataan kedua</abbr> lebih menarik, karena diabaikan atau disalahpahami.  Ini berbicara tentang interaksi abstraksi dengan detail, dan apa detailnya?  Ada kesalahpahaman bahwa rinciannya adalah kelas yang mengimplementasikan protokol - ya ini benar, tetapi tidak lengkap.  Anda perlu memahami bahwa rinciannya tidak terkait dengan bahasa pemrograman - bahasa C tidak memiliki protokol atau kelas, tetapi prinsip ini juga bertindak berdasarkan hal itu.  Sulit bagi saya untuk menjelaskan secara teoritis apa hasil tangkapannya, jadi saya akan memberikan dua contoh, dan kemudian mencoba membuktikan mengapa contoh kedua lebih tepat. <br><br>  Misalkan ada mobil kelas dan mesin kelas.  Kebetulan kami harus menghubungkan mereka - mesin berisi mesin.  Kami, sebagai programmer yang kompeten, memilih mesin protokol, mengimplementasikan protokol dan meneruskan implementasi protokol ke kelas mesin.  Semuanya tampak baik dan benar - sekarang Anda dapat dengan mudah mengganti implementasi mesin dan tidak berpikir bahwa ada sesuatu yang akan rusak.  Selanjutnya, mekanik mesin ditambahkan ke sirkuit.  Dia tertarik pada karakteristik mesin yang sama sekali berbeda dari mobil.  Kami memperluas protokol dan sekarang berisi serangkaian fitur yang lebih besar daripada awalnya.  Kisah ini diulangi untuk pemilik mobil, untuk pabrik yang memproduksi mesin, dll. <br><br><img src="https://habrastorage.org/webt/yh/hh/v1/yhhhv1kv5yvffc1hcoqu489pfqi.png" alt="Tidak ada inversi"><br><br>  Tapi di mana kesalahan dalam berpikir?  Masalahnya adalah bahwa koneksi yang dijelaskan, terlepas dari ketersediaan protokol, sebenarnya adalah "detail" - "detail".  Lebih tepatnya, dalam nama apa dan di mana protokol berada mesin. <br><br>  Sekarang pertimbangkan opsi lain yang <s>benar</s> . <br><br>  Seperti sebelumnya, ada dua kelas - mesin dan mobil.  Seperti sebelumnya, mereka harus terhubung.  Tapi sekarang kami mengumumkan protokol "Mesin Mobil" atau "Jantung Mobil".  Kami menempatkan di dalamnya hanya karakteristik yang dibutuhkan mobil dari mesin.  Dan kami menempatkan protokol tidak di sebelah implementasi "mesin", tetapi di samping mesin.  Lebih lanjut, jika kita membutuhkan mekanik, kita perlu membuat protokol lain dan mengimplementasikannya di mesin.  Tampaknya tidak ada yang berubah, tetapi pendekatannya sangat berbeda - pertanyaannya bukan pada namanya, tetapi pada siapa protokolnya dan apa protokolnya - "abstraksi" atau "detail". <br><br><img src="https://habrastorage.org/webt/wb/xl/qw/wbxlqwjb7ltz4pqvek-gybtxc00.png" alt="Inversi adalah"><br><br>  Sekarang mari kita menggambar analogi dengan kasus lain, karena argumen ini mungkin tidak jelas. <br><br>  Ada backend dan beberapa fungsionalitas diperlukan darinya.  Backend memberi kami metode besar yang berisi banyak data, dan mengatakan - "Anda membutuhkan 3 bidang ini dari 1000" <br><br><div class="spoiler">  <b class="spoiler_title">Sedikit cerita</b> <div class="spoiler_text">  Banyak yang dapat mengatakan bahwa ini tidak terjadi.  Dan mereka akan relatif benar - kebetulan backend ditulis secara terpisah untuk aplikasi mobile.  Kebetulan saya bekerja untuk sebuah perusahaan di mana backend adalah layanan dengan sejarah 10 tahun yang, antara lain, terkait dengan API negara.  Untuk banyak alasan, bukan kebiasaan bagi perusahaan untuk menulis metode terpisah untuk ponsel, dan saya harus menggunakan apa yang ada.  Dan ada satu metode luar biasa dengan sekitar seratus parameter di root, dan beberapa di antaranya adalah kamus bersarang.  Sekarang bayangkan 100 parameter, 20% di antaranya memiliki parameter bersarang, dan di dalam masing-masing parameter bersarang ada 20-30 parameter lain yang semuanya bersarang sama.  Saya tidak ingat persis, tetapi jumlah parameter melebihi 800 untuk objek sederhana, dan untuk yang kompleks bisa lebih tinggi dari 1000. </div></div><br>  Kedengarannya tidak terlalu bagus, bukan?  Biasanya backend menulis metode untuk tugas-tugas spesifik untuk frontend, dan frontend adalah pelanggan / pengguna metode ini.  Hmm ... Tetapi jika Anda memikirkannya, backend adalah mesin, dan frontend adalah mobil - mesin membutuhkan beberapa karakteristik mesin, dan bukan mesin perlu memberikan karakteristik untuk mobil.  Jadi mengapa, meskipun demikian, kami terus menulis Engine protokol dan menempatkannya lebih dekat dengan implementasi mesin, dan bukan mesin?  Ini semua tentang skala - di sebagian besar program iOS sangat jarang harus memperluas fungsionalitas sehingga solusi seperti itu menjadi masalah. <br><br><h2>  Lalu apa itu <abbr title="Ketergantungan injeksi">DI</abbr> </h2><br>  Ada substitusi konsep - DI bukan singkatan untuk DIP, tetapi singkatan yang sama sekali berbeda, meskipun faktanya sangat bersinggungan dengan DIP.  DI adalah injeksi ketergantungan atau Injeksi Ketergantungan, bukan Inversi.  Pembalikan berbicara tentang bagaimana kelas dan protokol harus berinteraksi satu sama lain, dan implementasi memberi tahu Anda dari mana mendapatkannya.  Secara umum, Anda dapat mengimplementasikannya dengan berbagai cara - mulai dari mana dependensi datang: konstruktor, properti, metode;  diakhiri dengan mereka yang membuatnya dan seberapa otomatis proses ini.  Pendekatannya berbeda tetapi, menurut saya, yang paling nyaman adalah wadah untuk injeksi ketergantungan.  Singkatnya, seluruh maknanya bermuara pada aturan sederhana: Kami memberi tahu wadah di mana dan bagaimana menerapkannya dan setelah itu semuanya dilaksanakan secara independen.  Pendekatan ini sesuai dengan "implementasi nyata dari dependensi" - ini adalah ketika kelas-kelas di mana dependensi tertanam tidak tahu apa-apa tentang bagaimana ini terjadi, yaitu mereka pasif. <br><br>  Dalam banyak bahasa, pendekatan berikut digunakan untuk implementasi ini: Dalam kelas / file individual, aturan implementasi dijelaskan menggunakan sintaksis bahasa, setelah itu mereka dikompilasi dan diimplementasikan secara otomatis.  Tidak ada keajaiban - tidak ada yang terjadi secara otomatis, hanya perpustakaan yang terintegrasi erat dengan sarana dasar bahasa, dan membebani metode pembuatan.  Jadi untuk Swift / Obj-C secara umum diterima bahwa titik awalnya adalah UIViewController, dan perpustakaan dapat dengan mudah mengintegrasikan diri ke dalam ViewController yang dibuat dari Storyboard.  Benar, jika Anda tidak menggunakan Storyboard, Anda harus melakukan sebagian pekerjaan dengan pena. <br><br>  Oh ya, saya hampir lupa - jawaban untuk pertanyaan utama, "mengapa kita membutuhkan ini?"  Tidak diragukan lagi, Anda dapat merawat injeksi ketergantungan sendiri, meresepkan semuanya dengan pena.  Tetapi masalah muncul ketika grafik menjadi besar - Anda harus menyebutkan banyak koneksi antar kelas, kode mulai tumbuh sangat banyak.  Oleh karena itu, perpustakaan yang secara otomatis menerapkan dependensi secara rekursif (dan bahkan secara siklikal) merawat diri mereka sendiri dan, sebagai bonus, mengontrol masa hidup mereka.  Artinya, perpustakaan tidak melakukan apa pun di luar yang alami - itu hanya menyederhanakan kehidupan pengembang.  Benar, jangan berpikir bahwa Anda dapat menulis perpustakaan seperti itu dalam sehari - itu adalah satu hal untuk menulis dengan pena semua dependensi untuk kasus tertentu, itu hal lain untuk mengajar komputer untuk menerapkan secara universal dan benar. <br><br><h1>  Sejarah perpustakaan </h1><br>  Kisah itu tidak akan lengkap jika saya tidak menceritakannya secara singkat.  Jika Anda mengikuti perpustakaan dari versi beta, itu tidak akan begitu menarik bagi Anda, tetapi bagi mereka yang melihatnya untuk pertama kali, saya pikir layak untuk memahami bagaimana itu muncul dan apa tujuan yang diikuti penulis (yaitu, saya). <br>  Perpustakaan adalah proyek kedua saya, yang saya putuskan, untuk keperluan pendidikan mandiri, untuk menulis dalam bahasa Swift.  Sebelumnya saya berhasil menulis logger, tetapi tidak mengunggahnya ke domain publik - ini lebih baik dan lebih baik. <br><br>  Tetapi dengan DI, ceritanya lebih menarik.  Ketika saya mulai melakukannya, saya hanya dapat menemukan satu perpustakaan di Swift - Swinject.  Pada saat itu, ia memiliki 500 bintang dan bug yang siklusnya biasanya tidak diproses.  Saya melihat semua ini dan ... Perilaku saya paling baik dijelaskan dengan frasa favorit saya "Dan kemudian Ostap menderita" - Saya mempelajari 5-6 bahasa, melihat apa yang ada dalam bahasa-bahasa ini, membaca artikel tentang topik ini dan menyadari bahwa itu bisa dilakukan dengan lebih baik.  Dan sekarang, setelah hampir tiga tahun, saya dapat mengatakan dengan keyakinan bahwa tujuan telah tercapai, saat ini DITranquillity adalah yang terbaik dalam pandangan dunia saya. <br><br>  Mari kita pahami apa itu perpustakaan DI yang baik: <br><br><ul><li>  Ini harus menyediakan semua implementasi dasar: konstruktor, properti, metode </li><li>  Seharusnya tidak memengaruhi kode bisnis. </li><li>  Dia harus dengan jelas menggambarkan apa yang salah. </li><li>  Dia harus memahami terlebih dahulu di mana ada kesalahan, bukan saat runtime. </li><li>  Itu harus diintegrasikan dengan alat dasar (Storyboard) </li><li>  Seharusnya memiliki sintaksis ringkas dan ringkas. </li><li>  Dia harus melakukan segalanya dengan cepat dan efisien. </li><li>  (Opsional) Itu harus hirarkis </li></ul><br>  Prinsip-prinsip inilah yang saya coba patuhi sepanjang pengembangan perpustakaan. <br><br><h1>  Fitur dan Manfaat Perpustakaan </h1><br>  Pertama, tautan ke repositori: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/ivlevAstef/DITranquillity</a> <br><br>  Keuntungan kompetitif utama, yang cukup penting bagi saya, adalah bahwa perpustakaan berbicara tentang kesalahan startup.  Setelah memulai aplikasi dan memanggil fungsi yang diinginkan, semua masalah, baik yang sudah ada maupun yang potensial, akan dilaporkan.  Inilah makna nama "tenang" perpustakaan - pada kenyataannya, setelah memulai program, perpustakaan menjamin bahwa semua dependensi yang diperlukan akan ada dan tidak ada siklus yang tidak dapat diselesaikan.  Di tempat-tempat di mana ada ambiguitas, perpustakaan akan memperingatkan bahwa mungkin ada masalah potensial. <br><br>  Kedengarannya baik bagi saya.  Tidak ada crash selama pelaksanaan program, jika programmer lupa sesuatu, maka ini akan segera dilaporkan. <br><br>  Fungsi log digunakan untuk menggambarkan masalah, yang sangat saya sarankan untuk digunakan.  Logging memiliki 4 level: kesalahan, peringatan, info, verbose.  Tiga yang pertama cukup penting.  Yang terakhir tidak begitu penting - ia menulis semua yang terjadi - objek mana yang terdaftar, objek mana yang mulai diperkenalkan, objek apa yang dibuat, dll. <br><br>  Tapi ini tidak semua perpustakaan menawarkan: <br><br><ul><li>  Keamanan ulir penuh - operasi apa pun dapat dilakukan dari utas apa pun dan semuanya akan berfungsi.  Kebanyakan orang tidak membutuhkan ini, jadi dalam hal keamanan benang, pekerjaan dilakukan untuk mengoptimalkan kecepatan eksekusi.  Tetapi perpustakaan pesaing, terlepas dari janji-janji, jatuh jika Anda mulai mendaftar dan menerima objek pada saat yang sama </li><li>  Kecepatan eksekusi cepat.  Pada perangkat nyata, DITranquillity dua kali lebih cepat dari pesaingnya.  Benar pada simulator, kecepatan eksekusi hampir setara.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan Uji</a> </li><li>  Ukuran kecil - perpustakaan beratnya kurang dari Swinject + SwinjectStoryboad + SwinjectAutoregistration, tetapi melampaui bundel ini dalam kemampuan </li><li>  Catatan singkat, ringkas, meskipun membuat ketagihan </li><li>  Hierarki.  Untuk proyek-proyek besar, yang terdiri dari banyak modul, ini merupakan nilai tambah yang sangat besar, karena perpustakaan dapat menemukan kelas yang diperlukan dengan jarak dari modul saat ini.  Artinya, jika Anda memiliki implementasi sendiri dari satu protokol di setiap modul, maka di setiap modul Anda akan mendapatkan implementasi yang diinginkan tanpa melakukan upaya apa pun </li></ul><br><h1>  Demonstrasi </h1><br>  Jadi mari kita mulai.  Sebagai proyek terakhir kali akan dipertimbangkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SampleHabr</a> .  Saya secara khusus tidak mulai mengubah contoh - sehingga Anda dapat membandingkan bagaimana semuanya telah berubah.  Dan contohnya menampilkan banyak fitur perpustakaan. <br><br>  Untuk jaga-jaga, agar tidak ada kesalahpahaman, karena proyek ini dipamerkan, ia menggunakan banyak fitur.  Tapi tidak ada yang mengganggu untuk menggunakan perpustakaan dengan cara yang disederhanakan - diunduh, dibuat wadah, terdaftar beberapa kelas, gunakan wadah. <br><br>  Pertama, kita perlu membuat kerangka kerja (opsional): <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppFramework</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIFramework</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   public static func load(container: DIContainer) { //     } }</span></span></code> </pre> <br>  Dan di awal program, buat wadah Anda sendiri, dengan tambahan kerangka kerja ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-type"><span class="hljs-type">DIContainer</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   container.append(framework: AppFramework.self) //     . //          ifdef DEBUG      ,         ,     . if !container.validate() { fatalError() }</span></span></code> </pre><br><h3>  Storyboard </h3><br>  Selanjutnya, Anda perlu membuat layar dasar.  Biasanya Storyboard digunakan untuk ini, dan dalam contoh ini saya akan menggunakannya, tetapi tidak ada yang mengganggu untuk menggunakan UIViewControllers. <br><br>  Untuk memulainya, kita perlu mendaftarkan Storyboard.  Untuk melakukan ini, buat "bagian" (opsional - Anda dapat menulis semua kode dalam kerangka kerja) dengan Storyboard terdaftar di dalamnya: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class AppPart: DIPart { static func load(container: DIContainer) { container.registerStoryboard(name: "Main", bundle: nil) .lifetime(.single) <span class="hljs-comment"><span class="hljs-comment">//   -    . } }</span></span></code> </pre><br><br>  Dan tambahkan bagian ke AppFramework: <br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">AppPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Seperti yang Anda lihat, perpustakaan memiliki sintaks yang nyaman untuk mendaftar Storyboard, dan saya sangat merekomendasikan menggunakannya.  Pada prinsipnya, Anda dapat menulis kode yang setara tanpa metode ini, tetapi akan lebih besar dan tidak akan dapat mendukung StoryboardReferences.  Artinya, Storyboard ini tidak akan berfungsi dari yang lain. <br><br>  Sekarang satu-satunya yang tersisa adalah membuat Storyboard dan menampilkan layar mulai.  Ini dilakukan di AppDelegate, setelah memeriksa wadah: <br><br><pre> <code class="swift hljs">window = <span class="hljs-type"><span class="hljs-type">UIWindow</span></span>(frame: <span class="hljs-type"><span class="hljs-type">UIScreen</span></span>.main.bounds) <span class="hljs-comment"><span class="hljs-comment">///  Storyboard let storyboard: UIStoryboard = container.resolve(name: "Main") window!.rootViewController = storyboard.instantiateInitialViewController() window!.makeKeyAndVisible()</span></span></code> </pre><br>  Membuat Storyboard menggunakan perpustakaan tidak jauh lebih rumit dari biasanya.  Dalam contoh ini, namanya dapat terlewatkan, karena kami hanya memiliki satu Storyboard - perpustakaan akan menduga bahwa Anda sudah memikirkannya.  Tetapi dalam beberapa proyek ada banyak Storyboard, jadi jangan lewatkan namanya lagi. <br><br><h3>  Presenter dan ViewController </h3><br>  Pergi ke layar itu sendiri.  Kami tidak akan memuat proyek dengan arsitektur yang kompleks, tetapi kami akan menggunakan MVP biasa.  Selain itu, saya sangat malas sehingga saya tidak akan membuat protokol untuk presenter.  Protokol akan sedikit lebih lambat untuk kelas lain, di sini penting untuk menunjukkan cara mendaftar dan menautkan Presenter dan ViewController. <br><br>  Untuk melakukan ini, tambahkan kode berikut ke AppPart: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) container.register(<span class="hljs-type"><span class="hljs-type">YourViewController</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .injection(\.presenter) <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  Tiga baris ini akan memungkinkan kita untuk mendaftar dua kelas, dan membangun koneksi di antara mereka. <br><br>  Orang-orang yang penasaran mungkin bertanya-tanya - mengapa sintaksis yang dimiliki Swinject di perpustakaan terpisah dijadikan yang utama dalam proyek ini?  Jawabannya terletak pada sasaran - berkat sintaks ini, perpustakaan menyimpan semua tautan di muka, daripada menghitungnya saat runtime.  Sintaks ini memberi Anda akses ke banyak fitur yang tidak tersedia untuk perpustakaan lain. <br><br>  Kami memulai aplikasi, dan semuanya berfungsi, semua kelas dibuat. <br><br><h3>  Data </h3><br>  Nah, sekarang kita perlu menambahkan kelas dan protokol untuk menerima data dari server: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerImpl</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(domain: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Data?</span></span> { ... } }</code> </pre><br>  Dan untuk kecantikan, kami akan membuat kelas DI ServerPart terpisah untuk server, tempat kami mendaftarkannya.  Biarkan saya mengingatkan Anda bahwa ini tidak perlu dan dapat didaftarkan langsung dalam wadah, tetapi kami tidak mencari cara mudah :) <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity class ServerPart: DIPart { static func load(container: DIContainer) { container.register{ ServerImpl(domain: "https:<span class="hljs-comment"><span class="hljs-comment">//github.com/") } .as(check: Server.self){$0} .lifetime(.single) } }</span></span></code> </pre><br>  Dalam kode ini, semuanya tidak setransparan yang sebelumnya, dan membutuhkan klarifikasi.  Pertama, di dalam register fungsi, kelas dibuat dengan melewati parameter. <br><br>  Kedua, ada fungsi `as` - ia mengatakan bahwa kelas akan dapat diakses oleh tipe lain - protokol.  Akhir yang aneh dari operasi ini dalam bentuk `{$ 0}` adalah bagian dari nama `check:`.  Artinya, kode ini memastikan bahwa ServerImpl adalah penerus Server.  Tetapi ada sintaks lain: `as (Server.self)` yang akan melakukan hal yang sama, tetapi tanpa memeriksa.  Untuk melihat apa yang akan dihasilkan oleh kompiler dalam kedua kasus, Anda dapat menghapus implementasi protokol. <br><br>  Mungkin ada beberapa fungsi `as` - ini berarti jenisnya tersedia dengan nama-nama ini.  Saya menarik perhatian Anda bahwa ini akan menjadi satu pendaftaran, yang berarti bahwa jika kelas adalah singleton, maka contoh yang sama akan tersedia untuk semua jenis yang ditentukan. <br><br>  Pada prinsipnya, jika Anda ingin melindungi diri dari kemungkinan membuat kelas berdasarkan jenis implementasi, atau Anda belum terbiasa dengan sintaks ini, maka Anda dapat menulis: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ServerImpl</span></span>(domain: <span class="hljs-string"><span class="hljs-string">"https://github.com/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> }</code> </pre><br>  Yang akan menjadi beberapa setara, tetapi tanpa kemampuan untuk menentukan beberapa tipe yang terpisah. <br><br>  Sekarang Anda dapat mengimplementasikan server di Presenter, untuk ini kami akan memperbaiki Presenter sehingga menerima Server: <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">Server</span></span>) { ... } }</code> </pre><br>  Kami memulai program, dan jatuh pada fungsi `validasi` di AppDelegate, dengan pesan bahwa jenis` Server` tidak ditemukan, tetapi diperlukan oleh` YourPresenter`.  Ada apa?  Harap dicatat bahwa kesalahan terjadi pada awal pelaksanaan program, dan bukan post factum.  Dan alasannya cukup sederhana - mereka lupa menambahkan `ServerPart` ke` AppFramework`: <br><br><pre> <code class="swift hljs">container.append(part: <span class="hljs-type"><span class="hljs-type">ServerPart</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br>  Kami mulai - semuanya bekerja. <br><br><h3>  Logger </h3><br>  Sebelum ini, ada seorang kenalan dengan peluang yang tidak terlalu mengesankan dan banyak dimiliki.  Sekarang akan ada demonstrasi bahwa perpustakaan lain di Swift tidak tahu caranya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek</a> terpisah dibuat di bawah penebang. <br><br>  Pertama, mari kita pahami apa yang akan menjadi penebang.  Untuk tujuan pendidikan, kami tidak akan melakukan sistem tipuan, sehingga logger adalah protokol dengan satu metode dan beberapa implementasi: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsoleLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(file: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(server: <span class="hljs-type"><span class="hljs-type">String</span></span>) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(loggers: [<span class="hljs-type"><span class="hljs-type">Logger</span></span>]) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg: String)</span></span></span></span> { ... } }</code> </pre><br>  Total, kami memiliki: <br><br><ul><li>  Protokol publik </li><li>  3 implementasi logger berbeda, yang masing-masing menulis ke tempat yang berbeda </li><li>  Satu logger pusat yang memanggil fungsi logging untuk semua orang </li></ul><br>  Proyek ini menciptakan `LoggerFramework` dan` LoggerPart`.  Saya tidak akan menulis kode mereka, tetapi saya hanya akan menulis internal `LoggerPart`: <br><br><pre> <code class="swift hljs">container.register{ <span class="hljs-type"><span class="hljs-type">ConsoleLogger</span></span>() } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">FileLogger</span></span>(file: <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">ServerLogger</span></span>(server: <span class="hljs-string"><span class="hljs-string">"http://server.com/"</span></span>) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .lifetime(.single) container.register{ <span class="hljs-type"><span class="hljs-type">MainLogger</span></span>(loggers: many($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } .<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(<span class="hljs-type"><span class="hljs-type">Logger</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>() .lifetime(.single)</code> </pre><br>  Kami telah melihat 3 pendaftaran pertama, dan yang terakhir menimbulkan pertanyaan. <br><br>  Parameter dilewatkan ke input.  Yang serupa sudah ditunjukkan ketika presenter dibuat, meskipun ada catatan disingkat - metode `init` hanya digunakan, tetapi tidak ada yang mengganggu untuk menulis seperti ini: <br><br><pre> <code class="swift hljs">container.register { <span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>(server: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Jika ada beberapa parameter, maka seseorang dapat menggunakan `$ 1`,` $ 2`, `$ 3`, dll.  sampai 16. <br><br>  Tetapi parameter ini memanggil fungsi `many`.  Dan di sini kesenangan dimulai.  Ada dua pengubah `banyak` dan` tag` di perpustakaan. <div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text">  Ada pengubah `arg` ketiga, tetapi tidak aman </div></div>  Pengubah `many` mengatakan bahwa Anda harus mendapatkan semua objek yang sesuai dengan tipe yang diinginkan.  Dalam hal ini, protokol Logger diharapkan, sehingga semua kelas yang mewarisi dari protokol ini akan ditemukan dan dibuat, dengan satu pengecualian - itu sendiri, yaitu, secara rekursif.  Itu tidak akan membuat sendiri selama inisialisasi, meskipun dapat dengan aman melakukan ini ketika diimplementasikan melalui properti. <br><br>  Tag, pada gilirannya, adalah tipe terpisah apa pun yang harus ditentukan selama penggunaan dan selama pendaftaran.  Artinya, tag adalah kriteria tambahan jika tidak ada tipe dasar yang cukup. <br><br>  Anda dapat membaca lebih lanjut tentang ini: <a href="">Pengubah</a> <br><br>  Kehadiran pengubah, terutama `banyak`, membuat perpustakaan lebih baik daripada yang lain.  Misalnya, Anda dapat menerapkan pola Observer pada tingkat yang sama sekali berbeda.  Karena 4 huruf ini, dalam proyek itu mungkin untuk menghapus 30-50 baris kode dari setiap Pengamat dalam proyek dan memecahkan masalah dengan pertanyaan - di mana dan kapan benda harus ditambahkan ke Observable.  Bisnis yang jelas bukan satu-satunya aplikasi, tetapi signifikan. <br><br>  Baiklah, kami akan menyelesaikan presentasi fitur dengan memperkenalkan logger di YourPresenter: <br><br><pre> <code class="swift hljs">container.register(<span class="hljs-type"><span class="hljs-type">YourPresenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) .injection { $<span class="hljs-number"><span class="hljs-number">0</span></span>.logger = $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  Di sini, misalnya, ini ditulis sedikit berbeda dari sebelumnya - ini dilakukan untuk contoh sintaks yang berbeda. <br><br>  Harap dicatat bahwa properti logger adalah opsional: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger: <span class="hljs-type"><span class="hljs-type">Logger?</span></span></code> </pre><br>  Dan ini tidak muncul dalam sintaks perpustakaan.  Berbeda dengan versi pertama, sekarang semua operasi untuk tipe yang biasa, opsional dan terpaksa opsional terlihat sama.  Selain itu, logika di dalamnya berbeda - jika jenisnya opsional, dan tidak terdaftar dalam wadah, maka program tidak akan macet, tetapi akan melanjutkan eksekusi. <br><br><h2>  Ringkasan </h2><br>  Hasilnya mirip dengan yang terakhir kali, hanya sintaks telah menjadi lebih pendek dan lebih fungsional. <br><br><h4>  Apa yang ditinjau: </h4><br><ul><li>  <a href="">Mendaftar secara singkat</a> </li><li>  <a href="">Bekerja dengan Storyboard, tetapi perpustakaan dapat bekerja dengan StoryboardReferences</a> </li><li>  <a href="">Pendaftaran melalui metode inisialisasi atau properti</a> </li><li>  <a href="">Implementasi berganda</a> </li><li>  <a href="">Bekerja dengan kerangka kerja dan bagian</a> </li><li>  <a href="">Sedikit validasi</a> </li></ul><br><h4>  Apa lagi yang bisa dilakukan perpustakaan: </h4><br><ul><li>  <a href="">5 masa hidup: tunggal, perRun (.weak / .strong), perContainer (.weak / .strong), objectGraph, prototype</a> </li><li>  <a href="">Nama tag</a> </li><li>  <a href="">Penebangan</a> </li><li>  <a href="">Bekerja dengan dependensi siklik</a> </li><li>  <a href="">Berakar dalam pandangan</a> </li><li>  <a href="">Implementasi yang ditangguhkan</a> </li><li>  Pengenalan argumen, tetapi fungsinya tidak didokumentasikan karena tidak aman </li></ul><br><h2>  Paket </h2><br>  Pertama-tama, direncanakan untuk beralih ke memeriksa grafik pada tahap kompilasi - yaitu, integrasi yang lebih dekat dengan kompiler.  Ada implementasi awal menggunakan SourceKitten, tetapi implementasi seperti itu memiliki kesulitan serius dengan inferensi tipe, sehingga direncanakan untuk beralih ke ast-dump - di swift5 menjadi bekerja pada proyek-proyek besar.  Di sini saya ingin mengucapkan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nekitosss</a> atas kontribusi besar dalam arah ini. <br><br>  Kedua, saya ingin berintegrasi dengan layanan visualisasi.  Ini akan menjadi proyek yang sedikit berbeda, tetapi terkait erat dengan perpustakaan.  Apa gunanya  Sekarang perpustakaan menyimpan seluruh grafik koneksi, yaitu, secara teori segala sesuatu yang terdaftar di perpustakaan dapat ditampilkan sebagai diagram kelas / komponen UML.  Dan akan menyenangkan untuk kadang-kadang melihat diagram ini. <br><br>  Fungsi ini direncanakan dalam dua bagian - bagian pertama akan memungkinkan Anda menambahkan API untuk mendapatkan semua informasi, dan yang kedua sudah terintegrasi dengan berbagai layanan. <br><br>  Opsi paling sederhana adalah menampilkan grafik tautan dalam bentuk teks, tetapi saya belum melihat opsi yang dapat dibaca - jika demikian, sarankan opsi di komentar. <br><br>  WatchOS - Saya sendiri tidak menulis proyek untuk mereka.  Untuk hidupnya dia hanya menulis sekali, lalu kecil.  Tetapi saya ingin membuat integrasi yang ketat, seperti dengan Storyboard. <br><br>  Itu semua terima kasih atas perhatiannya.  Saya sangat mengharapkan komentar dan jawaban survei. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang diri saya</b> <div class="spoiler_text">  Ivlev Alexander Evgenievich - pemimpin senior / tim di tim iOS.  Saya telah bekerja di perdagangan selama 7 tahun, di bawah iOS 4,5 tahun - sebelum itu saya adalah seorang pengembang C ++.  Tetapi total pengalaman pemrograman lebih dari 15 tahun - di sekolah saya berkenalan dengan dunia yang menakjubkan ini dan begitu terbawa olehnya sehingga ada suatu periode ketika saya bertukar permainan <s>, makanan, toilet, mimpi</s> untuk menulis kode.  Menurut salah satu artikel saya, Anda dapat menebak bahwa saya adalah mantan Olimpiade - karenanya, tidak sulit bagi saya untuk menulis karya yang kompeten dengan grafik.  Kekhususan - sistem pengukur informasi, dan pada suatu waktu saya terobsesi dengan multithreading dan paralelisme - ya, saya menulis kode di mana saya membuat asumsi dan bug pada topik yang serupa, tetapi saya memahami area masalah dan sangat memahami di mana Anda dapat mengabaikan mutex, dan di mana tidak layak. <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457188/">https://habr.com/ru/post/id457188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457178/index.html">Bagaimana prosesor dirancang dan diproduksi: desain CPU</a></li>
<li><a href="../id457180/index.html">Situs resmi Node.js sekarang dalam bahasa Rusia</a></li>
<li><a href="../id457182/index.html">Bahasa REXX, Hari Jadi ke-40</a></li>
<li><a href="../id457184/index.html">Secara dinamis membuat robots.txt untuk situs ASP.NET Core</a></li>
<li><a href="../id457186/index.html">Python dalam Visual Studio Code - rilis Juni</a></li>
<li><a href="../id457190/index.html">Kami memperlakukan bisnis melalui penerapan sistem CRM</a></li>
<li><a href="../id457192/index.html">Airbus mengambil ketinggian baru dengan realitas campuran Microsoft</a></li>
<li><a href="../id457194/index.html">Airbus mencapai ketinggian baru dengan bantuan teknologi realitas campuran Microsoft</a></li>
<li><a href="../id457196/index.html">Petty little joy # 5: Dynaconf - mengelola pengaturan dalam proyek</a></li>
<li><a href="../id457198/index.html">Jaringan saraf telah belajar menggambar adegan kompleks dari deskripsi tekstual</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>