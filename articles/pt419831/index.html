<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëó üßòüèæ ü§Ωüèª Como o JS funciona: elementos personalizados üîÆ üêÉ üñïüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Leitura recomendada] As outras 19 partes do ciclo  Parte 1: Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas 
 Parte 2: S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o JS funciona: elementos personalizados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[Leitura recomendada] As outras 19 partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre os internos da V8 e otimiza√ß√£o de c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciando a mem√≥ria, quatro tipos de vazamentos de mem√≥ria e lidando com eles</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Loop de eventos, ass√≠ncrono e cinco maneiras de melhorar seu c√≥digo com async / waitit</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebSocket e HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que escolher?</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recursos e escopo do WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores da Web e cinco cen√°rios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores de Servi√ßo</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notifica√ß√µes por push da Web</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rastrear altera√ß√µes no DOM com MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos de renderiza√ß√£o de p√°ginas da Web e dicas para otimizar seu desempenho</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anima√ß√£o com CSS e JavaScript</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: classes e heran√ßa, transpila√ß√£o em Babel e TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: armazenamento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: Tecnologia Shadow DOM e componentes da Web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: mecanismos de comunica√ß√£o WebRTC e P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: elementos personalizados</a> </div></div><br>  Apresentamos a voc√™ uma tradu√ß√£o de 19 artigos da s√©rie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SessionStack</a> de materiais sobre os recursos de v√°rios mecanismos do ecossistema JavaScript.  Hoje falaremos sobre o padr√£o Custom Elements - os chamados "elementos customizados".  Falaremos sobre quais tarefas eles permitem resolver e como cri√°-las e us√°-las. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="imagem"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revis√£o</font> </h2><br>  Em um dos artigos anteriores desta s√©rie, falamos sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shadow DOM</a> e algumas outras tecnologias que fazem parte de um fen√¥meno maior - componentes da Web.  Os componentes da Web s√£o projetados para permitir que os desenvolvedores estendam os recursos padr√£o do HTML criando elementos compactos, modulares e reutiliz√°veis.  Esse √© o padr√£o W3C relativamente novo que os fabricantes de todos os principais navegadores j√° notaram.  Ele pode ser encontrado em produ√ß√£o, embora, √© claro, enquanto seu trabalho √© fornecido por polifilos (falaremos sobre eles mais adiante). <br><br>  Como voc√™ j√° deve saber, os navegadores nos fornecem algumas ferramentas essenciais para o desenvolvimento de sites e aplicativos da web.  √â sobre HTML, CSS e JavaScript.  O HTML √© usado para estruturar as p√°ginas da Web. Gra√ßas ao CSS, elas t√™m uma boa apar√™ncia e o JavaScript √© respons√°vel por recursos interativos.  No entanto, antes do aparecimento dos componentes da web, n√£o era t√£o f√°cil associar a√ß√µes implementadas por JavaScript a uma estrutura HTML. <br><br>  Por uma quest√£o de fato, aqui consideraremos a base dos componentes da web - elementos personalizados.  Em poucas palavras, a API projetada para trabalhar com eles permite que o programador crie seus pr√≥prios elementos HTML com a l√≥gica JavaScript incorporada e os estilos descritos por CSS.  Muitos confundem elementos personalizados com a tecnologia Shadow DOM.  No entanto, essas s√£o duas coisas completamente diferentes que, de fato, se complementam, mas n√£o s√£o intercambi√°veis. <br><br>  Algumas estruturas (como Angular ou React) tentam resolver o mesmo problema que os elementos personalizados resolvem, introduzindo seus pr√≥prios conceitos.  Elementos personalizados podem ser comparados com diretivas angulares ou com componentes React.  No entanto, os elementos personalizados s√£o um recurso padr√£o do navegador; voc√™ n√£o precisa usar nada al√©m de JavaScript, HTML e CSS comuns para trabalhar com eles.  Obviamente, isso n√£o nos permite dizer que eles substituem as estruturas JS comuns.  As estruturas modernas nos d√£o muito mais do que apenas a capacidade de simular o comportamento de elementos personalizados.  Como resultado, podemos dizer que as estruturas e os elementos do usu√°rio s√£o tecnologias que podem ser usadas juntas para resolver tarefas de desenvolvimento da web. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Antes de continuarmos, vamos ver quais oportunidades a API nos oferece para trabalhar com elementos personalizados.  Ou seja, estamos falando de um objeto <code>customElements</code> global que possui v√°rios m√©todos: <br><br><ul><li>  O m√©todo <code>define(tagName, constructor, options)</code> permite definir (criar, registrar) um novo elemento do usu√°rio.  S√£o necess√°rios tr√™s argumentos - o nome da tag do elemento user, correspondente √†s regras de nomenclatura para esses elementos, uma declara√ß√£o de classe e um objeto com par√¢metros.  Atualmente, apenas um par√¢metro √© suportado - <code>extends</code> , que √© uma sequ√™ncia que especifica o nome do elemento inline a ser expandido.  Esse recurso √© usado para criar vers√µes especiais de elementos padr√£o. </li><li>  O m√©todo <code>get(tagName)</code> retorna o construtor do elemento user, desde que esse elemento j√° esteja definido, caso contr√°rio ele retorna <code>undefined</code> .  √â preciso um argumento - a tag de nome do elemento do usu√°rio. </li><li>  O <code>whenDefined(tagName)</code> retorna a promessa que √© resolvida ap√≥s a cria√ß√£o do elemento do usu√°rio.  Se um elemento j√° estiver definido, essa promessa ser√° resolvida imediatamente.  Uma promessa ser√° rejeitada se o nome da tag passado para ela n√£o for um nome v√°lido para o elemento do usu√°rio.  Este m√©todo aceita o nome da tag do elemento do usu√°rio. </li></ul><br><h2>  <font color="#3AC1EF">Crie itens personalizados</font> </h2><br>  Criar elementos personalizados √© muito simples.  Para fazer isso, duas coisas devem ser feitas: crie uma declara√ß√£o de classe para o elemento que deve estender a classe <code>HTMLElement</code> e registre esse elemento com o nome selecionado.  Aqui est√° o que parece: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  Se voc√™ n√£o deseja poluir o escopo atual, pode usar uma classe an√¥nima: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ });</span></span></code> </pre> <br>  Como voc√™ pode ver nos exemplos, o elemento user √© registrado usando o m√©todo <code>customElements.define(...)</code> voc√™ j√° conhece. <br><br><h2>  <font color="#3AC1EF">Problemas que os Elementos Customizados Resolvem</font> </h2><br>  Vamos falar sobre os problemas que nos permitem resolver elementos personalizados.  Uma delas √© melhorar a estrutura do c√≥digo e eliminar o que √© chamado de "div tag soup" (sopa de div).  Esse fen√¥meno √© uma estrutura de c√≥digo muito comum em aplicativos da web modernos, na qual existem muitos elementos <code>div</code> incorporados um no outro.  Aqui est√° o que pode parecer: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           ‚Ä¶         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Esse c√≥digo HTML √© usado por raz√µes justific√°veis ‚Äã‚Äã- descreve o layout da p√°gina e garante a exibi√ß√£o correta na tela.  No entanto, isso prejudica a legibilidade do c√≥digo HTML e complica sua manuten√ß√£o. <br><br>  Suponha que tenhamos um componente que se parece com a figura a seguir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Apar√™ncia do componente</font></i> <br><br>  Usando a abordagem tradicional para descrever essas coisas, o c√≥digo a seguir corresponder√° a esse componente: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Agora imagine que poder√≠amos, em vez deste c√≥digo, usar esta descri√ß√£o do componente: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Estou certo de que todos concordar√£o que o segundo fragmento de c√≥digo parece muito melhor.  Esse c√≥digo √© mais f√°cil de ler, mais f√°cil de manter e √© compreens√≠vel para o desenvolvedor e o navegador.  Tudo se resume ao fato de ser mais simples do que aquele em que existem muitas tags <code>div</code> aninhadas. <br><br>  O pr√≥ximo problema que pode ser resolvido com elementos personalizados √© a reutiliza√ß√£o de c√≥digo.  O c√≥digo que os desenvolvedores escrevem n√£o deve apenas estar funcionando, mas tamb√©m suportado.  Reutilizar c√≥digo, em vez de escrever constantemente as mesmas constru√ß√µes, melhora os recursos de suporte ao projeto. <br>  Aqui est√° um exemplo simples que o ajudar√° a entender melhor essa ideia.  Suponha que tenhamos o seguinte elemento: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  Se voc√™ precisar constantemente, com a abordagem usual, teremos que escrever o mesmo c√≥digo HTML repetidamente.  Agora imagine que voc√™ precisa fazer uma altera√ß√£o nesse c√≥digo que deve refletir-se onde quer que seja usado.  Isso significa que precisamos encontrar todos os locais onde esse fragmento √© usado e, em seguida, fazer as mesmas altera√ß√µes em todos os lugares.  √â longo, dif√≠cil e cheio de erros. <br><br>  Seria muito melhor se pud√©ssemos onde esse elemento √© necess√°rio, basta escrever o seguinte: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  No entanto, aplicativos web modernos s√£o muito mais que HTML est√°tico.  Eles s√£o interativos.  A fonte de sua interatividade √© o JavaScript.  Geralmente, para fornecer esses recursos, alguns elementos s√£o criados e os ouvintes de eventos s√£o conectados a eles, o que lhes permite responder √†s influ√™ncias do usu√°rio.  Por exemplo, eles podem responder a cliques, ao "pairar" do ponteiro do mouse sobre eles, arrastando-os pela tela e assim por diante.  Veja como conectar um ouvinte de evento a um elemento que ocorre quando voc√™ clica nele com o mouse: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  E aqui est√° o c√≥digo HTML para este elemento: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  Ao usar a API para trabalhar com elementos personalizados, toda essa l√≥gica pode ser inclu√≠da no pr√≥prio elemento.  Para compara√ß√£o - abaixo est√° o c√≥digo para declarar um elemento personalizado que inclui um manipulador de eventos: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  E aqui est√° como fica no c√≥digo HTML da p√°gina: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  √Ä primeira vista, pode parecer que mais linhas de c√≥digo JS s√£o necess√°rias para criar um elemento customizado.  No entanto, em aplicativos do mundo real, raramente acontece que esses elementos sejam criados apenas para serem usados ‚Äã‚Äãapenas uma vez.  Outro fen√¥meno t√≠pico em aplicativos da web modernos √© que a maioria dos elementos neles s√£o criados dinamicamente.  Isso leva √† necessidade de oferecer suporte a dois cen√°rios diferentes de trabalho com elementos - situa√ß√µes em que eles s√£o adicionados √† p√°gina dinamicamente usando JavaScript e situa√ß√µes em que s√£o descritos na estrutura HTML original da p√°gina.  Gra√ßas ao uso de elementos personalizados, o trabalho nessas duas situa√ß√µes √© simplificado. <br><br>  Como resultado, se resumirmos os resultados desta se√ß√£o, podemos dizer que os elementos do usu√°rio tornam o c√≥digo mais claro, simplificam seu suporte, ajudam a dividi-lo em pequenos m√≥dulos, que incluem toda a funcionalidade necess√°ria e s√£o adequados para reutiliza√ß√£o. <br><br>  Agora que discutimos os problemas gerais de trabalhar com elementos personalizados, vamos falar sobre seus recursos. <br><br><h2>  <font color="#3AC1EF">Exig√™ncias</font> </h2><br>  Antes de come√ßar a desenvolver seus pr√≥prios elementos personalizados, voc√™ deve conhecer algumas das regras que deve seguir ao cri√°-las.  Aqui est√£o elas: <br><br><ul><li>  O nome do componente deve incluir um h√≠fen (s√≠mbolo <code>-</code> ).  Gra√ßas a isso, o analisador HTML pode distinguir entre elementos incorporados e elementos do usu√°rio.  Al√©m disso, essa abordagem garante que n√£o haja colis√µes de nomes com elementos internos (tanto com os que est√£o agora como com os que aparecer√£o no futuro).  Por exemplo, o nome real do elemento customizado √© <code>&gt;my-custom-element&lt;</code> , e os nomes <code>&gt;myCustomElement&lt;</code> e <code>&lt;my_custom_element&gt;</code> n√£o s√£o adequados. </li><li>  √â proibido registrar a mesma tag mais de uma vez.  Tentar fazer isso far√° com que o navegador <code>DOMException</code> erro de <code>DOMException</code> .  Elementos personalizados n√£o podem ser redefinidos. </li><li>  Tags personalizadas n√£o podem ser fechadas automaticamente.  O analisador HTML suporta apenas um conjunto limitado de tags de fechamento autom√°tico padr√£o (por exemplo, <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">As possibilidades</font> </h2><br>  Vamos falar sobre o que voc√™ pode fazer com elementos personalizados.  Se voc√™ responder a essa pergunta em poucas palavras, acontece que voc√™ pode fazer muitas coisas interessantes com elas. <br><br>  Um dos recursos mais not√°veis ‚Äã‚Äãdos elementos personalizados √© que a declara√ß√£o de uma classe de elemento se refere ao pr√≥prio elemento DOM.  Isso significa que voc√™ pode usar a palavra-chave this em um an√∫ncio para conectar ouvintes de eventos, acessar propriedades, n√≥s filhos e assim por diante. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  Isso, √© claro, possibilita a grava√ß√£o de novos dados nos n√≥s filhos do elemento.  No entanto, n√£o √© recomend√°vel fazer isso, pois isso pode levar a um comportamento inesperado dos elementos.  Se voc√™ imaginar que est√° usando elementos projetados por outra pessoa, provavelmente ficar√° surpreso se sua pr√≥pria marca√ß√£o colocada no elemento for substitu√≠da por outra. <br><br>  Existem v√°rios m√©todos que permitem executar o c√≥digo em determinados pontos do ciclo de vida de um elemento. <br><br><ul><li>  O m√©todo <code>constructor</code> √© chamado uma vez, ao criar ou "atualizar" o elemento (falaremos sobre isso abaixo).  Na maioria das vezes, √© usado para inicializar o estado de um elemento, conectar ouvintes de eventos, criar um DOM DOM e assim por diante.  N√£o esque√ßa que voc√™ sempre precisa chamar <code>super()</code> no construtor. </li><li>  O m√©todo <code>connectedCallback</code> √© chamado toda vez que um elemento √© adicionado ao DOM.  Ele pode ser usado (e √© exatamente dessa maneira que √© recomend√°vel us√°-lo) para adiar a execu√ß√£o de qualquer a√ß√£o at√© o momento em que o elemento aparecer na p√°gina (por exemplo, desta forma, voc√™ pode atrasar o carregamento de alguns dados). </li><li>  O <code>disconnectedCallback</code> √© chamado quando um item √© removido do DOM.  Geralmente √© usado para liberar recursos.  Observe que esse m√©todo n√£o √© chamado se o usu√°rio fechar a guia do navegador com a p√°gina.  Portanto, n√£o confie nele quando necess√°rio para executar algumas a√ß√µes particularmente importantes. </li><li>  O m√©todo <code>attributeChangedCallback</code> √© chamado quando um <code>attributeChangedCallback</code> elemento √© adicionado, removido, atualizado ou substitu√≠do.  Al√©m disso, √© chamado quando o elemento √© criado pelo analisador.  No entanto, observe que esse m√©todo se aplica apenas aos atributos listados na propriedade <code>observedAttributes</code> . </li><li>  O m√©todo <code>adoptedCallback</code> chamado quando o m√©todo <code>document.adoptNode(...)</code> √© usado, usado para mover o n√≥ para outro documento. </li></ul><br>  Observe que todos os m√©todos acima s√£o s√≠ncronos.  Por exemplo, o m√©todo <code>connectedCallback</code> √© chamado imediatamente ap√≥s o elemento ser adicionado ao DOM, e o restante do programa aguarda a conclus√£o desse m√©todo. <br><br><h2>  <font color="#3AC1EF">Reflex√£o da propriedade</font> </h2><br>  Os elementos HTML incorporados t√™m um recurso muito conveniente: reflex√£o de propriedade.  Gra√ßas a esse mecanismo, os valores de algumas propriedades s√£o refletidos diretamente no DOM como atributos.  Digamos que isso seja caracter√≠stico da propriedade <code>id</code> .  Por exemplo, realizamos a seguinte opera√ß√£o: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Altera√ß√µes relevantes afetar√£o o DOM: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Este mecanismo opera na dire√ß√£o oposta.  √â muito √∫til porque permite configurar elementos declarativamente. <br><br>  Os elementos personalizados n√£o possuem esse recurso interno, mas voc√™ pode implement√°-lo.  Para que algumas propriedades dos elementos do usu√°rio se comportem de maneira semelhante, voc√™ pode configurar seus getters e setters. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Estendendo itens existentes</font> </h2><br>  A API de elementos personalizados permite criar n√£o apenas novos elementos HTML, mas tamb√©m estender os existentes.  Al√©m disso, estamos falando de elementos padr√£o e personalizados.  Isso √© feito usando a <code>extends</code> ao declarar uma classe: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Elementos padr√£o estendidos tamb√©m s√£o chamados de "elemento interno personalizado". <br><br>  √â recomend√°vel estabelecer uma regra para sempre expandir elementos existentes e faz√™-lo progressivamente.  Isso permitir√° que voc√™ salve em novos elementos os recursos que foram implementados nos elementos criados anteriormente (ou seja, propriedades, atributos, fun√ß√µes). <br><br>  Observe que agora os elementos internos personalizados s√£o suportados apenas no Chrome 67 ou superior.  Isso aparecer√° em outros navegadores, no entanto, sabe-se que os desenvolvedores do Safari decidiram n√£o implementar esta oportunidade. <br><br><h2>  <font color="#3AC1EF">Atualizar itens</font> </h2><br>  Como j√° mencionado, o <code>customElements.define(...)</code> √© usado para registrar elementos customizados.  No entanto, o registro n√£o pode ser chamado de a√ß√£o que deve ser executada em primeiro lugar.  O registro do elemento do usu√°rio pode ser adiado por um tempo; al√©m disso, esse momento pode chegar mesmo quando o elemento j√° foi adicionado ao DOM.  Esse processo √© chamado de atualiza√ß√£o.  Para descobrir quando um item ser√° registrado, o navegador fornece o <code>customElements.whenDefined(...)</code> .  Ele recebe o nome da tag do elemento e retorna a promessa que √© resolvida ap√≥s o registro do elemento. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  Por exemplo, pode ser necess√°rio adiar o registro de um elemento at√© que seus filhos sejam declarados.  Essa linha de comportamento pode ser extremamente √∫til se o projeto aninhar elementos do usu√°rio.  √Äs vezes, um pai pode confiar na implementa√ß√£o de elementos filho.  Nesse caso, voc√™ precisa garantir que os filhos sejam registrados antes dos pais. <br><br><h2>  <font color="#3AC1EF">Shadow dom</font> </h2><br>  Como j√° mencionado, os elementos personalizados e o Shadow DOM s√£o tecnologias complementares.  A primeira permite encapsular a l√≥gica JS nos elementos do usu√°rio e a segunda permite criar ambientes isolados para fragmentos DOM que n√£o s√£o afetados pelo que est√° fora deles.  Se voc√™ acha que precisa entender melhor o conceito Shadow DOM, d√™ uma olhada em uma de nossas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√µes anteriores</a> . <br><br>  Veja como usar o Shadow DOM para um elemento personalizado: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  Como voc√™ pode ver, chamar <code>this.attachShadow</code> desempenha um papel fundamental <code>this.attachShadow</code> . <br><br><h2>  <font color="#3AC1EF">Padr√µes</font> </h2><br>  Em um de nossos artigos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriores</a> , falamos um pouco sobre modelos, embora eles sejam, de fato, dignos de um artigo separado.  A seguir, veremos um exemplo simples de como incorporar modelos em elementos personalizados quando eles s√£o criados.  Portanto, usando a <code>&lt;template&gt;</code> , voc√™ pode descrever o fragmento DOM que ser√° processado pelo analisador, mas n√£o ser√° exibido na p√°gina: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  Veja como aplicar um modelo em um elemento personalizado: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  Como voc√™ pode ver, h√° uma combina√ß√£o de um elemento personalizado, um Shadow DOM e modelos.  Isso nos permitiu criar um elemento isolado em seu pr√≥prio espa√ßo, no qual a estrutura HTML √© separada da l√≥gica JS. <br><br><h2>  <font color="#3AC1EF">Estiliza√ß√£o</font> </h2><br>  At√© agora, falamos apenas de JavaScript e HTML, ignorando CSS.  Portanto, agora abordamos o tema dos estilos.  Obviamente, precisamos de uma maneira de estilizar elementos personalizados.  Os estilos podem ser adicionados dentro do Shadow DOM, mas surge a quest√£o de como estilizar esses elementos de fora, por exemplo - se eles n√£o forem usados ‚Äã‚Äãpela pessoa que os criou.  A resposta a esta pergunta √© bastante simples - os elementos personalizados s√£o estilizados da mesma maneira que os elementos internos. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Observe que os estilos externos t√™m preced√™ncia sobre os estilos declarados dentro de um elemento, substituindo-os. <br><br>  Voc√™ pode ter visto como, quando uma p√°gina √© exibida na tela, em algum momento voc√™ pode observar conte√∫do n√£o estilizado nela (√© o que se chama FOUC - Flash Of Unstyled Content).  Voc√™ pode evitar esse fen√¥meno definindo estilos para componentes n√£o registrados e usando alguns efeitos visuais ao registr√°-los.  Para fazer isso, voc√™ pode usar o seletor <code>:defined</code> .  Voc√™ pode fazer isso, por exemplo, assim: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Elementos desconhecidos e elementos de usu√°rio indefinidos</font> </h2><br>  A especifica√ß√£o HTML √© muito flex√≠vel, permite declarar as tags necess√°rias para o desenvolvedor.  E, se a tag n√£o for reconhecida pelo navegador, ser√° processada pelo analisador como <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  No entanto, ao trabalhar com elementos personalizados, esse esquema n√£o se aplica. ,       ?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         ‚Äî   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   ‚Äî   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Caros leitores!</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419831/">https://habr.com/ru/post/pt419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419817/index.html">Iniciando o Cluster RabbitMQ no Kubernetes</a></li>
<li><a href="../pt419819/index.html">Biomarcadores de envelhecimento. Fragilidade do painel. Parte 2</a></li>
<li><a href="../pt419823/index.html">Dueto incomum - senhas e imagens mnem√¥nicas</a></li>
<li><a href="../pt419825/index.html">Testando o desempenho de v√°rios tipos de unidades em um ambiente virtual</a></li>
<li><a href="../pt419829/index.html">A criptografia de chave padr√£o do OpenSSH √© pior que nenhuma</a></li>
<li><a href="../pt419833/index.html">Trabalho remoto, como funciona</a></li>
<li><a href="../pt419835/index.html">Como motivar autores, negociar com especialistas e geralmente escrever bons artigos</a></li>
<li><a href="../pt419837/index.html">Eu, RoboLoyer, ou como procurar anomalias nos documentos</a></li>
<li><a href="../pt419839/index.html">Hacking ATM de baixo n√≠vel da NCR</a></li>
<li><a href="../pt419843/index.html">GeekUniversity abre inscri√ß√µes na Faculdade de Intelig√™ncia Artificial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>