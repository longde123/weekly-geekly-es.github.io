<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïπÔ∏è üò§ ‚¨ÖÔ∏è Reddit Mobile Architecture Evolution üò¢ ü§öüèæ ‚ùóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der erste Artikel, in dem wir √ºber die Architektur der Reddit-Anwendung f√ºr iOS sprechen. Hier geht es um Funktionen, die n√§her an der Benutz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reddit Mobile Architecture Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423531/"><img src="https://habrastorage.org/webt/1r/dn/uj/1rdnujtx26d-qbtgc7g3w7g6cui.jpeg"><br><br>  Dies ist der erste Artikel, in dem wir √ºber die Architektur der Reddit-Anwendung f√ºr iOS sprechen.  Hier geht es um Funktionen, die n√§her an der Benutzeroberfl√§che arbeiten.  Insbesondere der √úbergang zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Model-View-Presenter</a> (MVP) -Architektur.  Die Vorteile eines solchen Refactorings: <br><br><ul><li>  Verbesserung der Codeflexibilit√§t, -klarheit und -wartbarkeit, um zuk√ºnftiges Wachstum zu unterst√ºtzen und Iterationen zu beschleunigen. </li><li>  Die Scroll-Leistung wurde um das 1,58-fache erh√∂ht. </li><li>  Stimulierende Unit-Tests.  Die Anzahl der Tests stieg von wenigen auf √ºber 200. </li></ul><a name="habracut"></a><br>  Unten sehen Sie ein visuelles Diagramm unserer Schichtarchitektur.  Der erste Artikel konzentriert sich auf die Ebenen "Ansicht" und "Pr√§sentator". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/640/d33/51d640d336e400357f95b3f1e7c7121d.png"></div><br>  <i><font color="gray">Der ultimative Blick auf unsere geschichtete Architektur</font></i> <br><br><h1>  Voraussetzungen f√ºr Ver√§nderung </h1><br>  Vor mehr als einem Jahr haben wir den Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûErstellen eines Men√ºbands in einer Reddit iOS-App‚Äú ver√∂ffentlicht</a> .  Es wurde erl√§utert, wie ein produktiver, erweiterbarer Feed mit einer bemerkenswerten Sitzungsrate von 99,95% ohne Absturz generiert werden kann.  Wir haben erkl√§rt, wie Sie die MVC-Architektur (Model-View-Controller) verwenden und Abstraktionen f√ºr Paging-Daten erstellen. <br><br>  Jetzt ist Reddit gewachsen und w√§chst als Organisation und als Dienstleistung weiter.  Infolgedessen sind die Anforderungen an die Reddit iOS-Anwendung gestiegen.  Es sollte mehr Funktionsanforderungen, schnellere iterative Schleifen und h√∂here Qualit√§tsstandards unterst√ºtzen.  Das Entwicklungsteam ist von drei auf mehr als zwanzig Personen angewachsen.  Die urspr√ºngliche MVC-Architektur erf√ºllt diese Anforderungen kaum, sodass architektonische √Ñnderungen vorgenommen werden mussten. <br><br><h1>  Das Wesentliche des Problems </h1><br>  Im Laufe der Zeit hat der Code an Flexibilit√§t und Klarheit verloren.  In der iOS-Entwicklergemeinde wird die Abk√ºrzung MVC h√§ufig als Massive View Controller entschl√ºsselt, da View Controller h√§ufig zu g√∂ttlichen Objekten mit mehr als tausend Zeilen anschwellen.  Trotz all unserer Bem√ºhungen trat das Problem wirklich auf: Die Vererbungshierarchie wurde unangenehm tief, und die Kontrolleure begannen, sich in obskure g√∂ttliche Objekte zu verwandeln, die Ver√§nderungen widerstehen. <br><br>  Wir haben den letzten Nagel in den MVC-Sarg getrieben, als wir beschlossen, die Pr√§sentationsstufe f√ºr das Band zu √§ndern.  Das Publikum der Reddit-Anwendung w√§chst, sodass die Bildlaufleistung zu oft von 60 FPS auf 45 bis 55 FPS herabgesetzt wurde.  Dies bedeutet, dass Sie die Bandpr√§sentationsebene neu schreiben m√ºssen, w√§hrend Sie die urspr√ºngliche Implementierung beibehalten.  In der vorhandenen MVC-Architektur konnten wir die Bandpr√§sentationsschicht jedoch nicht neu schreiben, ohne Tausende von Codezeilen zu duplizieren. <br><br>  Dar√ºber hinaus sind viele Teile der Codebasis schwer zu testen.  Der Code befindet sich in der hart getesteten Klasse der Pr√§sentationsschicht, und die Abh√§ngigkeiten sind h√§ufig allein (Singleton) oder in der Klasse selbst fest codiert.  Wir wollten die M√∂glichkeit normaler Tests realisieren. <br><br>  Weitere Aufgaben f√ºr das Refactoring: Die Anzahl der Fehler sollte gering bleiben, die neue Architektur sollte die Grundlage f√ºr zuk√ºnftiges Wachstum bilden und Funktionen, die von der vorhandenen Infrastruktur abh√§ngen, nicht beeintr√§chtigen.  Das hei√üt, evolution√§re, nicht revolution√§re √Ñnderungen sind erforderlich. <br><br><h1>  √úbergang zu MVP </h1><br>  Wir haben beschlossen, dass zur L√∂sung der oben genannten Probleme eine neue Version der Anwendung ben√∂tigt wird.  Nachdem wir verschiedene Optionen in Betracht gezogen hatten, entschieden wir uns f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Model-View-Presenter</a> (MVP) -Architektur.  MVP erf√ºllt alle diese Kriterien und ist eine bekannte und dokumentierte Architektur, sodass es einfacher ist, Ingenieure auszubilden.  Das Konzept der ‚ÄûAnsichtsmodelle‚Äú wird ebenfalls beibehalten.  Bei Bedarf k√∂nnen Sie in Presenter Ansichtsmodellobjekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach dem Prinzip der alleinigen Verantwortung</a> erstellen und diese zum Erweitern unserer Ansichten verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9d/71a/cc4/d9d71acc4bf37f6494d524015b4fb55f.png"></div><br>  <i><font color="gray">Model-View-Presenter-Diagramm</font></i> <br><br><h1>  Massive View Controller loswerden </h1><br>  F√ºr iOS-Anwendungen wird angenommen, dass Ansichtsobjekte Unterklassen von UIView sind, Controller-Objekte Unterklassen von UIViewController sind und Modellobjekte einfache alte Objekte sind.  Wie der Name UIViewController andeutet, werden hier die Ansicht und der Controller in einem Objekt zusammengefasst.  Das hei√üt, das MVC-Modell unter iOS verliert h√§ufig seine Vorteile aufgrund der engen Verbindung zwischen der Pr√§sentationsebene und dem Controller.  Interessanterweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erkennt</a> Apple selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Verbindung</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b21/06c/33f/b2106c33f786ae4c88477a1bed5d2eb0.png"></div><br>  <i><font color="gray">Oft wird die Model-View-Controller-Architektur f√ºr iOS zu</font></i> <br><br>  In der MVP-Architektur ber√ºcksichtigen wir dieses Konzept und formalisieren es, indem wir den UIViewController wirklich als explizites Objekt der Pr√§sentationsschicht betrachten.  Das Konzept, einen UIViewController als Pr√§sentationsobjekt mit einem schlechten Ruf zu behandeln, ist in den letzten Jahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">popul√§r geworden</a> . <br><br>  Daher entfernen wir alle √ºberfl√ºssigen Logik in unseren UIViewControllern.  Anschlie√üend weisen wir dem Vermittler zwischen der Ansicht und dem Modell Presenter zu.  In dieser neuen Rolle sind ihm Ansichtsobjekte wie der UIViewController nicht bekannt.  Beachten Sie, dass Presenter √ºber eine Schnittstelle mit der Ansicht interagiert.  Theoretisch k√∂nnen Sie die Implementierung einer Ansicht in NSViewController (f√ºr MacOS) usw. √§ndern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/85c/ee2/33285cee27e5526bbdaf6f136487fe4b.png"></div><br>  <i><font color="gray">Wir vereinfachen ViewController, indem wir Presenter einf√ºhren und Verantwortlichkeiten teilen</font></i> <br><br><h1>  √úber MVP-Optionen nachdenken </h1><br>  Wie Sie im MVP-Diagramm sehen k√∂nnen, war die Architektur MVC sehr √§hnlich.  In der Tat gibt es mehr √Ñhnlichkeiten als Unterschiede.  Eine solche Architektur hilft einfach dabei, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">korrekte Trennung von Pr√§sentationscode und Gesch√§ftslogik</a> herzustellen, die MVC sucht.  Tats√§chlich sind alle Ableitungen der Architektur von MV (x) wie MVP, MVVM, MVAdapter und andere einfach unterschiedliche Versionen desselben Konzepts. <br><br>  Man k√∂nnte sich fragen, warum wir MVC komplett aufgegeben haben.  Tats√§chlich beschreibt Apple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedene Arten von Controllern</a> : f√ºr Modelle, Vermittler und Koordination.  Ehrlich gesagt, k√∂nnten wir vielleicht unseren Presenter durch einen anderen Controller ersetzen.  Sie entschieden sich jedoch dagegen, da die meisten iOS-Entwickler aus irgendeinem Grund der Ansicht waren, dass der UIViewController ein Synonym f√ºr den Controller ist.  Mit dem Wort Presenter geben wir ein Signal, dass sich dieses Objekt erheblich von einem herk√∂mmlichen Controller mit bestimmten Funktionen und Eigenschaften unterscheidet. <br><br><h1>  Verbesserung von Flexibilit√§t, Nachhaltigkeit und Klarheit </h1><br>  "Komposition lieber als Vererbung" ist ein bekanntes Mantra in der Objektprogrammierung.  Mit der Vererbung m√ºssen Sie die Zukunft vorhersagen und eine riesige Taxonomie von Objekten erstellen.  Wenn jedoch Ihre ‚Äûideal‚Äú erstellte Vererbungshierarchie aufgrund unvorhergesehener √Ñnderungen auseinanderzufallen beginnt, ist es schwierig, diese starre Struktur zu √§ndern.  In der Komposition werden Objekte aus anderen Objekten erstellt und delegieren Arbeiten an diese.  Dies ist n√ºtzlich, da es einfach ist, das Verhalten eines Objekts zur Laufzeit zu √§ndern, indem Sie einfach die Objekte √§ndern, aus denen es besteht.  Diese zusammengesetzten Objekte sind noch verst√§ndlicher, da der Code aus der Vererbungshierarchie in eine Abstraktion gezwungen wird, die sich an einer bestimmten Aufgabe orientiert. <br><br>  Eine solche Komposition ist einer der Hauptvorteile, die uns die MVP-Architektur gegeben hat.  Jetzt k√∂nnen Sie das Verhalten des Controllers √§ndern, indem Sie einfach die Zusammensetzung eines bestimmten Pr√§sentators √§ndern.  Wir sind jetzt weniger besorgt √ºber die Entschl√ºsselung der komplexen und starren Vererbungsstruktur.  Schlie√ülich sind View Controller und Presenter-Objekte leichter zu verstehen, da sie klarere Aufgaben haben. <br><br>  Durch die Einf√ºhrung von Presenter und das Verschieben eines Teils der View-Controller-Logik haben wir die Controller-Vererbungshierarchie vereinfacht.  Die folgende Abbildung zeigt, dass wir die GalleryFeedViewController-Klasse entfernen konnten, da wir all diese Logik in den Presenter eingef√ºgt haben.  Wie bereits erw√§hnt, ist eine solche Vererbungshierarchie leichter zu verstehen und weniger starr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b56/d90/c13/b56d90c13388424bf32dcad9ccbd8b1a.png"></div><br>  <i><font color="gray">Vereinfachen Sie die Vererbungshierarchie durch Komposition</font></i> <br><br><h1>  Freie √Ñnderung an der Implementierung der Pr√§sentationsschicht </h1><br>  Wie bereits erw√§hnt, begann die Bildlaufleistung von 60 FPS auf 45 bis 55 FPS zu sinken.  Aus diesem Grund haben wir uns f√ºr die Bandpr√§sentationsebene f√ºr die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texture entschieden</a> .  Es handelt sich um eine Open-Source-Plattform auf Apple UIKit-Basis, die die Schnittstellenleistung durch Vorverarbeitung im Hintergrundthread verbessert.  In der vergangenen MVC-Architektur konnten wir die Implementierung auf Pr√§sentationsebene nicht ohne viel Codeduplizierung √§ndern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/836/f03/2dd/836f032dd8dfc3b87940913d0352a9da.png"></div><br>  <i><font color="gray">Vor der Implementierung von MVP mussten Sie im ViewController fremden Code duplizieren, der nicht mit View zusammenh√§ngt (orange).</font></i> <br><br>  Die neue MVP-Architektur erm√∂glichte die Einf√ºhrung der Texturunterst√ºtzung, anstatt die Dinge von Grund auf neu zu schreiben.  Wir haben nur die gesamte Nicht-View-Logik in die generische Presenter-Klasse eingef√ºgt.  Dann schrieben sie eine neue Implementierung der c-Textur-Pr√§sentationsschicht und verwendeten den Presenter-Code erneut.  Dies gab Unterst√ºtzung f√ºr beide Implementierungen von View, bis es Zeit war, das Band mit Texture f√ºr alle Benutzer bequem auszurollen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/4fb/8bc/bcc4fb8bc0d4426c9409015a0528a7ec.png"></div><br>  <i><font color="gray">Nach der MVP-Implementierung: Code ohne Ansicht in Shared Presenter verschoben</font></i> <br><br>  Was ist das Ergebnis?  Das folgende Diagramm zeigt eine Steigerung der Band-Scroll-Leistung.  Wir wollten ungef√§hr 60 FPS bleiben, um ein absolut fl√ºssiges Scrollen zu erreichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91d/421/7fb/91d4217fbf1d8576f9b28f5d6029ab94.png"></div><br><br><h1>  Unit Testing </h1><br>  Nat√ºrlich haben wir Unit-Tests nicht nur wegen MVP implementiert, sondern es war auch ein wichtiger Faktor.  Insbesondere die MVP-Architektur hat den Testbereich erweitert, indem Code auf eine Ebene verschoben wurde, auf der die √úberpr√ºfung einfacher ist.  Ein Nebeneffekt ist, dass die Ansichtsebenen einfacher geworden sind - und daher weniger h√§ufig getestet werden m√ºssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/1c5/f09/eb51c5f094d5e10252c25110e97514e1.png"></div><br>  <i><font color="gray">Erh√∂hen des Testbereichs nach dem Verschieben von Nicht-View-Code au√üerhalb dieser Ebene</font></i> <br><br>  Unit-Tests haben die Unterst√ºtzung der Codebasis verbessert: Sie erm√∂glichen es Ihnen, √Ñnderungen sicherer vorzunehmen und das richtige Verhalten zu verstehen.  Sie machen den Code auch flexibler und verst√§ndlicher, da sie Methoden wie Abh√§ngigkeitsinjektion, Komposition und Abstraktionsprogrammierung f√∂rdern.  Die Anzahl der Unit-Tests ist von wenigen auf √ºber 200 gestiegen. <br><br><h1>  Kritische Analyse von MVP in Reddit </h1><br>  Obwohl der Wechsel zu MVP viel geholfen hat, gibt es noch ein paar Dinge zu beachten. <br><br>  Der √úbergang des Bandes zu Texture verursachte neue Probleme mit Threads.  Die Anwendung unterst√ºtzte die asynchrone Implementierung von View zun√§chst nicht.  Das hei√üt, Fehler treten unvermeidlich auf, wenn der Ansichtsstatus und der Status der Anwendung nicht √ºbereinstimmen.  Beispielsweise kann eine Bandansicht N Datens√§tze enthalten.  Und im Hintergrund-Thread hat sich der Status der Anwendung leise ge√§ndert - und enth√§lt jetzt weniger als N Nachrichten.  Wenn die Diskrepanz nicht behoben wird, st√ºrzt die Anwendung einfach ab, wenn View versucht, den n-ten Beitrag im Stream anzuzeigen. <br><br>  Die am schwierigsten zu behebenden Fehler mit Threads.  Sie sind schwer zu reproduzieren, daher sind sie schwer zu debuggen.  Ich musste die Logik der Anfrage √§ndern und Daten empfangen, um den Feed anzuzeigen.  Insbesondere haben wir "Schutz" implementiert, mit dem Verbot von √Ñnderungen an der Datenquelle, wenn die Ansicht des Bandes einige √Ñnderungen erf√§hrt.  Diese und andere kleinere Korrekturen reduzierten die Anzahl der mit der Streaming-Verarbeitung verbundenen Fehler.  Das asynchrone Multithreading kann jedoch noch verbessert werden. <br><br>  Zweitens stellt die Presenter-Ebene einen zus√§tzlichen ‚ÄûSchritt‚Äú in der Pipeline dar.  Dieser Schritt hat seinen Preis in Bezug auf die Erh√∂hung der Codekomplexit√§t und die Verringerung der Leistung.  Manchmal m√∂chten Sie diese Logik nur aus einer Laune heraus oder weil Sie es gewohnt sind, im UIViewController ausf√ºhren.  Im schlimmsten Fall werden Sie feststellen, dass Presenter einfach als Entit√§t ohne sinnvolle Logik vorhanden ist.  In einer solchen Situation scheint der Pr√§sentator seine Existenz nicht zu rechtfertigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8c/2b8/4c7/f8c2b84c7672d146fe7b9ac37eee24c8.png"></div><br>  <i><font color="gray">Manchmal k√∂nnen Sie ohne Presenter von einer Ansichtsebene zu einer RedditCore-Ebene wechseln</font></i> <br><br>  Tats√§chlich ist unsere Anwendung nicht vollst√§ndig in die MVP-Architektur konvertiert.  Erstens ist die Konvertierung jedes einzelnen UIViewControllers in einen Presenter zu zeitaufw√§ndig - und nicht evolution√§r.  Zweitens wird, wie im vorherigen Absatz erw√§hnt, Presenter manchmal einfach nicht ben√∂tigt.  Wie wir in unserer Arbeit zur Implementierung von Texture for Ribbon festgestellt haben, eignet sich Presenter hervorragend zur Erleichterung einer massiven MVC oder zur Implementierung von View mit variablem Verhalten oder wenn Sie √ºber eine komplexe Logik verf√ºgen, die √ºberpr√ºft werden muss.  Aber manchmal ist der UIViewController so einfach, dass Presenter keinen Sinn ergibt.  Es ist also optional.  Presenter sollte nur bei Bedarf implementiert werden. <br><br><h1>  Zusammenfassung und Zukunftspl√§ne </h1><br>  Durch die √úberarbeitung der MVP-Architektur in der Reddit iOS-App konnten viele der Aufgaben gel√∂st werden.  Durch die Einf√ºhrung der Presenter-Schicht haben wir schrittweise die Anwendungsarchitektur entwickelt, um die neue Implementierung der Pr√§sentationsschicht zu unterst√ºtzen, ohne andere Funktionen zu st√∂ren.  Der Code wurde klarer, indem die "massive MVC" erleichtert wurde - die √úbertragung von Fremdlogik auf die Presenter-Ebene.  Wir haben Entwicklern auch die M√∂glichkeit gegeben, schneller zu iterieren und neue Funktionen bereitzustellen.  Und die Tests deutlich verbessert. <br><br>  Angesichts all dessen ist es noch ein langer Weg.  Wir erstellen weiterhin Presenter-Objekte und verbessern sie.  Wir m√ºssen weiterhin fremde Logik von UIViewControllern auf die Presenter-Ebene verschieben.  Es ist auch notwendig, dass alle Pr√§sentatoren besser auf das Prinzip der alleinigen Verantwortung ausgerichtet sind.  Am Ende entwickeln sich sowohl die Anwendung als auch die Architektur st√§ndig weiter. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423531/">https://habr.com/ru/post/de423531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423519/index.html">Wandering Monster: Wie man Probleme auf der Karte beseitigt</a></li>
<li><a href="../de423521/index.html">Sieben Faustregeln zum Experimentieren mit Websites</a></li>
<li><a href="../de423523/index.html">Kombinierter Sensor mit Vorlieben und Dichtern</a></li>
<li><a href="../de423527/index.html">Kinder-Apps sammeln massiv personenbezogene Daten und geben diese an Dritte weiter</a></li>
<li><a href="../de423529/index.html">Was braucht das ganze Team, um zu arbeiten? Wie kann man alle in das Projektmanagementsystem ziehen?</a></li>
<li><a href="../de423533/index.html">FAQ f√ºr Intercity-Passagierbusfl√ºge</a></li>
<li><a href="../de423535/index.html">Warum greifen M√ºlleimer auf das Internet zu?</a></li>
<li><a href="../de423537/index.html">K√ºnstliche Intelligenz im Dienste der Netzwerksicherheit. Teil 1</a></li>
<li><a href="../de423539/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends in den letzten zwei Wochen Nr. 330 (3. - 16. September 2018)</a></li>
<li><a href="../de423541/index.html">Kodi-Addons werden verwendet, um Crypto Miner zu verteilen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>