<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ¾ ğŸš¶ğŸ¿ ğŸ‘ğŸ¿ Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 3 ğŸ‘¨ğŸ»â€ğŸš’ ğŸ¤— ğŸ†™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/425559/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: â€œPemisahan Hak Istimewaâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: â€œPeluangâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: â€œKotak Pasir Klien Asliâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 8: â€œModel Keamanan Jaringanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 9: "Keamanan Aplikasi Web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 10: â€œEksekusi simbolikâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Sekarang, mengikuti cabang ke bawah, kita melihat ekspresi t = y.  Karena kami mempertimbangkan satu jalur pada satu waktu, kami tidak harus memperkenalkan variabel baru untuk t.  Kita dapat mengatakan bahwa karena t = y, maka t tidak lagi 0. <br><br>  Kami terus bergerak ke bawah dan sampai ke titik di mana kami sampai ke cabang lain.  Apa asumsi baru yang harus kita buat untuk mengikuti jalan ini lebih jauh?  Ini adalah asumsi bahwa t &lt;y. <br><br>  Apa itu t?  Jika Anda mencari cabang kanan, kita akan melihat bahwa t = y.  Dan di tabel kami, T = y dan Y = y.  Secara logis ini mengikuti dari sini bahwa pembatasan kita terlihat seperti y &lt;y, yang tidak mungkin. <br><br><img src="https://habrastorage.org/webt/tu/pe/kp/tupekplxzar-nappngbqlwuy12y.jpeg"><br><br>  Dengan demikian, kami memiliki semuanya dalam urutan sampai kami mencapai titik ini t &lt;y.  Sampai kita sampai pada pernyataan yang salah, kita memiliki semua ketidaksetaraan untuk menjadi benar.  Tapi ini tidak berhasil, karena ketika melakukan tugas-tugas cabang kanan, kami memiliki inkonsistensi logis. <br><br>  Kita memiliki apa yang sering disebut kondisi sang jalan.  Kondisi ini harus benar untuk program berjalan seperti ini.  Tetapi kita tahu bahwa kondisi ini tidak dapat dipenuhi, oleh karena itu tidak mungkin bagi program untuk pergi seperti ini.  Jadi jalan ini sekarang telah sepenuhnya dihilangkan, dan kita tahu bahwa jalan yang benar ini tidak dapat dilalui. <br><br>  Bagaimana dengan sebaliknya?  Mari kita coba melalui cabang kiri dengan cara yang berbeda.  Apa yang akan menjadi kondisi untuk jalur ini?  Sekali lagi, keadaan simbolis kita dimulai pada t = 0, dan X dan Y sama dengan variabel x dan y. <br><br><img src="https://habrastorage.org/webt/5a/oo/cc/5aooccskimxeaooehicyxgew8jc.jpeg"><br><br>  Seperti apa batasan jalan dalam kasus ini sekarang?  Kami menunjukkan cabang kiri sebagai Benar, dan cabang kanan sebagai Salah dan selanjutnya mempertimbangkan nilai t = x.  Sebagai hasil dari pemrosesan logis dari kondisi t = x, x&gt; y dan t &lt;y, kita mendapatkan bahwa kita secara bersamaan memiliki apa yang x&gt; y dan x &lt;y. <br><br><img src="https://habrastorage.org/webt/jz/lz/9e/jzlz9e9yvnbqh7y3wwaowffufuc.jpeg"><br><br>  Jelas bahwa kondisi jalan ini tidak memuaskan.  Kita tidak dapat memiliki x yang lebih besar dan lebih kecil dari y.  Tidak ada tugas untuk variabel X yang memenuhi kedua kendala.  Dengan demikian, ini memberitahu kita bahwa cara lain juga tidak memuaskan. <br><br>  Ternyata pada saat ini kami menjelajahi semua jalur yang mungkin dalam program yang dapat membawa kami ke keadaan ini.  Kami benar-benar dapat menetapkan dan memverifikasi bahwa tidak ada cara yang mungkin yang akan membawa kami ke pernyataan yang salah. <br>  <b>Hadirin:</b> Dalam contoh ini, Anda menunjukkan bahwa Anda mempelajari kemajuan suatu program di sepanjang semua cabang yang mungkin.  Tetapi salah satu keuntungan dari eksekusi simbolik adalah bahwa kita tidak perlu mempelajari semua jalur eksponensial yang mungkin.  Jadi bagaimana cara menghindari ini dalam contoh ini? <br><br>  <b>Profesor:</b> Ini pertanyaan yang sangat bagus.  Dalam hal ini, Anda berkompromi antara eksekusi karakter dan seberapa spesifik Anda inginkan.  Jadi dalam kasus ini, kita tidak begitu banyak menggunakan eksekusi simbolis karena pertama kali kita melihat aliran program pada kedua cabang secara bersamaan.  Namun berkat ini, keterbatasan kami menjadi sangat, sangat sederhana. <br><br>  Batasan individu â€œsatu demi satuâ€ sangat sederhana, tetapi Anda harus melakukannya berulang kali, mempelajari semua cabang yang ada, dan secara eksponensial - dan semua cara yang mungkin. <br>  Ada banyak jalur secara eksponensial, tetapi untuk setiap jalur secara keseluruhan, ada juga sejumlah besar data input yang eksponensial yang dapat melewati jalur tersebut.  Jadi ini sudah memberi Anda keuntungan besar, karena alih-alih mencoba semua input yang mungkin, Anda mencoba untuk mencoba segala cara yang mungkin.  Tetapi bisakah Anda melakukan sesuatu yang lebih baik? <br><br>  Ini adalah salah satu area di mana banyak percobaan telah dilakukan mengenai eksekusi simbolik, misalnya, eksekusi simultan dari beberapa jalur.  Dalam materi kuliah Anda bertemu heuristik dan serangkaian strategi yang digunakan para eksperimen untuk membuat pencarian lebih dapat dipecahkan. <br><br>  Sebagai contoh, salah satu hal yang mereka lakukan adalah mereka mengeksplorasi satu demi satu, tetapi tidak melakukannya secara membabi buta.  Mereka memeriksa kondisi jalan setelah setiap langkah diambil.  Misalkan di sini di program kami, alih-alih mengatakan "salah," akan ada pohon program yang kompleks, grafik aliran kontrol. <br><br><img src="https://habrastorage.org/webt/ly/a_/em/lya_em86ezzhqftrrv247zfdnwq.jpeg"><br><br>  Anda tidak perlu menunggu sampai mencapai akhir untuk memverifikasi bahwa jalur ini layak.  Pada saat itu, ketika Anda mencapai kondisi t &lt;y, Anda sudah tahu bahwa jalan ini tidak memuaskan, dan Anda tidak akan pernah pergi ke arah itu.  Oleh karena itu, memotong cabang yang salah pada awal program mengurangi jumlah pekerjaan empiris.  Eksplorasi jalan yang wajar mencegah kemungkinan kegagalan program di masa depan.  Banyak alat praktis yang digunakan saat ini terutama dimulai dengan pengujian acak untuk mendapatkan set jalan awal, setelah itu mereka akan mulai menjelajahi jalan di lingkungan.  Mereka memproses banyak opsi untuk kemungkinan eksekusi program untuk masing-masing cabang, bertanya-tanya apa yang terjadi pada jalur ini. <br><br>  Ini sangat berguna jika kita memiliki serangkaian tes yang baik.  Anda menjalankan tes dan menemukan bahwa bagian kode ini tidak dieksekusi.  Oleh karena itu, Anda dapat mengambil jalur yang paling dekat dengan implementasi kode dan bertanya apakah jalur ini dapat diubah sehingga berjalan ke arah yang benar? <br><br><img src="https://habrastorage.org/webt/ik/26/yz/ik26yz36aargvenedflizgtebnu.jpeg"><br><br>  Tetapi pada saat Anda mencoba untuk membuat semua jalur pada saat yang sama, pembatasan mulai yang menjadi sulit.  Oleh karena itu, apa yang dapat Anda lakukan adalah melakukan satu fungsi pada satu waktu, sementara Anda dapat mempelajari semua jalur dalam suatu fungsi bersama.  Jika Anda mencoba membuat balok besar, maka secara umum Anda dapat menjelajahi semua cara yang mungkin. <br><br>  Yang paling penting adalah bahwa untuk setiap cabang Anda memeriksa batasan Anda dan menentukan apakah cabang ini benar-benar berjalan dua arah.  Jika dia tidak bisa mengikuti kedua jalan, Anda menghemat waktu dan usaha dengan tidak mengikuti ke arah mana dia tidak bisa pergi.  Selain itu, saya tidak ingat strategi khusus yang mereka gunakan untuk menemukan cara yang lebih mungkin menghasilkan hasil yang sangat baik.  Tetapi memotong cabang yang salah pada tahap awal sangat penting. <br><br>  Sampai sekarang, kita telah berbicara terutama tentang "kode mainan", tentang variabel integer, tentang cabang, tentang hal-hal yang sangat sederhana.  Tetapi apa yang terjadi ketika Anda memiliki program yang lebih kompleks?  Secara khusus, apa yang terjadi ketika Anda memiliki program yang mencakup banyak? <br><br><img src="https://habrastorage.org/webt/jh/u9/j0/jhu9j05lzmmvolihvaaluj4tqqe.jpeg"><br><br>  Secara historis, tumpukan pinggul telah menjadi kutukan dari semua analisis perangkat lunak karena hal-hal yang bersih dan elegan dari waktu Fortran meledak sepenuhnya ketika Anda mencoba menjalankannya menggunakan program C di mana Anda mengalokasikan memori kiri dan kanan.  Di sana Anda memiliki overlay dan semua kekacauan yang terkait dengan program dengan memori yang dialokasikan dan dengan pointer aritmatika.  Ini adalah salah satu bidang di mana eksekusi simbolis memiliki kemampuan luar biasa untuk beralasan tentang program. <br><br>  Jadi bagaimana kita melakukan ini?  Mari kita lupakan ranting-ranting dan kontrol aliran sejenak.  Kami punya program sederhana di sini.  Ini mengalokasikan sebagian memori, membatalkannya, dan mendapat pointer baru y dari pointer x.  Kemudian dia menulis sesuatu ke y dan memeriksa apakah nilai yang disimpan dalam pointer y sama dengan nilai yang disimpan dalam pointer x? <br><br>  Berdasarkan pengetahuan dasar tentang C, Anda dapat melihat bahwa pemeriksaan ini tidak dilakukan karena x diatur ulang dan y = 25, sehingga x menunjukkan lokasi yang berbeda.  Sejauh ini, semuanya baik-baik saja dengan kami. <br>  Cara kami memodelkan heap, dan cara heap dimodelkan pada kebanyakan sistem, menggunakan representasi heap di C, di mana itu hanyalah basis alamat raksasa, array raksasa di mana Anda dapat menempatkan data Anda. <br>  Ini berarti bahwa kami dapat mewakili program kami sebagai dataset global yang sangat besar, yang akan disebut MEM.  Ini adalah array yang pada dasarnya akan memetakan alamat ke nilai.  Alamat hanya memiliki nilai 64-bit.  Dan apa yang akan terjadi setelah Anda membaca sesuatu dari alamat ini?  Itu tergantung pada bagaimana Anda memodelkan memori. <br><br>  Jika Anda memodelkannya pada level byte, Anda mendapatkan byte.  Jika Anda memodelkannya di level kata, Anda mendapatkan kata.  Tergantung pada jenis kesalahan yang Anda minati, dan tergantung pada apakah Anda khawatir tentang alokasi memori atau tidak, Anda akan memodelkannya sedikit berbeda, tetapi biasanya memori hanyalah sebuah array dari alamat ke nilai. <br><br><img src="https://habrastorage.org/webt/ml/5h/u3/ml5hu3rxqhuwkwjute0ykkgzzru.jpeg"><br><br>  Jadi alamatnya hanya bilangan bulat.  Di satu sisi, tidak masalah apa yang C pikirkan tentang alamat, itu hanya bilangan bulat 64-bit atau 32-bit, tergantung pada mesin Anda.  Ini hanyalah nilai yang diindeks dalam memori ini.  Dan apa yang dapat Anda masukkan ke dalam memori, Anda dapat membaca dari memori itu. <br><br>  Oleh karena itu, hal-hal seperti pointer aritmatika menjadi aritmatika integer.  Dalam prakteknya, ada beberapa kesulitan, karena di C, pointer aritmatika tahu tentang tipe pointer, dan mereka akan meningkat secara proporsional dengan ukuran.  Jadi, sebagai hasilnya, kami mendapatkan baris berikut: <br><br>  y = x + 10;  ïƒ sizeof (int) <br><br><img src="https://habrastorage.org/webt/nw/kg/zi/nwkgziisznkedw-6waxmrpsdn9a.jpeg"><br><br>  Tetapi yang terpenting adalah apa yang terjadi ketika Anda menulis dan membaca dari ingatan.  Berdasarkan pada penunjuk bahwa 25 harus ditulis dalam y, saya mengambil array memori dan mengindeksnya dengan y.  Dan saya menulis 25 ke lokasi memori ini. <br><br>  Kemudian saya beralih ke pernyataan MEM [y] = MEM [x], membaca nilai dari lokasi y dalam memori, membaca nilai dari lokasi x dalam memori, dan membandingkannya satu sama lain.  Jadi saya periksa apakah cocok atau tidak. <br><br>  Ini adalah asumsi yang sangat sederhana, memungkinkan Anda untuk beralih dari program yang menggunakan heap ke program yang menggunakan array global raksasa yang mewakili memori.  Ini berarti bahwa sekarang, ketika berbicara tentang program yang mengelola heap, Anda benar-benar tidak perlu berbicara tentang program yang mengelola heap.  Anda akan berhasil berbicara tentang array, dan bukan tentang tumpukan. <br><br>  Ini pertanyaan sederhana lainnya.  Bagaimana dengan fungsi malloc?  Anda bisa mengambil dan menggunakan implementasi malloc di C, melacak semua halaman yang disorot, melacak semua yang telah dibebaskan, hanya memiliki daftar gratis, dan itu sudah cukup.  Ternyata untuk banyak tujuan dan untuk banyak jenis kesalahan Anda tidak perlu malloc menjadi kompleks. <br><br>  Bahkan, Anda dapat beralih dari malloc, yang terlihat seperti ini: x = malloc (sizeof (int) * 100), ke malloc semacam ini: <br><br>  POS = 1 <br>  Int malloc (int n) { <br>  rv = POS <br>  POS + = n; <br>  } <br><br>  Yang hanya mengatakan: "Saya akan menyimpan konter untuk ruang kosong berikutnya dalam memori, dan setiap kali seseorang meminta alamat, saya memberinya lokasi ini dan meningkatkan posisi ini, dan kemudian mengembalikan rv."  Dalam hal ini, apa yang malloc dalam pengertian tradisional benar-benar diabaikan. <br><br><img src="https://habrastorage.org/webt/pp/tl/_r/pptl_romuwu16scn3eykmzscdmm.jpeg"><br><br>  Dalam hal ini, tidak ada memori yang membebaskan.  Fungsi hanya terus bergerak lebih jauh dan lebih jauh dari memori, dan lebih jauh, dan lebih jauh, dan ini adalah di mana ia berakhir tanpa rilis apa pun.  Dia juga tidak terlalu peduli bahwa ada area memori di mana itu tidak layak ditulis, karena ada alamat khusus yang sangat penting untuk sistem operasi. <br><br>  Itu tidak memodelkan apa pun yang membuat penulisan fungsi malloc menjadi rumit, tetapi hanya pada tingkat abstraksi tertentu, ketika Anda mencoba untuk berbicara tentang beberapa jenis kode kompleks yang melakukan manipulasi pointer. <br><br>  Pada saat yang sama, Anda tidak peduli tentang mengosongkan memori, tetapi Anda khawatir tentang apakah program akan, misalnya, menulis di luar buffer, dalam hal ini fungsi malloc ini bisa sangat baik. <br><br><img src="https://habrastorage.org/webt/kw/hy/sr/kwhysrcz5pnqvcxeuskiazouxgs.jpeg"><br><br>  Dan ini sebenarnya terjadi sangat, sangat sering ketika Anda melakukan eksekusi simbolik kode nyata.  Langkah yang sangat penting adalah memodelkan fungsi perpustakaan Anda.  Cara Anda memodelkan fungsi perpustakaan akan memiliki dampak besar, di satu sisi, pada kinerja dan skalabilitas analisis, tetapi di sisi lain, itu juga akan mempengaruhi akurasi. <br><br>  Jadi jika Anda memiliki malloc model "mainan", seperti ini, itu akan bertindak sangat cepat, tetapi pada saat yang sama akan ada jenis kesalahan tertentu yang tidak dapat Anda perhatikan.  Jadi, misalnya, dalam model ini saya sepenuhnya mengabaikan distribusi, jadi saya mungkin mendapatkan kesalahan jika seseorang mendapatkan akses ke ruang yang tidak terisi.  Karena itu, dalam kehidupan nyata, saya tidak akan pernah menggunakan model malloc Mickey Mouse ini. <br><br>  Jadi selalu ada keseimbangan antara akurasi analisis dan efisiensi.  Dan semakin kompleks model fungsi standar, seperti yang didapatkan malloc, semakin kecil skalanya analisisnya.  Tetapi untuk beberapa kelas kesalahan Anda perlu model-model sederhana ini.  Oleh karena itu, berbagai perpustakaan di C sangat penting, yang diperlukan untuk memahami apa yang sebenarnya dilakukan oleh program semacam itu. <br><br>  Oleh karena itu, kami mengurangi masalah penalaran tentang tumpukan dengan alasan tentang program dengan array, tetapi saya tidak benar-benar memberitahu Anda bagaimana berbicara tentang program dengan array.  Ternyata sebagian besar SMT solver mendukung teori array. <br><br><img src="https://habrastorage.org/webt/p3/m3/4j/p3m34j1tdfcrmtpyngc-syfb7rs.jpeg"><br><br>  Idenya adalah bahwa jika a adalah array, maka ada beberapa notasi yang memungkinkan Anda untuk mengambil array ini dan membuat array baru, di mana lokasi saya diperbarui ke nilai e.  Apakah itu jelas? <br><br>  Oleh karena itu, jika saya memiliki array a, dan saya melakukan operasi pembaruan ini, dan kemudian mencoba membaca nilai k, maka ini berarti bahwa nilai k akan sama dengan nilai k dalam array a, jika k berbeda dari i, dan itu akan sama dengan e, jika k sama dengan i. <br><br>  Memperbarui array berarti Anda harus mengambil array lama dan memperbaruinya dengan array baru.  Nah, jika Anda memiliki rumus yang mencakup teori array, itu sebabnya saya mulai dengan array nol, yang di mana-mana diwakili hanya oleh nol. <br><br><img src="https://habrastorage.org/webt/ga/gt/v_/gagtv_latqjqssanfp7tqklcq5i.jpeg"><br><br>  Kemudian saya menulis 5 ke lokasi i dan 7 ke lokasi j, setelah itu saya membaca dari k dan memeriksa apakah 5 atau tidak.  Kemudian dapat diperluas menggunakan definisi untuk sesuatu yang mengatakan, misalnya: "jika k adalah i dan k adalah y, sedangkan k berbeda dari j, maka ya, itu akan menjadi 5, jika tidak maka tidak akan menjadi 5 ". <br><br>  Dan dalam praktiknya, pemecah SMT tidak hanya memperluas ini ke banyak rumus Boolean, mereka menggunakan strategi bolak-balik antara pemecah SAT dan mesin, yang mampu berbicara tentang teori array untuk melakukan pekerjaan ini. <br><br>  Yang penting adalah bahwa dengan mengandalkan teori array ini, menggunakan strategi yang sama yang kami terapkan untuk menghasilkan rumus untuk bilangan bulat, Anda sebenarnya dapat menghasilkan rumus yang mencakup logika array, pembaruan array, sumbu array, iterasi array.  Dan selama Anda memperbaiki jalur Anda, rumus ini sangat mudah untuk dihasilkan. <br>  Jika Anda tidak memperbaiki jalur Anda, tetapi ingin membuat formula yang sesuai dengan bagian dari program di sepanjang semua jalur, maka ini juga relatif mudah.  Satu-satunya hal yang harus Anda hadapi adalah jenis loop khusus. <br><br>  Kamus dan peta juga sangat mudah dimodelkan menggunakan fungsi yang tidak ditentukan.  Sebenarnya, teori array itu sendiri hanyalah kasus khusus dari fungsi yang tidak terbatas.  Dengan bantuan fungsi seperti itu, hal-hal yang lebih rumit dapat dilakukan.  Dalam pemecah SMT modern, ada dukungan bawaan untuk alasan tentang set dan set operasi, yang bisa sangat berguna jika Anda berbicara tentang sebuah program yang mencakup set perhitungan. <br><br>  Saat merancang salah satu alat ini, fase pemodelan sangat penting.  Dan intinya bukan hanya bagaimana Anda memodelkan fungsi program yang kompleks ke teori Anda, misalnya, hal-hal seperti mengurangi tumpukan ke array.  Intinya adalah teori dan pemecah mana yang Anda gunakan.  Ada sejumlah besar teori dan pemecah masalah dengan hubungan yang berbeda, untuk itu perlu untuk memilih kompromi yang masuk akal antara efisiensi dan biaya. <br><br><img src="https://habrastorage.org/webt/wf/o9/2m/wfo92mcuifuz0rgcowvad6wrcxs.jpeg"><br><br>  Sebagian besar alat praktis mematuhi teori vektor bit dan, jika perlu, dapat menggunakan teori array untuk memodelkan tumpukan.  Secara umum, alat praktis mencoba menghindari teori yang lebih kompleks, seperti teori himpunan.  Ini karena mereka biasanya kurang terukur dalam beberapa kasus, jika Anda tidak berurusan dengan program yang benar-benar membutuhkan alat semacam ini untuk bekerja. <br><br>  <b>Audiens:</b> selain studi tentang kinerja simbolik, apa yang menjadi fokus pengembang? <br><br> <b>:</b>       â€”      ,      . , , ,             ,       .    ,     . <br><br>  ,       ,         .    ,       ,      ,   ,  ,    ,    ,            . <br><br> ,   â€”   ,     ,      . ,   ,           â€”     ,   JavaScript  Python,         .             ,     . <br><br><img src="https://habrastorage.org/webt/k_/hw/9f/k_hw9fclb1unjv4v4jojv1a-4bk.jpeg"><br><br>       ,             Python.  ,         ,        : Â«,    ,    ,     Â».   . <br><br> ,         ,   ,       ,    ,     . <br>   ,  ,   ,      -  ,           ,             . <br><br>      ,     ,     ,      .  , ,         Microsoft Word,     , ,   . <br><br>       , ,     ,         ,      . <br><br>    ,          .    ,        ,   - ,   - .    ,    ,      .     ,       . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Versi lengkap dari kursus ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps hingga Desember secara gratis</b> ketika membayar untuk jangka waktu enam bulan, Anda dapat memesan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425559/">https://habr.com/ru/post/id425559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425549/index.html">Saham Supermicro jatuh di tengah penyelidikan penyebaran chip mata-mata Cina</a></li>
<li><a href="../id425551/index.html">Siapa yang harus menerima uang dari penjualan karya seni yang dibuat oleh AI?</a></li>
<li><a href="../id425553/index.html">Apa yang Dapat Diceritakan oleh Pangeran Monte Cristo Tentang Keamanan Siber</a></li>
<li><a href="../id425555/index.html">Charles Nutter pada bahasa dinamis di JVM di jug.msk.ru</a></li>
<li><a href="../id425557/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1</a></li>
<li><a href="../id425561/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 2</a></li>
<li><a href="../id425563/index.html">California melarang penjualan perangkat IoT dengan atau tanpa kata sandi sederhana</a></li>
<li><a href="../id425565/index.html">Matematika fixed-point cepat untuk aplikasi keuangan di Jawa</a></li>
<li><a href="../id425569/index.html">Pengujian Fungsional PCB</a></li>
<li><a href="../id425571/index.html">Mengamankan server web di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>