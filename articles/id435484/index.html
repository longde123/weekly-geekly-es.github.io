<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚝 📙 🚽 Gaya fuzzing 1989 ⛪️ 🥅 🌷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan awal tahun 2019, adalah baik untuk mengingat masa lalu dan memikirkan masa depan. Mari kita melihat ke belakang selama 30 tahun dan merenungkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gaya fuzzing 1989</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435484/">  Dengan awal tahun 2019, adalah baik untuk mengingat masa lalu dan memikirkan masa depan.  Mari kita melihat ke belakang selama 30 tahun dan merenungkan artikel ilmiah pertama tentang fuzzing: <a href="">“Sebuah Studi Empiris tentang Keandalan Utilitas UNIX”</a> dan karya 1995 berikutnya <a href="">“Revisi Fuzzing” oleh</a> penulis yang sama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Barton Miller</a> . <br><br>  Pada artikel ini, kami akan mencoba menemukan bug dalam versi modern Ubuntu Linux menggunakan <b>alat yang sama</b> seperti pada karya fuzzing asli.  Anda harus membaca dokumen asli tidak hanya untuk konteks, tetapi juga untuk pemahaman.  Mereka ternyata sangat kenabian sehubungan dengan kerentanan dan eksploitasi selama beberapa dekade mendatang.  Pembaca yang penuh perhatian dapat melihat tanggal publikasi artikel asli: 1990.  Yang lebih penuh perhatian akan memperhatikan hak cipta di komentar sumber: 1989. <br><a name="habracut"></a><br><h1>  Ulasan singkat </h1><br>  Bagi mereka yang belum membaca dokumen (walaupun ini harus benar-benar dilakukan), bagian ini berisi ringkasan singkat dan beberapa kutipan yang dipilih. <br><br>  <a href="">Program fuzzing</a> menghasilkan aliran karakter acak, dengan kemampuan untuk hanya menghasilkan karakter yang dapat dicetak atau tidak dicetak.  Ia menggunakan nilai awal tertentu (benih), memastikan hasil yang dapat direproduksi, yang seringkali tidak dimiliki oleh fuzzer modern.  Seperangkat skrip dijalankan pada program yang diuji dan memeriksa keberadaan dump dasar.  Hang terdeteksi secara manual.  Adaptor memberikan input acak untuk program interaktif (artikel 1990), layanan jaringan (1995), dan aplikasi X grafis (1995). <br><br>  Artikel 1990 menguji empat arsitektur prosesor (i386, CVAX, Sparc, 68020) dan lima sistem operasi (4.3 BSD, SunOS, AIX, Xenix, Dynix).  Dalam artikel 1995, pilihan platform yang serupa.  Dalam artikel pertama, 25-33% dari utilitas gagal, tergantung pada platform.  Dalam artikel berikutnya, angka-angka ini berkisar dari 9% hingga 33%, dengan GNU (di SunOS) dan Linux memiliki tingkat kegagalan terendah. <br><br>  Artikel 1990 menyimpulkan bahwa 1) programmer tidak memeriksa batas-batas array atau kode kesalahan, 2) makro membuatnya sulit untuk membaca dan men-debug kode, dan 3) bahasa C sangat tidak aman.  Sangat tidak aman <code>gets</code> fungsi dan sistem tipe C. Terutama disebutkan Selama pengujian, penulis menemukan kerentanan Format String bertahun-tahun sebelum eksploitasi massal mereka.  Artikel diakhiri dengan survei terhadap pengguna tentang seberapa sering mereka memperbaiki bug atau melaporkannya.  Ternyata melaporkan bug itu sulit dan ada sedikit minat untuk memperbaikinya. <br><br>  Artikel 1995 menyebutkan perangkat lunak sumber terbuka dan membahas mengapa ia memiliki lebih sedikit kesalahan.  Kutipan: <br><br><blockquote>  Ketika kami menyelidiki penyebab kegagalan, muncul fenomena yang mengganggu: banyak bug (sekitar 40%) yang dilaporkan pada tahun 1990 masih ada dalam bentuk persisnya pada tahun 1995.  ... <br><br>  Metode yang digunakan di sini sederhana dan sebagian besar otomatis.  Sulit untuk memahami mengapa pengembang tidak menggunakan sumber yang mudah dan gratis ini untuk meningkatkan keandalan. </blockquote><br>  Hanya dalam 15-20 tahun teknik fuzzing akan menjadi praktik standar untuk vendor besar. <br><br>  Bagi saya juga sepertinya pernyataan 1990 ini meramalkan peristiwa masa depan: <br><br><blockquote>  Seringkali, gaya singkat pemrograman C dibawa ke ekstrim, bentuk menang atas fungsi yang benar.  Kemungkinan overflow dalam buffer input adalah lubang keamanan potensial, seperti yang ditunjukkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">worm Internet baru</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baru ini</a> . </blockquote><br><h1>  Metodologi uji </h1><br>  Untungnya, 30 tahun kemudian, Dr. Barton masih menyediakan <a href="">kode sumber, skrip, dan data lengkap untuk mereproduksi temuannya</a> : contoh terpuji yang harus diikuti oleh peneliti lain.  Script berfungsi tanpa masalah, dan alat fuzzing hanya membutuhkan perubahan kecil untuk dikompilasi dan dijalankan. <br><br>  Untuk pengujian ini, kami menggunakan <a href="">skrip dan input dari repositori dasar fuzz-1995</a> , karena ada daftar <a href="">aplikasi teruji yang</a> terbaru.  Menurut <a href="">README</a> , di sini adalah input acak yang sama seperti dalam penelitian asli.  Hasil di bawah ini untuk Linux modern diperoleh <b>persis pada kode fuzzing yang sama dan input data</b> seperti pada artikel aslinya.  Hanya daftar utilitas untuk pengujian yang berubah. <br><br><h1>  Utilitas berubah lebih dari 30 tahun </h1><br>  Jelas, ada beberapa perubahan dalam paket perangkat lunak Linux selama 30 tahun terakhir, meskipun beberapa utilitas terbukti telah melanjutkan silsilah mereka selama beberapa dekade.  Jika memungkinkan, kami mengambil versi modern dari program yang sama dari artikel 1995.  Beberapa program tidak lagi tersedia, kami menggantinya.  Pembenaran untuk semua penggantian: <br><br><ul><li>  <code>cfe</code> ⇨ <code>cc1</code> : Setara dengan preproses C dari artikel 1995. </li><li>  <code>dbx</code> ⇨ <code>gdb</code> : Setara dengan debugger 1995. </li><li>  <code>ditroff</code> ⇨ <code>groff</code> : <code>ditroff</code> tidak lagi tersedia. </li><li>  <code>dtbl</code> ⇨ <code>gtbl</code> : Setara dengan GNU Troff dari utilitas <code>dtbl</code> lama. </li><li>  <code>clisp</code> ⇨ <code>clisp</code> : Implementasi standar <code>clisp</code> . </li><li>  <code>more</code> ⇨ <code>more</code> <code>less</code> : Lebih sedikit lebih banyak! </li><li>  <code>prolog</code> ⇨ <code>swipl</code> : Ada dua opsi untuk prolog: SWI Prolog dan GNU Prolog.  Prolog SWI lebih disukai karena merupakan implementasi yang lebih tua dan lebih lengkap. </li><li>  <code>awk</code> ⇨ <code>gawk</code> : <code>awk</code> versi GNU. </li><li>  <code>cc</code> ⇨ <code>gcc</code> : Kompiler C standar. </li><li>  <code>compress</code> ⇨ <code>gzip</code> : GZip adalah turunan konseptual dari utilitas Unix <code>compress</code> lama. </li><li>  <code>lint</code> ⇨ <code>splint</code> : Lint ditulis ulang di bawah GPL. </li><li>  <code>/bin/mail</code> ⇨ <code>/usr/bin/mail</code> : Utilitas yang Setara dengan cara yang berbeda. </li><li>  <code>f77</code> ⇨ <code>fort77</code> : Ada dua variasi kompiler Fortan77: GNU Fortran dan Fort77.  Yang pertama direkomendasikan untuk Fortran 90, dan yang kedua untuk dukungan Fortran77.  Program <code>f2c</code> didukung secara aktif, daftar perubahannya telah dipertahankan sejak 1989. </li></ul><br><h1>  Hasil </h1><br>  Teknik fuzzing 1989 masih menemukan kesalahan pada 2018.  Tetapi ada beberapa kemajuan. <br><br>  Untuk mengukur kemajuan, Anda perlu dasar.  Untungnya, kerangka kerja semacam itu ada untuk utilitas Linux.  Meskipun Linux tidak ada pada saat artikel asli pada tahun 1990, tes kedua pada tahun 1995 meluncurkan kode fuzzing yang sama pada utilitas dari distribusi Slackware 2.1.0 1995.  Hasil yang sesuai diberikan dalam <a href="">tabel 3 artikel 1995 (hal. 7-9)</a> .  Dibandingkan dengan pesaing komersial, GNU / Linux terlihat sangat bagus: <br><br><blockquote>  Persentase kerusakan utilitas dalam UNIX versi Linux gratis adalah yang tertinggi kedua: 9%. </blockquote><br>  Jadi, mari kita bandingkan utilitas Linux 1995 dan 2018 dengan alat fuzzing 1989: <br><br><table><tbody><tr><th></th><th>  Ubuntu 18.10 (2018) </th><th>  Ubuntu 18.04 (2018) </th><th>  Ubuntu 16.04 (2016) </th><th>  Ubuntu 14.04 (2014) </th><th>  Slackware 2.1.0 (1995) </th></tr><tr><td>  Kecelakaan </td><td>  1 (f77) </td><td>  1 (f77) </td><td>  2 (f77, ul) </td><td>  2 (swipl, f77) </td><td>  4 (ul, flex, indent, gdb) </td></tr><tr><td>  Membeku </td><td>  1 (mantra) </td><td>  1 (mantra) </td><td>  1 (mantra) </td><td>  2 (mantra, unit) </td><td>  1 (tagag) </td></tr><tr><td>  Total Diuji </td><td>  81 </td><td>  81 </td><td>  81 </td><td>  81 </td><td>  55 </td></tr><tr><td>  Kegagalan / pembekuan,% </td><td>  2% </td><td>  2% </td><td>  4% </td><td>  5% </td><td>  9% </td></tr></tbody></table><br>  Yang mengejutkan, jumlah Linux lumpuh dan macet masih lebih besar dari nol, bahkan pada Ubuntu versi terbaru.  Jadi, <code>f77</code> memanggil program <code>f2c</code> dengan kesalahan segmentasi, dan program <code>spell</code> tergantung pada dua versi dari input tes. <br><br><h1>  Bug apa? </h1><br>  Saya dapat secara manual mengetahui akar penyebab beberapa bug.  Beberapa hasil, seperti kesalahan glibc, tidak terduga, sementara yang lain, seperti sprintf dengan buffer ukuran tetap, dapat diprediksi. <br><br><h3>  Kegagalan ul </h3><br>  Bug di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ul</a> sebenarnya adalah bug di glibc.  Secara khusus, itu dilaporkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (orang lain menemukannya di <code>ul</code> ) pada tahun 2016.  Menurut pelacak bug, kesalahan masih belum diperbaiki.  Karena bug tidak dapat direproduksi di Ubuntu 18.04 dan yang lebih baru, ia diperbaiki pada tingkat distribusi.  Dilihat oleh komentar pada pelacak bug, masalah utama bisa sangat serius. <br><br><h3>  Kecelakaan f77 </h3><br>  Program <code>f77</code> datang dalam paket fort77, yang itu sendiri adalah skrip shell di sekitar <code>f2c</code> , sumber penerjemah dari Fortran77 ke C. Debugging <code>f2c</code> menunjukkan bahwa kegagalan terjadi ketika fungsi <code>errstr</code> mencetak pesan kesalahan yang terlalu panjang.  <a href="">Kode sumber f2c</a> menunjukkan bahwa fungsi sprintf digunakan untuk menulis string panjang variabel ke buffer ukuran tetap: <br><br><pre> <code class="plaintext hljs">errstr(const char *s, const char *t) #endif { char buff[100]; sprintf(buff, s, t); err(buff); }</code> </pre> <br>  Tampaknya kode ini telah dipertahankan sejak pembuatan <code>f2c</code> .  Program ini memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejarah perubahan</a> setidaknya sejak tahun 1989.  Pada tahun 1995, ketika melakukan fuzzing kembali, kompiler Fortran77 tidak diuji, jika tidak masalahnya akan ditemukan sebelumnya. <br><br><h3>  Bekukan mantra </h3><br>  Sebuah contoh bagus dari kebuntuan klasik.  <code>spell</code> delegasi <code>ispell</code> melalui pipa.  <code>spell</code> membaca baris teks demi baris dan menghasilkan catatan pemblokiran ukuran baris dalam <code>ispell</code> .  Namun, <code>ispell</code> membaca maksimum <code>BUFSIZ/2</code> byte pada suatu waktu (4096 byte pada sistem saya) dan mengeluarkan catatan pemblokiran untuk memastikan bahwa klien telah menerima data validasi yang telah diproses sejauh ini.  Dua input tes yang berbeda memaksa <code>spell</code> untuk menulis string lebih dari 4096 karakter untuk <code>ispell</code> , yang mengakibatkan kebuntuan: <code>spell</code> menunggu <code>ispell</code> membaca seluruh string, sementara <code>ispell</code> menunggu <code>spell</code> mengonfirmasi bahwa ia telah membaca koreksi ejaan asli. <br><br><h3>  Gantung unit </h3><br>  Sekilas, sepertinya ada kondisi loop tak terbatas.  <code>libreadline</code> tampaknya berada di <code>libreadline</code> dan bukan di <code>units</code> , meskipun versi <code>units</code> lebih baru tidak mengalami kesalahan ini.  Log perubahan menunjukkan bahwa pemfilteran input telah ditambahkan yang secara tidak sengaja dapat memperbaiki masalah ini.  Namun, penyelidikan menyeluruh atas alasan-alasannya berada di luar cakupan blog ini.  Mungkin cara untuk menggantung <code>libreadline</code> masih ada. <br><br><h3>  Swipl crash </h3><br>  Demi kelengkapan, saya ingin menyebutkan crash <code>swipl</code> , meskipun saya tidak mempelajarinya dengan saksama, karena bug telah lama diperbaiki dan tampaknya memiliki kualitas yang cukup tinggi.  Kegagalan sebenarnya adalah pernyataan (mis. Yang seharusnya tidak pernah terjadi) yang dipanggil saat mengonversi karakter: <br><br> <code>[Thread 1] pl-fli.c:2495: codeToAtom: Assertion failed: chrcode &gt;= 0 <br> C-stack trace labeled "crash": <br> [0] __assert_fail+0x41 <br> [1] PL_put_term+0x18e <br> [2] PL_unify_text+0x1c4 <br> …</code> <br> <br>  Kecelakaan selalu buruk, tetapi setidaknya di sini program dapat melaporkan kesalahan, macet lebih awal dan keras. <br><br><h1>  Kesimpulan </h1><br>  Selama 30 tahun terakhir, fuzzing tetap menjadi cara yang sederhana dan dapat diandalkan untuk menemukan bug.  Meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelitian aktif sedang</a> berlangsung di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daerah ini</a> , bahkan fuzzer 30 tahun yang lalu berhasil menemukan kesalahan dalam utilitas Linux modern. <br><br>  Penulis artikel asli meramalkan masalah keamanan yang akan menyebabkan C selama beberapa dekade mendatang.  Dia berpendapat dengan meyakinkan bahwa kode yang tidak aman terlalu mudah untuk ditulis dalam C dan harus dihindari jika memungkinkan.  Secara khusus, artikel menunjukkan bahwa bug muncul bahkan dengan pentahapan paling sederhana, dan pengujian tersebut harus dimasukkan dalam praktik pengembangan perangkat lunak standar.  Sayangnya, saran ini belum diikuti selama beberapa dekade. <br><br>  Semoga Anda menikmati retrospektif 30 tahun ini.  Tunggu artikel Fuzzing berikutnya di tahun 2000, di mana kami akan memeriksa seberapa kuat aplikasi Windows 10 dibandingkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan Windows NT / 2000 yang setara ketika diuji dengan fuzzer</a> .  Saya pikir jawabannya sudah bisa ditebak. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435484/">https://habr.com/ru/post/id435484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435468/index.html">Bereaksi Tutorial Bagian 7: Gaya Inline</a></li>
<li><a href="../id435470/index.html">Bereaksi Tutorial, Bagian 8: Melanjutkan Pekerjaan pada Aplikasi TODO, Memperkenalkan Properti Komponen</a></li>
<li><a href="../id435476/index.html">Mkcert: sertifikat HTTPS yang valid untuk localhost</a></li>
<li><a href="../id435480/index.html">Microsoft dan Kroger akan memberikan perlawanan kepada Amazon di bidang ... perdagangan makanan</a></li>
<li><a href="../id435482/index.html">Sorot zirkon: vDSO (Objek Bersama Dinamis virtual)</a></li>
<li><a href="../id435488/index.html">Mengolok-olok, bertopik dan mata-mata di Kerangka Kerja Spock</a></li>
<li><a href="../id435490/index.html">Perubahan pajak Google pada 2019</a></li>
<li><a href="../id435494/index.html">Server klien yang mulus</a></li>
<li><a href="../id435496/index.html">Tesla menggugat karena kecelakaan di mana pengemudi dan penumpang Model S meninggal</a></li>
<li><a href="../id435498/index.html">Perpanjangan Direktur vCloud: Migrasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>