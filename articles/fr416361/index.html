<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë‚Äçü§ù‚Äçüßë ü•• ü§õüèª Comment organiser l'√©tat g√©n√©ral des applications React sans utiliser de biblioth√®ques (et pourquoi Mobx est n√©cessaire) üßó üçë üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imm√©diatement un petit spoiler - l'organisation d'un √©tat dans mobx n'est pas diff√©rente de l'organisation d'un √©tat g√©n√©ral sans utiliser mobx dans u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment organiser l'√©tat g√©n√©ral des applications React sans utiliser de biblioth√®ques (et pourquoi Mobx est n√©cessaire)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416361/"><p>  Imm√©diatement un petit spoiler - l'organisation d'un √©tat dans mobx n'est pas diff√©rente de l'organisation d'un √©tat g√©n√©ral sans utiliser mobx dans une pure r√©action.  La r√©ponse √† la question naturelle est pourquoi alors avez-vous besoin de ce mobx √† la fin de l'article, mais pour l'instant, l'article sera consacr√© √† l'organisation de l'√©tat dans une application propre et sans biblioth√®ques externes. </p><br><p><img src="https://habrastorage.org/webt/4x/dh/gw/4xdhgwhcoygforqwxaue1xutwwe.png"><br></p><br>  La r√©action fournit un moyen de stocker et de mettre √† jour l'√©tat des composants √† l'aide de la propri√©t√© state sur une instance d'un composant de classe et de la m√©thode setState.  N√©anmoins, parmi la communaut√© de r√©action, un tas de biblioth√®ques et d'approches suppl√©mentaires pour travailler avec l'√©tat sont utilis√©es (flux, redux, redux-ations, effecteur, mobx, c√©r√©bral, un tas d'entre eux).  Mais est-il possible de construire une application suffisamment grande avec un tas de logique m√©tier avec un grand nombre d'entit√©s et des relations de donn√©es complexes entre les composants en utilisant uniquement setState?  Existe-t-il un besoin de biblioth√®ques suppl√©mentaires pour travailler avec l'√©tat?  Voyons cela. <a name="habracut"></a><br><p>  Nous avons donc setState et qui met √† jour l'√©tat et appelle le rendu du composant.  Mais que se passe-t-il si les m√™mes donn√©es sont requises par de nombreux composants qui ne sont pas interconnect√©s?  Dans le dock officiel de la r√©action, il y a une section "lever l'√©tat" avec une description d√©taill√©e - nous √©levons simplement l'√©tat √† l'anc√™tre commun √† ces composants, en passant des donn√©es et des fonctions pour le changer via des accessoires (et via des composants interm√©diaires, si n√©cessaire).  Pour les petits exemples, cela semble raisonnable, mais la r√©alit√© est que dans les applications complexes, il peut y avoir beaucoup de d√©pendances entre les composants et la tendance √† transf√©rer des √©tats vers un composant commun de l'anc√™tre conduit au fait que l'√©tat entier sera pouss√© de plus en plus haut et se retrouvera dans le composant racine de l'application avec la logique de mise √† jour de cet √©tat pour tous les composants.  Par cons√©quent, setState ne se produira que pour mettre √† jour le composant de donn√©es local ou dans le composant racine de l'application, dans lequel toute la logique sera concentr√©e. </p><br><p>  Mais est-il possible de stocker le processus et l'√©tat de rendu dans une application React sans utiliser setState ou des biblioth√®ques suppl√©mentaires et fournir un acc√®s g√©n√©ral √† ces donn√©es √† partir de n'importe quel composant? </p><br><p>  Les objets javascript les plus courants et certaines r√®gles pour les organiser viennent √† notre aide. </p><br><p>  Mais vous devez d'abord apprendre √† d√©composer les applications en types d'entit√© et leurs relations. </p><br><p>  Pour commencer, nous introduisons un objet qui stockera des donn√©es globales qui s'appliquent √† l'ensemble de l'application dans son ensemble - (cela peut √™tre les param√®tres pour les styles, la localisation, la taille des fen√™tres, etc.) dans un seul objet AppState et nous pla√ßons simplement cet objet dans un fichier s√©par√©. </p><br><pre><code class="hljs julia">// src/stores/AppState.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, .... }</code> </pre> <br><p>  Maintenant, dans n'importe quel composant, vous pouvez importer et utiliser les donn√©es de notre magasin. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../stores/AppState.js"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SomeComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {AppState.locale === "..." ? ... : ...} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre><br><p>  Nous allons plus loin - presque chaque application a l'essence de l'utilisateur actuel (peu importe comment elle est cr√©√©e ou provient du serveur, etc.), donc l'objet singleton de notre utilisateur sera √©galement dans l'√©tat de l'application.  Il peut √©galement √™tre d√©plac√© vers un fichier distinct et √©galement import√©, ou il peut √™tre stock√© imm√©diatement dans l'objet AppState.  Et maintenant, l'essentiel - vous devez d√©terminer le diagramme des entit√©s qui composent l'application.  En termes de base de donn√©es, il s'agira de tables avec des relations un-√†-plusieurs ou plusieurs-√†-plusieurs, et toute cette cha√Æne de relations part de l'essence principale de l'utilisateur.  Eh bien, dans notre cas, l'objet de l'utilisateur stockera simplement un tableau d'autres objets-entit√©s-magasins, o√π chaque objet-magasin, √† son tour, stockera des tableaux d'autres entit√©s-magasins. </p><br><p>  Voici un exemple - il y a une logique m√©tier qui s'exprime comme "l'utilisateur peut cr√©er / √©diter / supprimer des dossiers, des projets dans chaque dossier, dans chaque projet de t√¢che et dans chaque t√¢che de sous-t√¢che" (il s'av√®re quelque chose comme un gestionnaire de t√¢ches) et va regarder dans le diagramme d'√©tat quelque chose comme √ßa: </p><br><pre> <code class="hljs powershell">export const AppStore = { locale: <span class="hljs-string"><span class="hljs-string">"en"</span></span>, theme: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, currentUser: { name: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, email: <span class="hljs-string"><span class="hljs-string">""</span></span> folders: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"folder1"</span></span>, <span class="hljs-type"><span class="hljs-type">projects</span></span>: [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"project1"</span></span>, <span class="hljs-type"><span class="hljs-type">tasks</span></span>: [ { <span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"task1"</span></span>, <span class="hljs-type"><span class="hljs-type">subtasks</span></span>: [ {<span class="hljs-type"><span class="hljs-type">text</span></span>: <span class="hljs-string"><span class="hljs-string">"subtask1"</span></span>}, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] }, <span class="hljs-type"><span class="hljs-type">.....</span></span> ] } }</code> </pre> <br><p>  Maintenant, le composant racine de l'application peut simplement importer cet objet et afficher des informations sur l'utilisateur, puis il peut transf√©rer l'objet utilisateur vers le composant de tableau de bord </p><br><pre> <code class="hljs xml"> .... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Dashboard</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{appState.user}/</span></span></span><span class="hljs-tag">&gt;</span></span> ....</code> </pre> <br><p>  et il peut rendre la liste des dossiers </p><br><pre> <code class="hljs javascript"> ... &lt;div&gt;{user.folders.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">folder</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Folder</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">folder</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{folder}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ...</code> </pre> <br><p>  et chaque composant du dossier affichera une liste de projets </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{folder.projects.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">project</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">project</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{project}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  et chaque composant du projet peut r√©pertorier les t√¢ches </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  et enfin, chaque composant de t√¢che peut afficher une liste de sous-t√¢ches en passant l'objet souhait√© au composant de sous-t√¢che </p><br><pre> <code class="hljs javascript"> .... &lt;div&gt;{task.subtask.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subtask</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Subtask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">subtask</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{subtask}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ....</code> </pre> <br><p>  Naturellement, sur une seule page, personne n'affichera toutes les t√¢ches de tous les projets de tous les dossiers, ils seront divis√©s par des panneaux lat√©raux (par exemple, une liste de dossiers), par pages, etc. mais la structure g√©n√©rale est √† peu pr√®s la m√™me - le composant parent rend le composant int√©gr√© passant un objet avec des accessoires les donn√©es.  Un point important doit √™tre not√© - tout objet (par exemple, un objet d'un dossier, d'un projet, d'une t√¢che) n'est pas stock√© dans l'√©tat d'un composant - le composant le re√ßoit simplement via des accessoires dans le cadre d'un objet plus g√©n√©ral.  Et par exemple, lorsque le composant de projet transmet l'objet de t√¢che ( <code>&lt;div&gt;{project.tasks.map(task=&gt;&lt;Task task={task}/&gt;)}&lt;/div&gt;</code> ) au composant enfant de Task, car les objets sont stock√©s dans un seul objet vous pouvez toujours modifier cet objet de t√¢che de l'ext√©rieur - par exemple, AppState.currentUser.folders [2] .projects [3] .tasks [4] .text = "√©dit√© la t√¢che", puis provoquer la mise √† jour du composant racine (ReactDOM.render (&lt;App /&gt; ) et nous obtenons ainsi l'√©tat actuel de l'application. </p><br><p>  Supposons en outre que nous voulons cr√©er une nouvelle sous-t√¢che en cliquant sur le bouton "+" dans le composant T√¢che.  Tout est simple </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.task.subtasks.push({text: <span class="hljs-string"><span class="hljs-string">""</span></span>}); updateDOM() }</code> </pre> <br><p>  puisque le composant Task re√ßoit en tant qu'accessoires l'objet de t√¢che et cet objet n'est pas stock√© dans son √©tat mais fait partie du magasin AppState global (c'est-√†-dire que l'objet de t√¢che est stock√© √† l'int√©rieur du tableau des t√¢ches de l'objet de projet plus g√©n√©ral, et qui √† son tour fait partie de l'objet utilisateur et l'utilisateur est d√©j√† stock√© √† l'int√©rieur de l'AppState ) et gr√¢ce √† cette connectivit√©, apr√®s avoir ajout√© un nouvel objet de t√¢che au tableau de sous-t√¢ches, vous pouvez appeler la mise √† jour du composant racine et ainsi mettre √† jour et mettre √† jour la maison pour toutes les modifications de donn√©es (peu importe o√π elles se sont produites) simplement en appelant la fonction upd  ateDOM, qui √† son tour met simplement √† jour le composant racine. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ReactDom.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }</code> </pre> <br><p>  Et peu importe les donn√©es de quelles parties d'AppState et de quels endroits nous changeons (par exemple, vous pouvez transf√©rer un objet de dossier via des accessoires via des composants interm√©diaires de projet et de t√¢che vers le composant de sous-t√¢che, et il peut simplement mettre √† jour le nom du dossier (this.props.folder.name = "nouveau nom) ") - en raison du fait que les composants re√ßoivent des donn√©es via des accessoires, la mise √† jour du composant racine mettra √† jour tous les composants imbriqu√©s et mettra √† jour l'application enti√®re. </p><br><p>  Essayons maintenant d'ajouter un peu de commodit√© au travail avec le c√¥t√©.  Dans l'exemple ci-dessus, vous pouvez remarquer que la cr√©ation d'un nouvel objet entit√© √† chaque fois (par exemple <code>project.tasks.push({text: "", subtasks: [], ...})</code> si l'objet poss√®de de nombreuses propri√©t√©s avec des param√®tres par d√©faut, puis √† chaque fois de les lister et vous pouvez faire une erreur et oublier quelque chose, etc. La premi√®re chose qui vient √† l'esprit est de mettre la cr√©ation d'un objet dans une fonction o√π les champs par d√©faut seront assign√©s et en m√™me temps les red√©finir avec de nouvelles donn√©es </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { text: <span class="hljs-string"><span class="hljs-string">""</span></span>, subtasks: [], ... //many default fields ...data } }</code> </pre> <br><p>  mais si vous regardez de l'autre c√¥t√©, cette fonction est le constructeur d'une certaine entit√© et les classes javascript sont parfaites pour ce r√¥le </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ text: <span class="hljs-string"><span class="hljs-string">""</span></span>; subtasks: []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) } }</code> </pre> <br><p>  puis la cr√©ation de l'objet cr√©era simplement une instance de la classe avec la possibilit√© de remplacer certains champs par d√©faut </p><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAddTask</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task({...}) }</code> </pre><br><p>  De plus, vous pouvez remarquer que de la m√™me mani√®re, en cr√©ant des classes pour les objets du projet, les utilisateurs, les sous-t√¢ches, nous obtenons la duplication de code √† l'int√©rieur du constructeur </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ Object.assign(this,data) }</span></span></span></span></code> </pre> <br><p>  mais nous pouvons profiter de l'h√©ritage et extraire ce code dans le constructeur de la classe de base. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } }</code> </pre> <br><p>  De plus, vous remarquerez que chaque fois que nous mettons √† jour un √©tat, nous modifions manuellement les champs de l'objet </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "..."; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.lastName = "..."; updateDOM();</code> </pre> <br><p>  et il devient difficile de suivre, de n√©gocier et de comprendre ce qui se passe dans le composant et il est donc n√©cessaire de d√©terminer un canal commun par lequel les mises √† jour de toutes les donn√©es passeront, puis nous pourrons ajouter la journalisation et toutes sortes d'autres commodit√©s.  Pour ce faire, la solution consiste √† cr√©er une m√©thode de mise √† jour dans la classe qui prendra un objet temporaire avec de nouvelles donn√©es et se mettra √† jour et √©tablira la r√®gle selon laquelle les objets peuvent √™tre mis √† jour uniquement via la m√©thode de mise √† jour et non par affectation directe </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ update(newData){ console.log(<span class="hljs-string"><span class="hljs-string">"before update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Object.assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); console.log(<span class="hljs-string"><span class="hljs-string">"after update"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//// user.update({firstName: "...", lastName: "..."})</span></span></code> </pre> <br><p>  Eh bien, afin de ne pas dupliquer le code dans chaque classe, nous d√©pla√ßons √©galement cette m√©thode de mise √† jour vers la classe de base. </p><br><p>  Vous pouvez maintenant voir que lorsque nous mettons √† jour certaines donn√©es, nous devons appeler manuellement la m√©thode updateDOM ().  Mais pour des raisons de commodit√©, il est possible d'effectuer cette mise √† jour automatiquement chaque fois qu'un appel √† la m√©thode update ({...}) de la classe de base se produit. <br>  Il s'av√®re que la classe de base ressemblera √† ceci </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } update(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>){ Object.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ReactDOM.render(&lt;App/&gt;, rootElement) } }</code> </pre><br><p>  Eh bien, de sorte que lors de l'appel successif de la m√©thode update () il n'y ait pas de mises √† jour inutiles, vous pouvez retarder la mise √† jour du composant au prochain cycle d'√©v√©nements </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); } update(data){ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TimerId === <span class="hljs-number"><span class="hljs-number">0</span></span>) { TimerId = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ TimerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, rootElement); }) } } }</code> </pre> <br><p>  De plus, vous pouvez progressivement augmenter les fonctionnalit√©s de la classe de base - par exemple, afin de ne pas avoir √† envoyer manuellement une demande au serveur √† chaque fois, en plus de mettre √† jour l'√©tat, vous pouvez envoyer une demande √† la m√©thode de mise √† jour ({..}) en arri√®re-plan.  Vous pouvez organiser un canal de mise √† jour en direct pour les sockets Web en ajoutant un compte de chaque objet cr√©√© dans la carte de hachage globale sans modifier les composants et utiliser les donn√©es de quelque mani√®re que ce soit. </p><br><p>  Il reste encore beaucoup √† faire, mais je veux mentionner un sujet int√©ressant - tr√®s souvent, passer un objet avec des donn√©es au composant n√©cessaire (par exemple, lorsqu'un composant de projet rend un composant de t√¢che - </p><br><pre> <code class="hljs javascript">&lt;div&gt;{project.tasks.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task</span></span></span><span class="hljs-function">=&gt;</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">task</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{task}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  le composant m√™me de la t√¢che peut n√©cessiter des informations qui ne sont pas stock√©es directement √† l'int√©rieur de la t√¢che mais qui se trouvent dans l'objet parent. </p><br><p>  Supposons que vous souhaitiez colorer toutes les t√¢ches dans une couleur stock√©e dans le projet et commune √† toutes les t√¢ches.  Pour ce faire, en plus des accessoires de t√¢che, le composant projet doit √©galement transmettre ses accessoires de projet <code>&lt;Task task={task} project={this.props.project}/&gt;</code> .  Et si vous devez soudainement colorer la t√¢che dans une couleur commune √† toutes les t√¢ches d'un dossier, vous devrez transf√©rer l'objet de dossier actuel du composant Dossier vers le composant T√¢che en le transmettant via le composant Projet interm√©diaire. <br>  Une d√©pendance fragile appara√Æt que le composant doit savoir ce dont ses composants imbriqu√©s ont besoin.  De plus, la possibilit√© d'un contexte de r√©action, m√™me si elle simplifiera le transfert √† travers des composants interm√©diaires, n√©cessitera toujours une description du fournisseur et la connaissance des donn√©es n√©cessaires pour les composants enfants. </p><br><p>  Mais le principal probl√®me est que chaque fois que vous modifiez une conception ou modifiez la liste de souhaits d'un client lorsqu'un composant a besoin de nouvelles informations, vous devrez modifier les composants sup√©rieurs soit en transmettant des accessoires soit en cr√©ant des fournisseurs de contexte.  J'aimerais que le composant re√ßoive par le biais d'accessoires un objet contenant des donn√©es pour acc√©der d'une mani√®re ou d'une autre √† l'√©tat de notre application.  Et ici, javascript est un bon ajustement (contrairement √† tous les langages fonctionnels comme l'orme ou les approches immuables comme redux) - afin que les objets puissent stocker des liens circulaires entre eux.  Dans ce cas, l'objet de t√¢che doit avoir un champ task.project avec un lien vers l'objet du projet parent dans lequel il est stock√© et l'objet de projet √† son tour doit avoir un lien vers l'objet dossier, etc., vers l'objet AppState racine.  Ainsi, le composant, quelle que soit sa profondeur, peut toujours passer par les objets parents via le lien et obtenir toutes les informations n√©cessaires et n'a pas besoin de le jeter √† travers un tas de composants interm√©diaires.  Par cons√©quent, nous introduisons une r√®gle - chaque fois que vous cr√©ez un objet, vous devez ajouter un lien vers l'objet parent.  Par exemple, maintenant la cr√©ation d'une nouvelle t√¢che ressemblera √† ceci </p><br><pre> <code class="hljs kotlin"> ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {project} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newTask = new Task({project: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project}) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.project.tasks.push(newTask);</code> </pre> <br><p>  De plus, avec une augmentation de la logique m√©tier, vous pouvez remarquer que le bolterplate est associ√© √† la prise en charge de backlink (par exemple, attribuer un lien √† l'objet parent lors de la cr√©ation d'un nouvel objet ou par exemple, lors du transfert d'un projet d'un dossier √† un autre, vous aurez besoin non seulement de mettre √† jour la propri√©t√© project.folder = newFolder et de supprimer vous-m√™me √† partir du tableau de projets du dossier pr√©c√©dent et en ajoutant un nouveau dossier au tableau de projets) commence √† se r√©p√©ter et il peut √©galement √™tre d√©plac√© vers la classe de base de sorte que lorsque vous cr√©ez l'objet, il suffisait de sp√©cifier le parent - <code>new Task({project: this.porps.project})</code>  <code>new Task({project: this.porps.project})</code> et la classe de base ajouterait automatiquement un nouvel objet au tableau <code>project.tasks</code> et √©galement lors du transfert de la t√¢che vers un autre projet, il suffirait de mettre √† jour le <code>task.update({project: newProject})</code> et la classe de base supprimerait automatiquement la t√¢che de un tableau de t√¢ches du projet pr√©c√©dent et ajout√© √† un nouveau.  Mais cela n√©cessitera d√©j√† la d√©claration de relations (par exemple, dans les propri√©t√©s ou m√©thodes statiques) pour que la classe de base sache quels champs mettre √† jour. </p><br><p>  <strong>Conclusion</strong> </p><br><p>  D'une mani√®re si simple, en utilisant uniquement des objets js, nous sommes arriv√©s √† la conclusion que vous pouvez obtenir toute la commodit√© de travailler avec l'√©tat g√©n√©ral de l'application sans introduire dans l'application la d√©pendance d'une biblioth√®que externe pour travailler avec l'√©tat. </p><br><p>  La question est, alors pourquoi avons-nous besoin de biblioth√®ques pour g√©rer l'√©tat et, en particulier, mobx? </p><br><p>  Le fait est que dans l'approche d√©crite de l'organisation de l'√©tat g√©n√©ral, lors de l'utilisation d'objets js ¬´vanille¬ª natifs ordinaires (ou objets de classe), il y a un gros inconv√©nient - lorsqu'une petite partie de l'√©tat ou m√™me un champ change, les composants seront mis √† jour ou ¬´rendus¬ª qui ne sont en aucun cas connect√©s. et ne d√©pendent pas de cette partie de l'√âtat. <br>  Et sur les grandes applications avec une interface utilisateur en gras, cela entra√Ænera des freins car la r√©action n'a tout simplement pas le temps de comparer r√©cursivement la maison virtuelle de l'application enti√®re, √©tant donn√© qu'en plus de comparer chaque moteur de rendu, une nouvelle arborescence d'objets sera g√©n√©r√©e √† chaque fois d√©crivant la disposition de tous les composants. </p><br><p>  Mais ce probl√®me, malgr√© son importance, est purement technique - il existe des biblioth√®ques similaires √† la r√©action vitale dom qui optimisent mieux le rendu et peuvent augmenter la limite des composants. </p><br><p>  Il existe des techniques de r√©novation domiciliaire plus efficaces que la cr√©ation d'un nouvel arbre de maison virtuelle et la passe de comparaison r√©cursive suivante avec l'arbre pr√©c√©dent. </p><br><p>  Et enfin, il existe des biblioth√®ques qui tentent de r√©soudre le probl√®me des mises √† jour lentes par une approche diff√©rente - √† savoir, pour suivre quelles parties de l'√©tat sont connect√©es √† quels composants et lors du changement de certaines donn√©es, calculer et mettre √† jour uniquement les composants qui d√©pendent de ces donn√©es et ne pas toucher les composants restants.  Redux est √©galement une telle biblioth√®que, mais elle n√©cessite une approche compl√®tement diff√©rente de l'organisation de l'√âtat.  Mais la biblioth√®que mobx, au contraire, n'apporte rien de nouveau et nous pouvons obtenir l'acc√©l√©ration du rendu pratiquement sans rien changer dans l'application - il suffit d'ajouter le d√©corateur <code>@observable</code> aux champs de la classe et le d√©corateur <code>@observable</code> est <code>@observable</code> aux composants qui rendent ces champs et il reste pour supprimer uniquement le code de mise √† jour inutile pour le composant racine dans la m√©thode update () de notre classe de base et nous obtiendrons une application pleinement fonctionnelle, mais maintenant changer une partie de l'√©tat ou m√™me un champ ne mettra √† jour que ces composants  qui a m√ªri sign√© (tournant √† l'int√©rieur de la m√©thode render ()) pour un domaine particulier d'un √©tat particulier de l'objet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416361/">https://habr.com/ru/post/fr416361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416349/index.html">Voir l'ondulation</a></li>
<li><a href="../fr416351/index.html">Approche descendante. √âconomie du produit. B√©n√©fice brut</a></li>
<li><a href="../fr416353/index.html">Audio Digest: 20 documents sur l'histoire des syst√®mes acoustiques et de la musique dans la culture sovi√©tique</a></li>
<li><a href="../fr416355/index.html">Entretien avec Gary Hudson, PDG d'Oisin Biotechnologies</a></li>
<li><a href="../fr416359/index.html">Environnement de travail rapide pour les d√©veloppeurs Web (Vagrant et PHPStorm)</a></li>
<li><a href="../fr416363/index.html">Ouverture officielle de Taobao en Russie</a></li>
<li><a href="../fr416365/index.html">Collection de souhaits et vote pour les nouvelles fonctionnalit√©s du navigateur Vivaldi</a></li>
<li><a href="../fr416367/index.html">Nous commen√ßons ReactOS avec BTRFS de la section</a></li>
<li><a href="../fr416369/index.html">√Ä peu pr√®s compliqu√©. Partie 2, cr√©ation d'une ¬´maison intelligente¬ª sans fil. Bas√© sur la technologie Linux, les logiciels Z-Wave et MajorDoMo</a></li>
<li><a href="../fr416371/index.html">Lampe de camping analogique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>