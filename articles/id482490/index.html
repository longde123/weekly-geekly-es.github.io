<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💖 👎 👺 Apa itu MISRA dan cara memasaknya 🏽 🤟 ⛸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mungkin, setiap pengembang program untuk mikrokontroler mungkin setidaknya pernah mendengar tentang standar pengkodean khusus yang dirancang untuk mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa itu MISRA dan cara memasaknya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/482490/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/5bc/021/cf95bc0219fd9e34f03d5cfc316f7e71.png" alt="Gambar 1"></div><br><br>  Mungkin, setiap pengembang program untuk mikrokontroler mungkin setidaknya pernah mendengar tentang standar pengkodean khusus yang dirancang untuk membantu meningkatkan keamanan dan portabilitas kode Anda.  Salah satu standar tersebut adalah MISRA.  Dalam artikel ini kita akan memeriksa secara lebih rinci apa standar ini, apa filosofinya dan bagaimana menggunakannya dalam proyek Anda. <br><a name="habracut"></a><br>  Banyak pembaca kami telah mendengar bahwa PVS-Studio mendukung klasifikasi peringatan mereka sesuai dengan standar MISRA.  Saat ini PVS-Studio <a href="https://www.viva64.com/ru/misra/">mencakup</a> lebih dari 100 aturan MISRA C: 2012 dan MISRA C ++: 2008. <br><br>  Artikel ini bertujuan untuk membunuh tiga burung dengan satu batu: <br><br><ol><li>  Katakan apa MISRA untuk mereka yang tidak terbiasa dengan standar ini; </li><li>  Ingatkan dunia yang melekat tentang apa yang kita mampu; </li><li>  Untuk membantu lebih dalam dalam perjalanan bisnis bagi karyawan baru yang juga akan lebih jauh mengembangkan alat analisa MISRA kami; </li></ol><br>  Saya harap saya bisa membuatnya menarik.  Jadi mari kita mulai! <br><br><h2>  Kisah MISRA </h2><br>  Sejarah MISRA dimulai sejak lama.  Kemudian, pada awal 90-an, program pemerintah Inggris dengan nama indikatif "Safe IT" mengalokasikan dana untuk berbagai proyek, dengan satu atau lain cara terkait dengan keamanan sistem elektronik.  Proyek MISRA (Asosiasi Keandalan Perangkat Lunak Industri Motor) sendiri didirikan untuk membuat panduan untuk mengembangkan perangkat lunak untuk mikrokontroler pada kendaraan darat - pada mobil, secara umum. <br><br>  Setelah menerima dana dari negara, tim MISRA mulai bekerja, dan pada November 1994 merilis panduan pertamanya: " <a href="https://pdfs.semanticscholar.org/f7ab/6319c0ab1fb546e406a3f65463cd0e5d2f0c.pdf">Pedoman pengembangan untuk perangkat lunak berbasis kendaraan</a> ".  Panduan ini belum dikaitkan dengan bahasa tertentu, tetapi harus saya akui: karya itu mengesankan dan mungkin menyangkut semua aspek yang mungkin terjadi dalam pengembangan perangkat lunak tertanam.  Ngomong-ngomong, para pengembang panduan ini baru-baru ini <a href="https://www.misra.org.uk/LinkClick.aspx%3Ffileticket%3DpHorDgiWiPs%253D%26amp%3Btabid%3D59">merayakan ulang tahun ke 25 dari</a> tanggal yang begitu penting bagi mereka. <br><br>  Ketika pendanaan dari negara berakhir, anggota MISRA memutuskan untuk terus bekerja bersama secara informal - ini berlanjut hingga hari ini.  Faktanya, MISRA (sebagai organisasi) adalah komunitas pemangku kepentingan dari berbagai industri manufaktur mobil dan pesawat terbang.  Sekarang pihak-pihak ini adalah: <br><br><ul><li>  Mobil motor Bentley </li><li>  Ford Motor Company </li><li> Jaguar land rover </li><li>  Sistem diesel delphi </li><li>  HORIBA MIRA </li><li>  Listrik protein </li><li>  Layanan teknik Visteon </li><li>  Universitas leeds </li><li>  Ricardo uk </li><li>  ZF TRW </li></ul><br>  Pelaku pasar yang sangat kuat, bukan?  Tidak mengherankan, standar terkait bahasa pertama mereka, MISRA C, telah diterima secara luas di antara para pengembang tertanam yang kritis terhadap misi.  MISRA C ++ muncul sedikit kemudian.  Secara bertahap, versi standar diperbarui dan disempurnakan untuk mencakup fitur-fitur baru bahasa.  Pada saat penulisan ini, versi saat ini adalah MISRA C: 2012 dan MISRA C ++: 2008. <br><br><h2>  Filsafat dan Contoh Aturan </h2><br>  Fitur yang paling khas dari MISRA adalah perhatiannya terhadap detail dan ketelitian yang luar biasa dalam memastikan keamanan.  Para penulis tidak hanya berkumpul di satu tempat semua "lubang" C dan C ++ yang muncul di benak (seperti, misalnya, penulis CERT) - mereka dengan hati-hati menyusun standar internasional bahasa-bahasa ini dan menuliskan semua cara yang mungkin dan tidak terpikirkan untuk membuat kesalahan.  Dan kemudian mereka mengambil dan menambahkan aturan tentang keterbacaan kode dari atas - ini untuk membuatnya lebih sulit untuk memperkenalkan kesalahan baru ke dalam kode yang sudah bersih. <br><br>  Untuk memahami tingkat keseriusan, pertimbangkan beberapa aturan yang diambil dari standar. <br><br>  Di satu sisi, ada banyak aturan yang baik dan cocok yang harus selalu diikuti setiap saat, terlepas dari apa tujuan proyek Anda.  Sebagian besar, mereka dirancang untuk menghilangkan perilaku yang tidak ditentukan / tidak ditentukan / tergantung implementasi.  Sebagai contoh: <br><br><ul><li>  Jangan gunakan nilai variabel yang tidak diinisialisasi </li><li>  Jangan gunakan pointer FILE setelah menutup aliran </li><li>  Semua fungsi non-void harus mengembalikan nilai. </li><li>  Penghitung lingkaran tidak boleh memiliki tipe titik-mengambang </li><li>  ... dll. </li></ul><br>  Di sisi lain, ada aturan, manfaat yang terletak di permukaan, tetapi yang (dari sudut pandang proyek biasa) tidak begitu berdosa untuk dilanggar: <br><br><ul><li>  Jangan gunakan goto dan longjmp </li><li>  Setiap switch harus diakhiri dengan default </li><li>  Jangan menulis kode yang tidak terjangkau </li><li>  Jangan gunakan fungsi variabel </li><li>  Jangan gunakan aritmatika alamat (kecuali <i>[]</i> dan <i>++</i> ) </li><li>  ... </li></ul><br>  Aturan seperti itu juga tidak buruk, dan dalam kombinasi dengan yang sebelumnya mereka sudah memberikan peningkatan keamanan yang nyata, tetapi apakah ini cukup untuk sistem embedded yang sangat bertanggung jawab?  Mereka digunakan tidak hanya dalam industri otomotif, tetapi juga dalam pembuatan pesawat terbang, kedirgantaraan, militer, dan medis. <br><br>  Kami tidak ingin, karena kesalahan perangkat lunak, beberapa mesin sinar-X <a href="https://www.viva64.com/ru/b/0438/">menyinari pasien dengan dosis 20.000 rad</a> , sehingga aturan "sehari-hari" yang biasa tidak lagi cukup.  Yang dipertaruhkan adalah nyawa manusia dan sejumlah besar uang, dan ketelitian harus dimasukkan.  Di sini aturan MISRA lainnya naik ke atas panggung: <br><ul><li>  Sufiks 'L' dalam literal harus selalu huruf besar (huruf 'l' kecil dapat dikacaukan dengan unit) </li><li>  Jangan gunakan operator koma (meningkatkan kemungkinan melakukan kesalahan) </li><li>  Jangan gunakan rekursi (setumpuk mikrokontroler kecil dapat dengan mudah meluap) </li><li>  Badan <i>if</i> , <i>else</i> , <i>for</i> , <i>while</i> , <i>do</i> , <i>statement switch</i> harus dibungkus dengan kurung kurawal (Anda berpotensi dapat membuat kesalahan jika <a href="https://www.viva64.com/ru/w/v2507/">kode tidak disejajarkan dengan benar</a> ) </li><li>  Jangan gunakan memori dinamis (karena ada kemungkinan tidak berhasil mengalokasikannya dari tumpukan, terutama di mikrokontroler) </li><li>  ... dan banyak, banyak aturan seperti itu. </li></ul><br>  Seringkali, orang yang menemukan MISRA berpendapat bahwa filosofi standar adalah "melarang ini dan melarang ini."  Sebenarnya ini memang benar, tetapi hanya sebagian saja. <br><br>  Ya, standar memang memiliki banyak aturan yang serupa, tetapi tujuannya bukan untuk melarang segala sesuatu yang mungkin, tetapi untuk membuat daftar semua-semua-semua cara untuk entah bagaimana melanggar keamanan kode.  Untuk sebagian besar aturan, Anda memilih untuk mengikutinya atau tidak.  Saya akan menjelaskan ini secara lebih rinci. <br><br>  Dalam MISRA C, aturan termasuk dalam tiga kategori utama: Mandatory, Required, and Advisory.  Wajib - ini adalah aturan yang tidak boleh dilanggar dengan alasan apa pun.  Misalnya, bagian ini mencakup aturan "jangan gunakan nilai variabel yang tidak diinisialisasi".  Aturan yang diperlukan kurang ketat: mereka memungkinkan kemungkinan penolakan, tetapi hanya jika penyimpangan ini didokumentasikan dan dibenarkan secara tertulis.  Aturan yang tersisa termasuk dalam kategori Penasihat - ini adalah aturan yang tidak perlu diikuti. <br><br>  MISRA C ++ sedikit berbeda: kategori Wajib tidak ada di sana, dan sebagian besar aturan termasuk dalam kategori Wajib.  Karena itu, pada kenyataannya, Anda memiliki hak untuk melanggar aturan apa pun - ingatlah untuk mendokumentasikan penyimpangan tersebut.  Ada juga Dokumen kategori - ini adalah aturan wajib (penyimpangan tidak diperbolehkan), yang terkait dengan praktik umum seperti "Setiap penggunaan assembler harus didokumentasikan" atau "perpustakaan plug-in harus mematuhi MISRA C ++". <br><br><h2>  Apa lagi yang ada di sana </h2><br>  Faktanya, MISRA bukan hanya seperangkat aturan.  Bahkan, ini adalah manual untuk menulis kode aman untuk mikrokontroler, dan karena itu penuh dengan segala macam kegunaan.  Mari kita lihat secara detail. <br><br>  Pertama, standar berisi deskripsi latar belakang yang agak menyeluruh: demi apa standar dibuat, mengapa C atau C ++ dipilih, kelebihan dan kekurangan bahasa ini. <br><br>  Kami sangat menyadari keutamaan bahasa-bahasa ini.  Ya, dan tentang kekurangannya, secara umum juga :) Apa kompleksitas tinggi, spesifikasi standar dan sintaksis yang tidak lengkap yang membuatnya sangat mudah untuk membuat kesalahan, dan kemudian mencari kesalahan untuk waktu yang lama.  Misalnya, Anda dapat menulis ini tanpa sengaja: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i); { do_something(); }</code> </pre> <br>  Namun, ada kemungkinan bahwa seseorang tidak akan melihat <a href="https://www.viva64.com/ru/w/v529/">titik koma tambahan</a> , kan?  Anda juga dapat menulis <a href="https://www.viva64.com/ru/w/v559/">seperti ini</a> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpendTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doWantToKillPeople)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doWantToKillPeople = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { StartNuclearWar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { PlayComputerGames(); } }</code> </pre> <br>  Baik bahwa kasus <a href="https://www.viva64.com/ru/w/v2507/">pertama</a> dan <a href="https://www.viva64.com/ru/w/v2561/">kedua</a> mudah ditangkap oleh aturan MISRA (yang pertama adalah MISRA C: 13.4 / MISRA C ++: 6.2.1, yang kedua adalah MISRA C: 13.4 / MISRA C ++: 6.2.1). <br><br>  Selain menjelaskan masalah, standar berisi sejumlah besar tips tentang apa yang perlu Anda ketahui sebelum Anda mulai: tentang cara mengatur proses pengembangan MISRA, tentang penggunaan analisis statis untuk memeriksa kode kepatuhan, pada dokumen mana yang perlu Anda simpan, dan bagaimana isi, dan sebagainya dan sebagainya. <br><br>  Di bagian akhir juga terdapat aplikasi yang berisi: daftar pendek dan ringkasan tabel aturan, daftar kecil kerentanan C / C ++, contoh dokumentasi penyimpangan dari aturan, serta beberapa daftar periksa yang dirancang untuk membantu Anda tidak tersesat di seluruh birokrasi ini. <br><br>  Seperti yang Anda lihat, MISRA bukan hanya seperangkat aturan, tetapi hampir seluruh infrastruktur untuk menulis kode aman untuk sistem tertanam. <br><br><h2>  Gunakan dalam proyek Anda </h2><br>  Bayangkan sebuah situasi: Anda akan menulis sebuah program untuk beberapa sistem embedded yang sangat penting dan bertanggung jawab.  Atau Anda sudah memiliki program, tetapi Anda perlu "mentransfer" ke MISRA.  Bagaimana cara memeriksa kode Anda untuk kepatuhan terhadap standar?  Apakah Anda benar-benar harus melakukannya secara manual? <br><br>  Verifikasi kode manual bukanlah tugas yang mudah dan berpotensi tidak mungkin.  Tidak hanya setiap pengulas harus hati-hati melihat setiap baris kode, tetapi mereka juga harus tahu standarnya.  Horor! <br><br>  Oleh karena itu, pengembang MISRA sendiri disarankan untuk menggunakan analisis statis untuk menguji kode Anda.  Memang, pada kenyataannya, analisis statis adalah proses peninjauan kode otomatis.  Anda cukup menjalankan analisa pada program Anda dan dalam beberapa menit Anda akan menerima laporan tentang kemungkinan pelanggaran standar.  Apa yang Anda butuhkan, bukan?  Anda hanya perlu melihat log dan memperbaiki responsnya. <br><br>  Pertanyaan berikutnya: pada titik apa Anda mulai menggunakan MISRA?  Jawabannya sederhana: semakin cepat semakin baik.  Idealnya, bahkan sebelum Anda mulai menulis kode, karena MISRA mengasumsikan bahwa Anda mengikuti standar selama masa pakai kode Anda. <br><br>  Tentu saja, tidak selalu mungkin untuk menulis MISRA sejak awal.  Sebagai contoh, sering terjadi bahwa suatu proyek telah dilaksanakan sebagian atau sepenuhnya, tetapi pelanggan berharap bahwa proyek tersebut memenuhi standar.  Dalam hal ini, Anda harus melakukan refactoring menyeluruh terhadap kode yang ada. <br><br>  Di sinilah perangkap muncul.  Saya bahkan akan mengatakan batu bawah air muncul.  Apa yang terjadi jika Anda mengambil analisa statis dan memeriksa proyek "biasa" untuk kepatuhan dengan standar MISRA?  Spoiler: Anda bisa takut. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/2b7/7d9/44e2b77d90cd9804e1ec0a5a38f166a2.png" alt="Gambar 5"></div><br><br>  Tentu saja, contoh dalam gambar ini dilebih-lebihkan.  Di sini Anda dapat melihat hasil pengecekan proyek yang cukup besar, yang sebenarnya tidak pernah terpikirkan untuk mengerjakan mikrokontroler.  Namun demikian, ketika memeriksa kode yang ada, Anda mungkin melihat satu, dua, lima, atau bahkan sepuluh ribu operasi penganalisa.  Dan dalam semua tumpukan ini operasi baru akan hilang yang dikeluarkan ke kode yang baru saja ditulis atau diubah. <br><br>  Apa yang harus dilakukan?  Apakah benar-benar perlu mengesampingkan semua hal dan duduk untuk memperbaiki semua yang lama? <br><br>  Kita tahu bahwa pertama kali proyek diperiksa, banyak hal positif yang muncul cukup sering, dan telah mengembangkan solusi yang akan membantu Anda mendapatkan manfaat dari penganalisa dengan segera, tanpa menghentikan pekerjaan.  Solusi ini disebut "basis penekan." <br><br>  Basis penekan adalah mekanisme PVS-Studio yang memungkinkan pesan penganalisa menekan secara besar-besaran.  Jika Anda memeriksa proyek untuk pertama kalinya dan menemukan beberapa ribu positif di sana, Anda cukup menambahkannya ke basis penekan, dan saat berikutnya Anda menjalankan analisa, itu akan memberi Anda nol peringatan. <br><br>  Dengan demikian, Anda dapat terus menulis dan memodifikasi kode dengan cara biasa, dan pada saat yang sama Anda akan melihat peringatan hanya tentang kesalahan-kesalahan yang baru saja diperkenalkan ke dalam proyek.  Pada saat yang sama, Anda akan mendapatkan manfaat maksimal dari alat analisa di sini dan sekarang, tanpa terganggu oleh kesalahan lama.  Beberapa klik - dan alat analisa diimplementasikan!  Anda dapat membaca petunjuk terperinci tentang ini di <a href="https://www.viva64.com/ru/m/0032/">sini</a> . <br><br>  Anda mungkin bertanya: "Tunggu, apa yang harus dilakukan dengan tanggapan tersembunyi?" Jawabannya cukup sederhana: jangan lupa tentang mereka dan diam-diam memperbaikinya.  Anda dapat, misalnya, meletakkan basis penekan dalam sistem kontrol versi dan hanya memperbolehkan komit yang tidak menambah jumlah operasi.  Dengan demikian, secara bertahap, "batu bawah air" Anda cepat atau lambat akan terkuras dan tidak akan ada jejaknya. <br><br>  Oke, alat analisa sudah diimplementasikan dan sekarang kami siap untuk melanjutkan.  Apa yang harus dilakukan selanjutnya?  Bersihkan bisnis - untuk bekerja dengan kode.  Tetapi apa yang dibutuhkan untuk dapat menyatakan kepatuhan dengan standar?  Bagaimana membuktikan bahwa proyek Anda sesuai dengan MISRA? <br><br>  Faktanya adalah bahwa tidak ada "sertifikat" khusus yang sesuai dengan kode Anda dengan MISRA.  Sesuai standar itu sendiri, pelacakan kode kepatuhan harus dilakukan oleh dua pihak: pelanggan perangkat lunak dan penyedia perangkat lunak.  Pemasok mengembangkan perangkat lunak yang sesuai dengan standar dan mengisi dokumen yang diperlukan.  Pelanggan, untuk bagiannya, harus memastikan bahwa data dari dokumen-dokumen ini benar. <br><br>  Jika Anda sendiri adalah pelanggan dan pengembang perangkat lunak Anda sendiri, maka tanggung jawab untuk mematuhi standar hanya akan berada di pundak Anda :) <br><br>  Secara umum, untuk membuktikan kesesuaian proyek Anda, Anda akan memerlukan dokumen bukti.  Daftar dokumen yang harus disiapkan oleh pengembang proyek dapat beragam, tetapi MISRA menawarkan beberapa sebagai referensi.  Mari kita pertimbangkan set ini lebih detail. <br><br>  Untuk mengklaim kepatuhan dengan standar, Anda akan memerlukan beberapa hal: <br><br><ul><li>  Sebenarnya proyek yang kodenya mematuhi aturan Wajib dan Diperlukan </li><li>  Panduan rencana penegakan </li><li>  Dokumentasi semua peringatan penyusun dan penganalisa statis </li><li>  Dokumentasi semua penyimpangan dari aturan yang Diperlukan </li><li>  Ringkasan pedoman kepatuhan </li></ul><br>  Yang pertama adalah rencana kepatuhan.  Ini adalah meja Anda yang paling penting, dan akan mengirim penguji ke semua dokumen lain.  Pada kolom pertama adalah daftar aturan MISRA, sisanya dicatat apakah ada penyimpangan dari aturan ini telah diidentifikasi.  Tabel ini terlihat seperti ini: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/643/231/3416432314b7841327af4659356de62c.png" alt="Gambar 8"></div><br>  Standar merekomendasikan membangun proyek Anda dengan beberapa kompiler, serta menggunakan dua atau lebih analisa statis untuk memeriksa kode Anda untuk kepatuhan.  Jika kompilator atau penganalisa menghasilkan semacam peringatan yang terkait dengan aturan, Anda harus mencatat ini dalam tabel dan dokumen: mengapa operasi tidak dapat dihilangkan, apakah itu salah, dll. <br><br>  Jika ada aturan yang tidak dapat diperiksa dengan penganalisa statis, maka Anda perlu melakukan prosedur peninjauan kode.  Prosedur ini juga harus didokumentasikan, setelah itu tautan ke dokumentasi ini harus ditambahkan ke rencana kepatuhan. <br><br>  Jika kompiler atau penganalisa statis ternyata benar, atau jika pelanggaran kode aktual ditemukan dalam proses peninjauan kode, Anda harus memperbaikinya atau mendokumentasikannya.  Sekali lagi, dengan melampirkan tautan ke dokumentasi di tabel. <br><br>  Dengan demikian, rencana kepatuhan adalah dokumen yang dengannya Anda dapat menemukan dokumentasi untuk setiap penyimpangan yang diidentifikasi dalam kode Anda. <br><br>  Sekarang sedikit tentang dokumentasi penyimpangan dari aturan.  Seperti yang telah saya sebutkan, dokumentasi semacam itu hanya diperlukan untuk aturan yang Diperlukan, karena Anda tidak dapat melanggar aturan tingkat Wajib, dan aturan Penasihat tidak dapat diikuti tanpa dokumentasi apa pun. <br><br>  Jika Anda memutuskan untuk menyimpang dari aturan, maka dokumentasi harus berisi: <br><br><ul><li>  Nomor Aturan Rusak </li><li>  Lokasi penyimpangan yang tepat </li><li>  Validitas penyimpangan </li><li>  Bukti bahwa penyimpangan tidak membahayakan keamanan </li><li>  Implikasi pengguna potensial </li></ul><br>  Seperti yang Anda lihat, pendekatan dokumentasi ini membuat Anda berpikir serius apakah pelanggaran itu sepadan.  Hal ini dilakukan secara khusus untuk melanggar peraturan yang diperlukan tidak baik :) <br><br>  Sekarang tentang ringkasan kepatuhan dengan aturan.  Makalah ini mungkin yang paling mudah diisi: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3d/77e/e05/f3d77ee05c3639efdc6df19706d60450.png" alt="Gambar 2"></div><br>  Kolom pusat diisi sebelum Anda mulai bekerja dengan kode, dan kolom paling kanan adalah setelah proyek Anda siap. <br><br>  Cukup masuk akal untuk mengajukan pertanyaan: mengapa Anda perlu menentukan kategori aturan, jika sudah ditentukan dalam standar itu sendiri?  Faktanya adalah bahwa standar memungkinkan "peningkatan" aturan dalam kategori yang lebih ketat.  Misalnya, pelanggan mungkin meminta Anda untuk memindahkan aturan Penasihat ke dalam kategori.  "Peningkatan" seperti itu harus dilakukan sebelum bekerja dengan kode, dan ringkasan kepatuhan dengan aturan memungkinkan hal ini dicatat dengan jelas. <br><br>  Dengan kolom terakhir, semuanya sederhana: cukup untuk hanya mencatat apakah aturan itu digunakan, dan jika demikian, maka ada penyimpangan dari itu. <br><br>  Seluruh tabel ini diperlukan agar Anda dapat dengan cepat melihat prioritas apa yang dimiliki aturan dan apakah kode cocok dengan mereka.  Jika tiba-tiba Anda tertarik untuk mengetahui alasan pasti penolakan, Anda selalu dapat merujuk ke rencana kepatuhan dan menemukan dokumentasi yang Anda butuhkan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b4/c84/ca8/5b4c84ca873358cbb9b5dd6349330da4.png" alt="Gambar 3"></div><br>  Jadi, Anda menulis kode dengan hati-hati mengikuti aturan MISRA.  Anda membuat rencana kepatuhan dan mendokumentasikan semua yang dapat Anda dokumentasikan, dan mengisi ringkasan kepatuhan.  Jika ini benar, maka Anda telah menerima kode yang sangat bersih, sangat mudah dibaca, dan sangat andal yang sekarang Anda benci :) <br><br>  Di mana program Anda akan tinggal sekarang?  Di mesin MRI?  Dalam sensor kecepatan biasa atau dalam sistem autopilot dari beberapa satelit luar angkasa?  Ya, Anda melewati jalur birokrasi yang serius, tapi ini sepele.  Bagaimana mungkin seseorang tidak menjadi teliti ketika kehidupan manusia nyata dipertaruhkan? <br><br>  Jika Anda berhasil dan berhasil mencapai kemenangan, maka saya dengan tulus mengucapkan selamat kepada Anda: Anda menulis kode aman berkualitas tinggi.  Terima kasih <br><br><h2>  Masa depan standar </h2><br>  Akhirnya, saya ingin berbicara sedikit tentang masa depan standar. <br><br>  MISRA saat ini hidup dan berkembang.  Misalnya, pada awal 2019, “MISRA C: 2012 Edisi Ketiga (Revisi Pertama)” diumumkan - pembaruan dan dilengkapi dengan aturan baru 2012 standar.  Pada saat yang sama, mereka mengumumkan rilis MISRA C: Amandemen 2 - C11 Core yang akan datang, standar 2012, di mana aturan akan ditambahkan yang mencakup versi pertama bahasa C pada tahun 2011 dan 2018. <br><br>  Tidak diam dan MISRA C ++.  Seperti yang Anda ketahui, standar MISRA C ++ terbaru kembali ke tahun 2008, jadi versi bahasa tertua yang tercakup adalah C ++ 03.  Karena itu, ada standar lain, mirip dengan MISRA, dan itu disebut AUTOSAR C ++.  Ini awalnya dipahami sebagai kelanjutan dari MISRA C ++ dan dimaksudkan untuk mencakup versi bahasa selanjutnya.  Tidak seperti dalangnya, AUTOSAR C ++ diperbarui dua kali setahun dan saat ini mendukung C ++ 14.  Peningkatan lebih lanjut direncanakan untuk C ++ 17, dan kemudian C ++ 20, dan seterusnya. <br><br>  Apa yang saya mulai tentang standar lain?  Faktanya adalah bahwa kurang dari setahun yang lalu, kedua organisasi mengumumkan penyatuan standar mereka menjadi satu.  Sekarang MISRA C ++ dan AUTOSAR C ++ akan menjadi standar tunggal, dan sekarang mereka akan dikembangkan bersama.  Saya pikir ini adalah berita bagus untuk pengembang yang menulis di bawah mikrokontroler C ++, dan tidak kurang berita bagus untuk pengembang analisis statis.  Masih banyak pekerjaan favorit di depan!  :) <br><br><h2>  Kesimpulan </h2><br>  Hari ini kami telah belajar banyak tentang MISRA: kami membaca sejarah kemunculannya, mempelajari contoh aturan dan filosofi standar, mempertimbangkan semua yang Anda butuhkan untuk menggunakan MISRA dalam proyek Anda, dan bahkan melihat sedikit ke masa depan.  Saya harap Anda sekarang lebih memahami apa MISRA itu dan bagaimana cara memasaknya! <br><br>  Menurut tradisi lama, saya akan meninggalkan tautan di sini ke penganalisa statis PVS-Studio kami.  Ia dapat menemukan tidak hanya penyimpangan dari standar MISRA, tetapi juga sejumlah <a href="https://www.viva64.com/ru/examples/">besar</a> kesalahan dan kerentanan.  Jika Anda tertarik untuk mencoba PVS-Studio sendiri, <a href="https://www.viva64.com/ru/pvs-studio-download/">unduh</a> versi demo dan periksa proyek Anda. <br><br>  Ini menyimpulkan artikel saya.  Saya berharap semua pembaca selamat Tahun Baru dan akhir pekan Tahun Baru yang bahagia! <br><br><h2>  Tautan situs </h2><br><ol><li>  Georgy Gribkov - " <a href="http://0x1.tv/%25D0%2591%25D0%25B5%25D0%25B7%25D0%25BE%25D0%25BF%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0_%25D0%25BC%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B0%25D1%2585_%25E2%2580%2594_%25D0%25BA%25D0%25B0%25D0%25BA_%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B5%25D0%25B6%25D0%25BD%25D1%258B%25D0%25B9_C/C%252B%252B_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25B2%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25B5%25D0%25BC%25D1%258B%25D1%2585_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC_(%25D0%2593%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B3%25D0%25B8%25D0%25B9_%25D0%2593%25D1%2580%25D0%25B8%25D0%25B1%25D0%25BA%25D0%25BE%25D0%25B2,_SECR-2019)">Keamanan dengan kecepatan maksimum - cara menulis kode C / C ++ yang andal untuk sistem tertanam</a> ." </li><li>  <a href="https://youtu.be/c5sJd4Abr8c">PVS-Studio adalah penganalisa kode statis</a> . </li><li>  <a href="https://youtu.be/9h7yObKAADU">Kolaborasi PVS-Studio &amp; KEIL 5</a> . </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/482486/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: George Gribkov.  <a href="https://habr.com/en/company/pvs-studio/blog/482486/">Apa itu MISRA dan bagaimana cara memasaknya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482490/">https://habr.com/ru/post/id482490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482478/index.html">Iteraptor: perpustakaan untuk redus peta transparan dalam</a></li>
<li><a href="../id482480/index.html">Sentuhan kosmik dari tahun keluar</a></li>
<li><a href="../id482482/index.html">Bermain peran</a></li>
<li><a href="../id482484/index.html">Cara meningkatkan efisiensi pengembangan menggunakan teori kendala</a></li>
<li><a href="../id482486/index.html">Apa itu Misra dan bagaimana cara memasaknya</a></li>
<li><a href="../id482492/index.html">Emisi pencairan permafrost dan gas rumah kaca</a></li>
<li><a href="../id482494/index.html">Perbarui Hasil Survei</a></li>
<li><a href="../id482496/index.html">Hasil: 9 terobosan teknologi utama tahun 2019</a></li>
<li><a href="../id482498/index.html">Sejarah evolusi antarmuka di Jawa</a></li>
<li><a href="../id482500/index.html">Python atau R: Manakah Pilihan Yang Lebih Baik Untuk Ilmu Data?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>