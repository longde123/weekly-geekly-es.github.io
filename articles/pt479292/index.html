<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÅ üê∫ ‚òùÔ∏è Como ensinar uma rede neural a reproduzir a f√≠sica dos jogos üìë üî∫ üë®üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em quase todos os jogos de computador modernos, a presen√ßa de um mecanismo f√≠sico √© um pr√©-requisito. Bandeiras e coelhos tremulando ao vento, bombard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como ensinar uma rede neural a reproduzir a f√≠sica dos jogos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/479292/"> Em quase todos os jogos de computador modernos, a presen√ßa de um mecanismo f√≠sico √© um pr√©-requisito.  Bandeiras e coelhos tremulando ao vento, bombardeados por bolas - tudo isso requer execu√ß√£o adequada.  E, √© claro, mesmo que nem todos os her√≥is usem capas de chuva ... mas aqueles que usam realmente precisam de uma simula√ß√£o adequada de tecido esvoa√ßante. <br><br><img src="https://habrastorage.org/webt/5-/tq/jb/5-tqjb5ugkqhg77mf9vr1lfzz9o.png"><br><br>  No entanto, a modelagem f√≠sica completa dessas intera√ß√µes geralmente se torna imposs√≠vel, pois √© uma ordem de magnitude mais lenta que o necess√°rio para jogos em tempo real.  Este artigo oferece um novo m√©todo de modelagem que pode acelerar simula√ß√µes f√≠sicas e torn√°-las 300-5000 vezes mais r√°pidas.  Seu objetivo √© tentar ensinar uma rede neural a simular for√ßas f√≠sicas. <br><a name="habracut"></a><br>  O progresso no desenvolvimento de motores f√≠sicos √© determinado pelo crescente poder computacional dos equipamentos t√©cnicos e pelo desenvolvimento de m√©todos de modelagem r√°pidos e est√°veis.  Tais m√©todos incluem, por exemplo, modelagem, cortando espa√ßo em subespa√ßos e abordagens orientadas a dados - ou seja, com base em dados.  O primeiro funciona apenas em um subespa√ßo reduzido ou compactado, onde apenas algumas formas de deforma√ß√£o s√£o levadas em considera√ß√£o.  Para grandes projetos, isso pode levar a um aumento significativo nos requisitos t√©cnicos.  As abordagens orientadas a dados usam a mem√≥ria do sistema e os dados pr√©-computados armazenados nele, o que reduz esses requisitos. <br><br>  Aqui, examinamos uma abordagem que combina os dois m√©todos: dessa maneira, pretende-se capitalizar os pontos fortes de ambos.  Esse m√©todo pode ser interpretado de duas maneiras: como um m√©todo de modelagem de subespa√ßo parametrizado por uma rede neural ou como um m√©todo DD baseado na modelagem de subespa√ßos para construir um meio simulado compactado. <br><br>  Sua ess√™ncia √© a seguinte: primeiro coletamos dados de simula√ß√£o de alta precis√£o usando o <abbr title="Maya nCloth - kit de ferramentas integrado para criar gr√°ficos de computador altamente realistas Autodesk Maya, que permite criar tecidos realistas e outros materiais deform√°veis.">Maya nCloth</abbr> e depois calculamos o subespa√ßo linear usando <abbr title="A an√°lise de componentes principais (PCA) √© uma das principais maneiras de reduzir a dimensionalidade dos dados, enquanto perde a menor quantidade de informa√ß√µes. Do ponto de vista matem√°tico, esse m√©todo √© uma transforma√ß√£o linear ortogonal que mapeia dados do espa√ßo de recurso original para um novo espa√ßo de menor dimens√£o. Nesse caso, o primeiro eixo do novo sistema de coordenadas √© constru√≠do de tal maneira que a dispers√£o dos dados ao longo dele seria m√°xima. O segundo eixo √© constru√≠do ortogonalmente ao primeiro para que a varia√ß√£o dos dados ao longo deles tamb√©m seja o m√°ximo poss√≠vel do restante, e assim por diante. Assim, o significado do m√©todo reside no fato de que cada componente principal est√° associado a uma certa fra√ß√£o da varia√ß√£o total do conjunto de dados original. Por sua vez, a varia√ß√£o, que √© uma medida da variabilidade dos dados, pode refletir o n√≠vel do conte√∫do de suas informa√ß√µes.">o m√©todo do componente principal (PCA)</abbr> .  Na pr√≥xima etapa, usamos o aprendizado de m√°quina com base no modelo cl√°ssico de rede neural e em nossa nova metodologia, ap√≥s o qual introduzimos o modelo treinado em um algoritmo interativo com v√°rias otimiza√ß√µes, como um algoritmo de descompress√£o eficiente por uma GPU e um m√©todo para aproximar os v√©rtices normais. <br><br><img src="https://habrastorage.org/webt/6n/_a/1u/6n_a1urmdl9_nqjackk2iwmvuag.png"><br>  <i>Figura 1. O diagrama estrutural do m√©todo</i> <br><br><h3>  Dados de treinamento </h3><br>  De um modo geral, a √∫nica entrada para esse m√©todo s√£o os carimbos de data / hora brutos das posi√ß√µes quadro a quadro dos v√©rtices do objeto.  A seguir, descrevemos o processo de coleta desses dados. <br><br>  Realizamos a simula√ß√£o no Maya nCloth, capturando dados a uma velocidade de 60 quadros por segundo, com 5 ou 20 subetapas e 10 ou 25 itera√ß√µes limitantes, dependendo da estabilidade da simula√ß√£o.  Para tecidos, use um modelo de camiseta com um leve aumento no peso do material e sua resist√™ncia ao esticamento e, para objetos deform√°veis, borracha dura com atrito reduzido.  Realizamos colis√µes externas colidindo tri√¢ngulos de geometria externa, autocolis√µes - v√©rtices com v√©rtices para tecido e tri√¢ngulos com tri√¢ngulos para borracha.  Em todos os casos, usamos uma espessura de colis√£o bastante grande - da ordem de 5 cm - para garantir a estabilidade do modelo e para evitar beliscar e rasgar o tecido. <br><br>  <i>Tabela 1. Par√¢metros dos Objetos Modelados</i> <br><img src="https://habrastorage.org/webt/dw/ag/tf/dwagtfbbptnhiioq-2gutci9ung.png"><br><br>  Para v√°rios tipos de intera√ß√£o de objetos simples (por exemplo, esferas), geraremos seu movimento de maneira aleat√≥ria cortando coordenadas aleat√≥rias em momentos aleat√≥rios.  Para simular a intera√ß√£o do tecido com um personagem, usamos um banco de dados de captura de movimento de 6,5 √ó 10 <sup>5</sup> quadros, que s√£o uma grande anima√ß√£o.  Ap√≥s a conclus√£o da simula√ß√£o, verificamos o resultado e exclu√≠mos os quadros com comportamento inst√°vel ou ruim.  Para a cena com a saia, removemos as m√£os do personagem, pois elas freq√ºentemente se cruzam com a geometria da malha das pernas e agora s√£o insignificantes. <br><br><img src="https://habrastorage.org/webt/0r/aa/ug/0raaugw5jdlmj9aqrzac7uj14-e.gif"><br>  <i>Figura 2. As duas primeiras cenas da tabela</i> <br><br>  Normalmente, precisamos de 10 <sup>5 a</sup> 10 <sup>6</sup> quadros de dados de treinamento.  Em nossa experi√™ncia, na maioria dos casos, 10 <sup>5</sup> quadros √© suficiente para teste, enquanto os melhores resultados s√£o alcan√ßados com 10 <sup>6</sup> quadros. <br><br><h3>  Treinamento </h3><br>  A seguir, falaremos sobre o processo de aprendizado de m√°quina: sobre parametriza√ß√£o em nossa rede neural, sobre arquitetura de rede e diretamente sobre a pr√≥pria t√©cnica. <br><br><h4>  Parametriza√ß√£o </h4><br>  Para obter um conjunto de dados de treinamento, coletamos as coordenadas dos v√©rtices em cada quadro <i>t</i> em um vetor <i>x <sub>t</sub></i> e, em seguida, combinamos esses vetores quadro a quadro em uma grande matriz X. Essa matriz descreve os estados do objeto modelado.  Al√©m disso, devemos ter uma id√©ia do estado dos objetos externos em cada quadro.  Para objetos simples (como bolas), √© poss√≠vel usar suas coordenadas tridimensionais, enquanto o estado de modelos complexos (personagem) √© descrito pela posi√ß√£o de cada articula√ß√£o em rela√ß√£o ao ponto de refer√™ncia: no caso de uma saia, esse suporte ser√° a articula√ß√£o do quadril, no caso de uma capa - o pesco√ßo.  Para objetos com um sistema de refer√™ncia m√≥vel, a posi√ß√£o da Terra em rela√ß√£o a ele deve ser levada em considera√ß√£o: ent√£o nosso sistema saber√° a dire√ß√£o da gravidade, bem como sua velocidade linear, acelera√ß√£o, velocidade de rota√ß√£o e acelera√ß√£o de rota√ß√£o.  Para a bandeira, levaremos em conta a velocidade e a dire√ß√£o do vento.  Como resultado, para cada objeto, obtemos um vetor grande que descreve o estado do objeto externo, e todos esses vetores tamb√©m s√£o combinados na matriz Y. <br><br>  Agora, aplicamos o PCA √†s matrizes X e Y e usamos as matrizes de transforma√ß√£o Z e W resultantes para construir a imagem do subespa√ßo.  Se o procedimento PCA exigir muita mem√≥ria, primeiro experimente nossos dados. <br><br>  A compacta√ß√£o do PCA inevitavelmente resulta em perda de detalhes, especialmente para objetos com muitas condi√ß√µes em potencial, como dobras finas de tecido.  No entanto, se o subespa√ßo consistir em 256 vetores base, isso geralmente ajudar√° a preservar a maioria dos detalhes.  Abaixo est√£o anima√ß√µes da f√≠sica padr√£o da capa e modelos com 256, 128 e 64 vetores base, respectivamente. <br><br><img src="https://habrastorage.org/webt/yt/gg/7a/ytgg7aiprksj0qtezlvbpy2qcs4.gif"><br>  <i>Figura 3. Compara√ß√£o do modelo de controle (padr√£o) com os modelos obtidos por nosso m√©todo em espa√ßos com diferentes bases de dimens√£o</i> <br><br><h4>  Modelo de origem e estendido </h4><br>  Foi necess√°rio desenvolver um modelo que pudesse prever o estado dos vetores de modelo em quadros futuros.  E como os objetos modelados s√£o geralmente caracterizados por in√©rcia com tend√™ncia a um determinado estado m√©dio de repouso (ap√≥s o procedimento PCA, o objeto leva esse estado a valores zero), um bom modelo inicial seria a express√£o representada pela linha 9 do algoritmo na Figura 4. Aqui Œ± e Œ≤ s√£o os par√¢metros do modelo, ‚äô √© um produto explodido.  Os valores desses par√¢metros ser√£o obtidos a partir dos dados de origem, resolvendo a <abbr title="O m√©todo dos m√≠nimos quadrados √© um m√©todo matem√°tico usado para resolver v√°rios problemas, com base na minimiza√ß√£o da soma dos desvios quadrados de algumas fun√ß√µes das vari√°veis ‚Äã‚Äãdesejadas.">equa√ß√£o linear dos m√≠nimos quadrados</abbr> individualmente para Œ± e Œ≤: <br><br><img src="https://habrastorage.org/webt/4g/ml/d1/4gmld1lrufdu-hdusjpuerfmb6w.png"><br><br>  Aqui ‚Ä† √© a <abbr title="A + √© chamado de matriz pseudo-inversa para uma matriz A se satisfizer os seguintes crit√©rios: A A + A = A; A + A A + = A +; (A A +) * = A A +; (A + A) * = A + A.">transforma√ß√£o pseudo</abbr> - <abbr title="A + √© chamado de matriz pseudo-inversa para uma matriz A se satisfizer os seguintes crit√©rios: A A + A = A; A + A A + = A +; (A A +) * = A A +; (A + A) * = A + A.">inversa da matriz</abbr> . <br><br>  Como essa previs√£o √© apenas uma aproxima√ß√£o muito aproximada e n√£o leva em considera√ß√£o a influ√™ncia de objetos externos w, obviamente, n√£o ser√° poss√≠vel modelar com precis√£o os dados de treinamento.  Portanto, treinamos a rede neural Œ¶ para aproximar os efeitos residuais do modelo de acordo com a 11¬™ linha do algoritmo.  Aqui, parametrizamos uma <abbr title="Rede neural feedforward √© uma rede neural na qual um sinal se propaga estritamente da camada de entrada para a camada de sa√≠da e n√£o se propaga na dire√ß√£o oposta.">rede neural de distribui√ß√£o direta</abbr> padr√£o com 10 camadas, para cada camada (exceto a sa√≠da), usando a fun√ß√£o de ativa√ß√£o <abbr title="A fun√ß√£o de ativa√ß√£o determina o valor de sa√≠da de um neur√¥nio, dependendo do resultado de uma soma ponderada de entradas e de um valor limite. A fun√ß√£o de ativa√ß√£o ReLu retorna x se x for positivo e 0 caso contr√°rio.">ReLU</abbr> .  Excluindo as camadas de entrada e sa√≠da, definimos o n√∫mero de unidades ocultas em cada camada restante igual a um tamanho e meio dos dados do PCA, o que levou a um bom compromisso entre o espa√ßo ocupado no disco r√≠gido e o desempenho. <br><br><img src="https://habrastorage.org/webt/re/7_/ii/re7_iisbng_s83ibdfmcn32idf8.png"><br>  <i>Figura 4. Algoritmo de aprendizado de rede neural</i> <br><br><h3>  Treinamento em redes neurais </h3><br>  Uma maneira padr√£o de treinar uma rede neural seria iterar todo o conjunto de dados e treinar a rede para fazer previs√µes para cada quadro.  Obviamente, essa abordagem levar√° a um baixo erro de aprendizado, mas o feedback dessa previs√£o causar√° um comportamento inst√°vel de seu resultado.  Portanto, para garantir uma previs√£o est√°vel a longo prazo, nosso algoritmo usa o <abbr title="A propaga√ß√£o reversa de erros √© uma maneira de treinar uma rede neural. O treinamento com esse algoritmo envolve duas passagens por todas as camadas da rede: direta e reversa. Com uma passagem direta, o vetor de entrada √© alimentado para a camada de entrada da rede neural, ap√≥s o qual se propaga atrav√©s da rede de camada para camada. Como resultado, √© gerado um conjunto de sinais de sa√≠da, que √© a resposta real da rede a uma determinada imagem de entrada. Durante uma passagem direta, todos os pesos l√≠quidos sin√°pticos s√£o fixos. Durante o reverso, eles s√£o configurados de acordo com a regra de corre√ß√£o de erros: a sa√≠da real da rede √© subtra√≠da da desejada, como resultado do qual um sinal de erro √© gerado. Esse sinal se propaga posteriormente pela rede na dire√ß√£o oposta √† dire√ß√£o das conex√µes sin√°pticas. Os pesos sin√°pticos s√£o ajustados para maximizar a sa√≠da da rede para o desejado.">m√©todo de propaga√ß√£o reversa de erros em</abbr> todo o procedimento de integra√ß√£o. <br><br>  Em geral, funciona assim: a partir de uma pequena janela de dados de treinamento <i>z</i> e <i>w,</i> pegamos os dois primeiros quadros <i>z <sub>0</sub></i> e <i>z <sub>1</sub></i> e adicionamos um pouco de ru√≠do <i>r <sub>0</sub></i> , <i>r <sub>1 a eles</sub></i> , a fim de atrapalhar levemente o caminho de aprendizado.  Ent√£o, para prever os pr√≥ximos quadros, executamos o algoritmo v√°rias vezes, retornando aos resultados anteriores das previs√µes a cada nova etapa de tempo.  Assim que obtemos uma previs√£o de toda a trajet√≥ria, calculamos o erro m√©dio de coordenadas e o passamos para o otimizador AmsGrad usando as derivadas autom√°ticas calculadas usando o TensorFlow. <br><br>  Repetiremos esse algoritmo em mini-amostras de 16 quadros, usando janelas sobrepostas de 32 quadros, por 100 √©pocas ou at√© o treinamento convergir.  Utilizamos a taxa de aprendizado de 0,0001, o coeficiente de atenua√ß√£o da taxa de aprendizado de 0,999 e o desvio padr√£o de ru√≠do calculado a partir dos tr√™s primeiros componentes do espa√ßo PCA.  Esse treinamento leva de 10 a 48 horas, dependendo da complexidade da instala√ß√£o e do tamanho dos dados do PCA. <br><br><img src="https://habrastorage.org/webt/k4/fe/in/k4feinopgrygcqm6p3dkrjk1pcu.gif"><br>  <i>Figura 5. Compara√ß√£o visual da saia de refer√™ncia e da que nossa rede neural aprendeu a construir</i> <br><br><h3>  Implementa√ß√£o do sistema </h3><br>  Descreveremos em detalhes a implementa√ß√£o de nosso m√©todo em um ambiente interativo, incluindo a avalia√ß√£o de uma rede neural, o c√°lculo das normais nas superf√≠cies dos objetos para renderiza√ß√£o e como lidamos com as interse√ß√µes vis√≠veis. <br><br><h4>  Aplicativo de renderiza√ß√£o </h4><br>  Renderizamos os modelos resultantes em um aplicativo 3D interativo simples escrito em C ++ e DirectX: mais uma vez implementamos os pr√©-processos e opera√ß√µes de rede neural no c√≥digo C ++ de thread √∫nico e carregamos os pesos de rede bin√°rios obtidos durante nosso procedimento de treinamento.  Em seguida, aplicamos algumas otimiza√ß√µes simples para a estimativa da rede, em particular a reutiliza√ß√£o de buffers de mem√≥ria e dados esparsos da matriz vetorial, o que se torna poss√≠vel devido √† presen√ßa de zero unidades ocultas obtidas gra√ßas √† fun√ß√£o de ativa√ß√£o ReLU. <br><br><h4>  Descompress√£o de GPU </h4><br>  Envie dados compactados do estado z para a GPU e descompacte-os para posterior renderiza√ß√£o.  Para esse fim, usamos um sombreador computacional simples, que para cada v√©rtice do objeto calcula o produto pontual do vetor z e as tr√™s primeiras linhas da matriz UT correspondentes √†s coordenadas desse v√©rtice, ap√≥s o qual adicionamos o valor m√©dio <i>x <sub>¬µ</sub></i> .  Essa abordagem tem duas vantagens sobre o <abbr title="O m√©todo ing√™nuo √© um m√©todo probabil√≠stico simples baseado na aplica√ß√£o do teorema de Bayes com suposi√ß√µes estritas (ing√™nuas) sobre independ√™ncia. Dependendo da natureza exata do modelo probabil√≠stico, os classificadores ing√™nuos de Bayes podem ser treinados com muita efic√°cia. Em muitas aplica√ß√µes pr√°ticas, o m√©todo da m√°xima verossimilhan√ßa √© usado para estimar par√¢metros para modelos bayesianos ing√™nuos.">m√©todo de</abbr> descompress√£o <abbr title="O m√©todo ing√™nuo √© um m√©todo probabil√≠stico simples baseado na aplica√ß√£o do teorema de Bayes com suposi√ß√µes estritas (ing√™nuas) sobre independ√™ncia. Dependendo da natureza exata do modelo probabil√≠stico, os classificadores ing√™nuos de Bayes podem ser treinados com muita efic√°cia. Em muitas aplica√ß√µes pr√°ticas, o m√©todo da m√°xima verossimilhan√ßa √© usado para estimar par√¢metros para modelos bayesianos ing√™nuos.">ing√™nuo</abbr> .  Em primeiro lugar, o paralelismo da GPU acelera significativamente o c√°lculo do vetor de estado do modelo, que pode levar at√© 1 ms.  Em segundo lugar, reduz o tempo de transfer√™ncia de dados entre a central e a GPU em uma ordem de magnitude, o que √© especialmente importante para plataformas nas quais a transfer√™ncia de todo o estado de todo o objeto √© muito lenta. <br><br><h4>  Previs√£o normal de v√©rtice </h4><br>  Durante a renderiza√ß√£o, n√£o basta ter acesso apenas √†s coordenadas dos v√©rtices - tamb√©m s√£o necess√°rias informa√ß√µes sobre as deforma√ß√µes de suas normais.  Geralmente, em um mecanismo f√≠sico, omita esse c√°lculo ou execute um rec√°lculo ing√™nuo quadro a quadro de normais com sua subsequente redistribui√ß√£o para os v√©rtices vizinhos.  Isso pode se mostrar ineficiente, porque a implementa√ß√£o b√°sica do processador central, al√©m dos custos de descompress√£o e transfer√™ncia de dados, requer outros 150 Œºs para esse procedimento.  E, embora esse c√°lculo possa ser realizado na GPU, ele se torna mais dif√≠cil de implementar devido √† necessidade de opera√ß√µes paralelas. <br><br>  Em vez disso, realizamos uma regress√£o linear do estado do subespa√ßo para vetores de estado completo normais no shader da GPU.  Conhecendo os valores das normais dos v√©rtices em cada quadro, calculamos a matriz Q, que melhor representa a representa√ß√£o do subespa√ßo nas normais dos v√©rtices. <br><br>  Como a previs√£o de normais em nosso m√©todo nunca foi apresentada antes, n√£o h√° garantia de que essa abordagem seja precisa, mas na pr√°tica ela provou ser realmente boa, como pode ser visto na figura abaixo. <br><br><img src="https://habrastorage.org/webt/ex/mn/ef/exmnefvyrkox7j-mcl7brp2vyog.png"><br>  <i>Figura 6. Compara√ß√£o dos modelos calculados pelo nosso m√©todo e a refer√™ncia (verdade fundamental), bem como a diferen√ßa entre eles</i> <br><br><h4>  Luta de interse√ß√£o </h4><br>  Nossa rede neural aprende a executar colis√µes com efici√™ncia, no entanto, devido a imprecis√µes nas previs√µes e erros causados ‚Äã‚Äãpela compress√£o do subespa√ßo, podem ocorrer interse√ß√µes entre objetos externos e simulados.  Al√©m disso, como adiamos o c√°lculo do estado completo da cena at√© o in√≠cio da renderiza√ß√£o, n√£o h√° como resolver esses problemas com anteced√™ncia.  Portanto, para manter o alto desempenho, √© necess√°rio eliminar essas interse√ß√µes durante a renderiza√ß√£o. <br><br>  Encontramos uma solu√ß√£o simples e eficaz para isso, consistindo no fato de que v√©rtices que se cruzam s√£o projetados na superf√≠cie dos primitivos a partir dos quais formamos o personagem.  √â f√°cil fazer essa proje√ß√£o na GPU usando o mesmo sombreador computacional que descompacta o tecido e calcula o sombreamento normal. <br><br>  Ent√£o, em primeiro lugar, comporemos o caractere dos objetos proxy conectados aos v√©rtices com diferentes raios inicial e final, ap√≥s o qual transferiremos informa√ß√µes sobre as coordenadas e raios desses objetos para o shader computacional.  Mais uma vez, verifique as coordenadas de cada v√©rtice quanto √† interse√ß√£o com o objeto proxy correspondente e, se houver, projete esse v√©rtice na superf√≠cie do objeto proxy.  Portanto, apenas corrigimos a posi√ß√£o do v√©rtice, sem tocar no pr√≥prio normal, para n√£o danificar o sombreamento. <br><br>  Essa abordagem remover√° pequenas interse√ß√µes vis√≠veis de objetos, desde que os erros do deslocamento do v√©rtice n√£o sejam t√£o grandes que a proje√ß√£o esteja no lado oposto do objeto proxy correspondente. <br><br><img src="https://habrastorage.org/webt/ef/9q/al/ef9qal2u48v_kwy6q8pqdspe9qi.png"><br>  <i>Figura 7. Modelo de caractere composto por objetos proxy e os resultados da elimina√ß√£o de interse√ß√µes vis√≠veis usando nosso m√©todo: antes e depois</i> <br><br><h3>  An√°lise de Resultados </h3><br>  Portanto, nossas cenas de teste incluem: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um avi√£o interagindo com uma bola controlada pelo usu√°rio; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um plano esticado entre quatro pontos que o usu√°rio pode mover; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma bandeira balan√ßando ao vento; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> capa e saia em um personagem animado controlado pelo usu√°rio; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um coelho sendo atingido por uma bola controlada pelo usu√°rio; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drag√£o, sobre o qual a chaleira se move. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em todos os exemplos, nosso m√©todo define a natureza das deforma√ß√µes pr√≥ximas √† natural. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m realizamos testes de estresse do nosso m√©todo em cenas com cem coelhos e 16 caracteres, cada qual modelado de forma independente a uma taxa de quadros de 120 e 240 quadros por segundo. </font></font><br><br><img src="https://habrastorage.org/webt/m8/ls/dz/m8lsdz-6i0bgaghswhtf8luequg.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 8. Teste em 16 caracteres. </font><font style="vertical-align: inherit;">Hora da festa!</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara√ß√£o com o padr√£o </font></font></h4><br> ,       , ,        ,       . <br><br>   ,          PCA.   ,        ,             ,   . <br><br><img src="https://habrastorage.org/webt/0o/mb/js/0ombjsge3myljg4b2ieuzr0seic.png"><br> <i> 9.   ,    ,  ‚Äì </i> <br><br><h4>  </h4><br>          ‚Äï     ,     .         ,     .        300-5000      ,   .           ,   <abbr title=" -   ‚Äî       ,       (Projective Dynamics)       ."> -   (HRPD)</abbr> , <abbr title="   (Long short-term memory) ‚Äî      ,     .      ,                 .  LSTM      ,   (gates) ¬´¬ª.">   (LSTM)</abbr>  <abbr title="    ‚Äî    LSTM-.            ¬´ ¬ª (update gate).  ,       .       ,   LSTM-.">   (GRU)</abbr> . <br><br>      ,          .        Intel Xeon E5-1650 3.5 GHz    GeForce GTX 1080 Titan. <br><br> <i> 2.    </i> <br><img src="https://habrastorage.org/webt/io/ax/rw/ioaxrwaeedpn506pzo7sv857as4.png"><br><br><h3>      </h3><br> ,         ,   .      ,                  . <br><br>    data-driven ,     . ,   ,         ,           ,    ,       .  ,      ,        ‚Äï ,       . <br><br>     ,      ,         ,         . <br><br>         ,      .      data-driven ,     ‚Äï ,       .        ,   ,    ,      .        , ,            ,       . <br><br>       ,         .        . <br><br>       , , ,      .   ,   , ‚Äï    ,       . -,         ,   ,    -      .                . <br><br> ,       ,       ,     ,     .    ,     ,      ,      , ‚Äï         ,       ,     .        . <br><br>        <a href="https://www.youtube.com/watch%3Fv%3DatcKO15YVD8"></a> . <br><br><img src="https://habrastorage.org/webt/1i/hx/uf/1ihxuf4flcfzfps0xuw6sk9p8ts.gif"><br> <i> 10.  vs : choose your fighter</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479292/">https://habr.com/ru/post/pt479292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479282/index.html">Se os dados n√£o couberem na mem√≥ria. M√©todos mais simples</a></li>
<li><a href="../pt479284/index.html">A casa que o rob√¥ construiu</a></li>
<li><a href="../pt479286/index.html">Escrevendo um aplicativo Web simples usando Spring MVC, Spring Data JPA e Hibernate</a></li>
<li><a href="../pt479288/index.html">Por que implementar o Service Desk e como escolher uma solu√ß√£o para sua empresa</a></li>
<li><a href="../pt479290/index.html">Algoritmos para pesquisar o volume e o centro de massa de um poliedro</a></li>
<li><a href="../pt479294/index.html">GitLab 12.5 lan√ßado com a cria√ß√£o de clusters EKS e o painel de ambiente</a></li>
<li><a href="../pt479296/index.html">Como eu parei de odiar e me apaixonei pelo desenvolvimento</a></li>
<li><a href="../pt479298/index.html">Antipadr√µes do PostgreSQL: CTE x CTE</a></li>
<li><a href="../pt479300/index.html">Ecologia e data centers. Como na R√∫ssia e no exterior, "dados ecol√≥gicos"</a></li>
<li><a href="../pt479302/index.html">Unity Shader Graph Basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>