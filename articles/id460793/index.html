<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 👨🏿‍🔬 🌞 Penataan Aplikasi Bereaksi 🚁 🤹🏻 👨🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahan, terjemahan yang kami terbitkan hari ini, mengungkapkan pendekatan yang digunakan oleh penulisnya ketika menyusun aplikasi Bereaksi. Secara khus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penataan Aplikasi Bereaksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/460793/">  Bahan, terjemahan yang kami terbitkan hari ini, mengungkapkan pendekatan yang digunakan oleh penulisnya ketika menyusun aplikasi Bereaksi.  Secara khusus, kita akan membahas di sini struktur folder yang digunakan, penamaan entitas, tempat di mana file tes berada, dan hal-hal serupa lainnya. <br><br>  Salah satu fitur React yang paling menyenangkan adalah bahwa perpustakaan ini tidak memaksa pengembang untuk secara ketat mematuhi konvensi tertentu mengenai struktur proyek.  Banyak dari ini tetap pada kebijaksanaan programmer.  Pendekatan ini berbeda dari itu, katakanlah, diadopsi dalam kerangka Ember.js atau Angular.  Mereka memberi pengembang lebih banyak fitur standar.  Kerangka kerja ini menyediakan konvensi mengenai struktur proyek dan aturan untuk penamaan file dan komponen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/k6/9y/ug/k69yugvbt27p3wtccvzeqrf_v4w.jpeg"></a> <br><br>  Secara pribadi, saya suka pendekatan yang diadopsi oleh React.  Faktanya adalah bahwa saya lebih suka mengendalikan sesuatu sendiri, tanpa bergantung pada "perjanjian" tertentu.  Namun, ada banyak keuntungan dari pendekatan penataan proyek yang ditawarkan Angular.  Pilihan antara kebebasan dan aturan yang kurang lebih kaku bermuara pada apa yang lebih dekat dengan Anda dan tim Anda. <br><br>  Selama bertahun-tahun bekerja dengan React, saya telah mencoba berbagai cara untuk menyusun aplikasi.  Beberapa ide yang saya terapkan ternyata lebih sukses daripada yang lain.  Oleh karena itu, di sini saya akan berbicara tentang segala sesuatu yang telah menunjukkan dirinya dengan baik dalam praktik.  Saya harap Anda menemukan sesuatu di sini yang bermanfaat bagi Anda. <br><a name="habracut"></a><br>  Saya tidak mencoba menunjukkan di sini cara penataan aplikasi yang "hanya benar".  Anda dapat mengambil beberapa ide saya dan mengubahnya agar sesuai dengan kebutuhan Anda.  Anda mungkin tidak setuju dengan saya dengan terus bekerja seperti sebelumnya.  Tim yang berbeda membuat aplikasi yang berbeda dan menggunakan cara yang berbeda untuk mencapai tujuan mereka. <br><br>  Penting untuk dicatat bahwa jika Anda melihat situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thread</a> , yang saya ikuti dalam pengembangan, dan melihat perangkat antarmuka-nya, Anda akan menemukan tempat-tempat di mana aturan-aturan yang akan saya bicarakan tidak dihormati.  Faktanya adalah bahwa "aturan" dalam pemrograman harus diambil hanya sebagai rekomendasi, dan bukan sebagai standar komprehensif yang berlaku dalam situasi apa pun.  Dan jika Anda berpikir bahwa semacam "aturan" tidak cocok untuk Anda - Anda, demi meningkatkan kualitas apa yang sedang Anda kerjakan, harus menemukan kekuatan untuk menyimpang dari "aturan" ini. <br><br>  Sebenarnya, sekarang, tanpa basa-basi lagi, saya menawarkan cerita saya tentang penataan aplikasi Bereaksi. <br><br><h2>  <font color="#3AC1EF">Jangan terlalu khawatir tentang aturannya.</font> </h2><br>  Mungkin Anda memutuskan bahwa rekomendasi yang Anda tidak terlalu khawatirkan tentang aturan terlihat aneh di awal percakapan kami.  Tapi inilah yang saya maksud ketika saya mengatakan bahwa kesalahan utama yang dimiliki programmer dalam mengamati peraturan adalah bahwa programmer terlalu mementingkan aturan.  Ini terutama benar pada awal pengerjaan proyek baru.  Pada saat pembuatan <code>index.jsx</code> pertama <code>index.jsx</code> tidak mungkin untuk mengetahui apa yang terbaik untuk proyek ini.  Ketika proyek berkembang, Anda secara alami akan menemukan beberapa jenis struktur file dan folder, yang mungkin cukup baik untuk proyek ini.  Jika selama kelanjutan pekerjaan ternyata struktur yang ada agak tidak berhasil, maka bisa diperbaiki. <br><br>  Jika Anda membaca ini dan mendapati diri Anda berpikir bahwa tidak ada dalam aplikasi Anda yang sedang dibahas, maka ini bukan masalah.  Setiap aplikasi unik, tidak ada dua tim pengembangan yang benar-benar identik.  Oleh karena itu, masing-masing tim, yang mengerjakan suatu proyek, datang ke beberapa perjanjian mengenai struktur dan metode mengerjakannya.  Ini membantu anggota tim bekerja secara produktif.  Jangan berusaha keras, setelah mengetahui tentang bagaimana seseorang melakukan sesuatu, segera perkenalkan hal ini kepada diri Anda sendiri.  Jangan mencoba memperkenalkan ke dalam pekerjaan Anda apa yang disebut bahan-bahan tertentu, dan bahkan dalam hal ini, "cara paling efektif" untuk menyelesaikan masalah.  Saya selalu mematuhi dan mematuhi strategi berikut mengenai rekomendasi tersebut.  Saya memiliki seperangkat aturan sendiri, tetapi membaca tentang bagaimana orang lain bertindak dalam situasi tertentu, saya memilih apa yang menurut saya berhasil dan cocok untuk saya.  Ini mengarah pada fakta bahwa seiring waktu, metode kerja saya meningkat.  Pada saat yang sama, saya tidak memiliki kejutan dan tidak ada keinginan untuk menulis ulang semuanya dari awal. <br><br><h2>  <font color="#3AC1EF">Komponen penting terletak di folder terpisah</font> </h2><br>  Pendekatan untuk menempatkan file komponen dalam folder yang saya datangi adalah bahwa komponen yang dapat dianggap "penting", "dasar", "dasar" dalam konteks aplikasi ditempatkan di folder yang terpisah.  Folder-folder ini, pada gilirannya, terletak di folder <code>components</code> .  Misalnya, jika kita berbicara tentang aplikasi untuk toko elektronik, maka komponen <code>&lt;Product&gt;</code> digunakan untuk menggambarkan produk dapat dikenali sebagai komponen yang serupa.  Inilah yang saya maksud: <br><br><pre> <code class="plaintext hljs">- src/  - components/    - product/      - product.jsx      - product-price.jsx    - navigation/      - navigation.jsx    - checkout-flow/      - checkout-flow.jsx</code> </pre> <br>  Dalam hal ini, komponen "sekunder" yang hanya digunakan oleh komponen "utama" tertentu berada di folder yang sama dengan komponen "utama" ini.  Pendekatan ini telah terbukti dalam praktiknya.  Faktanya adalah karena penerapannya, struktur tertentu muncul dalam proyek, tetapi tingkat folder bersarang tidak terlalu besar.  Aplikasinya tidak mengarah pada tampilan seperti <code>../../../</code> dalam perintah impor komponen, tidak membuatnya sulit untuk bergerak di sekitar proyek.  Pendekatan ini memungkinkan Anda untuk membangun hierarki komponen yang jelas.  Komponen itu, yang namanya sesuai dengan nama folder, dianggap "dasar".  Komponen lain yang terletak di folder yang sama berfungsi untuk membagi komponen "pangkalan" menjadi beberapa bagian, yang menyederhanakan bekerja dengan kode komponen ini dan dukungannya. <br><br>  Meskipun saya seorang pendukung kehadiran struktur folder tertentu dalam proyek, saya percaya bahwa hal yang paling penting adalah pemilihan nama file yang baik.  Folder itu sendiri kurang penting. <br><br><h2>  <font color="#3AC1EF">Menggunakan subfolder untuk subkomponen</font> </h2><br>  Salah satu kelemahan dari pendekatan di atas adalah penggunaannya dapat menyebabkan munculnya folder komponen "dasar" yang mengandung banyak file.  Pertimbangkan, misalnya, komponen <code>&lt;Product&gt;</code> .  File CSS akan dilampirkan padanya (kami akan membicarakannya nanti), menguji file, banyak subkomponen, dan, mungkin, sumber daya lain - seperti gambar dan ikon SVG.  Daftar "tambahan" ini tidak terbatas.  Semua ini akan jatuh ke folder yang sama dengan komponen "base". <br><br>  Saya benar-benar tidak peduli tentang itu.  Ini cocok untuk saya jika file memiliki nama yang dipikirkan dengan matang, dan jika mereka dapat dengan mudah ditemukan (menggunakan alat pencarian file di editor).  Jika demikian, maka struktur folder memudar ke latar belakang.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut ini</a> tweet tentang topik ini. <br><br>  Namun, jika Anda lebih suka proyek Anda memiliki struktur yang lebih luas, tidak ada yang sulit dalam memindahkan subkomponen ke folder mereka sendiri: <br><br><pre> <code class="javascript hljs">- src/  - components/    - product/      - product.jsx      - ...      - product-price/        - product-price.jsx</code> </pre> <br><h2>  <font color="#3AC1EF">File uji terletak di tempat yang sama dengan file komponen yang diuji.</font> </h2><br>  Kami memulai bagian ini dengan rekomendasi sederhana, yaitu file uji harus ditempatkan di tempat yang sama dengan file dengan kode yang diperiksa dengan bantuan mereka.  Saya juga akan berbicara tentang bagaimana saya lebih suka menyusun komponen, berusaha memastikan bahwa mereka akan saling berdekatan.  Tetapi sekarang saya dapat mengatakan bahwa saya merasa nyaman untuk menempatkan file uji di folder yang sama dengan file komponen.  Dalam hal ini, nama-nama file dengan tes identik dengan nama-nama file dengan kode.  Untuk nama pengujian, sebelum ekstensi nama file, akhiran <code>.test</code> hanya ditambahkan: <br><br><ul><li>  Nama file komponen: <code>auth.js</code> </li><li>  Uji nama file: <code>auth.test.js</code> </li></ul><br>  Pendekatan ini memiliki beberapa kekuatan: <br><br><ul><li>  Itu membuatnya mudah untuk menemukan file uji.  Sekilas, Anda bisa mengerti jika ada tes untuk komponen yang saya kerjakan. </li><li>  Semua perintah impor yang diperlukan sangat sederhana.  Dalam pengujian, untuk mengimpor kode yang diuji, Anda tidak perlu membuat struktur yang menggambarkan, katakanlah, jalan keluar dari folder <code>__tests__</code> .  Tim seperti itu terlihat sangat sederhana.  Misalnya, seperti ini: <code>import Auth from './auth'</code> . </li></ul><br>  Jika kami memiliki beberapa data yang digunakan selama pengujian, misalnya, sesuatu seperti tiruan permintaan API, kami menempatkannya di folder yang sama di mana komponen dan pengujiannya berada.  Ketika segala sesuatu yang mungkin diperlukan terletak di satu folder, ini berkontribusi pada pertumbuhan produktivitas.  Misalnya, jika Anda menggunakan struktur folder bercabang dan pemrogram yakin bahwa ada file tertentu, tetapi tidak dapat mengingat namanya, pemrogram harus mencari file ini di banyak subdirektori.  Dengan pendekatan yang diusulkan, lihat saja isi dari satu folder dan semuanya akan menjadi jelas. <br><br><h2>  <font color="#3AC1EF">Modul CSS</font> </h2><br>  Saya penggemar berat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul CSS</a> .  Kami menemukan bahwa mereka sangat bagus untuk membuat aturan CSS modular untuk komponen. <br><br>  Selain itu, saya sangat suka teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen-gaya</a> .  Namun, dalam proses pengerjaan proyek di mana banyak pengembang berpartisipasi, ternyata kehadiran file CSS nyata dalam proyek meningkatkan kegunaan. <br><br>  Seperti yang mungkin sudah Anda duga, file CSS kami berada, seperti file lainnya, di sebelah file komponen, di folder yang sama.  Ini sangat menyederhanakan perpindahan antar file ketika Anda perlu dengan cepat memahami makna suatu kelas. <br><br>  Rekomendasi yang lebih umum, esensi yang menembus semua materi ini, adalah bahwa semua kode yang terkait dengan komponen tertentu harus disimpan dalam folder yang sama di mana komponen ini berada.  Lewat sudah hari-hari ketika folder terpisah digunakan untuk menyimpan CSS dan kode JS, kode uji dan sumber daya lainnya.  Penggunaan struktur folder yang rumit mempersulit perpindahan antar file dan tidak memiliki manfaat yang jelas, kecuali bahwa hal itu membantu "mengatur kode."  Simpan file yang saling terhubung dalam folder yang sama - ini berarti menghabiskan lebih sedikit waktu untuk berpindah antar folder selama bekerja. <br><br>  Kami bahkan membuat loader Webpack untuk CSS, kemampuan yang sesuai dengan fitur pekerjaan kami.  Ia memeriksa nama kelas yang dideklarasikan dan melempar kesalahan di konsol jika kita merujuk ke kelas yang tidak ada. <br><br><h2>  <font color="#3AC1EF">Hampir selalu, hanya satu kode komponen yang ditempatkan dalam satu file</font> </h2><br>  Pengalaman saya menunjukkan bahwa programmer biasanya terlalu ketat mematuhi aturan bahwa kode untuk satu dan hanya satu komponen Bereaksi harus dalam satu file.  Pada saat yang sama, saya sepenuhnya mendukung gagasan bahwa tidak layak menempatkan terlalu banyak komponen dalam satu file (bayangkan kesulitan menamai file seperti itu!).  Tetapi saya percaya bahwa tidak ada yang salah dengan meletakkan file yang sama di mana kode komponen "besar" berada, dan kode komponen "kecil" yang terkait dengannya.  Jika langkah seperti itu membantu menjaga kemurnian kode, jika komponen "kecil" tidak terlalu besar untuk meletakkannya di file terpisah, maka ini tidak akan membahayakan siapa pun. <br><br>  Misalnya, jika saya membuat komponen <code>&lt;Product&gt;</code> , dan saya perlu sepotong kecil kode untuk menampilkan harganya, maka saya bisa melakukan ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Price = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ price, currency }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {currency}    {formatPrice(price)}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Product = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ,      !  return (    &lt;div&gt;      &lt;Price price={props.price} currency={props.currency} /&gt;      &lt;div&gt;loads more stuff...&lt;/div&gt;    &lt;/div&gt;  ) }</span></span></code> </pre> <br>  Hal yang baik tentang pendekatan ini adalah saya tidak perlu membuat file terpisah untuk komponen <code>&lt;Price&gt;</code> , dan bahwa komponen ini tersedia secara eksklusif untuk komponen <code>&lt;Product&gt;</code> .  Kami tidak mengekspor komponen ini, sehingga tidak dapat diimpor di tempat lain dalam aplikasi.  Ini berarti bahwa ketika ditanya apakah akan meletakkan <code>&lt;Price&gt;</code> dalam file terpisah, Anda dapat memberikan jawaban yang jelas dan positif jika Anda perlu mengimpornya di tempat lain.  Jika tidak, Anda dapat melakukannya tanpa memasukkan kode <code>&lt;Price&gt;</code> ke file terpisah. <br><br><h2>  <font color="#3AC1EF">Pisahkan folder untuk komponen universal</font> </h2><br>  Kami baru-baru ini menggunakan komponen universal.  Mereka, pada kenyataannya, membentuk sistem desain kami (yang kami rencanakan untuk diterbitkan suatu hari nanti), tetapi sejauh ini kami telah memulai dari yang kecil - dengan komponen seperti <code>&lt;Button&gt;</code> dan <code>&lt;Logo&gt;</code> .  Suatu komponen dianggap “universal” jika tidak terikat pada bagian tertentu dari situs, tetapi merupakan salah satu blok bangunan dari antarmuka pengguna. <br><br>  Komponen serupa terletak di folder Anda sendiri ( <code>src/components/generic</code> ).  Ini sangat menyederhanakan pekerjaan dengan semua komponen universal.  Mereka berada di satu tempat - sangat nyaman.  Seiring waktu, seiring pertumbuhan proyek, kami berencana untuk mengembangkan panduan gaya (kami adalah penggemar besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">styleguidist reaksi</a> ) untuk lebih menyederhanakan pekerjaan dengan komponen universal. <br><br><h2>  <font color="#3AC1EF">Menggunakan Alias ​​untuk Mengimpor Entitas</font> </h2><br>  Struktur folder yang relatif datar dalam proyek kami memastikan bahwa perintah impor tidak memiliki struktur terlalu panjang seperti <code>../../</code> .  Tetapi sulit dilakukan tanpa mereka.  Oleh karena itu, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel-plugin-module-resolver</a> untuk mengkonfigurasi alias yang menyederhanakan perintah impor. <br><br>  Anda dapat melakukan hal yang sama dengan Webpack, tetapi berkat plugin Babel, perintah impor yang sama dapat berfungsi dalam pengujian. <br><br>  Kami mengonfigurasikan ini dengan sepasang alias: <br><br><pre> <code class="javascript hljs">{  <span class="hljs-attr"><span class="hljs-attr">components</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components'</span></span>,  <span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>, }</code> </pre> <br>  Yang pertama sangat sederhana.  Ini memungkinkan Anda untuk mengimpor komponen apa pun, memulai perintah dengan <code>components</code> kata.  Dalam pendekatan normal, perintah impor terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../components/product/product'</span></span></code> </pre> <br>  Sebagai gantinya, kita dapat menulisnya seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'components/product/product'</span></span></code> </pre> <br>  Kedua perintah mengimpor file yang sama.  Ini sangat nyaman, karena memungkinkan Anda untuk tidak memikirkan struktur folder. <br><br>  Alias ​​kedua sedikit lebih rumit: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>,</code> </pre> <br>  Kami menggunakan regex di sini.  Ia menemukan perintah impor yang dimulai dengan <code>generic</code> (tanda <code>^</code> di awal ekspresi memungkinkan Anda untuk hanya memilih perintah yang dimulai dengan <code>generic</code> ), dan menangkap apa yang setelah <code>generic/</code> ke dalam grup.  Setelah itu, kami menggunakan fragmen yang ditangkap ( <code>\\1</code> ) dalam konstruksi <code>./src/components/generic/\\1/\\1</code> . <br><br>  Akibatnya, kita dapat menggunakan perintah impor untuk komponen universal semacam ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'generic/button'</span></span></code> </pre> <br>  Mereka dikonversi ke perintah berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/components/generic/button/button'</span></span></code> </pre> <br>  Perintah ini, misalnya, berfungsi untuk mengimpor file JSX yang menggambarkan tombol universal.  Kami melakukan semua ini karena pendekatan ini sangat menyederhanakan impor komponen universal.  Selain itu, ini akan bermanfaat bagi kita jika kita memutuskan untuk mengubah struktur file proyek (ini, karena sistem desain kita berkembang, sangat mungkin). <br><br>  Di sini saya ingin mencatat bahwa Anda harus berhati-hati ketika bekerja dengan nama samaran.  Jika Anda hanya memiliki sedikit dari mereka, dan mereka dirancang untuk menyelesaikan masalah impor standar, maka semuanya baik-baik saja.  Tetapi jika Anda memiliki banyak dari mereka, mereka dapat membawa lebih banyak kebingungan daripada kebaikan. <br><br><h2>  <font color="#3AC1EF">Folder lib universal untuk utilitas</font> </h2><br>  Saya ingin mendapatkan kembali semua waktu yang saya habiskan untuk mencari tempat yang sempurna untuk kode yang bukan kode komponen.  Saya membagikan ini semua sesuai dengan prinsip yang berbeda, menyoroti kode utilitas, layanan, fungsi tambahan.  Semua ini memiliki banyak nama sehingga saya tidak akan menyebut semuanya.  Sekarang saya tidak mencoba mencari tahu perbedaan antara "utilitas" dan "fungsi bantu" untuk menemukan tempat yang tepat untuk file tertentu.  Sekarang saya menggunakan pendekatan yang jauh lebih sederhana dan lebih mudah dipahami: semua ini jatuh ke dalam folder <code>lib</code> tunggal. <br><br>  Dalam jangka panjang, ukuran folder ini mungkin berubah menjadi sangat besar sehingga Anda harus menyusunnya entah bagaimana, tetapi ini benar-benar normal.  Selalu lebih mudah untuk melengkapi sesuatu dengan struktur tertentu daripada menyingkirkan kesalahan penataan yang berlebihan. <br><br>  Dalam proyek Thread kami, folder <code>lib</code> berisi sekitar 100 file.  Mereka dibagi kira-kira sama menjadi file yang berisi implementasi fitur-fitur tertentu, dan menjadi file uji.  Itu tidak menyebabkan kesulitan dalam menemukan file yang diperlukan.  Berkat <code>lib/name_of_thing</code> pencari cerdas yang dibangun di sebagian besar editor, saya hampir selalu harus memasukkan sesuatu seperti <code>lib/name_of_thing</code> , dan apa yang saya butuhkan dapat ditemukan. <br><br>  Selain itu, kami memiliki alias yang menyederhanakan pengimporan dari folder <code>lib</code> , memungkinkan Anda menggunakan perintah seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> formatPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lib/format_price'</span></span></code> </pre> <br>  Jangan khawatir dengan struktur folder datar yang dapat menyebabkan banyak file disimpan dalam satu folder.  Biasanya struktur seperti itulah yang diperlukan untuk proyek tertentu. <br><br><h2>  <font color="#3AC1EF">Menyembunyikan perpustakaan pihak ketiga di belakang API asli</font> </h2><br>  Saya sangat suka sistem pemantauan bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sentry</a> .  Saya sering menggunakannya ketika mengembangkan bagian server dan aplikasi klien.  Dengan bantuannya, Anda dapat menangkap pengecualian dan menerima pemberitahuan tentang terjadinya.  Ini adalah alat yang hebat yang memungkinkan kami mengikuti masalah yang dihadapi di situs. <br><br>  Setiap kali saya menggunakan perpustakaan pihak ketiga dalam proyek saya, saya berpikir tentang cara membuatnya sehingga, jika perlu, bisa diganti semudah mungkin dengan yang lain.  Seringkali, seperti halnya dengan sistem Sentry yang sama yang kita sukai, ini tidak perlu.  Tetapi, untuk berjaga-jaga, tidak ada salahnya untuk memikirkan cara untuk menghindari menggunakan layanan tertentu atau cara mengubahnya ke sesuatu yang lain. <br><br>  Solusi terbaik untuk masalah ini adalah mengembangkan API Anda sendiri yang menyembunyikan alat orang lain.  Ini adalah sesuatu seperti membuat modul <code>lib/error-reporting.js</code> yang mengekspor fungsi <code>reportError()</code> .  Inti dari modul ini menggunakan Sentry.  Tetapi Sentry hanya diimpor langsung dalam modul ini dan tidak di tempat lain.  Ini berarti bahwa mengganti Sentry dengan alat lain akan terlihat sangat sederhana.  Untuk melakukan ini, cukup mengubah satu file di satu tempat.  Selama API publik dari file ini tetap tidak berubah, sisa proyek bahkan tidak akan tahu bahwa ketika memanggil <code>reportError()</code> , itu bukan Sentry yang digunakan, tetapi sesuatu yang lain. <br><br>  Harap perhatikan bahwa API publik modul disebut fungsi yang diekspor dan argumennya.  Mereka juga disebut antarmuka publik dari modul. <br><br><h2>  <font color="#3AC1EF">Menggunakan PropTypes (atau alat seperti TypeScript atau Flow)</font> </h2><br>  Ketika saya melakukan pemrograman, saya memikirkan tiga versi diri saya: <br><br><ul><li>  Jack dari masa lalu dan kode yang dia tulis (terkadang kode meragukan). </li><li>  Jack hari ini, dan kode yang dia tulis sekarang. </li><li>  Jack dari masa depan.  Ketika saya memikirkan masa depan ini sendiri, saya bertanya pada diri saya saat ini tentang bagaimana saya bisa menulis kode yang akan membuat hidup saya lebih mudah di masa depan. </li></ul><br>  Ini mungkin terdengar aneh, tetapi saya merasa berguna, berpikir tentang cara menulis kode, tanyakan pertanyaan berikut: "Bagaimana itu akan dirasakan dalam enam bulan?". <br><br>  Salah satu cara sederhana untuk membuat diri Anda hadir dan diri Anda lebih produktif adalah dengan menentukan jenis properti ( <code>PropTypes</code> ) yang digunakan oleh komponen.  Ini akan menghemat waktu mencari kemungkinan kesalahan ketik.  Ini akan melindungi Anda dari situasi di mana, menggunakan komponen, properti dari tipe yang salah diterapkan, atau mereka benar-benar lupa tentang transfer properti.  Dalam kasus kami, aturan <a href="">eslint-react / prop-types</a> adalah pengingat yang baik tentang perlunya menggunakan <code>PropTypes</code> . <br><br>  Jika Anda melangkah lebih jauh, disarankan untuk menggambarkan properti seakurat mungkin.  Misalnya, Anda dapat melakukan ini: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.object.isRequired</code> </pre> <br>  Tetapi akan jauh lebih baik untuk melakukan ini: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.shape({  <span class="hljs-attr"><span class="hljs-attr">id</span></span>: PropTypes.number.isRequired,  <span class="hljs-attr"><span class="hljs-attr">title</span></span>: PropTypes.string.isRequired,  <span class="hljs-comment"><span class="hljs-comment">//    }).isRequired</span></span></code> </pre> <br>  Pada contoh pertama, pemeriksaan minimum yang diperlukan dilakukan.  Pada tahap kedua, pengembang diberikan informasi yang jauh lebih bermanfaat.  Mereka akan sangat berguna, misalnya, jika seseorang lupa tentang bidang tertentu yang digunakan dalam objek. <br><br><h2>  <font color="#3AC1EF">Perpustakaan pihak ketiga hanya digunakan ketika mereka benar-benar dibutuhkan.</font> </h2><br>  Tip ini lebih relevan dari sebelumnya dengan munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React hooks</a> .  Sebagai contoh, saya terlibat dalam perubahan besar pada salah satu bagian situs Thread dan memutuskan untuk memberi perhatian khusus pada penggunaan perpustakaan pihak ketiga.  ,       ,          .   (   ),  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,      React-.      —  ,    ,   React  API Context,        . <br><br> ,  ,  Redux,    .       ,      (            ,     ). ,           ,   ,           . <br><br><h2> <font color="#3AC1EF">   </font> </h2><br>   —   ,       ,   .      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     emitter.send('user_add_to_cart') //     emitter.on('user_add_to_cart', () =&gt; {  //  -  })</span></span></code> </pre> <br>      ,            .     ,             .      ,   «   ».   ,      ,   ,    .         . «»      - ,       .  ,    ,        . <br><br>      Redux.       .     ,  .  ,     ,  <code>user_add_to_cart</code> ,   .       .  , ,       Redux,      .     ,    Redux    ,     . <br><br>  ,       ,   ,  ,     : <br><br><ul><li>  ,   , .         . </li><li>  ,  ,   .       ,    . </li><li>  ,  -  , . ,     ,    . </li></ul><br>    - ,    .    ,        ,   .      ,        ,   ,           «» . <br><br>       ,       ,  API Context  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> . <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>         ,    (, ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ).     :    ,      . <br><br> ,    ,          ,     .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mount(  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ComponentUnderTest</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mountWithAuth(ComponentUnderTest, {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>,  <span class="hljs-attr"><span class="hljs-attr">userId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, })</code> </pre> <br>       : <br><br><ul><li>     .       —     ,     ,   ,      . </li><li>      —    <code>mountWithAuth</code>       .    ,          . </li></ul><br>   ,           <code>test-utils.js</code> . ,       —   .       . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>       .     ,     , ,  ,      .         ,  ,              .        ,   :       .               .           -     ,   . <br><br>  <b>Pembaca yang budiman!</b>     React-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460793/">https://habr.com/ru/post/id460793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460777/index.html">Inilah gilirannya: mengapa Apple telah mengubah persyaratan untuk pengembang aplikasi</a></li>
<li><a href="../id460779/index.html">Debug Lanjutan</a></li>
<li><a href="../id460783/index.html">Konsensus tentang reputasi simpul. Apakah itu perlu?</a></li>
<li><a href="../id460785/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 1. Pendahuluan dan aplikasi kantor</a></li>
<li><a href="../id460789/index.html">Akhirnya, peremajaan adalah suatu hal</a></li>
<li><a href="../id460795/index.html">12 tips untuk meningkatkan kinerja aplikasi JavaScript</a></li>
<li><a href="../id460797/index.html">Pengembangan JavaScript yang Bertanggung Jawab Bagian 2</a></li>
<li><a href="../id460799/index.html">Permintaan Pembayaran API Browser Standar</a></li>
<li><a href="../id460801/index.html">27 alat VS Code yang mengagumkan untuk pengembang JavaScript modern</a></li>
<li><a href="../id460803/index.html">Membaca untuk musim panas: buku untuk teknisi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>