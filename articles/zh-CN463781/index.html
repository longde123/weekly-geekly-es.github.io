<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😜 🧑🏿‍🤝‍🧑🏾 🆑 Android体系结构中的Zen隔离组件 🌧️ 👳🏿 💢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几年前，我们在Badoo开始使用MVI方法进行Android开发。 它旨在简化复杂的代码库并避免状态错误的问题：在简单的场景中，这很容易，但是系统越复杂，以正确的形式维护它就越困难，而遗漏错误也就越容易。 

 在Badoo中，所有应用程序都是异步的-不仅是因为用户可以通过UI使用广泛的功能，还因为...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android体系结构中的Zen隔离组件</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br> 几年前，我们在Badoo开始使用MVI方法进行Android开发。 它旨在简化复杂的代码库并避免状态错误的问题：在简单的场景中，这很容易，但是系统越复杂，以正确的形式维护它就越困难，而遗漏错误也就越容易。 <br><br> 在Badoo中，所有应用程序都是异步的-不仅是因为用户可以通过UI使用广泛的功能，还因为服务器可以单向发送数据。 使用聊天模块中的旧方法，我们遇到了几个奇怪的难以重现的错误，我们不得不花费很多时间来消除它们。 <br><br> 我们伦敦办公室的同事Zsolt Kocsi（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">媒体</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter</a> ）讲述了如何使用MVI构建易于重用的独立组件，使用此方法时有哪些优点以及遇到的不利之处。 <a name="habracut"></a><br><br> 这是有关Badoo Android体系结构的系列文章中的第三篇。 链接到前两个： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于Kotlin的现代MVI体系结构</a> 。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用Kotlin构建反应组件系统</a> 。 <br></li></ol><br><h2> 请勿停留在连接不良的组件上。 </h2><br> 弱连接被认为比强连接要好。 如果仅依赖接口而不依赖特定的实现，那么替换组件将更容易，无需重写大多数代码即可更轻松地切换到其他实现，从而简化了单元测试。 <br><br> 我们通常在这里结束并说，我们已经在连接方面做了一切可能。 <br><br> 但是，这种方法不是最佳的。 假设您有一个类A，需要使用其他三个类的功能：B，C和D。即使通过接口引用它们，每个以下类的A类也会变得更加困难： <br><br><ul><li> 即使不使用它们，他也知道所有接口中的所有方法，它们的名称和返回类型； <br></li><li> 在测试A时，您需要配置更多的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模拟对象</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模拟对象</a> ）； <br></li><li> 在我们没有或不想拥有B，C和D的其他情况下，重复使用A会更加困难。 <br></li></ul><br> 当然，正是A类必须确定为此所需的最少接口集（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SOLID中的</a>接口隔离原理）。 但是，实际上，为了方便起见，我们所有人都必须处理采用不同方法的情况：我们采用实现某些功能的现有类，将其所有公共方法提取到接口中，然后在需要上述类的地方使用此接口。 也就是说，使用该接口不是根据所需的组件，而是根据其他组件可以提供的组件。 <br><br> 使用这种方法，情况会随着时间的推移而恶化。 每当我们添加新功能时，我们的类就会链接到他们需要了解的新接口的网络中。 类的数量在增加，测试变得越来越困难。 <br><br> 结果，当您需要在不同的上下文中使用它们时，几乎没有连接它们的纠结，即使通过接口，也几乎不可能移动它们。 您可以进行类比：您想使用香蕉，而香蕉却是挂在树上的猴子手中的，因此，在香蕉的负载下，您会得到整块丛林。 简而言之，传输过程要花费很多时间，很快您就会开始问自己为什么在实践中很难重用代码。 <br><br><h2> 黑匣子组件 </h2><br> 如果我们希望组件易于使用和可重用，那么我们就不需要了解两件事： <br><br><ul><li> 关于在其他地方使用它； <br></li><li> 关于与其内部实现无关的其他组件。 <br></li></ul><br> 原因很明确：如果您不了解外界，那么您将不会与外界联系。 <br><br> 我们真正想要的组件是什么： <br><br><ul><li> 定义自己的输入（输入）和输出（输出）数据； <br></li><li> 不要考虑这些数据来自何处或去向何处； <br></li><li> 它必须是自给自足的，这样我们就不必知道使用该组件的内部结构。 <br></li></ul><br> 您可以将组件视为黑匣子或集成电路。 她具有输入和输出联系人。 您焊接它们-微型电路成为它一无所知的系统的一部分。 <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br> 到目前为止，假设我们一直在谈论双向数据流：如果类A需要某些东西，它将通过接口B提取一个方法，并以该函数返回的值的形式接收结果。 <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br> 但是随后A知道了B，因此我们想避免这种情况。 <br><br> 当然，这种方案对于低级别的实现功能是有意义的。 但是，如果我们需要一个可重复使用的组件，其功能就像一个独立的黑盒子，则需要确保它对外部接口，方法名称或返回值一无所知。 <br><br><h2> 我们传递到单向性 </h2><br> 但是如果没有接口名称和方法，我们将无法调用任何东西！ 剩下的就是使用单向数据流，在其中我们只需获取输入并生成输出： <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br> 首先，这看起来像是一个限制，但是这种解决方案具有许多优点，下面将对此进行讨论。 <br><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一篇文章中</a>我们就知道特征（Feature）定义了它们自己的输入数据（Wish）和它们自己的输出数据（State）。 因此，对于他们来说，愿望来自何处或国家何处都无关紧要。 <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br> 那就是我们所需要的！ 可以在可以输入特征的任何地方使用这些特征，并且可以使用输出进行任何所需的操作。 而且，由于功能不能直接与其他组件通信，因此它们是独立的，不相关的模块。 <br><br> 现在，采用View并对其进行设计，使其成为一个独立的模块。 <br><br> 首先，视图应尽可能简单，以便仅处理其内部任务。 <br><br> 什么样的任务？ 其中有两个： <br><br><ul><li> 渲染ViewModel（输入）; <br></li><li> 根据用户操作（输出）触发ViewEvents。 <br></li></ul><br> 为什么要使用ViewModel？ 为什么不直接绘制特征状态？ <br><br><ul><li>  （非）在屏幕上显示功能不是实现的一部分。 如果数据来自多个来源，则View应该能够呈现自身。 <br></li><li> 无需在视图中反映状态的复杂性  ViewModel应该仅包含保持简单所需的现成信息。 <br></li></ul><br> 此外，View对以下各项不应该感兴趣： <br><br><ul><li> 所有这些ViewModel来自何处； <br></li><li> 触发ViewEvent时会发生什么； <br></li><li> 任何业务逻辑； <br></li><li> 分析跟踪 <br></li><li> 日记 <br></li><li> 其他任务。 <br></li></ul><br> 所有这些都是外部任务，View不应与其连接。 让我们停止并总结一下View的简单性： <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Android实现应： <br><br><ol><li> 通过ID查找Android视图。 <br></li><li> 通过设置ViewModel的值来实现使用者接口的accept方法。 <br></li><li> 设置侦听器（ClickListeners）以与UI交互以生成特定事件。 <br></li></ol><br> 一个例子： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br> 如果不限于功能和视图，则此方法将使其他组件看起来像这样： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br> 现在一切都变得清晰了！ <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2> 团结，团结，团结！ </h2><br> 但是，如果我们有不同的组件，并且每个组件都有自己的输入和输出，该怎么办？ 我们将连接它们！ <br><br> 幸运的是，这可以使用Binder轻松完成，这也有助于创建正确的范围，正如我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二篇文章中</a>了解到的： <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2> 第一个优势：无需修改即可轻松扩展 </h2><br> 使用仅暂时连接的黑盒形式的无关组件使我们能够添加新功能，而无需修改现有组件。 <br><br> 举一个简单的例子： <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br> 在这里，要素（F）和视图（V）相互简单连接。 <br><br> 相应的绑定将是： <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br> 假设我们要向该系统添加一些UI事件的跟踪。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br> 好消息是，我们可以简单地通过重新使用现有的输出视图通道来做到这一点： <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br> 在代码中，它看起来像这样： <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br> 只需一行附加绑定即可添加新功能。 现在，我们不仅不能更改一行代码视图，而且甚至不知道输出用于解决新问题。 <br><br> 显然，现在，我们可以轻松避免其他麻烦和不必要的复杂组件。 它们保持简单。 您只需将组件连接到现有组件即可向系统添加功能。 <br><br><h2> 第二个优点：易于反复使用 </h2><br> 使用功能和视图的示例，可以清楚地看到，我们可以添加新的输入源或输出数据的使用者，只需一行就可以绑定。 这极大地促进了在应用程序不同部分中组件的重用。 <br><br> 但是，这种方法不限于类。 这种使用界面的方式使我们能够描述任何大小的独立反应组件。 <br><br> 通过将自己限制在某些输入和输出数据上，我们无需了解所有组件的工作原理，因此，我们很容易避免意外地将组件内部与系统的其他部分链接。 而且，无需绑定，您可以轻松，简单地重复使用组件。 <br><br> 我们将在以下文章之一中返回到这一点，并考虑使用此技术连接高层组件的示例。 <br><br><h2> 第一个问题：将绑定放在哪里？ </h2><br><ol><li> 选择抽象级别。 根据架构的不同，它可能是一个Activity，一个片段或某些ViewController。 我希望您在没有UI的那些部分中仍然具有某种程度的抽象。 例如，在DI上下文树的某些范围内。 <br></li><li> 在与UI的此部分相同的级别上为绑定创建一个单独的类。 如果是FooActivity，FooFragment或FooViewController，则可以在其旁边放置FooBindings。 <br></li><li> 确保在活动，片段等中使用的相同组件实例中嵌入FooBindings。 <br></li><li> 要形成绑定的范围，请使用“活动”或“片段”生命周期。 如果此循环不依赖于Android，则可以手动创建触发器，例如，在创建或销毁DI范围时。 范围的其他示例在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二篇文章中介绍</a> 。 <br></li></ol><br><h3> 第二个问题：测试 </h3><br> 由于我们的组件对别人一无所知，因此通常不需要存根。 简化了测试，以验证组件对输入数据的正确响应并产生预期结果。 <br><br> 对于功能，这意味着： <br><br><ul><li> 测试某些输入数据是否生成预期状态（输出）的能力。 <br></li></ul><br> 而对于View： <br><br><ul><li> 我们可以测试特定的ViewModel（输入）是否导致UI的预期状态； <br></li><li> 我们可以测试与UI交互的模拟是否导致预期的ViewEvent（输出）中的初始化。 <br></li></ul><br> 当然，组件之间的交互不会神奇地消失。 我们只是从组件本身提取了这些任务。 他们仍然需要测试。 但是呢 <br><br> 在我们的案例中，绑定器负责连接组件： <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br> 我们的测试应确认以下内容： <br><br>  1.变形金刚（映射器）。 <br><br> 某些连接具有映射器，您需要确保它们正确转换了元素。 在大多数情况下，一个简单的单元测试就足够了，因为映射器通常也很简单： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2.沟通。 <br><br> 您需要确保正确配置连接。 如果由于某种原因未建立它们之间的联系，那么各个组件和映射器的工作意义何在？ 通过使用存根，初始化源以及检查客户端是否收到了预期的结果来设置绑定环境，可以测试所有这些： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br> 而且尽管尽管测试时您将不得不编写与其他方法相同数量的代码，但是自足的组件使测试各个部分变得更加容易，因为任务是明确分开的。 <br><br><h2> 思考的食物 </h2><br> 尽管以黑匣子图的形式描述我们的系统对于一般理解是有益的，但这仅在系统的大小相对较小的情况下才有效。 <br><br> 五到八条装订线是可以接受的。 但是，如果连接更多，将很难理解正在发生的事情： <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br> 我们面对这样一个事实，即随着链接数量的增加（甚至比所提供的代码片段更多），情况变得更加复杂。 原因不仅在于行数-可以为不同的方法对某种绑定进行分组和提取-而且还因为使所有内容保持可见变得越来越困难。 这总是一个不好的迹象。 如果许多不同的组件位于同一级别，则无法想象所有可能的交互。 <br><br> 原因是使用组件-黑匣子还是其他？ <br><br> 显然，如果您要描述的范围最初很复杂，那么除非您将系统分成较小的部分，否则没有方法可以使您摆脱上述问题。 即使没有大量的绑定，它也将变得很复杂，但不会那么明显。 另外，如果复杂性被明确表示而不是隐藏起来，那就更好了。 最好能看到越来越多的单行连接列表，这些列表使您想起有多少个独立组件，而不是不知道隐藏在不同方法调用中的类中的那些链接。 <br><br> 由于组件本身很简单（它们是黑匣子，并且没有其他处理程序流入其中），所以将它们分开更容易，这意味着这是朝着正确方向迈出的一步。 我们将难度移至一个位置-绑定列表，一目了然，可让您评估总体情况并开始考虑如何摆脱困境。 <br><br> 寻找解决方案花费了我们很多时间，并且仍在进行中。 我们计划在以下文章中讨论如何解决此问题。 保持联系！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463781/">https://habr.com/ru/post/zh-CN463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463769/index.html">Mitap Netologii“数据科学职业：从初学者到中级”</a></li>
<li><a href="../zh-CN463771/index.html">[Peter]与Sebastian Dashner会面JUG.ru-使编写企业测试更加愉快</a></li>
<li><a href="../zh-CN463773/index.html">保护儿童免受信息侵害的方式是如何安排的-以及关于它最初来自何处的迷人故事（18岁以上）</a></li>
<li><a href="../zh-CN463775/index.html">谁使用SAML 2.0身份验证协议</a></li>
<li><a href="../zh-CN463777/index.html">Powershell主机可用性监视</a></li>
<li><a href="../zh-CN463785/index.html">终端仿真器概述</a></li>
<li><a href="../zh-CN463787/index.html">惠普的大惊喜</a></li>
<li><a href="../zh-CN463789/index.html">Swift中泛型的力量。 第二部分</a></li>
<li><a href="../zh-CN463791/index.html">铁抓地力：取决于几何形状和表面纹理的鸟类着陆运动学</a></li>
<li><a href="../zh-CN463795/index.html">英语中的含义阴影：如何使用动词“建议”，“推荐”，“建议”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>