<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜñ üë®üèæ‚Äçüéì üê´ NewSQL: SQL no va a ninguna parte üë®üèΩ‚Äçü§ù‚Äçüë®üèº üë®üèº‚ÄçüöÄ üë©‚Äç‚ù§Ô∏è‚Äçüë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tendencia NoSQL tiene casi 10 a√±os y puede sacar conclusiones y generalizaciones de forma segura. Haremos esto y hablaremos sobre el desarrollo de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL: SQL no va a ninguna parte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/413557/"> La tendencia NoSQL tiene casi 10 a√±os y puede sacar conclusiones y generalizaciones de forma segura.  Haremos esto y hablaremos sobre el desarrollo de NoSQL. <br><br>  Recordemos c√≥mo naci√≥ NoSQL.  Veamos qu√© es bueno y qu√© es malo, y qu√© ha resistido la prueba del tiempo.  Analicemos las caracter√≠sticas que ya est√°n en SQL y que ahora aparecen en NoSQL DBMS.  Destacamos los valores √∫nicos de NoSQL y miramos un poco m√°s adelante lo que suceder√° en el mercado ma√±ana. <br><br>  Y Konstantin Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@kostja</a> ), el desarrollador y arquitecto del DBMS Tarantool, que habl√≥ sobre las tendencias de NewSQL en su informe en RIT ++ 2017, nos ayudar√° con esto, porque se supone que el arquitecto debe entender lo que est√° sucediendo en el mundo de la base de datos para que al menos reinventar la rueda. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_8OZcgOKUyk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Sobre el orador</b> : Ahora Konstantin Osipov est√° trabajando en Tarantool, pero anteriormente particip√≥ en el desarrollo de MySQL, y cuando Konstantin comenz√≥ a trabajar en una nueva base de datos, estaba muy confundido sobre por qu√© esto deber√≠a hacerse, por qu√© se necesitaba la siguiente base de datos.  En particular, la actitud hacia NoSQL era muy esc√©ptica, en cuanto a "under-SQL". <br><br>  Sin embargo, el desarrollo contin√∫a, algunos de los principios originales se extinguen y, al mismo tiempo, las bases de datos NoSQL toman las capacidades del SQL cl√°sico.  En base a los resultados de estos varios a√±os de r√°pida transformaci√≥n, es muy posible extraer resultados intermedios y permitirse hacer varias predicciones para el futuro. <br><a name="habracut"></a><br><h2>  Plan <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Antecedentes</a>  Recordemos c√≥mo naci√≥ NoSQL, qu√© es bueno y qu√© es malo en √©l. <br></li><li>  Veamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qu√© de NoSQL ha resistido la prueba del tiempo</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NoSQL SQL</a> : N1QL y CQL.  Analicemos las caracter√≠sticas que ya est√°n en SQL y que ahora aparecen en NoSQL DBMS. <br></li><li>  NoSQL ya est√° muerto, y NewSQL a√∫n no ha nacido: qu√© tan c√°lido, tube SQL difiere de SQL en NoSQL. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Valores √∫nicos de NoSQL</a> .  Veremos qu√© bien sucedi√≥ en 10 a√±os de esfuerzo y qu√© suceder√° despu√©s. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bases de datos multimodelo y NewSQL</a> .  Veamos un poco m√°s adelante lo que estar√° en el mercado ma√±ana. <br></li></ul><br><h2><a name="NoSQL_tenets"></a>  Principios NoSQL <br></h2><br>  Muchas personas est√°n tratando de apegarse al t√©rmino NoSQL ahora, pero fue ampliamente adoptado en 2009 cuando apareci√≥ el hashtag <strong>#nosql</strong> .  El desarrollador de Last.FM invent√≥ esta etiqueta para las bases de datos distribuidas mitap. <br><br>  Despu√©s de eso, la etiqueta comenz√≥ a ganar popularidad en Twitter, y NoSQL se convirti√≥ en un tanque de drenaje o embudo para la frustraci√≥n, como lo llamo, frustraci√≥n que se ha acumulado durante muchos a√±os de trabajo con bases de datos tradicionales. <br><br><blockquote>  NoSQL es una salida a la frustraci√≥n, una etiqueta que todos los que no han tenido suficientes caracter√≠sticas SQL se han apropiado para s√≠ mismos. <br></blockquote><br>  Esta frustraci√≥n necesita ser estructurada y determinada de alguna manera que a la mayor√≠a de las personas no les gusta en los DBMS tradicionales.  Podemos distinguir 3 grandes bloques de tareas para cuya soluci√≥n se cre√≥ NoSQL: <br><br><ul><li>  <strong>escala horizontal;</strong> <br></li><li>  <strong>nuevos modelos de datos;</strong> <br></li><li>  <strong>Nuevos modelos de consistencia.</strong> <br></li></ul><br>  Veamos qu√© son estos bloques.  Tomemos, por ejemplo, bases de datos de valores clave.  La idea principal del modelo de datos de valor clave es que la base de datos es simple, pero es escalable.  El desarrollador tiene una gran cantidad de problemas, pero tiene una garant√≠a estricta de que su base de datos ser√° <strong>infinitamente escalable</strong> .  Pero la escalabilidad infinita no es m√°gica.  Las garant√≠as de escalabilidad se logran debido a la <strong>sem√°ntica extremadamente simple de las</strong> operaciones admitidas: en una base de datos de valores clave, cualquier operaci√≥n afecta estrictamente a un nodo del cl√∫ster. <br><br>  Inicialmente, fue muy dif√≠cil para la comunidad separar los modelos de datos de los modelos a escala.  Si nos fijamos en el mismo Cassandra, en las primeras versiones su modelo de datos se llamaba Wide Column Store, una base de datos de columnas anchas.  Si hay un √≠ndice en el valor clave del DBMS, por clave, en el almac√©n de columnas anchas siempre se crean autom√°ticamente dos √≠ndices: por clave y por familia de columnas. <br><br>  Adem√°s, el √≠ndice por clave es compartible y el √≠ndice por Column Family es local para un nodo de datos espec√≠fico.  Debido a esto, logramos una escala horizontal, pero al mismo tiempo tuvimos la oportunidad de realizar consultas locales en la familia de columnas.  Los veteranos recuerdan que se implement√≥ una caracter√≠stica similar en Oracle, mientras se manten√≠a el modelo relacional, y se llamaba tabla unida.  Esta caracter√≠stica hizo posible especificar la ubicaci√≥n f√≠sica de las dos tablas en el formulario unido.  Amplia tienda de columnas en Cassandra: implementa una tabla unida con distribuci√≥n autom√°tica en todo el cl√∫ster. <br><br><blockquote>  La fusi√≥n del modelo de datos y el modelo a escala es exactamente el problema que se resolvi√≥ utilizando el modelo relacional.  Bienvenido a los a√±os 70. </blockquote><br>  Adem√°s de los nuevos modelos de datos, NoSQL ha implementado nuevos modelos de consistencia.  S√≠, s√≠, de nuevo este famoso <strong>teorema CAP</strong> .  Hablar sobre el teorema de CAP me divierte todo el tiempo, ¬øqui√©n lo necesita?  Como no hay esturi√≥n de la segunda frescura, tampoco hay otras respuestas a la pregunta sobre la consistencia de los datos, excepto una: <strong>la base de datos debe garantizar esta consistencia</strong> .  Por lo tanto, los nuevos modelos de consistencia tambi√©n son, en mi opini√≥n, una tendencia a la muerte. <br><br><h2><a name="NoSQL_today"></a>  NoSQL hoy <br></h2><br>  La tesis que quiero expresar en primer lugar es la de todo el movimiento NoSQL sobrevivido: <br><br><ul><li>  escala horizontal; </li><li>  <s>nuevos modelos de datos modelos de</s> documentos y gr√°ficos de datos; </li><li>  <s>Nuevos modelos de consistencia.</s> </li></ul><br>  De las tesis sobre nuevos modelos de datos, casi uno y medio sobrevivieron y la tesis sobre modelos de consistencia muri√≥ por completo. <br><br><h2>  Gorro de muerte <br></h2><br>  ¬øPor qu√© no sobrevivieron algunos modelos de consistencia? <br><br>  ‚óè <strong>Consistencia eventual: inflaci√≥n a plazo</strong> <br>  ¬øQui√©n usa una base de datos que tiene un reloj vectorial en funcionamiento y la l√≥gica de negocios de la aplicaci√≥n est√° orientada a esto?  - nadie  ¬øQui√©n usa las bases de datos que tienen CRDT (tipos de datos replicados sin conflicto)?  ¬øQui√©n est√° usando Riak?  - nadie  ¬øQu√© usa la gente?  M√°s a menudo PostgreSQL, menos a menudo otras bases, por ejemplo, MongoDB. <br><br>  ‚óè <strong>MongoDB: atomic se reemplaza por aislado, las transacciones se agregan en 3.xx</strong> <br>  Esta base de datos tiene replicaci√≥n asincr√≥nica.  Esto es algo muy f√°cil de entender, aunque, de hecho, <strong>hay 4 tipos de replicaci√≥n asincr√≥nica</strong> .  La replicaci√≥n de los datos de la transacci√≥n puede ocurrir despu√©s de que una transacci√≥n se confirma localmente;  antes de que la transacci√≥n se confirme localmente. <br><br>  Es decir, el punto de confirmaci√≥n de la base de datos principal tambi√©n se puede correlacionar con el punto de confirmaci√≥n de la r√©plica de diferentes maneras. <br><br>  Ya se ha realizado una entrada en el registro local, pero a√∫n no ha volado a la r√©plica.  Suponga que quiere esperar a que al menos se vaya volando a una r√©plica.  Volado - no significa volado.  Llegado: esto no significa que se haya escrito en el diario local en la r√©plica. <br><br>  Inicialmente, MongoDB ten√≠a un modo: la solicitud llega al servidor, la base de datos respondi√≥ OK, ni siquiera ha llegado al disco, ni al libro de registro, no fue a ning√∫n lado.  Debido a esto, todo funciona muy r√°pido, pero luego comenzaron a criticar a MongoDB por esto y, por defecto, en versiones posteriores 3+, despu√©s de todo, primero comenz√≥ a escribir la transacci√≥n en el registro, y solo despu√©s de eso envi√≥ una confirmaci√≥n al cliente. <br><br>  Es decir, incluso la replicaci√≥n asincr√≥nica es un abismo de modelos sem√°nticos.  Por lo tanto, los <strong>modelos de consistencia son demasiado complicados para que un amplio c√≠rculo de desarrolladores los entiendan, y las transacciones y la replicaci√≥n sincr√≥nica est√°n reemplazando la variedad de modelos ex√≥ticos</strong> . <br><br>  En el contexto de la muerte del modelo de consistencia, todav√≠a hay una tendencia interesante en el desarrollo de una consistencia realmente m√°s estricta.  Hay transacciones en Redis, aunque no las llamar√≠a transacciones, pero a expensas de lo que es una transacci√≥n real, existe controversia sin ella. <br><br>  Veamos el historial de transacciones en NoSQL.  Inicialmente, MongoDB implement√≥ la atomicidad a nivel de documento.  Luego, se agreg√≥ un modo de ejecuci√≥n aislado para permitir a los desarrolladores, si realmente lo desean, actualizar varios documentos at√≥micamente. <br><br>  ‚óè <strong>transacciones Redis</strong> <br>  En los albores de NoSQL, se le ofreci√≥ al desarrollador poner todo el caso de negocios en un documento de canasta.  Aparece un flujo completo llamado dise√±o impulsado por dominio, que eleva esta perversi√≥n al rango de patr√≥n de dise√±o.  De hecho, si todo se almacena en un documento, la atomicidad se logra simplemente: realiz√≥ una transacci√≥n, un proceso de negocio y tiene un cambio at√≥mico en un documento. <br><br>  Pero resulta que esto no funciona.  Los datos deben normalizarse para evitar la redundancia de almacenamiento.  Deben normalizarse para consultas anal√≠ticas.  Al final, el modelo de datos est√° evolucionando, y el documento que ayer podr√≠a guardar toda la informaci√≥n necesaria para un escenario empresarial de hoy necesita ser ampliado y complementado. <br><br>  ¬øSe demuestran los problemas de atomicidad?  cu√°n estrechamente relacionados est√°n los modelos de datos con los modelos de consistencia: el advenimiento de las transacciones y la replicaci√≥n sincr√≥nica hace que la mayor√≠a de los modelos en NoSQL sean innecesarios. <br><br><h2>  Modelos de datos <br></h2><br>  Ahora hablemos de la pr√≥xima historia: la historia con modelos de datos. <br><br>  Grupos de modelos de datos inventados despu√©s de SQL: <br><br><ul><li>  Valor clave <br></li><li>  Documental <br></li><li>  Amplia tienda de columnas; <br></li><li>  Servidor de estructura de datos (para Redis); <br></li><li>  Graficar bases de datos. <br></li></ul><br>  Genial!  ¬°Tenemos tantos modelos de datos!  ¬øY qu√© tan bien escalan? <br><br>  Esta es una tesis, relacionada principalmente con la llamada hiperconvergencia, cuando todos los proyectos modernos usan servidores de un solo servidor y las empresas dejan de comprar m√°quinas escalables verticalmente. <br><br>  La hiperconvergencia ha llegado a nuestras vidas tan a fondo que hoy en d√≠a, incluso dentro de las m√°quinas con escala vertical, si hay alguna, ya existe un software escalable horizontalmente: observe c√≥mo funciona PureStorage o, si lo recuerda, de noche, Nutanix.  Por supuesto, venden gabinetes a personas, pero estos gabinetes est√°n dispuestos en el interior como bastidores ordinarios en un proveedor de alojamiento. <br><br>  Es decir, la escala horizontal es una tendencia que ejerce presi√≥n sobre todos, incluidos los inventores de nuevos modelos de datos.  Entonces, ¬øqu√© modelos de datos son buenos para el escalado horizontal y cu√°les son malos? <br><br>  ¬øEs bueno o malo para el escalado horizontal?  La respuesta, de hecho, es bastante controvertida, volveremos a ella m√°s tarde. <br><br><h3>  Redis <br></h3><br>  Cuando Redis agreg√≥ el cl√∫ster de Redis, result√≥ que no todas las operaciones del modelo de datos se escalan normalmente horizontalmente. <br><br><img src="https://habrastorage.org/webt/e9/j_/lu/e9j_lugugsuorakmg8o8qonvqmi.jpeg"><br><br>  Esta es una cita de la documentaci√≥n donde escriben que algo funciona para ellos en un fragmento en particular, y algo realmente funciona como en un cl√∫ster real. <br><br>  El problema fundamental de este enfoque es el mismo que en MySQL, que recogimos y nos dimos la mano.  Es decir, el desarrollador tiene dos modelos de datos: <br><br><ol><li>  En uno, piensa en el marco del √°lgebra relacional. <br></li><li>  Luego, cuando piensa en el fragmentaci√≥n independiente, piensa en el modelo de datos del √°lgebra relacional de fragmentos. <br></li></ol><br>  <strong>Un buen modelo de datos debe ser universal</strong> .  Lo hermoso del √°lgebra relacional: el resultado de una proyecci√≥n es una relaci√≥n, el resultado de cualquier operador es una relaci√≥n.  Y tan pronto como comenzamos a fragmentar MySQL manualmente en el cl√∫ster, perdemos eso. <br><br>  Sin embargo, Redis agrega un cl√∫ster de Redis porque <strong>todos quieren escalar horizontalmente</strong> . <br><br><h3>  Graficar bases de datos <br></h3><br>  Las bases de datos de gr√°ficos son un buen ejemplo que ayuda a <strong>separar los conceptos de escala horizontal de la inform√°tica y el almacenamiento</strong> .  La informaci√≥n siempre se puede dividir por cualquier n√∫mero de nodos.  Pero si la base de datos est√° dise√±ada por su naturaleza para procesar los datos que almacena, y estos c√°lculos no se escalan horizontalmente, entonces surge el problema del almacenamiento horizontal efectivo que permite que los c√°lculos funcionen. <br><br>  Veamos el problema de los DBMS de gr√°ficos de escala: los DBMS de SQL enfrentan barreras de escala muy similares. <br><br><img src="https://habrastorage.org/webt/pc/yp/mm/pcypmmbjtpdrzvgb4yqhwqd5f4g.jpeg"><br><br>  Tome la base de datos local en la que se almacena el gr√°fico.  Tarde o temprano, un nodo se llena y comenzamos a usar otros nodos.  Tan pronto como usamos m√°s de un nodo, el nodo central se sobrecarga, ya que se pierde la localidad de las solicitudes.  Algunas consultas en el gr√°fico se ven obligadas a ir a lo largo de varios nodos f√≠sicos, es decir, aparecen retrasos en la red. <br><br>  Supongamos que hicimos algo diferente: tomaron y rompieron todo con una buena funci√≥n de fragmentaci√≥n.  Calculamos un cierto hash, distribuyendo aleatoriamente todos los datos en nuestro cl√∫ster de manera bastante aleatoria, y tenemos otro problema. <br><br><img src="https://habrastorage.org/webt/g_/sh/z5/g_shz5c2avjc9vhwhtyfqmrwgbi.jpeg"><br><br>  Si en el esquema anterior al menos algunas consultas funcionaron bien, entonces el <strong>100% de las consultas son est√∫pidas aqu√≠</strong> , porque la mayor√≠a de las consultas de la base de datos est√°n conectadas con el <strong>recorrido del</strong> gr√°fico.  Cualquier desv√≠o desde el nodo debe ir a alg√∫n lado, y la mayor√≠a de las veces, para calcular la solicitud, debe ir a otro nodo. <br><br><img src="https://habrastorage.org/webt/hm/sg/hp/hmsghpnyj_w7yzi80oyuc6ecf3s.jpeg"><br><br>  La idea surge como un fragmento aproximadamente, como se muestra en el diagrama anterior: encuentre grupos y col√≥quelos en sus nodos: los subconjuntos estrechamente conectados se colocan juntos, los subconjuntos d√©bilmente conectados est√°n espaciados. <br><br>  Esta es una opci√≥n ideal, pero la <strong>opci√≥n ideal solo existe en teor√≠a</strong> .  Los datos en vivo no se prestan a particiones est√°ticas.  Para implementar este enfoque, debemos detectar autom√°ticamente los cl√∫steres en un conjunto que cambia din√°micamente, mover nodos constantemente dependiendo de los enlaces emergentes y desaparecidos. <br><br>  Por lo tanto, Neo4j en general ahora se escala como bases de datos SQL cl√°sicas.  Han estado trabajando en fragmentar durante bastante tiempo, tratando de resolver los problemas descritos. <br><br>  La tesis que expuse es que el <strong>escalado horizontal</strong> ejerce <strong>presi√≥n sobre todos</strong> , y que tarde o temprano todos los modelos de datos se ver√°n obligados a implementarlo.  Pero algunos modelos permanecer√°n con nosotros, mientras que otros no. <br><br>  Entonces, por ejemplo, si consideramos las bases de datos Key-Value y Document en forma pura, entonces mi afirmaci√≥n es que no lo ser√°n.  Si observa las bases de datos de gr√°ficos, ya ocupan un segmento significativo, pero est√°n bajo la presi√≥n de la escala horizontal. <br><br>  ¬øDesaparecer√°n las bases de datos de gr√°ficos?  Es m√°s probable que las <strong>columnas, como los documentos, se incluyan en todos los productos</strong> .  Esta tendencia se denomina bases de datos multimodelos, y m√°s adelante en el informe dar√© un ejemplo de c√≥mo esto puede funcionar en la pr√°ctica.  Pero por ahora, como otra ilustraci√≥n de la tendencia de las bases de datos multimodelos, veamos JSON. <br><br><h3>  Json <br></h3><br>  A continuaci√≥n se muestra un ejemplo de c√≥mo funciona una tendencia que se est√° volviendo global. <br><br><blockquote>  Sostengo que cualquier base de datos que sea capaz de admitir JSON de alguna manera admitir√° JSON. </blockquote><br>  Quiz√°s algunas bases de datos para la computaci√≥n matricial no admitan JSON.  Pero lo m√°s probable all√≠ ser√° √∫til.  Y todo lo dem√°s definitivamente lo ser√°. <br><br><table border="1"><tbody><tr><td width="141"></td><td width="94">  MySQL <br></td><td width="95">  PostgreSQL <br></td><td width="66">  Redis <br></td><td width="85">  Couchbase <br></td><td width="85">  Cassandra <br></td><td width="56">  Neo4j <br></td></tr><tr><td width="141">  Almacenamiento JSON <br></td><td width="94">  Si <br></td><td width="95">  Si <br></td><td width="66">  Si <br></td><td width="85">  Si <br></td><td width="85">  Si <br></td><td width="56">  Si! <br></td></tr><tr><td width="141">  Operaciones de campo JSON <br></td><td width="94">  Si <br></td><td width="95">  Si <br></td><td width="66">  Si <br></td><td width="85">  Si <br></td><td width="85">  No <br></td><td width="56">  No <br></td></tr><tr><td width="141">  Consulta Json <br></td><td width="94">  Si <br></td><td width="95">  Si <br></td><td width="66">  No <br></td><td width="85">  Si <br></td><td width="85">  Si <br></td><td width="56">  No <br></td></tr><tr><td width="141">  √çndice secundario JSON <br></td><td width="94">  Si <br></td><td width="95">  Si <br></td><td width="66">  No <br></td><td width="85">  Si <br></td><td width="85">  No <br></td><td width="56">  No <br></td></tr></tbody></table><br>  Esta tabla le permite ver visualmente lo que sucede con los modelos de datos.  Las bases de datos relacionales en su soporte para JSON est√°n incluso por delante de las no relacionales de la misma Cassandra.  No tiene claves secundarias para los campos JSON.  E incluso las bases de datos de gr√°ficos tambi√©n est√°n comenzando a incluir JSON, porque <strong>todos necesitan JSON</strong> . <br><br>  Por lo tanto, las bases de datos multimodelos, y en particular JSON como el tipo de datos que se encuentra en casi todos los productos, es lo que quedar√° de NoSQL de manera seria y permanente. <br><br>  <strong>Pero si todas las bases de datos admiten JSON, ¬øpor qu√© necesita bases de datos NoSQL?</strong> <br><br>  Solo queda una historia: escala horizontal.  Queremos escalar horizontalmente, y es por eso que usamos algo diferente a MySQL o PostgreSQL. <br><br><img src="https://habrastorage.org/webt/qp/rj/up/qprjupel17nogdvuzw2eal03hw4.jpeg"><br><br>  Esta es la nota clave de Thomas Ulin, vicepresidente de ingenier√≠a de MySQL en Oracle, que habla sobre el futuro de MySQL.  Lo mismo sucede en la comunidad de Postgres y otros productos relacionales.  La presi√≥n del escalado horizontal afecta al 100% de los productos debido a la transici√≥n a la hiperconvergencia y la computaci√≥n en la nube. <br><br>  Thomas dice que su visi√≥n es un producto con alta disponibilidad y escalabilidad fuera de la caja.  Estamos hablando de alta disponibilidad principalmente InnoDB Cluster, esto es replicaci√≥n grupal + InnoDB.  Tal base de datos nunca muere, incluso si es golpeada con un martillo. <br><br>  Luego, Thomas escribe " <strong>caracter√≠sticas de escala integradas</strong> " - "hemos preparado todas estas caracter√≠sticas".  El punto es que a trav√©s de las versiones x (creo que x = 2, 3) recibir√°n MySQL Cluster en su forma pura, que admitir√° SQL en el cl√∫ster, almacenamiento JSON en el cl√∫ster. <br><br>  Hoy, <strong>MySQL tiene un protocolo X que es muy similar a MongoDB</strong> y est√° dise√±ado para funcionar con JSON. <br><br><h2><a name="SQL_NoSQL"></a>  SQL en NoSQL <br></h2><br>  Ahora veamos el movimiento desde el otro lado.  Para declarar la muerte, debe observar no solo c√≥mo SQL adopta los principios de NoSQL, sino tambi√©n viceversa. <br><br><table border="1"><tbody><tr><td width="125"></td><td width="125">  Mongodb <br></td><td width="125">  Couchbase <br></td><td width="125">  Cassandra <br></td><td width="125">  Redis <br></td></tr><tr><td width="125">  Esquema de datos <br></td><td width="125">  S√≠ * <br></td><td width="125">  No <br></td><td width="125">  Si <br></td><td width="125">  No <br></td></tr><tr><td width="125">  NULL / valores ausentes <br></td><td width="125">  S√≠ * <br></td><td width="125">  Si <br></td><td width="125">  Si <br></td><td width="125">  No <br></td></tr><tr><td width="125">  Se une <br></td><td width="125">  Si <br></td><td width="125">  Si <br></td><td width="125">  No <br></td><td width="125">  No <br></td></tr><tr><td width="125">  Llaves secundarias <br></td><td width="125">  S√≠ * <br></td><td width="125">  Si <br></td><td width="125">  Si pero ... <br></td><td width="125">  No <br></td></tr><tr><td width="125">  GRUPO POR <br></td><td width="125">  S√≠ * <br></td><td width="125">  Si <br></td><td width="125">  No <br></td><td width="125">  No <br></td></tr><tr><td width="125">  JDBC / ODBC <br></td><td width="125">  No <br></td><td width="125">  Si <br></td><td width="125">  No <br></td><td width="125">  No <br></td></tr></tbody></table><br>  Aqu√≠, de hecho, tambi√©n hay ideas interesantes.  Tom√©, en mi opini√≥n, los l√≠deres.  Estoy de acuerdo en que no todo est√° aqu√≠, por ejemplo, Elastic tambi√©n es un l√≠der NoSQL.  Pero Elastic sigue siendo principalmente una soluci√≥n para la b√∫squeda de texto completo, por lo que no lo inclu√≠ en la tabla. <br><br>  Bases de datos de series de tiempo como una tendencia que no toco.  Existe una tesis entre las series de movimientos de tiempos que dice que este es un nicho separado, similar a las bases de datos de gr√°ficos, pero si profundiza, Postgres se sienta debajo del cap√≥. <br><br><h3>  Couchbase <br></h3><br>  En mi opini√≥n, Couchbase tiene la gama m√°s amplia de posibilidades del mundo SQL.  Todos saben que <strong>Couchbase es Memcached</strong> .  Dormando ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alan Kasindorf</a> ), uno de los desarrolladores de Memcached, ten√≠a una visi√≥n del producto completamente diferente, que no implicaba escala horizontal.  Por lo tanto, Memcache se bifurc√≥ para escalar horizontalmente.  Todo sali√≥ bien y comenz√≥ a hacer negocios a su alrededor, luego se fusion√≥ con CouchDB y as√≠ sucesivamente. <br><br>  Couchbase inicialmente se dice a s√≠ mismo que son una <strong>base de datos sin esquema</strong> .  Memcache es originalmente un valor clave muy simple.  Ahora veamos c√≥mo esta autoidentificaci√≥n cambia con el tiempo. <br><br>  Por ejemplo, Couchbase tiene claves secundarias, y las <strong>claves secundarias son en realidad el comienzo del esquema</strong> .  Si dice que tiene algunos campos por los cuales construye el √≠ndice, significa que ya est√° hablando sobre el esquema de estos documentos que almacena. <br><br>  Adem√°s, a medida que Couchbase recorta gradualmente toda la historia sobre el pasado de Memcache de la documentaci√≥n de hoy, tambi√©n recortar√° la historia sobre la consistencia eventual ma√±ana, aunque hoy todav√≠a hay muchas historias sobre la falta de consistencia de lectura: las claves secundarias finalmente son consistentes. <br><br>  Pero el problema es que Couchbase tiene JDBC / ODBC.  ,       Tableau  ClickView ‚Äî ,    CQL    SQL.   <strong>     ‚Äî    SQL.</strong> <br><br>  ,    . <br><br><img src="https://habrastorage.org/webt/ru/4o/wy/ru4owybeykx975o_owylkunnxrw.jpeg"><br><br>     ,   - ,      ,   ,    -   ‚Äî     ,     SQL. <br><br> ,    IS MISSING ‚Äî   ,     IS NULL? <br><br>   JDBC, ODBC       SQL    ?   30-40  ,  SQL-      SQL  ,  ,       :     look-in,  ,           .. <br><br>  ,   . <strong> ,  ,    .</strong> <br><br>  ,  Couchbase  JDBC/ODBC ‚Äî    .      ,   ‚Äî   . <br><br><h3> Secondary keys <br></h3><br>  ,    NoSQL ‚Äî   ,  ‚Äî   ,    .     OrientDB, ,   ,   . <br><br> SQL-     ,     (  ,    ),  NoSQL,   . <br><br>   NoSQL-   secondary keys.    secondary keys? <br><br> <strong>        </strong> (  ‚Äî    ): <br><br><ol><li>    ,     ,  <strong>  </strong> .               ,    range-,  SQL      .    range-             map/reduce   . <br></li><li>  <strong>    </strong> .     index notes,    .           range-  ..,     . <br></li></ol><br>           ,    , ,   ,     ,  .    ,      . <br><br> <strong>    </strong> .   , NoSQL-      SQL,   ,     ,     . <br><br>      :       CockroachDB?   : <strong>      ,       </strong> . ,  MySQL         ‚Äî       legacy.    ,  ,     .. <br><br>    ,  NoSQL-      legacy  10   . ,   ,     .     SQL-   ,   PostgreSQL,  ,  MySQL   Couchbase  ,    True NewSQL. <br><br>     ,  secondary keys.  MongoDB   SQL,     . ,       JOINs,   ,    . <br><br>  Redis  No,       .  Redis    ,      ‚Äî   .   ,      ,    ,    . <br><br>   ,  Redis    ‚Äî ,    - .    ,    Redis-,  SQL.    ,     Redis SQLite,     ‚Äî storage   ‚Äî  Redis',  in memory. <br><br>  NoSQL   ,         ,     ? <br><br><h3>   <br></h3><br>    ,  NoSQL     .   ,   ,    ,   SQL     .       SQL  . <br><br>  schemaless  ,    ,   ,     waterfall    :    agile,        -     .    ,        ,    CREATE TABLE,    . <br><br>   ,   online alter table.   Oracle    ,          . <br><br>     SQL      ,   . <strong>       MongoDB ‚Äî  ,     </strong> . <br><br>  MongoDB   ,  schemaless.        .   ,     ,      strict.  validation level  validation action. Validation level   ,           . <br><br>     ,       ,     - .          ,   ,   .  validation action     reject,  warn:   warning,     validation action. <br><br>   <strong>        </strong> .  ,  MongoDB (      Tarantool),     . <br>  Cassandra        JSON,      .      ‚Äî    ,    .  ,   ,   NoSQL,    . <br><br><h3>  <br></h3><br>   -,  NoSQL     SQL     . <br><br><img src="https://habrastorage.org/webt/je/z2/fj/jez2fj0_acxhcfrhuqh4zis3-es.jpeg"><br><br>  eventually consistent  ,    ,        ,    <strong> </strong> .    ,      ‚Äî    .   . <br><br>       ? <br><br>     ,    ,    .   BigQuery      , , Vertica,     . <br><br>  NoSQL     .  ,     SELECT    LTP,    LTP -   Key-value. <br><br><blockquote>    ,    NoSQL-          . </blockquote><br>   SELECT  JOIN    ,    ,    ,  <strong>    </strong> ‚Äî    .. <br><br><h2><a name="NoSQL_val"></a> NoSQL:   <br></h2><br> ,    <strong></strong> ,     ,       .     <strong>domain-specific languages</strong> . <br><br> NoSQL     DSL.     ‚Äî  <strong>RethinkDB ReQL</strong> .    ,    ‚Äî         domen specific language.     Python,  JavaScript  .. ‚Äî      .      SQL  ,           . <br><br>       ReQL,  . ReQL ,     ,     ‚Äî      .    RethinkDB, ,   ,     ,      ,   . <br><br>      : <br><br><ul><li> Elasticsearch Query Language: <ul><li> MIN/MAX/AVG; </li><li> derivative/percentiles/histogram/cumulative sum/serial diff; </li></ul></li><li> JSONIQ; <br></li><li> GraphQL; <br></li><li> SparQL; <br></li><li> Pregel. <br></li></ul><br>   , ,       SQL,   . <strong> -  SQL!</strong> <br><br>     SQL ‚Äî    OLTP ,  GROUP BY, Window Functions,       (recursive). SQL    ,      .     !        ,   ,    . <br><br><blockquote> ,   ,   . ,     ,    , ,       . <br></blockquote><br> , , Pregel ‚Äî     .     :   ,               /   .  -    ,  .   ,      ,     . <br><br>  -    SQL,    ,      ,       . <br><br>   ,  ,     <strong> ,  ,       </strong> .   . <br><br><h2><a name="MMDB"></a> -   <br></h2><br>  ,     ,   .      . <br><br><img src="https://habrastorage.org/webt/ul/ov/dv/ulovdv_tas-ndbzdymkwujc-cdm.jpeg"><br><br>    ArangoDB,      -      :   ,    ,   ( ),      ,    . <br><br><img src="https://habrastorage.org/webt/pp/k4/tb/ppk4tbnrjvmxesm52ac3somgiz4.jpeg"><br><br>   , ,          .               .    :  ,     . <br><br><img src="https://habrastorage.org/webt/zg/ml/gy/zgmlgy0df4it9m10lfxzyqnk4lo.jpeg"><br><br>    ,     ,    . ,  ,      ,    ,     .     . <br><br> <strong>           </strong> .           ,   ,   relations.  ,   relation    ,    ,       relations  .. <br><br><h2> UPSERT:   <br></h2><br>  No se trata completamente de NoSQL, pero esta es una tendencia que me parece muy importante: se trata de <strong>almacenamiento optimizado para escritura</strong> , que, en mi opini√≥n, permanecer√° con nosotros seriamente y durante mucho tiempo. <br><br>  Ni SQL ni NoSQL tienen declaraciones que se escriben solo por naturaleza.  Incluso absert, que est√° en MongoDB, en varios casos tambi√©n lee datos.  Insertar tambi√©n es una operaci√≥n de lectura, porque si una ID ya est√° definida en el documento, entonces debe verificar que no existe dicha ID. <br><br>  Usted dice: si hay √≠ndices, entonces debemos leer.  Pero <strong>incluso si hay √≠ndices, la lectura no siempre es necesaria</strong> .  La idea es esta: no desea leer en ning√∫n caso, no necesita hacerlo, no le importa el resultado de la lectura.  Desea agregar datos a la base de datos si a√∫n no existe.  Si existen, supongamos que reemplaza su versi√≥n anterior por una nueva o ejecuta alg√∫n tipo de comando de combinaci√≥n.  Es decir, debe inventar una <strong>nueva sem√°ntica</strong> para no leer. <br><br>  En mi opini√≥n, ni una sola base de datos proporciona esto ahora, pero el atractivo de los algoritmos de escritura optimizados es tan grande que realmente quiero esta posibilidad.  Debido a que gracias al almacenamiento optimizado de escritura, los √°rboles de LSM (RocksDB, LevelDB y otros) <strong>rendimiento de escritura sin lectura es 2 √≥rdenes de magnitud mayor que el rendimiento de escritura con lectura</strong> .  En lugar de 10 mil solicitudes por segundo, puede haber un mill√≥n en un nodo. <br>  Es por eso que la base de datos de series temporales ahora est√° ganando porque carecen de esta brecha sem√°ntica.  El flujo de datos que llega en ellos se define claramente como una serie temporal y se escribe de manera muy r√°pida y compacta en la base de datos, en particular.  porque no necesitas verificar la unicidad.  Este es un orden de magnitud m√°s r√°pido simplemente porque en las bases de datos tradicionales no existe tal operaci√≥n sem√°ntica que solo se escribir√≠a. <br><br>  Creo que aparecer√° <br><br><img src="https://habrastorage.org/webt/v0/-w/tl/v0-wtldczsojccjohz5nzbrcnrs.jpeg"><br><br>  ¬øA d√≥nde va todo esto despu√©s?  Si miras muy lejos, la innovaci√≥n no se detiene en NoSQL y NewSQL.  Nuestra comprensi√≥n de la informaci√≥n est√° en constante evoluci√≥n. <br><br><blockquote>  Una de las tendencias m√°s importantes del futuro, en mi opini√≥n, es que eliminaremos cada vez menos informaci√≥n. <br></blockquote><br>  Para esto, nace toda una serie de productos, que se denominan bases de datos temporales. <br><br><h2>  Despu√©s de NewSQL: base de datos temporal <br></h2><br>  A continuaci√≥n se muestran capturas de pantalla de Microsoft SQL Server.  Esta es una base de datos que le permite hacer preguntas en un momento dado: hay SELECT para el estado actual, pero a√∫n es posible hacer SELECT para alguna fecha en el pasado. <br><br><img src="https://habrastorage.org/webt/1z/pz/c5/1zpzc5-px5chjpkth1v12pa71bs.jpeg"><br><br>  Esto genera una serie de nuevas aplicaciones de bases de datos.  En primer lugar, puede rastrear el historial de un objeto.  En segundo lugar, puede calcular autom√°ticamente grupos, informes por per√≠odo.  No necesita crear tablas separadas para esto: tiene una representaci√≥n natural en una tabla: una entidad, una tabla. <br><br><img src="https://habrastorage.org/webt/_w/ls/kk/_wlskk1vblw3g3_fxcsgdgjqdm0.jpeg"><br><br>  Desde el punto de vista de la estructura interna, esta es en realidad la tabla principal y la tabla con el historial.  Cada l√≠nea est√° asociada con dos veces conocidas por el sistema.  Estas no son solo dos columnas que agreg√≥, sino datos que el sistema admite autom√°ticamente: <br><br><ol><li>  <strong>la hora en que se agreg√≥ el registro a la base de datos,</strong> <br></li><li>  <strong>hora del evento</strong> <br></li></ol><br>  Estos son tiempos diferentes, no importa cu√°n divertido. <br><br>  Supongamos que Ivan Ivanovich muri√≥ el 17 de noviembre, y este registro se ingres√≥ en la base de datos el 20 de noviembre; ambos tiempos se almacenan en dichas bases de datos. <br><br>  En mi opini√≥n, esta es tambi√©n una de las tendencias fundamentales.  ¬øPor qu√© pienso eso?  Si volvemos a las claves secundarias y la coherencia eventual, almacenar absolutamente todo solo le permite resolver este problema con elegancia. <br><br><blockquote>  Si nunca necesitamos eliminar nada de la base de datos, nuestra base de datos siempre es coherente, ¬°una historia tan interesante! <br></blockquote><br><h2>  Enlaces utiles <br></h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developer.couchbase.com/documentation/server/current/developer-guide/query-consistency.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://martinfowler.com/books/nosql.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://jimwebber.org/2011/02/on-sharding-graph-databases/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://docs.mongodb.com/manual/core/document-validation/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.oreilly.com/pub/e/3847</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.oreilly.com/ideas/data-modeling-with-multi-model-databases</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://redislabs.com/blog/redis-as-a-json-store/</a> </li></ul><br><div class="spoiler">  <b class="spoiler_title">FAQ</b> <div class="spoiler_text"><blockquote>  <em>- ¬øHay alg√∫n desarrollo en la creaci√≥n de una nueva base de datos que no se aplique a MySQL, PostgreSQL, MongoDB, etc.?</em> </blockquote><br>  En el buen sentido, la pregunta es: ¬øhabr√° nuevas bases de datos, nuevas empresas?  Creo que aparecer√°n cada vez menos.  La tormenta ha disminuido, y ahora veremos la salida antes que la llegada, CockroachDB fue uno de los √∫ltimos en llegar. <br><br>  Vayamos al grano.  Mi profesor en la universidad dijo que DBMS es un √°rea eternamente verde.  Por lo tanto, siempre veremos alg√∫n tipo de movimiento.  Pero creo que en el futuro cercano no aparecer√°n productos fundamentalmente diferentes, habr√° convergencia, no un auge. <br><br><blockquote>  <em>- No es una pregunta, sino m√°s bien una adici√≥n: SQL a menudo intenta hacer √≠ndices de cobertura para que el resultado de la consulta SQL no afecte al nivel de almacenamiento, sino que se obtiene inmediatamente del √≠ndice.</em>  <em>El √≠ndice en s√≠ mismo es en realidad un caso especial del gr√°fico.</em>  <em>Entonces, ¬øtal vez la tendencia es que toda la base de datos fluya gradualmente en un √≠ndice de gr√°fico empinado?</em> <br></blockquote><br>  Esta es una historia maravillosa que a todos los representantes de las bases de datos de gr√°ficos les encanta contar a sus clientes: ¬°no funciona!  Porque hay muchas maneras de actualizar los √≠ndices, y hay muchas opciones de indexaci√≥n, ¬°pero no todos tienen un gr√°fico!  Vamos a calmarnos, as√≠ como no todo es relacional, tampoco todos son un gr√°fico. <br><br><blockquote>  <em>- En tu opini√≥n, ¬øa d√≥nde ir√°n Elastic y similares?</em>  <em>Me refiero al hecho de que est√° empezando a resolver problemas muy extra√±os: est√° tratando de simular series de tiempo y una base anal√≠tica para trabajar con registros.</em>  <em>Parece que nadie lo usa para la b√∫squeda de texto.</em> <br></blockquote><br>  Elastic no tiene que moverse a ninguna parte porque Elastic se siente genial.  Resuelve un problema comercial espec√≠fico: es una b√∫squeda efectiva y todo lo relacionado con este ecosistema. <br><br>  Creo que todo proviene principalmente del hecho de que Elastic est√° tratando de ser todo.  Pero aqu√≠ la pregunta es de la tarea, la tarea Elastic es muy similar a las tareas de series de tiempo, por lo tanto, est√° justificada.  Elastic es bueno para buscar en grandes matrices de los mismos registros, etc. <br><br>  Hay un caso m√°s estrecho: es solo una b√∫squeda de texto completo, pero no har√° mucho de eso.  Se necesita hacer m√°s para diferenciarse de los competidores en primer lugar.  Por lo tanto, todo esto est√° sucediendo. <br><br>  Pero no creo que Elastic haga transacciones bancarias ma√±ana.  Todo llega al punto en que Couchbase, por ejemplo, ser√°, si no transacciones bancarias, sino algo tan r√°pido. <br></div></div><br><blockquote><h3>  Noticias </h3><br>  Muy pronto, <strong>el 21 de junio, la</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conferencia de Tarantool</a> <strong>tendr√° lugar en Mosc√∫</strong> , o brevemente <strong>T + Conf</strong> , una conferencia no solo sobre Tarantool en s√≠, sino sobre el uso de <strong>la computaci√≥n en memoria en</strong> general <strong>.</strong> <br><br><ul><li>  Konstantin Osipov planea hacer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> en el que examinar√° la arquitectura de Vinyl, sus capacidades y, lo m√°s importante, los mecanismos de ajuste y monitoreo de rendimiento espec√≠ficos de este motor de la manera m√°s consistente y detallada posible. </li><li>  Vladimir Perepelitsa, en formato tutorial, quiere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mostrar</a> que Tarantool es una base de datos que tiene un gran potencial para su uso como servidor de aplicaciones. </li><li>  Vladislav Zaitsev va a abordar este tema desde su lado, desde el lado de Internet de las cosas y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contar</a> , en particular, por qu√© el sistema de control de IoT. </li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413557/">https://habr.com/ru/post/es413557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413547/index.html">Experimenta 2 millones de sesiones sin cabeza</a></li>
<li><a href="../es413549/index.html">Curso de conferencia sobre desarrollo web</a></li>
<li><a href="../es413551/index.html">Desplazamiento y atenci√≥n (estudio 2018)</a></li>
<li><a href="../es413553/index.html">El registrador REG.RU priv√≥ al socio del acceso a 70 mil dominios y tom√≥ su servicio para s√≠ mismo</a></li>
<li><a href="../es413555/index.html">Interoperabilidad segura en sistemas distribuidos</a></li>
<li><a href="../es413559/index.html">Degradaci√≥n web o c√≥mo hacer que la web sea legible por humanos</a></li>
<li><a href="../es413561/index.html">Velocidad de √°rbol de expresi√≥n de Linq compilada</a></li>
<li><a href="../es413563/index.html">4 formas de importar un paquete en Go</a></li>
<li><a href="../es413565/index.html">An√°lisis de pirateo de Kubernetes - puerta trasera a trav√©s de kubelet</a></li>
<li><a href="../es413567/index.html">Comenzando con microservicios en Spring Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>