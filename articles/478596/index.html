<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèº üö© üïäÔ∏è Funciones an√≥nimas de PHP: exposici√≥n de la sesi√≥n de Black Magic üëÇüèº üí™ üßòüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probablemente, uno deber√≠a comenzar con el hecho de que una funci√≥n an√≥nima (cierre) en PHP no es una funci√≥n, sino un objeto de la clase Closure . En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones an√≥nimas de PHP: exposici√≥n de la sesi√≥n de Black Magic</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/478596/"><img src="https://habrastorage.org/webt/r6/gx/7h/r6gx7hxhbqlathbjqby__emcvj0.jpeg"><br><br>  Probablemente, uno deber√≠a comenzar con el hecho de que una funci√≥n an√≥nima (cierre) en PHP no es una funci√≥n, sino un objeto de la clase <a href="https://www.php.net/manual/ru/class.closure.php">Closure</a> .  En realidad, este art√≠culo podr√≠a haberse completado, pero si alguien est√° interesado en los detalles, bienvenido a cat. <br><br><a name="habracut"></a><br>  Para no ser infundado: <br><pre><code class="php hljs">$func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}; var_dump($func); --------- object(Closure)<span class="hljs-comment"><span class="hljs-comment">#1 (0) { }</span></span></code> </pre> <br>  Mirando hacia el futuro, dir√© que este no es realmente un objeto ordinario.  Vamos a resolverlo. <br><br>  Por ejemplo, tal c√≥digo <br><pre> <code class="php hljs">$func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>; }; $func();</code> </pre> <br>  compila en un conjunto de c√≥digos de operaci√≥n: <br><pre> <code class="php hljs">line <span class="hljs-comment"><span class="hljs-comment">#* EIO op fetch ext return operands -------------------------------------------------------------------------- 8 0 E &gt; DECLARE_LAMBDA_FUNCTION '%00%7Bclosure%7D%2Fin%2FcrvX50x7fabda9ed09e' 10 1 ASSIGN !0, ~1 11 2 INIT_DYNAMIC_CALL !0 3 DO_FCALL 0 11 2 &gt; RETURN 1 Function %00%7Bclosure%7D%2Fin%2FcrvX50x7fabda9ed09e: function name: {closure} line #* EIO op fetch ext return operands -------------------------------------------------------------------------- 9 0 E &gt; ECHO 'Hello+world%21' 10 1 &gt; RETURN null</span></span></code> </pre> <br>  El bloque con la descripci√≥n del cuerpo de la funci√≥n no es particularmente interesante para nosotros, pero en el primer bloque hay dos <b>c√≥digos de</b> <b>operaci√≥n</b> interesantes: <b>DECLARE_LAMBDA_FUNCTION</b> e <b>INIT_DYNAMIC_CALL</b> .  Comencemos con el segundo. <br><br><h1>  INIT_DYNAMIC_CALL </h1><br>  Este c√≥digo de operaci√≥n se usa cuando el compilador ve una llamada de funci√≥n en una variable o matriz.  Es decir <br><pre> <code class="php hljs">$variable(); [<span class="hljs-string"><span class="hljs-string">'ClassName'</span></span>, <span class="hljs-string"><span class="hljs-string">'staticMethod'</span></span>]();</code> </pre> <br>  Este no es un c√≥digo de operaci√≥n √∫nico espec√≠fico solo para cierres.  Esta sintaxis tambi√©n funciona para los objetos llamando al m√©todo <b>__invoke ()</b> , para las variables de cadena que contienen el nombre de la funci√≥n ( <b>$ a = 'funcName'; $ a ();</b> ), y para las matrices que contienen el nombre de la clase y el m√©todo est√°tico. <br><br>  En el caso del cierre, estamos interesados ‚Äã‚Äãen llamar a una variable con un objeto, lo cual es l√≥gico. <br>  Profundizando en el c√≥digo VM que procesa este c√≥digo <b>operativo</b> , llegamos a la funci√≥n <b>zend_init_dynamic_call_object</b> , en la que veremos lo siguiente (segmentaci√≥n): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">zend_execute_data *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_init_dynamic_call_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zend_object *function, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num_args)</span></span></span><span class="hljs-function"> </span></span>{ zend_function *fbc; zend_class_entry *called_scope; zend_object *object; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(function-&gt;handlers-&gt;get_closure) &amp;&amp; EXPECTED(function-&gt;handlers-&gt;get_closure(function, &amp;called_scope, &amp;fbc, &amp;object) == SUCCESS)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { zend_throw_error(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"Function name must be a string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } ... }</code> </pre> <br>  <i>Es curioso que la <b>llamada al</b> m√©todo <b>__invoke</b> familiar en t√©rminos de VM sea un intento de llamar al cierre: <b>get_closure</b> .</i> <br><br>  En realidad, en este punto, la diferencia comienza en el manejo de la llamada a la funci√≥n an√≥nima y al m√©todo <b>__invoke</b> de un objeto regular. <br>  En PHP, cada objeto tiene un conjunto de controladores diferentes que define su utilidad y m√©todos m√°gicos. <br><div class="spoiler">  <b class="spoiler_title">El conjunto est√°ndar se ve as√≠</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ZEND_API <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers std_object_handlers = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* offset */</span></span> zend_object_std_dtor, <span class="hljs-comment"><span class="hljs-comment">/* free_obj */</span></span> zend_objects_destroy_object, <span class="hljs-comment"><span class="hljs-comment">/* dtor_obj */</span></span> zend_objects_clone_obj, <span class="hljs-comment"><span class="hljs-comment">/* clone_obj */</span></span> zend_std_read_property, <span class="hljs-comment"><span class="hljs-comment">/* read_property */</span></span> zend_std_write_property, <span class="hljs-comment"><span class="hljs-comment">/* write_property */</span></span> zend_std_read_dimension, <span class="hljs-comment"><span class="hljs-comment">/* read_dimension */</span></span> zend_std_write_dimension, <span class="hljs-comment"><span class="hljs-comment">/* write_dimension */</span></span> zend_std_get_property_ptr_ptr, <span class="hljs-comment"><span class="hljs-comment">/* get_property_ptr_ptr */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* set */</span></span> zend_std_has_property, <span class="hljs-comment"><span class="hljs-comment">/* has_property */</span></span> zend_std_unset_property, <span class="hljs-comment"><span class="hljs-comment">/* unset_property */</span></span> zend_std_has_dimension, <span class="hljs-comment"><span class="hljs-comment">/* has_dimension */</span></span> zend_std_unset_dimension, <span class="hljs-comment"><span class="hljs-comment">/* unset_dimension */</span></span> zend_std_get_properties, <span class="hljs-comment"><span class="hljs-comment">/* get_properties */</span></span> zend_std_get_method, <span class="hljs-comment"><span class="hljs-comment">/* get_method */</span></span> zend_std_get_constructor, <span class="hljs-comment"><span class="hljs-comment">/* get_constructor */</span></span> zend_std_get_class_name, <span class="hljs-comment"><span class="hljs-comment">/* get_class_name */</span></span> zend_std_compare_objects, <span class="hljs-comment"><span class="hljs-comment">/* compare_objects */</span></span> zend_std_cast_object_tostring, <span class="hljs-comment"><span class="hljs-comment">/* cast_object */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* count_elements */</span></span> zend_std_get_debug_info, <span class="hljs-comment"><span class="hljs-comment">/* get_debug_info */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ------- */</span></span> zend_std_get_closure, <span class="hljs-comment"><span class="hljs-comment">/* get_closure */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ------- */</span></span> zend_std_get_gc, <span class="hljs-comment"><span class="hljs-comment">/* get_gc */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* do_operation */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* compare */</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get_properties_for */</span></span> };</code> </pre> <br></div></div><br>  Ahora estamos interesados ‚Äã‚Äãen el controlador <b>get_closure</b> .  Para un objeto normal, apunta a la funci√≥n <b>zend_std_get_closure</b> , que verifica que la funci√≥n <b>__invoke</b> est√© definida para el objeto y devuelve un puntero o un error.  Pero para la clase <b>Closure</b> , que implementa funciones an√≥nimas, en este conjunto de controladores se redefinen casi todas las funciones de utilidad, incluidas las que controlan el ciclo de vida.  Es decir  aunque para el usuario parece un objeto ordinario, pero de hecho es un mutante con superpoderes :) <br><div class="spoiler">  <b class="spoiler_title">Registrar manejadores para un objeto de clase Cierre</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_register_closure_ce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* {{{ */</span></span></span><span class="hljs-function"> </span></span>{ zend_class_entry ce; INIT_CLASS_ENTRY(ce, <span class="hljs-string"><span class="hljs-string">"Closure"</span></span>, closure_functions); zend_ce_closure = zend_register_internal_class(&amp;ce); zend_ce_closure-&gt;ce_flags |= ZEND_ACC_FINAL; zend_ce_closure-&gt;create_object = zend_closure_new; zend_ce_closure-&gt;serialize = zend_class_serialize_deny; zend_ce_closure-&gt;unserialize = zend_class_unserialize_deny; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;closure_handlers, &amp;std_object_handlers, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(zend_object_handlers)); closure_handlers.free_obj = zend_closure_free_storage; closure_handlers.get_constructor = zend_closure_get_constructor; closure_handlers.get_method = zend_closure_get_method; closure_handlers.write_property = zend_closure_write_property; closure_handlers.read_property = zend_closure_read_property; closure_handlers.get_property_ptr_ptr = zend_closure_get_property_ptr_ptr; closure_handlers.has_property = zend_closure_has_property; closure_handlers.unset_property = zend_closure_unset_property; closure_handlers.compare_objects = zend_closure_compare_objects; closure_handlers.clone_obj = zend_closure_clone; closure_handlers.get_debug_info = zend_closure_get_debug_info; <span class="hljs-comment"><span class="hljs-comment">/* ------- */</span></span> closure_handlers.get_closure = zend_closure_get_closure; <span class="hljs-comment"><span class="hljs-comment">/* ------- */</span></span> closure_handlers.get_gc = zend_closure_get_gc; }</code> </pre> <br></div></div><br>  El manual dice: <br><blockquote>  Adem√°s de los m√©todos descritos aqu√≠, esta clase tambi√©n tiene un m√©todo <b>__invoke</b> .  Este m√©todo solo es necesario para la compatibilidad con otras clases en las que se implementa la llamada m√°gica, ya que este m√©todo no se utiliza al llamar a la funci√≥n. </blockquote><br>  Y esto es verdad.  La funci√≥n <b>get_closure</b> para un cierre no devuelve <b>__invoke</b> , sino su funci√≥n a partir de la cual se cre√≥ el cierre. <br><br>  Puede estudiar las fuentes con m√°s detalle usted mismo: el archivo <b>zend_closure.c</b> , y pasaremos al siguiente c√≥digo de operaci√≥n. <br><br><h1>  DECLARE_LAMBDA_FUNCTION </h1><br>  Pero este es un c√≥digo de operaci√≥n exclusivo para circuitos y ya no funciona con nada.  Bajo el cap√≥ del procesador, hay tres operaciones principales: <br><ol><li>  Se busca un puntero a una funci√≥n compilada, que ser√° la esencia del cierre. </li><li>  Se define el contexto para crear el cierre (en otras palabras, <b>esto</b> ). </li><li>  En base a los dos primeros puntos, <b>se crea</b> un objeto de clase <b>Cierre</b> . </li></ol><br><br>  Y aqu√≠ en este lugar comienzan noticias no muy agradables. <br><br><h1>  Entonces, ¬øqu√© hay de malo con las funciones an√≥nimas? </h1><br>  Crear un cierre es una operaci√≥n m√°s dif√≠cil que crear un objeto ordinario.  No solo se llama el mecanismo est√°ndar para crear un objeto, sino que tambi√©n agrega una cierta cantidad de l√≥gica, la m√°s desagradable de las cuales es copiar toda la matriz de c√≥digos de operaci√≥n de su funci√≥n al cuerpo del cierre.  Esto en s√≠ mismo no es tan aterrador, pero exactamente hasta que comience a usarlo "incorrectamente". <br><br>  Para comprender exactamente d√≥nde esperan los problemas, analizaremos los casos en que se crea un cierre. <br>  El cierre se recrea: <br>  a) en cada procesamiento del <b>c√≥digo de operaci√≥n</b> DECLARE_LAMBDA_FUNCTION. <br>  Intuitivamente: exactamente el caso en el que el cierre se ve bien, pero de hecho se crear√° un nuevo objeto de cierre en cada iteraci√≥n del bucle. <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($values <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value){ doSomeStuff($value, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($args)</span></span></span><span class="hljs-function"> </span></span>{ closureBody }); }</code> </pre> <br>  b) cada vez que se <b>llama a los</b> m√©todos <b>bind</b> y <b>bindTo</b> : <br>  Aqu√≠ el cierre se volver√° a crear tambi√©n en cada iteraci√≥n. <br><pre> <code class="php hljs">$closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($args)</span></span></span><span class="hljs-function"> </span></span>{ closureBody }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($objects <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $object){ $closure-&gt;bindTo($object); $object-&gt;doSomeStuff($closure); }</code> </pre><br>  c) cada vez que se <b>llama al</b> m√©todo de <b>llamada</b> , si se utiliza un generador como funci√≥n.  Y si no es un generador, sino una funci√≥n ordinaria, solo se ejecuta la parte que copia la matriz de c√≥digos de operaci√≥n.  Tales cosas <br><br><h1>  Conclusiones </h1><br>  Si el rendimiento no es importante para usted a toda costa, entonces las funciones an√≥nimas son convenientes y agradables.  Y si es importante, entonces probablemente no valga la pena. <br><br>  En cualquier caso, ahora sabe que los cierres y los ciclos, si no est√°n preparados correctamente, son una combinaci√≥n. <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478596/">https://habr.com/ru/post/478596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478574/index.html">La verdad sobre los frenos de ferrocarril: Parte 4 - Frenos de pasajeros</a></li>
<li><a href="../478582/index.html">Informe VPN global sobre dispositivos m√≥viles en 2019</a></li>
<li><a href="../478584/index.html">Elementos internos de JVM, Parte 2 - Estructura de archivos de clase</a></li>
<li><a href="../478586/index.html">Ineficiencia</a></li>
<li><a href="../478590/index.html">¬øEst√°s seguro de que utilizas microservicios?</a></li>
<li><a href="../478602/index.html">MVC en Unity con Objetos Scriptables. Parte 2</a></li>
<li><a href="../478604/index.html">De trabajadores a programadores de php. Carrera de desarrollo inusual</a></li>
<li><a href="../478606/index.html">"Buenas noches": c√≥mo los dispositivos inteligentes privan a las personas del sue√±o</a></li>
<li><a href="../478616/index.html">Windows UAC nunca deja de sorprender, o C√≥mo detectar una informaci√≥n privilegiada</a></li>
<li><a href="../478618/index.html">School of Magic PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>