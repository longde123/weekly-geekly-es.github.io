<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßò ü•Å üåØ So sammeln Sie mit Prometheus Metriken, die nicht durch Zeitangaben verzerrt sind üìâ üí§ üë©üèΩ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Netzwerkanwendungen bestehen aus einem Webserver, der Echtzeitverkehr verarbeitet, und einem zus√§tzlichen Handler, der asynchron im Hintergrund ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So sammeln Sie mit Prometheus Metriken, die nicht durch Zeitangaben verzerrt sind</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/470133/"><p><img src="https://habrastorage.org/webt/-6/xs/ee/-6xseehi1ojmkxmb_phq6tr3h_a.jpeg"></p><br><p>  Viele Netzwerkanwendungen bestehen aus einem Webserver, der Echtzeitverkehr verarbeitet, und einem zus√§tzlichen Handler, der asynchron im Hintergrund ausgef√ºhrt wird.  Es gibt viele gute Tipps zum √úberpr√ºfen des Verkehrsstatus, und die Community h√∂rt nicht auf, Tools wie Prometheus zu entwickeln, die bei der Bewertung helfen.  Aber Handler sind manchmal nicht weniger - und noch wichtiger -.  Sie brauchen auch Aufmerksamkeit und Bewertung, aber es gibt wenig Anleitung, wie dies getan werden kann, w√§hrend h√§ufige Fallstricke vermieden werden. </p><br><p>  Dieser Artikel befasst sich mit den Traps, die bei der Bewertung asynchroner Handler am h√§ufigsten vorkommen. Anhand eines Beispiels eines Vorfalls in einer Produktionsumgebung, in der es trotz Metriken unm√∂glich war, genau zu bestimmen, was die Handler taten.  Die Verwendung von Metriken hat den Fokus so sehr verschoben, dass die Metriken selbst offen gelogen haben, sagen sie, Ihre Handler zur H√∂lle. </p><br><p> Wir werden sehen, wie Metriken so verwendet werden, dass eine genaue Sch√§tzung bereitgestellt wird, und abschlie√üend werden wir die Referenzimplementierung des Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-Client-Tracers zeigen</a> , den Sie in Ihren Anwendungen verwenden k√∂nnen. </p><a name="habracut"></a><br><h3 id="incident">  Vorfall </h3><br><p>  Die Warnungen erreichten eine Maschinengewehrgeschwindigkeit: Die Anzahl der HTTP-Fehler stieg stark an, und die Kontrollfelder best√§tigten, dass die Anforderungswarteschlangen gr√∂√üer wurden und die Antwortzeit abgelaufen war.  Ungef√§hr 2 Minuten sp√§ter wurden die Warteschlangen gel√∂scht und alles normalisiert. </p><br><p>  Bei n√§herer Betrachtung stellte sich heraus, dass unsere API-Server aufstanden und auf eine DB-Antwort warteten, die dazu f√ºhrte, dass sie blockierten und pl√∂tzlich alle Aktivit√§ten aufnahmen.  Und wenn man bedenkt, dass die schwerste Last h√§ufiger auf asynchrone Prozessoren f√§llt, sind sie zu den Hauptverd√§chtigen geworden.  Die logische Frage war: Was machen sie dort √ºberhaupt ?! </p><br><p>  Die Prometheus-Metrik zeigt, wie lange der Prozess dauert. Hier ist er: </p><br><pre><code class="plaintext hljs"># HELP job_worked_seconds_total Sum of the time spent processing each job class # TYPE job_worked_seconds_total counter job_worked_seconds_total{job}</code> </pre> <br><p>  Indem wir die Gesamtausf√ºhrungszeit jeder Aufgabe und die H√§ufigkeit verfolgen, mit der sich die Metrik √§ndert, ermitteln wir, wie viel Arbeitszeit aufgewendet wurde.  Wenn f√ºr einen Zeitraum von 15 Sekunden.  Wenn die Anzahl um 15 erh√∂ht wird, bedeutet dies, dass 1 Handler besch√§ftigt ist (eine Sekunde f√ºr jede letzte Sekunde), w√§hrend eine Erh√∂hung um 30 2 Handler usw. bedeutet. </p><br><p>  Ein Arbeitsplan w√§hrend des Vorfalls zeigt, was uns bevorsteht.  Die Ergebnisse sind entt√§uschend;  Der Zeitpunkt des Vorfalls (16: 02‚Äì16: 04) ist durch die alarmierende rote Linie gekennzeichnet: </p><br><p><img src="https://habrastorage.org/webt/33/1u/bc/331ubcimex4xb4hm_zdondnxcnw.png"><br>  <em>Handleraktivit√§t w√§hrend des Vorfalls: Eine merkliche L√ºcke ist sichtbar.</em> </p><br><p>  Es war f√ºr mich als Person, die nach diesem Albtraum debuggte, schmerzhaft zu sehen, dass die Aktivit√§tskurve gerade w√§hrend des Vorfalls ganz unten war.  Dies ist die Zeit f√ºr die Arbeit mit Web-Hooks, in denen wir 20 dedizierte Handler haben.  Aus den Protokollen wei√ü ich, dass sie alle im Gesch√§ft waren, und ich erwartete, dass die Kurve bei etwa 20 Sekunden liegen w√ºrde, und ich sah eine fast gerade Linie.  Sehen Sie au√üerdem diesen gro√üen blauen Gipfel um 16:05 Uhr?  Gemessen am Zeitplan verbrachten 20 Single-Threaded-Prozessoren 45 Sekunden.  f√ºr jede Sekunde der Aktivit√§t, aber ist das m√∂glich ?! </p><br><h3 id="gde-i-chto-poshlo-ne-tak">  Wo und was ist schief gelaufen? </h3><br><p>  Der Zeitplan des Vorfalls l√ºgt: Er verbirgt die Arbeitsaktivit√§t und zeigt gleichzeitig das √úberfl√ºssige - je nachdem, wo gemessen werden soll.  Um herauszufinden, warum dies geschieht, m√ºssen Sie die Implementierung der Metrikverfolgung und deren Interaktion mit Prometheus ber√ºcksichtigen. </p><br><p>  Beginnend mit der Erfassung von Metriken durch Handler k√∂nnen Sie ein ungef√§hres Workflow-Implementierungsschema skizzieren (siehe unten).  Hinweis: Handler aktualisieren Metriken erst <em>nach Abschluss einer Aufgabe</em> . </p><br><pre> <code class="plaintext hljs">class Worker JobWorkedSecondsTotal = Prometheus::Client::Counter.new(...) def work job = acquire_job start = Time.monotonic_now job.run ensure # run after our main method block duration = Time.monotonic_now - start JobWorkedSecondsTotal.increment(by: duration, labels: { job: job.class }) end end</code> </pre> <br><p>  Prometheus (mit seiner Philosophie, Metriken zu extrahieren) sendet alle 15 Sekunden eine GET-Anfrage an jeden Handler und zeichnet die Werte der Metriken zum Zeitpunkt der Anfrage auf.  Handler aktualisieren st√§ndig die Metriken abgeschlossener Aufgaben, und im Laufe der Zeit k√∂nnen wir die Dynamik von Wert√§nderungen grafisch darstellen. </p><br><p>  Das Problem mit Unter- und Neubewertung tritt immer dann auf, wenn die Zeit, die zum Ausf√ºhren einer Aufgabe ben√∂tigt wird, die Wartezeit f√ºr eine Anforderung √ºberschreitet, die alle 15 Sekunden eintrifft.  Beispielsweise beginnt eine Aufgabe 5 Sekunden vor der Anforderung und endet 1 Sekunde danach.  Ganz und gar dauert es 6 Sekunden, aber diese Zeit ist nur sichtbar, wenn die nach der Anforderung get√§tigten Zeitkosten gesch√§tzt werden, w√§hrend 5 dieser 6 Sekunden vor der Anforderung verbracht wurden. </p><br><p>  Die Indikatoren sind noch gottloser, wenn die Aufgaben l√§nger als der Berichtszeitraum (15 Sekunden) dauern. W√§hrend der Ausf√ºhrung der Aufgabe f√ºr 1 Minute hat Prometheus Zeit, 4 Anforderungen an die Prozessoren zu senden, aber die Metrik wird erst nach der vierten aktualisiert. </p><br><p>  Nachdem wir einen Zeitplan f√ºr die Arbeitsaktivit√§t erstellt haben, werden wir sehen, wie sich der Moment der Aktualisierung der Metrik auf das auswirkt, was Prometheus sieht.  In der folgenden Abbildung teilen wir die Zeitachse zweier Handler in mehrere Segmente auf, in denen Aufgaben unterschiedlicher Dauer angezeigt werden.  Rote (15 Sekunden) und blaue (30 Sekunden) Tags zeigen 2 Prometheus-Datenproben an.  Die Aufgaben, die als Datenquelle f√ºr die Bewertung dienten, sind jeweils farblich hervorgehoben. </p><br><p><img src="https://habrastorage.org/webt/ph/lc/z6/phlcz67lq7o3tpar3vgibp71h9o.png"></p><br><p>  Unabh√§ngig davon, was die Handler bei Volllast tun, erledigen sie alle 15 Sekunden 30 Sekunden Arbeit.  Da Prometheus die Arbeit erst nach Abschluss sieht, wurden nach den Metriken 14 Sekunden Arbeit im ersten Zeitintervall und 42 Sekunden im zweiten Zeitintervall erledigt.  Wenn jeder Handler eine umfangreiche Aufgabe √ºbernimmt, werden wir auch nach einigen Stunden bis zum Ende keine Berichte dar√ºber sehen, dass die Arbeit l√§uft. </p><br><p>  Um diesen Effekt zu demonstrieren, f√ºhrte ich ein Experiment mit zehn Handlern durch, die an Aufgaben beteiligt waren, deren L√§nge unterschiedlich und halbnormal zwischen 0,1 Sekunden und einem etwas h√∂heren Wert verteilt war (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuf√§llige Aufgaben</a> ).  Unten sind 3 Diagramme dargestellt, die die Arbeitsaktivit√§t darstellen.  Die Zeitdauer wird in aufsteigender Reihenfolge angezeigt. </p><br><p><img src="https://habrastorage.org/webt/6o/bx/jh/6obxjhklfq8sxwhdbjrzpnsgcmm.png"><br>  <em>Aufgaben bis zu 1 Sekunde.</em> </p><br><p>  Die erste Grafik zeigt, dass jeder Handler in jeder Sekunde ungef√§hr 1 Sekunde Arbeit erledigt - dies ist auf flachen Linien sichtbar, und der Gesamtarbeitsaufwand entspricht unseren F√§higkeiten (10 Handler geben eine Sekunde Arbeit pro Sekunde Zeit aus).  Tats√§chlich erwarten wir dies unabh√§ngig von der L√§nge der Aufgabe: Gerade bei kurzen und langen Aufgaben sollten Prozessoren mit konstanter Last so viel ausgeben. </p><br><p><img src="https://habrastorage.org/webt/x-/lj/zp/x-ljzpfv-jdybqpk-osmcfd3rui.png"><br>  <em>Aufgaben bis zu 15 Sekunden.</em> </p><br><p>  Die Dauer der Aufgaben nimmt zu, und im Zeitplan wird ein Durcheinander angezeigt: Wir haben immer noch 10 Prozessoren, die alle voll belegt sind, aber die Gesamtmenge der Arbeit √ºberspringt - entweder niedriger oder h√∂her als die Grenze der Nutzkapazit√§t (10 Sekunden). </p><br><p><img src="https://habrastorage.org/webt/uo/cc/mh/uoccmht2erjrgjywbvlo7sn6-tk.png"><br>  <em>Aufgaben bis zu 30 Sekunden.</em> </p><br><p>  Die Bewertung von Arbeiten mit einer Dauer von bis zu 30 Sekunden ist einfach l√§cherlich.  Eine zeitgebundene Metrik zeigt f√ºr die l√§ngsten Aufgaben keine Aktivit√§t an und zeichnet uns erst nach Abschluss der Aufgaben Aktivit√§tsspitzen. </p><br><h3 id="vosstanovim-doverie">  Stellen Sie das Vertrauen wieder her </h3><br><p>  Dies hat uns nicht gereicht, daher gibt es ein weiteres, viel heimt√ºckischeres Problem mit diesen langfristigen Aufgaben, die unsere Metriken beeintr√§chtigen.  Wann immer eine langfristige Aufgabe abgeschlossen ist - beispielsweise wenn Kubernetes einen Pod aus einem Pool wirft oder wenn ein Knoten stirbt, was passiert dann mit den Metriken?  Es lohnt sich, sie sofort nach Abschluss der Aufgabe zu aktualisieren, da sie zeigen, dass <strong>sie die</strong> Arbeit <strong>√ºberhaupt nicht erledigt haben</strong> . </p><br><p>  Metriken sollten nicht l√ºgen.  Der Laptop heult ungl√§ubig und verursacht existenziellen Horror. √úberwachungstools, die das Bild der Welt verzerren, sind eine Falle und f√ºr die Arbeit ungeeignet. </p><br><p>  Gl√ºcklicherweise ist die Angelegenheit behebbar.  Datenverzerrungen treten auf, weil Prometheus Messungen vornimmt, unabh√§ngig davon, wann Prozessoren Metriken aktualisieren.  Wenn wir die Handler bitten, die Metriken zu aktualisieren, wenn Prometheus Anforderungen sendet, werden wir feststellen, dass Prometheus nicht mehr eigenartig ist und die aktuelle Aktivit√§t anzeigt. </p><br><h3 id="predstavlyaem-tracer">  Wir stellen vor ... Tracer </h3><br><p>  Eine L√∂sung f√ºr das Problem der verzerrten Metriken ist der <code>Tracer</code> , ein abstrakt gestalteter <code>Tracer</code> , der die Aktivit√§t bei Aufgaben mit langer Laufzeit bewertet, indem Prometheus-bezogene Metriken schrittweise aktualisiert werden. </p><br><pre> <code class="plaintext hljs">class Tracer def trace(metric, labels, &amp;block) ... end def collect(traces = @traces) ... end end</code> </pre> <br><p>  Tracer bieten eine Verfolgungsmethode, die die Prometheus-Metriken und die zu verfolgende Aufgabe √ºbernimmt.  Der Befehl <code>trace</code> f√ºhrt den angegebenen Block aus (anonyme Ruby-Funktionen) und stellt sicher, dass Anforderungen an <code>tracer.collect</code> w√§hrend der Ausf√ºhrung die zugeh√∂rigen Metriken schrittweise aktualisieren, unabh√§ngig davon, wie viel Zeit seit der letzten Anforderung zum <code>collect</code> vergangen ist. </p><br><p>  Wir m√ºssen den <code>tracer</code> mit den Handlern verbinden, um die Dauer der Aufgabe und den Endpunkt zu verfolgen, der die Prometheus-Metrikanforderungen bedient.  Wir beginnen mit den Handlern, initialisieren einen neuen Tracer und bitten ihn, die Ausf√ºhrung von <code>acquire_job.run</code> . </p><br><pre> <code class="plaintext hljs">class Worker def initialize @tracer = Tracer.new(self) end def work @tracer.trace(JobWorkedSecondsTotal, labels) { acquire_job.run } end # Tell the tracer to flush (incremental) trace progress to metrics def collect @tracer.collect end end</code> </pre> <br><p>  Zu diesem Zeitpunkt aktualisiert der Tracer die Metriken nur in Sekunden, die f√ºr die abgeschlossene Aufgabe aufgewendet wurden - wie bei der ersten Implementierung der Metriken.  Wir m√ºssen den Tracer bitten, unsere Metriken zu aktualisieren, bevor wir eine Anfrage von Prometheus ausf√ºhren.  Dies kann durch Einrichten des Middleware-Racks erfolgen. </p><br><pre> <code class="plaintext hljs"># config.ru # https://rack.github.io/ class WorkerCollector def initialize(@app, workers: @workers); end def call(env) workers.each(&amp;:collect) @app.call(env) # call Prometheus::Exporter end end # Rack middleware DSL workers = start_workers # Array[Worker] # Run the collector before serving metrics use WorkerCollector, workers: workers use Prometheus::Middleware::Exporter</code> </pre> <br><p>  Rack ist eine Schnittstelle f√ºr Ruby-Webserver, mit der Sie mehrere Rack-Handler zu einem einzigen Endpunkt kombinieren k√∂nnen.  Der <code>config.ru</code> Befehl <code>config.ru</code> bestimmt, dass die Rack-Anwendung - wann immer sie die Anforderung empf√§ngt - den Befehl <code>collect</code> an die Handler sendet und erst dann den Prometheus-Client anweist, die Erfassungsergebnisse zu zeichnen. </p><br><p>  In unserem Diagramm aktualisieren wir die Metriken immer dann, wenn die Aufgabe abgeschlossen ist oder wenn wir eine Anfrage nach Metriken erhalten.  Aufgaben mit mehreren Abfragen senden gleicherma√üen Daten in allen Segmenten: Dies wird durch Aufgaben gezeigt, deren Dauer in Intervalle von 15 Sekunden unterteilt wurde. </p><br><p><img src="https://habrastorage.org/webt/v3/p-/ve/v3p-vekym_g0w_cnamhqxfsaaya.png"></p><br><h3 id="luchshe-li-eto">  Ist es besser </h3><br><p>  Die Verwendung von Tracer 24 Stunden am Tag wirkt sich darauf aus, wie die Aktivit√§t protokolliert wird.  Im Gegensatz zu den anf√§nglichen Messungen, die eine ‚ÄûS√§ge‚Äú zeigten, liefert das Experiment mit zehn Prozessoren ein Diagramm, das deutlich zeigt, dass jeder Prozessor in die gleichm√§√üig √ºberwachte Arbeit eingebettet ist, wenn die Anzahl der Peaks die Anzahl der laufenden Prozessoren und die Perioden dumpfer Stille √ºberschreitet. </p><br><p><img src="https://habrastorage.org/webt/a5/ng/lj/a5ngljwtmc1ppqxlpwjqdx98_eu.png"><br>  <em>Auf Vergleich basierende Metriken (links), die vom Tracer (rechts) gesteuert werden und aus einem Arbeitsexperiment stammen.</em> </p><br><p>  Verglichen mit dem offen gesagt ungenauen und chaotischen Zeitplan der anf√§nglichen Messungen sind die vom Tracer gesammelten Metriken glatt und konsistent.  Wir verkn√ºpfen die Arbeit jetzt nicht nur genau mit jeder Metrikanforderung, sondern sorgen uns auch nicht um den pl√∂tzlichen Tod eines der Handler: Prometheus zeichnet die Metriken auf, bis der Handler verschwindet, und bewertet alle seine Arbeiten. </p><br><h3 id="mozhno-li-eto-ispolzovat">  Kann das verwendet werden? </h3><br><p>  Ja!  Die <code>Tracer</code> Oberfl√§che hat sich in vielen Projekten als n√ºtzlich erwiesen. Dies ist also ein separates Ruby-Juwel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-Client-Tracer</a> .  Wenn Sie den Prometheus-Client in Ihren Ruby-Anwendungen verwenden, f√ºgen Sie einfach den <code>prometheus-client-tracer</code> zu Ihrer Gemfile hinzu: </p><br><pre> <code class="plaintext hljs">require "prometheus/client" require "prometheus/client/tracer" JobWorkedSecondsTotal = Prometheus::Client::Counter.new(...) Prometheus::Client.trace(JobWorkedSecondsTotal) do sleep(long_time) end</code> </pre> <br><p>  Wenn sich dies als n√ºtzlich f√ºr Sie herausstellt und Sie m√∂chten, dass der offizielle Prometheus Ruby-Client in <code>Tracer</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt wird</a> , hinterlassen Sie eine Bewertung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">client_ruby # 135</a> . </p><br><h3 id="nu-i-naposledok-koe-kakie-mysli">  Und zum Schluss noch ein paar Gedanken </h3><br><p>  Ich hoffe, dies hilft anderen dabei, Metriken f√ºr langfristige Aufgaben bewusster zu sammeln und eines der h√§ufigsten Probleme zu l√∂sen.  Machen Sie keinen Fehler, es ist nicht nur mit der asynchronen Verarbeitung verbunden: Wenn Ihre HTTP-Anforderungen verlangsamt werden, profitieren sie auch von der Verwendung des Tracers bei der Bewertung der f√ºr die Verarbeitung aufgewendeten Zeit. </p><br><p>  Feedback und Korrekturen sind wie gewohnt willkommen: Schreiben Sie an Twitter oder <a href="">√∂ffnen Sie PR</a> .  Wenn Sie zu Tracer Gem beitragen m√∂chten, befindet sich der Quellcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prometheus-client-tracer-ruby</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470133/">https://habr.com/ru/post/de470133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470121/index.html">Firmenprogrammierschulen oder Einstieg in die IT</a></li>
<li><a href="../de470123/index.html">Yandex.Geldfinanzfalle</a></li>
<li><a href="../de470125/index.html">Beurteilen Sie den Code eines anderen nicht streng</a></li>
<li><a href="../de470127/index.html">Komponist mit langem Kurzzeitged√§chtnis</a></li>
<li><a href="../de470129/index.html">Deklarative Speicherverwaltung</a></li>
<li><a href="../de470135/index.html">Eine interaktive Webanwendung ohne Programmierung? Einfach! Mavo in deinen Armen</a></li>
<li><a href="../de470139/index.html">2 Life Hacks: Alternativen zur klassischen Suche in Microsoft SQL Server</a></li>
<li><a href="../de470145/index.html">‚ÄûVorsicht, FAS!‚Äú: Warum ist ein milit√§risches Ticket in der Werbung gef√§hrlich, warum ist es wichtig, Mathe zu kennen und ob immer die blo√üe Wahrheit ben√∂tigt wird</a></li>
<li><a href="../de470153/index.html">Datenmodellw√∂rterbuch</a></li>
<li><a href="../de470155/index.html">Merkmale der nationalen Mustererkennung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>