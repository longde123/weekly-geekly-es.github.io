<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘 🥁 🌯 So sammeln Sie mit Prometheus Metriken, die nicht durch Zeitangaben verzerrt sind 📉 💤 👩🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Netzwerkanwendungen bestehen aus einem Webserver, der Echtzeitverkehr verarbeitet, und einem zusätzlichen Handler, der asynchron im Hintergrund ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So sammeln Sie mit Prometheus Metriken, die nicht durch Zeitangaben verzerrt sind</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/470133/"><p><img src="https://habrastorage.org/webt/-6/xs/ee/-6xseehi1ojmkxmb_phq6tr3h_a.jpeg"></p><br><p>  Viele Netzwerkanwendungen bestehen aus einem Webserver, der Echtzeitverkehr verarbeitet, und einem zusätzlichen Handler, der asynchron im Hintergrund ausgeführt wird.  Es gibt viele gute Tipps zum Überprüfen des Verkehrsstatus, und die Community hört nicht auf, Tools wie Prometheus zu entwickeln, die bei der Bewertung helfen.  Aber Handler sind manchmal nicht weniger - und noch wichtiger -.  Sie brauchen auch Aufmerksamkeit und Bewertung, aber es gibt wenig Anleitung, wie dies getan werden kann, während häufige Fallstricke vermieden werden. </p><br><p>  Dieser Artikel befasst sich mit den Traps, die bei der Bewertung asynchroner Handler am häufigsten vorkommen. Anhand eines Beispiels eines Vorfalls in einer Produktionsumgebung, in der es trotz Metriken unmöglich war, genau zu bestimmen, was die Handler taten.  Die Verwendung von Metriken hat den Fokus so sehr verschoben, dass die Metriken selbst offen gelogen haben, sagen sie, Ihre Handler zur Hölle. </p><br><p> Wir werden sehen, wie Metriken so verwendet werden, dass eine genaue Schätzung bereitgestellt wird, und abschließend werden wir die Referenzimplementierung des Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-Client-Tracers zeigen</a> , den Sie in Ihren Anwendungen verwenden können. </p><a name="habracut"></a><br><h3 id="incident">  Vorfall </h3><br><p>  Die Warnungen erreichten eine Maschinengewehrgeschwindigkeit: Die Anzahl der HTTP-Fehler stieg stark an, und die Kontrollfelder bestätigten, dass die Anforderungswarteschlangen größer wurden und die Antwortzeit abgelaufen war.  Ungefähr 2 Minuten später wurden die Warteschlangen gelöscht und alles normalisiert. </p><br><p>  Bei näherer Betrachtung stellte sich heraus, dass unsere API-Server aufstanden und auf eine DB-Antwort warteten, die dazu führte, dass sie blockierten und plötzlich alle Aktivitäten aufnahmen.  Und wenn man bedenkt, dass die schwerste Last häufiger auf asynchrone Prozessoren fällt, sind sie zu den Hauptverdächtigen geworden.  Die logische Frage war: Was machen sie dort überhaupt ?! </p><br><p>  Die Prometheus-Metrik zeigt, wie lange der Prozess dauert. Hier ist er: </p><br><pre><code class="plaintext hljs"># HELP job_worked_seconds_total Sum of the time spent processing each job class # TYPE job_worked_seconds_total counter job_worked_seconds_total{job}</code> </pre> <br><p>  Indem wir die Gesamtausführungszeit jeder Aufgabe und die Häufigkeit verfolgen, mit der sich die Metrik ändert, ermitteln wir, wie viel Arbeitszeit aufgewendet wurde.  Wenn für einen Zeitraum von 15 Sekunden.  Wenn die Anzahl um 15 erhöht wird, bedeutet dies, dass 1 Handler beschäftigt ist (eine Sekunde für jede letzte Sekunde), während eine Erhöhung um 30 2 Handler usw. bedeutet. </p><br><p>  Ein Arbeitsplan während des Vorfalls zeigt, was uns bevorsteht.  Die Ergebnisse sind enttäuschend;  Der Zeitpunkt des Vorfalls (16: 02–16: 04) ist durch die alarmierende rote Linie gekennzeichnet: </p><br><p><img src="https://habrastorage.org/webt/33/1u/bc/331ubcimex4xb4hm_zdondnxcnw.png"><br>  <em>Handleraktivität während des Vorfalls: Eine merkliche Lücke ist sichtbar.</em> </p><br><p>  Es war für mich als Person, die nach diesem Albtraum debuggte, schmerzhaft zu sehen, dass die Aktivitätskurve gerade während des Vorfalls ganz unten war.  Dies ist die Zeit für die Arbeit mit Web-Hooks, in denen wir 20 dedizierte Handler haben.  Aus den Protokollen weiß ich, dass sie alle im Geschäft waren, und ich erwartete, dass die Kurve bei etwa 20 Sekunden liegen würde, und ich sah eine fast gerade Linie.  Sehen Sie außerdem diesen großen blauen Gipfel um 16:05 Uhr?  Gemessen am Zeitplan verbrachten 20 Single-Threaded-Prozessoren 45 Sekunden.  für jede Sekunde der Aktivität, aber ist das möglich ?! </p><br><h3 id="gde-i-chto-poshlo-ne-tak">  Wo und was ist schief gelaufen? </h3><br><p>  Der Zeitplan des Vorfalls lügt: Er verbirgt die Arbeitsaktivität und zeigt gleichzeitig das Überflüssige - je nachdem, wo gemessen werden soll.  Um herauszufinden, warum dies geschieht, müssen Sie die Implementierung der Metrikverfolgung und deren Interaktion mit Prometheus berücksichtigen. </p><br><p>  Beginnend mit der Erfassung von Metriken durch Handler können Sie ein ungefähres Workflow-Implementierungsschema skizzieren (siehe unten).  Hinweis: Handler aktualisieren Metriken erst <em>nach Abschluss einer Aufgabe</em> . </p><br><pre> <code class="plaintext hljs">class Worker JobWorkedSecondsTotal = Prometheus::Client::Counter.new(...) def work job = acquire_job start = Time.monotonic_now job.run ensure # run after our main method block duration = Time.monotonic_now - start JobWorkedSecondsTotal.increment(by: duration, labels: { job: job.class }) end end</code> </pre> <br><p>  Prometheus (mit seiner Philosophie, Metriken zu extrahieren) sendet alle 15 Sekunden eine GET-Anfrage an jeden Handler und zeichnet die Werte der Metriken zum Zeitpunkt der Anfrage auf.  Handler aktualisieren ständig die Metriken abgeschlossener Aufgaben, und im Laufe der Zeit können wir die Dynamik von Wertänderungen grafisch darstellen. </p><br><p>  Das Problem mit Unter- und Neubewertung tritt immer dann auf, wenn die Zeit, die zum Ausführen einer Aufgabe benötigt wird, die Wartezeit für eine Anforderung überschreitet, die alle 15 Sekunden eintrifft.  Beispielsweise beginnt eine Aufgabe 5 Sekunden vor der Anforderung und endet 1 Sekunde danach.  Ganz und gar dauert es 6 Sekunden, aber diese Zeit ist nur sichtbar, wenn die nach der Anforderung getätigten Zeitkosten geschätzt werden, während 5 dieser 6 Sekunden vor der Anforderung verbracht wurden. </p><br><p>  Die Indikatoren sind noch gottloser, wenn die Aufgaben länger als der Berichtszeitraum (15 Sekunden) dauern. Während der Ausführung der Aufgabe für 1 Minute hat Prometheus Zeit, 4 Anforderungen an die Prozessoren zu senden, aber die Metrik wird erst nach der vierten aktualisiert. </p><br><p>  Nachdem wir einen Zeitplan für die Arbeitsaktivität erstellt haben, werden wir sehen, wie sich der Moment der Aktualisierung der Metrik auf das auswirkt, was Prometheus sieht.  In der folgenden Abbildung teilen wir die Zeitachse zweier Handler in mehrere Segmente auf, in denen Aufgaben unterschiedlicher Dauer angezeigt werden.  Rote (15 Sekunden) und blaue (30 Sekunden) Tags zeigen 2 Prometheus-Datenproben an.  Die Aufgaben, die als Datenquelle für die Bewertung dienten, sind jeweils farblich hervorgehoben. </p><br><p><img src="https://habrastorage.org/webt/ph/lc/z6/phlcz67lq7o3tpar3vgibp71h9o.png"></p><br><p>  Unabhängig davon, was die Handler bei Volllast tun, erledigen sie alle 15 Sekunden 30 Sekunden Arbeit.  Da Prometheus die Arbeit erst nach Abschluss sieht, wurden nach den Metriken 14 Sekunden Arbeit im ersten Zeitintervall und 42 Sekunden im zweiten Zeitintervall erledigt.  Wenn jeder Handler eine umfangreiche Aufgabe übernimmt, werden wir auch nach einigen Stunden bis zum Ende keine Berichte darüber sehen, dass die Arbeit läuft. </p><br><p>  Um diesen Effekt zu demonstrieren, führte ich ein Experiment mit zehn Handlern durch, die an Aufgaben beteiligt waren, deren Länge unterschiedlich und halbnormal zwischen 0,1 Sekunden und einem etwas höheren Wert verteilt war (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zufällige Aufgaben</a> ).  Unten sind 3 Diagramme dargestellt, die die Arbeitsaktivität darstellen.  Die Zeitdauer wird in aufsteigender Reihenfolge angezeigt. </p><br><p><img src="https://habrastorage.org/webt/6o/bx/jh/6obxjhklfq8sxwhdbjrzpnsgcmm.png"><br>  <em>Aufgaben bis zu 1 Sekunde.</em> </p><br><p>  Die erste Grafik zeigt, dass jeder Handler in jeder Sekunde ungefähr 1 Sekunde Arbeit erledigt - dies ist auf flachen Linien sichtbar, und der Gesamtarbeitsaufwand entspricht unseren Fähigkeiten (10 Handler geben eine Sekunde Arbeit pro Sekunde Zeit aus).  Tatsächlich erwarten wir dies unabhängig von der Länge der Aufgabe: Gerade bei kurzen und langen Aufgaben sollten Prozessoren mit konstanter Last so viel ausgeben. </p><br><p><img src="https://habrastorage.org/webt/x-/lj/zp/x-ljzpfv-jdybqpk-osmcfd3rui.png"><br>  <em>Aufgaben bis zu 15 Sekunden.</em> </p><br><p>  Die Dauer der Aufgaben nimmt zu, und im Zeitplan wird ein Durcheinander angezeigt: Wir haben immer noch 10 Prozessoren, die alle voll belegt sind, aber die Gesamtmenge der Arbeit überspringt - entweder niedriger oder höher als die Grenze der Nutzkapazität (10 Sekunden). </p><br><p><img src="https://habrastorage.org/webt/uo/cc/mh/uoccmht2erjrgjywbvlo7sn6-tk.png"><br>  <em>Aufgaben bis zu 30 Sekunden.</em> </p><br><p>  Die Bewertung von Arbeiten mit einer Dauer von bis zu 30 Sekunden ist einfach lächerlich.  Eine zeitgebundene Metrik zeigt für die längsten Aufgaben keine Aktivität an und zeichnet uns erst nach Abschluss der Aufgaben Aktivitätsspitzen. </p><br><h3 id="vosstanovim-doverie">  Stellen Sie das Vertrauen wieder her </h3><br><p>  Dies hat uns nicht gereicht, daher gibt es ein weiteres, viel heimtückischeres Problem mit diesen langfristigen Aufgaben, die unsere Metriken beeinträchtigen.  Wann immer eine langfristige Aufgabe abgeschlossen ist - beispielsweise wenn Kubernetes einen Pod aus einem Pool wirft oder wenn ein Knoten stirbt, was passiert dann mit den Metriken?  Es lohnt sich, sie sofort nach Abschluss der Aufgabe zu aktualisieren, da sie zeigen, dass <strong>sie die</strong> Arbeit <strong>überhaupt nicht erledigt haben</strong> . </p><br><p>  Metriken sollten nicht lügen.  Der Laptop heult ungläubig und verursacht existenziellen Horror. Überwachungstools, die das Bild der Welt verzerren, sind eine Falle und für die Arbeit ungeeignet. </p><br><p>  Glücklicherweise ist die Angelegenheit behebbar.  Datenverzerrungen treten auf, weil Prometheus Messungen vornimmt, unabhängig davon, wann Prozessoren Metriken aktualisieren.  Wenn wir die Handler bitten, die Metriken zu aktualisieren, wenn Prometheus Anforderungen sendet, werden wir feststellen, dass Prometheus nicht mehr eigenartig ist und die aktuelle Aktivität anzeigt. </p><br><h3 id="predstavlyaem-tracer">  Wir stellen vor ... Tracer </h3><br><p>  Eine Lösung für das Problem der verzerrten Metriken ist der <code>Tracer</code> , ein abstrakt gestalteter <code>Tracer</code> , der die Aktivität bei Aufgaben mit langer Laufzeit bewertet, indem Prometheus-bezogene Metriken schrittweise aktualisiert werden. </p><br><pre> <code class="plaintext hljs">class Tracer def trace(metric, labels, &amp;block) ... end def collect(traces = @traces) ... end end</code> </pre> <br><p>  Tracer bieten eine Verfolgungsmethode, die die Prometheus-Metriken und die zu verfolgende Aufgabe übernimmt.  Der Befehl <code>trace</code> führt den angegebenen Block aus (anonyme Ruby-Funktionen) und stellt sicher, dass Anforderungen an <code>tracer.collect</code> während der Ausführung die zugehörigen Metriken schrittweise aktualisieren, unabhängig davon, wie viel Zeit seit der letzten Anforderung zum <code>collect</code> vergangen ist. </p><br><p>  Wir müssen den <code>tracer</code> mit den Handlern verbinden, um die Dauer der Aufgabe und den Endpunkt zu verfolgen, der die Prometheus-Metrikanforderungen bedient.  Wir beginnen mit den Handlern, initialisieren einen neuen Tracer und bitten ihn, die Ausführung von <code>acquire_job.run</code> . </p><br><pre> <code class="plaintext hljs">class Worker def initialize @tracer = Tracer.new(self) end def work @tracer.trace(JobWorkedSecondsTotal, labels) { acquire_job.run } end # Tell the tracer to flush (incremental) trace progress to metrics def collect @tracer.collect end end</code> </pre> <br><p>  Zu diesem Zeitpunkt aktualisiert der Tracer die Metriken nur in Sekunden, die für die abgeschlossene Aufgabe aufgewendet wurden - wie bei der ersten Implementierung der Metriken.  Wir müssen den Tracer bitten, unsere Metriken zu aktualisieren, bevor wir eine Anfrage von Prometheus ausführen.  Dies kann durch Einrichten des Middleware-Racks erfolgen. </p><br><pre> <code class="plaintext hljs"># config.ru # https://rack.github.io/ class WorkerCollector def initialize(@app, workers: @workers); end def call(env) workers.each(&amp;:collect) @app.call(env) # call Prometheus::Exporter end end # Rack middleware DSL workers = start_workers # Array[Worker] # Run the collector before serving metrics use WorkerCollector, workers: workers use Prometheus::Middleware::Exporter</code> </pre> <br><p>  Rack ist eine Schnittstelle für Ruby-Webserver, mit der Sie mehrere Rack-Handler zu einem einzigen Endpunkt kombinieren können.  Der <code>config.ru</code> Befehl <code>config.ru</code> bestimmt, dass die Rack-Anwendung - wann immer sie die Anforderung empfängt - den Befehl <code>collect</code> an die Handler sendet und erst dann den Prometheus-Client anweist, die Erfassungsergebnisse zu zeichnen. </p><br><p>  In unserem Diagramm aktualisieren wir die Metriken immer dann, wenn die Aufgabe abgeschlossen ist oder wenn wir eine Anfrage nach Metriken erhalten.  Aufgaben mit mehreren Abfragen senden gleichermaßen Daten in allen Segmenten: Dies wird durch Aufgaben gezeigt, deren Dauer in Intervalle von 15 Sekunden unterteilt wurde. </p><br><p><img src="https://habrastorage.org/webt/v3/p-/ve/v3p-vekym_g0w_cnamhqxfsaaya.png"></p><br><h3 id="luchshe-li-eto">  Ist es besser </h3><br><p>  Die Verwendung von Tracer 24 Stunden am Tag wirkt sich darauf aus, wie die Aktivität protokolliert wird.  Im Gegensatz zu den anfänglichen Messungen, die eine „Säge“ zeigten, liefert das Experiment mit zehn Prozessoren ein Diagramm, das deutlich zeigt, dass jeder Prozessor in die gleichmäßig überwachte Arbeit eingebettet ist, wenn die Anzahl der Peaks die Anzahl der laufenden Prozessoren und die Perioden dumpfer Stille überschreitet. </p><br><p><img src="https://habrastorage.org/webt/a5/ng/lj/a5ngljwtmc1ppqxlpwjqdx98_eu.png"><br>  <em>Auf Vergleich basierende Metriken (links), die vom Tracer (rechts) gesteuert werden und aus einem Arbeitsexperiment stammen.</em> </p><br><p>  Verglichen mit dem offen gesagt ungenauen und chaotischen Zeitplan der anfänglichen Messungen sind die vom Tracer gesammelten Metriken glatt und konsistent.  Wir verknüpfen die Arbeit jetzt nicht nur genau mit jeder Metrikanforderung, sondern sorgen uns auch nicht um den plötzlichen Tod eines der Handler: Prometheus zeichnet die Metriken auf, bis der Handler verschwindet, und bewertet alle seine Arbeiten. </p><br><h3 id="mozhno-li-eto-ispolzovat">  Kann das verwendet werden? </h3><br><p>  Ja!  Die <code>Tracer</code> Oberfläche hat sich in vielen Projekten als nützlich erwiesen. Dies ist also ein separates Ruby-Juwel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-Client-Tracer</a> .  Wenn Sie den Prometheus-Client in Ihren Ruby-Anwendungen verwenden, fügen Sie einfach den <code>prometheus-client-tracer</code> zu Ihrer Gemfile hinzu: </p><br><pre> <code class="plaintext hljs">require "prometheus/client" require "prometheus/client/tracer" JobWorkedSecondsTotal = Prometheus::Client::Counter.new(...) Prometheus::Client.trace(JobWorkedSecondsTotal) do sleep(long_time) end</code> </pre> <br><p>  Wenn sich dies als nützlich für Sie herausstellt und Sie möchten, dass der offizielle Prometheus Ruby-Client in <code>Tracer</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt wird</a> , hinterlassen Sie eine Bewertung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">client_ruby # 135</a> . </p><br><h3 id="nu-i-naposledok-koe-kakie-mysli">  Und zum Schluss noch ein paar Gedanken </h3><br><p>  Ich hoffe, dies hilft anderen dabei, Metriken für langfristige Aufgaben bewusster zu sammeln und eines der häufigsten Probleme zu lösen.  Machen Sie keinen Fehler, es ist nicht nur mit der asynchronen Verarbeitung verbunden: Wenn Ihre HTTP-Anforderungen verlangsamt werden, profitieren sie auch von der Verwendung des Tracers bei der Bewertung der für die Verarbeitung aufgewendeten Zeit. </p><br><p>  Feedback und Korrekturen sind wie gewohnt willkommen: Schreiben Sie an Twitter oder <a href="">öffnen Sie PR</a> .  Wenn Sie zu Tracer Gem beitragen möchten, befindet sich der Quellcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prometheus-client-tracer-ruby</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470133/">https://habr.com/ru/post/de470133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470121/index.html">Firmenprogrammierschulen oder Einstieg in die IT</a></li>
<li><a href="../de470123/index.html">Yandex.Geldfinanzfalle</a></li>
<li><a href="../de470125/index.html">Beurteilen Sie den Code eines anderen nicht streng</a></li>
<li><a href="../de470127/index.html">Komponist mit langem Kurzzeitgedächtnis</a></li>
<li><a href="../de470129/index.html">Deklarative Speicherverwaltung</a></li>
<li><a href="../de470135/index.html">Eine interaktive Webanwendung ohne Programmierung? Einfach! Mavo in deinen Armen</a></li>
<li><a href="../de470139/index.html">2 Life Hacks: Alternativen zur klassischen Suche in Microsoft SQL Server</a></li>
<li><a href="../de470145/index.html">„Vorsicht, FAS!“: Warum ist ein militärisches Ticket in der Werbung gefährlich, warum ist es wichtig, Mathe zu kennen und ob immer die bloße Wahrheit benötigt wird</a></li>
<li><a href="../de470153/index.html">Datenmodellwörterbuch</a></li>
<li><a href="../de470155/index.html">Merkmale der nationalen Mustererkennung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>