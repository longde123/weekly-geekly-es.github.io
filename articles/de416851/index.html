<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèº üë®üèº‚Äç‚úàÔ∏è üë∏üèæ Ruhezustand - wor√ºber die Tutorials schweigen ü§∏üèæ ü§üüèΩ üå°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel behandelt nicht die Grundlagen des Ruhezustands (Definieren einer Entit√§t oder Schreiben von Kriterienabfragen). Hier werde ich versuch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ruhezustand - wor√ºber die Tutorials schweigen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Dieser Artikel behandelt nicht die Grundlagen des Ruhezustands (Definieren einer Entit√§t oder Schreiben von Kriterienabfragen).  Hier werde ich versuchen, √ºber interessantere Punkte zu sprechen, die bei der Arbeit wirklich n√ºtzlich sind.  Informationen, die ich nicht an einem Ort getroffen habe. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="Bild"><br><a name="habracut"></a><br>  Ich werde sofort reservieren.  Alle folgenden Aussagen gelten f√ºr Hibernate 5.2.  Fehler sind auch m√∂glich, weil ich etwas falsch verstanden habe.  Wenn Sie finden - schreiben Sie. <br><br><h2>  Probleme beim Zuordnen eines Objektmodells zu einem relationalen Modell </h2><br>  Beginnen wir jedoch mit den Grundlagen von ORM.  ORM - Objekt-relationales Mapping - dementsprechend haben wir relationale und Objektmodelle.  Und wenn wir uns gegenseitig anzeigen, gibt es Probleme, die wir selbst l√∂sen m√ºssen.  Nehmen wir sie auseinander. <br><br>  Nehmen wir zur Veranschaulichung das folgende Beispiel: Wir haben die Entit√§t "Benutzer", die entweder ein Jedi oder ein Angriffsflugzeug sein kann.  Die Jedi m√ºssen St√§rke und die Spezialisierung der Angriffsflugzeuge haben.  Unten ist ein Klassendiagramm. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="Bild"><br><br><h3>  Problem 1. Vererbung und polymorphe Abfragen. </h3><br>  Es gibt Vererbung im Objektmodell, aber nicht im relationalen Modell.  Dementsprechend ist dies das erste Problem - wie die Vererbung dem relationalen Modell korrekt zugeordnet werden kann. <br><br>  Der Ruhezustand bietet drei Optionen zum Anzeigen eines solchen Objektmodells: <br><br><ol><li>  Alle Erben befinden sich in derselben Tabelle: <br>  <b>@Inheritance (Strategie = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="Bild"><br><br>  In diesem Fall liegen die gemeinsamen Felder und die Felder der Erben in einer Tabelle.  Mit dieser Strategie vermeiden wir Verkn√ºpfungen bei der Auswahl von Entit√§ten.  Von den Minuspunkten ist anzumerken, dass wir erstens die Einschr√§nkung ‚ÄûNOT NULL‚Äú f√ºr die Spalte ‚Äûforce‚Äú im relationalen Modell nicht festlegen k√∂nnen und zweitens die dritte Normalform verlieren.  (Eine transitive Abh√§ngigkeit von Nicht-Schl√ºsselattributen wird angezeigt: Kraft und Disc). <br><br>  √úbrigens, auch aus diesem Grund gibt es zwei M√∂glichkeiten, eine Feldbeschr√§nkung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ungleich</a> Null anzugeben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">NotNull</a> ist f√ºr die Validierung verantwortlich.  @Column (nullable = true) - verantwortlich f√ºr die Nicht-Null-Einschr√§nkung in der Datenbank. <br><br>  Meiner Meinung nach ist dies der beste Weg, ein Objektmodell einem relationalen Modell zuzuordnen. <br></li><li>  Entit√§tsspezifische Felder befinden sich in einer separaten Tabelle. <br><br>  <b>@Inheritance (Strategie = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="Bild"><br><br>  In diesem Fall werden allgemeine Felder in einer gemeinsamen Tabelle und spezifische f√ºr untergeordnete Entit√§ten in separaten Tabellen gespeichert.  Mit dieser Strategie erhalten wir bei der Auswahl einer Entit√§t einen JOIN. Jetzt speichern wir die dritte Normalform und k√∂nnen auch eine NOT NULL-Einschr√§nkung in der Datenbank angeben. </li><li>  Jede Entit√§t hat eine eigene Tabelle. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="Bild"><br><br>  In diesem Fall haben wir keine gemeinsame Tabelle.  Mit dieser Strategie verwenden wir UNION f√ºr polymorphe Abfragen.  Wir haben Probleme mit Prim√§rschl√ºsselgeneratoren und anderen Integrit√§tsbeschr√§nkungen.  Von dieser Art der Vererbungszuordnung wird dringend abgeraten. </li></ol><br>  F√ºr alle F√§lle erw√§hne ich die Anmerkung - @MappedSuperclass.  Es wird verwendet, wenn Sie allgemeine Felder f√ºr mehrere Entit√§ten des Objektmodells ‚Äûausblenden‚Äú m√∂chten.  Dar√ºber hinaus wird die mit Anmerkungen versehene Klasse selbst nicht als separate Einheit betrachtet. <br><br><h3>  Problem 2. Zusammensetzungsverh√§ltnis in OOP </h3><br>  Zur√ºck zu unserem Beispiel stellen wir fest, dass wir im Objektmodell das Benutzerprofil in eine separate Entit√§t - Profil - aufgenommen haben.  Im relationalen Modell haben wir jedoch keine separate Tabelle daf√ºr ausgew√§hlt. <br><br>  Die OneToOne-Einstellung ist oft eine schlechte Praxis, weil  In select haben wir einen ungerechtfertigten JOIN (in den meisten F√§llen haben wir sogar fetchType = LAZY, wir werden JOIN haben - wir werden dieses Problem sp√§ter diskutieren). <br><br>  Es gibt @ Embedable- und @ Embeded-Annotationen, um eine Komposition in einer gemeinsamen Tabelle anzuzeigen.  Der erste befindet sich √ºber dem Feld und der zweite √ºber der Klasse.  Sie sind austauschbar. <br><br><h2>  Entity Manager </h2><br>  Jede Instanz von EntityManager (EM) definiert eine Interaktionssitzung mit der Datenbank.  Innerhalb einer EM-Instanz gibt es einen Cache der ersten Ebene.  Hier werde ich die folgenden wichtigen Punkte hervorheben: <br><br><ol><li>  <b>Erfassen der Datenbankverbindung</b> <br><br>  Dies ist nur ein interessanter Punkt.  Der Ruhezustand erfasst die Verbindung nicht zum Zeitpunkt des Empfangs der EM, sondern beim ersten Zugriff auf die Datenbank oder beim √ñffnen der Transaktion (obwohl dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gel√∂st werden kann</a> ).  Dies geschieht, um die Zeit der besetzten Verbindung zu verk√ºrzen.  W√§hrend des Empfangs von EM-a wird das Vorhandensein einer JTA-Transaktion √ºberpr√ºft. </li><li>  <b>Persistierte Entit√§ten haben immer eine ID</b> </li><li>  <b>Entit√§ten, die eine Zeile in der Datenbank beschreiben, entsprechen als Referenz</b> <br>  Wie oben erw√§hnt, verf√ºgt EM √ºber einen Cache der ersten Ebene. Die darin enthaltenen Objekte werden anhand der Referenz verglichen.  Dementsprechend stellt sich die Frage: Welche Felder sollten verwendet werden, um Gleichheit und Hashcode zu √ºberschreiben?  Betrachten Sie die folgenden Optionen: <br><br><ul><li>  Verwenden Sie alle Felder.  Schlechte Idee  Gleiches kann LAZY-Felder beeinflussen.  Dies gilt √ºbrigens auch f√ºr die toString-Methode. </li><li>  Verwenden Sie nur die ID.  Eine normale Idee, aber es gibt auch Nuancen.  Da id f√ºr neue Entit√§ten meistens einen Generator zum Zeitpunkt des Fortbestehens setzt.  Folgende Situation ist m√∂glich: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Verwenden Sie einen Gesch√§ftsschl√ºssel (ungef√§hr Felder, die eindeutig und NICHT NULL sind).  Diese Option ist jedoch nicht immer praktisch. <br><br>  √úbrigens, da es sich um NOT NULL und UNIQUE handelt, ist es manchmal praktisch, einen √∂ffentlichen Konstruktor mit NOT NULL-Argumenten zu erstellen, und der Konstruktor ohne Argumente ist gesch√ºtzt. </li><li>  √úberschreiben Sie nicht gleich und Hashcode √ºberhaupt. </li></ul></li><li>  <b>Wie Flush funktioniert</b> <br>  Flush - f√ºhrt akkumulierte Einf√ºgungen, Aktualisierungen und L√∂schvorg√§nge in der Datenbank aus.  Standardm√§√üig wird Flush in folgenden F√§llen ausgef√ºhrt: <br><br><ul><li>  Vor dem Ausf√ºhren der Abfrage (mit Ausnahme von em.get) ist dies erforderlich, um das ACID-Prinzip einzuhalten.  Zum Beispiel: Wir haben das Geburtsdatum des Angriffsflugzeugs ge√§ndert und wollten dann die Anzahl der Angriffsflugzeuge f√ºr Erwachsene ermitteln. <br><br>  Wenn es sich um CriteriaQuery oder JPQL handelt, wird Flush ausgef√ºhrt, wenn die Abfrage eine Tabelle betrifft, deren Entit√§ten sich im Cache der ersten Ebene befinden. </li><li>  Beim Festschreiben einer Transaktion; </li><li>  Manchmal, wenn eine neue Entit√§t beibehalten wird - in dem Fall, dass wir ihre ID nur durch Einf√ºgen erhalten k√∂nnen. </li></ul><br>  Und jetzt ein kleiner Test.  Wie viele UPDATE-Operationen werden in diesem Fall ausgef√ºhrt? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Eine interessante Funktion f√ºr den Ruhezustand ist unter dem Flush-Vorgang verborgen. Sie versucht, die Zeit zu verk√ºrzen, die zum Sperren von Zeilen in der Datenbank erforderlich ist. <br><br>  Beachten Sie auch, dass es unterschiedliche Strategien f√ºr den Sp√ºlvorgang gibt.  Sie k√∂nnen beispielsweise das Zusammenf√ºhren von √Ñnderungen an der Datenbank verbieten - dies wird als MANUAL bezeichnet (es deaktiviert auch den Mechanismus zur √úberpr√ºfung von Verschmutzungen). <br></li><li>  <b>Schmutzige √úberpr√ºfung</b> <br><br>  Dirty Checking ist ein Mechanismus, der w√§hrend eines Sp√ºlvorgangs ausgef√ºhrt wird.  Der Zweck besteht darin, ge√§nderte Entit√§ten zu finden und zu aktualisieren.  Um einen solchen Mechanismus zu implementieren, muss der Ruhezustand die Originalkopie des Objekts speichern (womit das tats√§chliche Objekt verglichen wird).  Genauer gesagt speichert der Ruhezustand eine Kopie der Felder des Objekts, nicht des Objekts selbst. <br><br>  Es ist anzumerken, dass der Vorgang der schmutzigen Pr√ºfung teuer sein kann, wenn der Graph der Entit√§ten gro√ü ist.  Vergessen Sie nicht, dass im Ruhezustand 2 Kopien von Entit√§ten gespeichert werden (ungef√§hr). <br>  Verwenden Sie die folgenden Funktionen, um die Kosten dieses Prozesses zu senken: <br><br><ul><li>  em.detach / em.clear - Entit√§ten von EntityManager trennen </li><li>  FlushMode = MANUAL - n√ºtzlich bei Lesevorg√§ngen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Unver√§nderlich</a> - vermeidet auch schmutzige √úberpr√ºfungsvorg√§nge </li></ul><br></li><li>  <b>Transaktionen</b> <br><br>  Wie Sie wissen, k√∂nnen Sie im Ruhezustand Entit√§ten nur innerhalb einer Transaktion aktualisieren.  Lesevorg√§nge bieten mehr Freiheit - wir k√∂nnen sie ausf√ºhren, ohne eine Transaktion explizit zu √∂ffnen.  Aber genau das ist die Frage: Lohnt es sich, eine Transaktion explizit f√ºr Lesevorg√§nge zu √∂ffnen? <br><br>  Ich werde einige Fakten anf√ºhren: <br><br><ul><li>  Jede Anweisung wird in der Datenbank innerhalb der Transaktion ausgef√ºhrt.  Auch wenn wir es offensichtlich nicht ge√∂ffnet haben.  (Auto-Commit-Modus). </li><li>  In der Regel sind wir nicht auf eine Abfrage an die Datenbank beschr√§nkt.  Beispiel: Um die ersten 10 Datens√§tze abzurufen, m√∂chten Sie wahrscheinlich die Gesamtzahl der Datens√§tze zur√ºckgeben.  Und das sind fast immer 2 Anfragen. </li><li>  Wenn es sich um Federdaten handelt, sind die Repository-Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">standardm√§√üig</a> transaktional, w√§hrend die Lesemethoden schreibgesch√ºtzt sind. </li><li>  Die Annotation @Transactional Spring (readOnly = true) wirkt sich auch auf den FlushMode aus, genauer gesagt, Spring versetzt ihn in den Status MANUAL, sodass der Ruhezustand keine Schmutzpr√ºfung durchf√ºhrt. </li><li>  Synthetische Tests mit einer oder zwei Datenbankabfragen zeigen, dass das automatische Festschreiben schneller ist.  Im Kampfmodus ist dies jedoch m√∂glicherweise nicht der Fall.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichneter Artikel zu diesem Thema</a> , + siehe Kommentare) </li></ul><br>  Kurz gesagt: Es wird empfohlen, in einer Transaktion eine Kommunikation mit der Datenbank durchzuf√ºhren. <br></li></ol><br><h2>  Generatoren </h2><br>  Generatoren werden ben√∂tigt, um zu beschreiben, wie die Prim√§rschl√ºssel unserer Entit√§ten Werte erhalten.  Lassen Sie uns kurz die Optionen durchgehen: <br><br><ul><li>  <b>GenerationType.AUTO</b> - Die Auswahl des Generators basiert auf dem Dialekt.  Nicht die beste Option, da hier nur die Regel ‚Äûexplizit ist besser als implizit‚Äú gilt. </li><li>  <b>GenerationType.IDENTITY</b> ist der einfachste Weg, einen Generator zu konfigurieren.  Es basiert auf der Spalte f√ºr die automatische Inkrementierung in der Tabelle.  Um id mit persist zu erhalten, m√ºssen wir daher einf√ºgen.  Aus diesem Grund wird die M√∂glichkeit einer verz√∂gerten Persistenz und damit einer Chargenbildung ausgeschlossen. </li><li>  <b>GenerationType.SEQUENCE</b> ist der bequemste Fall, wenn wir die ID aus der Sequenz erhalten. </li><li>  <b>GenerationType.TABLE</b> - In diesem Fall emuliert der Ruhezustand eine Sequenz √ºber eine zus√§tzliche Tabelle.  Nicht die beste Option, weil  In einer solchen L√∂sung muss der Ruhezustand eine separate Transaktion verwenden und pro Zeile sperren. </li></ul><br>  Lassen Sie uns etwas mehr √ºber die Sequenz sprechen.  Um die Betriebsgeschwindigkeit zu erh√∂hen, verwendet der Ruhezustand verschiedene Optimierungsalgorithmen.  Alle zielen darauf ab, die Anzahl der Gespr√§che mit der Datenbank (die Anzahl der Hin- und R√ºckfahrten) zu reduzieren.  Schauen wir sie uns genauer an: <br><br><ul><li>  <b>keine</b> - keine Optimierungen.  F√ºr jede ID ziehen wir eine Sequenz. </li><li>  <b>gepoolt und gepoolt</b> - in diesem Fall sollte sich unsere Sequenz um ein bestimmtes Intervall erh√∂hen - N in der Datenbank (SequenceGenerator.allocationSize).  Und in der Anwendung haben wir einen bestimmten Pool, die Werte, aus denen wir neuen Entit√§ten zuweisen k√∂nnen, ohne auf die Datenbank zuzugreifen. </li><li>  <b>hilo</b> - <b>Um</b> eine ID zu generieren, verwendet der hilo-Algorithmus zwei Zahlen: hi (in der Datenbank gespeichert - der Wert, der aus dem Sequenzaufruf erhalten wurde) und lo (nur in der Anwendung gespeichert - SequenceGenerator.allocationSize).  Basierend auf diesen Zahlen wird das Intervall zum Erzeugen der ID wie folgt berechnet: [(hi - 1) * lo + 1, hi * lo + 1).  Aus offensichtlichen Gr√ºnden wird dieser Algorithmus als veraltet angesehen und es wird nicht empfohlen, ihn zu verwenden. </li></ul><br>  Nun wollen wir sehen, wie der Optimierer ausgew√§hlt wird.  Der Ruhezustand verf√ºgt √ºber mehrere Sequenzgeneratoren.  Wir werden an 2 von ihnen interessiert sein: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> ist ein alter Generator, der den Hilo-Optimierer verwendet.  Standardm√§√üig ausgew√§hlt, wenn die Eigenschaft hibernate.id.new_generator_mappings == false vorhanden ist. </li><li>  <b>SequenceStyleGenerator</b> - wird standardm√§√üig verwendet (wenn die Eigenschaft hibernate.id.new_generator_mappings == true ist).  Dieser Generator unterst√ºtzt mehrere Optimierer, aber die Standardeinstellung ist zusammengefasst. </li></ul><br>  Sie k√∂nnen auch die Generator-Annotation @GenericGenerator konfigurieren. <br><br><h2>  Deadlock </h2><br>  Schauen wir uns ein Beispiel f√ºr eine Pseudocode-Situation an, die zu einem Deadlock f√ºhren kann: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Um solche Probleme zu vermeiden, verf√ºgt der Ruhezustand √ºber einen Mechanismus, der Deadlocks dieses Typs vermeidet - den Parameter hibernate.order_updates.  In diesem Fall werden alle Aktualisierungen nach ID sortiert und ausgef√ºhrt.  Ich werde auch noch einmal erw√§hnen, dass der Ruhezustand versucht, die Erfassung der Verbindung und die Ausf√ºhrung von Einf√ºgungen und Aktualisierungen zu "verz√∂gern". <br><br><h2>  Set, Tasche, Liste </h2><br>  Hibernate bietet drei M√∂glichkeiten, um die OneToMany-Kommunikationssammlung zu pr√§sentieren. <br><br><ul><li>  Set - eine ungeordnete Menge von Entit√§ten ohne Wiederholungen; </li><li>  Tasche - eine ungeordnete Gruppe von Entit√§ten; </li><li>  Liste ist eine geordnete Menge von Entit√§ten. </li></ul><br>  Es gibt keine Klasse f√ºr Bag im Java-Kern, die eine solche Struktur beschreiben w√ºrde.  Daher sind alle Listen und Sammlungen Taschen, es sei denn, Sie geben eine Spalte an, nach der unsere Sammlung sortiert wird (OrderColumn-Annotation. Nicht zu verwechseln mit SortBy).  Ich empfehle dringend, die OrderColumn-Annotation nicht zu verwenden, da die Funktionen (meiner Meinung nach) schlecht implementiert sind - keine optimalen SQL-Abfragen, m√∂gliche NULL-Werte im Blatt. <br><br>  Die Frage stellt sich, aber was ist besser, Tasche oder Set zu verwenden?  Bei der Verwendung einer Tasche sind zun√§chst folgende Probleme m√∂glich: <br><br><ul><li>  Wenn Ihre Version des Ruhezustands niedriger als 5.0.8 ist, gibt es beim Einf√ºgen einer untergeordneten Entit√§t einen ziemlich schwerwiegenden Fehler - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HHH-5855</a> -, dessen Duplizierung m√∂glich ist (im Fall von cascadType = MERGE und PERSIST). </li><li>  Wenn Sie bag f√ºr die ManyToMany-Beziehung verwenden, generiert der Ruhezustand beim L√∂schen einer Entit√§t aus der Sammlung √§u√üerst unangemessene Abfragen. Zuerst werden alle Zeilen aus der Verkn√ºpfungstabelle entfernt und anschlie√üend wird eine Einf√ºgung ausgef√ºhrt. </li><li>  Der Ruhezustand kann nicht mehrere Beutel f√ºr dieselbe Entit√§t gleichzeitig abrufen. </li></ul><br>  Wenn Sie der @ OneToMany-Verbindung eine weitere Entit√§t hinzuf√ºgen m√∂chten, ist die Verwendung von Bag rentabler, da  F√ºr diesen Vorgang m√ºssen nicht alle zugeh√∂rigen Entit√§ten geladen werden.  Sehen wir uns ein Beispiel an: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Kraftreferenzen </h2><br>  Referenz ist eine Referenz auf ein Objekt, f√ºr das wir das Laden verschoben haben.  Im Fall von ManyToOnes Beziehung zu fetchType = LAZY erhalten wir eine solche Referenz.  Die Initialisierung des Objekts erfolgt zum Zeitpunkt des Zugriffs auf die Felder der Entit√§t mit Ausnahme der ID (da wir den Wert dieses Felds kennen). <br><br>  Es ist anzumerken, dass sich die Referenz im Fall von Lazy Loading immer auf eine vorhandene Zeile in der Datenbank bezieht.  Aus diesem Grund funktionieren die meisten Lazy Loading-F√§lle in OneToOne-Beziehungen nicht. Der Ruhezustand muss auf JOIN eingestellt werden, um zu √ºberpr√ºfen, ob die Verbindung besteht und bereits ein JOIN vorhanden war. Anschlie√üend wird der Ruhezustand in das Objektmodell geladen.  Wenn wir in OneToOne nullable = true angeben, sollte LazyLoad funktionieren. <br><br>  Mit der em.getReference-Methode k√∂nnen wir unsere eigene Referenz erstellen.  In diesem Fall kann nicht garantiert werden, dass sich die Referenz auf eine vorhandene Zeile in der Datenbank bezieht. <br><br>  Lassen Sie uns ein Beispiel f√ºr die Verwendung eines solchen Links geben: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Nur f√ºr den Fall, ich erinnere Sie daran, dass wir im Falle einer geschlossenen EM oder eines getrennten Links eine LazyInitializationException erhalten. <br><br><h2>  Datum und Uhrzeit </h2><br>  Trotz der Tatsache, dass Java 8 √ºber eine hervorragende API f√ºr die Arbeit mit Datum und Uhrzeit verf√ºgt, k√∂nnen Sie mit der JDBC-API nur mit der alten Datums-API arbeiten.  Daher werden wir einige interessante Punkte analysieren. <br><br>  Zun√§chst m√ºssen Sie die Unterschiede zwischen LocalDateTime und Instant und ZonedDateTime klar verstehen.  (Ich werde mich nicht dehnen, aber ich werde ausgezeichnete Artikel zu diesem Thema geben: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Wenn kurz</b> <div class="spoiler_text">  LocalDateTime und LocalDate repr√§sentieren ein regul√§res Tupel von Zahlen.  Sie sind nicht an eine bestimmte Zeit gebunden.  Das hei√üt,  Die Landezeit des Flugzeugs kann nicht in LocalDateTime gespeichert werden.  Und das Geburtsdatum durch LocalDate ist ganz normal.  Der Augenblick stellt einen Zeitpunkt dar, zu dem wir zu jedem Zeitpunkt auf dem Planeten die Ortszeit erhalten k√∂nnen. <br></div></div><br>  Ein interessanterer und wichtigerer Punkt ist, wie die Daten in der Datenbank gespeichert werden.  Wenn wir den Typ TIMESTAMP WITH TIMEZONE angebracht haben, sollte es keine Probleme geben, aber wenn TIMESTAMP (OHNE TIMEZONE) steht, besteht die M√∂glichkeit, dass das Datum falsch geschrieben / gelesen wird.  (ohne LocalDate und LocalDateTime) <br><br>  Mal sehen warum: <br><br>  Wenn wir das Datum speichern, wird eine Methode mit der folgenden Signatur verwendet: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Wie Sie sehen, wird hier die alte API verwendet.  Das optionale Kalenderargument wird ben√∂tigt, um den Zeitstempel in eine Zeichenfolgendarstellung zu konvertieren.  Dh es speichert die Zeitzone in sich.  Wenn der Kalender nicht √ºbertragen wird, wird der Kalender standardm√§√üig mit der JVM-Zeitzone verwendet. <br><br>  Es gibt drei M√∂glichkeiten, um dieses Problem zu l√∂sen: <br><br><ul><li>  Stellen Sie die gew√ºnschte Zeitzone JVM ein </li><li>  Verwenden Sie den Parameter hibernate - hibernate.jdbc.time_zone (hinzugef√ºgt in 5.2) -, um nur ZonedDateTime und OffsetDateTime zu korrigieren </li><li>  Verwenden Sie den Typ TIMESTAMP WITH TIMEZONE </li></ul><br>  Eine interessante Frage, warum LocalDate und LocalDateTime nicht unter ein solches Problem fallen? <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Um diese Frage zu beantworten, m√ºssen Sie die Struktur der Klasse java.util.Date verstehen (java.sql.Date und java.sql.Timestamp, seine Erben und ihre Unterschiede in diesem Fall st√∂ren uns nicht).  Datum speichert das Datum in Millisekunden seit 1970, ungef√§hr in UTC, aber die toString-Methode konvertiert das Datum gem√§√ü der Systemzeitzone. <br><br>  Wenn wir also ein Datum ohne Zeitzone aus der Datenbank erhalten, wird es einem Zeitstempelobjekt zugeordnet, sodass die toString-Methode den gew√ºnschten Wert anzeigt.  Gleichzeitig kann die Anzahl der Millisekunden seit 1970 unterschiedlich sein (abh√§ngig von der Zeitzone).  Deshalb wird immer nur die Ortszeit korrekt angezeigt. <br><br>  Ich gebe auch ein Beispiel f√ºr den Code, der f√ºr die Konvertierung von Timesamp in LocalDateTime und Instant verantwortlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Batching </h2><br>  Standardm√§√üig werden Abfragen einzeln an die Datenbank gesendet.  Wenn die Stapelverarbeitung aktiviert ist, kann der Ruhezustand mehrere Anweisungen in einer Abfrage an die Datenbank senden.  (d. h. Batching reduziert die Anzahl der Roundtrips zur Datenbank) <br><br>  Dazu m√ºssen Sie: <br><br><ul><li>  Aktivieren Sie die Stapelverarbeitung und legen Sie die maximale Anzahl von Anweisungen fest: <br>  hibernate.jdbc.batch_size (5 bis 30 empfohlen) </li><li>  Aktivieren Sie die Sortierung der Einf√ºgungen und Aktualisierungen: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Wenn wir die Versionierung verwenden, m√ºssen wir auch aktivieren <br>  hibernate.jdbc.batch_versioned_data - Vorsicht, hier ben√∂tigen Sie den JDBC-Treiber, um die Anzahl der w√§hrend der Aktualisierung betroffenen Zeilen angeben zu k√∂nnen. </li></ul><br>  Ich m√∂chte Sie auch an die Effektivit√§t der Operation em.clear () erinnern - sie bindet Entit√§ten von em, wodurch Speicherplatz frei wird und die Zeit f√ºr die schmutzige √úberpr√ºfung verk√ºrzt wird. <br>  Wenn wir Postgres verwenden, k√∂nnen wir auch Ruhezustand sagen, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multi-Raw-Insert zu verwenden</a> . <br><br><h2>  N + 1 Problem </h2><br>  Dies ist ein ziemlich allgegenw√§rtiges Thema, gehen Sie es also schnell durch. <br><br>  Ein N + 1-Problem ist eine Situation, in der anstelle einer einzelnen Anforderung zur Auswahl von N B√ºchern mindestens N + 1 Anforderungen auftreten. <br><br>  Der einfachste Weg, um das N + 1-Problem zu l√∂sen, besteht darin, verwandte Tabellen abzurufen.  In diesem Fall k√∂nnen verschiedene andere Probleme auftreten: <br><br><ul><li>  <b>Paginierung.</b>  Bei OneToMany-Beziehungen kann der Ruhezustand keinen Versatz und keine Begrenzung angeben.  Daher tritt eine Paginierung im Speicher auf. </li><li>  <b>Das Problem eines kartesischen Produkts</b> ist eine Situation, in der eine Datenbank N * M * K Zeilen zur√ºckgibt, um N B√ºcher mit M Kapiteln und K Autoren auszuw√§hlen. </li></ul><br>  Es gibt andere M√∂glichkeiten, das N + 1-Problem zu l√∂sen. <br><br><ul><li>  <b>FetchMode</b> - Mit dieser <b>Option</b> k√∂nnen Sie den <b>Ladealgorithmus f√ºr untergeordnete</b> Entit√§ten √§ndern.  In unserem Fall interessieren uns folgende: <ul><li>  <b>FetchType.SUBSELECT</b> - L√§dt <b>untergeordnete</b> Datens√§tze in einer separaten Anforderung.  Der Nachteil ist, dass die gesamte Komplexit√§t der Hauptanforderung in der Unterauswahl wiederholt wird. </li><li>  <b>BATCH (FetchType.SELECT + BatchSize-Annotation)</b> - l√§dt auch Datens√§tze als separate Anforderung, stellt jedoch zusammen mit der Unterabfrage eine Bedingung wie WHERE parent_id IN (?,?,?, ..., N). </li></ul>  Es ist zu beachten, dass bei Verwendung von fetch in der Kriterien-API FetchType ignoriert wird - JOIN wird immer verwendet </li><li>  <b>JPA EntityGraph und Hibernate FetchProfile</b> - erm√∂glichen es Ihnen, Entity- <b>Laderegeln</b> in eine separate Abstraktion zu <b>verwandeln</b> - meiner Meinung nach sind beide Implementierungen unpraktisch. </li></ul><br><h2>  Testen </h2><br>  Im Idealfall sollte die Entwicklungsumgebung so viele n√ºtzliche Informationen wie m√∂glich √ºber den Betrieb des Ruhezustands und √ºber die Interaktion mit der Datenbank bereitstellen.  N√§mlich: <br><br><ul><li>  Protokollierung <ul><li>  org.hibernate.SQL: Debug </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Statistiken <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Von den n√ºtzlichen Dienstprogrammen kann Folgendes unterschieden werden: <br><ul><li>  <b>DBUnit</b> - Mit dieser <b>Option</b> k√∂nnen Sie den Status der Datenbank im XML-Format beschreiben.  Manchmal ist es bequem.  Aber √ºberlegen Sie besser noch einmal, ob Sie es brauchen. </li><li>  DataSource-Proxy <ul><li>  <b>p6spy</b> ist eine der √§ltesten L√∂sungen.  bietet erweiterte Abfrageprotokollierung, Laufzeit usw. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> ist ein praktisches Dienstprogramm zum Auffinden von N + 1-Problemen.  Au√üerdem k√∂nnen Sie Abfragen protokollieren.  Die Komposition enth√§lt eine interessante Annotation zum Wiederholen, mit der die Transaktion im Fall einer OptimisticLockException wiederholt wird. </li><li>  <b>Sniffy</b> - Erm√∂glicht es Ihnen, die Anzahl der Anforderungen durch die Anmerkung zu best√§tigen.  In gewisser Hinsicht eleganter als die Entscheidung von Vlad. </li></ul></li></ul><br>  Aber ich wiederhole noch einmal, dass dies nur f√ºr die Entwicklung ist, dies sollte nicht in die Produktion aufgenommen werden. <br><br><h2>  Literatur </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von Nikolai Alimenkov - Lassen Sie uns den Winterschlaf wieder schnell machen</a> - dieser Bericht hat mich dazu inspiriert, den Winterschlaf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehender</a> zu studieren.  Unten sind die Ressourcen aufgef√ºhrt, die ich verwendet habe. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Buch "Java Persistence API and Hibernate"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vlad M. Blog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Weakly Digest</a> - Daily Digest (indirekt mit dem Thema verbunden) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416851/">https://habr.com/ru/post/de416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416841/index.html">So testen Sie Hypothesen und verdienen mit Split-Tests Geld mit Swift</a></li>
<li><a href="../de416843/index.html">Nuklearraketenmotoren und elektrische Antriebssysteme f√ºr Nuklearraketen</a></li>
<li><a href="../de416845/index.html">10 Gr√ºnde, itracking zu verwenden oder es f√ºr immer aufzugeben</a></li>
<li><a href="../de416847/index.html">Ammyy Admin Site erneut kompromittiert</a></li>
<li><a href="../de416849/index.html">Oh mein Code. So werden Sie Systemadministrator</a></li>
<li><a href="../de416855/index.html">Bachelor der St. Petersburg State University</a></li>
<li><a href="../de416857/index.html">Wir bauen Tempel - im Code und im Leben. Meine Erfahrung bei der Entwicklung meiner zweiten Android-Anwendung</a></li>
<li><a href="../de416859/index.html">Treffen Sie alle auf einmal React Boilerplate von Maximilian Stoiber v3.6.0</a></li>
<li><a href="../de416863/index.html">Eine neue Art, Aussteller vorzustellen</a></li>
<li><a href="../de416865/index.html">Retro-Design f√ºr die erste tragbare Konsole aus dem fernen 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>