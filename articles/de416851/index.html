<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 👨🏼‍✈️ 👸🏾 Ruhezustand - worüber die Tutorials schweigen 🤸🏾 🤟🏽 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel behandelt nicht die Grundlagen des Ruhezustands (Definieren einer Entität oder Schreiben von Kriterienabfragen). Hier werde ich versuch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ruhezustand - worüber die Tutorials schweigen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416851/">  Dieser Artikel behandelt nicht die Grundlagen des Ruhezustands (Definieren einer Entität oder Schreiben von Kriterienabfragen).  Hier werde ich versuchen, über interessantere Punkte zu sprechen, die bei der Arbeit wirklich nützlich sind.  Informationen, die ich nicht an einem Ort getroffen habe. <br><img src="https://habrastorage.org/webt/fi/bk/xl/fibkxlt7g2xcrfqbd7crf-bdlpq.png" alt="Bild"><br><a name="habracut"></a><br>  Ich werde sofort reservieren.  Alle folgenden Aussagen gelten für Hibernate 5.2.  Fehler sind auch möglich, weil ich etwas falsch verstanden habe.  Wenn Sie finden - schreiben Sie. <br><br><h2>  Probleme beim Zuordnen eines Objektmodells zu einem relationalen Modell </h2><br>  Beginnen wir jedoch mit den Grundlagen von ORM.  ORM - Objekt-relationales Mapping - dementsprechend haben wir relationale und Objektmodelle.  Und wenn wir uns gegenseitig anzeigen, gibt es Probleme, die wir selbst lösen müssen.  Nehmen wir sie auseinander. <br><br>  Nehmen wir zur Veranschaulichung das folgende Beispiel: Wir haben die Entität "Benutzer", die entweder ein Jedi oder ein Angriffsflugzeug sein kann.  Die Jedi müssen Stärke und die Spezialisierung der Angriffsflugzeuge haben.  Unten ist ein Klassendiagramm. <br><br><img src="https://habrastorage.org/webt/9d/pr/49/9dpr49fuefbbzbw1zva43phn5qk.png" alt="Bild"><br><br><h3>  Problem 1. Vererbung und polymorphe Abfragen. </h3><br>  Es gibt Vererbung im Objektmodell, aber nicht im relationalen Modell.  Dementsprechend ist dies das erste Problem - wie die Vererbung dem relationalen Modell korrekt zugeordnet werden kann. <br><br>  Der Ruhezustand bietet drei Optionen zum Anzeigen eines solchen Objektmodells: <br><br><ol><li>  Alle Erben befinden sich in derselben Tabelle: <br>  <b>@Inheritance (Strategie = InheritanceType.SINGLE_TABLE)</b> <br><br><img src="https://habrastorage.org/webt/dr/qm/ql/drqmqltrkcv65eyrn-wpqtkq3gg.png" alt="Bild"><br><br>  In diesem Fall liegen die gemeinsamen Felder und die Felder der Erben in einer Tabelle.  Mit dieser Strategie vermeiden wir Verknüpfungen bei der Auswahl von Entitäten.  Von den Minuspunkten ist anzumerken, dass wir erstens die Einschränkung „NOT NULL“ für die Spalte „force“ im relationalen Modell nicht festlegen können und zweitens die dritte Normalform verlieren.  (Eine transitive Abhängigkeit von Nicht-Schlüsselattributen wird angezeigt: Kraft und Disc). <br><br>  Übrigens, auch aus diesem Grund gibt es zwei Möglichkeiten, eine Feldbeschränkung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ungleich</a> Null anzugeben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">NotNull</a> ist für die Validierung verantwortlich.  @Column (nullable = true) - verantwortlich für die Nicht-Null-Einschränkung in der Datenbank. <br><br>  Meiner Meinung nach ist dies der beste Weg, ein Objektmodell einem relationalen Modell zuzuordnen. <br></li><li>  Entitätsspezifische Felder befinden sich in einer separaten Tabelle. <br><br>  <b>@Inheritance (Strategie = InheritanceType.JOINED)</b> <br><br><img src="https://habrastorage.org/webt/05/wi/yt/05wiyttu0wnbvceub8udxmxtrn0.png" alt="Bild"><br><br>  In diesem Fall werden allgemeine Felder in einer gemeinsamen Tabelle und spezifische für untergeordnete Entitäten in separaten Tabellen gespeichert.  Mit dieser Strategie erhalten wir bei der Auswahl einer Entität einen JOIN. Jetzt speichern wir die dritte Normalform und können auch eine NOT NULL-Einschränkung in der Datenbank angeben. </li><li>  Jede Entität hat eine eigene Tabelle. <br><br>  <b>@ InheritanceType.TABLE_PER_CLASS</b> <br><br><img src="https://habrastorage.org/webt/0t/ni/jw/0tnijwm5ykxrpufkcaoblj5dfzq.png" alt="Bild"><br><br>  In diesem Fall haben wir keine gemeinsame Tabelle.  Mit dieser Strategie verwenden wir UNION für polymorphe Abfragen.  Wir haben Probleme mit Primärschlüsselgeneratoren und anderen Integritätsbeschränkungen.  Von dieser Art der Vererbungszuordnung wird dringend abgeraten. </li></ol><br>  Für alle Fälle erwähne ich die Anmerkung - @MappedSuperclass.  Es wird verwendet, wenn Sie allgemeine Felder für mehrere Entitäten des Objektmodells „ausblenden“ möchten.  Darüber hinaus wird die mit Anmerkungen versehene Klasse selbst nicht als separate Einheit betrachtet. <br><br><h3>  Problem 2. Zusammensetzungsverhältnis in OOP </h3><br>  Zurück zu unserem Beispiel stellen wir fest, dass wir im Objektmodell das Benutzerprofil in eine separate Entität - Profil - aufgenommen haben.  Im relationalen Modell haben wir jedoch keine separate Tabelle dafür ausgewählt. <br><br>  Die OneToOne-Einstellung ist oft eine schlechte Praxis, weil  In select haben wir einen ungerechtfertigten JOIN (in den meisten Fällen haben wir sogar fetchType = LAZY, wir werden JOIN haben - wir werden dieses Problem später diskutieren). <br><br>  Es gibt @ Embedable- und @ Embeded-Annotationen, um eine Komposition in einer gemeinsamen Tabelle anzuzeigen.  Der erste befindet sich über dem Feld und der zweite über der Klasse.  Sie sind austauschbar. <br><br><h2>  Entity Manager </h2><br>  Jede Instanz von EntityManager (EM) definiert eine Interaktionssitzung mit der Datenbank.  Innerhalb einer EM-Instanz gibt es einen Cache der ersten Ebene.  Hier werde ich die folgenden wichtigen Punkte hervorheben: <br><br><ol><li>  <b>Erfassen der Datenbankverbindung</b> <br><br>  Dies ist nur ein interessanter Punkt.  Der Ruhezustand erfasst die Verbindung nicht zum Zeitpunkt des Empfangs der EM, sondern beim ersten Zugriff auf die Datenbank oder beim Öffnen der Transaktion (obwohl dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelöst werden kann</a> ).  Dies geschieht, um die Zeit der besetzten Verbindung zu verkürzen.  Während des Empfangs von EM-a wird das Vorhandensein einer JTA-Transaktion überprüft. </li><li>  <b>Persistierte Entitäten haben immer eine ID</b> </li><li>  <b>Entitäten, die eine Zeile in der Datenbank beschreiben, entsprechen als Referenz</b> <br>  Wie oben erwähnt, verfügt EM über einen Cache der ersten Ebene. Die darin enthaltenen Objekte werden anhand der Referenz verglichen.  Dementsprechend stellt sich die Frage: Welche Felder sollten verwendet werden, um Gleichheit und Hashcode zu überschreiben?  Betrachten Sie die folgenden Optionen: <br><br><ul><li>  Verwenden Sie alle Felder.  Schlechte Idee  Gleiches kann LAZY-Felder beeinflussen.  Dies gilt übrigens auch für die toString-Methode. </li><li>  Verwenden Sie nur die ID.  Eine normale Idee, aber es gibt auch Nuancen.  Da id für neue Entitäten meistens einen Generator zum Zeitpunkt des Fortbestehens setzt.  Folgende Situation ist möglich: <br><br><pre><code class="java hljs">Entity foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Entity(); <span class="hljs-comment"><span class="hljs-comment">//   (id = null) set.put(foo); //   hashset em.persist(foo); // persist  (id = some value) set.contains(foo) == false // .. hashCode   </span></span></code> </pre> <br></li><li>  Verwenden Sie einen Geschäftsschlüssel (ungefähr Felder, die eindeutig und NICHT NULL sind).  Diese Option ist jedoch nicht immer praktisch. <br><br>  Übrigens, da es sich um NOT NULL und UNIQUE handelt, ist es manchmal praktisch, einen öffentlichen Konstruktor mit NOT NULL-Argumenten zu erstellen, und der Konstruktor ohne Argumente ist geschützt. </li><li>  Überschreiben Sie nicht gleich und Hashcode überhaupt. </li></ul></li><li>  <b>Wie Flush funktioniert</b> <br>  Flush - führt akkumulierte Einfügungen, Aktualisierungen und Löschvorgänge in der Datenbank aus.  Standardmäßig wird Flush in folgenden Fällen ausgeführt: <br><br><ul><li>  Vor dem Ausführen der Abfrage (mit Ausnahme von em.get) ist dies erforderlich, um das ACID-Prinzip einzuhalten.  Zum Beispiel: Wir haben das Geburtsdatum des Angriffsflugzeugs geändert und wollten dann die Anzahl der Angriffsflugzeuge für Erwachsene ermitteln. <br><br>  Wenn es sich um CriteriaQuery oder JPQL handelt, wird Flush ausgeführt, wenn die Abfrage eine Tabelle betrifft, deren Entitäten sich im Cache der ersten Ebene befinden. </li><li>  Beim Festschreiben einer Transaktion; </li><li>  Manchmal, wenn eine neue Entität beibehalten wird - in dem Fall, dass wir ihre ID nur durch Einfügen erhalten können. </li></ul><br>  Und jetzt ein kleiner Test.  Wie viele UPDATE-Operationen werden in diesem Fall ausgeführt? <br><br><pre> <code class="java hljs">val spaceCraft = em.find(SpaceCraft.class, <span class="hljs-number"><span class="hljs-number">1L</span></span>); spaceCraft.setCoords(...); spaceCraft.setCompanion( findNearestSpaceCraft(spacecraft) );</code> </pre> <br>  Eine interessante Funktion für den Ruhezustand ist unter dem Flush-Vorgang verborgen. Sie versucht, die Zeit zu verkürzen, die zum Sperren von Zeilen in der Datenbank erforderlich ist. <br><br>  Beachten Sie auch, dass es unterschiedliche Strategien für den Spülvorgang gibt.  Sie können beispielsweise das Zusammenführen von Änderungen an der Datenbank verbieten - dies wird als MANUAL bezeichnet (es deaktiviert auch den Mechanismus zur Überprüfung von Verschmutzungen). <br></li><li>  <b>Schmutzige Überprüfung</b> <br><br>  Dirty Checking ist ein Mechanismus, der während eines Spülvorgangs ausgeführt wird.  Der Zweck besteht darin, geänderte Entitäten zu finden und zu aktualisieren.  Um einen solchen Mechanismus zu implementieren, muss der Ruhezustand die Originalkopie des Objekts speichern (womit das tatsächliche Objekt verglichen wird).  Genauer gesagt speichert der Ruhezustand eine Kopie der Felder des Objekts, nicht des Objekts selbst. <br><br>  Es ist anzumerken, dass der Vorgang der schmutzigen Prüfung teuer sein kann, wenn der Graph der Entitäten groß ist.  Vergessen Sie nicht, dass im Ruhezustand 2 Kopien von Entitäten gespeichert werden (ungefähr). <br>  Verwenden Sie die folgenden Funktionen, um die Kosten dieses Prozesses zu senken: <br><br><ul><li>  em.detach / em.clear - Entitäten von EntityManager trennen </li><li>  FlushMode = MANUAL - nützlich bei Lesevorgängen </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Unveränderlich</a> - vermeidet auch schmutzige Überprüfungsvorgänge </li></ul><br></li><li>  <b>Transaktionen</b> <br><br>  Wie Sie wissen, können Sie im Ruhezustand Entitäten nur innerhalb einer Transaktion aktualisieren.  Lesevorgänge bieten mehr Freiheit - wir können sie ausführen, ohne eine Transaktion explizit zu öffnen.  Aber genau das ist die Frage: Lohnt es sich, eine Transaktion explizit für Lesevorgänge zu öffnen? <br><br>  Ich werde einige Fakten anführen: <br><br><ul><li>  Jede Anweisung wird in der Datenbank innerhalb der Transaktion ausgeführt.  Auch wenn wir es offensichtlich nicht geöffnet haben.  (Auto-Commit-Modus). </li><li>  In der Regel sind wir nicht auf eine Abfrage an die Datenbank beschränkt.  Beispiel: Um die ersten 10 Datensätze abzurufen, möchten Sie wahrscheinlich die Gesamtzahl der Datensätze zurückgeben.  Und das sind fast immer 2 Anfragen. </li><li>  Wenn es sich um Federdaten handelt, sind die Repository-Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">standardmäßig</a> transaktional, während die Lesemethoden schreibgeschützt sind. </li><li>  Die Annotation @Transactional Spring (readOnly = true) wirkt sich auch auf den FlushMode aus, genauer gesagt, Spring versetzt ihn in den Status MANUAL, sodass der Ruhezustand keine Schmutzprüfung durchführt. </li><li>  Synthetische Tests mit einer oder zwei Datenbankabfragen zeigen, dass das automatische Festschreiben schneller ist.  Im Kampfmodus ist dies jedoch möglicherweise nicht der Fall.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgezeichneter Artikel zu diesem Thema</a> , + siehe Kommentare) </li></ul><br>  Kurz gesagt: Es wird empfohlen, in einer Transaktion eine Kommunikation mit der Datenbank durchzuführen. <br></li></ol><br><h2>  Generatoren </h2><br>  Generatoren werden benötigt, um zu beschreiben, wie die Primärschlüssel unserer Entitäten Werte erhalten.  Lassen Sie uns kurz die Optionen durchgehen: <br><br><ul><li>  <b>GenerationType.AUTO</b> - Die Auswahl des Generators basiert auf dem Dialekt.  Nicht die beste Option, da hier nur die Regel „explizit ist besser als implizit“ gilt. </li><li>  <b>GenerationType.IDENTITY</b> ist der einfachste Weg, einen Generator zu konfigurieren.  Es basiert auf der Spalte für die automatische Inkrementierung in der Tabelle.  Um id mit persist zu erhalten, müssen wir daher einfügen.  Aus diesem Grund wird die Möglichkeit einer verzögerten Persistenz und damit einer Chargenbildung ausgeschlossen. </li><li>  <b>GenerationType.SEQUENCE</b> ist der bequemste Fall, wenn wir die ID aus der Sequenz erhalten. </li><li>  <b>GenerationType.TABLE</b> - In diesem Fall emuliert der Ruhezustand eine Sequenz über eine zusätzliche Tabelle.  Nicht die beste Option, weil  In einer solchen Lösung muss der Ruhezustand eine separate Transaktion verwenden und pro Zeile sperren. </li></ul><br>  Lassen Sie uns etwas mehr über die Sequenz sprechen.  Um die Betriebsgeschwindigkeit zu erhöhen, verwendet der Ruhezustand verschiedene Optimierungsalgorithmen.  Alle zielen darauf ab, die Anzahl der Gespräche mit der Datenbank (die Anzahl der Hin- und Rückfahrten) zu reduzieren.  Schauen wir sie uns genauer an: <br><br><ul><li>  <b>keine</b> - keine Optimierungen.  Für jede ID ziehen wir eine Sequenz. </li><li>  <b>gepoolt und gepoolt</b> - in diesem Fall sollte sich unsere Sequenz um ein bestimmtes Intervall erhöhen - N in der Datenbank (SequenceGenerator.allocationSize).  Und in der Anwendung haben wir einen bestimmten Pool, die Werte, aus denen wir neuen Entitäten zuweisen können, ohne auf die Datenbank zuzugreifen. </li><li>  <b>hilo</b> - <b>Um</b> eine ID zu generieren, verwendet der hilo-Algorithmus zwei Zahlen: hi (in der Datenbank gespeichert - der Wert, der aus dem Sequenzaufruf erhalten wurde) und lo (nur in der Anwendung gespeichert - SequenceGenerator.allocationSize).  Basierend auf diesen Zahlen wird das Intervall zum Erzeugen der ID wie folgt berechnet: [(hi - 1) * lo + 1, hi * lo + 1).  Aus offensichtlichen Gründen wird dieser Algorithmus als veraltet angesehen und es wird nicht empfohlen, ihn zu verwenden. </li></ul><br>  Nun wollen wir sehen, wie der Optimierer ausgewählt wird.  Der Ruhezustand verfügt über mehrere Sequenzgeneratoren.  Wir werden an 2 von ihnen interessiert sein: <br><br><ul><li>  <b>SequenceHiLoGenerator</b> ist ein alter Generator, der den Hilo-Optimierer verwendet.  Standardmäßig ausgewählt, wenn die Eigenschaft hibernate.id.new_generator_mappings == false vorhanden ist. </li><li>  <b>SequenceStyleGenerator</b> - wird standardmäßig verwendet (wenn die Eigenschaft hibernate.id.new_generator_mappings == true ist).  Dieser Generator unterstützt mehrere Optimierer, aber die Standardeinstellung ist zusammengefasst. </li></ul><br>  Sie können auch die Generator-Annotation @GenericGenerator konfigurieren. <br><br><h2>  Deadlock </h2><br>  Schauen wir uns ein Beispiel für eine Pseudocode-Situation an, die zu einem Deadlock führen kann: <br><br><pre> <code class="hljs pgsql">Thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) Thread #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> entity(id = <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Um solche Probleme zu vermeiden, verfügt der Ruhezustand über einen Mechanismus, der Deadlocks dieses Typs vermeidet - den Parameter hibernate.order_updates.  In diesem Fall werden alle Aktualisierungen nach ID sortiert und ausgeführt.  Ich werde auch noch einmal erwähnen, dass der Ruhezustand versucht, die Erfassung der Verbindung und die Ausführung von Einfügungen und Aktualisierungen zu "verzögern". <br><br><h2>  Set, Tasche, Liste </h2><br>  Hibernate bietet drei Möglichkeiten, um die OneToMany-Kommunikationssammlung zu präsentieren. <br><br><ul><li>  Set - eine ungeordnete Menge von Entitäten ohne Wiederholungen; </li><li>  Tasche - eine ungeordnete Gruppe von Entitäten; </li><li>  Liste ist eine geordnete Menge von Entitäten. </li></ul><br>  Es gibt keine Klasse für Bag im Java-Kern, die eine solche Struktur beschreiben würde.  Daher sind alle Listen und Sammlungen Taschen, es sei denn, Sie geben eine Spalte an, nach der unsere Sammlung sortiert wird (OrderColumn-Annotation. Nicht zu verwechseln mit SortBy).  Ich empfehle dringend, die OrderColumn-Annotation nicht zu verwenden, da die Funktionen (meiner Meinung nach) schlecht implementiert sind - keine optimalen SQL-Abfragen, mögliche NULL-Werte im Blatt. <br><br>  Die Frage stellt sich, aber was ist besser, Tasche oder Set zu verwenden?  Bei der Verwendung einer Tasche sind zunächst folgende Probleme möglich: <br><br><ul><li>  Wenn Ihre Version des Ruhezustands niedriger als 5.0.8 ist, gibt es beim Einfügen einer untergeordneten Entität einen ziemlich schwerwiegenden Fehler - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HHH-5855</a> -, dessen Duplizierung möglich ist (im Fall von cascadType = MERGE und PERSIST). </li><li>  Wenn Sie bag für die ManyToMany-Beziehung verwenden, generiert der Ruhezustand beim Löschen einer Entität aus der Sammlung äußerst unangemessene Abfragen. Zuerst werden alle Zeilen aus der Verknüpfungstabelle entfernt und anschließend wird eine Einfügung ausgeführt. </li><li>  Der Ruhezustand kann nicht mehrere Beutel für dieselbe Entität gleichzeitig abrufen. </li></ul><br>  Wenn Sie der @ OneToMany-Verbindung eine weitere Entität hinzufügen möchten, ist die Verwendung von Bag rentabler, da  Für diesen Vorgang müssen nicht alle zugehörigen Entitäten geladen werden.  Sehen wir uns ein Beispiel an: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( luke ); //       //  set spaceCraft.getCrew().put( luke ); //      //        .     ManyToOne   : luke.setCurrentSpaceCraft( spaceCraft );</span></span></code> </pre><br><h2>  Kraftreferenzen </h2><br>  Referenz ist eine Referenz auf ein Objekt, für das wir das Laden verschoben haben.  Im Fall von ManyToOnes Beziehung zu fetchType = LAZY erhalten wir eine solche Referenz.  Die Initialisierung des Objekts erfolgt zum Zeitpunkt des Zugriffs auf die Felder der Entität mit Ausnahme der ID (da wir den Wert dieses Felds kennen). <br><br>  Es ist anzumerken, dass sich die Referenz im Fall von Lazy Loading immer auf eine vorhandene Zeile in der Datenbank bezieht.  Aus diesem Grund funktionieren die meisten Lazy Loading-Fälle in OneToOne-Beziehungen nicht. Der Ruhezustand muss auf JOIN eingestellt werden, um zu überprüfen, ob die Verbindung besteht und bereits ein JOIN vorhanden war. Anschließend wird der Ruhezustand in das Objektmodell geladen.  Wenn wir in OneToOne nullable = true angeben, sollte LazyLoad funktionieren. <br><br>  Mit der em.getReference-Methode können wir unsere eigene Referenz erstellen.  In diesem Fall kann nicht garantiert werden, dass sich die Referenz auf eine vorhandene Zeile in der Datenbank bezieht. <br><br>  Lassen Sie uns ein Beispiel für die Verwendung eines solchen Links geben: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  bag spaceCraft.getCrew().add( em.getReference( User.class, 1L ) ); //      ,     </span></span></code> </pre> <br>  Nur für den Fall, ich erinnere Sie daran, dass wir im Falle einer geschlossenen EM oder eines getrennten Links eine LazyInitializationException erhalten. <br><br><h2>  Datum und Uhrzeit </h2><br>  Trotz der Tatsache, dass Java 8 über eine hervorragende API für die Arbeit mit Datum und Uhrzeit verfügt, können Sie mit der JDBC-API nur mit der alten Datums-API arbeiten.  Daher werden wir einige interessante Punkte analysieren. <br><br>  Zunächst müssen Sie die Unterschiede zwischen LocalDateTime und Instant und ZonedDateTime klar verstehen.  (Ich werde mich nicht dehnen, aber ich werde ausgezeichnete Artikel zu diesem Thema geben: den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Wenn kurz</b> <div class="spoiler_text">  LocalDateTime und LocalDate repräsentieren ein reguläres Tupel von Zahlen.  Sie sind nicht an eine bestimmte Zeit gebunden.  Das heißt,  Die Landezeit des Flugzeugs kann nicht in LocalDateTime gespeichert werden.  Und das Geburtsdatum durch LocalDate ist ganz normal.  Der Augenblick stellt einen Zeitpunkt dar, zu dem wir zu jedem Zeitpunkt auf dem Planeten die Ortszeit erhalten können. <br></div></div><br>  Ein interessanterer und wichtigerer Punkt ist, wie die Daten in der Datenbank gespeichert werden.  Wenn wir den Typ TIMESTAMP WITH TIMEZONE angebracht haben, sollte es keine Probleme geben, aber wenn TIMESTAMP (OHNE TIMEZONE) steht, besteht die Möglichkeit, dass das Datum falsch geschrieben / gelesen wird.  (ohne LocalDate und LocalDateTime) <br><br>  Mal sehen warum: <br><br>  Wenn wir das Datum speichern, wird eine Methode mit der folgenden Signatur verwendet: <br><br><pre> <code class="java hljs">setTimestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, Timestamp t, java.util.Calendar cal)</code> </pre> <br>  Wie Sie sehen, wird hier die alte API verwendet.  Das optionale Kalenderargument wird benötigt, um den Zeitstempel in eine Zeichenfolgendarstellung zu konvertieren.  Dh es speichert die Zeitzone in sich.  Wenn der Kalender nicht übertragen wird, wird der Kalender standardmäßig mit der JVM-Zeitzone verwendet. <br><br>  Es gibt drei Möglichkeiten, um dieses Problem zu lösen: <br><br><ul><li>  Stellen Sie die gewünschte Zeitzone JVM ein </li><li>  Verwenden Sie den Parameter hibernate - hibernate.jdbc.time_zone (hinzugefügt in 5.2) -, um nur ZonedDateTime und OffsetDateTime zu korrigieren </li><li>  Verwenden Sie den Typ TIMESTAMP WITH TIMEZONE </li></ul><br>  Eine interessante Frage, warum LocalDate und LocalDateTime nicht unter ein solches Problem fallen? <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort</b> <div class="spoiler_text">  Um diese Frage zu beantworten, müssen Sie die Struktur der Klasse java.util.Date verstehen (java.sql.Date und java.sql.Timestamp, seine Erben und ihre Unterschiede in diesem Fall stören uns nicht).  Datum speichert das Datum in Millisekunden seit 1970, ungefähr in UTC, aber die toString-Methode konvertiert das Datum gemäß der Systemzeitzone. <br><br>  Wenn wir also ein Datum ohne Zeitzone aus der Datenbank erhalten, wird es einem Zeitstempelobjekt zugeordnet, sodass die toString-Methode den gewünschten Wert anzeigt.  Gleichzeitig kann die Anzahl der Millisekunden seit 1970 unterschiedlich sein (abhängig von der Zeitzone).  Deshalb wird immer nur die Ortszeit korrekt angezeigt. <br><br>  Ich gebe auch ein Beispiel für den Code, der für die Konvertierung von Timesamp in LocalDateTime und Instant verantwortlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalDateTime LocalDateTime.ofInstant( ts.toInstant(), ZoneId.systemDefault() ); // Instant ts.toInstant();</span></span></code> </pre> <br></div></div><br><h2>  Batching </h2><br>  Standardmäßig werden Abfragen einzeln an die Datenbank gesendet.  Wenn die Stapelverarbeitung aktiviert ist, kann der Ruhezustand mehrere Anweisungen in einer Abfrage an die Datenbank senden.  (d. h. Batching reduziert die Anzahl der Roundtrips zur Datenbank) <br><br>  Dazu müssen Sie: <br><br><ul><li>  Aktivieren Sie die Stapelverarbeitung und legen Sie die maximale Anzahl von Anweisungen fest: <br>  hibernate.jdbc.batch_size (5 bis 30 empfohlen) </li><li>  Aktivieren Sie die Sortierung der Einfügungen und Aktualisierungen: <br>  hibernate.order_inserts <br>  hibernate.order_updates <br></li><li>  Wenn wir die Versionierung verwenden, müssen wir auch aktivieren <br>  hibernate.jdbc.batch_versioned_data - Vorsicht, hier benötigen Sie den JDBC-Treiber, um die Anzahl der während der Aktualisierung betroffenen Zeilen angeben zu können. </li></ul><br>  Ich möchte Sie auch an die Effektivität der Operation em.clear () erinnern - sie bindet Entitäten von em, wodurch Speicherplatz frei wird und die Zeit für die schmutzige Überprüfung verkürzt wird. <br>  Wenn wir Postgres verwenden, können wir auch Ruhezustand sagen, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multi-Raw-Insert zu verwenden</a> . <br><br><h2>  N + 1 Problem </h2><br>  Dies ist ein ziemlich allgegenwärtiges Thema, gehen Sie es also schnell durch. <br><br>  Ein N + 1-Problem ist eine Situation, in der anstelle einer einzelnen Anforderung zur Auswahl von N Büchern mindestens N + 1 Anforderungen auftreten. <br><br>  Der einfachste Weg, um das N + 1-Problem zu lösen, besteht darin, verwandte Tabellen abzurufen.  In diesem Fall können verschiedene andere Probleme auftreten: <br><br><ul><li>  <b>Paginierung.</b>  Bei OneToMany-Beziehungen kann der Ruhezustand keinen Versatz und keine Begrenzung angeben.  Daher tritt eine Paginierung im Speicher auf. </li><li>  <b>Das Problem eines kartesischen Produkts</b> ist eine Situation, in der eine Datenbank N * M * K Zeilen zurückgibt, um N Bücher mit M Kapiteln und K Autoren auszuwählen. </li></ul><br>  Es gibt andere Möglichkeiten, das N + 1-Problem zu lösen. <br><br><ul><li>  <b>FetchMode</b> - Mit dieser <b>Option</b> können Sie den <b>Ladealgorithmus für untergeordnete</b> Entitäten ändern.  In unserem Fall interessieren uns folgende: <ul><li>  <b>FetchType.SUBSELECT</b> - Lädt <b>untergeordnete</b> Datensätze in einer separaten Anforderung.  Der Nachteil ist, dass die gesamte Komplexität der Hauptanforderung in der Unterauswahl wiederholt wird. </li><li>  <b>BATCH (FetchType.SELECT + BatchSize-Annotation)</b> - lädt auch Datensätze als separate Anforderung, stellt jedoch zusammen mit der Unterabfrage eine Bedingung wie WHERE parent_id IN (?,?,?, ..., N). </li></ul>  Es ist zu beachten, dass bei Verwendung von fetch in der Kriterien-API FetchType ignoriert wird - JOIN wird immer verwendet </li><li>  <b>JPA EntityGraph und Hibernate FetchProfile</b> - ermöglichen es Ihnen, Entity- <b>Laderegeln</b> in eine separate Abstraktion zu <b>verwandeln</b> - meiner Meinung nach sind beide Implementierungen unpraktisch. </li></ul><br><h2>  Testen </h2><br>  Im Idealfall sollte die Entwicklungsumgebung so viele nützliche Informationen wie möglich über den Betrieb des Ruhezustands und über die Interaktion mit der Datenbank bereitstellen.  Nämlich: <br><br><ul><li>  Protokollierung <ul><li>  org.hibernate.SQL: Debug </li><li>  org.hibernate.type.descriptor.sql: trace </li></ul></li><li>  Statistiken <ul><li>  hibernate.generate_statistics </li></ul></li></ul><br>  Von den nützlichen Dienstprogrammen kann Folgendes unterschieden werden: <br><ul><li>  <b>DBUnit</b> - Mit dieser <b>Option</b> können Sie den Status der Datenbank im XML-Format beschreiben.  Manchmal ist es bequem.  Aber überlegen Sie besser noch einmal, ob Sie es brauchen. </li><li>  DataSource-Proxy <ul><li>  <b>p6spy</b> ist eine der ältesten Lösungen.  bietet erweiterte Abfrageprotokollierung, Laufzeit usw. </li><li>  <b>com.vladmihalcea: db-util: 0.0.1</b> ist ein praktisches Dienstprogramm zum Auffinden von N + 1-Problemen.  Außerdem können Sie Abfragen protokollieren.  Die Komposition enthält eine interessante Annotation zum Wiederholen, mit der die Transaktion im Fall einer OptimisticLockException wiederholt wird. </li><li>  <b>Sniffy</b> - Ermöglicht es Ihnen, die Anzahl der Anforderungen durch die Anmerkung zu bestätigen.  In gewisser Hinsicht eleganter als die Entscheidung von Vlad. </li></ul></li></ul><br>  Aber ich wiederhole noch einmal, dass dies nur für die Entwicklung ist, dies sollte nicht in die Produktion aufgenommen werden. <br><br><h2>  Literatur </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von Nikolai Alimenkov - Lassen Sie uns den Winterschlaf wieder schnell machen</a> - dieser Bericht hat mich dazu inspiriert, den Winterschlaf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehender</a> zu studieren.  Unten sind die Ressourcen aufgeführt, die ich verwendet habe. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Buch "Java Persistence API and Hibernate"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vlad M. Blog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Weakly Digest</a> - Daily Digest (indirekt mit dem Thema verbunden) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416851/">https://habr.com/ru/post/de416851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416841/index.html">So testen Sie Hypothesen und verdienen mit Split-Tests Geld mit Swift</a></li>
<li><a href="../de416843/index.html">Nuklearraketenmotoren und elektrische Antriebssysteme für Nuklearraketen</a></li>
<li><a href="../de416845/index.html">10 Gründe, itracking zu verwenden oder es für immer aufzugeben</a></li>
<li><a href="../de416847/index.html">Ammyy Admin Site erneut kompromittiert</a></li>
<li><a href="../de416849/index.html">Oh mein Code. So werden Sie Systemadministrator</a></li>
<li><a href="../de416855/index.html">Bachelor der St. Petersburg State University</a></li>
<li><a href="../de416857/index.html">Wir bauen Tempel - im Code und im Leben. Meine Erfahrung bei der Entwicklung meiner zweiten Android-Anwendung</a></li>
<li><a href="../de416859/index.html">Treffen Sie alle auf einmal React Boilerplate von Maximilian Stoiber v3.6.0</a></li>
<li><a href="../de416863/index.html">Eine neue Art, Aussteller vorzustellen</a></li>
<li><a href="../de416865/index.html">Retro-Design für die erste tragbare Konsole aus dem fernen 1979</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>