<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍⚕️ ❤️ 🥊 使用Fastify和Preact快速原型化Web应用程序 🤜🏿 🎀 🤜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="该材料的作者（我们今天将其翻译发表）希望分享一个有关他使用哪些技术快速开发Web应用程序原型的故事。 这些技术包括Fastify和Preact库。 他还使用htm库。 它可以轻松地与Preact集成在一起，并且可以使用类似于JSX的直观结构来描述DOM元素。 同时，不需要像Babel这样的编译器来处...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Fastify和Preact快速原型化Web应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442652/"> 该材料的作者（我们今天将其翻译发表）希望分享一个有关他使用哪些技术快速开发Web应用程序原型的故事。 这些技术包括Fastify和Preact库。 他还使用htm库。 它可以轻松地与Preact集成在一起，并且可以使用类似于JSX的直观结构来描述DOM元素。 同时，不需要像Babel这样的编译器来处理它。 在演示了原型开发工具和使用它的方法之后，该材料的作者将展示如何将此类应用程序打包到Docker容器中。 这样可以很容易地向感兴趣的每个人演示应用程序。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/iq/mq/4a/iqmq4a-j0p_qnlayhqdbmbb2au4.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">开始</font> </h2><br> 几周前，当我需要创建一个非常简单的原型Web应用程序时，我开始使用上述一组技术，旨在与同事一起测试一些假设。 <br><br> 我的实验非常成功。 我能够很快地创建原型，我的同事们能够方便地进行试验，他们能够快速表达出对原型的印象。 同时，即使未在计算机上安装Node.js和NPM，他们也可以测试项目。 <br><br> 所有这些使我想到了我应该编写有关我的Web应用程序快速原型设计方法的材料。 这种方法可能对其他人有用。 对于已经熟悉Fastify和Preact的人，我将立即概述最重要的事情，这将使他们立即将我的想法付诸实践。 <br><br><h2>  <font color="#3AC1EF">主要思想</font> </h2><br> 如果您已经熟悉Fastify和Preact，并且想了解如何组织基于这些技术的项目开发，那么您实际上要走几步。 即，我们正在谈论以下命令： <br><br><pre><code class="plaintext hljs">git clone https://github.com/lmammino/fastify-preact-htm-boilerplate.git my-new-project cd my-new-project rm -rf .git npm install</code> </pre> <br> 当然，您可以将项目名称<code>my-new-project</code>更改为您的项目名称。 <br><br> 安装完所需的所有内容之后，就可以开始进行项目了。 即，我们正在谈论以下内容： <br><br><ul><li>  <code>src/ui</code>文件夹包含应用程序客户端部分的文件（此处使用Preact和htm）。 </li><li>  <code>src/server</code>文件夹包含与应用程序服务器端相关的文件（此处使用Fastify）。 </li></ul><br> 通过编辑适当的文件，您可以运行项目： <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br> 之后，您可以通过在浏览器中转到<code>localhost:3000</code>地址来对其进行测试。 <br><br> 还有一件事。 如果您喜欢我的开发，我将非常感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>的明星。 <br><br> 现在，让我们看一下这里使用的技术以及使用它们的功能。 <br><br><h2>  <font color="#3AC1EF">固定</font> </h2><br>  Fastify是用于Node.js的快速，经济的Web框架。 这个项目最初是由两个程序员创建的。 现在，该项目的团队有10个人，有130多人帮助开发了该项目，他在GitHub上收集了近10,000个星星。 <br><br>  Fastify受诸如Express和Hapi之类的Node.js框架的影响，这种框架已经存在了很长时间。 它最初旨在提高生产力，为程序员提供便利并借助插件来扩展其功能。 顺便说一下，这是我最喜欢的Fastify功能之一。 <br><br> 如果您不熟悉Fastify框架或想更好地了解它，我可以推荐其官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 <br><br> 应当指出，我与Fastify有关。 我是主要开发团队的成员，主要负责支持项目站点并处理其文档。 <br><br><h2>  <font color="#3AC1EF">事前</font> </h2><br>  Preact是一个用于开发Web项目用户界面的库，由一个人创建，它是React的紧凑而快速的替代品。 事实证明，该项目非常成功，现在整个开发团队都参与其中，他在GitHub上获得了20,000多颗星。 <br><br> 我喜欢Preact的原因之一是该库具有用于描述应用程序可视组件的可扩展层。 在正常情况下，可以结合使用JSX和Babel来使用该库来翻译代码，但是，如果您不想安装Babel并配置应用程序构建过程，则可以将Preact与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">htm</a>库一起使用，后者使用模板文字，并且不需要启动在现代浏览器中使用的项目时进行编译。 <br><br> 在本文中，我们将使用htm库，并将很快考虑一些示例。 <br><br><h2>  <font color="#3AC1EF">项目概况</font> </h2><br> 在这里，我们介绍了创建项目的整个过程。 我们的目标是开发一个简单的Web应用程序，在启动时在服务器上显示有关时间的信息。 在这里，为了使我们的工作更加明确。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/9fe/c12/4d89fec1291d3ab9b66f7673af992d06.png"></div><br>  <i><font color="#999999">浏览器中的应用</font></i> <br><br> 这是一个单页应用程序（SPA），其中Preact和htm用于形成其客户端部分，而Fastify用于创建旨在接收服务器时间的API。 <br><br> 细心的读者可能会注意到上图中显示的页面上有一个漂亮的图标图标。 是的，他在那里很小，所以对于那些想睁大眼睛看看的人，我将为他提供帮助。 这是它的放大版本。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaa/3a8/c3b/aaa3a8c3b25bba5f361af23d9af0f22b.jpg"></div><br>  <i><font color="#999999">网站图标</font></i> <br><br><h2>  <font color="#3AC1EF">设置应用程序的服务器端</font> </h2><br> 让我们从创建一个新文件夹开始： <br><br><pre> <code class="plaintext hljs">mkdir server-time cd server-time</code> </pre> <br> 现在初始化NPM项目并安装Fastify： <br><br><pre> <code class="plaintext hljs">npm init -y npm i --save fastify@next fastify-static@next fastify-cli</code> </pre> <br> 请注意，在描述某些依赖<code>@next</code>时，我使用了<code>@next</code>构造。 这样做是为了确保项目使用Fastify 2库，该库当前处于候选发布状态，但很快将成为主要的稳定版本。 <br><br> 请注意，您还可以使用<code>fastify-cli</code>命令行<code>fastify-cli</code>基于Fastify创建一个新项目： <br><br><pre> <code class="plaintext hljs">npx fastify-cli generate server-time</code> </pre> <br> 在撰写本文时，该团队创建了一个旨在使用Fastify 1.x的项目，但是很快在Fastify 2发布之后，该工具将得到更新。 <br><br> 让我们分析一下已安装的软件包： <br><br><ul><li>  <code>fastify</code>是框架的核心组件。 </li><li>  <code>fastify-static</code>是一个附加插件，可让您方便地通过Fastify服务器提供静态文件。 </li><li>  <code>fastify-cli</code>是一个命令行工具，可让您基于Fastify创建项目。 </li></ul><br> 目前，我们准备创建基于Fastify的API。 因此，让我们将服务器代码放入<code>src/server/server.js</code> ： <br><br><pre> <code class="plaintext hljs">const path = require('path') module.exports = async function(fastify, opts) { //      `src/ui` fastify.register(require('fastify-static'), {   root: path.join(__dirname, '..', 'ui'), }) //     API fastify.get('/api/time', async (request, reply) =&gt; {   return { time: new Date().toISOString() } }) }</code> </pre> <br> 我相信上面的代码可以很好地说明自己，但是有一些有趣的细节值得一谈。 这对于没有Fastify经验的人尤其有用。 <br><br> 在此代码中需要注意的第一件事是此处使用了<code>async</code>关键字。  Fastify支持异步/等待样式开发和更传统的回调方法。 究竟要选择什么取决于特定开发人员的偏好。 <br><br> 另一个有趣的细节是，我们在这里将服务器定义为导出模块。 该模块（在Fastify术语中称为“插件”）是一个功能，它以Fastify的实例（ <code>fastify</code> ）和一组选项（ <code>opts</code> ）作为参数。 在模块声明中，我们可以使用<code>fastify</code>实例注册插件。 这正是<code>fastify-static</code>插件发生的情况。 我们还可以使用诸如<code>fastify.get</code>和<code>fastify.post</code>类的特殊方法来描述HTTP端点。 <br><br> 尽管看起来有点不寻常，但此处使用的模块化方法具有其优势。 首先，应注意，它允许您组合多个服务器。 想象一下，您已经创建了一个用于博客服务的服务器，以及一个用于论坛的服务器。 通过将它们附加到<code>/blog</code>和<code>/forum</code>类的路径，可以轻松地将它们集成到现有应用程序中。 <br><br> 此外，这种方法允许您从服务器绑定（例如套接字绑定）中抽象应用程序和子应用程序，将解决方案传递给根应用程序或<code>fastify-cli</code> 。 <br><br> 使用<code>fastify</code>命令行<code>fastify</code>启动服务器： <br><br><pre> <code class="plaintext hljs">node_modules/.bin/fastify start --log-level info src/server/server.js</code> </pre> <br> 为了简化我们的生活，我们可以将此命令添加到<code>package.json</code>文件的<code>scripts</code>部分： <br><br><pre> <code class="plaintext hljs">{ "scripts": {   "start": "fastify start --log-level info src/server/server.js" } }</code> </pre> <br> 在实际启动服务器之前，我们需要确保有一个静态资源将位于其中的文件夹。 否则， <code>fastify-static</code>将<code>fastify-static</code>错误。 创建此文件夹： <br><br><pre> <code class="plaintext hljs">mkdir src/ui</code> </pre> <br> 现在，我们可以使用<code>npm start</code>命令启动应用程序，并使用浏览器导航到<code>localhost:3000/api/time</code> 。 <br><br> 如果一切正常，在浏览器中，您将看到类似以下内容： <br><br><pre> <code class="plaintext hljs">{ "time": "2019-02-17T19:32:03.354Z" }</code> </pre> <br> 此时，您可以欣赏Fastify的另一个不错的功能。 事实是，在某些路由返回对象的情况下，会自动应用JSON序列化。 <br><br> 现在，有关服务器API的工作已完成。 让我们有一个前端。 <br><br><h2>  <font color="#3AC1EF">前端设定</font> </h2><br> 与前端相关的所有项目代码都位于<code>src/ui</code>文件夹中。 它将包含5个文件： <br><br><ul><li>  app.js-精确的应用程序代码。 </li><li>  <code>bootstrap.min.css</code>用于设置应用程序样式的CSS代码（直接从Bootstrap框架获取）。 </li><li>  <code>favicon.ico</code> -favicon文件。 如果您正在开发一个认真的应用程序，那么没有一个良好的favicon文件就无法做。 </li><li>  <code>index.html</code>是我们的一页应用程序的主要HTML文件。 </li><li>  <code>preacthtm.js</code> -Preact和htm库的代码。 </li></ul><br> 首先，将文件放置在文件夹中，它们是样式，库和图标图标： <br><br><pre> <code class="plaintext hljs">curl "https://unpkg.com/htm@2.0.0/preact/standalone.js" &gt; src/ui/preacthtm.js curl "https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" &gt; src/ui/bootstrap.min.css curl "https://github.com/lmammino/fastify-preact-htm-boilerplate/blob/master/src/ui/favicon.ico?raw=true" &gt; src/ui/favicon.ico</code> </pre> <br> 现在创建<code>src/ui/index.html</code>文件： <br><br><pre> <code class="plaintext hljs">&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;   &lt;meta charset="utf-8" /&gt;   &lt;meta     name="viewport"     content="width=device-width, initial-scale=1, shrink-to-fit=no"   /&gt;   &lt;!-- Bootstrap CSS --&gt;   &lt;link rel="stylesheet" href="/bootstrap.min.css" /&gt;   &lt;title&gt;My awesome server time&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div id="app"&gt;&lt;/div&gt;   &lt;!-- JavaScript --&gt;   &lt;script src="/preacthtm.js"&gt;&lt;/script&gt;   &lt;script src="/app.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br> 我们面前有一个非常普通的HTML页面，通过该页面我们可以加载所有资源（CSS和JS），并使用标识符<code>app</code>创建一个空的<code>&lt;div&gt;</code>元素，我们将在项目执行期间将应用程序输出到其中。 <br><br> 现在看一下应用程序代码，它应该在<code>src/ui/app.js</code> ： <br><br><pre> <code class="plaintext hljs">/*  htmPreact */ const { html, Component, render } = htmPreact class App extends Component { componentDidMount() {   this.setState({ loading: true, time: null })   fetch('/api/time')     .then(response =&gt; response.json())     .then(data =&gt; this.setState({ loading: false, time: data.time })) } render(props, state) {   return html`     &lt;div class="container mt-5"&gt;       &lt;div class="row justify-content-center"&gt;         &lt;div class="col"&gt;           &lt;h1&gt;Hello from your new App&lt;/h1&gt;           &lt;div&gt;             ${state.loading &amp;&amp;               html`                 &lt;p&gt;Loading time from server...&lt;/p&gt;               `} ${state.time &amp;&amp;               html`                 &lt;p&gt;Time from server: &lt;i&gt;&lt;font color="#999999"&gt;${state.time}&lt;/font&gt;&lt;/i&gt; &lt;/p&gt;               `}           &lt;/div&gt;           &lt;hr /&gt;           &lt;div&gt;             Have fun changing the code from this boilerplate:             &lt;ul&gt;               &lt;li&gt;UI code available at &lt;code&gt;/src/ui&lt;/code&gt;&lt;/li&gt;               &lt;li&gt;Server-side code available at &lt;code&gt;/src/server&lt;/code&gt;&lt;/li&gt;             &lt;/ul&gt;           &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   ` } } render( html`   &lt;${App} /&gt; `, document.getElementById('app') )</code> </pre> <br> 此应用程序中只有一个有状态的组件，称为<code>App</code> 。 该组件的状态包括2个变量： <br><br><ul><li>  <code>loading</code>是一个逻辑变量，用于指示是否正在某个特定时间点执行对服务器API的请求，以获得有关服务器时间的信息。 </li><li>  <code>time</code>一个字符串，其中包含从服务器接收的最新时间信息。 </li></ul><br> 如果您熟悉React，那么您可以轻松理解以上代码。 <br> 使用Preact和htm，我们可以通过声明扩展内置<code>Component</code>类的类来创建组件。 <br><br> 在此类中，我们可以使用生命周期方法（例如<code>componentDidMount()</code>来描述组件的行为，还可以使用行为类似于React中常规<code>render()</code>方法的方法。 <br><br> 在我们的例子中，将组件附加到页面上（ <code>componentDidMount()</code>方法），我们就设置状态<code>loading</code>属性并使用<code>fetch</code>执行API请求。 <br> 请求完成后，我们设置<code>time</code>状态属性的值，并将<code>loading</code>属性重置为<code>false</code> 。 <br><br> 每当组件状态更改或向其传递新属性时，都会自动调用<code>render()</code>方法。 在这种方法中，我们使用htm描述DOM组件。 <br><br>  htm库允许您使用带有特殊标记<code>html</code>标记模板文字来描述DOM节点。 在我们的模板文字中，可能会出现动态表达式，就像我们用来检查状态并决定如果应用程序正在从服务器加载数据以及是否已经在数据中显示的内容那样，已加载。 <br><br> 还值得注意的是，我们需要创建该应用程序的实例并将其显示在HTML页面上。 这是通过使用<code>htmPreact</code>全局对象的<code>render()</code>函数完成的。 <br><br> 现在，前端应用程序上的工作已完成。 您可以重新启动服务器，转到<code>localhost:3000</code>并尝试使用我们刚刚创建的内容。 例如，您可以在此应用程序的基础上开发自己的应用程序。 而且，当您构建的内容看起来足以将其展示给他人时，对于将应用程序打包到Docker容器中可能很有用。 <br><br><h2>  <font color="#3AC1EF">应用程序容器化</font> </h2><br> 我相信向他人展示您的新小型项目的最佳方法是为此目的使用Docker的功能。 <br><br> 多亏了Docker，任何试图在家中运行您的应用程序的人都无需考虑是否已安装了适当版本的Node.js和NPM，因此，他无需下载应用程序源代码即可通过输入正确的命令顺序来保重，安装其依赖项并启动服务器。 <br><br> 为了将应用程序打包到Docker容器中，我们需要在项目的根文件夹中创建一个非常简单的<code>Dockerfile</code> ： <br><br><pre> <code class="plaintext hljs">FROM node:11-alpine WORKDIR /app COPY . /app RUN npm install --production EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br> 在这里，我们描述以下操作： <br><br><ul><li> 该映像是基于基于Alpine Linux构建的Node.js 11映像创建的。 </li><li> 当前文件夹中的所有内容都会复制到容器的<code>/app</code>文件夹中。 </li><li> 之后，我们运行<code>npm install</code>命令下载并安装依赖项。 使用<code>--production</code>标志会导致这样的事实，即只会安装生产中部署项目所需的依赖项。 如果项目使用许多开发依赖项，则可以加快图像创建速度。 </li><li> 我们指示容器应具有开放孔3000，默认情况下，服务器将在该孔上工作。 </li><li> 最后，我们描述了一个命令<code>npm start</code> ，它将在容器启动时执行。 她启动该应用程序。 </li></ul><br> 为了收集容器的图像，请执行以下命令： <br><br><pre> <code class="plaintext hljs">docker build -t server-time .</code> </pre> <br> 几秒钟后，映像应已准备就绪，您应该能够启动容器： <br><br><pre> <code class="plaintext hljs">docker run -it -p 3000:3000 server-time</code> </pre> <br>  <code>-p</code>允许您配置容器端口3000和本地端口3000之间的连接。这将允许您访问位于<code>localhost:3000</code>的容器化应用程序。 <br> 现在，您可以与他人共享您的应用程序了。 为了在Docker环境中运行它，只要在计算机上安装了Docker，就足以在其文件夹中执行上述两个命令。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们讨论了如何使用Fastify和Preact创建一个用于快速开发Web应用程序的环境。 此外，我们讨论了如何使用Docker与其他人共享应用程序。 <br><br> 如上所述，建议的工具是为快速原型设计的，因此现在您可能想知道开发实际应用程序时缺少什么。 最有可能的是，当您提到“真实的应用程序”时，是指以下功能： <br><br><ul><li> 应用程序前端部分的资源汇编：可能使用Webpack，Babel或其他工具来创建优化的文件（捆绑包）。 </li><li> 在应用程序的前端进行路由。 </li><li> 服务器渲染 </li><li> 永久数据存储方式。 </li></ul><br> 开发实际应用程序的所有这些可能性尚未添加到此处讨论的技术集合中，因此，现在我将其视为开发原型的工具。 我敢肯定，如果您喜欢自己所看到的内容，并且将所有这些内容视为将来解决实际问题的应用程序的基础，则可以轻松找到所需内容并创建可用于Fastify和Preact的应用程序。生产发布。 <br><br>  <b>亲爱的读者们！</b> 您如何原型化Web应用程序？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442652/">https://habr.com/ru/post/zh-CN442652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442642/index.html">三月份阅读内容：针对营销人员，管理人员，开发人员和设计师的22本新书</a></li>
<li><a href="../zh-CN442644/index.html">大多数非编程技能可提高开发人员价值</a></li>
<li><a href="../zh-CN442646/index.html">Kubernetes网络：入口</a></li>
<li><a href="../zh-CN442648/index.html">去分配机制</a></li>
<li><a href="../zh-CN442650/index.html">React应用程序的分析和优化</a></li>
<li><a href="../zh-CN442654/index.html">切换到Next.js并加快歧管网站首页的加载7.5倍</a></li>
<li><a href="../zh-CN442658/index.html">使用CSS的8个技巧：视差，粘页脚等</a></li>
<li><a href="../zh-CN442660/index.html">调和牛顿与量子世界的数学</a></li>
<li><a href="../zh-CN442662/index.html">如何观看SDDL而不看分号</a></li>
<li><a href="../zh-CN442664/index.html">QIWI Kitchen 2月6日-现状如何+演讲者演讲</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>