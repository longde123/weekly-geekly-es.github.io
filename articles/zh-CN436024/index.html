<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 📴 ⚔️ 如何不乱扔Java 🍟 🐙 🥨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有一个普遍的误解，就是如果您不喜欢垃圾回收，那么您就不需要用Java来编写，而是要用C / C ++来编写。 在过去的三年中，我一直在编写用于货币交易的低延迟Java代码，而且我必须避免以各种方式创建不必要的对象。 结果，我为自己制定了一些简单的规则，即如何减少Java中的分配（如果不减少到零，然后...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何不乱扔Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436024/"><p> 有一个普遍的误解，就是如果您不喜欢垃圾回收，那么您就不需要用Java来编写，而是要用C / C ++来编写。 在过去的三年中，我一直在编写用于货币交易的低延迟Java代码，而且我必须避免以各种方式创建不必要的对象。 结果，我为自己制定了一些简单的规则，即如何减少Java中的分配（如果不减少到零，然后减少到合理的最低限度），而无需借助手动内存管理。 也许对社区中的某人也很有用。 </p><a name="habracut"></a><br><h2> 为什么根本避免垃圾 </h2><br><p> 关于GC是什么以及如何配置它们，已经有很多说法和文章了。 但是最终，无论您如何设置GC，乱抛垃圾的代码都无法达到最佳效果。 在吞吐量和延迟之间始终要权衡取舍。 要改善一个而不恶化另一个就变得不可能。 通常，GC开销是通过研究日志来衡量的-您可以从中了解暂停的时间和花费的时间。 但是，GC日志不包含有关此开销的所有信息。 线程创建的对象将自动放置在运行线程的处理器核心的L1高速缓存中。 这导致其他潜在有用数据被挤出。 通过大量分配，有用的数据也可以从L3缓存中推出。 线程下次访问该数据时，将发生未命中高速缓存，这将导致程序执行的延迟。 此外，由于L3高速缓存对于同一处理器中的所有内核都是通用的，因此垃圾流将推送L3高速缓存中的数据和其他线程/应用程序，即使它们是用裸C编写的，它们也已经遇到了额外的高速缓存未命中。并且不要创建垃圾。 没有设置，没有垃圾收集器（C4或ZGC都没有）将有助于解决此问题。 改善整体情况的唯一方法是不要不必要地创建不必要的对象。  Java与C ++不同，Java没有丰富的内存处理机制，但是，有许多方法可以最小化分配。 他们将被讨论。 </p><br><div class="spoiler">  <b class="spoiler_title">抒情离题</b> <div class="spoiler_text"><p> 当然，您不需要编写所有无垃圾代码。 关于Java语言的事情是，您可以通过仅删除主要垃圾源来极大地简化生活。 编写无锁算法时，您也不能处理安全的内存回收。 如果某些代码在应用程序启动时仅执行一次，那么它可以分配任意数量的代码，这没什么大不了的。 好吧，当然，消除多余垃圾的主要工作工具是分配探查器。 </p></div></div><br><h2> 使用原始类型 </h2><br><p>在许多情况下，最简单的事情是使用基本类型而不是对象类型。  JVM进行了许多优化，以最大程度地减少对象类型的开销，例如，缓存较小的整数类型值和内联简单类。 但是这些优化并不总是值得依赖的，因为它们可能无法解决：整数值可能不会被缓存，并且内联可能不会发生。 此外，在使用条件整数时，我们被迫遵循该链接，这有可能导致高速缓存未命中。 同样，所有对象都有标头，这些标头会占用缓存中的额外空间，从而从那里挤出其他数据。 让我们来看一下：原始int占用4个字节。 对象<code>Integer</code>占用16个字节+与此整数的链接的大小最小为4个字节（对于压缩的oop）。 总的来说，与<code>int</code>相比， <code>Integer</code>占用的空间多五（！） <code>int</code> 。 因此，最好自己使用基本类型。 我会举几个例子。 </p><br><h3> 例子1.常规计算 </h3><br><p> 假设我们有一个常规函数，它只是在计算一些东西。 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer a, Integer b, Integer c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><p> 这样的代码很可能会内联（方法和类），并且不会导致不必要的分配，但是您不能确定这一点。 即使发生这种情况， <code>NullPointerException</code>可能会飞出此处也存在问题。  JVM要么不得不在幕后插入<code>null</code>检查，要么从上下文中以某种方式理解到<code>null</code>不能作为参数。 无论如何，最好只在基元上编写相同的代码。 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><h3> 例子2. Lambdas </h3><br><p> 有时对象是在我们不知情的情况下创建的。 例如，如果我们将基本类型传递到期望的对象类型。 使用lambda表达式时，通常会发生这种情况。 <br> 假设我们有以下代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;Integer&gt; calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p> 尽管变量x是原始变量，但仍将创建Integer类型的对象，该对象将传递给计算器。 为了避免这种情况，请使用<code>IntConsumer</code>而不是<code>Consumer&lt;Integer&gt;</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntConsumer calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p> 这样的代码将不再导致创建额外的对象。  Java.util.function具有一整套适用于使用原始类型的标准接口： <code>DoubleSupplier</code> ， <code>LongFunction</code>等。 好吧，如果缺少某些东西，那么您总是可以使用基本元素添加所需的接口。 例如，可以使用自制界面来代替<code>BiConsumer&lt;Integer, Double&gt;</code> 。 </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntDoubleConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; }</code> </pre> <br><h3> 例子3.集合 </h3><br><p> 使用基本类型可能很困难，因为此类型的变量在集合中。 假设我们有一些<code>List&lt;Integer&gt;</code>并且我们想找出其中的数字并计算每个数字重复多少次。 为此，我们使用<code>HashMap&lt;Integer, Integer&gt;</code> 。 代码如下： </p><br><pre> <code class="java hljs">List&lt;Integer&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Map&lt;Integer, Integer&gt; counters = new HashMap&lt;&gt;(); for (Integer x : numbers) { counters.compute(x, (k, v) -&gt; v == null ? 1 : v + 1); }</span></span></code> </pre> <br><p> 这段代码在几种方面都是不好的。 首先，它使用中间数据结构，这可能不需要它。 好吧，为简单起见，我们假设以后会需要此列表。 您无法将其完全删除。 其次，在两个地方<code>Integer</code>使用对象<code>Integer</code>而不是原始<code>int</code> 。 第三， <code>compute</code>方法中有很多分配。 第四，分配迭代器。 但是，此分配可能会变成内联。 如何将此代码转换为无垃圾代码？ 您只需要对某些第三方库中的原语使用集合。 有许多包含此类集合的库。 以下代码使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">agrona</a>库。 </p><br><pre> <code class="java hljs">IntArrayList numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntArrayList(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Int2IntCounterMap counters = new Int2IntCounterMap(0); for (int i = 0; i &lt; numbers.size(); i++) { counters.incrementAndGet(numbers.getInt(i)); }</span></span></code> </pre> <br><p> 此处创建的对象是两个集合和两个<code>int[]</code> ，它们位于这些集合内。 通过对它们调用<code>clear()</code>方法，可以重用这两个集合。 使用基元上的集合，我们没有使代码复杂化（甚至通过删除其中包含复杂lambda的计算方法来简化了代码），并且与使用标准集合相比，还获得了以下额外好处： </p><br><ol><li> 几乎完全没有分配。 如果集合被重用，那么将根本没有分配。 </li><li> 节省大量内存（ <code>IntArrayList</code>占用的空间比<code>ArrayList&lt;Integer&gt;</code>少大约五倍。如上所述，我们关心的是处理器高速缓存（而不是RAM）的经济使用。 </li><li> 串行访问内存。 关于为何如此重要的话题已经写了很多，所以我不会就此止步。 以下是几篇文章： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Martin Thompson</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ulrich Drepper</a> 。 </li></ol><br><p> 关于收藏的另一个小评论。 可能会发现该集合包含不同类型的值，因此不可能用具有原语的集合替换它。 我认为，这表明数据结构或整个算法的设计不佳。 在这种情况下，最有可能不是主要问题。 </p><br><h2> 可变对象 </h2><br><p> 但是，如果不能放弃原语怎么办？ 例如，如果我们需要的方法应该返回几个值。 答案很简单-使用可变对象。 </p><br><div class="spoiler">  <b class="spoiler_title">小题外话</b> <div class="spoiler_text"><p> 有些语言强调使用不可变对象，例如在Scala中。 支持它们的主要论据是，大大简化了编写多线程代码的过程。 但是，还存在与垃圾过多分配相关的开销。 如果我们想避免它们，那么我们不应该创建短暂的不可变对象。 </p></div></div><br><p> 在实践中看起来像什么？ 假设我们需要计算商和除法的余数。 为此，我们使用以下代码。 </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 在这种情况下，如何摆脱分配？ 没错，将<code>IntPair</code>作为参数传递并在其中写入结果。 在这种情况下，您需要编写详细的javadoc，甚至更好的是，对变量名使用某种约定，并在其中写入结果。 例如，它们可以以前缀out开头。 在这种情况下，免费垃圾代码将如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor, IntPair outResult)</span></span></span><span class="hljs-function"> </span></span>{ outResult.x = value / divisor; outResult.y = value % divisor; }</code> </pre> <br><p> 我想指出， <code>divide</code>不应该将链接保存到任何地方配对或将其传递给可以做到这一点的方法，否则我们可能会遇到很大的问题。 如我们所见，可变对象比基本类型更难使用，因此，如果可以使用基本类型，则更好。 实际上，在我们的示例中，我们将分配问题从除法内部转移到外部。 在调用此方法的所有地方，我们都需要有一些<code>IntPair</code>虚拟对象，并将其传递给<code>divide</code> 。 通常足以将这个虚拟对象存储在对象的<code>final</code>字段中，在此我们称为<code>divide</code> 。 让我给您举一个牵强的示例：假设我们的程序仅处理通过网络接收数字流，将它们相除，然后将结果发送到同一套接字。 </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntPair pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BufferedReader in; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PrintWriter out; SocketListener(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Socket socket) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException { in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(socket.getInputStream())); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(socket.getOutputStream(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); divide(value, divisor, pair); out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p> 为简洁起见，我没有编写用于处理错误，正确终止程序等的“额外”代码。 这段代码的主要思想是，我们<code>IntPair</code>的<code>IntPair</code>对象创建一次并存储在<code>final</code>字段中。 </p><br><h2> 对象池 </h2><br><p> 当我们使用可变对象时，我们必须首先从某个地方取出一个空对象，然后将所需的数据写入其中，在某个地方使用它，然后“就地”返回该对象。 在上面的示例中，对象始终处于“适当位置”，即 在<code>final</code>领域。 不幸的是，这并非总是能够以简单的方式做到的。 例如，我们可能事先不确切知道我们需要多少个对象。 在这种情况下，对象池将为我们提供帮助。 当我们需要一个空对象时，我们从对象池中获取它，而当不再需要它时，我们将其返回。 如果池中没有可用的对象，则池将创建一个新对象。 实际上，这是一种手动内存管理，具有所有后续后果。 如果可以使用以前的方法，建议不要诉诸此方法。 可能出什么问题了？ </p><br><ul><li> 我们可以忘记将对象返回到池中，然后将创建垃圾（“内存泄漏”）。 这是一个小问题-性能会略有下降，但是GC将正常运行，并且程序将继续运行。 </li><li> 我们可以将对象返回到池中，但是将其链接保存到某个位置。 然后其他人将从池中获取该对象，此时，在我们的程序中，已经有两个指向同一对象的链接。 这是一个经典的售后使用问题。 很难登场，因为 与C ++不同，该程序不会崩溃，并且将继续<em>无法</em>正常工作。 </li></ul><br><p> 为了减少发生上述错误的可能性，您可以使用标准的try-with-resources构造。 它可能看起来像这样： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T object)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STORAGE.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p> 除法可能如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = IntPair.create(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p> 和<code>listenSocket</code>方法<code>listenSocket</code>这样的： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IntPair pair = divide(value, divisor)) { out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p> 在IDE中，当在try-with-resources块之外使用<code>AutoCloseable</code>对象时，通常可以配置所有情况的突出显示。 但这不是绝对的选择，因为 可以关闭IDE中的高亮显示。 因此，还有另一种保证对象返回池的方法-控制反转。 我举一个例子： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;IntPair&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(IntPair pair = STORAGE.get()) { consumer.accept(pair); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p> 在这种情况下，我们基本上无法<code>IntPair</code>外部访问<code>IntPair</code>类的对象。 不幸的是，这种方法也不总是有效。 例如，如果一个线程从池中获取对象并将其放入队列中，而另一个线程将其从队列中移出并返回池中，则它将不起作用。 </p><br><p> 显然，如果我们不在池中存储通用对象，但是某些库对象未实现<code>AutoCloseable</code> ，那么try-with-resources选项也将不起作用。 </p><br><p> 这里的另一个问题是多线程。 对象池的实现必须非常快，这很难实现。 慢速缓冲池对性能的危害大于弊。 反过来，TLAB中新对象的分配非常快，比C中的malloc快得多。编写快速对象池是我现在不想开发的独立主题。 我只能说我还没有看到任何好的“现成”实现。 </p><br><h2> 而不是结论 </h2><br><p> 简而言之，在对象池中重复使用对象是严重的痔疮。 幸运的是，几乎总是可以没有它。 我的个人经验是，过度使用对象池表示应用程序体系结构存在问题。 通常，对我们而言，在<code>final</code>字段中缓存的对象的一个​​实例就足够了。 但是，如果可以使用原始类型，那么即使这也太过分了。 </p><br><h2> 更新： </h2><br><p> 是的，对于那些不怕按位转换的人，我还记得另一种方法：将几种小的原始类型打包为一个大的原始类型。 假设我们需要返回两个<code>int</code> 。 在这种特殊情况下，您不能使用<code>IntPair</code>对象，而是返回一个<code>long</code> ，前四个字节将与第一个<code>IntPair</code>相对应，第二个4个字节与第二个<code>IntPair</code>相对应。 代码可能看起来像这样： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)left &lt;&lt; Integer.SIZE) | (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)right &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFL</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(value &gt;&gt;&gt; Integer.SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = value / divisor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combine(left, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> xy = divide(value, divisor); out.print(getLeft(xy)); out.print(getRight(xy)); } }</code> </pre> <br><p> 当然，需要对这些方法进行彻底的测试，因为将它们写下来非常容易。 但是然后就使用它。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436024/">https://habr.com/ru/post/zh-CN436024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436012/index.html">我是个无用的白痴，所以我想辞掉工作：给软件开发人员的10个问题，试点</a></li>
<li><a href="../zh-CN436014/index.html">混沌的数学模型</a></li>
<li><a href="../zh-CN436016/index.html">星号语音识别IVR-快速，轻松，免费</a></li>
<li><a href="../zh-CN436020/index.html">Magento 2：从外部来源导入产品</a></li>
<li><a href="../zh-CN436022/index.html">我们如何在自由软件中完全开发Librem 5 DevKit</a></li>
<li><a href="../zh-CN436026/index.html">咨询台：“ Internet存档”-历史，任务和附属项目</a></li>
<li><a href="../zh-CN436028/index.html">针对VMware用户的Kubernetes简介。 第一部分。理论</a></li>
<li><a href="../zh-CN436032/index.html">React教程第9部分：组件属性</a></li>
<li><a href="../zh-CN436036/index.html">人工智能研究人员可以委托他进行工作测试吗？</a></li>
<li><a href="../zh-CN436038/index.html">寂静之声：要达到最适合睡眠的环境，需要多少个疯狂的小玩意？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>