<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐱 👀 👘 Ein neues Spiel mit einer alten Atmosphäre auf Three.js. Teil 2 👨🏼‍⚕️ 👩🏼‍🤝‍👨🏿 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil habe ich über die Probleme gesprochen, die beim Erstellen eines 3D-Spiels für den Browser mit Three.js aufgetreten sind. Jetzt möchte i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein neues Spiel mit einer alten Atmosphäre auf Three.js. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Teil habe ich über die Probleme gesprochen, die beim Erstellen eines 3D-Spiels für den Browser mit Three.js aufgetreten sind.  Jetzt möchte ich ausführlich auf die Lösung einiger wichtiger Probleme beim Schreiben eines Spiels eingehen, z. B. das Erstellen von Ebenen, das Erkennen von Kollisionen und das Anpassen des Bilds an beliebige Proportionen des Browserfensters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Level-Diagramme </h3><br>  Tatsächlich werden die Ebenen selbst in einem 3D-Editor erstellt, nämlich ihre Geometrie, Texturabbildung, Backschatten usw.  Ich habe das alles im ersten Teil beschrieben.  Warum gibt es andere Systeme?  Tatsache ist, dass Three.js keine physische Engine bietet und ich Level-Schemata verwende, um Hindernisse zu identifizieren. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  Three.js zur Lösung des Kollisionsproblems bietet nur Raytracing - die einfachste Methode, um den Schnittpunkt der Geometrie von Objekten zu bestimmen.  Im Prinzip kann es verwendet werden, und ich habe es sogar in einem meiner anderen Projekte getan.  Es war eine virtuelle Stadt direkt auf der Website, im Browser.  Sie können sich in der Stadt bewegen und nicht durch die Mauern gehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  Für den Fall, dass der Schnittpunkt der Geometrie des Spielers und des Gebäudes während der Bewegung auftritt, habe ich die Abstoßung des Spielers um einen bestimmten Abstand in die der Wand entgegengesetzte Richtung implementiert.  Dafür müssen Objekte jedoch Parallelepipeds sein.  Um einige komplexe Objekte herum habe ich Collider erstellt (wir werden die unsichtbaren Objekte nennen, die die Rolle von Hindernissen spielen und den Spieler daran hindern, durch sich selbst zu gelangen), durch die Kreuzungen ausgearbeitet wurden.  Und die unteren Teile einiger Gebäude, die einfach „Kisten“ sind, wurden manchmal selbst als Kollider verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  Bei geometrisch komplexen Objekten funktioniert die Strahlverfolgung möglicherweise nicht oder verhält sich nicht unangemessen.  Und genau als Lösung können Sie nicht einen, sondern mehrere kleine unsichtbare Kollider in Form von Parallelepipeds mit 100% Transparenz in das Objekt einbetten, die nebeneinander und übereinander gezeichnet sind und die Form des Objekts grob wiederholen. <br><br>  Im Spiel über Dungeons ist das Level ein einzelnes langes Objekt mit Schnittbewegungen, um den Spieler zu bewegen.  Um das Kollisionsproblem zu lösen, könnte man bei Bedarf unsichtbare Kollider kleben und Raytracing verwenden.  Ich entschied mich jedoch für den anderen Weg. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  Zunächst wollte ich den Prozess der Erstellung einer Reihe von Collidern automatisieren. </li><li>  Zweitens können Sie nur Informationen über die Collider, dh deren Koordinaten im Raum, verwenden und die 3D-Szene selbst nicht mit zusätzlichen leeren Objekten laden. </li><li>  Drittens können Sie die Berechnung von Schnittpunkten in nur zwei Koordinaten verwenden, da das Spiel nur eine Seitenansicht verwendet und sich eine der Koordinaten beim Bewegen nie ändert. </li><li>  Und viertens wird es tatsächlich ein Level-Schema geben.  Darüber hinaus ist es einfach bequem, mit einem solchen Schema neue Level zu entwickeln.  Sie können einfach Blöcke in einem beliebigen Grafikeditor über den Bildschirm ziehen, neue Korridore und Hindernisse erstellen, dann das Skript ausführen und Informationen zu den Collidern abrufen.  Das heißt, das Problem des Level-Editors ist teilweise gelöst. </li></ul><br>  Ich habe ein Skript geschrieben, das Eingabeparameter wie den Namen der Level-Schema-Datei (png) und die Farbe verwendet, deren Füllung als Hindernis interpretiert wird.  Die Standardfarbe für freien Speicherplatz ist Schwarz.  Für die Verarbeitung durch das Skript muss das Schema jeder Ebene in einer separaten PNG-Datei gespeichert werden.  Für die unterste Ebene sieht es beispielsweise so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  Ich stimmte zu, dass ein Block 80 Pixel breit und 48 Pixel hoch sein sollte.  Dies entspricht 4 x 2,4 Metern in der 3D-Welt.  Es wäre möglich, 40 x 24 Pixel zu erstellen, das heißt zehnmal, aber auf dem Bild sieht es klein aus. <br><br>  Das Ergebnis des Skripts auf der ersten Ebene (das Bild wird rechts zugeschnitten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  Das Skript wird im Browser ausgeführt.  Ich denke, HTML-Markup macht keinen Sinn, es ist elementar: Dateneingabefelder und eine Startschaltfläche.  Als nächstes wird das gelesene Bild auf der Leinwand angezeigt.  Als Ergebnis des Skripts wird unter dem Bild in der 3D-Weltskala ein Array angezeigt, das die unteren linken und oberen rechten Koordinaten jedes Blocks sowie den im Skript für jede Ebene angegebenen Versatz enthält.  Dieses Array kann kopiert und in die Liste der im Spiel zu verwendenden Collider eingefügt werden (mehr dazu weiter unten). Es wird in einer Art Konstante gespeichert.  Koordinaten erscheinen auch auf dem Bild selbst, jedoch im Referenzrahmen des 2D-Bildes.  Diese Zahlen werden in der Mitte jedes Blocks angezeigt und ermöglichen es Ihnen, zu überprüfen, ob alle Blöcke in die Berechnung einbezogen sind.  Diese Nummern werden für nichts anderes als für die Sichtprüfung benötigt.  Einige Blöcke, z. B. Spalten, zwischen denen der Spieler spielt, sollten nicht gezählt werden.  Über welche Objekte von der Berechnung ausgeschlossen werden - siehe unten. <br><br>  Zusätzlich gibt es zum Beispiel auf der zweiten Ebene dünne horizontale Platten, auf denen der Spieler geht.  Sie müssen berücksichtigt werden.  Dementsprechend müssen Sie sicherstellen, dass auch Zahlen darauf erscheinen.  Machen Sie sie im Diagramm 2 Pixel hoch. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Nun, wie das Skript Blöcke berücksichtigt: <br><br><ul><li>  Das Schema wird von 80x48-Blöcken verarbeitet, in denen jeweils ein Bereich vom 2. bis zum 79. Pixel horizontal und vom 2. bis zum 47. Pixel vertikal genommen wird.  Das erste und das letzte Pixel werden nicht verwendet, sodass Sie um die Blöcke herum einen schwarzen Rahmen mit einer Breite von 1 Pixel erstellen können. Dies verbessert die visuelle Wahrnehmung der Schaltung und erleichtert deren Erstellung. </li><li>  Alle Pixel der oberen Reihe des Blocks werden angezeigt.  Wenn sich unter ihnen farbige befinden, gehen die Koordinaten des Blocks horizontal vom ersten bis zum letzten farbigen Pixel und vertikal bis zur vollen Höhe des Blocks im endgültigen Array.  Dies ist ein leerer Block mit voller oder teilweiser Breite. </li><li>  Alle Pixel der unteren Zeile des Blocks werden angezeigt.  Wenn sich unter ihnen farbige befinden, in der oberen Reihe jedoch keine farbige, werden die Koordinaten des Blocks horizontal vom ersten bis zum letzten farbigen Pixel und vertikal 3 Pixel vom unteren bis zum endgültigen Array verschoben.  Dies wird eine Plattform sein, auf der man laufen kann.  Innerhalb eines Blocks können sich mehrere horizontale Plattformen befinden.  Plattformen werden nur am unteren Rand des Blocks erkannt.  Die Koordinaten der Plattform werden in einen Block „versenkt“, der sich darunter befindet, so dass sich die Oberfläche der Plattform auf derselben Ebene befindet wie benachbarte Blöcke - nicht Plattformen. </li><li>  Spalten und andere Dekorationen innerhalb eines leeren Blocks werden nicht verarbeitet, da nur die obere und untere Pixelreihe berücksichtigt werden.  Daher können Sie innerhalb des Blocks Dekor, Erklärungen für das Diagramm, Zeiger, Spalten usw. platzieren, ohne befürchten zu müssen, dass dies das Ergebnis des Skripts irgendwie beeinflusst. </li></ul><br>  Anschließend werden alle aus dem Array erhaltenen Koordinaten in den Maßstab der 3D-Welt übersetzt, multipliziert mit dem Koeffizienten des Maßstabs (der beim Erstellen im 3D-Editor ausgewählt wurde).  Das Array ist für den Einsatz im Spiel bereit.  Der Skriptcode wurde in Eile geschrieben, gibt also nicht vor, elegant zu sein, sondern erfüllt seine Aufgabe. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Nun - darüber, wie das Spiel mit einer Reihe von Blöcken funktioniert.  Das Spiel verwendet sich kreuzende Korridore (Ebenen).  Wenn sich ein Spieler in einen Korridor verwandelt, wird ein neues Array von Blöcken verbunden: und für jeden Korridor wird dementsprechend ein eigenes Array erhalten, das aus seinem Level-Schema erhalten wird.  Während der Bewegung des Spielers werden seine Koordinaten darauf überprüft, dass sie sich in jedem Block befinden.  Und wenn er sich in einem Block befindet, bekommen wir eine Kollision.  Aber bei jeder Bewegung des Spielers müssen wir nicht nach Schnittpunkten mit allen Blöcken des Levels suchen, da es viele davon geben kann.  Erstellen Sie ein Array nur der Blöcke, die dem Player am nächsten liegen. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Hier am Eingang x, y sind die aktuellen Koordinaten des Spielers, dw, dh ist die Entfernung, in der Sie horizontal und vertikal nach Blöcken suchen möchten, beispielsweise 12 und 8 Meter.  Mit anderen Worten, nehmen Sie alle Blöcke um den Spieler auf einem Quadrat von 24 x 16 Metern.  Sie werden an der Suche nach Zusammenstößen teilnehmen.  ap.v.lv.d [i] ist ein Element eines Arrays von Blöcken der aktuellen Ebene. Tatsächlich ist er selbst auch ein Array von 4 Zahlen, die die Grenzen eines Blocks definieren - [x1, y1, x2, y2], um das Quadrat zu überprüfen horizontal nehmen wir Elemente mit den Indizes 0 und 2 und vertikal - 1 und 3. Wenn es eine Übereinstimmung gibt, fügen Sie diesen Block der Liste für Kollisionen ap.v.coll hinzu. <br><br>  Wenn sich der Spieler bewegt, aktualisieren wir diese Liste der Kollisionen. Um jedoch die Leistung zu sparen, tun wir dies nicht bei jedem Schritt (oder besser gesagt beim Rendern des Rahmens), sondern wenn der Spieler ein bestimmtes, etwas kleineres Quadrat verlässt, das in ap.v.collwStep und angegeben ist ap.v.collhStep, z. B. 8 und 4 Meter.  Das heißt, wir werden das Kollisionsarray wieder zusammensetzen, wenn der Spieler einen bestimmten Pfad horizontal oder vertikal von seiner ursprünglichen Position aus passiert.  Erinnern wir uns gleichzeitig an die Position, an der wir das Array wieder zusammengesetzt haben, um es für die nächste Iteration zu verwenden.  pers [ax] - hier meinen wir mit ax die Koordinatenachse (ax), sie kann x oder z sein, abhängig von der Richtung des Korridors, entlang dem der Spieler geht. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  Warum solche Schwierigkeiten?  Warum nicht die gesamte Reihe von Kollisionen auf der Ebene nutzen und kein Dampfbad nehmen?  Tatsache ist, dass die Kollisionserkennung nach einem viel komplexeren Algorithmus durchgeführt wird und es unrentabel ist, die Kollision bei jedem Frame-Rendering mit absolut allen Ebenenblöcken und nicht mit den nächstgelegenen zu überprüfen.  (Obwohl dies nicht korrekt ist.) <br><br>  Die Definition von Kollisionen bei jedem Rendern eines Frames unter Verwendung des oben vorbereiteten Kollisionsarrays: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Hier sind x, y, xOld, yOld die neuen und aktuellen Koordinaten des Spielers.  Neue werden auf Knopfdruck basierend auf einer bestimmten Bewegungsgeschwindigkeit berechnet, dh dies sind mögliche Koordinaten.  Sie werden überprüft, um festzustellen, ob sie in einen Block der Kollisionsliste fallen.  Wenn sie fallen, rollen sie zu den alten zurück und der Spieler passiert das Hindernis nicht.  Und wenn sie nicht fallen, werden sie aktuell.  pw2 und ph2 sind halb so breit und hoch wie der imaginäre Collider des Spielers (Spielerbreite / 2, Spielerhöhe / 2).  Die Ausgabe wird ausgegeben, wenn eine horizontale und vertikale Kollision vorliegt (collw, collh), ob sich unter dem Player ein Supportblock befindet (supportf) - dies macht deutlich, ob die Herbstanimation weiter gestartet werden soll oder ob der Player einfach zu einem benachbarten Block gewechselt hat und so weiter.  Fragen Sie einfach nicht, warum ich dort 0,001 addiert und 0,11 subtrahiert habe.  Dies ist eine schreckliche Krücke, die verhindert, dass sie durch die Blöcke fällt und Jitter verursacht, wenn sie mit einem horizontalen Hindernis kollidiert ... Diese Funktion funktioniert, muss jedoch auf normale Weise neu geschrieben werden.  Die Optimierung dieser Funktion fehlt ebenfalls noch. <br><br>  Ich denke, bei Kollisionen lohnt es sich, hier zu enden. <br><br>  Es ist schwer zu sagen, wie viel schneller oder vielleicht langsamer als das Raytracing meiner Methode ist, aber im letzteren Fall speichert Three.js auch eine Reihe von Objekten, die am Kollisionssystem beteiligt sind.  Es ist nur so, dass die Kollisionen dort durch die Methode der Emission des Strahls und seinen Schnittpunkt mit den Ebenen der Seiten der Objekte und bei mir durch die Bestimmung bestimmt werden, ob die Koordinaten eines Objekts entlang jeder der beiden Achsen innerhalb des anderen liegen. <br><br>  Das Spiel hat auch sich bewegende Objekte (Hai) und Markierungsobjekte, die eine Art Animation auslösen (z. B. löst der Kontakt mit Wasser die Bewegung eines Hais aus).  Alle diese Objekte nehmen auch an Kollisionen teil, einige mit zeitlich variierenden Koordinaten.  Dort ist seltsamerweise alles einfacher: Während der Bewegung des Objekts werden seine Koordinaten mit den Koordinaten des Spielers verglichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  Im Allgemeinen ist die Pflege eines Javascript-Gamepads in einem Browser keine triviale Aufgabe.  Es gibt keine Tastendruck- und Freigabeereignisse.  Es gibt nur Ereignisse, die das Gerät und den Status verbinden und trennen, die durch regelmäßige Abfragen ermittelt und dann mit dem vorherigen verglichen werden können. <br><br>  Ein Video, das die Funktionsweise des Gamepads in einem Browser auf einem Tablet unter Windows 8.1 und einem PC unter Windows 10 zeigt. Das Tablet ist jedoch ein altes, das 2014 veröffentlicht wurde, sodass die dynamische Beleuchtung im Spiel darauf ausgeschaltet wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Um das Gamepad abzufragen, wird eine Funktion verwendet, die alle 100 Millisekunden aufgerufen wird.  Es wird mit der Funktion meiner Bibliothek m3d.lib.globalTimer.addEvent eingestellt. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  Hier ist globalTimer das von mir geschriebene Javascript setInterval Timer Event Management System.  Dort wird einfach eine Reihe von Ereignissen zu einem bestimmten Array hinzugefügt, die in unterschiedlichen Intervallen aufgerufen werden müssen.  Dann wird ein setInterval-Timer mit der Frequenz eingestellt, die dem Ereignis mit der höchsten Frequenz von allen entspricht.  Der Timer fragt die Funktion m3d.lib.globalTimer.update () ab, die die Liste aller Ereignisse durchläuft und die Funktionen derjenigen ausführt, die ausgeführt wurden.  Beim Hinzufügen oder Entfernen von Ereignissen kann sich auch die Intervallfrequenz ändern (z. B. wenn Sie das schnellste Ereignis löschen). <br><br>  Das Spiel legt außerdem Handler für jede Gamepad-Taste fest: 'a' steht für die Achse (Axt), 'b' für die Schaltfläche (Schaltfläche) und 11 für die linke Abweichung entlang der horizontalen Achse des Kreuzes (als ob die Schaltfläche 1). 12 - die rechte Abweichung entlang der horizontalen Achse des Kreuzes (als ob seine Taste 2), 21 und 22 - für die vertikale Achse.  Zum Beispiel: <br><br>  ['a', 11], <br>  ['b', 3] <br><br>  bedeutet, dass die nächste Funktion gleichzeitig für die Abweichung entlang der horizontalen Achse nach links und für die Taste 3 (links) eingestellt wird.  Nun, dann wird eine Funktion eingestellt, die ausgeführt wird, wenn die Taste gedrückt und dann losgelassen wird. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Hier ist apcontrolsRenderStart () eine Funktion, die ein Rendering startet, wenn es noch nicht ausgeführt wird.  Im Allgemeinen ist die Unterstützung für das Gamepad eng mit meiner m3d-Bibliothek verbunden. Wenn ich also alle Funktionen beschreibe, wird es sich sehr lange erstrecken ... <br><br>  Ich gebe Ihnen nur einen Teil davon - das Gamepad, in dem ich die Initialisierung des Gamepads, die Installation von Handlern und die Statusabfrage auf einfachste Weise implementiert habe. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  Im Allgemeinen ist die Gamepad-Unterstützung im Spiel noch unvollständig: Es wird nur die Unterstützung für das einfachste Gamepad implementiert, nicht jedoch die, die beispielsweise in der XBox verwendet wird, da ich sie nicht habe.  Wenn ich es bekomme, programmiere ich es und arbeite damit.  Dort ist es möglich, die Geschwindigkeit des Charakters anzupassen, dh es ist möglich, sich mit jeder Geschwindigkeit im Bereich von Schritt zu Lauf zu bewegen.  Dies wird erreicht, indem Bruchparameter von den Achsen genommen werden.  Mein Gamepad gibt nur die Ganzzahlen -1 und 1 zurück. Außerdem hat mein Gamepad ein ekelhaftes Kreuz, und wenn es nach links oder rechts gedrückt wird, wird gleichzeitig nach unten oder oben gedrückt.  Daher habe ich oben und unten am Kreuz nicht verwendet und es mit den Schaltflächen rechts auf dem Gamepad dupliziert ... Bis zur Veröffentlichung des Spiels habe ich vor, mehrere Profile von Gamepads zu erstellen.  Außerdem werden beim Anschluss mehrerer Gamepads bisher nur letztere verwendet. <br><br><h3>  Reaktionsbildschirm </h3><br>  Das Spiel ist für ein Seitenverhältnis von 16: 9 ausgelegt.  Ich habe jedoch eine automatische horizontale Anpassung von ± 10% hinzugefügt, damit im erweiterten Browserfenster keine solchen schwarzen Balken an den Seiten angezeigt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  Und es wäre so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  Im Vollbildmodus wird es echtes 16: 9 geben.  Es wäre möglich, das Bild im Allgemeinen an jedes Seitenverhältnis des Browserfensters anzupassen, aber ich habe es nicht getan, da ein niedrig breites Fenster zu einem zu großen Betrachtungswinkel führen würde, was aus Sicht des Spiels nicht gut ist: entfernte Sackgassen, Objekte, Feinde sind sofort sichtbar und alles andere, was der Spieler noch nicht sehen muss.  Daher beschränkte ich mich darauf, innerhalb von ± 10% von 16: 9 einzustellen.  Bei schmalen Monitoren (4: 3) erkannte ich jedoch die Möglichkeit, durch Drücken der Y-Taste von 16: 9 in den Anpassungsmodus von 4: 3 auf 16: 9 zu wechseln.  Aber nicht breiter - also auch hier, um das Gameplay nicht zu brechen.  Das heißt, Sie können im klassischen Verhältnis 16: 9 spielen oder das Bild auf die Höhe des Fensters vergrößern, indem Sie es horizontal zuschneiden.  Dies ist jedoch auch nicht sehr gut, beispielsweise in Arcade-Situationen, in denen etwas von der Seite auf den Spieler zufliegt.  Für die Reaktion bleibt wenig Zeit.  Sie können jedoch jederzeit schnell zum klassischen Modus zurückkehren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  Die Anpassung des Bildschirms sowie alle im Spiel verwendeten Hotkeys werden im folgenden Video gezeigt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Tatsächlich wird das Seitenverhältnis in den Spieleinstellungen festgelegt. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  Und im Spiel, wenn Sie Y drücken, wechselt es: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Meine Bibliothek hat ein Ereignis, das im Fenster zum Ändern der Größe hängt.  Hier ist ein Fragment davon: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  m3d.lib.inBlock ist auch eine Funktion meiner Bibliothek, die ein Rechteck mit Parametern wie Zentrieren, Skalieren oder Zuschneiden in ein anderes Rechteck einschreibt und die neuen Abmessungen des beschrifteten Rechtecks ​​sowie die Größe der Felder anzeigt, die in diesem Prozess gebildet werden.  Basierend auf diesen Informationen wird der div-Container des Fensters positioniert.  'Renderer' ist ein Blockkontextelement einer 3D-Szene.  Dann wird die Leinwand dort gemäß den erhaltenen Parametern skaliert. <br><br>  Die Benutzeroberfläche wird im Container auf einem separaten Canvas-Element angezeigt.  Im Allgemeinen besteht der Dokumentbaum aus drei transparenten DIV-Blöcken mit absoluter Positionierung (je nach den Anforderungen des Spiels mehr oder weniger möglich): Unten befindet sich die Leinwand der 3D-Szene, oben die Leinwand für IU und oben die Animationselemente der Benutzeroberfläche und andere visuelle Effekte .  Das heißt, die Benutzeroberfläche wird nicht in 3D gerendert, sondern auf ihrem Knavass oder ihrer Ebene.  Die Aufgabe, Ebenen zu einem einzigen Bild zu kombinieren, bleibt dem Browser überlassen.  Um mit der Benutzeroberfläche zu arbeiten, habe ich ein spezielles Objekt in der Bibliothek.  Kurz gesagt - das Wesentliche ist wie folgt.  Sprite-Listen mit UI-Elementen im PNG-Format mit Transparenz werden geladen.  Von dort werden die notwendigen Elemente übernommen - Hintergründe, Schaltflächen.  Und sie werden mit der Funktion js drawImage (img, ix, iy, iw, ih, x, y, w, h) auf der mittleren Leinwand gezeichnet.  Das heißt, die erforderlichen Fragmente aus dem Bild werden an den erforderlichen Positionen auf dem Bildschirm angezeigt.  Über den damit verbundenen Hintergründen werden Schaltflächen angezeigt. Alle Positionen und Größen werden in der UI-Konfiguration festgelegt.  Beim Ändern der Fenstergröße werden die Positionen von Elementen auf der Zielleinwand (auf der sie angezeigt werden) neu berechnet, je nachdem, ob dieses oder jenes Element horizontal und vertikal zentriert oder an einer Ecke oder Fläche des Bildschirms ausgerichtet ist.  Dadurch wird eine adaptive Benutzeroberfläche erstellt, die nicht vom Seitenverhältnis des Bildschirms abhängt.  Es ist nur erforderlich, die minimal mögliche Auflösung horizontal und vertikal einzustellen und nicht darunter zu fallen, damit sich die Elemente nicht überlappen.  Ich werde ein anderes Mal über die Benutzeroberfläche sprechen, da sich der Artikel als umfangreich herausstellte und ich immer noch an der Benutzeroberfläche arbeite, da mir noch viele Funktionen fehlen.  Auf hochauflösenden Monitoren sieht die Benutzeroberfläche beispielsweise klein aus.  Abhängig von der Bildschirmauflösung können Sie die Größe der Elemente mit einem bestimmten Koeffizienten multiplizieren.  Andererseits werden die riesigen Schaltflächen auf dem Bildschirm möglicherweise nicht benötigt?  Wenn die Bildschirmauflösung sehr groß ist, ist der Bildschirm selbst ziemlich groß. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  Sie können dem Programmierer die Wahl lassen, ob die IU dynamisch mit der Größe des Fensters skaliert oder die Elemente in den Ecken verteilt werden sollen.  Bei der dynamischen Größe gibt es auch eigene Fragen - zum Beispiel die „Seife“ einer Benutzeroberfläche, wenn sie in zu großem Maßstab angezeigt wird.  Wenn Sie Sprites von Schnittstellenelementen in einer absichtlich großen Auflösung erstellen, nehmen diese viel Platz ein und sind wahrscheinlich auch für kleine Geräte nicht nützlich - sie benötigen immer noch keine großen Sprites, verbrauchen jedoch Speicher. <br><br>  Ich denke das reicht für heute.  Es gibt noch etwas zu überlegen, wie man dies oder das umsetzt.  In der Zwischenzeit schweife ich für einige Zeit vom Programmieren ab und mache Werbung.  Ich habe vor, an zwei Indie-Showcases teilzunehmen, und bin aktiv an der Förderung des Spiels in sozialen Netzwerken beteiligt, da ich im November die Crowdfunding-Plattform betreten möchte: Ich benötige Spezialisten auf dem Gebiet der 3D-Grafik und der Skelettanimation, um das Spiel zu vervollständigen. <br><br>  In den folgenden Artikeln werde ich über Touch-Steuerelemente in Browsern für mobile Geräte sprechen - nicht jeder verbindet ein Gamepad oder eine Tastatur mit dem Tablet, über die Optimierung von 3D-Grafiken für Geräte mit geringem Stromverbrauch und vieles mehr. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472272/">https://habr.com/ru/post/de472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472258/index.html">Wie man "lernt zu lernen" - die Achtsamkeit verbessert</a></li>
<li><a href="../de472262/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 318 (vom 14. bis 20. Oktober)</a></li>
<li><a href="../de472264/index.html">Digitale Archäologie und virtuelle Realität oder wie ich versucht habe, mich mit BIM und VR anzufreunden</a></li>
<li><a href="../de472268/index.html">Verbessern der Microsoft Edge-Steuerelemente auf Chromium</a></li>
<li><a href="../de472270/index.html">„Sie haben keinen Zugang zum aktuellen Gebet“: High-Tech-Perlen aus dem Vatikan wurden in 15 Minuten gehackt</a></li>
<li><a href="../de472274/index.html">Remote SSH: Tipps und Hacks</a></li>
<li><a href="../de472278/index.html">Mein Lieblingsgit Commit</a></li>
<li><a href="../de472280/index.html">Die Aufgabe, das Vorhandensein einer Handfläche auf einem Venenscanner festzustellen</a></li>
<li><a href="../de472288/index.html">9 nützliche Browser-Erweiterungen für Entwickler (Liste für 2020)</a></li>
<li><a href="../de472290/index.html">Strukturen gegen Klassen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>