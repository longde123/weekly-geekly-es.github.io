<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê± üëÄ üëò Ein neues Spiel mit einer alten Atmosph√§re auf Three.js. Teil 2 üë®üèº‚Äç‚öïÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèø üë®üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil habe ich √ºber die Probleme gesprochen, die beim Erstellen eines 3D-Spiels f√ºr den Browser mit Three.js aufgetreten sind. Jetzt m√∂chte i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein neues Spiel mit einer alten Atmosph√§re auf Three.js. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Teil habe ich √ºber die Probleme gesprochen, die beim Erstellen eines 3D-Spiels f√ºr den Browser mit Three.js aufgetreten sind.  Jetzt m√∂chte ich ausf√ºhrlich auf die L√∂sung einiger wichtiger Probleme beim Schreiben eines Spiels eingehen, z. B. das Erstellen von Ebenen, das Erkennen von Kollisionen und das Anpassen des Bilds an beliebige Proportionen des Browserfensters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Level-Diagramme </h3><br>  Tats√§chlich werden die Ebenen selbst in einem 3D-Editor erstellt, n√§mlich ihre Geometrie, Texturabbildung, Backschatten usw.  Ich habe das alles im ersten Teil beschrieben.  Warum gibt es andere Systeme?  Tatsache ist, dass Three.js keine physische Engine bietet und ich Level-Schemata verwende, um Hindernisse zu identifizieren. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  Three.js zur L√∂sung des Kollisionsproblems bietet nur Raytracing - die einfachste Methode, um den Schnittpunkt der Geometrie von Objekten zu bestimmen.  Im Prinzip kann es verwendet werden, und ich habe es sogar in einem meiner anderen Projekte getan.  Es war eine virtuelle Stadt direkt auf der Website, im Browser.  Sie k√∂nnen sich in der Stadt bewegen und nicht durch die Mauern gehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  F√ºr den Fall, dass der Schnittpunkt der Geometrie des Spielers und des Geb√§udes w√§hrend der Bewegung auftritt, habe ich die Absto√üung des Spielers um einen bestimmten Abstand in die der Wand entgegengesetzte Richtung implementiert.  Daf√ºr m√ºssen Objekte jedoch Parallelepipeds sein.  Um einige komplexe Objekte herum habe ich Collider erstellt (wir werden die unsichtbaren Objekte nennen, die die Rolle von Hindernissen spielen und den Spieler daran hindern, durch sich selbst zu gelangen), durch die Kreuzungen ausgearbeitet wurden.  Und die unteren Teile einiger Geb√§ude, die einfach ‚ÄûKisten‚Äú sind, wurden manchmal selbst als Kollider verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  Bei geometrisch komplexen Objekten funktioniert die Strahlverfolgung m√∂glicherweise nicht oder verh√§lt sich nicht unangemessen.  Und genau als L√∂sung k√∂nnen Sie nicht einen, sondern mehrere kleine unsichtbare Kollider in Form von Parallelepipeds mit 100% Transparenz in das Objekt einbetten, die nebeneinander und √ºbereinander gezeichnet sind und die Form des Objekts grob wiederholen. <br><br>  Im Spiel √ºber Dungeons ist das Level ein einzelnes langes Objekt mit Schnittbewegungen, um den Spieler zu bewegen.  Um das Kollisionsproblem zu l√∂sen, k√∂nnte man bei Bedarf unsichtbare Kollider kleben und Raytracing verwenden.  Ich entschied mich jedoch f√ºr den anderen Weg. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  Zun√§chst wollte ich den Prozess der Erstellung einer Reihe von Collidern automatisieren. </li><li>  Zweitens k√∂nnen Sie nur Informationen √ºber die Collider, dh deren Koordinaten im Raum, verwenden und die 3D-Szene selbst nicht mit zus√§tzlichen leeren Objekten laden. </li><li>  Drittens k√∂nnen Sie die Berechnung von Schnittpunkten in nur zwei Koordinaten verwenden, da das Spiel nur eine Seitenansicht verwendet und sich eine der Koordinaten beim Bewegen nie √§ndert. </li><li>  Und viertens wird es tats√§chlich ein Level-Schema geben.  Dar√ºber hinaus ist es einfach bequem, mit einem solchen Schema neue Level zu entwickeln.  Sie k√∂nnen einfach Bl√∂cke in einem beliebigen Grafikeditor √ºber den Bildschirm ziehen, neue Korridore und Hindernisse erstellen, dann das Skript ausf√ºhren und Informationen zu den Collidern abrufen.  Das hei√üt, das Problem des Level-Editors ist teilweise gel√∂st. </li></ul><br>  Ich habe ein Skript geschrieben, das Eingabeparameter wie den Namen der Level-Schema-Datei (png) und die Farbe verwendet, deren F√ºllung als Hindernis interpretiert wird.  Die Standardfarbe f√ºr freien Speicherplatz ist Schwarz.  F√ºr die Verarbeitung durch das Skript muss das Schema jeder Ebene in einer separaten PNG-Datei gespeichert werden.  F√ºr die unterste Ebene sieht es beispielsweise so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  Ich stimmte zu, dass ein Block 80 Pixel breit und 48 Pixel hoch sein sollte.  Dies entspricht 4 x 2,4 Metern in der 3D-Welt.  Es w√§re m√∂glich, 40 x 24 Pixel zu erstellen, das hei√üt zehnmal, aber auf dem Bild sieht es klein aus. <br><br>  Das Ergebnis des Skripts auf der ersten Ebene (das Bild wird rechts zugeschnitten): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  Das Skript wird im Browser ausgef√ºhrt.  Ich denke, HTML-Markup macht keinen Sinn, es ist elementar: Dateneingabefelder und eine Startschaltfl√§che.  Als n√§chstes wird das gelesene Bild auf der Leinwand angezeigt.  Als Ergebnis des Skripts wird unter dem Bild in der 3D-Weltskala ein Array angezeigt, das die unteren linken und oberen rechten Koordinaten jedes Blocks sowie den im Skript f√ºr jede Ebene angegebenen Versatz enth√§lt.  Dieses Array kann kopiert und in die Liste der im Spiel zu verwendenden Collider eingef√ºgt werden (mehr dazu weiter unten). Es wird in einer Art Konstante gespeichert.  Koordinaten erscheinen auch auf dem Bild selbst, jedoch im Referenzrahmen des 2D-Bildes.  Diese Zahlen werden in der Mitte jedes Blocks angezeigt und erm√∂glichen es Ihnen, zu √ºberpr√ºfen, ob alle Bl√∂cke in die Berechnung einbezogen sind.  Diese Nummern werden f√ºr nichts anderes als f√ºr die Sichtpr√ºfung ben√∂tigt.  Einige Bl√∂cke, z. B. Spalten, zwischen denen der Spieler spielt, sollten nicht gez√§hlt werden.  √úber welche Objekte von der Berechnung ausgeschlossen werden - siehe unten. <br><br>  Zus√§tzlich gibt es zum Beispiel auf der zweiten Ebene d√ºnne horizontale Platten, auf denen der Spieler geht.  Sie m√ºssen ber√ºcksichtigt werden.  Dementsprechend m√ºssen Sie sicherstellen, dass auch Zahlen darauf erscheinen.  Machen Sie sie im Diagramm 2 Pixel hoch. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Nun, wie das Skript Bl√∂cke ber√ºcksichtigt: <br><br><ul><li>  Das Schema wird von 80x48-Bl√∂cken verarbeitet, in denen jeweils ein Bereich vom 2. bis zum 79. Pixel horizontal und vom 2. bis zum 47. Pixel vertikal genommen wird.  Das erste und das letzte Pixel werden nicht verwendet, sodass Sie um die Bl√∂cke herum einen schwarzen Rahmen mit einer Breite von 1 Pixel erstellen k√∂nnen. Dies verbessert die visuelle Wahrnehmung der Schaltung und erleichtert deren Erstellung. </li><li>  Alle Pixel der oberen Reihe des Blocks werden angezeigt.  Wenn sich unter ihnen farbige befinden, gehen die Koordinaten des Blocks horizontal vom ersten bis zum letzten farbigen Pixel und vertikal bis zur vollen H√∂he des Blocks im endg√ºltigen Array.  Dies ist ein leerer Block mit voller oder teilweiser Breite. </li><li>  Alle Pixel der unteren Zeile des Blocks werden angezeigt.  Wenn sich unter ihnen farbige befinden, in der oberen Reihe jedoch keine farbige, werden die Koordinaten des Blocks horizontal vom ersten bis zum letzten farbigen Pixel und vertikal 3 Pixel vom unteren bis zum endg√ºltigen Array verschoben.  Dies wird eine Plattform sein, auf der man laufen kann.  Innerhalb eines Blocks k√∂nnen sich mehrere horizontale Plattformen befinden.  Plattformen werden nur am unteren Rand des Blocks erkannt.  Die Koordinaten der Plattform werden in einen Block ‚Äûversenkt‚Äú, der sich darunter befindet, so dass sich die Oberfl√§che der Plattform auf derselben Ebene befindet wie benachbarte Bl√∂cke - nicht Plattformen. </li><li>  Spalten und andere Dekorationen innerhalb eines leeren Blocks werden nicht verarbeitet, da nur die obere und untere Pixelreihe ber√ºcksichtigt werden.  Daher k√∂nnen Sie innerhalb des Blocks Dekor, Erkl√§rungen f√ºr das Diagramm, Zeiger, Spalten usw. platzieren, ohne bef√ºrchten zu m√ºssen, dass dies das Ergebnis des Skripts irgendwie beeinflusst. </li></ul><br>  Anschlie√üend werden alle aus dem Array erhaltenen Koordinaten in den Ma√üstab der 3D-Welt √ºbersetzt, multipliziert mit dem Koeffizienten des Ma√üstabs (der beim Erstellen im 3D-Editor ausgew√§hlt wurde).  Das Array ist f√ºr den Einsatz im Spiel bereit.  Der Skriptcode wurde in Eile geschrieben, gibt also nicht vor, elegant zu sein, sondern erf√ºllt seine Aufgabe. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Nun - dar√ºber, wie das Spiel mit einer Reihe von Bl√∂cken funktioniert.  Das Spiel verwendet sich kreuzende Korridore (Ebenen).  Wenn sich ein Spieler in einen Korridor verwandelt, wird ein neues Array von Bl√∂cken verbunden: und f√ºr jeden Korridor wird dementsprechend ein eigenes Array erhalten, das aus seinem Level-Schema erhalten wird.  W√§hrend der Bewegung des Spielers werden seine Koordinaten darauf √ºberpr√ºft, dass sie sich in jedem Block befinden.  Und wenn er sich in einem Block befindet, bekommen wir eine Kollision.  Aber bei jeder Bewegung des Spielers m√ºssen wir nicht nach Schnittpunkten mit allen Bl√∂cken des Levels suchen, da es viele davon geben kann.  Erstellen Sie ein Array nur der Bl√∂cke, die dem Player am n√§chsten liegen. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Hier am Eingang x, y sind die aktuellen Koordinaten des Spielers, dw, dh ist die Entfernung, in der Sie horizontal und vertikal nach Bl√∂cken suchen m√∂chten, beispielsweise 12 und 8 Meter.  Mit anderen Worten, nehmen Sie alle Bl√∂cke um den Spieler auf einem Quadrat von 24 x 16 Metern.  Sie werden an der Suche nach Zusammenst√∂√üen teilnehmen.  ap.v.lv.d [i] ist ein Element eines Arrays von Bl√∂cken der aktuellen Ebene. Tats√§chlich ist er selbst auch ein Array von 4 Zahlen, die die Grenzen eines Blocks definieren - [x1, y1, x2, y2], um das Quadrat zu √ºberpr√ºfen horizontal nehmen wir Elemente mit den Indizes 0 und 2 und vertikal - 1 und 3. Wenn es eine √úbereinstimmung gibt, f√ºgen Sie diesen Block der Liste f√ºr Kollisionen ap.v.coll hinzu. <br><br>  Wenn sich der Spieler bewegt, aktualisieren wir diese Liste der Kollisionen. Um jedoch die Leistung zu sparen, tun wir dies nicht bei jedem Schritt (oder besser gesagt beim Rendern des Rahmens), sondern wenn der Spieler ein bestimmtes, etwas kleineres Quadrat verl√§sst, das in ap.v.collwStep und angegeben ist ap.v.collhStep, z. B. 8 und 4 Meter.  Das hei√üt, wir werden das Kollisionsarray wieder zusammensetzen, wenn der Spieler einen bestimmten Pfad horizontal oder vertikal von seiner urspr√ºnglichen Position aus passiert.  Erinnern wir uns gleichzeitig an die Position, an der wir das Array wieder zusammengesetzt haben, um es f√ºr die n√§chste Iteration zu verwenden.  pers [ax] - hier meinen wir mit ax die Koordinatenachse (ax), sie kann x oder z sein, abh√§ngig von der Richtung des Korridors, entlang dem der Spieler geht. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  Warum solche Schwierigkeiten?  Warum nicht die gesamte Reihe von Kollisionen auf der Ebene nutzen und kein Dampfbad nehmen?  Tatsache ist, dass die Kollisionserkennung nach einem viel komplexeren Algorithmus durchgef√ºhrt wird und es unrentabel ist, die Kollision bei jedem Frame-Rendering mit absolut allen Ebenenbl√∂cken und nicht mit den n√§chstgelegenen zu √ºberpr√ºfen.  (Obwohl dies nicht korrekt ist.) <br><br>  Die Definition von Kollisionen bei jedem Rendern eines Frames unter Verwendung des oben vorbereiteten Kollisionsarrays: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Hier sind x, y, xOld, yOld die neuen und aktuellen Koordinaten des Spielers.  Neue werden auf Knopfdruck basierend auf einer bestimmten Bewegungsgeschwindigkeit berechnet, dh dies sind m√∂gliche Koordinaten.  Sie werden √ºberpr√ºft, um festzustellen, ob sie in einen Block der Kollisionsliste fallen.  Wenn sie fallen, rollen sie zu den alten zur√ºck und der Spieler passiert das Hindernis nicht.  Und wenn sie nicht fallen, werden sie aktuell.  pw2 und ph2 sind halb so breit und hoch wie der imagin√§re Collider des Spielers (Spielerbreite / 2, Spielerh√∂he / 2).  Die Ausgabe wird ausgegeben, wenn eine horizontale und vertikale Kollision vorliegt (collw, collh), ob sich unter dem Player ein Supportblock befindet (supportf) - dies macht deutlich, ob die Herbstanimation weiter gestartet werden soll oder ob der Player einfach zu einem benachbarten Block gewechselt hat und so weiter.  Fragen Sie einfach nicht, warum ich dort 0,001 addiert und 0,11 subtrahiert habe.  Dies ist eine schreckliche Kr√ºcke, die verhindert, dass sie durch die Bl√∂cke f√§llt und Jitter verursacht, wenn sie mit einem horizontalen Hindernis kollidiert ... Diese Funktion funktioniert, muss jedoch auf normale Weise neu geschrieben werden.  Die Optimierung dieser Funktion fehlt ebenfalls noch. <br><br>  Ich denke, bei Kollisionen lohnt es sich, hier zu enden. <br><br>  Es ist schwer zu sagen, wie viel schneller oder vielleicht langsamer als das Raytracing meiner Methode ist, aber im letzteren Fall speichert Three.js auch eine Reihe von Objekten, die am Kollisionssystem beteiligt sind.  Es ist nur so, dass die Kollisionen dort durch die Methode der Emission des Strahls und seinen Schnittpunkt mit den Ebenen der Seiten der Objekte und bei mir durch die Bestimmung bestimmt werden, ob die Koordinaten eines Objekts entlang jeder der beiden Achsen innerhalb des anderen liegen. <br><br>  Das Spiel hat auch sich bewegende Objekte (Hai) und Markierungsobjekte, die eine Art Animation ausl√∂sen (z. B. l√∂st der Kontakt mit Wasser die Bewegung eines Hais aus).  Alle diese Objekte nehmen auch an Kollisionen teil, einige mit zeitlich variierenden Koordinaten.  Dort ist seltsamerweise alles einfacher: W√§hrend der Bewegung des Objekts werden seine Koordinaten mit den Koordinaten des Spielers verglichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  Im Allgemeinen ist die Pflege eines Javascript-Gamepads in einem Browser keine triviale Aufgabe.  Es gibt keine Tastendruck- und Freigabeereignisse.  Es gibt nur Ereignisse, die das Ger√§t und den Status verbinden und trennen, die durch regelm√§√üige Abfragen ermittelt und dann mit dem vorherigen verglichen werden k√∂nnen. <br><br>  Ein Video, das die Funktionsweise des Gamepads in einem Browser auf einem Tablet unter Windows 8.1 und einem PC unter Windows 10 zeigt. Das Tablet ist jedoch ein altes, das 2014 ver√∂ffentlicht wurde, sodass die dynamische Beleuchtung im Spiel darauf ausgeschaltet wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Um das Gamepad abzufragen, wird eine Funktion verwendet, die alle 100 Millisekunden aufgerufen wird.  Es wird mit der Funktion meiner Bibliothek m3d.lib.globalTimer.addEvent eingestellt. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  Hier ist globalTimer das von mir geschriebene Javascript setInterval Timer Event Management System.  Dort wird einfach eine Reihe von Ereignissen zu einem bestimmten Array hinzugef√ºgt, die in unterschiedlichen Intervallen aufgerufen werden m√ºssen.  Dann wird ein setInterval-Timer mit der Frequenz eingestellt, die dem Ereignis mit der h√∂chsten Frequenz von allen entspricht.  Der Timer fragt die Funktion m3d.lib.globalTimer.update () ab, die die Liste aller Ereignisse durchl√§uft und die Funktionen derjenigen ausf√ºhrt, die ausgef√ºhrt wurden.  Beim Hinzuf√ºgen oder Entfernen von Ereignissen kann sich auch die Intervallfrequenz √§ndern (z. B. wenn Sie das schnellste Ereignis l√∂schen). <br><br>  Das Spiel legt au√üerdem Handler f√ºr jede Gamepad-Taste fest: 'a' steht f√ºr die Achse (Axt), 'b' f√ºr die Schaltfl√§che (Schaltfl√§che) und 11 f√ºr die linke Abweichung entlang der horizontalen Achse des Kreuzes (als ob die Schaltfl√§che 1). 12 - die rechte Abweichung entlang der horizontalen Achse des Kreuzes (als ob seine Taste 2), 21 und 22 - f√ºr die vertikale Achse.  Zum Beispiel: <br><br>  ['a', 11], <br>  ['b', 3] <br><br>  bedeutet, dass die n√§chste Funktion gleichzeitig f√ºr die Abweichung entlang der horizontalen Achse nach links und f√ºr die Taste 3 (links) eingestellt wird.  Nun, dann wird eine Funktion eingestellt, die ausgef√ºhrt wird, wenn die Taste gedr√ºckt und dann losgelassen wird. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Hier ist apcontrolsRenderStart () eine Funktion, die ein Rendering startet, wenn es noch nicht ausgef√ºhrt wird.  Im Allgemeinen ist die Unterst√ºtzung f√ºr das Gamepad eng mit meiner m3d-Bibliothek verbunden. Wenn ich also alle Funktionen beschreibe, wird es sich sehr lange erstrecken ... <br><br>  Ich gebe Ihnen nur einen Teil davon - das Gamepad, in dem ich die Initialisierung des Gamepads, die Installation von Handlern und die Statusabfrage auf einfachste Weise implementiert habe. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  Im Allgemeinen ist die Gamepad-Unterst√ºtzung im Spiel noch unvollst√§ndig: Es wird nur die Unterst√ºtzung f√ºr das einfachste Gamepad implementiert, nicht jedoch die, die beispielsweise in der XBox verwendet wird, da ich sie nicht habe.  Wenn ich es bekomme, programmiere ich es und arbeite damit.  Dort ist es m√∂glich, die Geschwindigkeit des Charakters anzupassen, dh es ist m√∂glich, sich mit jeder Geschwindigkeit im Bereich von Schritt zu Lauf zu bewegen.  Dies wird erreicht, indem Bruchparameter von den Achsen genommen werden.  Mein Gamepad gibt nur die Ganzzahlen -1 und 1 zur√ºck. Au√üerdem hat mein Gamepad ein ekelhaftes Kreuz, und wenn es nach links oder rechts gedr√ºckt wird, wird gleichzeitig nach unten oder oben gedr√ºckt.  Daher habe ich oben und unten am Kreuz nicht verwendet und es mit den Schaltfl√§chen rechts auf dem Gamepad dupliziert ... Bis zur Ver√∂ffentlichung des Spiels habe ich vor, mehrere Profile von Gamepads zu erstellen.  Au√üerdem werden beim Anschluss mehrerer Gamepads bisher nur letztere verwendet. <br><br><h3>  Reaktionsbildschirm </h3><br>  Das Spiel ist f√ºr ein Seitenverh√§ltnis von 16: 9 ausgelegt.  Ich habe jedoch eine automatische horizontale Anpassung von ¬± 10% hinzugef√ºgt, damit im erweiterten Browserfenster keine solchen schwarzen Balken an den Seiten angezeigt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  Und es w√§re so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  Im Vollbildmodus wird es echtes 16: 9 geben.  Es w√§re m√∂glich, das Bild im Allgemeinen an jedes Seitenverh√§ltnis des Browserfensters anzupassen, aber ich habe es nicht getan, da ein niedrig breites Fenster zu einem zu gro√üen Betrachtungswinkel f√ºhren w√ºrde, was aus Sicht des Spiels nicht gut ist: entfernte Sackgassen, Objekte, Feinde sind sofort sichtbar und alles andere, was der Spieler noch nicht sehen muss.  Daher beschr√§nkte ich mich darauf, innerhalb von ¬± 10% von 16: 9 einzustellen.  Bei schmalen Monitoren (4: 3) erkannte ich jedoch die M√∂glichkeit, durch Dr√ºcken der Y-Taste von 16: 9 in den Anpassungsmodus von 4: 3 auf 16: 9 zu wechseln.  Aber nicht breiter - also auch hier, um das Gameplay nicht zu brechen.  Das hei√üt, Sie k√∂nnen im klassischen Verh√§ltnis 16: 9 spielen oder das Bild auf die H√∂he des Fensters vergr√∂√üern, indem Sie es horizontal zuschneiden.  Dies ist jedoch auch nicht sehr gut, beispielsweise in Arcade-Situationen, in denen etwas von der Seite auf den Spieler zufliegt.  F√ºr die Reaktion bleibt wenig Zeit.  Sie k√∂nnen jedoch jederzeit schnell zum klassischen Modus zur√ºckkehren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  Die Anpassung des Bildschirms sowie alle im Spiel verwendeten Hotkeys werden im folgenden Video gezeigt: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Tats√§chlich wird das Seitenverh√§ltnis in den Spieleinstellungen festgelegt. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  Und im Spiel, wenn Sie Y dr√ºcken, wechselt es: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Meine Bibliothek hat ein Ereignis, das im Fenster zum √Ñndern der Gr√∂√üe h√§ngt.  Hier ist ein Fragment davon: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  m3d.lib.inBlock ist auch eine Funktion meiner Bibliothek, die ein Rechteck mit Parametern wie Zentrieren, Skalieren oder Zuschneiden in ein anderes Rechteck einschreibt und die neuen Abmessungen des beschrifteten Rechtecks ‚Äã‚Äãsowie die Gr√∂√üe der Felder anzeigt, die in diesem Prozess gebildet werden.  Basierend auf diesen Informationen wird der div-Container des Fensters positioniert.  'Renderer' ist ein Blockkontextelement einer 3D-Szene.  Dann wird die Leinwand dort gem√§√ü den erhaltenen Parametern skaliert. <br><br>  Die Benutzeroberfl√§che wird im Container auf einem separaten Canvas-Element angezeigt.  Im Allgemeinen besteht der Dokumentbaum aus drei transparenten DIV-Bl√∂cken mit absoluter Positionierung (je nach den Anforderungen des Spiels mehr oder weniger m√∂glich): Unten befindet sich die Leinwand der 3D-Szene, oben die Leinwand f√ºr IU und oben die Animationselemente der Benutzeroberfl√§che und andere visuelle Effekte .  Das hei√üt, die Benutzeroberfl√§che wird nicht in 3D gerendert, sondern auf ihrem Knavass oder ihrer Ebene.  Die Aufgabe, Ebenen zu einem einzigen Bild zu kombinieren, bleibt dem Browser √ºberlassen.  Um mit der Benutzeroberfl√§che zu arbeiten, habe ich ein spezielles Objekt in der Bibliothek.  Kurz gesagt - das Wesentliche ist wie folgt.  Sprite-Listen mit UI-Elementen im PNG-Format mit Transparenz werden geladen.  Von dort werden die notwendigen Elemente √ºbernommen - Hintergr√ºnde, Schaltfl√§chen.  Und sie werden mit der Funktion js drawImage (img, ix, iy, iw, ih, x, y, w, h) auf der mittleren Leinwand gezeichnet.  Das hei√üt, die erforderlichen Fragmente aus dem Bild werden an den erforderlichen Positionen auf dem Bildschirm angezeigt.  √úber den damit verbundenen Hintergr√ºnden werden Schaltfl√§chen angezeigt. Alle Positionen und Gr√∂√üen werden in der UI-Konfiguration festgelegt.  Beim √Ñndern der Fenstergr√∂√üe werden die Positionen von Elementen auf der Zielleinwand (auf der sie angezeigt werden) neu berechnet, je nachdem, ob dieses oder jenes Element horizontal und vertikal zentriert oder an einer Ecke oder Fl√§che des Bildschirms ausgerichtet ist.  Dadurch wird eine adaptive Benutzeroberfl√§che erstellt, die nicht vom Seitenverh√§ltnis des Bildschirms abh√§ngt.  Es ist nur erforderlich, die minimal m√∂gliche Aufl√∂sung horizontal und vertikal einzustellen und nicht darunter zu fallen, damit sich die Elemente nicht √ºberlappen.  Ich werde ein anderes Mal √ºber die Benutzeroberfl√§che sprechen, da sich der Artikel als umfangreich herausstellte und ich immer noch an der Benutzeroberfl√§che arbeite, da mir noch viele Funktionen fehlen.  Auf hochaufl√∂senden Monitoren sieht die Benutzeroberfl√§che beispielsweise klein aus.  Abh√§ngig von der Bildschirmaufl√∂sung k√∂nnen Sie die Gr√∂√üe der Elemente mit einem bestimmten Koeffizienten multiplizieren.  Andererseits werden die riesigen Schaltfl√§chen auf dem Bildschirm m√∂glicherweise nicht ben√∂tigt?  Wenn die Bildschirmaufl√∂sung sehr gro√ü ist, ist der Bildschirm selbst ziemlich gro√ü. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  Sie k√∂nnen dem Programmierer die Wahl lassen, ob die IU dynamisch mit der Gr√∂√üe des Fensters skaliert oder die Elemente in den Ecken verteilt werden sollen.  Bei der dynamischen Gr√∂√üe gibt es auch eigene Fragen - zum Beispiel die ‚ÄûSeife‚Äú einer Benutzeroberfl√§che, wenn sie in zu gro√üem Ma√üstab angezeigt wird.  Wenn Sie Sprites von Schnittstellenelementen in einer absichtlich gro√üen Aufl√∂sung erstellen, nehmen diese viel Platz ein und sind wahrscheinlich auch f√ºr kleine Ger√§te nicht n√ºtzlich - sie ben√∂tigen immer noch keine gro√üen Sprites, verbrauchen jedoch Speicher. <br><br>  Ich denke das reicht f√ºr heute.  Es gibt noch etwas zu √ºberlegen, wie man dies oder das umsetzt.  In der Zwischenzeit schweife ich f√ºr einige Zeit vom Programmieren ab und mache Werbung.  Ich habe vor, an zwei Indie-Showcases teilzunehmen, und bin aktiv an der F√∂rderung des Spiels in sozialen Netzwerken beteiligt, da ich im November die Crowdfunding-Plattform betreten m√∂chte: Ich ben√∂tige Spezialisten auf dem Gebiet der 3D-Grafik und der Skelettanimation, um das Spiel zu vervollst√§ndigen. <br><br>  In den folgenden Artikeln werde ich √ºber Touch-Steuerelemente in Browsern f√ºr mobile Ger√§te sprechen - nicht jeder verbindet ein Gamepad oder eine Tastatur mit dem Tablet, √ºber die Optimierung von 3D-Grafiken f√ºr Ger√§te mit geringem Stromverbrauch und vieles mehr. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472272/">https://habr.com/ru/post/de472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472258/index.html">Wie man "lernt zu lernen" - die Achtsamkeit verbessert</a></li>
<li><a href="../de472262/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 318 (vom 14. bis 20. Oktober)</a></li>
<li><a href="../de472264/index.html">Digitale Arch√§ologie und virtuelle Realit√§t oder wie ich versucht habe, mich mit BIM und VR anzufreunden</a></li>
<li><a href="../de472268/index.html">Verbessern der Microsoft Edge-Steuerelemente auf Chromium</a></li>
<li><a href="../de472270/index.html">‚ÄûSie haben keinen Zugang zum aktuellen Gebet‚Äú: High-Tech-Perlen aus dem Vatikan wurden in 15 Minuten gehackt</a></li>
<li><a href="../de472274/index.html">Remote SSH: Tipps und Hacks</a></li>
<li><a href="../de472278/index.html">Mein Lieblingsgit Commit</a></li>
<li><a href="../de472280/index.html">Die Aufgabe, das Vorhandensein einer Handfl√§che auf einem Venenscanner festzustellen</a></li>
<li><a href="../de472288/index.html">9 n√ºtzliche Browser-Erweiterungen f√ºr Entwickler (Liste f√ºr 2020)</a></li>
<li><a href="../de472290/index.html">Strukturen gegen Klassen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>