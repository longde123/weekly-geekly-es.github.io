<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛑 🙌🏼 🍺 Pendekatan teknik untuk pengembangan perangkat lunak 🐝 🔽 😨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara menguji ide, arsitektur dan algoritma tanpa menulis kode? Bagaimana cara merumuskan dan memverifikasi propertinya? Apa itu pemeriksa mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendekatan teknik untuk pengembangan perangkat lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/457810/"><p>  Bagaimana cara menguji ide, arsitektur dan algoritma tanpa menulis kode?  Bagaimana cara merumuskan dan memverifikasi propertinya?  Apa itu pemeriksa model dan pencari model?  Persyaratan dan spesifikasi - peninggalan masa lalu? </p><br><p>  Hai  Nama saya Vasil Dyadov, sekarang saya bekerja sebagai programmer di Yandex, sebelum itu saya bekerja di Intel, saya dulu mengembangkan kode RTL (register transfer level) pada Verilog / VHDL untuk ASIC / FPGA.  Saya telah lama menyukai topik keandalan perangkat lunak dan perangkat keras, matematika, alat, dan metode yang digunakan untuk mengembangkan perangkat lunak dan logika dengan properti yang telah ditentukan sebelumnya. </p><br><p>  Ini adalah artikel pertama saya dalam seri yang dirancang untuk menarik perhatian pengembang dan manajer pada pendekatan teknik untuk pengembangan perangkat lunak.  Baru-baru ini, ia telah diabaikan dengan tidak patut, meskipun ada perubahan revolusioner dalam pendekatan dan alat pendukungnya. </p><br><p>  Saya tidak akan menyembunyikan: tugas utama artikel ini adalah untuk membangkitkan minat.  Jadi akan ada minimum penalaran yang panjang dan maksimum spesifisitas. </p><br><p><img src="https://habrastorage.org/webt/1s/o1/cp/1so1cpitzwds_nhpyzfz1a3f4rc.gif"></p><a name="habracut"></a><br><p> Artikel ini memiliki dua bagian.  Pada bagian pertama saya akan menjelaskan apa yang saya maksud dengan pendekatan teknik, pada bagian kedua saya akan menunjukkan contoh penggunaan pendekatan dalam kerangka tugas sederhana (dekat dengan bidang arsitektur layanan mikro). </p><br><p>  Saya selalu terbuka untuk membahas masalah yang terkait dengan pengembangan perangkat lunak, dan saya akan senang mengobrol dengan pembaca (koordinat untuk komunikasi ada di profil saya). </p><br><h2 id="chast-1-inzhenernyy-podhod-k-razrabotke">  Bagian 1. Pendekatan teknik untuk pengembangan </h2><br><p>  Apa ini  Saya akan menunjukkan kepada Anda contoh membangun jembatan: </p><br><ul><li>  Tahap 1 adalah pengumpulan persyaratan untuk jembatan: jenis jembatan, kapasitas muat, dll. </li><li>  Tahap 2 - spesifikasi persyaratan dan perhitungan struktur (spesifikasi). </li><li>  Tahap 3 - konstruksi aktual itu sendiri berdasarkan perhitungan teknik (spesifikasi). </li></ul><br><p>  Tentu saja, ini analogi yang disederhanakan.  Tidak ada yang membuat jembatan prototipe untuk menjelaskan persyaratan dan spesifikasi.  Parameterisasi tidak dapat ditambahkan ke jembatan sehingga menjadi melengkung atau ditangguhkan.  Tapi secara keseluruhan, saya pikir analoginya jelas. </p><br><p>  Dalam pengembangan perangkat lunak, langkah 1 dan 2 sering tidak ada atau sangat lemah diekspresikan.  Jika persyaratannya ditetapkan, maka tidak jelas, tidak lengkap, dan informal.  Hanya beberapa persyaratan detail dan kembangkan spesifikasi yang jelas. </p><br><p>  Banyak orang berpikir bahwa ini adalah buang-buang waktu, peninggalan masa lalu, terutama jika pendekatan tangkas untuk pembangunan dipilih (terutama dengan iterasi singkat).  Dan ini adalah kesalahan besar. </p><br><p>  Mengapa </p><br><p>  Untuk mulai dengan, kita akan memahami apa persyaratan dan spesifikasi seperti itu dan apa perbedaan signifikan mereka, yang tidak selalu jelas bagi banyak profesional. </p><br><h3 id="chto-takoe-trebovaniya">  Apa saja persyaratannya? </h3><br><p>  Singkatnya, persyaratan adalah perumusan properti produk dalam hal area subjek.  Misalnya, seperti ini: "Semua instance dari program harus sama memproses permintaan input." </p><br><p>  Persyaratan tidak menggunakan ketentuan ruang lingkup implementasi.  Begitu istilah "sinkronisasi negara", Raft, Paxos, "kompleksitas logaritmik dalam waktu" bocor ke dalam persyaratan, maka persyaratan dan spesifikasi mulai bercampur. </p><br><p>  Penting untuk memahami hal ini dan dengan jelas memisahkan satu dari yang lain. </p><br><p>  Mengapa </p><br><ol><li><p>  Persyaratan harus jelas bagi konsumen perangkat lunak, oleh karena itu, mereka harus berasal dari bidang subjek yang sedang dikembangkan perangkat lunak (seringkali, para ahli yang jauh dari pengembangan harus dilibatkan dalam merumuskan persyaratan dan menetapkan tugas untuk pengembangan perangkat lunak). </p><br></li><li><p>  Properti perangkat lunak yang dilihat konsumen dievaluasi oleh metrik area subjek.  Penting untuk memisahkan persyaratan dan spesifikasi agar dapat 1) mengidentifikasi metrik produk utama yang digunakan konsumen untuk mengevaluasi perangkat lunak kami, dan 2) memahami dengan jelas properti produk mana yang penting bagi pengguna dan mana yang tidak. </p><br></li></ol><br><p>  Kalau tidak, itu bisa berubah seperti ini: pengembang, tidak memenuhi tenggat waktu, akan mengorbankan properti penting dan mencurahkan banyak waktu dan perhatian untuk yang tidak penting.  Selain itu, apa yang tampaknya penting dari sudut pandang pengembangan perangkat lunak mungkin tidak penting dari sudut pandang pengguna. </p><br><p>  Contoh klasik dari perbedaan tersebut diberikan dalam berbagai literatur tentang pengembangan antarmuka pengguna dan dalam artikel (misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu Respons Sistem dan Kepuasan Pengguna: Studi Eksperimental Aplikasi Berbasis Browser</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Latensi Komputer: 1977-2017</a> ).  Pengembang biasanya mencoba untuk mengoptimalkan waktu pelaksanaan operasi, misalnya, mencari informasi dalam database, dan waktu respons pengguna adalah penting.  Dan jika pencarian lambat, tetapi pengguna mulai melihat hasil yang dikembalikan secepat mungkin, maka menurutnya perangkat lunak tersebut berfungsi lebih baik daripada yang pencarian dengan cepat, tetapi pertama-tama mengakumulasi hasil dan akhirnya menampilkan semuanya. </p><br><p>  Itulah sebabnya perencana sumber daya OS berbeda untuk mode operasi server dan desktop.  Untuk mode server, throughput maksimum sistem adalah penting, mis., Optimalisasi waktu dan memori untuk menggunakan server secara efisien.  Dan bagi pengguna, keterlambatan dalam respons sistem adalah penting.  Semakin cepat sistem merespons tindakan, semakin cepat tampaknya, bahkan jika kerjanya lebih lambat. </p><br><p>  Dan akhirnya, alasan terpenting: </p><br><p>  <strong>Jika persyaratan dan spesifikasi tercampur, itu artinya kita tidak sepenuhnya memahami tugas-tugas yang sedang kita kembangkan perangkat lunak.</strong>  <strong>Kami mulai merumuskan dan menyelesaikan masalah dari bidang subjek di bidang pengembangan perangkat lunak.</strong>  <strong>Karenanya, logika domain bocor dan membingungkan logika kode.</strong>  <strong>Hasilnya adalah kode yang digabungkan secara ketat yang sulit untuk dipertahankan.</strong> </p><br><p>  Ini ditulis dengan baik oleh Michael Jackson dalam buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Problem Frames: Analyzing &amp; Structure Problem Development Software</a> .  Menurut pendapat saya, ini adalah salah satu buku paling berguna untuk pengembang perangkat lunak.  Pertama-tama ia mengajarkan untuk menganalisis masalah pengguna, yang harus dipecahkan oleh perangkat lunak yang baik.  Program supercepat yang menghabiskan sedikit sumber daya sistem tetapi tidak menyelesaikan tugas pengguna adalah program yang buruk.  Keren tapi jelek. </p><br><h3 id="chto-est-specifikaciya">  Apa spesifikasinya? </h3><br><p>  Spesifikasi adalah perumusan properti perangkat lunak dalam hal bidang pengembangan perangkat lunak.  Di sinilah konsep kompleksitas, sinkronisasi, dll. </p><br><p>  Spesifikasi dapat diatur secara hierarkis: dari abstrak ke spesifik, di mana Anda dapat menulis kode.  Pendekatan ini seringkali paling efektif.  Spesifikasi abstrak dengan mudah mencerminkan arsitektur - Anda dapat melihat properti dasar, menemukan kesalahan arsitektur, dll. Oleh karena itu, kami dapat menemukan masalah pada tahap awal siklus hidup perangkat lunak dan secara signifikan mengurangi biaya perbaikan kesalahan. </p><br><p>  Penting untuk diperhatikan manfaat dan pentingnya spesifikasi untuk protokol dan antarmuka antara komponen sistem, yang akan membantu menghindari situasi ini: <br><img src="https://habrastorage.org/webt/ap/ej/si/apejsivp0epnahw7v99muevkkxs.jpeg"></p><br><h3 id="v-chyom-otlichie-ot-obychnogo-podhoda-k-razrabotke">  Apa perbedaan dari pendekatan pengembangan yang biasa? </h3><br><p>  Dalam pendekatan teknik, kami melakukan pra-desain perangkat lunak dengan karakteristik yang diperlukan sesuai dengan spesifikasi.  Kami memeriksa spesifikasi untuk properti yang diperlukan yang berasal dari persyaratan. </p><br><p>  Saya membuat perbandingan dalam bentuk tablet (sangat subyektif): </p><br><div class="scrollable-table"><table><tbody><tr><th>  Properti </th><th>  Pendekatan teknik </th><th>  Pendekatan kerajinan </th></tr><tr><td>  Pernyataan persyaratan </td><td>  Detail, sering digunakan format ReqIF dan alat terkait (Eclipse RMF, misalnya) </td><td>  Detailing biasanya kecil, kata-katanya tidak akurat, informal </td></tr><tr><td>  Spesifikasi </td><td>  Seringkali formal, B-metode, Z, VDM, TLA +, Alloy, dll digunakan. </td><td>  Apa kamu  Spesifikasi apa?  Kami menulis dalam file apa yang perlu kami lakukan dan bagaimana cara kerjanya, dan itu sudah cukup </td></tr><tr><td>  Spesifikasi debugging dan pemodelan </td><td>  Pro-B, Atelier B, TLA + / TLC, Alloy, PRISM, VECS, dll. </td><td>  Oh, seperti apa itu? </td></tr><tr><td>  Menyoroti metrik </td><td>  Detail, berdasarkan spesifikasi dan model </td><td>  Baiklah, kami akan membuat beberapa metrik, tulis di halaman wiki </td></tr><tr><td>  Pengembangan kode </td><td>  Berdasarkan spesifikasi dan model </td><td>  Nah, di sini seperti biasa: clap-clap - dan dalam produksi </td></tr><tr><td>  Pengujian </td><td>  Tes berbasis model yang ditargetkan untuk kasus tepi yang diidentifikasi pada model;  directional acak yang dihasilkan oleh model.  Integrasi untuk kasus tepi sesuai dengan spesifikasi antarmuka dan protokol interaksi. <br>  Mesin pengawas berdasarkan sifat-sifat model LTL;  fuzzing arah;  Pengecekan model terbatas (Divine, misalnya) </td><td>  Nah, seperti biasa: tes unit kecil, maka kita akan memikirkan kasus-kasus khas dan menambahkan integrasi dan yang sistem;  fuzzing untuk beberapa fungsi kritis (fuzzing lemah untuk menemukan kesalahan sinkronisasi dalam perangkat lunak multithreaded?);  kami sedikit melakukan tes di bawah pembersih </td></tr><tr><td>  Verifikasi </td><td>  Sebagai contoh, ambil GNATprove atau Frama-C, ambil properti dari spesifikasi, beri catatan kode, dan buktikan secara formal bahwa kode tersebut sesuai dengan spesifikasi formal;  atau kami akan menggunakan Atelier B untuk beralih dari spesifikasi ke implementasi melalui pembuatan kode pada tahap akhir;  atau pilih metode lain </td><td>  Nah, ini menakutkan, panjang dan mahal, dan kami tidak merumuskan properti untuk verifikasi formal: untuk apa kepatuhan memeriksa? </td></tr></tbody></table></div><br><h3 id="a-ne-za-vodopadnuyu-li-model-razrabotki-tut-idyot-agitaciya">  Dan bukankah model agitasi untuk model pengembangan air terjun di sini? </h3><br><p>  Rekayasa perangkat lunak, termasuk spesifikasi dan simulasi formal, berjalan dengan baik dengan pendekatan gesit. </p><br><p>  Diyakini bahwa pendekatan rekayasa untuk pengembangan tidak sesuai dengan pengembangan perangkat lunak berulang yang cepat (seperti yang dinyatakan dalam banyak artikel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut adalah contohnya</a> ). </p><br><p>  Tapi ini tidak benar.  Pendekatan teknik telah berhasil diterapkan di banyak proyek, termasuk proyek dengan iterasi pendek. </p><br><p>  Sebelumnya, karena sarana dan alat pendukung yang kurang berkembang, pendekatan teknik memang terkait erat dengan model air terjun. </p><br><p>  <em>Tetapi sekarang semuanya telah berubah secara dramatis.</em> </p><br><p>  Berkat keberhasilan terobosan dalam bidang pemodelan, pemecah SAT / SMT, dll., Sekarang memungkinkan untuk dengan cepat memeriksa ruang besar status sistem untuk mengetahui properti yang kita butuhkan dan tidak adanya yang tidak perlu, untuk memverifikasi volume industri kode, dll. </p><br><p>  Alat industri kelas satu seperti Alloy, TLA + / TLC, Atelier B, PRISM muncul, yang mengalihkan tugas memformalkan dan memeriksa spesifikasi dari bidang akademik / matematika, yang membutuhkan kualifikasi tinggi dan upaya besar, ke tugas tombol, dapat diakses oleh sebagian besar programmer. </p><br><p>  Spesifikasi sekarang dapat dikembangkan secara iteratif dan bertahap.  Model dirancang dengan baik secara iteratif, dari abstrak hingga beton.  Waktu simulasi bahkan untuk sistem besar dihitung dalam hitungan menit dan jam. </p><br><p>  Persyaratan mudah ditentukan secara iteratif, terutama dengan pendekatan dan alat modern. <br>  Dan penyempurnaan persyaratan, spesifikasi, refactoring model, penulisan kode dan refactoringnya dapat dengan mudah berjalan paralel - dalam satu iterasi. </p><br><p>  Secara umum, pendekatan teknik sekarang sama sekali tidak sama dengan model air terjun, ini adalah dua hal yang independen. </p><br><p>  Pendekatan teknik mudah dikombinasikan dengan metodologi pengembangan organisasi. </p><br><p>  Blog Hillel Wayne menunjukkan betapa mudahnya bekerja dengan spesifikasi dan model formal.  Dia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang</a> bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang</a> bagaimana secara formal menentukan logika antarmuka pengguna suatu program dalam 10 menit dan memeriksa beberapa propertinya. </p><br><p>  Saya tidak akan masuk ke detail dan menerjemahkan seluruh artikel, saya hanya akan menunjukkan spesifikasi itu sendiri di <strong>Alloy</strong> : </p><br><div class="spoiler">  <b class="spoiler_title">Spesifikasi UI</b> <div class="spoiler_text"><pre><code class="plaintext">open util/ordering[Time]
sig Time {
    state: one State
}
abstract sig State {}
abstract sig Login extends State {}
abstract sig Reports extends Login {}

one sig Logout extends State {}
one sig Students, Summary, Standards extends Reports {}
one sig Answers extends Login {}

pred transition[t: Time, start: State, end: State] {
  t.state in start
  t.next.state in end
}

pred logout[t: Time] { transition[t, Login, Logout] }
pred login[t: Time] { transition[t, Logout, Summary] }
pred students[t: Time] { transition[t, Reports, Students] }
pred summary[t: Time] { transition[t, Reports, Summary] }
pred standards[t: Time] { transition[t, Reports, Standards] }
pred answers[t: Time] { transition[t, Students, Answers] }
pred close_answers[t: Time] { transition[t, Answers, Students] }

fact Trace {
  first.state = Summary
  all t: Time - last |
    logout[t] or
    login[t] or
    students[t] or
    summary[t] or
    standards[t] or
    answers[t] or
    close_answers[t]
}</code></pre></div></div><br>
<p> ,    .    ,    UI       .</p><br>
<p>     :</p><br>
<pre><code class="plaintext">check {all t: Time | t.state = Answers implies 
        t.prev.state = Students} for 7</code></pre><br>
<p>    .</p><br>
<p>  ,        ,         .</p><br>
<p>        agile.</p><br>
<p>         —  .</p><br>
<h3 id="formalizaciya-specifikaciy"> </h3><br>
<p>   ,    ,       —  <strong>Alloy</strong>,              .</p><br>
<p>    ,    ,             (    )     .</p><br>
<p>       (  )      ,    .</p><br>
<p>     ,    .</p><br>
<h2 id="chast-2-primer-ispolzovaniya-alloy"> 2.   Alloy</h2><br>
<p>   Alloy,         : ,        ,     .</p><br>
<p>                   ,    —    ,   ,    -     .</p><br>
<p>             .</p><br>
<p>    ,     ,         .</p><br>
<h3 id="otnosheniya"></h3><br>
<p>        <math></math><img src="https://habrastorage.org/getpro/habr/formulas/a9a/f7d/d6b/a9af7dd6bb59a9f4658dcac8b18065ca.svg" alt="$\big\{x,y\big\}$" data-tex="inline">,  <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d43/295/5cf/d432955cfad9eeabdf201072735eb4a2.svg" alt="$x \in X$" data-tex="inline">  <math></math><img src="https://habrastorage.org/getpro/habr/formulas/65f/93e/96e/65f93e96e5d87b7d30a03ab77eee349b.svg" alt="$y \in Y$" data-tex="inline">.</p><br>
<p> Alloy   : <code>X-&gt;Y</code>.</p><br>
<p>         (     <strong>util/relation</strong>):</p><br>
<div class="spoiler"><b class="spoiler_title"> relation.als</b><div class="spoiler_text"><pre><code class="plaintext">module relation

-- :
-- set A -    A,   
-- one A -       A
-- lone A -    A   
-- some A -      A

-- :
-- univ -       ,
--            
-- iden -   {A0, A0},     
--               univ
--        iden = {a : univ, b: univ |  a=b}
--            
-- none -  

-- :
-- : and, or, =&gt; (), != ( ), not
--  :
-- &amp; - 
-- A-&gt;B -      .
--        
-- X&lt;:Y -     Y ,   
--           X
-- A in B -  A   B
-- ~A -     A
-- A + B - 
-- no A - A ,  A = none
-- ^A -     A,
--         B , :
--      A in B,
--      {E0, E1}, {E1, E2} in B =&gt; {E0, E2} in B
-- A.B -  JOIN,  . :
--       {A0, B0} in A, {B0, C0, D0} in B, 
--       {A0, C0, D0} in A.B 

-- :
-- all X : Y | .... - 
-- some X : Y | .... - 

--  :
-- pred[a: A, b:B] {...}    
-- : pred[a, b]  a.pred[b]
--       
-- -,    
-- method(self : Object, args ...)

pred valid [rel : univ-&gt;univ, dom : set univ, cod : set univ] {
  rel.univ in dom and rel.univ in cod
}
fun domain [rel : univ-&gt;univ] : set (rel.univ) { rel.univ }
fun codomain [rel : univ-&gt;univ] : set (univ.rel) { univ.rel }
pred total  [rel: univ-&gt;univ, dom: set univ] {
  all x: dom | some x.rel
}
pred partial [rel: univ-&gt;univ, dom: set univ] {
  all x: dom | lone x.rel
}
pred functional [rel: univ-&gt;univ, dom: set univ] {
  all x: dom | one x.rel
}
pred surjective [rel: univ-&gt;univ, cod: set univ] {
  all x: cod | some rel.x
}
pred injective [rel: univ-&gt;univ, cod: set univ] {
  all x: cod | lone rel.x
}
pred bijective [rel: univ-&gt;univ, cod: set univ] {
  all x: cod | one rel.x
}
pred bijection [rel: univ-&gt;univ, dom, cod: set univ] {
  rel.functional[dom] and rel.bijective[cod]
}
pred reflexive [rel: univ-&gt;univ, s: set univ] {
  s&lt;:iden in rel
}
pred irreflexive [rel: univ-&gt;univ] {no iden &amp; rel}
pred symmetric [rel: univ-&gt;univ] {~rel in rel}
pred antisymmetric [rel: univ-&gt;univ] {~rel &amp; rel in iden}
pred transitive [rel: univ-&gt;univ] {rel.rel in rel}
pred acyclic [rel: univ-&gt;univ, s: set univ] {
  all x: s | x not in x.^rel
}
pred complete[rel: univ-&gt;univ, s: univ] {
  all x,y:s | (x!=y =&gt; x-&gt;y in (rel + ~rel))
}
pred preorder [rel: univ-&gt;univ, s: set univ] {
  rel.reflexive[s] and rel.transitive
}
pred equality [rel: univ-&gt;univ, s: set univ] {
  rel.preorder[s] and rel.symmetric
}
pred partial_order [rel: univ-&gt;univ, s: set univ] {
  rel.preorder[s] and rel.antisymmetric
}
pred total_order [rel: univ-&gt;univ, s: set univ] {
  rel.partial_order[s] and rel.complete[s]
}</code></pre></div></div><br>
<p>      ,      ,           Alloy.</p><br>
<h3 id="grafy"></h3><br>
<p>       .</p><br>
<p>       <strong>utils/graph</strong>, ,     ,          :</p><br>
<div class="spoiler"><b class="spoiler_title"> graph.als</b><div class="spoiler_text"><pre><code class="plaintext">module graph[node]
open relation

--     
fun nodes[r: node-&gt;node]: set node {
  r.domain+ r.codomain
}

--  ,     
--       
--   
pred connected[r: node-&gt;node] {
  all n1,n2 : r.nodes | n1 in n2.*(r + ~r)
}

--    
pred dag [r: node-&gt;node] {
  r.acyclic[r.nodes]
}

--    
--   ,   
--   
fun roots [r: node-&gt;node] : set node {
  let ns = r.nodes | -- ns -   
    ns - ns.^r --     ,
               --    -
               --  
}

--   
--  -  ,  
--   
fun leaves [r: node-&gt;node] : set node {
  let ns = r.nodes | -- ns -   
    ns - ns.^~r --     ,
                --    -
                --  
}</code></pre></div></div><br>
<h3 id="vychislitelnyy-graf"> </h3><br>
<p>  —  ,       .</p><br>
<p> :</p><br>
<ul>
<li>(1)   — ,    ,     ;</li>
<li>(2)   — ,    ,    ;</li>
<li>(3)    —   ,     ;</li>
<li>(4)  ,  — ;</li>
<li>(5)          .       .   ,  ,    ,       ;</li>
<li>(6)  ,     —   ,        .</li>
</ul><br>
<p>       .</p><br>
<p>   ,    ,  <strong>Alloy</strong>:</p><br>
<div class="spoiler"><b class="spoiler_title"> compgraph.als</b><div class="spoiler_text"><pre><code class="plaintext">module compgraph[node]

open graph[node]
open relation

pred valid [edges: node-&gt;node,
            source : one node, --  1
            drain : one node --  2
] {
  edges.antisymmetric and edges.irreflexive --  6
  graph/roots[edges] = source --  1  4
  graph/leaves[edges] = drain --  2  4
}</code></pre></div></div><br>
<p>     :</p><br>
<pre><code class="plaintext">open compgraph[node] as cg -- cg -  

enum node {n0, n1, n2, n3, n4}
--    ,    

run cg/valid --     cg,  
  --  valid    : relation  compgraph</code></pre><br>
<p>      :</p><br>
<div class="spoiler"><b class="spoiler_title">  </b><div class="spoiler_text"><p><img src="https://habrastorage.org/webt/s-/jc/oa/s-jcoayzy93rucqvfwlmnjkshsq.png"></p></div></div><br>
<p> ,         (  ).</p><br>
<p>         ,     .</p><br>
<h3 id="konsistentnost-vychislitelnogo-grafa">  </h3><br>
<p>          ,    .</p><br>
<p>     .          .         ,     .</p><br>
<p>,       .        :</p><br>
<ul>
<li>  —      , . .      ;</li>
<li>  —      ;</li>
<li>  —       , .&nbsp;.          ,      .</li>
</ul><br>
<p> ,            , . .       (       ,       ).</p><br>
<p>  ,        :</p><br>
<ul>
<li>(7)   (  ).        ,        ,     ;</li>
<li>(8)         , .&nbsp;.   .</li>
</ul><br>
<p>         ,       .</p><br>
<p>   ,   ,  ,    .</p><br>
<ul>
<li>(9)     ,   .</li>
</ul><br>
<p> (, ,    ) :</p><br>
<ul>
<li>(10)    .</li>
</ul><br>
<p>    :</p><br>
<div class="spoiler"><b class="spoiler_title"> compgraph.als</b><div class="spoiler_text"><pre><code class="plaintext">module compgraph[node]

open graph[node]

pred active[edges : node-&gt;node,
            source: node,
            n : node
] {
  -- n    ,
  --   
  n in source.^edges
}

pred safe[edges : node-&gt;node,
          drain : node,
          n : node
] {
  --    ,  drain,
  --      n
  --      
  --  n     
  --  
  no n.*edges &amp; (leaves[edges] - drain)
  --     , 
  --       
  --     ,
  --  ,     drain
  drain in n.*edges
}

pred valid [edges: node-&gt;node,
            source : one node, --  1
            drain : one  node --  2
] {
  edges.connected --     
                  --     ( 
                  --        ),
                  --      , 
                  -- ,   
                  --  connected
  edges.dag --  6  8
  source in edges.roots --  1, 4  9
  drain in edges.leaves --  2, 4  8
  all n : edges.roots - source |
    not active[edges, source, n] --  9
  all n : edges.nodes | -- 10 
    active[edges, source, n] =&gt; safe[edges, drain, n]
}</code></pre></div></div><br>
<p>            .</p><br>
<h3 id="operacii-nad-vychislitelnym-grafom">   </h3><br>
<p>       .</p><br>
<p> ,            .</p><br>
<p>        :</p><br>
<ol>
<li> ;</li>
<li>  ;</li>
<li>   ;</li>
<li> ;</li>
<li>  ;</li>
<li> .</li>
</ol><br>
<p>    .       .             :        .</p><br>
<p>    ,          ?          ? </p><br>
<p>   .</p><br>
<p>  ,      ,      .</p><br>
<p>,        .</p><br>
<p> ,     :</p><br>
<ul>
<li>     (  ,        );</li>
<li> ;</li>
<li> ;</li>
<li>      .</li>
</ul><br>
<p>      .</p><br>
<p>   ,      .</p><br>
<p>     :</p><br>
<ol>
<li> -&gt; ;</li>
<li> -&gt; ;</li>
<li> -&gt; ;</li>
<li> -&gt; .</li>
</ol><br>
<p>    ,      .</p><br>
<p>,           :     ,   .         -  ,   —    ,     / .</p><br>
<p>   , :  -&gt; .</p><br>
<p>   ,  :</p><br>
<ul>
<li>  ;</li>
<li>  .</li>
</ul><br>
<p>      ,       .</p><br>
<p>     ,   <strong>Alloy</strong>        ,     .     ,    <strong>Alloy</strong>       .</p><br>
<div class="spoiler"><b class="spoiler_title">  </b><div class="spoiler_text"><pre><code class="plaintext">pred connect[
  old_edges : node-&gt;node,
  new_edges : node-&gt;node,
  source : one node,
  drain : one node,
  from : one node, 
  to : one node
] {
  --    
  from-&gt;to not in old_edges

  -- from   to,
  --    
  from not in to.*old_edges

  -- to    ,
  --    
  -- 
  to in (old_edges.nodes - source)

  --   to  
  -- ,   
  --   to  
  safe[old_edges, drain, to]

  --    ,
  --      
  --  
  new_edges = old_edges + from-&gt;to
}</code></pre></div></div><br>
<p> <strong>connect</strong>            .</p><br>
<p> ,  <strong>connect</strong>   :</p><br>
<pre><code class="plaintext">open compgraph[node] as cg

sig node {}

check {
  --      r1, r2
  all r1, r2 : node-&gt;node |
  --     source, drain, from, to
  all source, drain, from, to : node  {
    -- r1     
    -- source/drain /
    --  r2   r1   
    -- connect  from-&gt;to
    (cg/valid[r1, source, drain] and
     connect[r1, r2, source, drain, from, to])
    --   ,  r2 + source/drain
    --    
    -- 
    implies cg/valid[r2, source, drain]
    --    connect  
    --  
  }
} for 8</code></pre><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="plaintext">Executing "Check check$1 for 8"
   Sig this/node scope &lt;= 8
   Sig this/node in [[node$0], [node$1], [node$2], [node$3],
     [node$4], [node$5], [node$6], [node$7]]
   Generating facts...
   Simplifying the bounds...
   Solver=sat4j Bitwidth=4 MaxSeq=7 SkolemDepth=4 Symmetry=20
   Generating CNF...
   Generating the solution...
   8374 vars. 168 primary vars. 22725 clauses. 108ms.
   No counterexample found. Assertion may be valid. 26904ms</code></pre></div></div><br>
<p><strong>Alloy</strong>               .   , "<code>168 primary vars</code>"   ,    <math></math><img src="https://habrastorage.org/getpro/habr/formulas/738/817/223/738817223ccd2ccb1412e00a2ae45908.svg" alt="$2^{168}$" data-tex="inline">    .        30 !</p><br>
<p>      ,   <strong>connect</strong>     .</p><br>
<p>  ,  :</p><br>
<div class="spoiler"><b class="spoiler_title"> </b><div class="spoiler_text"><pre><code class="plaintext">pred disconnect[
  old_edges : node-&gt;node,
  new_edges : node-&gt;node,
  source : one node,
  drain : one node,
  from : one node,
  to : one node
] {
  --     
  from-&gt;to in old_edges

  --    from
  --   
  safe[new_edges, drain, from]

  --    
  new_edges.connected

  --  
  new_edges = old_edges - from-&gt;to
}</code></pre></div></div><br>
<p>:</p><br>
<pre><code class="plaintext">open compgraph[node] as cg
sig node {}
check {
  all r1, r2 : node-&gt;node |
  all source, drain, from, to : node  {
    (cg/valid[r1, source, drain] and
     disconnect[r1, r2, source, drain, from, to])
    implies cg/valid[r2, source, drain]
  }
} for 8</code></pre><br>
<p>!  !        :</p><br>
<div class="spoiler"><b class="spoiler_title">  disconnect</b><div class="spoiler_text"><p><img src="https://habrastorage.org/webt/so/lf/uh/solfuh-3byq1aftttdz7v2e4v3w.png"></p><br>
<p>,   <strong>r1</strong>, —      <strong>disconnect</strong>, <strong>r2</strong> —  . ,   <strong>r1</strong>,     <strong>r2</strong>,  <strong>r2</strong>    .</p><br>
<p>,    —     <strong>from-&gt;to</strong>,    <strong>source</strong> (  <strong>from</strong>)     .</p></div></div><br>
<p>  <strong>disconnect</strong>:</p><br>
<div class="spoiler"><b class="spoiler_title">   </b><div class="spoiler_text"><pre><code class="plaintext">pred disconnect[
  old_edges : node-&gt;node,
  new_edges : node-&gt;node,
  source : one node,
  drain : one node,
  from : one node,
  to : one node
] {
  from-&gt;to in old_edges
  ( safe[new_edges, drain, from] or
   (from not in new_edges.nodes and
    from != source))
  new_edges.connected
  new_edges = old_edges - from &gt;to
}</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"> </b><div class="spoiler_text"><pre><code class="plaintext">Executing "Check check$2 for 8"
   Sig this/node scope &lt;= 8
   Sig this/node in [[node$0], [node$1], [node$2], [node$3], [node$4], [node$5], [node$6], [node$7]]
   Generating facts...
   Simplifying the bounds...
   Solver=sat4j Bitwidth=4 MaxSeq=7 SkolemDepth=4 Symmetry=20
   Generating CNF...
   Generating the solution...
   8505 vars. 168 primary vars. 24808 clauses. 207ms.
   No counterexample found. Assertion may be valid. 18369ms.</code></pre></div></div><br>
<p>      ,      .</p><br>
<h3 id="polnota-operaciy"> </h3><br>
<p>     ,             ?</p><br>
<p>   ,          ?            ?</p><br>
<p> :</p><br>
<pre><code class="plaintext">--     
--     ,
-- ,       
--       
check {
  all r1,r2: node-&gt;node | all source,drain: node |
  some intermediate : seq node-&gt;node {
     cg/valid[r1, source, drain] and cg/valid[r2, source, drain]
     =&gt;
     intermediate.first = r1 and
     intermediate.last = r2 and
     all i : intermediate.inds - intermediate.lastIdx {
       let from = intermediate[i] |
       let to = intermediate[i+1] |
       some n1, n2 : node |
         connect[from,to, source, drain, n1, n2]
         or
         disconnect[from, to, source, drain, n1, n2]
     }
  }
} for 3</code></pre><br>
<p>    :</p><br>
<pre><code class="plaintext">Executing "Check check$3"
   Sig this/node scope &lt;= 3
   Sig this/node in [[node$0], [node$1], [node$2]]
   Generating facts...
   Simplifying the bounds...
   Solver=sat4j Bitwidth=4 MaxSeq=4 SkolemDepth=4 Symmetry=20
   Generating CNF...
   Generating the solution...
A type error has occured: (see the stacktrace)
Analysis cannot be performed since it requires higher-order
quantification that could not be skolemized.</code></pre><br>
<p>  ?</p><br>
<p>    <strong>Alloy</strong>:            .</p><br>
<p>       «some intermediate…»,           —  .</p><br>
<p>       .</p><br>
<p> (   ,   )    ,      .</p><br>
<p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">higher-order Alloy</a>,    ,           .    ,     CEGIS — counter-example guided inductive synthesis.</p><br>
<p>        ,      .</p><br>
<p>           ,       ,     ,  :</p><br>
<pre><code class="plaintext">check {
  all edges, edges1 : node-&gt;node |
  all source,drain, from, to : node {
    (cg/valid[edges, source, drain] and
    cg/valid[edges1, source, drain] and
    edges1 = edges + from-&gt;to and
    edges1 != edges)
    =&gt;
    some n1, n2: node | connect[edges, edges1, source, drain, n1, n2]
  }
} for 7</code></pre><br>
<p>   ,    :</p><br>
<div class="spoiler"><b class="spoiler_title">  connect  </b><div class="spoiler_text"><pre><code class="plaintext">Executing "Check check$3 for 7"
   Sig this/node scope &lt;= 7
   Sig this/node in [[node$0], [node$1], [node$2], [node$3],
     [node$4], [node$5], [node$6]]
   Generating facts...
   Simplifying the bounds...
   Solver=sat4j Bitwidth=4 MaxSeq=7 SkolemDepth=4 Symmetry=20
   Generating CNF...
   Generating the solution...
   6471 vars. 133 primary vars. 16634 clauses. 200ms.
   Counterexample found. Assertion is invalid. 116ms.</code></pre></div></div><br>
<p> ! </p><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><p><img src="https://habrastorage.org/webt/qd/6x/rv/qd6xrvnjwhoi3qgk35sicegzdk4.png"></p><br>
<p>  —     ,   —  .      <strong>from-&gt;to</strong>.</p><br>
<p>  ,   <strong>connect</strong>          (, , ).</p></div></div><br>
<p> <strong>connect</strong>:</p><br>
<div class="spoiler"><b class="spoiler_title">  connect</b><div class="spoiler_text"><pre><code class="plaintext">pred connect[
  old_edges : node-&gt;node,
  new_edges : node-&gt;node,
  source : one node,
  drain : one node,
  from : one node, 
  to : one node
] {
  from-&gt;to not in old_edges
  from not in to.*old_edges
  to in (old_edges.nodes - source)
  --   
  active[old_edges, source, from] =&gt; safe[old_edges, drain, to]
  --   to    from,
  -- ,   to     ,
  --   from,    
  --   
  new_edges.connected
  --   ,    
  --    :)
  new_edges = old_edges + from -&gt; to
}</code></pre></div></div><br>
<p> :</p><br>
<div class="spoiler"><b class="spoiler_title"></b><div class="spoiler_text"><pre><code class="plaintext">Executing "Check check$3 for 7"
   Sig this/node scope &lt;= 7
   Sig this/node in [[node$0], [node$1], [node$2], [node$3],
     [node$4], [node$5], [node$6]]
   Generating facts...
   Simplifying the bounds...
   Solver=sat4j Bitwidth=4 MaxSeq=7 SkolemDepth=4 Symmetry=20
   Generating CNF...
   Generating the solution...
   6513 vars. 133 primary vars. 16837 clauses. 125ms.
   No counterexample found. Assertion may be valid. 291ms.</code></pre></div></div><br>
<p>  .</p><br>
<p>        <strong>disconnect</strong>.    ,   :</p><br>
<div class="spoiler"><b class="spoiler_title">  diconnect</b><div class="spoiler_text"><pre><code class="plaintext">pred disconnect[
  old_edges : node-&gt;node,
  new_edges : node-&gt;node,
  source : one node,
  drain : one node,
  from : one node,
  to : one node
] {
  from-&gt;to in old_edges
  --       ,
  --     
  active[old_edges, source, from] =&gt; safe[new_edges, drain, from]
  -- ,      
  -- ,     :
  -- (from not in new_edges.nodes and
  --  from != source)

  new_edges.connected
  new_edges = old_edges - from-&gt;to
}</code></pre></div></div><br>
<p> ,  ,              /   ,              .</p><br>
<p> , ,       (, <strong>source-&gt;drain</strong>),           connect/disconnect      .</p><br>
<p>         (  ,           ,      ).</p><br>
<h3 id="chto-dalshe"> ?</h3><br>
<p>       , .</p><br>
<p>               ,    ,    ,      .&nbsp;.</p><br>
<p>        :      ,     ( safe/active  .).</p><br>
<p>         .</p><br>
<p>,         .</p><br>
<p>   ,   —        ,    .&nbsp;.</p><br>
<p>      ,      .</p><br>
<p>          ,        .</p><br>
<p>        ,          ,          (  ) .</p><br>
<h3 id="a-skolko-vremeni-ushlo-na-etu-model-vychislitelnogo-grafa">        ?</h3><br>
<p>    <strong>Alloy</strong>       .</p><br>
<p>        .</p><br>
<p> ,           ,      ,       Python.</p><br>
<p>         ,   (   )     .</p><br>
<h3 id="kak-poeksperimentirovat-s-modelyami-grafov">    ?</h3><br>
<p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alloy Analyzer</a>,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  GitHub</a> —  .</p><br>
<h3 id="a-chto-nam-dayot-opisanie-na-alloy">      Alloy?</h3><br>
<p>   :</p><br>
<ul>
<li>     ,   ,        -   ;</li>
<li>,    ,  ,   assert’  ,       .&nbsp;.;</li>
<li>           (      );</li>
<li>       ,        ,       ,       . ,       ,      .</li>
</ul><br>
<h2 id="zaklyuchenie"></h2><br>
<p>         . Facebook, Google, Microsoft, Amazon          .</p><br>
<ul>
<li>Amazon Web Services, ,      (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Use of Formal Methods at Amazon Web Services</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Formal reasoning about the security of Amazon Web Services</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amazon Relies on Formal Methods for the Security of AWS</a>)</li>
<li>Facebook      (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>).</li>
<li>Google       (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>).</li>
<li>Microsoft      ,    (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spec#</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Formal Methods at Scale in Microsoft</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Formal Methods and Toolsfor Distributed Systems</a>).</li>
</ul><br>
<p>      ,  ,               . </p><br>
<p> agile-         ,     <em> </em>.</p><br>
<p>      ,       :    .</p><br>
<p>      .</p><br>
<p>                .</p><br>
<p>          ,  , ,   ,      (TLA+/TLC, B-method/Atelier&nbsp;B, Promela/SPIN).      .</p><br>
<h2 id="bibliografiya"></h2><br>
<h3 id="knigi-dlya-pogruzheniya-v-oblast">    </h3><br>
<p>  ,    ,   ,    .     .</p><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Michael Jackson Problem Frames: Analysing &amp; Structuring Software Development Problems</a><br>
     (  !),     .   ,        .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daniel Jackson Software Abstractions: Logic, Language, and Analysis</a><br>
  model finder Alloy   .      ,     .     ( join,   ).   ,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> . MODEL CHECKING.      </a><br>
    .  ,    ,   .       ,            .</li>
</ol><br>
<h3 id="primery-prakticheskogo-primeneniya-alloy">   Alloy</h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pamela Zave. How to Make Chord Correct</a><br>
  <strong>Alloy</strong>     <strong>DHT Chord</strong>,   (  ,      ),    .   ,        .<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a><br>
      <strong>Alloy</strong>,      .</li>
</ol></li>
</ol><br>
<h3 id="blogi"></h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hillel Wayne</a><br>
    .  ,  .  ,    .</li>
</ol><br>
<h3 id="prezentacii"></h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">. . , . . , . . .      </a><br>
 ,   ,       .</li>
</ol><br>
<h3 id="alloy">Alloy</h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alloy Analyzer</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Higher-Order Alloy</a><br>
       <strong>Alloy</strong>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Online Tutorial</a><br>
  ,      .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Materials</a><br>
 .</li>
</ol></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457810/">https://habr.com/ru/post/id457810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457796/index.html">Fitur RTC M41T56</a></li>
<li><a href="../id457798/index.html">Apa yang dilakukan oleh sumber dana terbuka - berbicara tentang proyek OpenStack dan Linux Foundation baru-baru ini</a></li>
<li><a href="../id457800/index.html">Kerentanan kritis MacOS Mojave secara aktif dieksploitasi oleh penjahat cyber</a></li>
<li><a href="../id457804/index.html">ListenIt - ekstensi Google Chrome untuk secara otomatis membuat versi audio artikel</a></li>
<li><a href="../id457808/index.html">Thermal imager. Cari Thermal Compact</a></li>
<li><a href="../id457812/index.html">"Tunggu! Siapa yang datang? " Video pengawasan di teras</a></li>
<li><a href="../id457814/index.html">Langkah Selanjutnya 2</a></li>
<li><a href="../id457816/index.html">Sekilas tentang Juju</a></li>
<li><a href="../id457820/index.html">Bagaimana menumbuhkan penginjil untuk perusahaan Anda</a></li>
<li><a href="../id457824/index.html">Stres infeksius: sinkronisasi interspesifik tingkat kortisol pada contoh anjing dan pemiliknya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>