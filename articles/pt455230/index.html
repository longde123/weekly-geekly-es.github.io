<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏾 👨‍👨‍👧‍👦 ☝🏿 Tipos de referência anuláveis ​​em C # 8.0 e análise estática 👧🏿 🕝 🧓🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Não é segredo que a Microsoft esteja trabalhando no lançamento da oitava versão do C # há algum tempo. Na versão recente do Visual Studio 2019, uma no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de referência anuláveis ​​em C # 8.0 e análise estática</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Quadro 9"></p><br>  Não é segredo que a Microsoft esteja trabalhando no lançamento da oitava versão do C # há algum tempo.  Na versão recente do Visual Studio 2019, uma nova versão do idioma (C # 8.0) já está disponível, mas até agora apenas como uma versão beta.  Os planos para esta nova versão têm vários recursos, cuja implementação pode não parecer muito óbvia, ou melhor, não muito esperada.  Uma dessas inovações é a capacidade de usar os tipos de Referência Nula.  O significado declarado dessa inovação é a luta contra as exceções de referência nulas (NRE). <br><a name="habracut"></a><br>  Estamos satisfeitos com o desenvolvimento da linguagem e os novos recursos devem ajudar os desenvolvedores.  Por coincidência, em nosso analisador PVS-Studio para C #, os recursos para detectar exatamente os mesmos NREs no código foram expandidos relativamente recentemente.  E nos perguntamos - existe algum sentido agora para os analisadores estáticos em geral, e para o PVS-Studio em particular, tentar procurar uma desreferenciação potencial de referências nulas, se, pelo menos no novo código usando a Referência Nullable, essa desreferenciação se tornar "impossível" ?  Vamos tentar responder a esta pergunta. <br><br><h2>  Prós e contras da inovação </h2><br>  Para começar, vale lembrar que, na versão beta mais recente do C # 8.0, disponível no momento da redação deste artigo, a Referência Nula é desativada por padrão, ou seja,  o comportamento dos tipos de referência não será alterado. <br><br>  O que são tipos de referência anuláveis ​​no C # 8.0, se você os incluir?  Esse é o mesmo bom e antigo tipo de referência, com a diferença de que variáveis ​​desse tipo agora devem ser marcadas com '?'  (por exemplo, <i>string?</i> ), semelhante a como já é feito para <i>Nullable &lt;T&gt;</i> , ou seja,  tipos significativos anuláveis ​​(por exemplo, <i>int?</i> ).  No entanto, agora a mesma <i>string</i> sem '?'  já começando a ser interpretado como uma referência não anulável, ou seja,  este é um tipo de referência cuja variável não pode conter valores <i>nulos</i> . <br><br>  A exceção de referência nula é uma das exceções mais irritantes, porque fala pouco sobre a origem do problema, especialmente se houver várias desreferências seguidas no método que lança a exceção.  A capacidade de proibir a passagem de <i>nulo</i> para uma variável de referência do tipo parece boa, mas se o <i>nulo</i> anterior <i>foi</i> passado para o método, e alguma lógica de execução adicional foi vinculada a isso, então o que devo fazer agora?  Obviamente, você pode passar um valor literal, constante ou simplesmente "impossível" em vez de <i>nulo</i> que, de acordo com a lógica do programa, não pode ser atribuído a essa variável em nenhum outro lugar.  No entanto, a queda de todo o programa pode ser substituída por uma execução incorreta "silenciosa".  Nem sempre será melhor do que ver o erro imediatamente. <br><br>  E se, em vez disso, lançar uma exceção?  Uma exceção significativa em um lugar onde algo deu errado é sempre melhor do que um <i>NRE em</i> algum lugar mais alto ou mais baixo da pilha.  Mas é bom se estivermos falando sobre nosso próprio projeto, onde podemos consertar os consumidores e inserir um <i>bloco try-catch,</i> e ao desenvolver uma biblioteca usando a (Nullable Reference), assumimos a responsabilidade de que algum método sempre retorne um valor.  E nem sempre é no código nativo que será (pelo menos simples) substituir o retorno <i>nulo</i> por lançar uma exceção (muito código pode ser afetado). <br><br>  Você pode habilitar a Referência Nullable em todo o nível do projeto, adicionando a propriedade <i>NullableContextOptions</i> com o valor <i>enable</i> , ou no nível do arquivo usando a diretiva pré-processador: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Os tipos agora serão mais visuais.  Pela assinatura do método, é possível determinar seu comportamento, se ele contém uma verificação de <i>nulo</i> ou não, ele pode retornar <i>nulo</i> ou não.  Agora, se você tentar acessar uma variável de referência anulável sem verificar, o compilador gerará um aviso. <br><br>  Bastante conveniente ao usar bibliotecas de terceiros, mas há uma situação com possível desinformação.  O fato é que passar <i>nulo</i> ainda é possível, por exemplo, usando o novo operador que perdoa nulo (!).  I.e.  é que, com a ajuda de um único ponto de exclamação, você pode quebrar todas as outras suposições que serão feitas sobre uma interface usando essas variáveis: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Sim, pode-se dizer que é errado escrever dessa maneira, e ninguém nunca fará isso, mas enquanto essa oportunidade permanecer, não será mais possível confiar totalmente apenas no contrato imposto pela interface desse método (que não pode retornar nulo). <br><br>  E você pode, a propósito, escrever a mesma coisa com a ajuda de vários operadores !, Como o C # agora permite que você escreva assim (e esse código é completamente compilado): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  I.e.  gostaríamos de enfatizar ainda mais: preste atenção - isso pode ser <i>nulo</i> !!!  (nós da equipe chamamos isso de programação "emocional").  De fato, o compilador (da Roslyn), ao criar uma árvore de código de sintaxe, interpreta o operador!  semelhante a colchetes simples, seu número, como é o caso entre colchetes, é ilimitado.  Embora, se você escrever muitos deles, o compilador possa ser "despejado".  Talvez isso mude na versão final do C # 8.0. <br><br>  De maneira semelhante, você pode ignorar o aviso do compilador ao acessar uma variável de referência anulável sem verificar: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Você pode escrever mais emocionalmente: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Essa sintaxe é realmente difícil de imaginar em um projeto real, colocando um operador que <i>perdoa nulos</i> que dizemos ao compilador: está tudo bem aqui, nenhuma verificação é necessária.  Adicionando um operador elvis, dizemos: mas em geral pode não ser normal, vamos verificar. <br><br>  E agora surge uma pergunta legítima - por que, se o conceito de um tipo de referência não anulável implica que uma variável desse tipo não pode conter <i>nulo</i> , ainda podemos escrevê-la com tanta facilidade aí?  O fato é que, “sob o capô”, no nível do código IL, nosso tipo de referência não anulável permanece ... todo o mesmo tipo de referência “comum”.  E toda a sintaxe de nulidade é na verdade apenas uma anotação para o analisador estático embutido no compilador (e, em nossa opinião, não é o analisador mais conveniente, mas mais sobre isso posteriormente).  Em nossa opinião, incluir a nova sintaxe no idioma apenas como anotação para uma ferramenta de terceiros (mesmo que esteja embutida no compilador) não é a solução mais "bonita", porque  para um programador que usa essa linguagem, isso é apenas uma anotação pode não ser óbvio - afinal, uma sintaxe muito semelhante para estruturas anuláveis ​​funciona de uma maneira completamente diferente. <br><br>  Voltando a como ainda é possível "quebrar" os tipos de Referência Anulável.  No momento da redação, se houver vários projetos na solução, ao passar de um método declarado em um projeto, uma variável de referência, por exemplo, do tipo <i>String,</i> para um método de outro projeto em que <i>NullableContextOptions está</i> ativado <i>, o</i> compilador decidirá que já é uma String não anulável, e não dará um aviso.  E isso apesar do grande número de atributos <i>[Nullable (1)]</i> adicionados a cada método de campo e classe no código IL, quando as Nullable Reference estão ativadas <i>.</i>  A propósito, esses atributos devem ser levados em consideração se você estiver trabalhando com uma lista de atributos por meio de reflexão, contando com a existência apenas dos atributos que você adicionou. <br><br>  Essa situação pode criar problemas adicionais ao converter uma base de código grande em uma Referência Anulável.  Muito provavelmente, esse processo será gradual, projeto por projeto.  Obviamente, com uma abordagem competente para mudar, você pode mudar gradualmente para um novo funcional, mas se você já tiver um rascunho de trabalho, quaisquer alterações nele serão perigosas e indesejáveis ​​(funciona - não toque!).  É por isso que, ao usar o analisador PVS-Studio, não há necessidade de editar o código-fonte ou de alguma forma marcá-lo para detectar possíveis <i>NREs</i> .  Para verificar os locais onde uma <i>NullReferenceException</i> pode ocorrer <i>,</i> você só precisa iniciar o analisador e observar os avisos do V3080.  Não há necessidade de alterar as propriedades do projeto ou o código fonte.  Não há necessidade de adicionar diretivas, atributos ou operadores.  Não há necessidade de alterar seu código. <br><br>  Com o suporte dos tipos de Referência nula no analisador PVS-Studio, enfrentamos uma opção - o analisador deve interpretar variáveis ​​de referência não anuláveis ​​como sempre valores diferentes de zero?  Depois de estudar a questão das possibilidades de "quebrar" essa garantia, chegamos à conclusão de que não existe - o analisador não deve fazer tal suposição.  De fato, mesmo que tipos de referência não anuláveis ​​sejam usados ​​em qualquer lugar do projeto, o analisador pode suplementar seu uso apenas descobrindo situações nas quais um valor <i>nulo</i> pode aparecer em uma variável. <br><br><h2>  Como o PVS-Studio procura exceções de referência nulas </h2><br>  Os mecanismos de fluxo de dados no analisador C # PVS-Studio monitoram os possíveis valores das variáveis ​​durante a análise.  Em particular, o PVS-Studio também realiza análises interprocedurais, ou seja,  Ele tenta determinar o possível valor retornado pelo método, bem como os métodos chamados nesse método, etc.  Entre outras coisas, o analisador lembra variáveis ​​que podem ser potencialmente <i>nulas</i> .  Se no futuro o analisador vir a desreferenciação sem verificar essa variável, novamente, no código atual que está sendo verificado ou dentro do método chamado neste código, será emitido o aviso V3080 sobre uma possível exceção de referência nula. <br><br>  Ao mesmo tempo, a principal idéia subjacente a esse diagnóstico é que o analisador jurará apenas se encontrar em algum lugar a atribuição de <i>nulo</i> a uma variável.  Essa é a principal diferença entre o comportamento desse diagnóstico e o analisador incorporado no compilador que funciona com os tipos de Referência Nula.  O analisador embutido no compilador jurará a qualquer desreferência de uma variável de referência nula não verificada do tipo, a menos que, é claro, esse analisador seja "enganado" pelo operador! de qualquer outra maneira, absolutamente qualquer analisador pode ser usado, especialmente se você definir esse objetivo e o PVS-Studio não for uma exceção). <br><br>  O PVS-Studio jura apenas se for <i>nulo</i> (em um contexto local ou proveniente de um método).  Ao mesmo tempo, mesmo que a variável seja uma variável de referência não anulável, o comportamento do analisador não será alterado - ele ainda jurará se vir que nulo foi gravado nela.  Essa abordagem nos parece mais correta (ou pelo menos conveniente para o usuário do analisador), pois  não é necessário "cobrir" todo o código com verificações <i>nulas</i> para encontrar desreferências em potencial - isso poderia ter sido feito antes, sem uma Referência Anulável, por exemplo, com os mesmos contratos.  Além disso, o analisador agora pode ser usado para controle adicional sobre as mesmas variáveis ​​de referência não anuláveis.  Se eles forem usados ​​"honestamente" e nunca forem atribuídos nulos - o analisador permanecerá silencioso.  Se nulo for designado e a variável for desreferenciada sem verificação, o analisador avisará sobre isso com a mensagem V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Vamos considerar alguns exemplos desse disparo dos diagnósticos do V3080 no código do próprio Roslyn.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verificamos este projeto</a> há pouco tempo, mas, desta vez, consideraremos apenas os possíveis gatilhos de exceção de referência nula que não estavam nos artigos anteriores.  Vamos ver como o analisador PVS-Studio pode encontrar uma possível desreferenciação de referências nulas e como esses locais podem ser corrigidos usando a nova sintaxe Nullable Reference. <br><br>  <i>V3080 [CWE-476] Possível desreferência nula dentro do método.</i>  <i>Considere inspecionar o segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como você pode ver, a variável <i>chainedTupleType</i> pode ser nula em uma das ramificações de execução de código.  Em seguida, <i>chainedTupleType é</i> passado dentro do método <i>ConstructTupleUnderlyingType</i> e é usado lá com verificação por meio de <i>Debug.Assert</i> .  Essa situação é muito comum em Roslyn, no entanto, vale lembrar que <i>Debug.Assert</i> é excluído na versão do assembly.  Portanto, o analisador ainda considera perigosa a desreferenciação dentro do método <i>ConstructTupleUnderlyingType</i> .  A seguir, apresentamos o corpo desse método, onde ocorre a desreferenciação: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Se o analisador deve levar em consideração essa afirmação é realmente um ponto discutível (alguns de nossos usuários desejam fazer isso), porque os contratos da System.Diagnostics.Contracts, por exemplo, o analisador agora leva em consideração.  Vou contar apenas um pequeno exemplo do uso real do mesmo Roslyn em nosso analisador.  Recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suportamos a nova versão do Visual Studio</a> e, ao mesmo tempo, atualizamos o analisador Roslyn para a versão 3.  Depois disso, o analisador começou a cair ao verificar um determinado código no qual não havia travado anteriormente.  Ao mesmo tempo, o analisador começou a cair não dentro do nosso código, mas dentro do código do próprio Roslyn - cair com uma exceção de referência nula.  E a depuração adicional mostrou que, no local em que Roslyn agora cai, exatamente algumas linhas acima, há a mesma verificação <i>nula</i> no <i>Debug.Assert</i> .  E ela, como vemos, não salvou. <br><br>  Este é um exemplo muito bom de problemas com a Referência Nulável <i>,</i> porque o compilador considera <i>Debug.Assert uma</i> verificação válida em qualquer configuração.  Ou seja, se você simplesmente habilitar <i>#nullable enable</i> e marcar o argumento <i>chainedTupleTypeOpt</i> como uma referência nula <i>,</i> não haverá avisos do compilador no local de desreferência no método <i>ConstructTupleUnderlyingType</i> . <br><br>  Considere o seguinte exemplo de acionamento do PVS-Studio. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'eficazRuleset'.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esse aviso observa que a chamada do método <i>WithEffectiveAction</i> pode retornar <i>nulo</i> , mas o resultado é usado sem verificação ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  O corpo do método <i>WithEffectiveAction</i> , que pode retornar nulo, é gravado na variável <i>effectiveRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Se você ativar o modo Nullable Reference para o método <i>GetEffectiveRuleSet</i> , teremos dois lugares nos quais precisamos alterar o comportamento.  Como existe uma exceção no método acima, é lógico supor que a chamada do método seja agrupada em um <i>bloco try-catch</i> e ela reescreverá o método corretamente, lançando uma exceção em vez de retornar nulo.  Mas, escalando os desafios, vemos que a interceptação é alta e as consequências podem ser imprevisíveis.  Vejamos a variável de consumidor <i>effectiveRuleset</i> - <i>IsStricterThan</i> método <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como você pode ver, essa é uma opção simples para duas enumerações com um possível valor de enumeração <i>ReportDiagnostic.Default</i> .  Portanto, é melhor reescrever a chamada da seguinte maneira: <br><br>  A assinatura <i>WithEffectiveAction</i> será alterada: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  a chamada terá a seguinte aparência: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  sabendo que o <i>IsStricterThan</i> realiza apenas comparação - a condição pode ser reescrita, por exemplo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Vamos passar para a próxima mensagem do analisador. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  O uso adicional da variável <i>propertySymbol</i> deve ser levado em consideração ao corrigir o aviso do analisador. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  O método <i>GetMemberSymbol</i> também pode retornar <i>nulo</i> em alguns casos. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Usando um tipo de referência anulável, a chamada mudará assim: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Muito simples quando você sabe onde corrigi-lo.  A análise estática encontra facilmente esse erro em potencial, obtendo todos os valores de campo possíveis em todas as cadeias de chamadas de procedimento. <br><br>  <i>V3080 Possível desreferência nula.</i>  <i>Considere inspecionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  O problema está na linha de verificação de <i>simpleName.Length.</i>  <i>simpleName</i> é o resultado de uma cadeia inteira de métodos e pode ser <i>nulo</i> .  A propósito, por uma questão de curiosidade, você pode observar o método <i>RemoveExtension</i> e encontrar diferenças em <i>Path.GetFileNameWithoutExtension.</i>  Aqui, poderíamos nos restringir à verificação de <i>simpleName! = Null</i> , mas no contexto de links diferentes de zero, o código será mais ou menos assim: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  A chamada terá a seguinte aparência: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclusão </h2><br>  Os tipos de referência anulável podem ser de grande ajuda no planejamento de uma arquitetura criada a partir do zero, mas a reformulação do código existente pode exigir muito tempo e cuidado, pois pode causar muitos erros sutis.  Neste artigo, não pretendemos desencorajar ninguém de usar os tipos de Referência Nulável em nossos projetos.  Acreditamos que essa inovação é geralmente útil para o idioma, embora a forma como foi implementada possa suscitar dúvidas. <br><br>  Você deve sempre se lembrar das limitações inerentes a essa abordagem, e que o modo de Referência Nulável ativado não protege contra erros com a desreferenciação de links nulos e, se usado incorretamente, pode até levar a eles.  Vale a pena considerar o uso de um analisador estático moderno, por exemplo, o PVS-Studio, que oferece suporte à análise interprocedural, como uma ferramenta adicional que, junto com a Referência Nullable, pode protegê-lo de não fazer referência a referências nulas.  Cada uma dessas abordagens - tanto a análise interprocedural aprofundada quanto a anotação de assinaturas de métodos (que essencialmente faz a referência nula) - tem suas vantagens e desvantagens.  O analisador permitirá que você obtenha uma lista de locais potencialmente perigosos e também, ao alterar um código existente, veja todas as consequências de tais alterações.  Se você atribuir <i>nulo</i> em qualquer caso, o analisador deve indicar imediatamente a todos os consumidores a variável, onde ela não é verificada antes da referência à referência. <br><br>  Você pode procurar por outros erros de forma independente, tanto no projeto considerado como no seu.  Para fazer isso, basta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixar</a> e experimentar o analisador PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Se você deseja compartilhar este artigo com um público que fala inglês, use o link para a tradução: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de referência anuláveis ​​em C # 8.0 e análise estática</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455230/">https://habr.com/ru/post/pt455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455216/index.html">Medidor de velocidade Doppler</a></li>
<li><a href="../pt455218/index.html">Abordagem Ecossistêmica à Tecnologia Empresarial</a></li>
<li><a href="../pt455224/index.html">Música Finger: Tocar qualquer coisa com SpecDrums de Sphero</a></li>
<li><a href="../pt455226/index.html">Por que aplicar um linguista aplicado?</a></li>
<li><a href="../pt455228/index.html">Aquele que ressuscitou Duke Nukem: Entrevista com Randy Pitchford, Assistente de caixa de velocidades</a></li>
<li><a href="../pt455234/index.html">Tipos de referência anuláveis ​​em C # 8.0 e análise estática</a></li>
<li><a href="../pt455236/index.html">Comodo revoga certificados sem motivo</a></li>
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relatório de erros</a></li>
<li><a href="../pt455244/index.html">História em quadrinhos "A soldagem é fácil" na versão atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscrições para o Customer Experience Day em São Petersburgo estão abertas em 20 de junho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>