<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèæ üë®‚Äçüë®‚Äçüëß‚Äçüë¶ ‚òùüèø Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica üëßüèø üïù üßìüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="N√£o √© segredo que a Microsoft esteja trabalhando no lan√ßamento da oitava vers√£o do C # h√° algum tempo. Na vers√£o recente do Visual Studio 2019, uma no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/455230/"><p><img src="https://habrastorage.org/getpro/habr/post_images/523/17b/496/52317b4960a8b063bc7b6541e4e2666d.png" alt="Quadro 9"></p><br>  N√£o √© segredo que a Microsoft esteja trabalhando no lan√ßamento da oitava vers√£o do C # h√° algum tempo.  Na vers√£o recente do Visual Studio 2019, uma nova vers√£o do idioma (C # 8.0) j√° est√° dispon√≠vel, mas at√© agora apenas como uma vers√£o beta.  Os planos para esta nova vers√£o t√™m v√°rios recursos, cuja implementa√ß√£o pode n√£o parecer muito √≥bvia, ou melhor, n√£o muito esperada.  Uma dessas inova√ß√µes √© a capacidade de usar os tipos de Refer√™ncia Nula.  O significado declarado dessa inova√ß√£o √© a luta contra as exce√ß√µes de refer√™ncia nulas (NRE). <br><a name="habracut"></a><br>  Estamos satisfeitos com o desenvolvimento da linguagem e os novos recursos devem ajudar os desenvolvedores.  Por coincid√™ncia, em nosso analisador PVS-Studio para C #, os recursos para detectar exatamente os mesmos NREs no c√≥digo foram expandidos relativamente recentemente.  E nos perguntamos - existe algum sentido agora para os analisadores est√°ticos em geral, e para o PVS-Studio em particular, tentar procurar uma desreferencia√ß√£o potencial de refer√™ncias nulas, se, pelo menos no novo c√≥digo usando a Refer√™ncia Nullable, essa desreferencia√ß√£o se tornar "imposs√≠vel" ?  Vamos tentar responder a esta pergunta. <br><br><h2>  Pr√≥s e contras da inova√ß√£o </h2><br>  Para come√ßar, vale lembrar que, na vers√£o beta mais recente do C # 8.0, dispon√≠vel no momento da reda√ß√£o deste artigo, a Refer√™ncia Nula √© desativada por padr√£o, ou seja,  o comportamento dos tipos de refer√™ncia n√£o ser√° alterado. <br><br>  O que s√£o tipos de refer√™ncia anul√°veis ‚Äã‚Äãno C # 8.0, se voc√™ os incluir?  Esse √© o mesmo bom e antigo tipo de refer√™ncia, com a diferen√ßa de que vari√°veis ‚Äã‚Äãdesse tipo agora devem ser marcadas com '?'  (por exemplo, <i>string?</i> ), semelhante a como j√° √© feito para <i>Nullable &lt;T&gt;</i> , ou seja,  tipos significativos anul√°veis ‚Äã‚Äã(por exemplo, <i>int?</i> ).  No entanto, agora a mesma <i>string</i> sem '?'  j√° come√ßando a ser interpretado como uma refer√™ncia n√£o anul√°vel, ou seja,  este √© um tipo de refer√™ncia cuja vari√°vel n√£o pode conter valores <i>nulos</i> . <br><br>  A exce√ß√£o de refer√™ncia nula √© uma das exce√ß√µes mais irritantes, porque fala pouco sobre a origem do problema, especialmente se houver v√°rias desrefer√™ncias seguidas no m√©todo que lan√ßa a exce√ß√£o.  A capacidade de proibir a passagem de <i>nulo</i> para uma vari√°vel de refer√™ncia do tipo parece boa, mas se o <i>nulo</i> anterior <i>foi</i> passado para o m√©todo, e alguma l√≥gica de execu√ß√£o adicional foi vinculada a isso, ent√£o o que devo fazer agora?  Obviamente, voc√™ pode passar um valor literal, constante ou simplesmente "imposs√≠vel" em vez de <i>nulo</i> que, de acordo com a l√≥gica do programa, n√£o pode ser atribu√≠do a essa vari√°vel em nenhum outro lugar.  No entanto, a queda de todo o programa pode ser substitu√≠da por uma execu√ß√£o incorreta "silenciosa".  Nem sempre ser√° melhor do que ver o erro imediatamente. <br><br>  E se, em vez disso, lan√ßar uma exce√ß√£o?  Uma exce√ß√£o significativa em um lugar onde algo deu errado √© sempre melhor do que um <i>NRE em</i> algum lugar mais alto ou mais baixo da pilha.  Mas √© bom se estivermos falando sobre nosso pr√≥prio projeto, onde podemos consertar os consumidores e inserir um <i>bloco try-catch,</i> e ao desenvolver uma biblioteca usando a (Nullable Reference), assumimos a responsabilidade de que algum m√©todo sempre retorne um valor.  E nem sempre √© no c√≥digo nativo que ser√° (pelo menos simples) substituir o retorno <i>nulo</i> por lan√ßar uma exce√ß√£o (muito c√≥digo pode ser afetado). <br><br>  Voc√™ pode habilitar a Refer√™ncia Nullable em todo o n√≠vel do projeto, adicionando a propriedade <i>NullableContextOptions</i> com o valor <i>enable</i> , ou no n√≠vel do arquivo usando a diretiva pr√©-processador: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable string cantBeNull = string.Empty; string? canBeNull = null; cantBeNull = canBeNull!;</span></span></code> </pre> <br>  Os tipos agora ser√£o mais visuais.  Pela assinatura do m√©todo, √© poss√≠vel determinar seu comportamento, se ele cont√©m uma verifica√ß√£o de <i>nulo</i> ou n√£o, ele pode retornar <i>nulo</i> ou n√£o.  Agora, se voc√™ tentar acessar uma vari√°vel de refer√™ncia anul√°vel sem verificar, o compilador gerar√° um aviso. <br><br>  Bastante conveniente ao usar bibliotecas de terceiros, mas h√° uma situa√ß√£o com poss√≠vel desinforma√ß√£o.  O fato √© que passar <i>nulo</i> ainda √© poss√≠vel, por exemplo, usando o novo operador que perdoa nulo (!).  I.e.  √© que, com a ajuda de um √∫nico ponto de exclama√ß√£o, voc√™ pode quebrar todas as outras suposi√ß√µes que ser√£o feitas sobre uma interface usando essas vari√°veis: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length;</span></span></code> </pre> <br>  Sim, pode-se dizer que √© errado escrever dessa maneira, e ningu√©m nunca far√° isso, mas enquanto essa oportunidade permanecer, n√£o ser√° mais poss√≠vel confiar totalmente apenas no contrato imposto pela interface desse m√©todo (que n√£o pode retornar nulo). <br><br>  E voc√™ pode, a prop√≥sito, escrever a mesma coisa com a ajuda de v√°rios operadores !, Como o C # agora permite que voc√™ escreva assim (e esse c√≥digo √© completamente compilado): <br><pre> <code class="cpp hljs">cantBeNull = canBeNull!!!!!!!;</code> </pre> <br>  I.e.  gostar√≠amos de enfatizar ainda mais: preste aten√ß√£o - isso pode ser <i>nulo</i> !!!  (n√≥s da equipe chamamos isso de programa√ß√£o "emocional").  De fato, o compilador (da Roslyn), ao criar uma √°rvore de c√≥digo de sintaxe, interpreta o operador!  semelhante a colchetes simples, seu n√∫mero, como √© o caso entre colchetes, √© ilimitado.  Embora, se voc√™ escrever muitos deles, o compilador possa ser "despejado".  Talvez isso mude na vers√£o final do C # 8.0. <br><br>  De maneira semelhante, voc√™ pode ignorar o aviso do compilador ao acessar uma vari√°vel de refer√™ncia anul√°vel sem verificar: <br><pre> <code class="cpp hljs">canBeNull!.ToString();</code> </pre> <br>  Voc√™ pode escrever mais emocionalmente: <br><pre> <code class="cpp hljs">canBeNull!!!?.ToString();</code> </pre> <br>  Essa sintaxe √© realmente dif√≠cil de imaginar em um projeto real, colocando um operador que <i>perdoa nulos</i> que dizemos ao compilador: est√° tudo bem aqui, nenhuma verifica√ß√£o √© necess√°ria.  Adicionando um operador elvis, dizemos: mas em geral pode n√£o ser normal, vamos verificar. <br><br>  E agora surge uma pergunta leg√≠tima - por que, se o conceito de um tipo de refer√™ncia n√£o anul√°vel implica que uma vari√°vel desse tipo n√£o pode conter <i>nulo</i> , ainda podemos escrev√™-la com tanta facilidade a√≠?  O fato √© que, ‚Äúsob o cap√¥‚Äù, no n√≠vel do c√≥digo IL, nosso tipo de refer√™ncia n√£o anul√°vel permanece ... todo o mesmo tipo de refer√™ncia ‚Äúcomum‚Äù.  E toda a sintaxe de nulidade √© na verdade apenas uma anota√ß√£o para o analisador est√°tico embutido no compilador (e, em nossa opini√£o, n√£o √© o analisador mais conveniente, mas mais sobre isso posteriormente).  Em nossa opini√£o, incluir a nova sintaxe no idioma apenas como anota√ß√£o para uma ferramenta de terceiros (mesmo que esteja embutida no compilador) n√£o √© a solu√ß√£o mais "bonita", porque  para um programador que usa essa linguagem, isso √© apenas uma anota√ß√£o pode n√£o ser √≥bvio - afinal, uma sintaxe muito semelhante para estruturas anul√°veis ‚Äã‚Äãfunciona de uma maneira completamente diferente. <br><br>  Voltando a como ainda √© poss√≠vel "quebrar" os tipos de Refer√™ncia Anul√°vel.  No momento da reda√ß√£o, se houver v√°rios projetos na solu√ß√£o, ao passar de um m√©todo declarado em um projeto, uma vari√°vel de refer√™ncia, por exemplo, do tipo <i>String,</i> para um m√©todo de outro projeto em que <i>NullableContextOptions est√°</i> ativado <i>, o</i> compilador decidir√° que j√° √© uma String n√£o anul√°vel, e n√£o dar√° um aviso.  E isso apesar do grande n√∫mero de atributos <i>[Nullable (1)]</i> adicionados a cada m√©todo de campo e classe no c√≥digo IL, quando as Nullable Reference est√£o ativadas <i>.</i>  A prop√≥sito, esses atributos devem ser levados em considera√ß√£o se voc√™ estiver trabalhando com uma lista de atributos por meio de reflex√£o, contando com a exist√™ncia apenas dos atributos que voc√™ adicionou. <br><br>  Essa situa√ß√£o pode criar problemas adicionais ao converter uma base de c√≥digo grande em uma Refer√™ncia Anul√°vel.  Muito provavelmente, esse processo ser√° gradual, projeto por projeto.  Obviamente, com uma abordagem competente para mudar, voc√™ pode mudar gradualmente para um novo funcional, mas se voc√™ j√° tiver um rascunho de trabalho, quaisquer altera√ß√µes nele ser√£o perigosas e indesej√°veis ‚Äã‚Äã(funciona - n√£o toque!).  √â por isso que, ao usar o analisador PVS-Studio, n√£o h√° necessidade de editar o c√≥digo-fonte ou de alguma forma marc√°-lo para detectar poss√≠veis <i>NREs</i> .  Para verificar os locais onde uma <i>NullReferenceException</i> pode ocorrer <i>,</i> voc√™ s√≥ precisa iniciar o analisador e observar os avisos do V3080.  N√£o h√° necessidade de alterar as propriedades do projeto ou o c√≥digo fonte.  N√£o h√° necessidade de adicionar diretivas, atributos ou operadores.  N√£o h√° necessidade de alterar seu c√≥digo. <br><br>  Com o suporte dos tipos de Refer√™ncia nula no analisador PVS-Studio, enfrentamos uma op√ß√£o - o analisador deve interpretar vari√°veis ‚Äã‚Äãde refer√™ncia n√£o anul√°veis ‚Äã‚Äãcomo sempre valores diferentes de zero?  Depois de estudar a quest√£o das possibilidades de "quebrar" essa garantia, chegamos √† conclus√£o de que n√£o existe - o analisador n√£o deve fazer tal suposi√ß√£o.  De fato, mesmo que tipos de refer√™ncia n√£o anul√°veis ‚Äã‚Äãsejam usados ‚Äã‚Äãem qualquer lugar do projeto, o analisador pode suplementar seu uso apenas descobrindo situa√ß√µes nas quais um valor <i>nulo</i> pode aparecer em uma vari√°vel. <br><br><h2>  Como o PVS-Studio procura exce√ß√µes de refer√™ncia nulas </h2><br>  Os mecanismos de fluxo de dados no analisador C # PVS-Studio monitoram os poss√≠veis valores das vari√°veis ‚Äã‚Äãdurante a an√°lise.  Em particular, o PVS-Studio tamb√©m realiza an√°lises interprocedurais, ou seja,  Ele tenta determinar o poss√≠vel valor retornado pelo m√©todo, bem como os m√©todos chamados nesse m√©todo, etc.  Entre outras coisas, o analisador lembra vari√°veis ‚Äã‚Äãque podem ser potencialmente <i>nulas</i> .  Se no futuro o analisador vir a desreferencia√ß√£o sem verificar essa vari√°vel, novamente, no c√≥digo atual que est√° sendo verificado ou dentro do m√©todo chamado neste c√≥digo, ser√° emitido o aviso V3080 sobre uma poss√≠vel exce√ß√£o de refer√™ncia nula. <br><br>  Ao mesmo tempo, a principal id√©ia subjacente a esse diagn√≥stico √© que o analisador jurar√° apenas se encontrar em algum lugar a atribui√ß√£o de <i>nulo</i> a uma vari√°vel.  Essa √© a principal diferen√ßa entre o comportamento desse diagn√≥stico e o analisador incorporado no compilador que funciona com os tipos de Refer√™ncia Nula.  O analisador embutido no compilador jurar√° a qualquer desrefer√™ncia de uma vari√°vel de refer√™ncia nula n√£o verificada do tipo, a menos que, √© claro, esse analisador seja "enganado" pelo operador! de qualquer outra maneira, absolutamente qualquer analisador pode ser usado, especialmente se voc√™ definir esse objetivo e o PVS-Studio n√£o for uma exce√ß√£o). <br><br>  O PVS-Studio jura apenas se for <i>nulo</i> (em um contexto local ou proveniente de um m√©todo).  Ao mesmo tempo, mesmo que a vari√°vel seja uma vari√°vel de refer√™ncia n√£o anul√°vel, o comportamento do analisador n√£o ser√° alterado - ele ainda jurar√° se vir que nulo foi gravado nela.  Essa abordagem nos parece mais correta (ou pelo menos conveniente para o usu√°rio do analisador), pois  n√£o √© necess√°rio "cobrir" todo o c√≥digo com verifica√ß√µes <i>nulas</i> para encontrar desrefer√™ncias em potencial - isso poderia ter sido feito antes, sem uma Refer√™ncia Anul√°vel, por exemplo, com os mesmos contratos.  Al√©m disso, o analisador agora pode ser usado para controle adicional sobre as mesmas vari√°veis ‚Äã‚Äãde refer√™ncia n√£o anul√°veis.  Se eles forem usados ‚Äã‚Äã"honestamente" e nunca forem atribu√≠dos nulos - o analisador permanecer√° silencioso.  Se nulo for designado e a vari√°vel for desreferenciada sem verifica√ß√£o, o analisador avisar√° sobre isso com a mensagem V3080: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable String GetStr() { return _count &gt; 0 ? _str : null!; } String str = GetStr(); var len = str.Length; &lt;== V3080: Possible null dereference. Consider inspecting </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'str'</span></span></span></span></code> </pre> <br><br>  Vamos considerar alguns exemplos desse disparo dos diagn√≥sticos do V3080 no c√≥digo do pr√≥prio Roslyn.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verificamos este projeto</a> h√° pouco tempo, mas, desta vez, consideraremos apenas os poss√≠veis gatilhos de exce√ß√£o de refer√™ncia nula que n√£o estavam nos artigos anteriores.  Vamos ver como o analisador PVS-Studio pode encontrar uma poss√≠vel desreferencia√ß√£o de refer√™ncias nulas e como esses locais podem ser corrigidos usando a nova sintaxe Nullable Reference. <br><br>  <i>V3080 [CWE-476] Poss√≠vel desrefer√™ncia nula dentro do m√©todo.</i>  <i>Considere inspecionar o segundo argumento: chainedTupleType.</i>  <i>Microsoft.CodeAnalysis.CSharp TupleTypeSymbol.cs 244</i> <br><pre> <code class="cpp hljs">NamedTypeSymbol chainedTupleType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_underlyingType.Arity &lt; TupleTypeSymbol.RestPosition) { .... chainedTupleType = null; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create(ConstructTupleUnderlyingType(firstTupleType, chainedTupleType, newElementTypes), elementNames: _elementNames);</code> </pre> <br>  Como voc√™ pode ver, a vari√°vel <i>chainedTupleType</i> pode ser nula em uma das ramifica√ß√µes de execu√ß√£o de c√≥digo.  Em seguida, <i>chainedTupleType √©</i> passado dentro do m√©todo <i>ConstructTupleUnderlyingType</i> e √© usado l√° com verifica√ß√£o por meio de <i>Debug.Assert</i> .  Essa situa√ß√£o √© muito comum em Roslyn, no entanto, vale lembrar que <i>Debug.Assert</i> √© exclu√≠do na vers√£o do assembly.  Portanto, o analisador ainda considera perigosa a desreferencia√ß√£o dentro do m√©todo <i>ConstructTupleUnderlyingType</i> .  A seguir, apresentamos o corpo desse m√©todo, onde ocorre a desreferencia√ß√£o: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NamedTypeSymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConstructTupleUnderlyingType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( NamedTypeSymbol firstTupleType, NamedTypeSymbol chainedTupleTypeOpt, ImmutableArray&lt;TypeWithAnnotations&gt; elementTypes)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert (chainedTupleTypeOpt is null == elementTypes.Length &lt; RestPosition); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loop &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... currentSymbol = chainedTupleTypeOpt.Construct(chainedTypes); loop--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentSymbol; }</code> </pre> <br>  Se o analisador deve levar em considera√ß√£o essa afirma√ß√£o √© realmente um ponto discut√≠vel (alguns de nossos usu√°rios desejam fazer isso), porque os contratos da System.Diagnostics.Contracts, por exemplo, o analisador agora leva em considera√ß√£o.  Vou contar apenas um pequeno exemplo do uso real do mesmo Roslyn em nosso analisador.  Recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suportamos a nova vers√£o do Visual Studio</a> e, ao mesmo tempo, atualizamos o analisador Roslyn para a vers√£o 3.  Depois disso, o analisador come√ßou a cair ao verificar um determinado c√≥digo no qual n√£o havia travado anteriormente.  Ao mesmo tempo, o analisador come√ßou a cair n√£o dentro do nosso c√≥digo, mas dentro do c√≥digo do pr√≥prio Roslyn - cair com uma exce√ß√£o de refer√™ncia nula.  E a depura√ß√£o adicional mostrou que, no local em que Roslyn agora cai, exatamente algumas linhas acima, h√° a mesma verifica√ß√£o <i>nula</i> no <i>Debug.Assert</i> .  E ela, como vemos, n√£o salvou. <br><br>  Este √© um exemplo muito bom de problemas com a Refer√™ncia Nul√°vel <i>,</i> porque o compilador considera <i>Debug.Assert uma</i> verifica√ß√£o v√°lida em qualquer configura√ß√£o.  Ou seja, se voc√™ simplesmente habilitar <i>#nullable enable</i> e marcar o argumento <i>chainedTupleTypeOpt</i> como uma refer√™ncia nula <i>,</i> n√£o haver√° avisos do compilador no local de desrefer√™ncia no m√©todo <i>ConstructTupleUnderlyingType</i> . <br><br>  Considere o seguinte exemplo de acionamento do PVS-Studio. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'eficazRuleset'.</i>  <i>RuleSet.cs 146</i> <br><pre> <code class="cpp hljs">var effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, ....)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre><br>  Esse aviso observa que a chamada do m√©todo <i>WithEffectiveAction</i> pode retornar <i>nulo</i> , mas o resultado √© usado sem verifica√ß√£o ( <i>effectiveRuleset.GeneralDiagnosticOption</i> ).  O corpo do m√©todo <i>WithEffectiveAction</i> , que pode retornar nulo, √© gravado na vari√°vel <i>effectiveRuleset</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RuleSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WithEffectiveAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_includes.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(....); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuleSet(....); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br><br>  Se voc√™ ativar o modo Nullable Reference para o m√©todo <i>GetEffectiveRuleSet</i> , teremos dois lugares nos quais precisamos alterar o comportamento.  Como existe uma exce√ß√£o no m√©todo acima, √© l√≥gico supor que a chamada do m√©todo seja agrupada em um <i>bloco try-catch</i> e ela reescrever√° o m√©todo corretamente, lan√ßando uma exce√ß√£o em vez de retornar nulo.  Mas, escalando os desafios, vemos que a intercepta√ß√£o √© alta e as consequ√™ncias podem ser imprevis√≠veis.  Vejamos a vari√°vel de consumidor <i>effectiveRuleset</i> - <i>IsStricterThan</i> m√©todo <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStricterThan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ReportDiagnostic action1, ReportDiagnostic action2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action2) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Suppress: ....; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Warn: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action1 == ReportDiagnostic.Error; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ReportDiagnostic.Error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Como voc√™ pode ver, essa √© uma op√ß√£o simples para duas enumera√ß√µes com um poss√≠vel valor de enumera√ß√£o <i>ReportDiagnostic.Default</i> .  Portanto, √© melhor reescrever a chamada da seguinte maneira: <br><br>  A assinatura <i>WithEffectiveAction</i> ser√° alterada: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public RuleSet? WithEffectiveAction(ReportDiagnostic action)</span></span></code> </pre> <br>  a chamada ter√° a seguinte apar√™ncia: <br><pre> <code class="cpp hljs">RuleSet? effectiveRuleset = ruleSet.GetEffectiveRuleSet(includedRulesetPaths); effectiveRuleset = effectiveRuleset?.WithEffectiveAction(ruleSetInclude.Action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsStricterThan(effectiveRuleset?.GeneralDiagnosticOption ?? ReportDiagnostic.Default, effectiveGeneralOption)) effectiveGeneralOption = effectiveRuleset.GeneralDiagnosticOption;</code> </pre> <br>  sabendo que o <i>IsStricterThan</i> realiza apenas compara√ß√£o - a condi√ß√£o pode ser reescrita, por exemplo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effectiveRuleset == null || IsStricterThan(effectiveRuleset.GeneralDiagnosticOption, effectiveGeneralOption))</code> </pre> <br>  Vamos passar para a pr√≥xima mensagem do analisador. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'propertySymbol'.</i>  <i>BinderFactory.BinderFactoryVisitor.cs 372</i> <br><pre> <code class="cpp hljs">var propertySymbol = GetPropertySymbol(parent, resultBinder); var accessor = propertySymbol.GetMethod; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)accessor != null) resultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMethodBinder(accessor, resultBinder);</code> </pre> <br>  O uso adicional da vari√°vel <i>propertySymbol</i> deve ser levado em considera√ß√£o ao corrigir o aviso do analisador. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SourcePropertySymbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPropertySymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BasePropertyDeclarationSyntax basePropertyDeclarationSyntax, Binder outerBinder)</span></span></span><span class="hljs-function"> </span></span>{ .... NamedTypeSymbol container = GetContainerType(outerBinder, basePropertyDeclarationSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)container == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SourcePropertySymbol)GetMemberSymbol(propertyName, basePropertyDeclarationSyntax.Span, container, SymbolKind.Property); }</code> </pre> <br>  O m√©todo <i>GetMemberSymbol</i> tamb√©m pode retornar <i>nulo</i> em alguns casos. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Symbol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMemberSymbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memberName, TextSpan memberSpan, NamedTypeSymbol container, SymbolKind kind)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Symbol sym in container.GetMembers(memberName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind != kind) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sym.Kind == SymbolKind.Method) { .... var implementation = ((MethodSymbol)sym).PartialImplementationPart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((object)implementation != null) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(implementation.Locations[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> implementation; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InSpan(sym.Locations, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.syntaxTree, memberSpan)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sym; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br>  Usando um tipo de refer√™ncia anul√°vel, a chamada mudar√° assim: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable SourcePropertySymbol? propertySymbol = GetPropertySymbol(parent, resultBinder); MethodSymbol? accessor = propertySymbol?.GetMethod; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((object)accessor != null) resultBinder = new InMethodBinder(accessor, resultBinder);</span></span></code> </pre> <br>  Muito simples quando voc√™ sabe onde corrigi-lo.  A an√°lise est√°tica encontra facilmente esse erro em potencial, obtendo todos os valores de campo poss√≠veis em todas as cadeias de chamadas de procedimento. <br><br>  <i>V3080 Poss√≠vel desrefer√™ncia nula.</i>  <i>Considere inspecionar 'simpleName'.</i>  <i>CSharpCommandLineParser.cs 1556</i> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> simpleName; simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)); outputFileName = simpleName + outputKind.GetDefaultExtension(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (simpleName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !outputKind.IsNetModule()) ....</code> </pre> <br>  O problema est√° na linha de verifica√ß√£o de <i>simpleName.Length.</i>  <i>simpleName</i> √© o resultado de uma cadeia inteira de m√©todos e pode ser <i>nulo</i> .  A prop√≥sito, por uma quest√£o de curiosidade, voc√™ pode observar o m√©todo <i>RemoveExtension</i> e encontrar diferen√ßas em <i>Path.GetFileNameWithoutExtension.</i>  Aqui, poder√≠amos nos restringir √† verifica√ß√£o de <i>simpleName! = Null</i> , mas no contexto de links diferentes de zero, o c√≥digo ser√° mais ou menos assim: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#nullable enable public static string? RemoveExtension(string path) { .... } string simpleName;</span></span></code> </pre> <br>  A chamada ter√° a seguinte apar√™ncia: <br><pre> <code class="cpp hljs">simpleName = PathUtilities.RemoveExtension( PathUtilities.GetFileName(sourceFiles.FirstOrDefault().Path)) ?? String.Empty;</code> </pre> <br><h2>  Conclus√£o </h2><br>  Os tipos de refer√™ncia anul√°vel podem ser de grande ajuda no planejamento de uma arquitetura criada a partir do zero, mas a reformula√ß√£o do c√≥digo existente pode exigir muito tempo e cuidado, pois pode causar muitos erros sutis.  Neste artigo, n√£o pretendemos desencorajar ningu√©m de usar os tipos de Refer√™ncia Nul√°vel em nossos projetos.  Acreditamos que essa inova√ß√£o √© geralmente √∫til para o idioma, embora a forma como foi implementada possa suscitar d√∫vidas. <br><br>  Voc√™ deve sempre se lembrar das limita√ß√µes inerentes a essa abordagem, e que o modo de Refer√™ncia Nul√°vel ativado n√£o protege contra erros com a desreferencia√ß√£o de links nulos e, se usado incorretamente, pode at√© levar a eles.  Vale a pena considerar o uso de um analisador est√°tico moderno, por exemplo, o PVS-Studio, que oferece suporte √† an√°lise interprocedural, como uma ferramenta adicional que, junto com a Refer√™ncia Nullable, pode proteg√™-lo de n√£o fazer refer√™ncia a refer√™ncias nulas.  Cada uma dessas abordagens - tanto a an√°lise interprocedural aprofundada quanto a anota√ß√£o de assinaturas de m√©todos (que essencialmente faz a refer√™ncia nula) - tem suas vantagens e desvantagens.  O analisador permitir√° que voc√™ obtenha uma lista de locais potencialmente perigosos e tamb√©m, ao alterar um c√≥digo existente, veja todas as consequ√™ncias de tais altera√ß√µes.  Se voc√™ atribuir <i>nulo</i> em qualquer caso, o analisador deve indicar imediatamente a todos os consumidores a vari√°vel, onde ela n√£o √© verificada antes da refer√™ncia √† refer√™ncia. <br><br>  Voc√™ pode procurar por outros erros de forma independente, tanto no projeto considerado como no seu.  Para fazer isso, basta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixar</a> e experimentar o analisador PVS-Studio. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Paul Eremeev, Alexander Senichkin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455230/">https://habr.com/ru/post/pt455230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455216/index.html">Medidor de velocidade Doppler</a></li>
<li><a href="../pt455218/index.html">Abordagem Ecossist√™mica √† Tecnologia Empresarial</a></li>
<li><a href="../pt455224/index.html">M√∫sica Finger: Tocar qualquer coisa com SpecDrums de Sphero</a></li>
<li><a href="../pt455226/index.html">Por que aplicar um linguista aplicado?</a></li>
<li><a href="../pt455228/index.html">Aquele que ressuscitou Duke Nukem: Entrevista com Randy Pitchford, Assistente de caixa de velocidades</a></li>
<li><a href="../pt455234/index.html">Tipos de refer√™ncia anul√°veis ‚Äã‚Äãem C # 8.0 e an√°lise est√°tica</a></li>
<li><a href="../pt455236/index.html">Comodo revoga certificados sem motivo</a></li>
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relat√≥rio de erros</a></li>
<li><a href="../pt455244/index.html">Hist√≥ria em quadrinhos "A soldagem √© f√°cil" na vers√£o atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscri√ß√µes para o Customer Experience Day em S√£o Petersburgo est√£o abertas em 20 de junho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>