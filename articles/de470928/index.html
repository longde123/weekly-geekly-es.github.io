<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦‍👦 💢 🏴‍☠️ Best Practices für die Ausführung von Buildah in einem Container 🔗 👨🏽‍⚖️ ↔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist das Schöne daran, die Laufzeit von Containern in separate Instrumentenkomponenten zu unterteilen? Insbesondere die Tatsache, dass diese Tools ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Best Practices für die Ausführung von Buildah in einem Container</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/470928/">  Was ist das Schöne daran, die Laufzeit von Containern in separate Instrumentenkomponenten zu unterteilen?  Insbesondere die Tatsache, dass diese Tools kombiniert werden können, um sich gegenseitig zu schützen. <br><br><img src="https://habrastorage.org/webt/mj/b5/x9/mjb5x9ahbaz_rlyie6anq31p2jm.png" width="100%"><br><br>  Viele Menschen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fühlen</a> sich von der Idee angezogen, Container- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCIs</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> oder einem ähnlichen System zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> .  Angenommen, wir haben eine CI / CD, die ständig Bilder sammelt, dann wäre etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat OpenShift</a> / Kubernetes sehr nützlich für den Lastausgleich während der Montage.  Bis vor kurzem gaben die meisten Benutzer den Containern einfach Zugriff auf den Docker-Socket und durften den Docker-Build-Befehl ausführen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben vor einigen Jahren gezeigt,</a> dass dies sehr unsicher ist. Es ist sogar noch schlimmer, als ein passwortloses root oder sudo anzugeben. <br><a name="habracut"></a><br>  Daher versuchen die Leute ständig, Buildah in einem Container auszuführen.  Kurz gesagt, wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> dafür erstellt, wie es unserer Meinung nach am besten ist, Buildah im Container auszuführen und die entsprechenden Bilder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quay.io/buildah zu platzieren</a> .  Fangen wir an ... <br><br><h3>  Anpassung </h3><br>  Diese Bilder werden aus Docker-Dateien kompiliert, die sich im Buildah-Repository im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">buildahimage befinden</a> . <br>  Hier sehen wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabile Version von Dockerfile an</a> . <br><br><pre><code class="plaintext hljs"># stable/Dockerfile # # Build a Buildah container image from the latest # stable version of Buildah on the Fedoras Updates System. # https://bodhi.fedoraproject.org/updates/?search=buildah # This image can be used to create a secured container # that runs safely with privileges within the container. # FROM fedora:latest # Don't include container-selinux and remove # directories used by dnf that are just taking # up space. RUN yum -y install buildah fuse-overlayfs --exclude container-selinux; rm -rf /var/cache /var/log/dnf* /var/log/yum.* # Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf</code> </pre> <br>  Anstelle von OverlayFS, das auf der Linux-Kernel-Ebene des Hosts implementiert ist, verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fuse-Overlay-</a> Programm im Container, da OverlayFS derzeit nur bereitgestellt werden kann, wenn ihm von Linux-Funktionen SYS_ADMIN-Berechtigungen gewährt werden.  Und wir möchten unsere Buildah-Container ohne Root-Rechte ausführen.  Fuse-Overlay ist ziemlich schnell und leistungsfähiger als der VFS-Speichertreiber.  Beachten Sie, dass Sie beim Starten eines Buildah-Containers mit Fuse das Gerät / dev / fuse angeben müssen. <br><br><pre> <code class="plaintext hljs">podman run --device /dev/fuse quay.io/buildahctr ... RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  Als nächstes erstellen wir ein Verzeichnis für zusätzlichen Speicher.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container / Speicher</a> unterstützt das Konzept, zusätzliche schreibgeschützte Bildspeicher anzuschließen.  Sie können beispielsweise den Overlay-Speicherbereich auf einem Computer konfigurieren und dann NFS verwenden, um diesen Speicher auf einem anderen Computer bereitzustellen und Bilder von diesem zu verwenden, ohne ihn per Pull herunterzuladen.  Wir benötigen diesen Speicher, um eine Art Image-Speicher vom Host als Volume verbinden und im Container verwenden zu können. <br><br><pre> <code class="plaintext hljs"># Set up environment variables to note that this is # not starting with user namespace and default to # isolate the filesystem with chroot. ENV _BUILDAH_STARTED_IN_USERNS="" BUILDAH_ISOLATION=chroot</code> </pre><br>  Unter Verwendung der Umgebungsvariablen BUILDAH_ISOLATION sagen wir schließlich, dass der Buildah-Container standardmäßig mit der Chroot-Isolierung beginnen sollte.  Eine zusätzliche Isolierung ist hier nicht erforderlich, da wir bereits im Container arbeiten.  Damit Buildah eigene Container mit Trennung von Namensräumen erstellen kann, ist das Privileg SYS_ADMIN erforderlich. Dazu müssen die SELinux- und SECCOMP-Regeln für den Container geschwächt werden, was unserer Installation zum Erstellen aus einem sicheren Container widerspricht. <br><br><h3>  Führen Sie Buildah im Container aus </h3><br>  Mit dem oben beschriebenen Buildah-Container-Image-Schema können Sie die Art und Weise, wie Sie solche Container ausführen, flexibel variieren. <br><br><h4>  Geschwindigkeit vs. Sicherheit </h4><br>  Computersicherheit ist immer ein Kompromiss zwischen der Geschwindigkeit des Prozesses und dem Umfang des Schutzes.  Diese Aussage gilt auch für das Zusammenstellen von Containern. Im Folgenden werden Optionen für einen solchen Kompromiss betrachtet. <br><br>  Das oben beschriebene Container-Image behält sein Repository in / var / lib / container.  Daher müssen wir den Inhalt in diesem Ordner bereitstellen, und die Art und Weise, wie wir dies tun, wirkt sich stark auf die Assemblierungsgeschwindigkeit von Container-Images aus. <br><br>  Betrachten wir drei Optionen. <br><br>  <b>Option 1.</b> Wenn maximale Sicherheit erforderlich ist, können Sie für jeden Container einen eigenen Ordner für Container / Image erstellen und über Volume-Mount mit dem Container verbinden.  Legen Sie außerdem das Kontextverzeichnis im Container selbst im Ordner / build ab: <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers1 # podman run -v ./build:/build:z -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable\ buildah -t image1 bud /build # podman run -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable buildah push \ image1 registry.company.com/myuser # rm -rf /var/lib/containers1</code> </pre><br>  <i>Sicherheit</i>  Buildah, das in einem solchen Container ausgeführt wird, bietet maximale Sicherheit: Es werden keine Root-Berechtigungen mit Funktionstools zugewiesen, und alle SECOMP- und SELinux-Einschränkungen gelten für ihn. Ein solcher Container kann sogar mit Isolation des Benutzernamensraums ausgeführt werden, wobei eine Option wie --uidmap 0: 100000: 10000 hinzugefügt wird . <br><br>  <i>Leistung.</i>  Die Leistung hier ist jedoch minimal, da alle Bilder aus Containerregistern jedes Mal auf den Host kopiert werden und das Caching nicht mit dem Wort "no way" funktioniert.  Nach Abschluss seiner Arbeit sollte der Buildah-Container das Image an die Registrierung senden und den Inhalt auf dem Host zerstören.  Wenn das Container-Image das nächste Mal erfasst wird, muss es erneut aus der Registrierung heruntergeladen werden, da zu diesem Zeitpunkt nichts mehr auf dem Host verbleibt. <br><br>  <b>Option 2.</b> Wenn Sie Leistung auf Docker-Ebene benötigen, können Sie den Container / Speicher des Hosts direkt in den Container einbinden. <br><br><pre> <code class="plaintext hljs"># podman run -v ./build:/build:z -v /var/lib/containers:/var/lib/containers --security-opt label:disabled quay.io/buildah/stable buildah -t image2 bud /build # podman run -v /var/lib/containers:/var/lib/containers --security-opt label:disabled \ quay.io/buildah/stable buildah push image2 registry.company.com/myuser</code> </pre><br>  <i>Sicherheit</i>  Dies ist die am wenigsten sichere Methode zum Erstellen von Containern, da der Container hier den Speicher auf dem Host ändern darf und möglicherweise ein schädliches Image in Podman oder CRI-O übertragen kann.  Darüber hinaus müssen Sie die SELinux-Trennung deaktivieren, damit die Prozesse im Buildah-Container mit dem Speicher auf dem Host interagieren können.  Bitte beachten Sie, dass diese Option immer noch besser ist als der Docker-Socket, da der Container durch die verbleibenden Sicherheitsfunktionen blockiert wird und nicht einfach einen Container auf dem Host aufnehmen und ausführen kann. <br><br>  <i>Leistung.</i>  Hier ist es maximal, da das Caching voll involviert ist.  Wenn Podman oder CRI-O es bereits geschafft haben, das gewünschte Image auf den Host herunterzuladen, muss der Buildah-Prozess im Container es nicht erneut herunterladen, und nachfolgende Assemblys, die auf diesem Image basieren, können auch das erforderliche Image aus dem Cache entnehmen. <br><br>  <b>Option 3.</b> Im Wesentlichen besteht diese Methode darin, mehrere Bilder in einem Projekt mit einem freigegebenen Ordner für Containerbilder zu kombinieren. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/project3 # podman run --security-opt label:level=s0:C100, C200 -v ./build:/build:z \ -v /var/lib/project3:/var/lib/containers:Z quay.io/buildah/stable buildah -t image3 bud /build # podman run --security-opt label:level=s0:C100, C200 \ -v /var/lib/project3:/var/lib/containers quay.io/buildah/stable buildah push image3 \ registry.company.com/myuser</code> </pre><br>  In diesem Beispiel wird der Projektordner (/ var / lib / project3) zwischen den Starts nicht gelöscht, sodass alle nachfolgenden Builds innerhalb des Projekts das Caching nutzen. <br><br>  <i>Sicherheit</i>  Etwas zwischen Option 1 und 2. Einerseits haben Container keinen Zugriff auf Inhalte auf dem Host und können dementsprechend nichts Schlechtes in den Podman / CRI-O-Image-Speicher schieben.  Andererseits kann ein Container im Rahmen seines Projekts die Montage anderer Container stören. <br><br>  <i>Leistung.</i>  Hier ist es schlimmer als bei Verwendung eines gemeinsam genutzten Caches auf Hostebene, da Sie keine Bilder verwenden können, die bereits zuvor mit Podman / CRI-O heruntergeladen wurden.  Nachdem Buildah das Image heruntergeladen hat, kann dieses Image jedoch in allen nachfolgenden Builds innerhalb des Projekts verwendet werden. <br><br><h4>  Zusätzlicher Speicher </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container / Speicher</a> haben so coole Dinge wie zusätzliche Speicher, dank derer Container-Engines beim Starten und Erstellen von Containern externe Bildspeicher im schreibgeschützten Overlay-Modus verwenden können.  Tatsächlich können Sie der Datei storage.conf einen oder mehrere schreibgeschützte Speicher hinzufügen, sodass die Container-Engine beim Starten des Containers nach dem gewünschten Image sucht.  Darüber hinaus lädt er das Bild nur dann aus der Registrierung herunter, wenn er es in keinem dieser Repositories findet.  Die Container-Engine kann nur in einen beschreibbaren Speicher schreiben ... <br><br>  Wenn Sie nach oben scrollen und die Docker-Datei sehen, mit der wir das Image quay.io/buildah/stable erstellen, gibt es folgende Zeilen: <br><br><pre> <code class="plaintext hljs"># Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  In der ersten Zeile ändern wir /etc/containers/storage.conf im Container-Image und weisen den Speichertreiber an, "zusätzliche Bildspeicher" im Ordner / var / lib / shared zu verwenden.  Erstellen Sie in der nächsten Zeile einen freigegebenen Ordner und fügen Sie einige Sperrdateien hinzu, damit kein Missbrauch durch Container / Speicher erfolgt.  Grundsätzlich erstellen wir nur einen leeren Container-Image-Speicher. <br><br>  Wenn Sie Container / Speicher über diesem Ordner bereitstellen, kann Buildah Images verwenden. <br><br>  Zurück zu Option 2, die oben erläutert wurde, wenn ein Buildah-Container auf Hosts lesen und in Container / Speicher schreiben kann und dementsprechend aufgrund des Image-Caching auf Podman / CRI-O-Ebene maximale Leistung aufweist, jedoch ein Minimum an Sicherheit bietet, da er direkt schreiben kann im Lager.  Und jetzt werden wir hier zusätzlichen Speicher befestigen und das Beste aus zwei Welten herausholen. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers4 # podman run -v ./build:/build:z -v /var/lib/containers/storage:/var/lib/shared:ro -v \ /var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable \ buildah -t image4 bud /build # podman run -v /var/lib/containers/storage:/var/lib/shared:ro \ -v &gt;/var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable buildah push image4 \ registry.company.com/myuser # rm -rf /var/lib/continers4</code> </pre><br>  Beachten Sie, dass der Host / var / lib / container / storage im schreibgeschützten Modus in / var / lib / shared im Container bereitgestellt wird.  Daher kann Buildah in einem Container alle Bilder verwenden, die zuvor mit Podman / CRI-O heruntergeladen wurden (hi, speed), aber nur in sein eigenes Repository schreiben (hi, security).  Beachten Sie auch, dass dies erfolgt, ohne die SELinux-Trennung für den Container zu deaktivieren. <br><br><h4>  Wichtige Nuance </h4><br>  In keinem Fall sollten Sie Bilder aus dem zugrunde liegenden Speicher entfernen.  Andernfalls kann der Buildah-Container herausfliegen. <br><br><h4>  Und das sind nicht alle Vorteile. </h4><br>  Zusätzliche Speicherfunktionen sind nicht auf das obige Szenario beschränkt.  Sie können beispielsweise alle Container-Images in einem gemeinsam genutzten Netzwerkspeicher platzieren und Zugriff auf alle Buildah-Container gewähren.  Angenommen, wir haben Hunderte von Images, die unser CI / CD-System regelmäßig zum Erstellen von Container-Images verwendet.  Wir konzentrieren alle diese Images auf einen einzelnen Speicherhost und öffnen dann mithilfe der bevorzugten Netzwerkspeicher-Tools (NFS, Gluster, Ceph, ISCSI, S3 ...) gemeinsam genutzten Speicher für alle Buildah- oder Kubernetes-Knoten. <br><br>  Jetzt reicht es aus, diesen Netzwerkspeicher in den Buildah-Container unter / var / lib / shared zu mounten, und das ist alles - Buildah-Container müssen keine Bilder mehr per Pull herunterladen.  Damit werfen wir die Vorbevölkerungsphase aus und sind sofort bereit, die Container auszurollen. <br><br>  Und natürlich kann dies innerhalb des vorhandenen Kubernetes-Systems oder der Containerinfrastruktur verwendet werden, um Container überall zu starten und auszuführen, ohne Bilder per Pull herunterzuladen.  Darüber hinaus kann die Containerregistrierung, die eine Push-Anforderung zum Laden eines aktualisierten Images empfängt, dieses Image automatisch an einen gemeinsam genutzten Netzwerkspeicher senden, wo es sofort allen Knoten zur Verfügung steht. <br><br>  Die Größe von Container-Images kann manchmal viele Gigabyte erreichen.  Die Funktionalität zusätzlicher Speicher ermöglicht es Ihnen, auf das Klonen solcher Bilder durch Knoten zu verzichten, und macht das Starten von Containern fast sofort. <br><br>  Darüber hinaus arbeiten wir derzeit an einer neuen Funktion zur Bereitstellung von Overlay-Volumes, die die Montage von Containern noch schneller macht. <br><br><h3>  Fazit </h3><br>  Das Ausführen einer Buildah in einem Container in Kubernetes / CRI-O, Podman oder sogar Docker ist real und einfacher und viel sicherer als die Verwendung von docker.socket.  Wir haben die Flexibilität bei der Arbeit mit Bildern erheblich verbessert. Jetzt können Sie sie auf verschiedene Arten starten, um ein optimales Gleichgewicht zwischen Sicherheit und Leistung zu erzielen. <br><br>  Die Funktionalität zusätzlicher Speicher ermöglicht es Ihnen, das Herunterladen von Bildern auf Knoten zu beschleunigen oder sogar vollständig zu eliminieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470928/">https://habr.com/ru/post/de470928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470918/index.html">F # 9: Geben Sie Option ein</a></li>
<li><a href="../de470920/index.html">5+ Möglichkeiten, eine Verbindung zu einer DataLine-Cloud herzustellen</a></li>
<li><a href="../de470922/index.html">Ankündigung von mitap ThinkJava # 10 in Kharkov</a></li>
<li><a href="../de470924/index.html">Warum für das neue Projekt habe ich Robot Framework genommen</a></li>
<li><a href="../de470926/index.html">„Wir vertrauen uns. Zum Beispiel haben wir überhaupt keine Gehälter “- ein großes Interview mit Tim Lister, Autor von Peopleware</a></li>
<li><a href="../de470930/index.html">Gamification des Produkts. Verlauf Ratatype</a></li>
<li><a href="../de470934/index.html">Heilt vor der Hochzeit: Zellproliferation und Regenerationsfähigkeit von Quallen</a></li>
<li><a href="../de470938/index.html">So öffnen Sie einen Link in Python. Arbeiten mit WebBrowser und Lösen eines Problems mit Internet Explorer</a></li>
<li><a href="../de470940/index.html">MSK VUE.JS Meetup # 3 bei Mail.ru Group: Materialien von Mitap</a></li>
<li><a href="../de470942/index.html">Vom Anfänger bis zur Stilikone: Wie wir in 2GIS Auszeichnungen vergeben haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>