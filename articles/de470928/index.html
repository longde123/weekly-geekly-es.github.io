<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüë¶‚Äçüë¶ üí¢ üè¥‚Äç‚ò†Ô∏è Best Practices f√ºr die Ausf√ºhrung von Buildah in einem Container üîó üë®üèΩ‚Äç‚öñÔ∏è ‚ÜîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist das Sch√∂ne daran, die Laufzeit von Containern in separate Instrumentenkomponenten zu unterteilen? Insbesondere die Tatsache, dass diese Tools ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Best Practices f√ºr die Ausf√ºhrung von Buildah in einem Container</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/470928/">  Was ist das Sch√∂ne daran, die Laufzeit von Containern in separate Instrumentenkomponenten zu unterteilen?  Insbesondere die Tatsache, dass diese Tools kombiniert werden k√∂nnen, um sich gegenseitig zu sch√ºtzen. <br><br><img src="https://habrastorage.org/webt/mj/b5/x9/mjb5x9ahbaz_rlyie6anq31p2jm.png" width="100%"><br><br>  Viele Menschen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºhlen</a> sich von der Idee angezogen, Container- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCIs</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> oder einem √§hnlichen System zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> .  Angenommen, wir haben eine CI / CD, die st√§ndig Bilder sammelt, dann w√§re etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat OpenShift</a> / Kubernetes sehr n√ºtzlich f√ºr den Lastausgleich w√§hrend der Montage.  Bis vor kurzem gaben die meisten Benutzer den Containern einfach Zugriff auf den Docker-Socket und durften den Docker-Build-Befehl ausf√ºhren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben vor einigen Jahren gezeigt,</a> dass dies sehr unsicher ist. Es ist sogar noch schlimmer, als ein passwortloses root oder sudo anzugeben. <br><a name="habracut"></a><br>  Daher versuchen die Leute st√§ndig, Buildah in einem Container auszuf√ºhren.  Kurz gesagt, wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> daf√ºr erstellt, wie es unserer Meinung nach am besten ist, Buildah im Container auszuf√ºhren und die entsprechenden Bilder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quay.io/buildah zu platzieren</a> .  Fangen wir an ... <br><br><h3>  Anpassung </h3><br>  Diese Bilder werden aus Docker-Dateien kompiliert, die sich im Buildah-Repository im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">buildahimage befinden</a> . <br>  Hier sehen wir uns die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabile Version von Dockerfile an</a> . <br><br><pre><code class="plaintext hljs"># stable/Dockerfile # # Build a Buildah container image from the latest # stable version of Buildah on the Fedoras Updates System. # https://bodhi.fedoraproject.org/updates/?search=buildah # This image can be used to create a secured container # that runs safely with privileges within the container. # FROM fedora:latest # Don't include container-selinux and remove # directories used by dnf that are just taking # up space. RUN yum -y install buildah fuse-overlayfs --exclude container-selinux; rm -rf /var/cache /var/log/dnf* /var/log/yum.* # Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf</code> </pre> <br>  Anstelle von OverlayFS, das auf der Linux-Kernel-Ebene des Hosts implementiert ist, verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fuse-Overlay-</a> Programm im Container, da OverlayFS derzeit nur bereitgestellt werden kann, wenn ihm von Linux-Funktionen SYS_ADMIN-Berechtigungen gew√§hrt werden.  Und wir m√∂chten unsere Buildah-Container ohne Root-Rechte ausf√ºhren.  Fuse-Overlay ist ziemlich schnell und leistungsf√§higer als der VFS-Speichertreiber.  Beachten Sie, dass Sie beim Starten eines Buildah-Containers mit Fuse das Ger√§t / dev / fuse angeben m√ºssen. <br><br><pre> <code class="plaintext hljs">podman run --device /dev/fuse quay.io/buildahctr ... RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  Als n√§chstes erstellen wir ein Verzeichnis f√ºr zus√§tzlichen Speicher.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container / Speicher</a> unterst√ºtzt das Konzept, zus√§tzliche schreibgesch√ºtzte Bildspeicher anzuschlie√üen.  Sie k√∂nnen beispielsweise den Overlay-Speicherbereich auf einem Computer konfigurieren und dann NFS verwenden, um diesen Speicher auf einem anderen Computer bereitzustellen und Bilder von diesem zu verwenden, ohne ihn per Pull herunterzuladen.  Wir ben√∂tigen diesen Speicher, um eine Art Image-Speicher vom Host als Volume verbinden und im Container verwenden zu k√∂nnen. <br><br><pre> <code class="plaintext hljs"># Set up environment variables to note that this is # not starting with user namespace and default to # isolate the filesystem with chroot. ENV _BUILDAH_STARTED_IN_USERNS="" BUILDAH_ISOLATION=chroot</code> </pre><br>  Unter Verwendung der Umgebungsvariablen BUILDAH_ISOLATION sagen wir schlie√ülich, dass der Buildah-Container standardm√§√üig mit der Chroot-Isolierung beginnen sollte.  Eine zus√§tzliche Isolierung ist hier nicht erforderlich, da wir bereits im Container arbeiten.  Damit Buildah eigene Container mit Trennung von Namensr√§umen erstellen kann, ist das Privileg SYS_ADMIN erforderlich. Dazu m√ºssen die SELinux- und SECCOMP-Regeln f√ºr den Container geschw√§cht werden, was unserer Installation zum Erstellen aus einem sicheren Container widerspricht. <br><br><h3>  F√ºhren Sie Buildah im Container aus </h3><br>  Mit dem oben beschriebenen Buildah-Container-Image-Schema k√∂nnen Sie die Art und Weise, wie Sie solche Container ausf√ºhren, flexibel variieren. <br><br><h4>  Geschwindigkeit vs. Sicherheit </h4><br>  Computersicherheit ist immer ein Kompromiss zwischen der Geschwindigkeit des Prozesses und dem Umfang des Schutzes.  Diese Aussage gilt auch f√ºr das Zusammenstellen von Containern. Im Folgenden werden Optionen f√ºr einen solchen Kompromiss betrachtet. <br><br>  Das oben beschriebene Container-Image beh√§lt sein Repository in / var / lib / container.  Daher m√ºssen wir den Inhalt in diesem Ordner bereitstellen, und die Art und Weise, wie wir dies tun, wirkt sich stark auf die Assemblierungsgeschwindigkeit von Container-Images aus. <br><br>  Betrachten wir drei Optionen. <br><br>  <b>Option 1.</b> Wenn maximale Sicherheit erforderlich ist, k√∂nnen Sie f√ºr jeden Container einen eigenen Ordner f√ºr Container / Image erstellen und √ºber Volume-Mount mit dem Container verbinden.  Legen Sie au√üerdem das Kontextverzeichnis im Container selbst im Ordner / build ab: <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers1 # podman run -v ./build:/build:z -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable\ buildah -t image1 bud /build # podman run -v /var/lib/containers1:/var/lib/containers:Z quay.io/buildah/stable buildah push \ image1 registry.company.com/myuser # rm -rf /var/lib/containers1</code> </pre><br>  <i>Sicherheit</i>  Buildah, das in einem solchen Container ausgef√ºhrt wird, bietet maximale Sicherheit: Es werden keine Root-Berechtigungen mit Funktionstools zugewiesen, und alle SECOMP- und SELinux-Einschr√§nkungen gelten f√ºr ihn. Ein solcher Container kann sogar mit Isolation des Benutzernamensraums ausgef√ºhrt werden, wobei eine Option wie --uidmap 0: 100000: 10000 hinzugef√ºgt wird . <br><br>  <i>Leistung.</i>  Die Leistung hier ist jedoch minimal, da alle Bilder aus Containerregistern jedes Mal auf den Host kopiert werden und das Caching nicht mit dem Wort "no way" funktioniert.  Nach Abschluss seiner Arbeit sollte der Buildah-Container das Image an die Registrierung senden und den Inhalt auf dem Host zerst√∂ren.  Wenn das Container-Image das n√§chste Mal erfasst wird, muss es erneut aus der Registrierung heruntergeladen werden, da zu diesem Zeitpunkt nichts mehr auf dem Host verbleibt. <br><br>  <b>Option 2.</b> Wenn Sie Leistung auf Docker-Ebene ben√∂tigen, k√∂nnen Sie den Container / Speicher des Hosts direkt in den Container einbinden. <br><br><pre> <code class="plaintext hljs"># podman run -v ./build:/build:z -v /var/lib/containers:/var/lib/containers --security-opt label:disabled quay.io/buildah/stable buildah -t image2 bud /build # podman run -v /var/lib/containers:/var/lib/containers --security-opt label:disabled \ quay.io/buildah/stable buildah push image2 registry.company.com/myuser</code> </pre><br>  <i>Sicherheit</i>  Dies ist die am wenigsten sichere Methode zum Erstellen von Containern, da der Container hier den Speicher auf dem Host √§ndern darf und m√∂glicherweise ein sch√§dliches Image in Podman oder CRI-O √ºbertragen kann.  Dar√ºber hinaus m√ºssen Sie die SELinux-Trennung deaktivieren, damit die Prozesse im Buildah-Container mit dem Speicher auf dem Host interagieren k√∂nnen.  Bitte beachten Sie, dass diese Option immer noch besser ist als der Docker-Socket, da der Container durch die verbleibenden Sicherheitsfunktionen blockiert wird und nicht einfach einen Container auf dem Host aufnehmen und ausf√ºhren kann. <br><br>  <i>Leistung.</i>  Hier ist es maximal, da das Caching voll involviert ist.  Wenn Podman oder CRI-O es bereits geschafft haben, das gew√ºnschte Image auf den Host herunterzuladen, muss der Buildah-Prozess im Container es nicht erneut herunterladen, und nachfolgende Assemblys, die auf diesem Image basieren, k√∂nnen auch das erforderliche Image aus dem Cache entnehmen. <br><br>  <b>Option 3.</b> Im Wesentlichen besteht diese Methode darin, mehrere Bilder in einem Projekt mit einem freigegebenen Ordner f√ºr Containerbilder zu kombinieren. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/project3 # podman run --security-opt label:level=s0:C100, C200 -v ./build:/build:z \ -v /var/lib/project3:/var/lib/containers:Z quay.io/buildah/stable buildah -t image3 bud /build # podman run --security-opt label:level=s0:C100, C200 \ -v /var/lib/project3:/var/lib/containers quay.io/buildah/stable buildah push image3 \ registry.company.com/myuser</code> </pre><br>  In diesem Beispiel wird der Projektordner (/ var / lib / project3) zwischen den Starts nicht gel√∂scht, sodass alle nachfolgenden Builds innerhalb des Projekts das Caching nutzen. <br><br>  <i>Sicherheit</i>  Etwas zwischen Option 1 und 2. Einerseits haben Container keinen Zugriff auf Inhalte auf dem Host und k√∂nnen dementsprechend nichts Schlechtes in den Podman / CRI-O-Image-Speicher schieben.  Andererseits kann ein Container im Rahmen seines Projekts die Montage anderer Container st√∂ren. <br><br>  <i>Leistung.</i>  Hier ist es schlimmer als bei Verwendung eines gemeinsam genutzten Caches auf Hostebene, da Sie keine Bilder verwenden k√∂nnen, die bereits zuvor mit Podman / CRI-O heruntergeladen wurden.  Nachdem Buildah das Image heruntergeladen hat, kann dieses Image jedoch in allen nachfolgenden Builds innerhalb des Projekts verwendet werden. <br><br><h4>  Zus√§tzlicher Speicher </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container / Speicher</a> haben so coole Dinge wie zus√§tzliche Speicher, dank derer Container-Engines beim Starten und Erstellen von Containern externe Bildspeicher im schreibgesch√ºtzten Overlay-Modus verwenden k√∂nnen.  Tats√§chlich k√∂nnen Sie der Datei storage.conf einen oder mehrere schreibgesch√ºtzte Speicher hinzuf√ºgen, sodass die Container-Engine beim Starten des Containers nach dem gew√ºnschten Image sucht.  Dar√ºber hinaus l√§dt er das Bild nur dann aus der Registrierung herunter, wenn er es in keinem dieser Repositories findet.  Die Container-Engine kann nur in einen beschreibbaren Speicher schreiben ... <br><br>  Wenn Sie nach oben scrollen und die Docker-Datei sehen, mit der wir das Image quay.io/buildah/stable erstellen, gibt es folgende Zeilen: <br><br><pre> <code class="plaintext hljs"># Adjust storage.conf to enable Fuse storage. RUN sed -i -e 's|^#mount_program|mount_program|g' -e '/additionalimage.*/a "/var/lib/shared",' /etc/containers/storage.conf RUN mkdir -p /var/lib/shared/overlay-images /var/lib/shared/overlay-layers; touch /var/lib/shared/overlay-images/images.lock; touch /var/lib/shared/overlay-layers/layers.lock</code> </pre><br>  In der ersten Zeile √§ndern wir /etc/containers/storage.conf im Container-Image und weisen den Speichertreiber an, "zus√§tzliche Bildspeicher" im Ordner / var / lib / shared zu verwenden.  Erstellen Sie in der n√§chsten Zeile einen freigegebenen Ordner und f√ºgen Sie einige Sperrdateien hinzu, damit kein Missbrauch durch Container / Speicher erfolgt.  Grunds√§tzlich erstellen wir nur einen leeren Container-Image-Speicher. <br><br>  Wenn Sie Container / Speicher √ºber diesem Ordner bereitstellen, kann Buildah Images verwenden. <br><br>  Zur√ºck zu Option 2, die oben erl√§utert wurde, wenn ein Buildah-Container auf Hosts lesen und in Container / Speicher schreiben kann und dementsprechend aufgrund des Image-Caching auf Podman / CRI-O-Ebene maximale Leistung aufweist, jedoch ein Minimum an Sicherheit bietet, da er direkt schreiben kann im Lager.  Und jetzt werden wir hier zus√§tzlichen Speicher befestigen und das Beste aus zwei Welten herausholen. <br><br><pre> <code class="plaintext hljs"># mkdir /var/lib/containers4 # podman run -v ./build:/build:z -v /var/lib/containers/storage:/var/lib/shared:ro -v \ /var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable \ buildah -t image4 bud /build # podman run -v /var/lib/containers/storage:/var/lib/shared:ro \ -v &gt;/var/lib/containers4:/var/lib/containers:Z quay.io/buildah/stable buildah push image4 \ registry.company.com/myuser # rm -rf /var/lib/continers4</code> </pre><br>  Beachten Sie, dass der Host / var / lib / container / storage im schreibgesch√ºtzten Modus in / var / lib / shared im Container bereitgestellt wird.  Daher kann Buildah in einem Container alle Bilder verwenden, die zuvor mit Podman / CRI-O heruntergeladen wurden (hi, speed), aber nur in sein eigenes Repository schreiben (hi, security).  Beachten Sie auch, dass dies erfolgt, ohne die SELinux-Trennung f√ºr den Container zu deaktivieren. <br><br><h4>  Wichtige Nuance </h4><br>  In keinem Fall sollten Sie Bilder aus dem zugrunde liegenden Speicher entfernen.  Andernfalls kann der Buildah-Container herausfliegen. <br><br><h4>  Und das sind nicht alle Vorteile. </h4><br>  Zus√§tzliche Speicherfunktionen sind nicht auf das obige Szenario beschr√§nkt.  Sie k√∂nnen beispielsweise alle Container-Images in einem gemeinsam genutzten Netzwerkspeicher platzieren und Zugriff auf alle Buildah-Container gew√§hren.  Angenommen, wir haben Hunderte von Images, die unser CI / CD-System regelm√§√üig zum Erstellen von Container-Images verwendet.  Wir konzentrieren alle diese Images auf einen einzelnen Speicherhost und √∂ffnen dann mithilfe der bevorzugten Netzwerkspeicher-Tools (NFS, Gluster, Ceph, ISCSI, S3 ...) gemeinsam genutzten Speicher f√ºr alle Buildah- oder Kubernetes-Knoten. <br><br>  Jetzt reicht es aus, diesen Netzwerkspeicher in den Buildah-Container unter / var / lib / shared zu mounten, und das ist alles - Buildah-Container m√ºssen keine Bilder mehr per Pull herunterladen.  Damit werfen wir die Vorbev√∂lkerungsphase aus und sind sofort bereit, die Container auszurollen. <br><br>  Und nat√ºrlich kann dies innerhalb des vorhandenen Kubernetes-Systems oder der Containerinfrastruktur verwendet werden, um Container √ºberall zu starten und auszuf√ºhren, ohne Bilder per Pull herunterzuladen.  Dar√ºber hinaus kann die Containerregistrierung, die eine Push-Anforderung zum Laden eines aktualisierten Images empf√§ngt, dieses Image automatisch an einen gemeinsam genutzten Netzwerkspeicher senden, wo es sofort allen Knoten zur Verf√ºgung steht. <br><br>  Die Gr√∂√üe von Container-Images kann manchmal viele Gigabyte erreichen.  Die Funktionalit√§t zus√§tzlicher Speicher erm√∂glicht es Ihnen, auf das Klonen solcher Bilder durch Knoten zu verzichten, und macht das Starten von Containern fast sofort. <br><br>  Dar√ºber hinaus arbeiten wir derzeit an einer neuen Funktion zur Bereitstellung von Overlay-Volumes, die die Montage von Containern noch schneller macht. <br><br><h3>  Fazit </h3><br>  Das Ausf√ºhren einer Buildah in einem Container in Kubernetes / CRI-O, Podman oder sogar Docker ist real und einfacher und viel sicherer als die Verwendung von docker.socket.  Wir haben die Flexibilit√§t bei der Arbeit mit Bildern erheblich verbessert. Jetzt k√∂nnen Sie sie auf verschiedene Arten starten, um ein optimales Gleichgewicht zwischen Sicherheit und Leistung zu erzielen. <br><br>  Die Funktionalit√§t zus√§tzlicher Speicher erm√∂glicht es Ihnen, das Herunterladen von Bildern auf Knoten zu beschleunigen oder sogar vollst√§ndig zu eliminieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470928/">https://habr.com/ru/post/de470928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470918/index.html">F # 9: Geben Sie Option ein</a></li>
<li><a href="../de470920/index.html">5+ M√∂glichkeiten, eine Verbindung zu einer DataLine-Cloud herzustellen</a></li>
<li><a href="../de470922/index.html">Ank√ºndigung von mitap ThinkJava # 10 in Kharkov</a></li>
<li><a href="../de470924/index.html">Warum f√ºr das neue Projekt habe ich Robot Framework genommen</a></li>
<li><a href="../de470926/index.html">‚ÄûWir vertrauen uns. Zum Beispiel haben wir √ºberhaupt keine Geh√§lter ‚Äú- ein gro√ües Interview mit Tim Lister, Autor von Peopleware</a></li>
<li><a href="../de470930/index.html">Gamification des Produkts. Verlauf Ratatype</a></li>
<li><a href="../de470934/index.html">Heilt vor der Hochzeit: Zellproliferation und Regenerationsf√§higkeit von Quallen</a></li>
<li><a href="../de470938/index.html">So √∂ffnen Sie einen Link in Python. Arbeiten mit WebBrowser und L√∂sen eines Problems mit Internet Explorer</a></li>
<li><a href="../de470940/index.html">MSK VUE.JS Meetup # 3 bei Mail.ru Group: Materialien von Mitap</a></li>
<li><a href="../de470942/index.html">Vom Anf√§nger bis zur Stilikone: Wie wir in 2GIS Auszeichnungen vergeben haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>