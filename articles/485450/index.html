<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÑ ü§πüèº üë©üèº‚Äçü§ù‚Äçüë®üèø ¬øQu√© hay de nuevo en SObjectizer-5.7.0 y qu√© espera para este proyecto? ü•Ä üë¥üèæ üññüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SObjectizer es un marco de trabajo de C ++ 17 relativamente peque√±o que le permite utilizar enfoques como Modelo de actor, Publicar-Suscribirse y Comu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© hay de nuevo en SObjectizer-5.7.0 y qu√© espera para este proyecto?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485450/"><p>  <a href="https://github.com/Stiffstream/sobjectizer">SObjectizer</a> es un marco de trabajo de C ++ 17 relativamente peque√±o que le permite utilizar enfoques como Modelo de actor, Publicar-Suscribirse y Comunicar procesos secuenciales (CSP) en programas de C ++.  Lo que simplifica enormemente el desarrollo de aplicaciones complejas multiproceso en C ++.  Si el lector oye acerca de SObjectizer por primera vez, puede impresionarlo en esta <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/What%2520is%2520SObjectizer-5.7%2520%2528at%2520v.5.7.0%2529.pdf/download">presentaci√≥n</a> o en este <a href="https://habr.com/post/304386/">art√≠culo</a> ya bastante antiguo. </p><br><p>  En t√©rminos generales, no hay tantas herramientas abiertas, todav√≠a vivas y en desarrollo similares para C ++.  Uno solo puede recordar <a href="https://www.state-machine.com/qpcpp/">QP / C ++</a> , <a href="http://actor-framework.org/">CAF: C ++ Actor Framework</a> , <a href="https://github.com/jinncrafters/actor-zeta">actor-zeta</a> y el proyecto de <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> muy joven.  Hay una opci√≥n, pero no tan grande. </p><br><p>  Recientemente, <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">otra versi√≥n "principal" de SObjectizer</a> ha estado disponible, donde finalmente ha aparecido algo de lo que se ha hablado durante mucho tiempo, y al que me he acercado varias veces sin √©xito.  Podemos decir que se ha alcanzado un hito.  Esta es tambi√©n una ocasi√≥n para hablar sobre lo que SObjectizer esperar√° despu√©s del lanzamiento de la versi√≥n 5.7.0. </p><br><h1 id="podderzhka-send_case-v-select">  Soporte Send_case en select () </h1><br><p>  Por lo tanto, la innovaci√≥n m√°s importante que apareci√≥ en v.5.7.0 y para la cual la compatibilidad con v.5.6 lanzada el a√±o pasado (y no rompemos la compatibilidad) es el soporte para send_case en la funci√≥n select ().  Lo que hizo que SObjectizer's select () se parezca mucho m√°s a Go select.  Ahora, usando select (), no solo puede leer mensajes de varios canales CSP, sino tambi√©n enviar mensajes salientes a aquellos canales que estaban listos para ser escritos. </p><a name="habracut"></a><br><p>  Pero para revelar este tema, debe comenzar desde lejos. </p><br><h2 id="poyavlenie-elementov-csp-v-sobjectizer-5">  La aparici√≥n de elementos CSP en SObjectizer-5 </h2><br><p>  Los elementos de CSP, a saber, los an√°logos de los canales de CSP, aparecieron en SObjectizer-5 no para marcar la casilla "Soporte de CSP", sino para resolver un problema pr√°ctico. </p><br><p>  La cuesti√≥n era que cuando toda la aplicaci√≥n se basa completamente en SObjectizer, el intercambio de informaci√≥n entre varias entidades (partes) del programa se realiza de la √∫nica manera obvia.  Todo en la aplicaci√≥n se presenta en forma de agentes (actores) y los agentes simplemente se env√≠an mensajes entre s√≠ de manera est√°ndar. </p><br><p>  Pero cuando en la aplicaci√≥n solo se implementa parte de la funcionalidad en SObjectizer ... </p><br><p>  Por ejemplo, una aplicaci√≥n GUI en Qt o wxWidgets, en la que la parte principal del c√≥digo es una GUI, y se necesita un SObjectizer para realizar algunas tareas en segundo plano.  O parte de la aplicaci√≥n se escribe utilizando hilos desnudos y Asio, y los datos le√≠dos por Asio desde la red se env√≠an a los agentes de SObjectizer para su procesamiento. </p><br><p>  Cuando una aplicaci√≥n tiene una parte SObjectizer y una parte no SObjectizer, surge la pregunta: ¬øc√≥mo transferir informaci√≥n desde la parte SObjectizer de la aplicaci√≥n a la parte no SObjectizer? </p><br><p>  La soluci√≥n se encontr√≥ en forma de la llamada  cadenas de mensajes (mchains), es decir  conversaciones  Lo cual, simplemente sucedi√≥, result√≥ ser la esencia de los canales CSP.  La parte SObjectizer de la aplicaci√≥n env√≠a mensajes a mchain de la manera habitual, utilizando la funci√≥n regular send (). </p><br><p>  Para leer mensajes de la parte que no es SObjectizer, puede usar la nueva funci√≥n de recepci√≥n (), para usar la cual no necesitaba crear agentes o sumergirse en cualquier otro comod√≠n de SObjectizer. </p><br><p>  Result√≥ bastante entendible y esquema de trabajo. </p><br><h2 id="nachalo-ispolzovaniya-mchains-ne-po-naznacheniyu">  Mal uso de mchains </h2><br><p>  Adem√°s, el esquema result√≥ ser tan comprensible y funcional que r√°pidamente algunas aplicaciones en SObjectizer comenzaron a escribir sin ning√∫n agente, solo en mchain-ahs.  Es decir  utilizando el enfoque CSP, no el modelo de actor.  Ya hab√≠a art√≠culos al respecto aqu√≠ en Habr√©: <a href="https://habr.com/ru/post/336854/">uno</a> y <a href="https://habr.com/ru/post/358120/">dos</a> . </p><br><p>  Esto condujo a dos consecuencias interesantes. </p><br><p>  Primero, la funci√≥n de recepci√≥n () ha crecido demasiado con funciones avanzadas.  Esto era necesario para que fuera posible hacer una sola llamada para recibir (), cuyo retorno se producir√≠a cuando ya se haya realizado todo el trabajo necesario.  Estos son ejemplos de lo que puede hacer SObjectizer's reciben (): </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//    3 . //  3    mchain ,   . //   receive    3 , //      . receive( from(chain).handle_n( 3 ), handlers... ); //    3 . //       mchain ,    //     200ms. // ..     200ms,    receive,   //      . receive( from(chain).handle_n( 3 ).empty_timeout( milliseconds(200) ), handlers... ); //       . //     ,    //  500ms. receive( from(chain).handle_all().empty_timeout( milliseconds(500) ), handlers... ); //       . //       2s. receive( from(chain).handle_all().total_time( seconds(2) ), handlers... );</span></span></code> </pre> <br><p>  En segundo lugar, pronto qued√≥ claro que, a pesar de que se pueden colocar varios tipos de mensajes en el mchain de SObjectizer, e incluso a pesar de la presencia de una funci√≥n de recepci√≥n avanzada (), a veces es necesario poder trabajar con varios canales a la vez ... </p><br><h2 id="select-no-tolko-dlya-chteniya">  seleccione () pero solo lectura </h2><br><p>  La funci√≥n select () se ha agregado a SObjectizer para leer y procesar mensajes de varias cadenas.  Clear business select () apareci√≥ no solo as√≠, sino bajo la influencia del lenguaje Go.  Pero select () de SObjectizer ten√≠a dos caracter√≠sticas. </p><br><p>  En primer lugar, nuestro select (), como recibir (), estaba orientado a scripts, cuando select () se llama solo una vez y todo el trabajo √∫til se realiza dentro de √©l.  Por ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); <span class="hljs-comment"><span class="hljs-comment">//    3 . //    3    ch1. //  2  ch1    ch2. //    ch1  2  ch2... // //   ,       . // select()      3 , //     . select( from_all().handle_n( 3 ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //    3 . //    ,     200ms. select( from_all().handle_n( 3 ).empty_timeout( milliseconds(200) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //       . //    ,     500ms. select( from_all().handle_all().empty_timeout( milliseconds(500) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) );</span></span></code> </pre> <br><p>  En segundo lugar, select () no admit√≠a el env√≠o de mensajes al canal.  Es decir  fue posible leer mensajes de canales.  Pero para enviar mensajes al canal usando select () - no. </p><br><p>  Ahora incluso es dif√≠cil recordar por qu√© sucedi√≥.  Probablemente porque select () con el soporte de send_case result√≥ ser una tarea dif√≠cil y no se encontraron recursos para resolverlo. </p><br><h3 id="mchain-y-v-sobjectizer-hitree-chem-kanaly-v-go">  mchain's en SObjectizer es m√°s complicado que los canales en Go </h3><br><p>  Inicialmente, select () sin el soporte de send_case no se consideraba un problema.  El hecho es que las cadenas en SObjectizer tienen sus propios detalles que los canales Go no tienen. </p><br><p>  En primer lugar, las m√°quinas SObjectizer se dividen en adimensionales y con una capacidad m√°xima fija.  Por lo tanto, si send () se ejecuta para una mchain adimensional, este send () no se bloquear√° en principio.  Por lo tanto, no tiene sentido usar select () para enviar un mensaje a la mchain adimensional. </p><br><p>  En segundo lugar, para mchains con una capacidad m√°xima fija, cuando se crea, indica inmediatamente lo que sucede cuando intenta escribir un mensaje en mchain completo: </p><br><ul><li>  ¬øDebo esperar la aparici√≥n de espacio libre en mchain?  Y si es necesario, cu√°nto tiempo; </li><li>  si no hay espacio libre, entonces qu√© hacer: eliminar el mensaje m√°s antiguo de mchain, ignorar el nuevo mensaje, lanzar una excepci√≥n o incluso llamar a std :: abort () (este script dif√≠cil es muy solicitado en la pr√°ctica). </li></ul><br><p>  Por lo tanto, un escenario bastante frecuente (hasta donde yo s√©) de usar select en Go para enviar un mensaje que no bloquea estrictamente goroutin estaba inmediatamente disponible en SObjectizer sin chispas y sin select. </p><br><h2 id="v-konce-koncov-polnocennyy-select">  Al final, una selecci√≥n completa () </h2><br><p>  Sin embargo, el tiempo pas√≥, ocasionalmente hubo casos en que la falta de soporte de send_case en select () a√∫n se ve afectada.  Adem√°s, en estos casos, las capacidades integradas de mchains no ayudaron, sino todo lo contrario. </p><br><p>  Por lo tanto, de vez en cuando intent√© abordar el problema de la implementaci√≥n de send_case.  Pero hasta hace poco, nada funcionaba.  Principalmente porque no fue posible idear el dise√±o de este send_case en s√≠.  Es decir  ¬øC√≥mo deber√≠a verse send_case dentro de select ()?  ¬øQu√© debe hacer exactamente si es posible enviar?  En caso de imposibilidad?  ¬øQu√© hacer con la divisi√≥n en cadenas adimensionales y fijas? </p><br><p>  Fue posible encontrar respuestas que me sentaron a estas y otras preguntas solo en diciembre de 2019.  En gran parte debido a las consultas con personas que est√°n familiarizadas con Go y han utilizado las selecciones Go en el trabajo real.  Bueno, tan pronto como la imagen de send_case finalmente tom√≥ forma, la implementaci√≥n lleg√≥ all√≠. </p><br><p>  Entonces ahora puedes escribir as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greeting</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> text_; }; select(from_all().handle_n(<span class="hljs-number"><span class="hljs-number">1</span></span>), send_case(ch, <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;Greeting&gt;::make(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>), []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello sent!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }));</code> </pre> <br><p>  Lo importante es que send_case en select () ignora la respuesta de sobrecarga que se configur√≥ para el mchain objetivo.  Entonces, en el ejemplo anterior, ch podr√≠a crearse con la reacci√≥n abort_app al intentar enviar un mensaje al canal completo.  Y si intenta llamar a simple send () para escribir en ch, se puede llamar a std :: abort ().  Pero en el caso de select (), y esto no suceder√°, select () esperar√° hasta que aparezca espacio libre en el cap.  O hasta que ch est√© cerrado. </p><br><p>  Aqu√≠ hay algunos ejemplos m√°s de lo que send_case puede hacer en select () de SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//     ,   //    . //    . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     . //     ( ) //   ( ). select(from_all().handle_n(3), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     chW. //     chW    150ms. select(from_all().handle_n(1).empty_timeout(150ms), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //     chW. //  ,   chW   . select(from_all().handle_n(1).no_wait_on_empty(), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //    ,      250ms. select(from_all().handle_all().total_time(250ms), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...}));</span></span></code> </pre> <br><p>  Naturalmente, send_case en select () se puede usar junto con accept_case: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          //  .       //  . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMsg&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMsg&gt;::make(...), []{...}), receive_case(ch3, [](...){...}), receive_case(ch4, [](...){...}));</span></span></code> </pre> <br><p>  Ahora, en SObjectizer, el enfoque CSP puede usarse, como dicen, en todos los campos.  No ser√° peor que en Go.  Detallado, por supuesto.  Pero no peor :) </p><br><p>  Podemos decir que la larga historia de agregar soporte para el enfoque CSP a SObjectizer ha terminado. </p><br><h1 id="drugie-vazhnye-veschi-v-etom-relize">  Otras cosas importantes en esta versi√≥n </h1><br><h2 id="okonchatelnyy-pereezd-na-github">  Movimiento final a github </h2><br><p>  SObjectizer originalmente vivi√≥ y se desarroll√≥ en <a href="https://sourceforge.net/projects/sobjectizer/">SourceForge</a> .  Un a√±o de comerciales desde 2006.  Pero en SF.net, el rendimiento de Subversion fue disminuyendo cada vez m√°s, por lo que el a√±o pasado nos mudamos a BitBucket y Mercurial.  Tan pronto como hicimos esto, Atlassian anunci√≥ que los repositorios de Mercurial con BitBucket pronto se eliminar√≠an por completo.  Por lo tanto, desde agosto de 2019, tanto SObjectizer como so5extra se encuentran en GitHub. </p><br><p>  SF.net tiene todo el contenido anterior, incluido el Wiki con documentaci√≥n para versiones anteriores de SObjectizer.  Y tambi√©n <a href="https://sourceforge.net/projects/sobjectizer/files/">la secci√≥n Archivos</a> desde donde puede descargar archivos de diferentes versiones de SObjectizer / so5extra y no solo (por ejemplo, <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/">archivos PDF con algunas presentaciones sobre SObjectizer</a> ). </p><br><p>  En general, b√∫scanos ahora en <a href="https://github.com/Stiffstream/sobjectizer">GitHub</a> .  Y no te olvides de poner estrellas, tenemos muy pocas por ahora;) </p><br><h2 id="ispravleno-povedenie-enveloped-messages">  Comportamiento fijo de mensajes envueltos </h2><br><p>  En SO-5.7.0, se realiz√≥ una peque√±a correcci√≥n que no podr√≠a haber sido mencionada.  Pero vale la pena decirlo, porque esta es una buena demostraci√≥n de c√≥mo las diversas caracter√≠sticas que se acumulan en SObjectizer se afectan entre s√≠ durante su desarrollo. </p><br><p>  Hace cuatro a√±os, se agreg√≥ soporte para agentes, que son m√°quinas de estado jer√°rquicas, a SObjectizer (m√°s detalles <a href="https://habr.com/post/423497/">aqu√≠</a> ).  Luego, despu√©s de otro par de a√±os, se agregaron <a href="https://habr.com/ru/post/426983/">sobres de mensajes</a> a SObjectizer.  Es decir  el mensaje, cuando se envi√≥, estaba envuelto en un objeto de sobre adicional y este sobre podr√≠a recibir informaci√≥n sobre lo que est√° sucediendo con el mensaje. </p><br><p>  Una de las caracter√≠sticas del mecanismo de mensajes envueltos es que se informa al sobre que el mensaje ha sido entregado al destinatario.  Es decir, que se encontr√≥ un controlador para este mensaje en el agente del suscriptor y que se llam√≥ a este controlador. </p><br><p>  Result√≥ que si el agente receptor del mensaje es una m√°quina de estados jer√°rquica que utiliza una funci√≥n como <code>suppress()</code> (es decir, forzar el mensaje a ignorarse en un estado espec√≠fico), el sobre puede recibir una notificaci√≥n de entrega incorrecta, aunque el destinatario realmente rechaz√≥ el mensaje debido a <code>suppress()</code> .  Una situaci√≥n a√∫n m√°s interesante fue con <code>transfer_to_state()</code> , porque  despu√©s de cambiar el estado del agente receptor, se puede encontrar el controlador de mensajes o puede estar ausente.  Pero el sobre sobre la entrega del mensaje fue informado de todos modos. </p><br><p>  Casos muy raros, que, hasta donde yo s√©, no han sido mostrados en la pr√°ctica por nadie.  Sin embargo, se hizo un error de c√°lculo. </p><br><p>  Por lo tanto, en SO-5.7.0 este punto se mejora y si el mensaje se ignora como resultado de aplicar <code>suppress()</code> o <code>transfer_to_state()</code> , el sobre ya no pensar√° que el mensaje ha sido entregado al destinatario. </p><br><h2 id="dopolnitelnaya-biblioteka-so5extra-smenila-licenziyu-na-bsd-3-clause">  La biblioteca adicional de so5extra cambia la licencia BSD-3-CLAUSE </h2><br><p>  En 2017, comenzamos a hacer una biblioteca de componentes adicionales para SObjectizer llamada <a href="https://github.com/Stiffstream/so5extra">so5extra</a> .  Durante este tiempo, la biblioteca ha crecido significativamente y contiene muchas cosas √∫tiles en el hogar. </p><br><p>  So5extra se distribuy√≥ originalmente bajo una doble licencia: GNU Affero GPL v.3 para proyectos de c√≥digo abierto y comerciales para proyectos cerrados. </p><br><p>  Ahora hemos cambiado la licencia de so5extra y, a partir de la versi√≥n 1.4.0, so5extra se distribuye bajo la licencia BSD-3-CLAUSE.  Es decir  se puede usar de forma gratuita incluso cuando se desarrolla software propietario. </p><br><p>  Por lo tanto, si le falta algo en SObjectizer, <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-docs">puede echar un vistazo a so5extra</a> , ¬øqu√© <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-docs">sucede</a> si ya tiene lo que necesita? </p><br><h1 id="buduschee-sobjectizer-a">  El futuro de SObjectizer </h1><br><p>  Antes de decir algunas palabras sobre lo que SObjectizer est√° esperando, debe hacer una digresi√≥n importante.  Especialmente para aquellos que creen que SObjectizer es un "desperdicio de referencia", "mano de obra hasta la rodilla", "laboratorio de estudiantes", "proyecci√≥n experimental que los autores abandonan cuando juegan lo suficiente" ... (esto es solo una parte de las caracter√≠sticas que hab√≠amos escuchado de expertos en de nuestro internet en los √∫ltimos 4-5 a√±os). </p><br><p>  He estado desarrollando SObjectizer durante casi dieciocho a√±os.  Y puedo decir responsablemente que nunca fue un proyecto piloto.  Esta es una herramienta pr√°ctica que entr√≥ en trabajo real desde su primera versi√≥n en el a√±o 2002. </p><br><p>  Tanto yo como mis colegas, y las personas que nos atrevimos a tomar y probar SObjectizer, nos convencimos muchas veces de que SObjectizer realmente hace que el desarrollo de algunos tipos de aplicaciones C ++ multiproceso sea mucho m√°s f√°cil.  Por supuesto, SObjectizer no es una bala de plata, y de ninguna manera siempre se puede usar.  Pero cuando corresponde, ayuda. </p><br><p>  La vida regularmente brinda una oportunidad una vez m√°s para estar convencido de esto.  De vez en cuando, el c√≥digo multiproceso de otra persona nos llama la atenci√≥n, en el que no hab√≠a nada similar a SObjectizer y es poco probable que aparezca.  Trate este c√≥digo aqu√≠ y all√°, los momentos son sorprendentes cuando el uso de actores o canales CSP podr√≠a hacer que el c√≥digo sea m√°s simple y confiable.  Pero no, debe crear patrones no triviales de interacci√≥n de subprocesos mediante mutex-s y condition_variables, donde en SObjectizer puede administrar con una mchain, un par de mensajes y un temporizador integrado en SObjectizer.  Y luego tambi√©n pasa mucho tiempo para probar estos esquemas no triviales ... </p><br><p>  Entonces SObjectizer fue √∫til para nosotros.  Me atrevo a pensar que fue √∫til no solo para nosotros.  Y lo m√°s importante, hace tiempo que est√° aqu√≠ y est√° disponible gratuitamente para todos.  No se ir√° a ning√∫n lado.  ¬øY d√≥nde ir a lo que hay en OpenSource bajo una licencia permisiva?  ;) </p><br><p>  Otra cosa es que nosotros mismos implementamos toda nuestra gran lista de deseos en SObjectizer.  Y el desarrollo futuro de SObjectizer estar√° determinado no tanto por nuestras necesidades como por los deseos de los usuarios. </p><br><p>  Habr√° tales deseos, habr√° nuevas funciones en SObjectizer. </p><br><p>  No ser√° ... Bueno, entonces solo emitiremos versiones correctivas de vez en cuando y verificaremos el rendimiento de SObjectizer en las nuevas versiones de compiladores de C ++. </p><br><p>  Entonces, si desea ver algo en SObjectizer, h√°ganoslo saber.  Si necesita ayuda con SObjectizer, no dude en contactarnos (a trav√©s de <a href="https://github.com/Stiffstream/sobjectizer/issues">Problemas en GitHub</a> o en <a href="https://groups.google.com/forum/">el grupo de Google</a> ), definitivamente intentaremos ayudarlo. </p><br><p>  Bueno, quiero agradecer a los lectores que pudieron leer hasta el final de este art√≠culo.  Y tratar√© de responder cualquier pregunta sobre SObjectizer / so5extra, en caso de que surja. </p><br><p>  PS.  Estar√≠a agradecido si los lectores encontraran tiempo para escribir en los comentarios si fue interesante / √∫til leer art√≠culos sobre SObjectizer y si quieren hacer esto en el futuro.  ¬øO es mejor para nosotros dejar de perder el tiempo escribiendo tales art√≠culos, y as√≠ dejar de tomar el tiempo de los usuarios de Habr? </p><br><p>  PPS  ¬øO tal vez alguien consider√≥ a SObjectizer como una herramienta que no podr√≠a aplicarse por una raz√≥n u otra?  Ser√≠a muy interesante saber sobre esto. </p></div></div><p>Source: <a href="https://habr.com/ru/post/485450/">https://habr.com/ru/post/485450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485426/index.html">Coches en los Pa√≠ses Bajos: estad√≠sticas e informaci√≥n para 2019</a></li>
<li><a href="../485428/index.html">El misterioso programa LyX. Parte 5</a></li>
<li><a href="../485430/index.html">Editor de texto simple para m√∫ltiples usuarios con encriptaci√≥n de extremo a extremo</a></li>
<li><a href="../485438/index.html">Prueba de componentes de la interfaz de usuario de React</a></li>
<li><a href="../485448/index.html">Otra radio FM en el RDA5807 con Arduino</a></li>
<li><a href="../485452/index.html">¬øPor qu√© Rust lidera el marco de referencia TechEmpower Framework?</a></li>
<li><a href="../485454/index.html">Comenzando con las devoluciones de usuarios: consejos para el modelo enganchado</a></li>
<li><a href="../485458/index.html">Silenciador ob√∫s</a></li>
<li><a href="../485460/index.html">20 bibliotecas para una espectacular aplicaci√≥n de iOS</a></li>
<li><a href="../485462/index.html">Nos ocupamos de eSIM (+ entrevista con un experto)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>