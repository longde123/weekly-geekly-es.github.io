<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔠 🕸️ 💊 Bolak-balik untuk jaringan saraf, atau ulasan penggunaan auto-encoders dalam analisis teks 🥐 🧖🏿 ⚾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami sudah menulis di artikel pertama dari blog perusahaan kami tentang bagaimana algoritma untuk mendeteksi pinjaman yang dapat ditransfer bekerja. H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bolak-balik untuk jaringan saraf, atau ulasan penggunaan auto-encoders dalam analisis teks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/antiplagiat/blog/418173/"> Kami sudah menulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama dari blog perusahaan kami</a> tentang bagaimana algoritma untuk mendeteksi pinjaman yang dapat ditransfer bekerja.  Hanya beberapa paragraf dalam artikel yang dikhususkan untuk topik membandingkan teks, meskipun gagasan itu layak mendapatkan deskripsi yang jauh lebih terperinci.  Namun, seperti yang Anda tahu, seseorang tidak dapat langsung menceritakan tentang segalanya, meskipun ia benar-benar ingin.  Dalam upaya untuk membayar upeti pada topik ini dan arsitektur jaringan yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">auto-encoder</a> ", yang kami punya perasaan yang sangat hangat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Oleg_Bakhteev</a> dan saya menulis tinjauan ini. <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deep Learning for NLP (tanpa Magic)</a> <br><br>  Seperti yang kami sebutkan di artikel itu, perbandingan teks adalah "semantik" - kami tidak membandingkan fragmen teks itu sendiri, tetapi vektor yang bersesuaian dengannya.  Vektor tersebut diperoleh sebagai hasil dari pelatihan jaringan saraf, yang menampilkan fragmen teks dengan panjang sewenang-wenang menjadi vektor dari dimensi besar tetapi tetap.  Cara mendapatkan pemetaan seperti itu dan cara mengajar jaringan untuk menghasilkan hasil yang diinginkan adalah masalah terpisah, yang akan dibahas di bawah ini. <br><a name="habracut"></a><br><h1>  Apa itu pembuat enkode otomatis? </h1><br>  Secara formal, jaringan saraf disebut auto-encoder (atau auto-encoder), yang melatih untuk mengembalikan objek yang diterima pada input jaringan. <br><img src="https://habrastorage.org/webt/jy/jw/ip/jyjwipnzwzlyidenzeovey3jba4.png"><br>  Auto-encoder terdiri dari dua bagian: sebuah encoder <b>f</b> , yang mengkodekan sampel <b>X</b> ke representasi internal <b>H</b> , dan decoder <b>g</b> , yang mengembalikan sampel asli.  Dengan demikian, autocoder mencoba untuk menggabungkan versi yang dipulihkan dari setiap objek sampel dengan objek asli. <br><br>  Saat melatih encoder otomatis, fungsi berikut ini diminimalkan: <br><img src="https://habrastorage.org/webt/9f/ay/cm/9faycmmbldgcxvehefjrurcusyq.png"><br><br>  Di mana <b>r</b> berarti versi objek asli yang dipulihkan: <br><img src="https://habrastorage.org/webt/zf/oe/oi/zfoeoiwfxnrscvv0n5cv4keku5k.png"><br><br>  Perhatikan contoh yang disediakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog.keras.io</a> : <br><img src="https://habrastorage.org/webt/lw/wp/i_/lwwpi_kn0wyrduexhkqyrg9jttk.png"><br>  Jaringan menerima objek <b>x</b> sebagai input (dalam kasus kami, nomor 2). <br><br>  Jaringan kami menyandikan objek ini ke keadaan tersembunyi.  Kemudian, menurut keadaan laten, rekonstruksi objek <b>r</b> dikembalikan, yang harus sama dengan x.  Seperti yang kita lihat, gambar yang dipulihkan (di sebelah kanan) menjadi lebih buram.  Ini dijelaskan oleh fakta bahwa kami mencoba untuk tetap dalam pandangan tersembunyi hanya tanda-tanda paling penting dari objek, sehingga objek dikembalikan dengan kerugian. <br><br>  Model auto-encoder dilatih berdasarkan prinsip telepon yang rusak, di mana satu orang (encoder) mentransmisikan informasi <b>(x</b> ) ke orang kedua (decoder <b>)</b> , dan dia, pada gilirannya, memberi tahu dia kepada orang ketiga <b>(r (x))</b> . <br><br>  Salah satu tujuan utama dari auto-encoders adalah untuk mengurangi dimensi ruang sumber.  Ketika kita berhadapan dengan auto-encoders, prosedur pelatihan jaringan saraf itu sendiri membuat auto-encoder mengingat fitur-fitur utama dari objek yang akan lebih mudah untuk mengembalikan objek sampel asli. <br><br>  Di sini kita dapat menggambar analogi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode komponen utama</a> : ini adalah metode pengurangan dimensi, yang hasilnya adalah proyeksi sampel ke subruang di mana varians sampel ini maksimum. <br><br>  Memang, auto-encoder adalah generalisasi dari metode komponen utama: dalam kasus ketika kita membatasi diri kita pada pertimbangan model linier, auto-encoder dan metode komponen utama memberikan representasi vektor yang sama.  Perbedaan muncul ketika kita mempertimbangkan model yang lebih kompleks, misalnya, jaringan saraf multilayer sepenuhnya terhubung, sebagai encoder dan decoder. <br><br>  Contoh perbandingan metode komponen utama dan auto-encoder disajikan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengurangi Dimensi Data dengan Jaringan Saraf Tiruan</a> : <br><img src="https://habrastorage.org/webt/bj/ap/hq/bjaphq8tpjla39pbn2djsrm84y4.png"><br><br>  Di sini, hasil pelatihan auto-encoder dan metode komponen utama untuk pengambilan sampel gambar wajah manusia ditunjukkan.  Baris pertama menunjukkan wajah orang-orang dari sampel kontrol, mis.  dari bagian yang ditangguhkan khusus dari sampel yang tidak digunakan oleh algoritma dalam proses pembelajaran.  Pada baris kedua dan ketiga adalah gambar yang dipulihkan dari keadaan tersembunyi auto-encoder dan metode komponen utama, masing-masing, dari dimensi yang sama.  Di sini Anda dapat melihat dengan jelas seberapa baik auto-encoder bekerja. <br><br>  Dalam artikel yang sama, contoh ilustratif lain: membandingkan hasil auto-encoder dan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LSA</a> untuk tugas pencarian informasi.  Metode LSA, seperti metode komponen utama, adalah metode pembelajaran mesin klasik dan sering digunakan dalam tugas yang berkaitan dengan pemrosesan bahasa alami. <br><img src="https://habrastorage.org/webt/di/h5/j3/dih5j3wsflfohomgzzrjo9e6n7k.png"><br>  Gambar tersebut menunjukkan proyeksi 2D dari beberapa dokumen yang diperoleh menggunakan metode auto-encoder dan LSA.  Warna menunjukkan tema dokumen.  Dapat dilihat bahwa proyeksi dari auto-encoder memecah dokumen berdasarkan topik dengan baik, sedangkan LSA menghasilkan hasil yang jauh lebih berisik. <br><br>  Aplikasi penting lain dari auto- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">encoders adalah pra-pelatihan jaringan</a> .  Pra-pelatihan jaringan digunakan ketika jaringan yang dioptimalkan cukup dalam.  Dalam hal ini, melatih jaringan "dari awal" bisa sangat sulit, oleh karena itu, pertama-tama seluruh jaringan direpresentasikan sebagai rantai pembuat enkode. <br><br>  Algoritma pra-pelatihan cukup sederhana: untuk setiap layer kita melatih auto-encoder kita sendiri, dan kemudian kita menetapkan bahwa output dari encoder berikutnya secara bersamaan merupakan input untuk lapisan jaringan berikutnya.  Model yang dihasilkan terdiri dari rantai enkode yang dilatih untuk mempertahankan fitur objek yang paling penting, masing-masing pada lapisannya sendiri.  Skema pra-pelatihan disajikan di bawah ini: <br><img src="https://habrastorage.org/webt/yy/mc/ui/yymcuigpqgegoa_7gwndzfxulia.png"><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">psyyz10.github.io</a> <br><br>  Struktur ini disebut Stenced Autoencoder dan sering digunakan sebagai "overclocking" untuk lebih lanjut melatih model jaringan penuh dalam.  Motivasi untuk pelatihan jaringan saraf seperti itu adalah bahwa jaringan saraf yang dalam adalah fungsi non-cembung: dalam proses pelatihan jaringan, optimalisasi parameter dapat "terjebak" dalam minimum lokal.  Pra-pelatihan yang serakah terhadap parameter jaringan memungkinkan Anda menemukan titik awal yang baik untuk pelatihan terakhir dan dengan demikian mencoba menghindari minimum lokal semacam itu. <br><br>  Tentu saja, kami tidak mempertimbangkan semua struktur yang mungkin, karena ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Jarang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Denoising</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Kontraktif</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Kontraktif Rekonstruksi</a> .  Mereka berbeda di antara mereka sendiri dengan menggunakan berbagai fungsi kesalahan dan ketentuan hukuman kepada mereka.  Semua arsitektur ini, menurut pendapat kami, pantas mendapatkan ulasan terpisah.  Dalam artikel kami, kami menunjukkan, pertama-tama, konsep umum auto-encoders dan tugas-tugas khusus dari analisis teks yang diselesaikan dengan menggunakannya. <br><br><h2>  Bagaimana cara kerjanya dalam teks? </h2><br>  Kami sekarang beralih ke contoh spesifik penggunaan autocoder untuk tugas analisis teks.  Kami tertarik pada kedua sisi aplikasi - kedua model untuk memperoleh representasi internal, dan penggunaan representasi internal ini sebagai atribut, misalnya, dalam masalah klasifikasi lebih lanjut.  Artikel-artikel tentang topik ini paling sering menyentuh tugas-tugas seperti analisis sentimen atau deteksi ulang kata-kata, tetapi ada juga karya yang menggambarkan penggunaan auto-encoders untuk membandingkan teks dalam bahasa yang berbeda atau untuk terjemahan mesin. <br><br>  Dalam tugas analisis teks, objek yang paling sering adalah kalimat, mis.  urutan kata yang dipesan.  Jadi, auto-encoder menerima urutan kata-kata ini dengan tepat, atau lebih tepatnya, representasi vektor dari kata-kata ini yang diambil dari beberapa model yang dilatih sebelumnya.  Apa representasi vektor kata, itu dianggap pada Habré dalam detail yang cukup, misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dengan demikian, auto-encoder, mengambil urutan kata-kata sebagai input, harus melatih beberapa representasi internal dari seluruh kalimat yang memenuhi karakteristik yang penting bagi kami, berdasarkan pada tugas.  Dalam masalah analisis teks, kita perlu memetakan kalimat ke vektor sehingga mereka dekat dalam arti beberapa fungsi jarak, paling sering merupakan ukuran kosinus: <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deep Learning for NLP (tanpa Magic)</a> <br><br>  Salah satu penulis pertama yang menunjukkan keberhasilan penggunaan auto-encoders dalam analisis teks adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Richard Socher</a> . <br><br>  Dalam artikelnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dynamic Pooling dan Unfolding Recursive Autoencoder untuk Paraphrase Detection,</a> ia menjelaskan struktur autocoding baru - Unfolding Recursive Autoencoder (Unfolding RAE) (lihat gambar di bawah). <br><img src="https://habrastorage.org/webt/zn/va/o9/znvao90juxs6ywwmm5ywwe6nrdm.png"><br>  Membuka RAE <br><br>  Diasumsikan bahwa struktur kalimat didefinisikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser sintaksis</a> .  Struktur paling sederhana dianggap - struktur pohon biner.  Pohon seperti itu terdiri dari dedaunan - kata-kata dari sebuah fragmen, simpul internal (simpul cabang) —fase, dan simpul terminal.  Mengambil urutan kata-kata (x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> ) sebagai input (tiga representasi vektor kata dalam contoh ini), auto-encoder secara berurutan mengkodekan, dalam hal ini, dari kanan ke kiri, representasi vektor dari kata-kata kalimat menjadi representasi vektor dari kolokasi, dan kemudian menjadi vektor Presentasi seluruh penawaran.  Khususnya dalam contoh ini, pertama-tama kita menggabungkan vektor x <sub>2</sub> dan x <sub>3</sub> , kemudian mengalikannya dengan matriks <i>W yang</i> memiliki dimensi <i>tersembunyi × 2 tidak terlihat</i> , di mana <i>tersembunyi</i> adalah di mana ukuran representasi internal yang tersembunyi, <i>terlihat</i> adalah dimensi dari kata vektor.  Jadi, kita mengurangi dimensi, lalu menambahkan non-linearitas menggunakan fungsi tanh.  Pada langkah pertama, kita mendapatkan representasi vektor tersembunyi untuk frasa dua kata <i>x <sub>2</sub></i> dan <i>x <sub>3</sub></i> : <i>h <sub>1</sub></i> = <i>tanh⁡ (W <sub>e</sub> [x <sub>2</sub> , x <sub>3</sub> ] + b <sub>e</sub> )</i> .  Pada yang kedua, kita menggabungkannya dan kata yang tersisa <i>h <sub>2</sub></i> = <i>tanh⁡ (W <sub>e</sub> [h1, x <sub>1</sub> ] + b <sub>e</sub> )</i> dan mendapatkan representasi vektor untuk seluruh kalimat - <i>h <sub>2</sub></i> .  Seperti disebutkan di atas, dalam definisi auto-encoder, kita perlu meminimalkan kesalahan antara objek dan versi yang dipulihkan.  Dalam kasus kami, ini adalah kata-kata.  Oleh karena itu, setelah menerima representasi vektor akhir dari seluruh kalimat <i>h <sub>2</sub></i> , kami akan mendekode versinya yang dipulihkan (x <sub>1</sub> ', x <sub>2</sub> ', x <sub>3</sub> ').  Dekoder di sini bekerja dengan prinsip yang sama dengan pembuat enkode, hanya matriks parameter dan vektor shift yang berbeda di sini: <i>W <sub>d</sub></i> dan <i>b <sub>d</sub></i> . <br><br>  Dengan menggunakan struktur pohon biner, Anda dapat menyandikan kalimat dengan panjang apa pun ke dalam vektor dimensi tetap - kami selalu menggabungkan sepasang vektor dari dimensi yang sama, menggunakan matriks parameter <i>W yang sama</i> .  Dalam kasus pohon non-biner, Anda hanya perlu menginisialisasi matriks terlebih dahulu jika kami ingin menggabungkan lebih dari dua kata - 3, 4, ... n, dalam hal ini matriks hanya akan memiliki dimensi <i>tersembunyi × tidak terlihat</i> . <br><br>  Perlu dicatat bahwa dalam artikel ini, representasi vektor terlatih dari frasa digunakan tidak hanya untuk menyelesaikan masalah klasifikasi - beberapa kalimat diulang atau tidak.  Data percobaan tentang pencarian tetangga terdekat juga disajikan - hanya berdasarkan vektor tawaran yang diterima, vektor terdekat dalam sampel dicari yang dekat dengan artinya: <br><br><img src="https://habrastorage.org/webt/d6/pv/ae/d6pvaevnd18k2ouizgs3t9k0xbk.png"><br><br>  Namun, tidak ada yang mengganggu kita untuk menggunakan arsitektur jaringan lain untuk penyandian dan pengodean kata untuk menggabungkan kata-kata menjadi kalimat. <br><br>  Berikut adalah contoh dari artikel NIPS 2017 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembelajaran Representasi Paragraf Dekonvolusional</a> : <br><img src="https://habrastorage.org/webt/g9/u7/0m/g9u70mec8rpyrbnxuqtnflyxcfo.png"><br><br>  Kita melihat bahwa pengkodean sampel <b>X</b> ke dalam representasi tersembunyi <b>h</b> terjadi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaringan saraf convolutional</a> , dan dekoder bekerja pada prinsip yang sama. <br><br>  Atau di sini adalah contoh menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GRU-GRU</a> dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skip-Thought Vectors</a> . <br><br>  Fitur yang menarik di sini adalah bahwa model ini bekerja dengan tiga kali lipat kalimat: ( <i>s <sub>i-1</sub> , s <sub>i</sub> , s <sub>i + 1</sub></i> ).  Kalimat <i>s <sub>i</sub></i> dikodekan menggunakan rumus GRU standar, dan dekoder, menggunakan informasi representasi internal <i>s <sub>i</sub></i> , mencoba memecahkan kode <i>s <sub>i-1</sub></i> dan <i>s <sub>i +1</sub></i> , juga menggunakan GRU. <br><br><img src="https://habrastorage.org/webt/ed/od/-r/edod-radj66y43mbsgu31zxo7nu.png"><br><br>  Prinsip operasi dalam hal ini menyerupai model standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan mesin jaringan saraf</a> , yang bekerja sesuai dengan skema encoder-decoder.  Namun, di sini kami tidak memiliki dua bahasa, kami mengirimkan frasa dalam satu bahasa ke input unit pengkodean kami dan mencoba mengembalikannya.  Dalam proses pembelajaran, ada minimalisasi beberapa fungsional kualitas internal (ini tidak selalu kesalahan rekonstruksi), maka, jika diperlukan, vektor pra-terlatih digunakan sebagai fitur dalam masalah lain. <br><br>  Makalah lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Rekursif Bilingual Correspondence untuk Terjemahan Mesin Statistik</a> , menyajikan arsitektur yang mengambil pandangan segar pada terjemahan mesin.  Pertama, untuk dua bahasa, autocoder rekursif dilatih secara terpisah (sesuai dengan prinsip yang dijelaskan di atas - di mana Unfolding RAE diperkenalkan).  Kemudian, di antara mereka, sebuah auto-encoder ketiga dilatih - pemetaan antara dua bahasa.  Arsitektur seperti itu memiliki keuntungan yang jelas - ketika menampilkan teks dalam berbagai bahasa ke dalam satu ruang tersembunyi yang umum, kita dapat membandingkannya tanpa menggunakan terjemahan mesin sebagai langkah perantara. <br><br><img src="https://habrastorage.org/webt/tj/rq/un/tjrqunxjtnbgsivzz7iohnm8ibs.png"><br><br>  Pelatihan auto-encoders pada fragmen teks sering ditemukan dalam artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelatihan peringkat</a> .  Di sini, sekali lagi, fakta bahwa kita sedang melatih fungsional akhir dari kualitas peringkat adalah penting, pertama-tama kita melatih trainer-otomatis untuk menginisialisasi vektor permintaan dan tanggapan yang lebih baik yang dikirimkan ke input jaringan. <br><br><img src="https://habrastorage.org/webt/5t/a1/qn/5ta1qnx9gqzl9dypb0t4nhgcjtg.jpeg"><br><br>  Dan, tentu saja, kita tidak bisa tidak menyebut <a href="">Varietas Autoencoder</a> , atau <a href="">VAE</a> , sebagai model generatif.  Yang terbaik, tentu saja, hanya menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entri kuliah ini dari Yandex</a> .  Sudah cukup bagi kita untuk mengatakan yang berikut: jika kita ingin <i>menghasilkan</i> objek dari ruang tersembunyi dari auto-encoder konvensional, maka kualitas generasi tersebut akan rendah, karena kita tidak tahu apa-apa tentang distribusi variabel tersembunyi.  Tetapi Anda dapat segera melatih pembuat enkode otomatis untuk menghasilkan, memperkenalkan asumsi distribusi. <br><br>  Dan kemudian, menggunakan VAE, Anda dapat menghasilkan teks dari ruang tersembunyi ini, misalnya, seperti yang dilakukan penulis artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghasilkan Kalimat dari Ruang Kontinu</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autoencoder Variabel Konvolusional Hibrid untuk Pembuatan Teks</a> . <br><br>  Properti generatif dari VAE juga bekerja dengan baik dalam tugas membandingkan teks dalam bahasa yang berbeda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan Variasi Autoencoding untuk Menginduksi Penyesuaian Kata Lintas Bahasa adalah</a> contoh yang bagus untuk ini. <br><br>  Sebagai kesimpulan, kami ingin membuat perkiraan kecil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Representasi Pembelajaran</a> - pelatihan dalam representasi internal yang menggunakan VAE tepat, terutama dalam hubungannya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generative Adversarial Networks</a> , adalah salah satu pendekatan yang paling berkembang dalam beberapa tahun terakhir - ini dapat dinilai dengan setidaknya topik paling umum dari artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi</a> pembelajaran mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICLR 2018</a> terbaru. dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICML 2018</a> .  Ini cukup logis - karena penggunaannya telah membantu meningkatkan kualitas dalam sejumlah tugas, dan tidak hanya terkait dengan teks.  Tapi ini adalah topik ulasan yang sama sekali berbeda ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418173/">https://habr.com/ru/post/id418173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418163/index.html">Tes Produksi: Platform Otomatisasi Netflix Netflix</a></li>
<li><a href="../id418165/index.html">Quasar, Sobaken dan Vermin: mengungkap detail kampanye mata-mata cyber yang sedang berlangsung</a></li>
<li><a href="../id418167/index.html">ScadaPy: tambahkan protokol IEC 60870-5-104</a></li>
<li><a href="../id418169/index.html">Apa yang baru di Veeam Ketersediaan Konsol 2.0 Pembaruan 1?</a></li>
<li><a href="../id418171/index.html">Metrik apa yang diandalkan jika pengguna melakukan sedikit konversi di situs?</a></li>
<li><a href="../id418177/index.html">Mengedit gambar .heic tanpa kehilangan warna</a></li>
<li><a href="../id418183/index.html">Penerapan analisis wicara dalam bisnis</a></li>
<li><a href="../id418185/index.html">Satu kisah otopsi: bagaimana kami membalikkan Hancitor</a></li>
<li><a href="../id418187/index.html">Di Amerika, mereka menyarankan untuk mengganti semua perpustakaan dengan hub Amazon. Publik marah</a></li>
<li><a href="../id418189/index.html">Pewaris Zeus: mengapa Trojan IcedID berbahaya bagi nasabah bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>