<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèª üë©üèª‚Äçü§ù‚Äçüë®üèæ üîà Toda a verdade sobre o RTOS. Artigo 29. Interrup√ß√µes no N√∫cleo SE üõ†Ô∏è üë∫ üßëüèæ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os microprocessadores e microcontroladores modernos cont√™m algum tipo de mecanismo de interrup√ß√£o. Esses mecanismos s√£o necess√°rios para fornece...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 29. Interrup√ß√µes no N√∫cleo SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/">  Todos os microprocessadores e microcontroladores modernos cont√™m algum tipo de mecanismo de interrup√ß√£o.  Esses mecanismos s√£o necess√°rios para fornecer a capacidade de resposta exigida por muitos aplicativos.  Obviamente, responsividade e previsibilidade s√£o o principal objetivo ao usar o RTOS, mas ao mesmo tempo se op√µem.  O uso de interrup√ß√µes pode prejudicar a integridade do sistema operacional em tempo real.  Esse problema e sua solu√ß√£o foram mencionados em um dos artigos anteriores (n¬∫s 4 e 6).  Neste artigo, veremos a estrat√©gia de manipula√ß√£o de interrup√ß√µes usada no Nucleus SE.  Em todos os casos, as interrup√ß√µes N√ÉO s√£o controladas pelo Nucleus SE: s√£o processadas quando ocorrem de acordo com a prioridade e os vetores da maneira usual.  Seu tempo de execu√ß√£o √© simplesmente "roubado" do tempo dispon√≠vel no c√≥digo do aplicativo principal e do planejador.  Obviamente, segue-se que todos os manipuladores de interrup√ß√£o devem ser simples, curtos e r√°pidos. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores da s√©rie:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Temporizadores de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 27</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais de Dados: Introdu√ß√£o e Servi√ßos B√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: Introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sem√°foros: Servi√ßos Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sem√°foros: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 18</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Servi√ßos Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Introdu√ß√£o e Servi√ßos B√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Signals</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parti√ß√µes de mem√≥ria: servi√ßos e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Se√ß√µes de mem√≥ria: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API n√£o suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Servi√ßos para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configura√ß√£o e introdu√ß√£o √† API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avan√ßados e preserva√ß√£o de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementa√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Projeto Interno e Implanta√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Introdu√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros servi√ßos RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intera√ß√£o e sincroniza√ß√£o de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, altern√¢ncia de contexto e interrup√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdu√ß√£o.</a> <br></div></div><br><h2>  Interrup√ß√µes regulares e controladas </h2><br>  O Nucleus SE oferece duas maneiras de lidar com interrup√ß√µes: "nativo" ou "regular" (Nativo), nas quais as interrup√ß√µes n√£o s√£o nada de especial e, em certa medida, t√™m intera√ß√£o limitada com o SO (pelo menos ao usar o agendador priorit√°rio) e " Gerenciado, no qual voc√™ pode acessar um n√∫mero muito maior de chamadas de API do manipulador de interrup√ß√µes. <br><br>  Usando as macros de E / S, o manipulador de interrup√ß√£o Nucleus SE pode ser usado no modo padr√£o ou gerenciado. <br><br><h3>  Interrup√ß√£o do pessoal </h3><br>  As interrup√ß√µes da equipe do N√∫cleo SE s√£o o manipulador de interrup√ß√£o padr√£o e podem ser consideradas "n√£o gerenciadas".  Eles geralmente s√£o usados ‚Äã‚Äãquando a interrup√ß√£o pode ocorrer com alta frequ√™ncia e requer processamento com baixo uso de recursos de computa√ß√£o.  Esse manipulador provavelmente √© escrito em C, pois muitos compiladores incorporados modernos suportam o desenvolvimento de manipuladores de interrup√ß√£o usando a palavra-chave interrupt.  Somente as informa√ß√µes contextuais que o compilador considera necess√°rias s√£o armazenadas.  Isso leva a limita√ß√µes significativas sobre o que os manipuladores de interrup√ß√£o padr√£o podem fazer, o que veremos em breve. <br><br>  Para criar um manipulador de interrup√ß√£o regular no Nucleus SE, basta escrever um manipulador de interrup√ß√£o regular, incluindo chamar a macro <b>NUSE_NISR_Enter ()</b> no in√≠cio e chamar <b>NUSE_NISR_Exit ()</b> no final.  Essas macros s√£o definidas no arquivo <b>nuse_types.</b>  he defina a vari√°vel global <b>NUSE_Task_State</b> como <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Interrup√ß√µes guiadas </h3><br>  Se voc√™ precisar de mais flexibilidade para opera√ß√µes do manipulador de interrup√ß√µes, as interrup√ß√µes gerenciadas do Nucleus SE podem ser a solu√ß√£o.  A principal diferen√ßa da interrup√ß√£o padr√£o √© manter o contexto.  Em vez de permitir que o compilador salve v√°rios registros na pilha, uma interrup√ß√£o controlada salva o contexto inteiro da tarefa (em seu pr√≥prio bloco de contexto) na entrada.  Em seguida, o contexto da tarefa atual √© restaurado do bloco de contexto na sa√≠da.  Isso fornece a capacidade de alterar a tarefa atual pelo trabalho do c√≥digo do manipulador de interrup√ß√µes, o que √© poss√≠vel ao usar o planejador de prioridades.  Uma descri√ß√£o completa da preserva√ß√£o e restaura√ß√£o do contexto no Nucleus SE foi fornecida em um artigo anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 10</a> ). <br><br>  Obviamente, a preserva√ß√£o total do contexto implica um aumento no uso de recursos de computa√ß√£o em compara√ß√£o com o armazenamento de v√°rios registros na pilha, o que ocorre durante uma interrup√ß√£o padr√£o.  Esse pre√ßo deve ser pago por uma flexibilidade adicional, e √© por isso que √© fornecida uma op√ß√£o de abordagem de manipula√ß√£o de interrup√ß√£o. <br><br>  Uma interrup√ß√£o gerenciada √© criada usando a macro <b>NUSE_MANAGED_ISR ()</b> descrita em <b>nuse_types.h</b> .  Essa macro cria uma fun√ß√£o que cont√©m as seguintes a√ß√µes: <br><br><ul><li>  manter o contexto da tarefa; </li><li>  Atribuindo <b>NUSE_Task_State a</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  c√≥digo de fun√ß√£o do manipulador de interrup√ß√µes fornecido pelo usu√°rio; </li><li>  restaurando <b>NUSE_Task_State</b> para seu estado anterior; </li><li>  restaurar o contexto da tarefa. </li></ul><br>  A macro usa dois par√¢metros: o nome da interrup√ß√£o usado como o nome da fun√ß√£o para o manipulador gerado e o nome da fun√ß√£o que cont√©m a l√≥gica do usu√°rio para o manipulador de interrup√ß√µes. <br><br><h3>  Chamadas de API do manipulador de interrup√ß√µes </h3><br>  O conjunto de fun√ß√µes da API que podem ser chamadas de um manipulador de interrup√ß√£o padr√£o ou gerenciado depende de qual planejador √© usado.  Em termos gerais, o uso do agendador priorit√°rio fornece muitas op√ß√µes para acessar o agendador por meio de uma chamada de fun√ß√£o da API, o que √© dif√≠cil ao usar o manipulador de interrup√ß√£o padr√£o. <br><br>  <b><i>Chamadas de API para o manipulador de interrup√ß√£o padr√£o ao usar o planejador de prioridade</i></b> <br><br>  Ao usar o planejador de prioridade, √© permitido um n√∫mero limitado de chamadas de fun√ß√£o da API do manipulador de interrup√ß√£o padr√£o.  Essa limita√ß√£o √© o resultado da flexibilidade da API do Nucleus SE: muitas chamadas podem fazer com que a tarefa fique pronta e o planejador n√£o pode ser chamado pelo manipulador de interrup√ß√£o padr√£o (j√° que o contexto da tarefa n√£o √© salvo).  Desativar bloqueios de tarefas fornece ainda mais flexibilidade. <br><br>  As seguintes chamadas de API s√£o sempre permitidas: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  No entanto, apenas <b>NUSE_Signals_Send ()</b> √© √∫til para eles, pois fornece uma maneira conveniente de indicar √† tarefa que alguma a√ß√£o √© necess√°ria. <br><br>  Se o bloqueio estiver desativado, ou seja, as tarefas n√£o poder√£o ser colocadas em estado de prontid√£o por muitas chamadas de API, outras chamadas de API estar√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Algumas chamadas de API s√£o sempre inacess√≠veis aos manipuladores de interrup√ß√£o padr√£o, pois inevitavelmente exigem o trabalho de um agendador: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Chamadas de API para o manipulador de interrup√ß√µes gerenciado ou manipulador de interrup√ß√£o padr√£o ao usar qualquer agendador que n√£o seja o agendador de prioridade</i></b> <br><br>  Muitas outras fun√ß√µes da API podem ser chamadas a partir do manipulador de interrup√ß√µes ao usar os agendadores Run to Completion, Round Robin ou Time Slice.  Se um agendador de prioridade for usado, os manipuladores de interrup√ß√£o gerenciados ter√£o um conjunto semelhante de fun√ß√µes.  Isso ocorre porque as chamadas s√£o permitidas, o que pode levar ao agendamento de outra tarefa.  Esse recurso √© fornecido pelo c√≥digo <b>NUSE_Reschedule ()</b> , que detecta o contexto de chamada no manipulador de interrup√ß√µes e suprime a altera√ß√£o de contexto (permitindo que isso aconte√ßa no final do manipulador de interrup√ß√µes).  Uma an√°lise completa do trabalho do agendador foi apresentada em um dos artigos anteriores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n¬∫ 9</a> ). <br><br>  O principal requisito √© que as chamadas de API dentro do manipulador de interrup√ß√µes n√£o levem √† suspens√£o da tarefa atual, por exemplo, aguardando a libera√ß√£o de um recurso. <br><br>  Em outras palavras, essas chamadas devem ser feitas com a <b>op√ß√£o de</b> pausa <b>NUSE_NO_SUSPEND</b> . <br><br>  Com isso em mente, as seguintes chamadas de API podem ser usadas: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Algumas chamadas s√£o sempre barradas, pois est√£o diretamente relacionadas √† tarefa atual: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Manipulador de interrup√ß√£o de rel√≥gio em tempo real </h2><br>  O manipulador de interrup√ß√£o do Real Time Clock (RTC) √© o √∫nico manipulador de interrup√ß√£o completo no Nucleus SE.  Al√©m de fornecer toda a funcionalidade necess√°ria para o gerenciamento de tempo no Nucleus SE, tamb√©m serve como exemplo de grava√ß√£o de um manipulador de interrup√ß√µes gerenciado. <br><br><h3>  Opera√ß√µes do manipulador de interrup√ß√£o RTC </h3><br>  As fun√ß√µes fornecidas pelo manipulador de interrup√ß√µes do RTC foram listadas em um dos artigos anteriores, que tratavam do amplo t√≥pico de hora do sistema no Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 27</a> ).  A funcionalidade descrita √© opcional, dependendo da configura√ß√£o do aplicativo. <br><br><div class="spoiler">  <b class="spoiler_title">A seguir est√° o c√≥digo completo do manipulador de interrup√ß√£o do RTC.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  A seguir, analisamos quatro √°reas principais de funcionalidade do manipulador de interrup√ß√µes RTC. <br><br>  <b><i>Temporizadores</i></b> <br>  Se os cron√¥metros do aplicativo estiverem configurados, o manipulador de interrup√ß√£o entrar√° em um loop para processar cada cron√¥metro, diminuindo seu contador em 1. Se o cron√¥metro terminar a contagem (ou seja, o contador atingir 0), duas a√ß√µes ser√£o poss√≠veis: <br><br><ul><li>  se o manipulador de conclus√£o do timer estiver configurado e o cron√¥metro tiver um ponteiro de fun√ß√£o correto (n√£o <b>NULL</b> ) (em <b>NUSE_Timer_Expiration_Routine_Address []</b> ), o manipulador ser√° executado usando um par√¢metro de <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  se o cron√¥metro estiver configurado para inicializar ap√≥s a conclus√£o (ou seja, <b>NUSE_Timer_Reschedule_Time []</b> possui um valor diferente de zero), o cron√¥metro ser√° recarregado com esse valor. </li></ul><br>  Os cron√¥metros de aplicativos foram descritos em detalhes em um artigo anterior (n¬∫ 28). <br><br>  <b><i>Rel√≥gio do sistema</i></b> <br>  Se um timer do sistema estiver configurado, o valor de <b>NUSE_Tick_Cloc</b> k simplesmente aumentar√° em 1. Mais informa√ß√µes podem ser encontradas no artigo # 28. <br><br>  <b><i>Suspender uma tarefa (repouso da tarefa)</i></b> <br>  Se o suporte para pausar tarefas estiver ativado (ou seja, a chamada da API <b>NUSE_Task_Sleep ()</b> estiver configurada), o contador de tempo limite de cada tarefa (o valor em <b>NUSE_Task_Timeout_Counter []</b> ) ser√° verificado e, se n√£o for igual a zero, diminui em 1. Se atingir zero, a tarefa correspondente ser√° retomada. . <br><br>  <b><i>Agendamento de intervalo de tempo</i></b> <br>  Se um agendador do Time Slice for usado, o contador do agendador ( <b>NUSE_Time_Slice_Ticks</b> ) ser√° diminu√≠do.  Se atingir zero, o agendador √© chamado.  A chamada para <b>NUSE_Reschedule ()</b> √© respons√°vel por redefinir o contador. <br><br><h3>  Interrup√ß√£o controlada </h3><br>  √â necess√°rio explicar por que o manipulador de interrup√ß√µes do RTC √© control√°vel, pois, sob certas circunst√¢ncias, o usu√°rio pode decidir reescrev√™-lo como uma interrup√ß√£o padr√£o para reduzir o uso de recursos de computa√ß√£o.  Por exemplo, se apenas uma fun√ß√£o de hora do sistema for usada (ou seja, n√£o houver cron√¥metros de aplicativo, n√£o houver suspens√µes de tarefas e n√£o houver agendador de Time Slice), uma interrup√ß√£o regular funcionar√°.  A interrup√ß√£o guiada √© necess√°ria nos seguintes casos: <br><br><ul><li>  se os temporizadores forem usados ‚Äã‚Äãe os manipuladores para sua conclus√£o estiverem configurados, pois esses manipuladores podem fazer chamadas de API (no contexto de interrup√ß√£o), o que causar√° um novo agendamento.  Eles t√™m as mesmas limita√ß√µes que as chamadas de API feitas a partir de manipuladores de interrup√ß√£o (veja anteriormente neste artigo); </li><li>  se um agendador de prioridade for usado, a conclus√£o de uma suspens√£o de tarefa poder√° exigir a ativa√ß√£o de uma tarefa com prioridade mais alta; </li><li>  se o agendador do Time Slice for usado, ele ser√° chamado a partir do manipulador de interrup√ß√µes do RTC; portanto, √© necess√°ria uma interrup√ß√£o controlada. </li></ul><br><h2>  Compat√≠vel com n√∫cleo RTOS </h2><br>  Como a implementa√ß√£o das interrup√ß√µes do Nucleus SE √© muito diferente do Nucleus RTOS, voc√™ n√£o deve esperar compatibilidade nesse sentido.  O Nucleus RTOS possui um esquema de interrup√ß√£o padr√£o / de baixo n√≠vel / alto n√≠vel, que √© um pouco como o esquema de interrup√ß√£o padr√£o / controlado no Nucleus SE. <br><br><h3>  Manipuladores de interrup√ß√£o de baixo e alto n√≠vel </h3><br>  <b><i>Manipuladores de interrup√ß√£o de baixo n√≠vel</i></b> <br>  Uma Rotina de Servi√ßo de Interrup√ß√£o de Baixo N√≠vel (LISR) √© executada da mesma maneira que um manipulador regular, incluindo o uso da pilha atual.  O n√∫cleo RTOS mant√©m o contexto at√© que o manipulador de interrup√ß√£o de baixo n√≠vel seja chamado e restaura o contexto ap√≥s a conclus√£o do manipulador.  Portanto, um manipulador de interrup√ß√£o de baixo n√≠vel pode ser gravado em C e chamar outros manipuladores em C. No entanto, apenas alguns servi√ßos Nucleus RTOS est√£o dispon√≠veis para o manipulador de baixo n√≠vel.  Se a manipula√ß√£o de interrup√ß√µes exigir servi√ßos adicionais do Nucleus RTOS, voc√™ precisar√° ativar um manipulador de interrup√ß√µes de alto n√≠vel.  O Nucleus RTOS suporta o uso de v√°rios manipuladores de interrup√ß√£o de baixo n√≠vel. <br><br>  <b><i>Manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br>  A Rotina de Servi√ßo de Interrup√ß√£o de Alto N√≠vel (HISR) √© criada e exclu√≠da dinamicamente.  Cada processador de alto n√≠vel possui seu pr√≥prio espa√ßo de pilha e sua pr√≥pria unidade de controle.  A mem√≥ria √© alocada pelo aplicativo.  E, √© claro, um manipulador de interrup√ß√£o de alto n√≠vel deve ser criado antes que um manipulador de interrup√ß√£o de baixo n√≠vel possa ativ√°-lo. <br><br>  Como o manipulador de interrup√ß√£o de alto n√≠vel possui sua pr√≥pria pilha e unidade de controle, ele pode ser temporariamente bloqueado se tentar acessar a estrutura de dados do Nucleus RTOS atualmente em uso. <br><br>  Existem tr√™s n√≠veis de prioridade dispon√≠veis para um manipulador de interrup√ß√£o de alto n√≠vel.  Se um manipulador de n√≠vel superior com uma prioridade mais alta for ativado durante o trabalho de um manipulador com uma prioridade mais baixa, um manipulador com uma prioridade mais baixa ser√° executado √† medida que a tarefa for conclu√≠da.  Manipuladores de interrup√ß√£o de alto n√≠vel com a mesma prioridade s√£o executados na ordem em que s√£o ativados.  Todos os manipuladores de interrup√ß√£o de alto n√≠vel ativados devem ser conclu√≠dos antes de continuar a agendar tarefas no modo normal. <br><br><h3>  Utilit√°rio de API do n√∫cleo RTOS solicita interrup√ß√£o </h3><br>  O n√∫cleo RTOS possui v√°rias chamadas de API para oferecer suporte a interrup√ß√µes.  Nenhum deles √© implementado no Nucleus SE. <br><br>  Para interrup√ß√µes padr√£o, as chamadas de API fornecem as seguintes fun√ß√µes: <br><br><ul><li>  controle (ativa√ß√£o / desativa√ß√£o) de interrup√ß√£o (local e globalmente); </li><li>  definindo o vetor de interrup√ß√£o. </li></ul><br>  Para interrup√ß√µes de baixo n√≠vel: <br><br><ul><li>  registrando um manipulador de interrup√ß√£o de baixo n√≠vel no kernel. </li></ul><br>  Para interrup√ß√µes de alto n√≠vel: <br><br><ul><li>  cria√ß√£o / remo√ß√£o de interrup√ß√µes de alto n√≠vel; </li><li>  ativa√ß√£o de interrup√ß√£o de alto n√≠vel; </li><li>  obtendo o n√∫mero de interrup√ß√µes de alto n√≠vel no aplicativo (no momento); </li><li>  obter indicadores para controlar unidades de todas as interrup√ß√µes de alto n√≠vel; </li><li>  obter indicadores para controlar as unidades da atual interrup√ß√£o de alto n√≠vel; </li><li>  Obtendo informa√ß√µes de interrup√ß√£o de alto n√≠vel. </li></ul><br>  <b><i>Controle global de interrup√ß√£o</i></b> <br><br>  Essa chamada ativa ou desativa interrup√ß√µes, independentemente da tarefa.  Portanto, a interrup√ß√£o desativada por esta chamada permanecer√° assim at√© que seja ativada reutilizando essa chamada. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Par√¢metros: <br><br>  <b>new_level</b> - um novo n√≠vel de interrup√ß√£o para o sistema.  Ele sempre pode aceitar os valores <b>NU_DISABLE_INTERRUPTS</b> (desativa todas as interrup√ß√µes) e <b>NU_ENABLE_INTERRUPTS</b> (ativa todas as interrup√ß√µes).  Outros valores podem estar dispon√≠veis, dependendo da arquitetura. <br><br>  Valor de retorno: <br><br>  Esta chamada de servi√ßo retorna o n√≠vel anterior de interrup√ß√µes ativadas. <br><br>  <b><i>Controle de interrup√ß√£o local</i></b> <br><br>  Essa chamada de servi√ßo permite ativar ou desativar as interrup√ß√µes, dependendo da tarefa.  Essa chamada altera o registro de status para o valor especificado.  O registro de status retornar√° ao valor especificado pela √∫ltima chamada para <b>NU_Control_Interrupts () na</b> pr√≥xima vez que o contexto for alterado. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Par√¢metros: <br><br>  <b>new_level</b> - um novo n√≠vel de interrup√ß√£o para a tarefa atual.  Ele sempre pode aceitar os valores <b>NU_DISABLE_INTERRUPTS</b> (desativa todas as interrup√ß√µes) e <b>NU_ENABLE_INTERRUPTS</b> (ativa todas as interrup√ß√µes).  Outros valores podem estar dispon√≠veis, dependendo da arquitetura. <br><br>  Valor de retorno: <br>  Esta chamada de servi√ßo retorna o n√≠vel anterior de interrup√ß√µes ativadas. <br><br>  <b><i>Definindo o vetor de interrup√ß√£o</i></b> <br><br>  Essa sobrecarga substitui o vetor de interrup√ß√£o especificado pelo vetor controlado pelo manipulador de interrup√ß√µes. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Par√¢metros: <br><br>  <b>vector</b> - <b>vetor de</b> interrup√ß√£o para o qual a interrup√ß√£o ser√° registrada; <br>  <b>new</b> √© o manipulador de interrup√ß√£o escrito para o vetor. <br><br>  Valor de retorno: <br><br>  Essa chamada de utilit√°rio retorna um ponteiro para o manipulador de interrup√ß√µes registrado anteriormente para o vetor de interrup√ß√£o. <br><br>  <b><i>Registro de interrup√ß√£o de baixo n√≠vel</i></b> <br><br>  Essa sobrecarga chama a fun√ß√£o do manipulador de interrup√ß√£o de baixo n√≠vel com o vetor de interrup√ß√£o.  O contexto do sistema √© salvo automaticamente antes que o manipulador de interrup√ß√£o de baixo n√≠vel especificado seja chamado e restaurado ap√≥s a conclus√£o do manipulador de interrup√ß√£o. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Par√¢metros: <br><br>  <b>vector</b> - <b>vetor de</b> interrup√ß√£o para o qual a interrup√ß√£o ser√° registrada; <br>  <b>lisr_entry</b> - a fun√ß√£o que ser√° registrada para o vetor, o valor <b>NU_NULL</b> limpar√° o vetor; <br>  <b>old_lisr</b> √© uma fun√ß√£o registrada anteriormente para o vetor especificado. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_VECTOR</b> - vetor inv√°lido; <br>  <b>NU_NOT_Rector</b> - no momento o vetor n√£o est√° registrado, pois o <b>cancelamento</b> de registro foi especificado em l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - O n√∫mero m√°ximo de manipuladores de interrup√ß√£o de baixo n√≠vel registrados foi atingido. <br><br>  <b><i>Criando um manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br>  Essa chamada de utilit√°rio cria um manipulador de interrup√ß√£o de alto n√≠vel. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Par√¢metros: <br><br>  <b>hisr</b> - um ponteiro para um bloco de controle fornecido pelo usu√°rio para um manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>name</b> - ponteiro para um nome de 7 caracteres para um manipulador de interrup√ß√£o de alto n√≠vel com um zero final; <br>  <b>hisr_entry</b> - o ponto de entrada da fun√ß√£o de manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>prioridade</b> - h√° tr√™s prioridades para manipuladores de interrup√ß√£o de alto n√≠vel (0-2);  a prioridade 0 √© a mais alta; <br>  <b>stack_pointer</b> - ponteiro para a √°rea de pilha do manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>stack_size</b> - o n√∫mero de bytes na pilha do manipulador de interrup√ß√µes de alto n√≠vel. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_HISR</b> - um ponteiro nulo para a unidade de controle do manipulador de interrup√ß√£o de alto n√≠vel ( <b>NULL</b> ) ou a unidade de controle j√° est√° em uso; <br>  <b>NU_INVALID_ENTRY</b> - um ponteiro nulo para o ponto de entrada de um manipulador de interrup√ß√£o de alto n√≠vel ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - prioridade incorreta para um manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>NU_INVALID_MEMORY</b> - ponteiro de pilha inv√°lido; <br>  <b>NU_INVALID_SIZE</b> - o tamanho da pilha √© muito pequeno. <br><br>  <b><i>Removendo um manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br>  Essa chamada de utilit√°rio remove o manipulador de interrup√ß√£o de alto n√≠vel criado anteriormente. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Par√¢metros: <br><br>  <b>hisr</b> √© um ponteiro para o bloco de controle do manipulador de interrup√ß√£o de alto n√≠vel fornecido pelo usu√°rio. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_HISR</b> - Ponteiro <b>inv√°lido</b> para um manipulador de interrup√ß√£o de alto n√≠vel. <br><br>  <b><i>Ativando um manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br><br>  Essa chamada de utilit√°rio ativa um manipulador de interrup√ß√£o de alto n√≠vel.  Se o manipulador de interrup√ß√£o de alto n√≠vel especificado estiver sendo executado no momento, a solicita√ß√£o de ativa√ß√£o n√£o ser√° executada at√© que o manipulador pare de funcionar.  Um manipulador de interrup√ß√£o de alto n√≠vel √© executado uma vez para cada solicita√ß√£o de ativa√ß√£o. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Par√¢metros: <br><br>  <b>hisr</b> √© um ponteiro para o bloco de controle de um manipulador de interrup√ß√£o de alto n√≠vel. <br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_HISR</b> - ponteiro inv√°lido para a unidade de controle de um manipulador de interrup√ß√£o de alto n√≠vel. <br><br>  <b><i>Obtendo o n√∫mero de manipuladores de interrup√ß√£o de alto n√≠vel em um sistema</i></b> <br>  Essa chamada de utilit√°rio retorna o n√∫mero de manipuladores de interrup√ß√£o de alto n√≠vel instalados.  Todos os manipuladores de interrup√ß√£o de alto n√≠vel criados s√£o considerados instalados.  Manipuladores de interrup√ß√£o remotos de alto n√≠vel n√£o s√£o considerados instalados. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Par√¢metros: <br>  Est√£o ausentes. <br><br>  Valor de retorno: <br>  Essa chamada de utilit√°rio retorna o n√∫mero de manipuladores de interrup√ß√£o de alto n√≠vel instalados no sistema. <br><br>  <b><i>Obtendo ponteiros para controlar blocos de manipuladores de interrup√ß√£o de alto n√≠vel</i></b> <br><br>  Essa chamada de servi√ßo forma uma lista seq√ºencial de ponteiros para todos os manipuladores de interrup√ß√£o de alto n√≠vel instalados no sistema. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Par√¢metros: <br><br>  <b>pointer_list</b> - ponteiro para uma matriz de ponteiros <b>NU_HISR</b> ;  essa matriz ser√° preenchida com ponteiros para os manipuladores de interrup√ß√£o de alto n√≠vel instalados no sistema; <br>  <b>maximum_pointers</b> - o n√∫mero m√°ximo de ponteiros <b>NU_HISR</b> que podem ser colocados na matriz;  geralmente √© igual ao tamanho da matriz <b>pointer_list</b> . <br><br>  Valor de retorno: <br>  Essa chamada de utilit√°rio retorna o n√∫mero de manipuladores de interrup√ß√£o de alto n√≠vel ativos no sistema. <br><br>  <b><i>Obtendo um ponteiro para o atual manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br>  Essa chamada de utilit√°rio retorna um ponteiro para o manipulador de interrup√ß√£o de alto n√≠vel em execu√ß√£o no momento. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Par√¢metros: <br>  Est√£o ausentes. <br><br>  Valor de retorno: <br>  Essa chamada de servi√ßo retorna um ponteiro para a unidade de controle do manipulador de interrup√ß√£o de alto n√≠vel em execu√ß√£o no momento.  Se um manipulador de interrup√ß√£o de n√≠vel n√£o alto chamar essa fun√ß√£o, <b>NU_NULL ser√°</b> retornado. <br><br>  <b><i>Obtendo informa√ß√µes sobre um manipulador de interrup√ß√£o de alto n√≠vel</i></b> <br>  Essa chamada de utilit√°rio retorna v√°rias informa√ß√µes sobre o manipulador de interrup√ß√£o de alto n√≠vel especificado. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Par√¢metros: <br><br>  <b>hisr</b> - um ponteiro para um manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>name</b> - ponteiro para a regi√£o de 8 caracteres para o nome do manipulador de interrup√ß√£o de alto n√≠vel, incluindo o zero final; <br>  <b>schedule_count</b> - ponteiro para uma vari√°vel pelo n√∫mero total de vezes que esse manipulador de interrup√ß√£o de alto n√≠vel foi agendado; <br>  <b>prioridade</b> - um ponteiro para uma vari√°vel para armazenar a prioridade de um manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>stack_base</b> - ponteiro para um ponteiro para armazenar o ponteiro original na pilha;  esse √© o mesmo ponteiro que foi passado ao criar o manipulador de interrup√ß√£o de alto n√≠vel; <br>  <b>stack_size</b> - um ponteiro para uma vari√°vel para armazenar o tamanho total da pilha de um manipulador de interrup√ß√£o de alto n√≠vel; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um ponteiro para uma vari√°vel para armazenar a quantidade m√≠nima de espa√ßo dispon√≠vel na pilha detectada durante a execu√ß√£o de um manipulador de interrup√ß√£o de alto n√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a chamada foi conclu√≠da com sucesso; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ponteiro </font><b><font style="vertical-align: inherit;">inv√°lido</font></b><font style="vertical-align: inherit;"> para um manipulador de interrup√ß√£o de alto n√≠vel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chamadas de API de manipuladores de interrup√ß√£o </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamada de API de manipuladores de interrup√ß√£o de baixo n√≠vel Um manipulador de interrup√ß√£o de baixo n√≠vel</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode usar apenas os seguintes recursos do Nucleus RTOS:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas de servi√ßo da API de manipuladores de interrup√ß√£o de alto n√≠vel Os manipuladores de interrup√ß√£o de</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alto n√≠vel t√™m acesso √† maioria das fun√ß√µes do Nucleus RTOS, exceto para fun√ß√µes de pausa autom√°tica, uma vez que um manipulador de interrup√ß√£o de alto n√≠vel n√£o pode suspender a fun√ß√£o Nucleus RTOS, o par√¢metro sempre deve ser</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥ximo artigo desta s√©rie abordar√° os procedimentos de inicializa√ß√£o e inicializa√ß√£o do Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre o autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls trabalha na ind√∫stria eletr√¥nica h√° mais de trinta anos, passando a maior parte do tempo em firmware. </font><font style="vertical-align: inherit;">Ele agora √© engenheiro de firmware na Mentor Embedded (uma divis√£o da Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls frequentemente fala em confer√™ncias e semin√°rios, autor de v√°rios artigos t√©cnicos e dois livros sobre firmware. </font><font style="vertical-align: inherit;">Vive no Reino Unido. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profissional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458770/">https://habr.com/ru/post/pt458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458758/index.html">O esplendor e a pobreza da literatura traduzida</a></li>
<li><a href="../pt458760/index.html">A exposi√ß√£o de Las Vegas √© para desenvolvedores de eletr√¥nicos, n√£o para consumidores. Um relat√≥rio da Design Automation Conference</a></li>
<li><a href="../pt458764/index.html">Pr√°ticas √°geis b√°sicas para equipes t√©cnicas e n√£o t√©cnicas em 2019</a></li>
<li><a href="../pt458766/index.html">IronPython do lado do mal: como descobrimos um ataque cibern√©tico a servi√ßos p√∫blicos em um pa√≠s europeu</a></li>
<li><a href="../pt458768/index.html">5-6 raz√µes para vir para GolangConf</a></li>
<li><a href="../pt458774/index.html">DBMS funcional</a></li>
<li><a href="../pt458778/index.html">Mecanismo de relat√≥rios do Satellite 6.5: o que e por qu√™</a></li>
<li><a href="../pt458782/index.html">Adapta√ß√£o de programas do ZX Spectrum ao TR-DOS por meios modernos. Parte 3</a></li>
<li><a href="../pt458784/index.html">Transmita projetos e bibliotecas do Altium Designer para o PADS Professional</a></li>
<li><a href="../pt458786/index.html">Os mantenedores de videogame mant√™m a cultura do jogo passo a passo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>