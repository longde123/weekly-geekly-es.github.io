<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏻 👩🏻‍🤝‍👨🏾 🔈 Toda a verdade sobre o RTOS. Artigo 29. Interrupções no Núcleo SE 🛠️ 👺 🧑🏾‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os microprocessadores e microcontroladores modernos contêm algum tipo de mecanismo de interrupção. Esses mecanismos são necessários para fornece...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 29. Interrupções no Núcleo SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/">  Todos os microprocessadores e microcontroladores modernos contêm algum tipo de mecanismo de interrupção.  Esses mecanismos são necessários para fornecer a capacidade de resposta exigida por muitos aplicativos.  Obviamente, responsividade e previsibilidade são o principal objetivo ao usar o RTOS, mas ao mesmo tempo se opõem.  O uso de interrupções pode prejudicar a integridade do sistema operacional em tempo real.  Esse problema e sua solução foram mencionados em um dos artigos anteriores (nºs 4 e 6).  Neste artigo, veremos a estratégia de manipulação de interrupções usada no Nucleus SE.  Em todos os casos, as interrupções NÃO são controladas pelo Nucleus SE: são processadas quando ocorrem de acordo com a prioridade e os vetores da maneira usual.  Seu tempo de execução é simplesmente "roubado" do tempo disponível no código do aplicativo principal e do planejador.  Obviamente, segue-se que todos os manipuladores de interrupção devem ser simples, curtos e rápidos. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores da série:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Temporizadores de software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 27</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais de Dados: Introdução e Serviços Básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: serviços auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: Introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Semáforos: Serviços Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Semáforos: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 18</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Serviços Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Introdução e Serviços Básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Signals</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Partições de memória: serviços e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seções de memória: introdução e serviços básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API não suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serviços para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configuração e introdução à API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avançados e preservação de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Projeto Interno e Implantação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Núcleo SE: Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros serviços RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interação e sincronização de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, alternância de contexto e interrupções</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdução.</a> <br></div></div><br><h2>  Interrupções regulares e controladas </h2><br>  O Nucleus SE oferece duas maneiras de lidar com interrupções: "nativo" ou "regular" (Nativo), nas quais as interrupções não são nada de especial e, em certa medida, têm interação limitada com o SO (pelo menos ao usar o agendador prioritário) e " Gerenciado, no qual você pode acessar um número muito maior de chamadas de API do manipulador de interrupções. <br><br>  Usando as macros de E / S, o manipulador de interrupção Nucleus SE pode ser usado no modo padrão ou gerenciado. <br><br><h3>  Interrupção do pessoal </h3><br>  As interrupções da equipe do Núcleo SE são o manipulador de interrupção padrão e podem ser consideradas "não gerenciadas".  Eles geralmente são usados ​​quando a interrupção pode ocorrer com alta frequência e requer processamento com baixo uso de recursos de computação.  Esse manipulador provavelmente é escrito em C, pois muitos compiladores incorporados modernos suportam o desenvolvimento de manipuladores de interrupção usando a palavra-chave interrupt.  Somente as informações contextuais que o compilador considera necessárias são armazenadas.  Isso leva a limitações significativas sobre o que os manipuladores de interrupção padrão podem fazer, o que veremos em breve. <br><br>  Para criar um manipulador de interrupção regular no Nucleus SE, basta escrever um manipulador de interrupção regular, incluindo chamar a macro <b>NUSE_NISR_Enter ()</b> no início e chamar <b>NUSE_NISR_Exit ()</b> no final.  Essas macros são definidas no arquivo <b>nuse_types.</b>  he defina a variável global <b>NUSE_Task_State</b> como <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Interrupções guiadas </h3><br>  Se você precisar de mais flexibilidade para operações do manipulador de interrupções, as interrupções gerenciadas do Nucleus SE podem ser a solução.  A principal diferença da interrupção padrão é manter o contexto.  Em vez de permitir que o compilador salve vários registros na pilha, uma interrupção controlada salva o contexto inteiro da tarefa (em seu próprio bloco de contexto) na entrada.  Em seguida, o contexto da tarefa atual é restaurado do bloco de contexto na saída.  Isso fornece a capacidade de alterar a tarefa atual pelo trabalho do código do manipulador de interrupções, o que é possível ao usar o planejador de prioridades.  Uma descrição completa da preservação e restauração do contexto no Nucleus SE foi fornecida em um artigo anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 10</a> ). <br><br>  Obviamente, a preservação total do contexto implica um aumento no uso de recursos de computação em comparação com o armazenamento de vários registros na pilha, o que ocorre durante uma interrupção padrão.  Esse preço deve ser pago por uma flexibilidade adicional, e é por isso que é fornecida uma opção de abordagem de manipulação de interrupção. <br><br>  Uma interrupção gerenciada é criada usando a macro <b>NUSE_MANAGED_ISR ()</b> descrita em <b>nuse_types.h</b> .  Essa macro cria uma função que contém as seguintes ações: <br><br><ul><li>  manter o contexto da tarefa; </li><li>  Atribuindo <b>NUSE_Task_State a</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  código de função do manipulador de interrupções fornecido pelo usuário; </li><li>  restaurando <b>NUSE_Task_State</b> para seu estado anterior; </li><li>  restaurar o contexto da tarefa. </li></ul><br>  A macro usa dois parâmetros: o nome da interrupção usado como o nome da função para o manipulador gerado e o nome da função que contém a lógica do usuário para o manipulador de interrupções. <br><br><h3>  Chamadas de API do manipulador de interrupções </h3><br>  O conjunto de funções da API que podem ser chamadas de um manipulador de interrupção padrão ou gerenciado depende de qual planejador é usado.  Em termos gerais, o uso do agendador prioritário fornece muitas opções para acessar o agendador por meio de uma chamada de função da API, o que é difícil ao usar o manipulador de interrupção padrão. <br><br>  <b><i>Chamadas de API para o manipulador de interrupção padrão ao usar o planejador de prioridade</i></b> <br><br>  Ao usar o planejador de prioridade, é permitido um número limitado de chamadas de função da API do manipulador de interrupção padrão.  Essa limitação é o resultado da flexibilidade da API do Nucleus SE: muitas chamadas podem fazer com que a tarefa fique pronta e o planejador não pode ser chamado pelo manipulador de interrupção padrão (já que o contexto da tarefa não é salvo).  Desativar bloqueios de tarefas fornece ainda mais flexibilidade. <br><br>  As seguintes chamadas de API são sempre permitidas: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  No entanto, apenas <b>NUSE_Signals_Send ()</b> é útil para eles, pois fornece uma maneira conveniente de indicar à tarefa que alguma ação é necessária. <br><br>  Se o bloqueio estiver desativado, ou seja, as tarefas não poderão ser colocadas em estado de prontidão por muitas chamadas de API, outras chamadas de API estarão disponíveis: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Algumas chamadas de API são sempre inacessíveis aos manipuladores de interrupção padrão, pois inevitavelmente exigem o trabalho de um agendador: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>Chamadas de API para o manipulador de interrupções gerenciado ou manipulador de interrupção padrão ao usar qualquer agendador que não seja o agendador de prioridade</i></b> <br><br>  Muitas outras funções da API podem ser chamadas a partir do manipulador de interrupções ao usar os agendadores Run to Completion, Round Robin ou Time Slice.  Se um agendador de prioridade for usado, os manipuladores de interrupção gerenciados terão um conjunto semelhante de funções.  Isso ocorre porque as chamadas são permitidas, o que pode levar ao agendamento de outra tarefa.  Esse recurso é fornecido pelo código <b>NUSE_Reschedule ()</b> , que detecta o contexto de chamada no manipulador de interrupções e suprime a alteração de contexto (permitindo que isso aconteça no final do manipulador de interrupções).  Uma análise completa do trabalho do agendador foi apresentada em um dos artigos anteriores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nº 9</a> ). <br><br>  O principal requisito é que as chamadas de API dentro do manipulador de interrupções não levem à suspensão da tarefa atual, por exemplo, aguardando a liberação de um recurso. <br><br>  Em outras palavras, essas chamadas devem ser feitas com a <b>opção de</b> pausa <b>NUSE_NO_SUSPEND</b> . <br><br>  Com isso em mente, as seguintes chamadas de API podem ser usadas: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Algumas chamadas são sempre barradas, pois estão diretamente relacionadas à tarefa atual: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Manipulador de interrupção de relógio em tempo real </h2><br>  O manipulador de interrupção do Real Time Clock (RTC) é o único manipulador de interrupção completo no Nucleus SE.  Além de fornecer toda a funcionalidade necessária para o gerenciamento de tempo no Nucleus SE, também serve como exemplo de gravação de um manipulador de interrupções gerenciado. <br><br><h3>  Operações do manipulador de interrupção RTC </h3><br>  As funções fornecidas pelo manipulador de interrupções do RTC foram listadas em um dos artigos anteriores, que tratavam do amplo tópico de hora do sistema no Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="># 27</a> ).  A funcionalidade descrita é opcional, dependendo da configuração do aplicativo. <br><br><div class="spoiler">  <b class="spoiler_title">A seguir está o código completo do manipulador de interrupção do RTC.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  A seguir, analisamos quatro áreas principais de funcionalidade do manipulador de interrupções RTC. <br><br>  <b><i>Temporizadores</i></b> <br>  Se os cronômetros do aplicativo estiverem configurados, o manipulador de interrupção entrará em um loop para processar cada cronômetro, diminuindo seu contador em 1. Se o cronômetro terminar a contagem (ou seja, o contador atingir 0), duas ações serão possíveis: <br><br><ul><li>  se o manipulador de conclusão do timer estiver configurado e o cronômetro tiver um ponteiro de função correto (não <b>NULL</b> ) (em <b>NUSE_Timer_Expiration_Routine_Address []</b> ), o manipulador será executado usando um parâmetro de <b>NUSE_Timer_Expiration_Routine_Parameter []</b> ; </li><li>  se o cronômetro estiver configurado para inicializar após a conclusão (ou seja, <b>NUSE_Timer_Reschedule_Time []</b> possui um valor diferente de zero), o cronômetro será recarregado com esse valor. </li></ul><br>  Os cronômetros de aplicativos foram descritos em detalhes em um artigo anterior (nº 28). <br><br>  <b><i>Relógio do sistema</i></b> <br>  Se um timer do sistema estiver configurado, o valor de <b>NUSE_Tick_Cloc</b> k simplesmente aumentará em 1. Mais informações podem ser encontradas no artigo # 28. <br><br>  <b><i>Suspender uma tarefa (repouso da tarefa)</i></b> <br>  Se o suporte para pausar tarefas estiver ativado (ou seja, a chamada da API <b>NUSE_Task_Sleep ()</b> estiver configurada), o contador de tempo limite de cada tarefa (o valor em <b>NUSE_Task_Timeout_Counter []</b> ) será verificado e, se não for igual a zero, diminui em 1. Se atingir zero, a tarefa correspondente será retomada. . <br><br>  <b><i>Agendamento de intervalo de tempo</i></b> <br>  Se um agendador do Time Slice for usado, o contador do agendador ( <b>NUSE_Time_Slice_Ticks</b> ) será diminuído.  Se atingir zero, o agendador é chamado.  A chamada para <b>NUSE_Reschedule ()</b> é responsável por redefinir o contador. <br><br><h3>  Interrupção controlada </h3><br>  É necessário explicar por que o manipulador de interrupções do RTC é controlável, pois, sob certas circunstâncias, o usuário pode decidir reescrevê-lo como uma interrupção padrão para reduzir o uso de recursos de computação.  Por exemplo, se apenas uma função de hora do sistema for usada (ou seja, não houver cronômetros de aplicativo, não houver suspensões de tarefas e não houver agendador de Time Slice), uma interrupção regular funcionará.  A interrupção guiada é necessária nos seguintes casos: <br><br><ul><li>  se os temporizadores forem usados ​​e os manipuladores para sua conclusão estiverem configurados, pois esses manipuladores podem fazer chamadas de API (no contexto de interrupção), o que causará um novo agendamento.  Eles têm as mesmas limitações que as chamadas de API feitas a partir de manipuladores de interrupção (veja anteriormente neste artigo); </li><li>  se um agendador de prioridade for usado, a conclusão de uma suspensão de tarefa poderá exigir a ativação de uma tarefa com prioridade mais alta; </li><li>  se o agendador do Time Slice for usado, ele será chamado a partir do manipulador de interrupções do RTC; portanto, é necessária uma interrupção controlada. </li></ul><br><h2>  Compatível com núcleo RTOS </h2><br>  Como a implementação das interrupções do Nucleus SE é muito diferente do Nucleus RTOS, você não deve esperar compatibilidade nesse sentido.  O Nucleus RTOS possui um esquema de interrupção padrão / de baixo nível / alto nível, que é um pouco como o esquema de interrupção padrão / controlado no Nucleus SE. <br><br><h3>  Manipuladores de interrupção de baixo e alto nível </h3><br>  <b><i>Manipuladores de interrupção de baixo nível</i></b> <br>  Uma Rotina de Serviço de Interrupção de Baixo Nível (LISR) é executada da mesma maneira que um manipulador regular, incluindo o uso da pilha atual.  O núcleo RTOS mantém o contexto até que o manipulador de interrupção de baixo nível seja chamado e restaura o contexto após a conclusão do manipulador.  Portanto, um manipulador de interrupção de baixo nível pode ser gravado em C e chamar outros manipuladores em C. No entanto, apenas alguns serviços Nucleus RTOS estão disponíveis para o manipulador de baixo nível.  Se a manipulação de interrupções exigir serviços adicionais do Nucleus RTOS, você precisará ativar um manipulador de interrupções de alto nível.  O Nucleus RTOS suporta o uso de vários manipuladores de interrupção de baixo nível. <br><br>  <b><i>Manipulador de interrupção de alto nível</i></b> <br>  A Rotina de Serviço de Interrupção de Alto Nível (HISR) é criada e excluída dinamicamente.  Cada processador de alto nível possui seu próprio espaço de pilha e sua própria unidade de controle.  A memória é alocada pelo aplicativo.  E, é claro, um manipulador de interrupção de alto nível deve ser criado antes que um manipulador de interrupção de baixo nível possa ativá-lo. <br><br>  Como o manipulador de interrupção de alto nível possui sua própria pilha e unidade de controle, ele pode ser temporariamente bloqueado se tentar acessar a estrutura de dados do Nucleus RTOS atualmente em uso. <br><br>  Existem três níveis de prioridade disponíveis para um manipulador de interrupção de alto nível.  Se um manipulador de nível superior com uma prioridade mais alta for ativado durante o trabalho de um manipulador com uma prioridade mais baixa, um manipulador com uma prioridade mais baixa será executado à medida que a tarefa for concluída.  Manipuladores de interrupção de alto nível com a mesma prioridade são executados na ordem em que são ativados.  Todos os manipuladores de interrupção de alto nível ativados devem ser concluídos antes de continuar a agendar tarefas no modo normal. <br><br><h3>  Utilitário de API do núcleo RTOS solicita interrupção </h3><br>  O núcleo RTOS possui várias chamadas de API para oferecer suporte a interrupções.  Nenhum deles é implementado no Nucleus SE. <br><br>  Para interrupções padrão, as chamadas de API fornecem as seguintes funções: <br><br><ul><li>  controle (ativação / desativação) de interrupção (local e globalmente); </li><li>  definindo o vetor de interrupção. </li></ul><br>  Para interrupções de baixo nível: <br><br><ul><li>  registrando um manipulador de interrupção de baixo nível no kernel. </li></ul><br>  Para interrupções de alto nível: <br><br><ul><li>  criação / remoção de interrupções de alto nível; </li><li>  ativação de interrupção de alto nível; </li><li>  obtendo o número de interrupções de alto nível no aplicativo (no momento); </li><li>  obter indicadores para controlar unidades de todas as interrupções de alto nível; </li><li>  obter indicadores para controlar as unidades da atual interrupção de alto nível; </li><li>  Obtendo informações de interrupção de alto nível. </li></ul><br>  <b><i>Controle global de interrupção</i></b> <br><br>  Essa chamada ativa ou desativa interrupções, independentemente da tarefa.  Portanto, a interrupção desativada por esta chamada permanecerá assim até que seja ativada reutilizando essa chamada. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Parâmetros: <br><br>  <b>new_level</b> - um novo nível de interrupção para o sistema.  Ele sempre pode aceitar os valores <b>NU_DISABLE_INTERRUPTS</b> (desativa todas as interrupções) e <b>NU_ENABLE_INTERRUPTS</b> (ativa todas as interrupções).  Outros valores podem estar disponíveis, dependendo da arquitetura. <br><br>  Valor de retorno: <br><br>  Esta chamada de serviço retorna o nível anterior de interrupções ativadas. <br><br>  <b><i>Controle de interrupção local</i></b> <br><br>  Essa chamada de serviço permite ativar ou desativar as interrupções, dependendo da tarefa.  Essa chamada altera o registro de status para o valor especificado.  O registro de status retornará ao valor especificado pela última chamada para <b>NU_Control_Interrupts () na</b> próxima vez que o contexto for alterado. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Parâmetros: <br><br>  <b>new_level</b> - um novo nível de interrupção para a tarefa atual.  Ele sempre pode aceitar os valores <b>NU_DISABLE_INTERRUPTS</b> (desativa todas as interrupções) e <b>NU_ENABLE_INTERRUPTS</b> (ativa todas as interrupções).  Outros valores podem estar disponíveis, dependendo da arquitetura. <br><br>  Valor de retorno: <br>  Esta chamada de serviço retorna o nível anterior de interrupções ativadas. <br><br>  <b><i>Definindo o vetor de interrupção</i></b> <br><br>  Essa sobrecarga substitui o vetor de interrupção especificado pelo vetor controlado pelo manipulador de interrupções. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Parâmetros: <br><br>  <b>vector</b> - <b>vetor de</b> interrupção para o qual a interrupção será registrada; <br>  <b>new</b> é o manipulador de interrupção escrito para o vetor. <br><br>  Valor de retorno: <br><br>  Essa chamada de utilitário retorna um ponteiro para o manipulador de interrupções registrado anteriormente para o vetor de interrupção. <br><br>  <b><i>Registro de interrupção de baixo nível</i></b> <br><br>  Essa sobrecarga chama a função do manipulador de interrupção de baixo nível com o vetor de interrupção.  O contexto do sistema é salvo automaticamente antes que o manipulador de interrupção de baixo nível especificado seja chamado e restaurado após a conclusão do manipulador de interrupção. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Parâmetros: <br><br>  <b>vector</b> - <b>vetor de</b> interrupção para o qual a interrupção será registrada; <br>  <b>lisr_entry</b> - a função que será registrada para o vetor, o valor <b>NU_NULL</b> limpará o vetor; <br>  <b>old_lisr</b> é uma função registrada anteriormente para o vetor especificado. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_INVALID_VECTOR</b> - vetor inválido; <br>  <b>NU_NOT_Rector</b> - no momento o vetor não está registrado, pois o <b>cancelamento</b> de registro foi especificado em l <b>isr_entry</b> ; <br>  <b>NO_MORE_LISRS</b> - O número máximo de manipuladores de interrupção de baixo nível registrados foi atingido. <br><br>  <b><i>Criando um manipulador de interrupção de alto nível</i></b> <br>  Essa chamada de utilitário cria um manipulador de interrupção de alto nível. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Parâmetros: <br><br>  <b>hisr</b> - um ponteiro para um bloco de controle fornecido pelo usuário para um manipulador de interrupção de alto nível; <br>  <b>name</b> - ponteiro para um nome de 7 caracteres para um manipulador de interrupção de alto nível com um zero final; <br>  <b>hisr_entry</b> - o ponto de entrada da função de manipulador de interrupção de alto nível; <br>  <b>prioridade</b> - há três prioridades para manipuladores de interrupção de alto nível (0-2);  a prioridade 0 é a mais alta; <br>  <b>stack_pointer</b> - ponteiro para a área de pilha do manipulador de interrupção de alto nível; <br>  <b>stack_size</b> - o número de bytes na pilha do manipulador de interrupções de alto nível. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_INVALID_HISR</b> - um ponteiro nulo para a unidade de controle do manipulador de interrupção de alto nível ( <b>NULL</b> ) ou a unidade de controle já está em uso; <br>  <b>NU_INVALID_ENTRY</b> - um ponteiro nulo para o ponto de entrada de um manipulador de interrupção de alto nível ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - prioridade incorreta para um manipulador de interrupção de alto nível; <br>  <b>NU_INVALID_MEMORY</b> - ponteiro de pilha inválido; <br>  <b>NU_INVALID_SIZE</b> - o tamanho da pilha é muito pequeno. <br><br>  <b><i>Removendo um manipulador de interrupção de alto nível</i></b> <br>  Essa chamada de utilitário remove o manipulador de interrupção de alto nível criado anteriormente. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Parâmetros: <br><br>  <b>hisr</b> é um ponteiro para o bloco de controle do manipulador de interrupção de alto nível fornecido pelo usuário. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_INVALID_HISR</b> - Ponteiro <b>inválido</b> para um manipulador de interrupção de alto nível. <br><br>  <b><i>Ativando um manipulador de interrupção de alto nível</i></b> <br><br>  Essa chamada de utilitário ativa um manipulador de interrupção de alto nível.  Se o manipulador de interrupção de alto nível especificado estiver sendo executado no momento, a solicitação de ativação não será executada até que o manipulador pare de funcionar.  Um manipulador de interrupção de alto nível é executado uma vez para cada solicitação de ativação. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Parâmetros: <br><br>  <b>hisr</b> é um ponteiro para o bloco de controle de um manipulador de interrupção de alto nível. <br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi concluída com sucesso; <br>  <b>NU_INVALID_HISR</b> - ponteiro inválido para a unidade de controle de um manipulador de interrupção de alto nível. <br><br>  <b><i>Obtendo o número de manipuladores de interrupção de alto nível em um sistema</i></b> <br>  Essa chamada de utilitário retorna o número de manipuladores de interrupção de alto nível instalados.  Todos os manipuladores de interrupção de alto nível criados são considerados instalados.  Manipuladores de interrupção remotos de alto nível não são considerados instalados. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Parâmetros: <br>  Estão ausentes. <br><br>  Valor de retorno: <br>  Essa chamada de utilitário retorna o número de manipuladores de interrupção de alto nível instalados no sistema. <br><br>  <b><i>Obtendo ponteiros para controlar blocos de manipuladores de interrupção de alto nível</i></b> <br><br>  Essa chamada de serviço forma uma lista seqüencial de ponteiros para todos os manipuladores de interrupção de alto nível instalados no sistema. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Parâmetros: <br><br>  <b>pointer_list</b> - ponteiro para uma matriz de ponteiros <b>NU_HISR</b> ;  essa matriz será preenchida com ponteiros para os manipuladores de interrupção de alto nível instalados no sistema; <br>  <b>maximum_pointers</b> - o número máximo de ponteiros <b>NU_HISR</b> que podem ser colocados na matriz;  geralmente é igual ao tamanho da matriz <b>pointer_list</b> . <br><br>  Valor de retorno: <br>  Essa chamada de utilitário retorna o número de manipuladores de interrupção de alto nível ativos no sistema. <br><br>  <b><i>Obtendo um ponteiro para o atual manipulador de interrupção de alto nível</i></b> <br>  Essa chamada de utilitário retorna um ponteiro para o manipulador de interrupção de alto nível em execução no momento. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Parâmetros: <br>  Estão ausentes. <br><br>  Valor de retorno: <br>  Essa chamada de serviço retorna um ponteiro para a unidade de controle do manipulador de interrupção de alto nível em execução no momento.  Se um manipulador de interrupção de nível não alto chamar essa função, <b>NU_NULL será</b> retornado. <br><br>  <b><i>Obtendo informações sobre um manipulador de interrupção de alto nível</i></b> <br>  Essa chamada de utilitário retorna várias informações sobre o manipulador de interrupção de alto nível especificado. <br><br>  Protótipo de chamada de serviço: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Parâmetros: <br><br>  <b>hisr</b> - um ponteiro para um manipulador de interrupção de alto nível; <br>  <b>name</b> - ponteiro para a região de 8 caracteres para o nome do manipulador de interrupção de alto nível, incluindo o zero final; <br>  <b>schedule_count</b> - ponteiro para uma variável pelo número total de vezes que esse manipulador de interrupção de alto nível foi agendado; <br>  <b>prioridade</b> - um ponteiro para uma variável para armazenar a prioridade de um manipulador de interrupção de alto nível; <br>  <b>stack_base</b> - ponteiro para um ponteiro para armazenar o ponteiro original na pilha;  esse é o mesmo ponteiro que foi passado ao criar o manipulador de interrupção de alto nível; <br>  <b>stack_size</b> - um ponteiro para uma variável para armazenar o tamanho total da pilha de um manipulador de interrupção de alto nível; <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimum_stack</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um ponteiro para uma variável para armazenar a quantidade mínima de espaço disponível na pilha detectada durante a execução de um manipulador de interrupção de alto nível. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a chamada foi concluída com sucesso; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ponteiro </font><b><font style="vertical-align: inherit;">inválido</font></b><font style="vertical-align: inherit;"> para um manipulador de interrupção de alto nível.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chamadas de API de manipuladores de interrupção </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamada de API de manipuladores de interrupção de baixo nível Um manipulador de interrupção de baixo nível</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode usar apenas os seguintes recursos do Nucleus RTOS:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamadas de serviço da API de manipuladores de interrupção de alto nível Os manipuladores de interrupção de</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alto nível têm acesso à maioria das funções do Nucleus RTOS, exceto para funções de pausa automática, uma vez que um manipulador de interrupção de alto nível não pode suspender a função Nucleus RTOS, o parâmetro sempre deve ser</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O próximo artigo desta série abordará os procedimentos de inicialização e inicialização do Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre o autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls trabalha na indústria eletrônica há mais de trinta anos, passando a maior parte do tempo em firmware. </font><font style="vertical-align: inherit;">Ele agora é engenheiro de firmware na Mentor Embedded (uma divisão da Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls frequentemente fala em conferências e seminários, autor de vários artigos técnicos e dois livros sobre firmware. </font><font style="vertical-align: inherit;">Vive no Reino Unido. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> profissional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">de Colin</font></a><font style="vertical-align: inherit;"> , e-mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458770/">https://habr.com/ru/post/pt458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458758/index.html">O esplendor e a pobreza da literatura traduzida</a></li>
<li><a href="../pt458760/index.html">A exposição de Las Vegas é para desenvolvedores de eletrônicos, não para consumidores. Um relatório da Design Automation Conference</a></li>
<li><a href="../pt458764/index.html">Práticas ágeis básicas para equipes técnicas e não técnicas em 2019</a></li>
<li><a href="../pt458766/index.html">IronPython do lado do mal: como descobrimos um ataque cibernético a serviços públicos em um país europeu</a></li>
<li><a href="../pt458768/index.html">5-6 razões para vir para GolangConf</a></li>
<li><a href="../pt458774/index.html">DBMS funcional</a></li>
<li><a href="../pt458778/index.html">Mecanismo de relatórios do Satellite 6.5: o que e por quê</a></li>
<li><a href="../pt458782/index.html">Adaptação de programas do ZX Spectrum ao TR-DOS por meios modernos. Parte 3</a></li>
<li><a href="../pt458784/index.html">Transmita projetos e bibliotecas do Altium Designer para o PADS Professional</a></li>
<li><a href="../pt458786/index.html">Os mantenedores de videogame mantêm a cultura do jogo passo a passo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>