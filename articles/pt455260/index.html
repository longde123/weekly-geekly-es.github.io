<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèæ üëÇüèª üéôÔ∏è √Årvore Merkle: enferrujado e r√°pido üì∑ ‚õ¥Ô∏è üôÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Descoberto recentemente a linguagem Rust. Ele compartilhou suas primeiras impress√µes em um artigo anterior . Agora eu decidi ir um pouco ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Årvore Merkle: enferrujado e r√°pido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455260/"><p><img src="https://habrastorage.org/webt/02/we/l8/02wel89vk_uuxibqbvaiimofkkk.png" alt="imagem"></p><br><p>  Ol√° pessoal!  Descoberto recentemente a linguagem Rust.  Ele compartilhou suas primeiras impress√µes em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> .  Agora eu decidi ir um pouco mais fundo, para isso voc√™ precisa de algo mais s√©rio do que a lista.  Minha escolha caiu na √°rvore Merkle.  Neste artigo eu quero: </p><br><ul><li>  falar sobre essa estrutura de dados </li><li>  veja o que Rust j√° tem </li><li>  ofere√ßa sua implementa√ß√£o </li><li>  comparar desempenho </li></ul><a name="habracut"></a><br><h1 id="derevo-merkla">  √Årvore Merkle </h1><br><p> Essa √© uma estrutura de dados relativamente simples e j√° existe muita informa√ß√£o na Internet, mas acho que meu artigo ficar√° incompleto sem uma descri√ß√£o da √°rvore. </p><br><h2 id="v-chyom-problema">  Qual √© o problema </h2><br><p>  A √°rvore Merkle foi inventada em 1979, mas ganhou popularidade gra√ßas ao blockchain.  A cadeia de blocos na rede √© muito grande (para bitcoin √© mais do que 200 GB), e nem todos os n√≥s podem us√°-lo.  Por exemplo, telefones ou caixas registradoras.  No entanto, eles precisam saber sobre o fato de incluir essa ou aquela transa√ß√£o no bloco.  Para isso, foi inventado o protocolo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SPV - Verifica√ß√£o Simplificada de Pagamento</a> . </p><br><h2 id="kak-ustroeno-derevo">  Como uma √°rvore funciona </h2><br><p>  Esta √© uma √°rvore bin√°ria cujas folhas s√£o hashes de qualquer objeto.  Para construir o pr√≥ximo n√≠vel, os hashes das folhas vizinhas s√£o coletados em pares, concatenados e o hash do resultado da concatena√ß√£o √© calculado, o que √© ilustrado na figura no cabe√ßalho.  Assim, a raiz da √°rvore √© um hash de todas as folhas.  Se voc√™ remover ou adicionar um elemento, a raiz mudar√°. </p><br><h2 id="kak-rabotaet-derevo">  Como funciona uma √°rvore? </h2><br><p>  Tendo uma √°rvore Merkle, √© poss√≠vel construir evid√™ncias da inclus√£o de uma transa√ß√£o em um bloco como um caminho de um hash de transa√ß√£o para a raiz.  Por exemplo, estamos interessados ‚Äã‚Äãna transa√ß√£o Tx2, pois a prova ser√° (Hash3, Hash01).  Esse mecanismo tamb√©m √© usado no SPV.  O cliente baixa apenas o cabe√ßalho do bloco com seu hash.  Tendo uma transa√ß√£o de interesse, ele solicita prova de um n√≥ que cont√©m toda a cadeia.  Ent√£o ele faz uma verifica√ß√£o, para Tx2 ser√°: </p><br><pre><code class="plaintext hljs">hash(Hash01, hash(Hash2, Hash3)) = Root Hash</code> </pre> <br><p>  O resultado √© comparado com a raiz do cabe√ßalho do bloco.  Essa abordagem torna imposs√≠vel falsificar evid√™ncias, pois nesse caso o resultado do teste n√£o converge para o conte√∫do do cabe√ßalho. </p><br><h1 id="kakie-uzhe-est-realizacii">  Quais implementa√ß√µes j√° existem </h1><br><p>  A ferrugem √© uma linguagem jovem, mas muitas realiza√ß√µes da √°rvore Merkle j√° est√£o escritas nela.  A julgar pelo Github, no momento 56, isso √© mais do que em C e C ++ combinados.  Embora o Go os fa√ßa stand-up com 80 implementa√ß√µes. </p><br><h2 id="spinresearchmerklershttpsgithubcomspinresearchmerklers">  <a href="">SpinResearch / merkle.rs</a> </h2><br><p>  Para minha compara√ß√£o, escolhi essa implementa√ß√£o pelo n√∫mero de estrelas no reposit√≥rio. </p><br><p>  Essa √°rvore √© constru√≠da da maneira mais √≥bvia, ou seja, √© um gr√°fico de objetos.  Como j√° observei, essa abordagem n√£o √© totalmente compat√≠vel com Rust.  Por exemplo, n√£o √© poss√≠vel fazer comunica√ß√£o bidirecional dos filhos para os pais. </p><br><p>  A constru√ß√£o da evid√™ncia ocorre atrav√©s de uma pesquisa em profundidade.  Se uma folha com o hash correto for encontrada, o caminho para ela ser√° o resultado. </p><br><h2 id="chto-mozhno-uluchshit">  O que pode ser melhorado </h2><br><p>  N√£o foi interessante para mim fazer uma implementa√ß√£o simples (n + 1) -√©sima, ent√£o pensei em otimiza√ß√£o.  O c√≥digo para minha <em>√°rvore de merkle de vetor</em> est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> . </p><br><h3 id="hranenie-dannyh">  Armazenamento de dados </h3><br><p>  A primeira coisa que vem √† mente √© mudar a √°rvore para uma matriz.  Essa solu√ß√£o ser√° muito melhor em termos de localidade dos dados: mais ocorr√™ncias de cache e melhor pr√©-carregamento.  Andar por objetos espalhados da mem√≥ria leva mais tempo.  Um fato conveniente √© que todos os hashes t√™m o mesmo comprimento, porque  calculado por um algoritmo.  A √°rvore Merkle na matriz ficar√° assim: <br><img src="https://habrastorage.org/webt/7_/in/4_/7_in4_ijawhhqj4f9pldunhl2mu.png" alt="imagem"></p><br><h3 id="dokazatelstvo">  Prova </h3><br><p>  Ao inicializar a √°rvore, voc√™ pode criar um HashMap com todos os √≠ndices de folhas.  Assim, quando n√£o h√° folha, n√£o √© necess√°rio contornar a √°rvore inteira e, se houver, voc√™ pode ir imediatamente para ela e subir √† raiz, construindo uma prova.  Na minha implementa√ß√£o, fiz o HashMap opcional. </p><br><h3 id="konkatenaciya-i-heshirovanie">  Concatena√ß√£o e hash </h3><br><p>  Parece que aqui pode ser melhorado?  Afinal, tudo est√° claro - pegue dois hashes, cole-os e calcule um novo hash.  Mas o fato √© que essa fun√ß√£o n√£o √© comutativa, ou seja,  hash (H0, H1) ‚â† hash (H1, H0).  Por isso, ao construir a prova, √© necess√°rio lembrar de que lado o n√≥ vizinho est√°.  Isso dificulta a implementa√ß√£o do algoritmo e adiciona a necessidade de armazenar dados redundantes.  Tudo √© muito f√°cil de corrigir, basta classificar os dois n√≥s antes do hash.  Por exemplo, citei Tx2, levando em considera√ß√£o a comutatividade, a verifica√ß√£o ser√° assim: </p><br><pre> <code class="plaintext hljs">hash(hash(Hash2, Hash3), Hash01) = Root Hash</code> </pre> <br><p>  Quando voc√™ n√£o precisa se preocupar com o pedido, o algoritmo de verifica√ß√£o se parece com uma convolu√ß√£o simples de uma matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { proof[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .fold( get_pair_hash(proof[<span class="hljs-number"><span class="hljs-number">0</span></span>], proof[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo), |a, b| get_pair_hash(a.as_ref(), b, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.algo) ).as_ref() == <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_root() }</code> </pre> <br><p>  O elemento zero √© o hash do objeto desejado, o primeiro √© seu vizinho. </p><br><h1 id="pognali">  Vamos l√°! </h1><br><p>  A hist√≥ria ficaria incompleta sem uma compara√ß√£o de desempenho, o que me levou v√°rias vezes mais que a implementa√ß√£o da √°rvore em si.  Para esses prop√≥sitos, usei a estrutura de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crit√©rios</a> .  As fontes dos pr√≥prios testes est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Todos os testes s√£o realizados atrav√©s da interface <em>TreeWrapper</em> , que foi implementada para os dois assuntos: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeWrapper</span></span></span></span>&lt;V&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Criterion, counts: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;, data: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;V&gt;&gt;, title: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>); }</code> </pre> <br><p>  Ambas as √°rvores trabalham com a mesma criptografia em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>anel</em></a> .  Aqui n√£o vou comparar bibliotecas diferentes.  Eu peguei o mais comum. </p><br><p>  Como objetos hash, seq√º√™ncias geradas aleatoriamente s√£o usadas.  As √°rvores s√£o comparadas em matrizes de v√°rios comprimentos: (500, 1000, 1500, 2000, 2500 3000).  2500 - 3000 √© o n√∫mero aproximado de transa√ß√µes no bloco de bitcoin no momento. </p><br><p>  Em todos os gr√°ficos, o eixo X indica o n√∫mero de elementos da matriz (ou o n√∫mero de transa√ß√µes no bloco) e o eixo Y representa o tempo m√©dio para concluir a opera√ß√£o em microssegundos.  Ou seja, quanto mais, pior. </p><br><h2 id="sozdanie-dereva">  Fabrica√ß√£o de √°rvores </h2><br><p>  O armazenamento de todos os dados da √°rvore em uma matriz excede muito o gr√°fico de desempenho dos objetos.  Para uma matriz com 500 elementos, 1,5 vezes, e para 3000 elementos j√° 3,6 vezes.  A natureza n√£o linear da depend√™ncia da complexidade do volume de dados de entrada na implementa√ß√£o padr√£o √© claramente vis√≠vel. </p><br><p>  Al√©m disso, em compara√ß√£o, adicionei duas variantes da √°rvore de vetores: com e sem <em>HashMap</em> .  O preenchimento de uma estrutura de dados adicional adiciona cerca de 20%, mas permite pesquisar objetos muito mais rapidamente ao criar evid√™ncias. <br><img src="https://habrastorage.org/webt/xk/nf/kj/xknfkjl5aqy8oqagfzaj05p1qo4.png" alt="imagem"></p><br><h2 id="postroenie-dokazatelstva">  Construindo evid√™ncias </h2><br><p>  Aqui voc√™ pode ver a √≥bvia inefici√™ncia da pesquisa em profundidade.  Com um aumento na entrada, isso s√≥ piora.  √â importante entender que os objetos que voc√™ est√° procurando s√£o folhas, para que n√£o haja complexidade de <em>log (n)</em> .  Se os dados forem pr√©-hash, o tempo de opera√ß√£o √© praticamente independente do n√∫mero de elementos.  Sem hash, a complexidade cresce linearmente e consiste em busca de for√ßa bruta. <br><img src="https://habrastorage.org/webt/py/lc/20/pylc206tjr1oraib8eynbeeatym.png" alt="imagem"></p><br><h2 id="validaciya-dokazatelstva">  Valida√ß√£o de evid√™ncia </h2><br><p>  Esta √© a √∫ltima opera√ß√£o.  N√£o depende da estrutura da √°rvore, porque  trabalha com o resultado da constru√ß√£o de evid√™ncias.  Acredito que a principal dificuldade aqui √© o c√°lculo de hash. <br><img src="https://habrastorage.org/webt/2h/n6/hk/2hn6hkfzrbhxnejuihg2xx2hpoc.png" alt="imagem"></p><br><h1 id="itog">  Sum√°rio </h1><br><ul><li>  A maneira como os dados s√£o armazenados afeta muito o desempenho.  Quando tudo em uma matriz √© muito mais r√°pido.  E serializar essa estrutura ser√° muito simples.  A quantidade total de c√≥digo tamb√©m √© reduzida. </li><li>  Concatenar n√≥s com a classifica√ß√£o simplifica bastante o c√≥digo, mas n√£o o torna mais r√°pido. </li></ul><br><h1 id="nemnogo-o-rust">  Um pouco sobre Rust </h1><br><ul><li>  Gostei da estrutura de <em>crit√©rios</em> .  D√° resultados claros com valores m√©dios e desvios equipados com gr√°ficos.  Capaz de comparar diferentes implementa√ß√µes do mesmo c√≥digo. </li><li>  A falta de heran√ßa n√£o interfere muito na vida. </li><li>  Macros s√£o um mecanismo poderoso.  Eu os usei em <a href="">meus testes</a> em <a href="">√°rvore</a> para parametriza√ß√£o.  Eu acho que se eles forem mal utilizados, voc√™ poder√° fazer algo que n√£o ser√° feliz mais tarde. </li><li>  Em alguns lugares, o compilador se entedia com suas verifica√ß√µes de mem√≥ria.  Minha suposi√ß√£o inicial de que come√ßar a escrever em Rust simplesmente n√£o funcionava estava correta. <br><img src="https://habrastorage.org/webt/1n/uw/mf/1nuwmfwfozbeosqyvhtmbybur7w.png" alt="imagem"></li></ul><br><h1 id="ssylki">  Refer√™ncias </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma descri√ß√£o mais completa do algoritmo da √°rvore Merkle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crit√©rio - estrutura de teste de carga</a> </li><li>  <a href="">merkle.rs - a √°rvore mais popular sob Rust</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vector-merkle-tree - implementa√ß√£o da minha √°rvore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">merkle-tree-test-rs - um projeto para comparar o desempenho de duas bibliotecas</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455260/">https://habr.com/ru/post/pt455260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455248/index.html">Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</a></li>
<li><a href="../pt455250/index.html">Aquele que ressuscitou Duke Nukem: entrevista com Randy Pitchford, m√°gico da Gearbox</a></li>
<li><a href="../pt455252/index.html">.NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1</a></li>
<li><a href="../pt455256/index.html">Habr Weekly # 4 / Computex, como beta da Apple, Durov est√° morrendo de fome, gato BadComedian, por que a rede neural procurou atores pornogr√°ficos</a></li>
<li><a href="../pt455258/index.html">Come√ßou a vota√ß√£o dos relat√≥rios da se√ß√£o Backend no anivers√°rio do DevConfX, que ser√° realizada de 21 a 22 de junho em Moscou</a></li>
<li><a href="../pt455264/index.html">Seja como Munch, ou algumas palavras sobre dever t√©cnico</a></li>
<li><a href="../pt455268/index.html">Como tudo come√ßou: displays flex√≠veis e dobr√°veis ‚Äã‚Äã- a hist√≥ria da apar√™ncia e sa√≠da de "pessoas"</a></li>
<li><a href="../pt455272/index.html">TheOutloud - D√™ voz e compartilhe seus artigos e hist√≥rias favoritas.</a></li>
<li><a href="../pt455274/index.html">Microsoft lan√ßa uma iniciativa educacional de larga escala nas universidades russas</a></li>
<li><a href="../pt455280/index.html">Resposta do psiquiatra ao artigo "Doente-saud√°vel"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>