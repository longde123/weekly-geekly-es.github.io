<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐧 👨‍👦‍👦 ⛓️ Buku "Bekerja dengan BigData di awan. Memproses dan menyimpan data dengan contoh-contoh dari Microsoft Azure » 👉🏾 ⬛️ 🛤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah buku berbahasa Rusia yang awalnya rahasia di mana rahasia memproses data besar (Big Data) di awan diperiksa dengan contoh nyata. 

 Fokusny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Bekerja dengan BigData di awan. Memproses dan menyimpan data dengan contoh-contoh dari Microsoft Azure »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428375/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/un/xm/vy/unxmvydwj2ybjfabsmi3vbdcnsg.jpeg" align="left" alt="gambar"></a>  Ini adalah buku berbahasa Rusia yang awalnya rahasia di mana rahasia memproses data besar (Big Data) di awan diperiksa dengan contoh nyata. <br><br>  Fokusnya adalah pada solusi Microsoft Azure dan AWS.  Semua tahapan pekerjaan dipertimbangkan - mendapatkan data yang disiapkan untuk diproses di cloud, menggunakan penyimpanan cloud, alat analisis data cloud.  Perhatian khusus diberikan pada layanan SAAS, keunggulan teknologi cloud dibandingkan dengan solusi yang digunakan pada server khusus atau mesin virtual. <br><br>  Buku ini dirancang untuk khalayak luas dan akan berfungsi sebagai sumber daya yang sangat baik untuk pengembangan Azure, Docker, dan teknologi tak terpisahkan lainnya, yang tanpanya perusahaan modern tidak terpikirkan. <br><br>  Kami mengundang Anda untuk membaca bagian "Unduh langsung data streaming" <br><a name="habracut"></a><br><h3>  10.1.  Arsitektur umum </h3><br>  Dalam bab sebelumnya, kami memeriksa situasi ketika banyak aplikasi klien harus mengirim sejumlah besar pesan yang perlu diproses secara dinamis, ditempatkan di repositori dan kemudian diproses lagi di dalamnya.  Pada saat yang sama, perlu untuk dapat mengubah logika dari pemrosesan data dan aliran penyimpanan tanpa menggunakan mengubah kode klien.  Dan akhirnya, dari sudut pandang alasan keamanan, klien harus memiliki hak untuk melakukan hanya satu hal - mengirim pesan atau menerimanya, tetapi sama sekali tidak membaca data atau menghapus basis data, dan mereka seharusnya tidak memiliki hak langsung untuk menulis data ini. <br><br>  Tugas semacam itu sangat umum dalam sistem yang bekerja dengan perangkat IoT yang terhubung melalui koneksi Internet, serta dalam sistem analisis log online.  Selain persyaratan yang tercantum di atas untuk layanan khusus kami, ada dua persyaratan lagi yang terkait dengan spesifikasi "Internet of things" dan untuk memastikan pemrosesan pesan yang andal.  Pertama-tama, protokol interaksi antara klien dan penerima layanan harus sangat sederhana sehingga dapat diimplementasikan pada perangkat dengan kemampuan komputasi yang terbatas dan memori yang sangat terbatas (misalnya, Arduino, Intel Edison, STM32 Discovery, dan platform "tidak pantas" lainnya, seperti seperti sebelumnya RaspberryPi).  Persyaratan berikutnya adalah pengiriman pesan yang andal, terlepas dari kemungkinan kegagalan layanan pemrosesan.  Ini adalah persyaratan yang lebih kuat daripada persyaratan keandalan yang tinggi.  Memang, untuk memastikan keandalan keseluruhan sistem, perlu bahwa keandalan semua komponennya cukup tinggi dan penambahan komponen baru tidak mengarah pada peningkatan nyata dalam jumlah kegagalan.  Selain kegagalan dalam infrastruktur cloud, kesalahan dapat terjadi pada layanan yang dibuat oleh pengguna.  Dan bahkan kemudian, pesan harus diproses segera setelah layanan pengguna dipulihkan.  Untuk melakukan ini, layanan penerimaan aliran pesan harus dapat menyimpan pesan dengan andal hingga diproses atau hingga masa pakainya berakhir (ini diperlukan untuk mencegah memori berlebih selama aliran pesan berkelanjutan).  Layanan dengan properti ini disebut Event Hub.  Untuk perangkat IoT terdapat hub khusus (IoT Hub), yang memiliki sejumlah properti lain yang sangat penting untuk digunakan bersama dengan perangkat Internet of Things (misalnya, komunikasi dua arah dari satu titik, perutean pesan bawaan, “digital doubles” dari perangkat dan sejumlah lainnya).  Namun, layanan ini masih terspesialisasi, dan kami tidak akan mempertimbangkannya secara rinci. <br><br>  Sebelum beralih ke konsep konsentrasi pesan, mari kita beralih ke ide-ide yang melatarbelakanginya. <br><br>  Misalkan kita memiliki sumber pesan (misalnya, permintaan dari klien) dan layanan yang harus menanganinya.  Memproses satu permintaan membutuhkan waktu dan membutuhkan sumber daya komputasi (CPU, memori, IOPS).  Selain itu, selama pemrosesan satu permintaan, sisa permintaan tidak dapat diproses.  Agar aplikasi klien tidak membeku saat menunggu layanan akan dirilis, perlu untuk memisahkannya dengan bantuan layanan tambahan yang akan bertanggung jawab untuk menyimpan pesan saat mereka sedang menunggu pemrosesan saat dalam antrian.  Pemisahan ini juga diperlukan untuk meningkatkan keandalan keseluruhan sistem.  Memang, klien mengirim pesan ke sistem, tetapi layanan pemrosesan mungkin "jatuh", tetapi pesan tidak boleh hilang, harus disimpan dalam layanan yang lebih dapat diandalkan daripada layanan pemrosesan.  Versi paling sederhana dari layanan semacam itu disebut antrian (Gbr. 10.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/8v/vn/ql8vvnkz7cm8mkc0mrgtrdczzae.png" alt="gambar"></div><br>  Layanan antrian berfungsi sebagai berikut: klien mengetahui URL antrian dan memiliki kunci akses untuk itu.  Menggunakan SDK atau API dari antrian, klien menempatkan pesan di dalamnya yang berisi timestamp, pengidentifikasi dan badan pesan dengan muatan dalam format JSON, XML atau biner. <br><br>  Kode program layanan termasuk siklus yang "mendengarkan" antrian, mengambil pesan berikutnya di setiap langkah, dan jika ada pesan dalam antrian, itu diekstraksi dan diproses.  Jika layanan berhasil memproses pesan, itu dihapus dari antrian.  Jika kesalahan terjadi selama pemrosesan, itu tidak dihapus dan dapat diproses lagi ketika versi baru dari layanan, dengan kode yang diperbaiki, diluncurkan.  Antrian dirancang untuk menyinkronkan satu klien (atau sekelompok klien serupa) dan tepat satu layanan pemrosesan (meskipun yang terakhir dapat ditemukan di server cluster atau pada server farm).  Layanan Antrian Cloud termasuk Antrian Penyimpanan Azure, Antrian Bus Layanan Azure, dan AWS SQS.  Layanan yang dihosting di mesin virtual termasuk RabbitMQ, ZeroMQ, MSMQ, IBM MQ, dll. <br><br>  Layanan antrian yang berbeda menjamin berbagai jenis pengiriman pesan: <br><ul><li>  Setidaknya satu kali pengiriman pesan </li><li>  pengiriman ketat satu kali; </li><li>  pengiriman pesan dengan tetap menjaga pesanan; </li><li>  pengiriman pesan tanpa mempertahankan pesanan. </li></ul><br>  Antrian menyediakan pengiriman pesan yang andal dari satu sumber ke satu layanan pemrosesan, yaitu interaksi satu-ke-satu.  Tetapi bagaimana jika perlu menyediakan pengiriman pesan ke beberapa layanan?  Dalam hal ini, Anda perlu menggunakan layanan yang disebut "topik" (topik) (Gbr. 10.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wo/mi/6i/womi6if7bwniohwxjvik1r68v_4.png" alt="gambar"></div><br>  Elemen penting dari arsitektur ini adalah "langganan".  Ini adalah jalur yang terdaftar di bagian di mana pesan dikirim.  Pesan diterbitkan dalam topik oleh klien dan ditransfer ke salah satu langganan, dari mana mereka diekstraksi oleh salah satu layanan dan diproses olehnya.  Topik menyediakan arsitektur interaksi layanan pelanggan satu-ke-banyak.  Contoh layanan tersebut termasuk Topik Bus Layanan Azure dan AWS SNS. <br><br>  Sekarang anggaplah bahwa ada sejumlah besar klien heterogen yang perlu mengirim banyak pesan ke berbagai layanan, yaitu, kita perlu membangun sistem interaksi banyak-ke-banyak.  Tentu saja, arsitektur seperti itu dapat dibangun menggunakan beberapa bagian, tetapi konstruksi seperti itu tidak dapat diskalakan dan membutuhkan upaya untuk administrasi dan pemantauan.  Namun, ada layanan terpisah - konsentrator pesan (Gbr. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/na/sg/5tnasgyiet_8zcd0zmtvxj4koeg.png" alt="gambar"></div><br>  Hub menerima pesan dari banyak klien.  Semua klien dapat mengirim pesan ke satu titik akhir layanan umum atau terhubung secara terpisah ke titik akhir yang berbeda melalui tombol khusus.  Tombol-tombol ini memungkinkan Anda untuk mengelola klien secara fleksibel: lepaskan beberapa, sambungkan yang baru, dll. Di dalam hub ada juga partisi.  Tetapi dalam kasus ini, mereka dapat didistribusikan di antara semua klien untuk meningkatkan produktivitas (round robin - "dengan penambahan siklik") atau klien dapat mempublikasikan pesan di salah satu bagian.  Di sisi lain, layanan pemrosesan digabungkan ke dalam kelompok konsumen.  Satu atau beberapa layanan dapat dihubungkan ke satu grup.  Dengan demikian, konsentrator pesan adalah layanan paling fleksibel yang dapat dikonfigurasi sebagai antrian, bagian atau grup antrian, atau sekumpulan bagian.  Secara umum, konsentrator pesan menyediakan hubungan banyak-ke-banyak antara klien dan layanan.  Hub ini termasuk Apache Kafka, Azure Event Hub, dan AWS Kinesis Stream. <br><br>  Sebelum melihat layanan PaaS berbasis cloud, kami akan memperhatikan layanan yang sangat kuat dan terkenal - Apache Kafka.  Dalam lingkungan cloud, ini dapat diakses sebagai distribusi yang disebarkan langsung ke kluster mesin virtual atau menggunakan layanan HDInsight.  Jadi, Apache Kafka adalah layanan yang menyediakan fitur-fitur berikut: <br><ul><li>  Posting dan berlangganan aliran pesan </li><li>  penyimpanan pesan yang andal; </li><li>  Aplikasi layanan pemrosesan pesan streaming pihak ketiga. </li></ul><br>  Secara fisik, Kafka berjalan dalam satu cluster dari satu atau lebih server.  Kafka menyediakan API untuk berinteraksi dengan klien eksternal (Gbr. 10.4). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/50/ug/gz50ugazn-xwectzo--c8pulh4c.png" alt="gambar"></div><br>  Pertimbangkan API ini secara berurutan. <br><ul><li>  API Vendor memungkinkan aplikasi klien untuk mempublikasikan aliran pesan dalam satu atau lebih topik Kafka. </li><li>  API Pelanggan memberi aplikasi klien kemampuan untuk berlangganan satu atau lebih topik dan memproses aliran pesan yang disampaikan oleh topik ke klien. </li><li>  API prosesor aliran memungkinkan aplikasi untuk berinteraksi dengan kluster Kafka sebagai prosesor streaming.  Sumber untuk satu prosesor mungkin satu atau lebih topik.  Dalam hal ini, pesan yang diproses juga ditempatkan dalam satu atau beberapa topik. </li><li>  API konektor membantu untuk menghubungkan sumber data eksternal (misalnya, RDB) sebagai sumber pesan (misalnya, dimungkinkan untuk mencegat peristiwa perubahan data dalam database) dan sebagai penerima. </li></ul><br>  Di Kafka, interaksi antara klien dan cluster berlangsung melalui TCP, yang difasilitasi oleh SDK yang ada untuk berbagai bahasa pemrograman, termasuk .Net.  Tetapi bahasa dasar SDK adalah Java dan Scala. <br><br>  Dalam sebuah cluster, penyimpanan aliran pesan (dalam terminologi Kafka juga disebut sebagai entri) terjadi secara logis pada objek yang disebut topik (Gbr. 10.5).  Setiap catatan terdiri dari kunci, nilai, dan cap waktu.  Intinya, topik adalah urutan catatan (pesan) yang telah diterbitkan oleh pelanggan.  Topik Kafka mendukung dari 0 hingga beberapa pelanggan.  Setiap topik secara fisik direpresentasikan sebagai log yang dipartisi.  Setiap bagian adalah urutan catatan yang terurut, dimana yang baru tiba di input Kafka terus ditambahkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qn/yi/wu/qnyiwuqtcxijhasj3iz7q8eh4jm.png" alt="gambar"></div><br>  Setiap entri di bagian sesuai dengan nomor dalam urutan, juga disebut offset, yang secara unik mengidentifikasi pesan ini dalam urutan.  Tidak seperti antrian, Kafka menghapus pesan tidak setelah memproses layanan, tetapi setelah masa pakai pesan.  Ini adalah properti yang sangat penting, memberikan kemampuan membaca dari satu topik ke konsumen yang berbeda.  Selain itu, bias dikaitkan dengan masing-masing konsumen (Gambar 10.6).  Dan setiap tindakan membaca hanya mengarah pada peningkatan nilai untuk setiap klien secara individual dan ditentukan secara tepat oleh klien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/1b/mk/mj1bmkl7ooowixrdekhfg3-bix8.png" alt="gambar"></div><br>  Dalam kasus normal, offset ini bertambah satu setelah berhasil membaca satu pesan dari topik.  Tetapi jika perlu, klien dapat menggeser offset ini dan mengulangi operasi baca. <br><br>  Menggunakan konsep bagian memiliki tujuan sebagai berikut. <br><br>  Pertama, bagian memberikan kemampuan untuk skala topik ketika satu topik tidak cocok dalam simpul yang sama.  Pada saat yang sama, setiap bagian memiliki satu simpul memimpin (jangan bingung dengan simpul kepala dari seluruh kluster) simpul dan nol atau beberapa simpul pengikut.  Node kepala bertanggung jawab atas pemrosesan operasi baca / tulis, sementara pengikut adalah salinan pasifnya.  Jika master node gagal, salah satu node penerus secara otomatis akan menjadi simpul kepala.  Setiap simpul kluster adalah pengarah untuk beberapa bagian dan pengikut untuk yang lain.  Kedua, replikasi tersebut meningkatkan kinerja pembacaan karena kemungkinan operasi pembacaan paralel. <br><br>  Produser dapat menempatkan pesan dalam topik apa pun pilihannya secara eksplisit atau dalam mode round robin secara implisit (yaitu, dengan pengisian seragam).  Konsumen disatukan dalam apa yang disebut kelompok konsumen, dan setiap pesan yang diterbitkan dalam topik disampaikan kepada satu pelanggan di setiap kelompok konsumen.  Klien dalam hal ini dapat di-host secara fisik di satu atau lebih server / mesin virtual.  Secara lebih rinci, pengiriman pesan adalah sebagai berikut.  Untuk semua pelanggan yang termasuk dalam kelompok konsumen yang sama, pesan dapat didistribusikan antar pelanggan untuk mengoptimalkan pemuatan.  Jika pelanggan termasuk kelompok konsumen yang berbeda, maka setiap pesan akan dikirim ke masing-masing kelompok.  Pemisahan pesan dari bagian oleh kelompok konsumen yang berbeda ditunjukkan pada Gambar.  10.7. <br><br>  Sekarang saya akan menjelaskan secara singkat parameter utama pengiriman dan penyimpanan pesan yang dijamin oleh Kafka. <br><ul><li>  Pesan yang dikirim oleh produsen ke topik tertentu akan ditambahkan secara ketat sesuai urutan pengirimannya. </li><li>  Klien melihat urutan pesan dalam topik yang diterima saat pesan disimpan.  Akibatnya, pesan dikirim dari produsen ke konsumen secara ketat sesuai urutan penerimaannya. </li><li>  Replikasi topik N-lipat memastikan stabilitas topik terhadap kegagalan N-1 node tanpa kehilangan kinerja. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/qp/ms/rfqpmsno04krpiqxhs1qv8agwhu.png" alt="gambar"></div><br>  Jadi, layanan Apache Kafka dapat digunakan dalam mode berikut. <br><br><ul><li>  Layanan - broker pesan (antrian) atau layanan publikasi - berlangganan pesan (topik).  Memang, Kafka didasarkan pada sekelompok topik yang dapat dikonversi menjadi antrian dengan satu pelanggan.  (Harus diingat: berbeda dengan layanan pialang pesan biasa, yang dibangun berdasarkan prinsip antrian, dalam pesan Kafka dihapus hanya setelah masa pakainya berakhir, sementara pialang menerapkan prinsip Peek-Delete, yaitu pengambilan dan penghapusan setelah pemrosesan berhasil. ) Prinsip kelompok konsumen merangkum dua konsep ini, dan kemampuan untuk mempublikasikan pesan dalam semua topik dengan distribusi round robin menjadikan Kafka sebagai pialang pesan multi-mode universal. </li><li>  Layanan untuk analisis pesan streaming.  Ini dimungkinkan berkat API untuk prosesor streaming yang termasuk dalam Kafka, yang memungkinkan Anda membangun sistem yang kompleks, dibuat berdasarkan Event Driven, dengan layanan yang memfilter pesan atau meresponsnya, serta layanan yang menggabungkan pesan. </li></ul><br>  Semua properti ini memungkinkan untuk menggunakan Kafka sebagai komponen utama platform yang bekerja dengan streaming data dan memiliki kemampuan hebat untuk membangun sistem pemrosesan pesan yang kompleks.  Tetapi pada saat yang sama, Kafka cukup rumit dalam hal penempatan dan konfigurasi sekelompok beberapa node, yang membutuhkan upaya administrasi yang signifikan.  Tetapi, di sisi lain, karena ide-ide yang mendasari Kafka sangat cocok untuk membangun sistem, streaming pesan dan menerima pesan, penyedia cloud menyediakan layanan PaaS yang mengimplementasikan ide-ide ini dan menyembunyikan semua kesulitan membangun dan mengelola cluster Kafka.  Tetapi karena layanan ini memiliki sejumlah batasan dalam hal kustomisasi dan ekspansi di luar batas yang dialokasikan untuk layanan, penyedia cloud menyediakan layanan IaaS / PaaS khusus untuk penyebaran fisik Kafka dalam kelompok mesin virtual.  Dalam hal ini, pengguna memiliki kebebasan hampir lengkap untuk konfigurasi dan ekspansi.  Layanan ini termasuk Azure HDInsight.  Sudah disebutkan di atas.  Itu dibuat untuk, di satu sisi, menyediakan pengguna dengan layanan dari ekosistem Hadoop sendiri, tanpa pembungkus eksternal, dan di sisi lain, untuk meringankan kesulitan yang timbul dari instalasi langsung, administrasi dan konfigurasi IaaS.  Hosting Docker agak terpisah.  Karena ini adalah topik yang sangat penting, kami akan mempertimbangkannya, tetapi pertama-tama berkenalan dengan layanan PaaS yang diimplementasikan menggunakan konsep dasar Kafka. <br><br><h3>  10.2.  Pusat acara Azure </h3><br>  Pertimbangkan layanan hub pesan Pusat Acara Azure.  Ini adalah layanan yang dibangun pada model PaaS.  Berbagai grup klien dapat bertindak sebagai sumber pesan untuk Azure Event Hub (Gambar 10.8).  Pertama-tama, ini adalah kelompok layanan cloud yang sangat besar yang output atau pemicunya dapat dikonfigurasikan untuk mengirim pesan langsung ke Event Hub.  Ini bisa berupa Stream Analytics Job, Event Grid dan sekelompok layanan signifikan yang mengarahkan kembali peristiwa - log di Hub Acara (terutama dibangun menggunakan AppService: Aplikasi Api, Aplikasi Web, Aplikasi Seluler, dan Aplikasi Fungsi). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/wr/-y/thwr-yanwimel2wqzorsolaojxo.png" alt="gambar"></div><br>  Pesan yang dikirim ke hub dapat langsung ditangkap dan disimpan di Blob Storage atau Data Lake Store. <br><br>  Kelompok sumber berikutnya adalah klien atau perangkat lunak eksternal yang tidak ada Azure Event Hub SDK dan yang tidak dapat diintegrasikan langsung dengan layanan Azure.  Klien-klien ini terutama termasuk perangkat IoT.  Mereka dapat mengirim pesan ke Event Hub melalui HTTPS atau AMQP.  Pertimbangan tentang bagaimana menghubungkan perangkat-perangkat ini berada di luar cakupan buku kami. <br><br>  Akhirnya, klien perangkat lunak yang menghasilkan pesan dan mengirimkannya ke Event Hub menggunakan Azure Event Hub SDK.  Grup ini mencakup Azure PowerShell dan Azure CLI. <br>  Sebagai penerima pesan (konsumen - "konsumen") dari Hub Peristiwa, Pekerjaan Stream Analytics atau layanan integrasi Grid Peristiwa dapat digunakan.  Selain itu, dimungkinkan untuk menerima pesan oleh klien perangkat lunak menggunakan Azure Event Hub SDK.  Konsumen terhubung ke Event Hub menggunakan protokol AMQP 1.0. <br><br>  Pertimbangkan konsep dasar dari Azure Event Hub yang diperlukan untuk memahami cara menggunakannya dan mengkonfigurasinya.  Sumber apa pun (juga disebut penerbit dalam dokumentasi) yang mengirim pesan ke hub harus menggunakan HTTPS atau AMQP 1.0.  Pilihan protokol ditentukan oleh jenis klien, jaringan komunikasi dan persyaratan untuk tingkat pesan.  AMQP membutuhkan koneksi permanen antara dua soket TCP dua arah.  Itu dilindungi dengan menggunakan protokol enkripsi lapisan transport TLS atau SSL / TLS.   ,  ,       AMQP   ,  HTTPS,          .      HTTPS. <br><br>     ,         SAS (Shared Access Signature) tokens.          SAS-          SAS   .      SAS-,      (  ). <br><br>         256 .  ,                  . <br><br>  ,      Event Hub.      ,        ,      ,     -.   EventHub     (partitions).   EventHub —    ,     «  —  » (FIFO) (. 10.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iq/2g/_p/iq2g_p_ldvolfuahy8admgxqhzo.png" alt="gambar"></div><br>   —       Event Hub.  Event Hub    2  32 ,          Event Hub.   ,          . <br><br>    (    )    ,      (    ,     — . ),       (retention period),   .   .           .       ,  Azure Event Hub    (offset).     —    ,      ,  ,  ,      .          . Azure Event Hub SDK    ,     ,     .       -,         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/ab/bc/feabbcymdq52xiddkbp2vcajz-k.png" alt="gambar"></div><br>  ,          ,     ,       ,    .   Azure Event Hub SDK     ,        .  ,     Storage Account.  Azure,     Event Hub,       . <br><br>     Event Hub     (partition key),          .    —   . ,         (    )          .        ,       (round robin). <br><br>       .      ,       (consumer group) (. 10.11).             .             (view) (     ) ,  ,     .        ,       .     — 20,            ,            . <br><br>          .  ,              .    ,     (throughput unit).         : <br><ul><li>    — 1 M    1000    (   ,       ); </li><li>    — 2 M  . </li></ul><br>         .      ,     .           .         .  Berhati-hatilah!  ,     ,    ,       Event Hub. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i_/l0/jc/i_l0jcqwomkuargf-sygdrfufdc.png" alt="gambar"></div><br>        (namespace) (. 10.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jf/de/h-/jfdeh-khouxn6olnkxcgw6-w1a4.png" alt="gambar"></div><br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Kupon diskon 20% untuk <b>penjaja</b> - <b>BigData</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428375/">https://habr.com/ru/post/id428375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428365/index.html">Kisah tentang bagaimana penagihan Google berubah, atau bagaimana menghindari biaya yang tidak perlu</a></li>
<li><a href="../id428367/index.html">Kami membuat modem sonar terkecil di dunia</a></li>
<li><a href="../id428369/index.html">Keluar dari roda Sansara, ekstremisme, dan beberapa hal hijau - penguraian tugas dari buklet GridGain di konferensi Joker 2018</a></li>
<li><a href="../id428371/index.html">Permainan IBM lama</a></li>
<li><a href="../id428373/index.html">iPhone tidak nyaman digunakan</a></li>
<li><a href="../id428377/index.html">Biomarker Penuaan Epigenetik</a></li>
<li><a href="../id428379/index.html">Proses desain yang sebenarnya. Kisah selangkah demi selangkah tentang cara membuat situs web yang berorientasi bisnis</a></li>
<li><a href="../id428381/index.html">Investasi $ 10 juta dan pujian Wozniak - jalan panjang untuk menciptakan perancang komputer untuk anak-anak</a></li>
<li><a href="../id428383/index.html">Sony telah menerbitkan daftar lengkap game untuk PlayStation Classic</a></li>
<li><a href="../id428385/index.html">Lebih banyak kopi, lebih sedikit kafein: Intel 9th ​​Gen (bagian 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>