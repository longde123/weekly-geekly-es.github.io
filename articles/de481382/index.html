<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüéì ‚õ¥Ô∏è üßóüèø Windows Native Applications und Acronis Active Restore ‚ôüÔ∏è ü•¶ üõ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute setzen wir die Geschichte fort, wie wir gemeinsam mit den Mitarbeitern der Innopolis University die Active Restore-Technologie entwickeln, damit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Native Applications und Acronis Active Restore</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/481382/">  Heute setzen wir die Geschichte fort, wie wir gemeinsam mit den Mitarbeitern der Innopolis University die Active Restore-Technologie entwickeln, damit der Benutzer nach einem Ausfall so schnell wie m√∂glich mit der Arbeit an seiner Maschine beginnen kann.  Wir werden √ºber native Windows-Anwendungen sprechen, einschlie√ülich der Funktionen ihrer Erstellung und ihres Starts.  Under the cut - ein wenig √ºber unser Projekt sowie eine praktische Anleitung zum Schreiben nativer Anwendungen. <br><br><img src="https://habrastorage.org/webt/rc/bv/yl/rcbvylee_0ylshzywkrdlip0c9o.jpeg"><br><a name="habracut"></a><br>  In fr√ºheren Beitr√§gen haben wir bereits dar√ºber gesprochen, was <a href="https://habr.com/ru/company/acronis/blog/477658/">Active Restore</a> ist und wie Studenten aus Innopolis den <a href="https://habr.com/ru/company/acronis/blog/479524/">Service entwickeln</a> .  Heute m√∂chte ich mich auf native Anwendungen konzentrieren, auf deren Ebene wir unseren aktiven Wiederherstellungsdienst begraben m√∂chten.  Wenn alles klappt, k√∂nnen wir: <br><br><ul><li>  Viel fr√ºher, um den Dienst selbst zu starten </li><li>  Viel fr√ºher, um die Cloud zu kontaktieren, in der das Backup liegt </li><li>  Es ist viel fr√ºher zu verstehen, in welchem ‚Äã‚ÄãModus sich das System befindet - normaler Start oder Wiederherstellung </li><li>  Um im Voraus viel weniger Dateien wiederherzustellen </li><li>  Erm√∂glichen Sie dem Benutzer einen noch schnelleren Einstieg. </li></ul><br><h3>  Was ist eine native Anwendung im Allgemeinen? </h3><br>  Schauen wir uns zur Beantwortung dieser Frage die Reihenfolge der Aufrufe an, die das System durchf√ºhrt, wenn beispielsweise ein Programmierer in seiner Anwendung versucht, eine Datei zu erstellen. <br><br><img src="https://habrastorage.org/webt/gb/d_/a7/gbd_a7c7l1d-6dlo4zh-fygf5dm.jpeg"><br>  <i>Pavel Yosifovich - Windows-Kernel-Programmierung (2019)</i> <br><br>  Der Programmierer verwendet die Funktion <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> , die in der Headerdatei fileapi.h deklariert und in Kernel32.dll implementiert ist.  Diese Funktion selbst erstellt jedoch keine Datei, sondern √ºberpr√ºft nur die Argumente an der Eingabe und ruft die Funktion <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">NtCreateFile auf</a> (das Pr√§fix Nt gibt lediglich an, dass die Funktion nativ ist).  Diese Funktion ist in der Header-Datei winternl.h deklariert und in ntdll.dll implementiert.  Sie bereitet den Sprung in den Nuklearraum vor und ruft anschlie√üend das System auf, um eine Datei zu erstellen.  In diesem Fall stellt sich heraus, dass Kernel32 nur ein Wrapper f√ºr Ntdll ist.  Einer der Gr√ºnde daf√ºr ist, dass Microsoft in der Lage ist, die Funktionen der einheimischen Welt zu √§ndern, die Standardschnittstellen jedoch nicht zu ber√ºhren.  Microsoft r√§t davon ab, native Funktionen direkt aufzurufen, und dokumentiert die meisten davon nicht.  Undokumentierte Features finden Sie √ºbrigens <a href="http://undocumented.ntinternals.net/">hier</a> . <br><br>  Der Hauptvorteil nativer Anwendungen besteht darin, dass ntdll viel fr√ºher als kernel32 in das System geladen wird.  Dies ist logisch, da Kernel32 ntdll ben√∂tigt, um zu funktionieren.  Infolgedessen k√∂nnen Anwendungen, die native Funktionen verwenden, viel fr√ºher ausgef√ºhrt werden. <br><br>  Daher sind Windows Native Applications Programme, die zu einem fr√ºhen Zeitpunkt beim Booten von Windows ausgef√ºhrt werden k√∂nnen.  Sie verwenden NUR Funktionen von ntdll.  Ein Beispiel f√ºr eine solche Anwendung: <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/autochk">autochk</a> f√ºhrt <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chkdsk">das Dienstprogramm chkdisk aus</a> , um die Festplatte vor dem Starten der Hauptdienste auf Fehler zu √ºberpr√ºfen.  Auf dieser Ebene m√∂chten wir unsere aktive Wiederherstellung sehen. <br><br><h3>  Was brauchen wir </h3><br><ul><li> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit), jetzt auch als WDK 7 (Windows Driver Kit) bekannt. </li><li>  Virtuelle Maschine (z. B. Windows 7 x 64) </li><li>  Nicht unbedingt, aber Header-Dateien k√∂nnen hier heruntergeladen <a href="https://github.com/arizvisa/ndk">werden.</a> </li></ul><br><h3>  Was ist im Code? </h3><br>  Lassen Sie uns ein wenig √ºben und als Beispiel eine kleine Anwendung schreiben, die: <br><br><ol><li>  Zeigt eine Meldung auf dem Bildschirm an. </li><li>  Weist ein wenig Speicher zu </li><li>  Warten auf Tastatureingabe </li><li>  Gibt den belegten Speicher frei </li></ol><br>  In nativen Anwendungen ist der Einstiegspunkt nicht der Haupt- oder WinMain-Punkt, sondern die NtProcessStartup-Funktion, da wir den neuen Prozess tats√§chlich direkt im System starten. <br><br>  Beginnen wir mit der Anzeige der Meldung auf dem Bildschirm.  Dazu haben wir eine native Funktion <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FError%252FNtDisplayString.html">NtDisplayString</a> , die als Argument einen Zeiger auf ein Objekt der UNICODE_STRING-Struktur verwendet.  RtlInitUnicodeString hilft uns beim Initialisieren.  Um Text auf dem Bildschirm anzuzeigen, k√∂nnen wir daher eine so kleine Funktion schreiben: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//usage: WriteLn(L"Here is my text\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); }</span></span></code> </pre> <br>  Da uns nur Funktionen von ntdll zur Verf√ºgung stehen und es einfach noch keine anderen Bibliotheken im Speicher gibt, werden wir definitiv Probleme haben, Speicher zuzuweisen.  Der neue Operator existiert noch nicht (da er aus einer zu √ºbergeordneten C ++ - Welt stammt), es gibt auch keine Malloc-Funktion (es werden Laufzeit-C-Bibliotheken ben√∂tigt).  Sie k√∂nnen nat√ºrlich nur den Stapel verwenden.  Wenn wir jedoch Speicher dynamisch zuweisen m√ºssen, m√ºssen wir dies auf dem Heap (d. H. Heap) tun.  Lassen Sie uns daher einen Haufen f√ºr uns selbst zusammenstellen, und wir werden ihn uns merken, wenn wir ihn brauchen. <br><br>  Die Funktion <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap ist</a> f√ºr diese Aufgabe geeignet.  Mit RtlAllocateHeap und RtlFreeHeap belegen wir au√üerdem Speicherplatz und geben ihn frei, wenn wir ihn ben√∂tigen. <br><br><pre> <code class="cpp hljs">PVOID memory = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PVOID buffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ULONG bufferSize = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory);</span></span></code> </pre> <br>  Warten wir nun auf die Tastatureingabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //... HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } }</span></span></code> </pre> <br>  Alles, was wir tun m√ºssen, ist, <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FFile%252FNtReadFile.html">NtReadFile</a> auf einem ge√∂ffneten Ger√§t zu verwenden und zu warten, bis die Tastatur einen Klick an uns zur√ºckgibt.  Wird die ESC-Taste gedr√ºckt, arbeiten wir weiter.  Um das Ger√§t zu √∂ffnen, m√ºssen wir die Funktion NtCreateFile aufrufen (Sie m√ºssen \ Device \ KeyboardClass0 √∂ffnen).  Wir werden auch <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">NtCreateEvent aufrufen</a> , um das zu <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">wartende</a> Objekt zu initialisieren.  Wir werden die KEYBOARD_INPUT_DATA-Struktur, die die Tastaturdaten darstellt, unabh√§ngig deklarieren.  Dies wird unsere Arbeit erleichtern. <br><br>  Die native Anwendung endet mit einem Aufruf der <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">NtTerminateProcess-</a> Funktion, da wir nur unseren eigenen Prozess <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">beenden</a> . <br><br>  Alle Codes unserer kleinen Anwendung: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntifs.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// \WinDDK\7600.16385.1\inc\ddk #include "ntdef.h" //------------------------------------ // Following function definitions can be found in native development kit // but I am too lazy to include `em so I declare it here //------------------------------------ NTSYSAPI NTSTATUS NTAPI NtTerminateProcess( IN HANDLE ProcessHandle OPTIONAL, IN NTSTATUS ExitStatus ); NTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); NTSTATUS NtWaitForSingleObject( IN HANDLE Handle, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout ); NTSYSAPI NTSTATUS NTAPI NtCreateEvent( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState ); // https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //---------------------------------------------------------- // Our code goes here //---------------------------------------------------------- // usage: WriteLn(L"Hello Native World!\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); } void NtProcessStartup(void* StartupArgument) { // it is important to declare all variables at the beginning HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; PVOID memory = NULL; PVOID buffer = NULL; ULONG bufferSize = 42; //use it if debugger connected to break //DbgBreakPoint(); WriteLn(L"Hello Native World!\n"); // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); WriteLn(L"Keyboard ready\n"); // create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); WriteLn(L"Heap ready\n"); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); WriteLn(L"Buffer allocated\n"); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory); WriteLn(L"Heap destroyed\n"); WriteLn(L"Press ESC to continue...\n"); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } } NtTerminateProcess(NtCurrentProcess(), 0); }</span></span></span></span></code> </pre> <br>  <b>PS:</b> Wir k√∂nnen einfach die DbgBreakPoint () - Funktion im Code verwenden, um den Debugger anzuhalten.  Richtig, Sie m√ºssen WinDbg f√ºr das Kernel-Debugging mit der virtuellen Maschine verbinden.  Eine Anleitung dazu finden Sie <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">hier</a> oder verwenden Sie einfach <a href="http://sysprogs.com/legacy/virtualkd/">VirtualKD</a> . <br><br><h3>  Zusammenstellung und Montage </h3><br>  Der einfachste Weg, eine native Anwendung zu erstellen, ist die Verwendung von <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit).  Wir brauchen genau die alte siebte Version, da sp√§tere Versionen einen etwas anderen Ansatz haben und eng mit Visual Studio zusammenarbeiten.  Wenn wir DDK verwenden, ben√∂tigt unser Projekt nur Makefile und Sources. <br><br>  <i>Makefile</i> <br><pre> <code class="bash hljs">!INCLUDE $(NTMAKEENV)\makefile.def</code> </pre> <br>  <i>Quellen:</i> <br><pre> <code class="bash hljs">TARGETNAME = MyNative TARGETTYPE = PROGRAM UMTYPE = nt BUFFER_OVERFLOW_CHECKS = 0 MINWIN_SDK_LIB_PATH = $(SDK_LIB_PATH) SOURCES = source.c INCLUDES = $(DDK_INC_PATH); \ C:\WinDDK\7600.16385.1\ndk; TARGETLIBS = $(DDK_LIB_PATH)\ntdll.lib \ $(DDK_LIB_PATH)\nt.lib USE_NTDLL = 1</code> </pre> <br>  Ihr Makefile wird genau das gleiche sein, aber lassen Sie uns n√§her auf die Quellen eingehen.  Diese Datei enth√§lt die Quellen Ihres Programms (.c-Dateien), Erstellungsoptionen und andere Parameter. <br><br><ul><li>  ZIELNAME - Der Name der ausf√ºhrbaren Datei, die das Ergebnis sein soll. </li><li>  TARGETTYPE - Typ der ausf√ºhrbaren Datei, es kann ein Treiber (.sys) sein, dann sollte der Feldwert DRIVER sein, wenn die Bibliothek (.lib), dann ist der Wert LIBRARY.  In unserem Fall ben√∂tigen wir eine ausf√ºhrbare Datei (.exe), daher setzen wir den Wert auf PROGRAM. </li><li>  UMTYPE - m√∂gliche Werte f√ºr dieses Feld: Konsole f√ºr eine Konsolenanwendung, Fenster f√ºr den Betrieb im Fenstermodus.  Wir m√ºssen aber nt angeben, um die native Anwendung zu erhalten. </li><li>  BUFFER_OVERFLOW_CHECKS - √úberpr√ºfung des Stacks auf Puffer√ºberlauf, leider nicht in unserem Fall, deaktivieren Sie ihn. </li><li>  MINWIN_SDK_LIB_PATH - dieser Wert bezieht sich auf die Variable SDK_LIB_PATH. Machen Sie sich keine Sorgen, dass Sie eine solche Systemvariable nicht deklariert haben. Sobald wir den gepr√ºften Build von DDK ausf√ºhren, wird diese Variable deklariert und verweist auf die erforderlichen Bibliotheken. </li><li>  QUELLEN - eine Liste der Quellen Ihres Programms. </li><li>  INCLUDES - Header-Dateien, die f√ºr die Assemblierung ben√∂tigt werden.  Sie geben normalerweise den Pfad zu den Dateien an, die mit dem DDK geliefert werden. Sie k√∂nnen jedoch auch andere angeben. </li><li>  TARGETLIBS - eine Liste der Bibliotheken, die verkn√ºpft werden m√ºssen. </li><li>  USE_NTDLL ist ein Pflichtfeld, das aus offensichtlichen Gr√ºnden auf Position 1 gesetzt werden muss. </li><li>  USER_C_FLAGS - alle Flags, die Sie in Pr√§prozessoranweisungen verwenden k√∂nnen, wenn Sie Anwendungscode vorbereiten. </li></ul><br>  Zum Erstellen m√ºssen wir x86 (oder x64) Checked Build ausf√ºhren, das Arbeitsverzeichnis in den Projektordner √§ndern und den Befehl Build ausf√ºhren.  Das Ergebnis im Screenshot zeigt, dass wir eine ausf√ºhrbare Datei gesammelt haben. <br><br><img src="https://habrastorage.org/webt/9a/aj/hp/9aajhpa858ohtthlkjnenl1nnic.jpeg" alt="Bauen"><br><br>  Diese Datei kann nicht so einfach ausgef√ºhrt werden, das System schw√∂rt und veranlasst uns, mit folgendem Fehler √ºber ihr Verhalten nachzudenken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ev/zu/zwevzuxrc6zc8fvgye_msqa0k6y.jpeg" alt="Fehler"></div><br><br><h3>  Wie starte ich eine native Anwendung? </h3><br>  Beim Start von autochk wird die Startreihenfolge von Programmen durch den Wert des Registrierungsschl√ºssels bestimmt: <br><br><pre> <code class="bash hljs">HKLM\System\CurrentControlSet\Control\Session Manager\BootExecute</code> </pre> <br>  Der Sitzungsmanager f√ºhrt die Programme aus dieser Liste nacheinander aus.  Der Sitzungsmanager selbst sucht nach ausf√ºhrbaren Dateien im Verzeichnis system32.  Das Format des Registrierungsschl√ºsselwerts lautet wie folgt: <br><br><pre> <code class="bash hljs">autocheck autochk *MyNative</code> </pre> <br>  Der Wert sollte im hexadezimalen Format und nicht im √ºblichen ASCII-Format vorliegen. Daher hat der oben dargestellte Schl√ºssel das folgende Format: <br><br><pre> <code class="bash hljs">61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Um den Namen zu konvertieren, k√∂nnen Sie einen Onlinedienst verwenden, beispielsweise <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">diesen</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ii/ky/sn/iikysns0tim-qpz91mbazv4uepa.jpeg"></div><br>  Es stellt sich heraus, dass wir zum Ausf√ºhren der nativen Anwendung Folgendes ben√∂tigen: <br><br><ol><li>  Kopieren Sie die ausf√ºhrbare Datei in den Ordner system32 </li><li>  F√ºgen Sie der Registrierung einen Schl√ºssel hinzu </li><li>  Maschine neu starten </li></ol><br>  Der Einfachheit halber finden Sie hier ein fertiges Skript zum Installieren einer nativen Anwendung: <br><br>  <i>install.bat</i> <br><br><pre> <code class="bash hljs">@<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> off copy MyNative.exe %systemroot%\system32\. regedit /s add.reg <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Native Example Installed pause</code> </pre> <br>  <i>add.reg</i> <br><br><pre> <code class="bash hljs">REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager] <span class="hljs-string"><span class="hljs-string">"BootExecute"</span></span>=hex(7):61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Nach der Installation und dem Neustart, noch bevor der Benutzerauswahlbildschirm angezeigt wird, wird das folgende Bild angezeigt: <br><br><img src="https://habrastorage.org/webt/yi/5p/7_/yi5p7_4vygq1wttxg_edlw-keqi.jpeg" alt="Ergebnis"><br><br><h3>  Zusammenfassung </h3><br>  Am Beispiel einer so kleinen Anwendung waren wir √ºberzeugt, dass es durchaus m√∂glich ist, die Anwendung auf Windows Native-Ebene auszuf√ºhren.  Dar√ºber hinaus werden die Mitarbeiter der Innopolis-Universit√§t weiterhin einen Service aufbauen, der den Prozess der Interaktion mit dem Fahrer viel fr√ºher als in der vorherigen Version unseres Projekts einleitet.  Und mit dem Aufkommen der win32-Shell wird es logisch sein, die Kontrolle auf einen bereits entwickelten, vollwertigen Dienst zu √ºbertragen (mehr dazu <a href="https://habr.com/ru/company/acronis/blog/479524/">hier</a> ). <br><br>  Im n√§chsten Artikel werden wir auf eine andere Komponente des Active Restore-Dienstes eingehen, n√§mlich den UEFI-Treiber.  Abonnieren Sie unseren Blog, um den n√§chsten Beitrag nicht zu verpassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481382/">https://habr.com/ru/post/de481382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481370/index.html">Greta Tunberg ist richtig? Flugzeuge VS Z√ºge</a></li>
<li><a href="../de481372/index.html">Indexierbarer bin√§rer Baum</a></li>
<li><a href="../de481374/index.html">Habr Weekly # 32 / Rambler gab den R√ºcken frei, Manipulationen bei der Arbeit, wie man ein Haustierprojekt sch√ºtzt, Gadgets machen leise Selfies</a></li>
<li><a href="../de481376/index.html">Analyse der Lektionen, die der Community von der NGINX-Situation beigebracht wurden</a></li>
<li><a href="../de481378/index.html">So optimieren Sie die Anwendungsentwicklung</a></li>
<li><a href="../de481386/index.html">Dithering: Rauschendes Signal zur Verbesserung</a></li>
<li><a href="../de481388/index.html">Wie Kryptow√§hrungsb√∂rsen ihre Blockchains aufbauen, die DeFi trotzen</a></li>
<li><a href="../de481390/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../de481392/index.html">Da habe ich eine zentralisierte Kryptow√§hrung in PHP geschrieben. (Teil 1 - Grundlegende Zusammenfassungen + Schnellstart)</a></li>
<li><a href="../de481394/index.html">Neuerstellung in einem neuen Spiel, was wir f√ºr das alte geliebt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>