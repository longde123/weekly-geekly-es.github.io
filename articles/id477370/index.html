<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔬 👨🏼‍⚖️ 👎🏻 Php tanpa server 👉🏻 👨🏻‍🚀 🧔🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menjelang peluncuran kursus Pengembang PHP Backend, kami memiliki pelajaran terbuka tradisional . Kali ini kami berkenalan dengan konsep Serverless, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Php tanpa server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/477370/"><p>  Menjelang peluncuran kursus <a href="https://otus.pw/PjYz/">Pengembang PHP Backend,</a> kami memiliki <a href="https://www.youtube.com/watch%3Fv%3DcGBggTdDmKI">pelajaran terbuka tradisional</a> .  Kali ini kami berkenalan dengan konsep Serverless, berbicara tentang penerapannya di AWS, membahas prinsip-prinsip operasi, perakitan dan peluncuran, dan juga membangun PHP-bot PHP sederhana berdasarkan AWS Lambda. </p><br><p>  Dosen - <a href="https://otus.ru/teacher/491/">Alexander Pryakhin</a> , CTO Rusia Westwing. </p><br><hr><br><p><img src="https://habrastorage.org/webt/fm/-y/de/fm-yde0vvpixphwgwoqfsumq-n4.jpeg"></p><a name="habracut"></a><br><h2 id="kratkiy-ekskurs-v-istoriyu">  Sebuah perjalanan singkat ke dalam sejarah </h2><br><p><img src="https://habrastorage.org/webt/w7/jh/mk/w7jhmkufvziqczxd8ppmbgjylpy.png"></p><br><p>  Bagaimana kita bisa sampai pada kehidupan sehingga komputasi tanpa server muncul?  Tentu saja, mereka muncul tidak hanya seperti itu, tetapi menjadi kelanjutan logis dari teknologi virtualisasi yang ada. </p><br><p><img src="https://habrastorage.org/webt/am/jv/dt/amjvdt02rv2bv7_-yhbexlhejm0.png"></p><br><p>  Apa yang biasanya kita virtualisasikan?  Misalnya, sebuah prosesor.  Anda juga dapat melakukan virtualisasi memori dengan menyorot area memori tertentu dan membuatnya dapat diakses oleh beberapa pengguna dan tidak dapat diakses oleh orang lain.  Anda dapat melakukan virtualisasi jaringan VPN.  Dan sebagainya. </p><br><p><img src="https://habrastorage.org/webt/il/2o/p_/il2op_dxfloq7om6r_czugnhebq.png"></p><br><p>  Virtualisasi itu baik karena kami lebih baik memanfaatkan sumber daya dan meningkatkan produktivitas.  Tetapi ada juga kelemahannya, misalnya, pada suatu waktu ada masalah kompatibilitas.  Namun, praktis tidak ada arsitektur yang tidak sesuai dengan mesin virtual modern. </p><br><p>  Kekurangan berikutnya adalah kita menambahkan lapisan abstraksi tambahan, menambahkan hypervisor, menambahkan mesin virtual dengan sendirinya, dan, tentu saja, kita bisa kehilangan sedikit kecepatan.  Agak rumit dan penggunaan server. </p><br><p><img src="https://habrastorage.org/webt/yh/on/4j/yhon4j0ial2rlrdfq_grqgx6yjw.png"></p><br><p>  Jika kami membawa mesin virtual standar, itu akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/rq/ii/at/rqiiat114asa0rziaowjsjp1amg.png"></p><br><p> Pertama, kami memiliki server besi, dan kedua, sistem operasi yang akan memutar hypervisor kami.  Dan di atas semua ini, mesin virtual kami berputar, di mana ada OS tamu, perpustakaan, dan aplikasi.  Jika Anda berpikir secara logis, maka kami melihat beberapa overhead di hadapan OS tamu, karena sebenarnya kami menghabiskan sumber daya tambahan. </p><br><p>  Bagaimana saya bisa menyelesaikan masalah overhead?  Menolak mesin virtual dan meletakkan sistem manajemen kontainer di atas sistem operasi utama.  Tentu saja, sistem yang paling populer sekarang adalah Docker Engine.  Kemudian pustaka di dalam wadah akan menggunakan kernel host dari sistem operasi. </p><br><p><img src="https://habrastorage.org/webt/rb/wv/ce/rbwvceyh5h8mrsgsst9bu8acadk.png"></p><br><p>  Dengan cara ini, kami menghapus overhead, tetapi Docker juga tidak ideal, dan memiliki masalah sendiri dan fitur kerja yang tidak semua orang suka. </p><br><p>  Hal utama yang harus dipahami adalah Docker dan mesin virtual adalah pendekatan yang berbeda, dan tidak perlu menyamakan mereka.  Docker bukan mikrovirtual yang dapat digunakan sebagai mesin virtual, karena wadahnya untuk itu dan wadahnya.  Namun wadah tersebut memungkinkan kami untuk memberikan fleksibilitas dan pendekatan yang sama sekali berbeda untuk pengiriman berkelanjutan, ketika kami mengirimkan barang-barang ke produksi dan memahami bahwa mereka sudah diuji dan berfungsi. </p><br><h2 id="oblachnye-tehnologii">  Teknologi cloud </h2><br><p>  Dengan semakin berkembangnya virtualisasi, teknologi cloud juga mulai berkembang.  Ini adalah solusi yang baik, tetapi perlu disebutkan segera bahwa awan bukan peluru perak dan bukan obat mujarab untuk semua penyakit.  Di sini orang tidak bisa tidak mengingat satu kutipan terkenal: </p><br><blockquote>  "Ketika saya mendengar seseorang menggembar-gemborkan cloud sebagai peluru ajaib untuk semua masalah komputasi, saya diam-diam mengganti" cloud "dengan" badut "dan melanjutkan dengan senyum seperti zen." <br>  Amy kaya </blockquote><p>  Namun, untuk perusahaan menengah yang ingin menerima tingkat layanan tertentu dan toleransi kesalahan tanpa suntikan keuangan yang besar, cloud adalah pilihan yang cukup.  Dan bagi banyak perusahaan, menjaga pusat data mereka dengan SLA yang sama akan jauh lebih mahal daripada dilayani di cloud.  Selain itu, kita dapat menggunakan cloud untuk kebutuhan kita, karena mereka menyediakan beberapa hal hanya dalam beberapa klik mouse, yang sangat nyaman.  Misalnya, kemampuan mengangkat mesin atau jaringan virtual dalam beberapa klik. <br>  Ya, ada batasan, misalnya, Undang-Undang Federal ke 152 yang melarang penyimpanan data pribadi di luar negeri, sehingga Amazon yang sama tidak akan cocok untuk kita selama audit.  Jangan lupa tentang Vendor-lock.  Banyak solusi cloud yang tidak saling porting, meskipun penyimpanan yang kompatibel dengan S3 yang sama didukung oleh sebagian besar penyedia. </p><br><p>  Awan memberi kami kesempatan untuk menerima berbagai tingkat layanan tanpa pengetahuan yang terfokus secara sempit.  Semakin sedikit pengetahuan yang Anda butuhkan, semakin banyak kami akan membayar.  Pada gambar di bawah ini, Anda dapat melihat piramida, di mana, dari bawah ke atas, penurunan persyaratan pengetahuan teknis saat menggunakan cloud ditampilkan: </p><br><p><img src="https://habrastorage.org/webt/ro/hi/aj/rohiajoeei87pirilzujxcaelqs.png"></p><br><h2 id="serverless-i-faas-function-as-a-service">  Serverless dan FaaS (Berfungsi Sebagai Layanan) </h2><br><p>  Serverless adalah cara yang cukup muda untuk menjalankan skrip di awan, misalnya, seperti AWS (dalam hal AWS, server diimplementasikan dalam Lambda).  Pendekatan * aaS yang tercantum pada piramida di atas sudah akrab: IaaS (EC2, VDS), PaaS (Shared Hosting), SaaS (Office 365, Tilda).  Jadi, Serverless adalah implementasi dari pendekatan FaaS.  Dan pendekatan ini terdiri dalam menyediakan platform siap pakai bagi pengguna untuk pengembangan, peluncuran, dan pengelolaan fungsionalitas tertentu tanpa perlu persiapan dan konfigurasi sendiri. </p><br><p>  Bayangkan bahwa Anda memiliki mesin yang bergerak dalam pemrosesan dokumen malam hari, melakukan tugas dari jam 00:00 hingga jam 6:00, dan selama sisa jam itu diam.  Pertanyaannya adalah: mengapa harus membayar di siang hari?  Dan mengapa tidak menggunakan sumber daya gratis untuk hal lain?  Keinginan untuk optimisasi dan keinginan untuk menghabiskan uang hanya untuk apa yang benar-benar Anda gunakan, dan menyebabkan munculnya FaaS. </p><br><p>  Serverless adalah sumber daya untuk mengeksekusi kode dan tidak lebih.  Ini tidak berarti bahwa tidak ada server di belakang skrip kami - itu, tetapi kami, pada kenyataannya, tidak memiliki sumber daya yang dialokasikan secara khusus di mana Lambda kami akan diluncurkan.  Ketika kami menjalankan skrip kami, infrastruktur mikro segera dibuka di bawahnya, dan ini bukan masalah Anda pada prinsipnya - Anda hanya berpikir bahwa kode Anda dieksekusi, dan Anda tidak perlu memikirkan hal lain. <br>  Tentu saja ini membutuhkan pendekatan tertentu untuk pengembangan kode Anda.  Misalnya, Anda tidak dapat menyimpan apa pun di lingkungan ini, Anda harus mengeluarkan semuanya.  Jika ini adalah data, maka diperlukan database eksternal, jika ini adalah log, maka layanan log eksternal, jika itu adalah file, maka penyimpanan file eksternal.  Untungnya, penyedia Serverless mana pun menyediakan kemampuan untuk terhubung ke sistem eksternal. </p><br><p>  Anda hanya memiliki kode, Anda bekerja dalam paradigma Stateless, Anda tidak memiliki status.  Untuk dunia PHP yang sama, ini berarti, misalnya, Anda dapat melupakan mekanisme sesi standar.  Pada prinsipnya, Anda bahkan dapat membangun Serverless Anda, dan baru-baru ini di Habré ada <a href="https://habr.com/ru/company/southbridge/blog/475044/">artikel tentang hal ini</a> . </p><br><p>  Gagasan utama Serverless adalah bahwa infrastruktur tidak memerlukan dukungan dari tim.  Semuanya jatuh di pundak platform, di mana Anda, pada kenyataannya, membayar uang.  Dari minus - Anda tidak mengontrol lingkungan eksekusi dan tidak tahu di mana apa yang dilakukan. </p><br><p>  Jadi Serverless: </p><br><ul><li>  tidak berarti tidak adanya server secara fisik; </li><li>  bukan pembunuh virtualoks dan Docker; </li><li>  tidak hype di sini dan sekarang. <br>  Serverless harus didorong secara sadar dan sengaja.  Misalnya, jika Anda perlu dengan cepat menguji hipotesis tanpa melibatkan setengah tim.  Jadi Anda mendapatkan Function As A Service.  Fungsi akan merespons beberapa peristiwa, dan karena ada reaksi terhadap peristiwa, peristiwa ini harus dipanggil oleh sesuatu - untuk ini, ada banyak pemicu dalam AWS yang sama. </li></ul><br><p>  Fitur FaaS: </p><br><ul><li>  infrastruktur tidak memerlukan konfigurasi; </li><li>  Model acara “out of the box”; </li><li>  Tanpa kewarganegaraan; </li><li>  penskalaan sangat mudah dan dilakukan secara otomatis sesuai dengan kebutuhan pengguna. </li></ul><br><h2 id="aws-lambda">  AWS Lambda </h2><br><p>  Implementasi FaaS pertama dan tersedia untuk umum adalah AWS Lambda.  Jika ini adalah tesis, maka ia memiliki fitur-fitur berikut: <br>  - tersedia sejak 2014; <br>  - Mendukung di luar kotak Java, Node.js, Python, Go, dan runtimes khusus; <br>  - kami membayar untuk: <br>  jumlah panggilan; <br>  memimpin waktu. <br>  AWS Lambda: mengapa dibutuhkan: <br>  Pembuangan  Anda hanya membayar untuk saat layanan berjalan. <br>  Kecepatan.  Lambda sendiri naik dan bekerja sangat cepat. <br>  Fungsional  Lambda memiliki banyak fitur untuk diintegrasikan dengan layanan AWS. <br>  Performa.  Menempatkan lambda cukup sulit.  Secara paralel, ini dapat dilakukan tergantung pada wilayah dari maksimum 1000 hingga 3000 salinan.  Dan jika diinginkan, batas ini dapat ditingkatkan dengan menulis dukungan. </p><br><p>  Kami memiliki tubuh lambda, editor online, VPC sebagai kotak perhitungan virtual, pencatatan, kode itu sendiri, variabel lingkungan dan pemicu yang menyebabkan lambda (omong-omong, membuat versi berfungsi dengan sangat baik).  Anatomi Lambda yang sangat baik diuraikan dalam <a href="https://habr.com/ru/post/457100/">artikel ini</a> . </p><br><p>  Kode disimpan baik di dalam tubuh (jika ini adalah bahasa yang didukung di luar kotak) atau dalam lapisan.  Kami memiliki pemicu yang memanggil lambda, lambda membaca lingkungan sementara, menariknya sendiri dan menjalankan kode kami: </p><br><p><img src="https://habrastorage.org/webt/sr/py/zu/srpyzu9gzq6gfkekd-tbo5zkmyq.png"></p><br><p>  Jika kami memiliki runtime khusus, kami harus meletakkan kode dalam sebuah layer.  Jika Anda bekerja dengan Docker, maka layer Docker sangat mirip dengan layer di lambda - semacam repositori semu di mana penjilidan kami yang diperlukan berada.  Di sana kita memiliki file lingkungan yang dapat dieksekusi (jika kita berbicara tentang PHP, Anda harus meletakkan biner PHP yang dikompilasi terlebih dahulu), file bootstrap lambda (terletak secara default) dan skrip yang dipanggil langsung yang akan dieksekusi. </p><br><p><img src="https://habrastorage.org/webt/pj/es/fp/pjesfpgl0xix6psx4tqwegms_4m.png"></p><br><p>  Dengan pengiriman, semuanya tidak begitu cerah: </p><br><p><img src="https://habrastorage.org/webt/xg/qt/km/xgqtkmwgjqrisunlmvwtgym2nkk.png"></p><br><p>  Artinya, kami ditawari untuk mengambil file dengan kode, mengunggahnya ke arsip zip, mengunggahnya ke layer dan menjalankan kode kami.  Sangat keren bahwa ini ditawarkan dalam dokumentasi resmi Amazon. </p><br><p><img src="https://habrastorage.org/webt/w2/ls/vr/w2lsvrvdjcbta6km5boxp3ntsgw.png"></p><br><p>  Tentu saja, ini tidak sesuai dengan kenyataan modern, dan bau dua per seribu di udara.  Untungnya, orang-orang baik mencoba dan membuat beberapa kerangka kerja, jadi kami akan menggunakan kerangka Serverless yang dikembangkan di Node.js dan memungkinkan kami untuk mengelola aplikasi berdasarkan AWS Lambda.  Selain itu, ketika kita berbicara tentang penyebaran dan pengembangan, tentu saja, saya tidak benar-benar ingin menggunakan secara manual, tetapi ada keinginan untuk melakukan sesuatu yang fleksibel dan otomatis. </p><br><p>  Jadi, kita perlu: <br>  - AWS CLI - antarmuka baris perintah untuk bekerja dengan layanan AWS; <br>  - kerangka Serverless yang telah disebutkan di atas (versi pengembangan gratis, dan fungsinya cukup untuk mata); <br>  - Perpustakaan Bref, yang diperlukan untuk menulis kode.  Pustaka ini diinstal menggunakan komposer, sehingga kode tersebut akan kompatibel dengan kerangka kerja apa pun.  Solusi yang bagus, terutama mengingat AWS Lambda tidak mendukung pemanggilan skrip PHP di luar kotak. </p><br><p><img src="https://habrastorage.org/webt/ke/de/4w/kede4wq7a7kupqj4zheld7ifkp0.png"></p><br><h2 id="nastraivaem-okruzhenie-i-aws">  Sesuaikan lingkungan dan AWS Anda </h2><br><h3 id="aws-cli">  AWS CLI </h3><br><p>  Mari kita mulai dengan membuat akun dan menginstal AWS CLI.  Shell konsol AWS didasarkan pada Python 2.7+ atau 3.4+.  Karena AWS merekomendasikan versi 3 Python, kami tidak akan berdebat. <br>  Contoh di bawah ini untuk Ubuntu. </p><br><pre><code class="plaintext hljs">sudo apt-get -y install python3-pip</code> </pre> <br><p>  Kemudian instal langsung AWS CLI: </p><br><pre> <code class="plaintext hljs">pip3 install awscli --upgrade --user</code> </pre> <br><p>  Periksa instalasi: </p><br><pre> <code class="plaintext hljs">aws --version</code> </pre> <br><p>  Sekarang Anda harus menghubungkan AWS CLI ke akun Anda.  Anda dapat menggunakan nama pengguna dan kata sandi Anda yang sudah ada, tetapi akan lebih baik jika Anda membuat pengguna terpisah melalui AWS IAM, dengan mendefinisikannya hanya hak akses yang diperlukan.  Memanggil konfigurasi tidak akan menyebabkan masalah: </p><br><pre> <code class="plaintext hljs">aws configure</code> </pre> <br><p>  Selanjutnya, Anda akan memerlukan AWS Secret dan AWS Access Key.  Mereka dapat diperoleh di ASW IAM di tab "Keamanan kredensial" (terletak di halaman pengguna yang diinginkan).  Tombol "Buat kunci akses" akan membantu menghasilkan kunci akses.  Simpan bersama mereka. </p><br><p><img src="https://habrastorage.org/webt/yn/t3/0q/ynt30qaych_hosd73v0bl3yb51q.png"></p><br><p>  Untuk mendaftarkan bot baru di Telegram, gunakan @BotFather dan perintah / newbot.  Akibatnya, token yang diperlukan untuk menghubungkan ke bot Anda akan dikembalikan kepada Anda.  Kunci juga. </p><br><p><img src="https://habrastorage.org/webt/mn/db/6_/mndb6_yarkg6ssd1cmfaykayuam.png"></p><br><h3 id="serverless-framework">  Kerangka tanpa server </h3><br><p>  Untuk menginstal Serverless Framework, Anda perlu akun di <a href="https://serverless.com/">https://serverless.com/</a> . <br>  Setelah menyelesaikan pendaftaran, kami akan melanjutkan ke instalasi di workstation kami.  Node.js 6 dan di atas akan diperlukan. </p><br><pre> <code class="plaintext hljs">sudo apt-get -y install nodejs</code> </pre> <br><p>  Untuk memastikan peluncuran yang benar di lingkungan kami, kami mengikuti langkah-langkah yang disarankan: </p><br><pre> <code class="plaintext hljs">mkdir ~/.npm-global export PATH=~/.npm-global/bin:$PATH source ~/.profile npm config set prefix '~/.npm-global'</code> </pre> <br><p>  Juga tambahkan: </p><br><pre> <code class="plaintext hljs">~/.npm-global/bin:$PATH</code> </pre> <br><p>  ke file / etc / environment. <br>  Sekarang masukkan Serverless: </p><br><pre> <code class="plaintext hljs">npm install -g serverless</code> </pre> <br><h3 id="aws">  Aws </h3><br><p>  Nah, saatnya untuk beralih ke antarmuka AWS dan menambahkan nama domain.  Kami membuat zona AWS Route 53, catatan DNS, dan sertifikat SSL untuknya. <br>  Selain itu, Anda memerlukan ELB, yang kami buat di layanan EC2 -&gt; Load Balancers.  Ngomong-ngomong, saat membuat ELB, Anda harus melewati semua langkah wizard, yang menunjukkan sertifikat yang dibuat. </p><br><p>  Sedangkan untuk penyeimbang, Anda bisa membuatnya melalui AWS CLI menggunakan perintah berikut: </p><br><pre> <code class="plaintext hljs">aws elb create-load-balancer --load-balancer-name my-load-balancer --listeners "Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=80" "Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80,SSLCertificateId=arn:aws:iam::123456789012:server-certificate/my-server-cert" --subnets subnet-15aaab61 --security-groups sg-a61988c3</code> </pre> <br><p>  Sebuah penyeimbang akan dibutuhkan setelah penyebaran pertama.  Dalam hal ini, Anda perlu mengirim permintaan ke domain kami untuk itu.  Untuk mengimplementasikan ini, dalam pengaturan catatan DNS (bidang "Alias ​​target"), mulai masukkan nama ELB yang dibuat.  Akibatnya, Anda akan melihat daftar drop-down, sehingga tetap memilih entri yang diinginkan dan menyimpannya. </p><br><p><img src="https://habrastorage.org/webt/-i/yr/8g/-iyr8gsoknvxwk0nsjvwtiolca0.png"></p><br><p>  Sekarang buka kode. </p><br><h3 id="pishem-kod">  Menulis kode </h3><br><p>  Kami akan menggunakan Bref untuk menulis kode.  Seperti disebutkan sebelumnya, pustaka ini diinstal menggunakan komposer, sehingga kode tersebut akan kompatibel dengan kerangka kerja apa pun.  Omong-omong, para pengembang telah menggambarkan proses menggunakan Bref dengan <a href="https://bref.sh/docs/frameworks/laravel.html">Laravel</a> dan <a href="https://bref.sh/docs/frameworks/symfony.html">Symfony</a> .  Tetapi disarankan bagi kita untuk mengerjakan PHP "telanjang" - ini akan membantu untuk lebih memahami esensinya. <br>  Kami mulai dengan dependensi: </p><br><pre> <code class="plaintext hljs">{ "require": { "php": "&gt;=7.2", "bref/bref": "^0.5.9", "telegram-bot/api": "*" }, "autoload": { "psr-4": { "App\": "src/" } } }</code> </pre> <br><p>  Kami akan menulis dalam PHP 7.2 dan lebih tinggi, dan untuk bekerja dengan Telegram, shell untuk API ini cocok untuk kami - <a href="https://github.com/TelegramBot/Api">https://github.com/TelegramBot/Api</a> .  Adapun kode itu sendiri, itu akan ditempatkan di direktori src. </p><br><p>  Jadi, lingkungan serverless sedang melalui dialog konsol.  Diperlukan aplikasi HTTP, dan dari sudut pandang Lambda, ini berarti panggilan skrip akan dieksekusi dengan cara yang sama seperti Nginx.  Interpretasi akan dilakukan oleh PHP-FPM.  Secara umum, ini lebih mirip panggilan skrip konsol standar.  Ini adalah poin penting, karena tanpa mempertimbangkan fitur ini, kami tidak akan dapat memanggil skrip melalui HTTP. <br>  Kami melakukan: </p><br><pre> <code class="plaintext hljs">vendor/bin/bref init</code> </pre> <br><p>  Dalam dialog, pilih item "aplikasi HTTP" dan jangan lupa untuk menentukan wilayah, karena aplikasi harus bekerja di wilayah yang sama di mana penyeimbang bekerja. <br>  Setelah inisialisasi, 2 file baru akan muncul: <br>  index.php - file yang dipanggil; <br>  serverless.yml - file konfigurasi penyebaran. <br>  Folder .serverless perlu segera ditambahkan ke .gitignore (folder tersebut akan muncul setelah upaya pertama yang digunakan). </p><br><p>  Setelah kami memiliki aplikasi web, kami akan memasukkan index.php ke folder publik, segera beralih ke serverless.yml.  Berikut ini tampilannya dalam implementasi kami: </p><br><pre> <code class="plaintext hljs">#  lambda- service: app #    provider: name: aws #   ! region: eu-central-1 #    runtime: provided # ,  bref  1024.         memoryLimit: 256 #   stage: dev #    environment: BOT_TOKEN: ${ssm:/app/bot-token} #  bref plugins: - ./vendor/bref/bref #  Lambda- functions: #       php-api-dev # service-function-stage api: handler: public/index.php description: '' # in seconds (API Gateway has a timeout of 29 seconds) timeout: 28 layers: - ${bref:layer.php-73-fpm} #     API Gateway events: - http: 'ANY /' - http: 'ANY /{proxy+}' #    environment: MY_VARIABLE: ${ssm:/app/my_variable}</code> </pre> <br><p>  Sekarang mari kita menganalisis garis yang tidak jelas.  Kami sebagian besar membutuhkan variabel lingkungan.  Kami tidak ingin koneksi database hardcode, API eksternal, dll. Jika kami terhubung ke Telegram, kami akan memiliki token kami sendiri, yang diterima dari BotFather.  Dan tidak disarankan untuk menyimpan token ini di serverless.yml, jadi lebih baik untuk mengirimnya ke penyimpanan ssm AWS: </p><br><pre> <code class="plaintext hljs">aws ssm put-parameter --region eu-central-1 --name '/app/my_variable' --type String --value '___BOTFATHER'</code> </pre> <br><p>  Omong-omong, kami merujuknya dalam konfigurasi. <br>  Variabel-variabel ini tersedia sebagai variabel lingkungan, dan Anda dapat mengaksesnya dalam PHP menggunakan fungsi getenv.  Jika kita berbicara tentang contoh kita, maka mari kita simpan token bot dalam lingkup global untuk kesederhanaan.  Kami juga dapat mentransfer token ke ruang lingkup fungsi tunggal, dan panggilan itu sendiri tidak akan berubah dari ini. </p><br><p>  Mari kita lanjutkan.  Sekarang mari kita membuat kelas BotApp sederhana - itu akan bertanggung jawab untuk menghasilkan respons untuk bot dan akan menanggapi perintah.  Pengembang Telegram merekomendasikan penambahan dukungan untuk perintah / help dan / start untuk semua bot.  Mari kita tambahkan perintah lain untuk bersenang-senang.  Kelas itu sendiri cukup sederhana dan memungkinkan untuk mengimplementasikan Front controller di index.php tanpa memuat file panggilan itu sendiri.  Untuk mendapatkan logika yang lebih kompleks, arsitektur harus dikembangkan dan rumit. </p><br><pre> <code class="plaintext hljs">&lt;?php namespace App; use TelegramBot\Api\Client; use Telegram\Bot\Objects\Update; class BotApp { function run(): void{ $token = getenv('BOT_TOKEN'); $bot = new Client($token); //   start $bot-&gt;command('start', function ($message) use ($bot) { $answer = ' !'; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); //    $bot-&gt;command('help', function ($message) use ($bot) { $answer = ': /help -  '; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); //   $bot-&gt;command('hello', function ($message) use ($bot) { $answer = '-,  - ,   Serverless '; $bot-&gt;sendMessage($message-&gt;getChat()-&gt;getId(), $answer); }); $bot-&gt;run(); } }</code> </pre> <br><p>  Dan di sini adalah daftar index.php: </p><br><pre> <code class="plaintext hljs">&lt;?php require_once('../vendor/autoload.php'); use App\BotApp; try{ $botApp = new BotApp(); $botApp-&gt;run(); } catch (Exception $e){ echo $e-&gt;getMessage(); print_r($e-&gt;getTrace(), 1); }</code> </pre> <br><p>  Ini mungkin tampak aneh, tetapi semuanya siap bagi kita untuk berangkat ke Produksi.  Mari kita lakukan ini dengan menjalankan perintah di folder serverless.yml: </p><br><pre> <code class="plaintext hljs">sls deploy</code> </pre> <br><p>  Dalam mode normal, serverless akan mengemas file dalam arsip zip, membuat S3-bucket tempat untuk meletakkannya, kemudian membuat atau memperbarui Aplikasi AWS yang dilampirkan ke Lambda, dan menempatkan kode dan runtime di lapisan yang terpisah. </p><br><p>  Selama peluncuran pertama, Gateway API akan dibuat (kami membiarkannya agar lebih mudah untuk menguji panggilan, tetapi kemudian disarankan untuk menghapusnya).  Anda juga perlu mengonfigurasi panggilan Lambda melalui ELB, yang kami pilih "Tambahkan pemicu" di jendela kontrol fungsi dan pilih "Application Load Balancer" di daftar turun bawah.  Anda perlu menentukan ELB yang dibuat sebelumnya, mengatur koneksi melalui HTTPS, membiarkan Host kosong, dan di Path menentukan jalur yang akan dipanggil Lambda (misalnya, / lambda / mytgbot).  Akibatnya, Lambda Anda akan tersedia di URL dengan jalur yang ditentukan. </p><br><p>  Sekarang Anda dapat mendaftarkan bagian respons bot di Telegram sehingga kurir mengerti ke mana harus mendapatkan pesan.  Untuk melakukan ini, panggil URL berikut di browser, tetapi jangan lupa untuk mengganti parameter Anda sendiri ke dalamnya: </p><br><pre> <code class="plaintext hljs">https://api.telegram.org/bot_/setWebhook?url=https://my-elb-host.com/lambda/mytgbot</code> </pre> <br><p>  Akibatnya, API akan mengembalikan "OK", setelah itu bot akan tersedia. </p><br><p><img src="https://habrastorage.org/webt/g-/rd/kl/g-rdkldh57hxw-sbbcl_ci9nmyk.png"></p><br><h2 id="testiruem-bota-na-lokali">  Menguji bot di lokal </h2><br><p>  Bot dapat diuji sebelum penyebaran.  Faktanya adalah bahwa Serverless Framework mendukung peluncuran di lokal menggunakan wadah Docker untuk ini.  Perintah panggilan: </p><br><pre> <code class="plaintext hljs">sls invoke local --docker -f myFunction</code> </pre> <br><p>  Jangan lupa bahwa kami menggunakan variabel lingkungan, jadi selama panggilan mereka juga harus diatur dalam format: </p><br><pre> <code class="plaintext hljs">sls invoke local --docker -f myFunction --env VAR1=val1</code> </pre> <br><h2 id="logi">  Log </h2><br><p>  Secara default, output panggilan akan masuk ke CloudWatch - tersedia di panel Pemantauan fungsi Lambda yang sesuai.  Di sini Anda dapat membaca jejak panggilan jika terjadi dump di sisi PHP.  Selain itu, Anda dapat menghubungkan layanan pemantauan lanjutan, tetapi mereka akan dikenakan biaya beberapa sen tambahan setiap bulan. </p><br><h2 id="itogo">  Total </h2><br><p>  Sebagai hasilnya, kami mendapat solusi yang cukup cepat, fleksibel, terukur, dan juga relatif murah.  Ya, Lambda tidak selalu menang dibandingkan dengan VM dan wadah standar, tetapi ada situasi ketika aplikasi Serverless membantu untuk "menembak" dengan cepat dan efisien.  Dan contoh bot yang dibuat hanya menunjukkan ini. <br>  Materi yang berguna tentang topik: </p><br><ul><li>  <a href="http.html">Dokumentasi bref</a> </li><li>  <a href="https://habr.com/ru/post/457100/">Teori Lambda</a> ; </li><li>  <a href="https://dev.to/sosnowski/anatomy-of-aws-lambda-1i1e">Anatomi Lambda</a> ; </li><li>  <a href="https://serverless.com/">Kerangka Tanpa Server</a> </li><li>  <a href="https://devenergy.ru/archives/941">Bot Telegram Serverless berbasis pada PHP dan AWS Lambda</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477370/">https://habr.com/ru/post/id477370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477358/index.html">Kami mengundang Anda ke DINS DevOps EVENING pada 5 Desember: kami berbicara tentang sistem pemrosesan acara, berbagi pengalaman dengan Influx</a></li>
<li><a href="../id477360/index.html">Apa yang Baru dalam Simulasi SOLIDWORKS 2020</a></li>
<li><a href="../id477362/index.html">Lebih dari anti-spam: cara mendapatkan yang terbaik dari Gateway Email Keamanan Anda</a></li>
<li><a href="../id477364/index.html">Bagaimana cara menjadi pengembang Java? Atau mungkin memilih Python?</a></li>
<li><a href="../id477366/index.html">Lima pertanyaan tentang merancang bahasa pemrograman</a></li>
<li><a href="../id477372/index.html">Amazon kalah perang karena kepalsuan</a></li>
<li><a href="../id477374/index.html">Mesin Z yang membingungkan</a></li>
<li><a href="../id477378/index.html">Mixed Agile - Pendekatan Waterfall ketika menerapkan aplikasi bisnis (alias Agile-like)</a></li>
<li><a href="../id477382/index.html">Esports - menghasilkan keuntungan: Mercedes, megaphone, taruhan, dan branding untuk esports</a></li>
<li><a href="../id477384/index.html">Konferensi “Keamanan Informasi. Ancaman masa kini dan masa depan ”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>