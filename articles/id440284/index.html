<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≠ ‚úãüèº üëÇüèª Tampilan segar menampilkan dialog di Android ü¶Ö üíÖüèª üë∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gambar tersebut menunjukkan pikiran pertama dari pembaca yang bertanya-tanya apa yang dapat ditulis tentang tugas sederhana seperti menampilkan dialog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tampilan segar menampilkan dialog di Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/440284/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/cu/u9/xl/cuu9xl-sjrrfz5v4pqqh9hocnxo.png"></a> </p><br><p>  Gambar tersebut menunjukkan pikiran pertama dari pembaca yang bertanya-tanya apa yang dapat ditulis tentang tugas sederhana seperti menampilkan dialog.  Manajer berpikir dengan cara yang sama: "Tidak ada yang rumit di sini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vasya</a> kami akan lakukan dalam 5 menit."  Tentu saja, saya melebih-lebihkan, tetapi pada kenyataannya semuanya tidak sesederhana seperti yang terlihat pada pandangan pertama.  Apalagi jika kita berbicara tentang Android. </p><br><p>  Jadi, 2019 ada di halaman, dan <strong>kami masih tidak tahu cara menampilkan dialog dengan benar</strong> . </p><a name="habracut"></a><br><p>  Mari kita lakukan secara berurutan dan mulai dengan pernyataan masalah: </p><br><blockquote>  Diperlukan untuk menampilkan dialog sederhana dengan teks untuk mengonfirmasi tindakan dan tombol "konfirmasi / batal".  Dengan mengklik tombol ‚Äúkonfirmasi‚Äù - lakukan tindakan, dengan tombol ‚Äúbatal‚Äù - tutup dialog. </blockquote><br><h1 id="reshenie-v-lob">  Solusi Dahi </h1><br><p>  Saya akan menyebut metode ini junior, karena ini bukan pertama kalinya saya menemukan kesalahpahaman mengapa Anda tidak bisa menggunakan AlertDialog, seperti yang ditunjukkan di bawah ini: </p><br><pre><code class="kotlin hljs">AlertDialog.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setMessage(<span class="hljs-string"><span class="hljs-string">"Please, confirm the action"</span></span>) .setPositiveButton(<span class="hljs-string"><span class="hljs-string">"Confirm"</span></span>) { dialog, which -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle click } .setNegativeButton("Cancel", null) .create() .show()</span></span></code> </pre> <br><p>  Cara yang cukup umum untuk pengembang pemula, sangat jelas dan intuitif.  Tetapi, seperti dalam banyak kasus ketika bekerja dengan Android, metode ini sepenuhnya salah.  Tiba-tiba, kami mendapatkan kebocoran memori, cukup hidupkan perangkat, dan Anda akan melihat kesalahan berikut dalam log: </p><br><div class="spoiler">  <b class="spoiler_title">stacktrace</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">E/WindowManager: android.view.WindowLeaked: Activity com.example.testdialog.MainActivity has leaked window DecorView@71b5789[MainActivity] that was originally added here at android.view.ViewRootImpl.&lt;init&gt;(ViewRootImpl.java:511) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:346) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93) at android.app.Dialog.show(Dialog.java:329) at com.example.testdialog.MainActivity.onCreate(MainActivity.kt:27) at android.app.Activity.performCreate(Activity.java:7144) at android.app.Activity.performCreate(Activity.java:7135) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1271) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2931) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3086) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1816) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6718) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)</code> </pre></div></div><br><p>  Di Stackoverflow, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertanyaan</a> tentang masalah ini adalah salah satu yang paling populer.  Singkatnya, masalahnya adalah kita menunjukkan dialog atau tidak menutup dialog setelah aktivasi selesai. </p><br><p>  Anda dapat, tentu saja, mengabaikan panggilan pada dialog di aktivitas onPause atau onDestroy, seperti yang disarankan dalam jawaban dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> .  Tapi ini bukan yang kita butuhkan.  Kami ingin dialog pulih setelah memutar perangkat. </p><br><h1 id="ustarevshiy-sposob">  Cara yang ketinggalan jaman </h1><br><p>  Sebelum fragmen muncul di Android, dialog seharusnya ditampilkan melalui panggilan ke metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aktivasi showDialog</a> .  Dalam hal ini, aktivitas mengelola siklus hidup dialog dengan benar dan mengembalikannya setelah berbelok.  Penciptaan dialog itu sendiri harus diimplementasikan dalam panggilan balik onCreateDialog: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CONFIRMATION_DIALOG_ID = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... @Override protected Dialog onCreateDialog(int id, Bundle args) { if (id == CONFIRMATION_DIALOG_ID) { return new AlertDialog.Builder(this) .setMessage("Please, confirm the action") .setPositiveButton("Confirm", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // handle click } }) .create(); } else { return super.onCreateDialog(id, args); } } }</span></span></code> </pre> <br><p>  Sangat tidak nyaman bahwa Anda harus memulai pengidentifikasi dialog dan meneruskan parameter melalui Bundle.  Dan kita masih bisa mendapatkan masalah "jendela bocor" jika kita mencoba menampilkan dialog setelah memanggil onDestroy pada aktivitas.  Ini dimungkinkan, misalnya, ketika mencoba menampilkan kesalahan setelah operasi asinkron. </p><br><p>  Secara umum, masalah ini tipikal untuk Android, ketika Anda perlu melakukan sesuatu setelah operasi asinkron, dan aktivitas atau fragmen sudah hancur pada saat itu.  Ini mungkin mengapa pola MV * lebih populer di komunitas Android daripada di antara pengembang iOS. </p><br><h1 id="sposob-iz-dokumentacii">  Metode dari dokumentasi </h1><br><p>  Fragmen muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Android Honeycomb</a> , dan metode yang dijelaskan di atas sudah tidak digunakan lagi, dan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">showDialog</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aktivitas</a> ditandai sebagai sudah usang.  Tidak, AlertDialog tidak ketinggalan zaman, karena banyak yang salah.  Baru saja ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DialogFragment</a> , yang membungkus objek dialog dan mengontrol siklus hidupnya. </p><br><blockquote>  Cuplikan asli juga tidak digunakan lagi sejak API 28.  Sekarang Anda harus menggunakan hanya implementasi dari Perpustakaan Dukungan (AndroidX). </blockquote><p>  Mari selesaikan tugas kita, sebagaimana ditentukan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> : </p><br><ol><li>  Pertama, Anda perlu mewarisi dari DialogFragment dan mengimplementasikan pembuatan dialog dalam metode onCreateDialog. </li><li>  Jelaskan antarmuka acara dialog dan instantiate pendengar dalam metode onAttach. </li><li>  Menerapkan antarmuka acara dialog dalam suatu kegiatan atau fragmen. </li></ol><br><blockquote>  Jika pembaca tidak begitu jelas mengapa pendengar tidak dapat melewati konstruktor, maka dia dapat membaca lebih lanjut tentang ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </blockquote><p>  Kode fragmen dialog: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DialogFragment</span></span></span></span>() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener: ConfirmationListener <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAttach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAttach(context) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Instantiate the ConfirmationListener so we can send events to the host listener = activity as ConfirmationListener } catch (e: ClassCastException) { // The activity doesn't implement the interface, throw exception throw ClassCastException(activity.toString() + " must implement ConfirmationListener") } } override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { return AlertDialog.Builder(context!!) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; listener.confirmButtonClicked() } .setNegativeButton("Cancel") { _, _ -&gt; listener.cancelButtonClicked() } .create() } }</span></span></code> </pre> <br><p>  Kode Aktivasi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), ConfirmationListener { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showConfirmationDialog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ConfirmationDialogFragment() .show(supportFragmentManager, <span class="hljs-string"><span class="hljs-string">"ConfirmationDialogFragmentTag"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// handle click } override fun cancelButtonClicked() { // handle click } }</span></span></code> </pre> <br><p>  Kode yang cukup ternyata, kan? </p><br><p>  Sebagai aturan, ada beberapa jenis MVP dalam proyek ini, tetapi saya memutuskan bahwa panggilan presenter dapat dihilangkan dalam kasus ini.  Dalam contoh di atas, ada baiknya menambahkan metode statis untuk membuat dialogInstance baru dan meneruskan parameter ke argumen fragmen, semua seperti yang diharapkan. </p><br><p>  Dan ini semua agar dialog bersembunyi tepat waktu dan dikembalikan dengan benar.  Tidak mengherankan bahwa pertanyaan seperti itu muncul di Stackoverflow: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> . </p><br><h1 id="poisk-idealnogo-resheniya">  Menemukan solusi sempurna </h1><br><p>  Keadaan saat ini tidak sesuai dengan kami, dan kami mulai mencari cara untuk membuat bekerja dengan dialog lebih nyaman.  Ada perasaan bahwa Anda dapat membuatnya lebih mudah, hampir seperti pada metode pertama. </p><br><p>  Berikut ini adalah pertimbangan yang memandu kami: </p><br><ul><li>  <strong>Apakah saya perlu menyimpan dan memulihkan dialog setelah mematikan proses aplikasi?</strong> <br>  Dalam kebanyakan kasus, ini tidak diperlukan, seperti dalam contoh kami, ketika Anda perlu menunjukkan pesan sederhana atau bertanya sesuatu.  Dialog semacam itu relevan sampai perhatian pengguna hilang.  Jika Anda mengembalikannya setelah lama tidak ada dalam aplikasi, pengguna akan kehilangan konteks dengan tindakan yang direncanakan.  Karena itu, <strong>Anda hanya perlu mendukung belokan perangkat</strong> dan menangani siklus hidup dialog dengan benar.  Jika tidak, dari pergerakan perangkat yang canggung, pengguna dapat kehilangan pesan yang baru saja dibuka tanpa membacanya. </li><li>  Saat menggunakan DialogFragment, terlalu banyak kode boilerplate muncul, kesederhanaan hilang.  Oleh karena itu, alangkah baiknya untuk menghilangkan fragmen sebagai pembungkus dan <strong>menggunakan Dialog secara langsung</strong> .  Untuk melakukan ini, Anda harus menyimpan keadaan dialog untuk menampilkannya lagi setelah membuat kembali Lihat dan menyembunyikannya ketika Tampilan mati. </li><li>  Semua orang terbiasa memahami tampilan dialog sebagai sebuah tim, terutama jika Anda hanya bekerja dengan MVP.  Tugas pemulihan negara selanjutnya dipikul oleh Manajer Fragment.  Tetapi Anda dapat melihat situasi ini secara berbeda dan mulai <strong>menganggap dialog sebagai suatu keadaan</strong> .  Ini jauh lebih nyaman ketika bekerja dengan pola PM atau MVVM. </li><li>  Mengingat sebagian besar aplikasi sekarang menggunakan pendekatan reaktif, ada kebutuhan <strong>untuk dialog menjadi reaktif</strong> .  Tugas utama bukanlah untuk memutus rantai yang mengawali tampilan dialog, dan untuk melampirkan aliran peristiwa yang reaktif untuk mendapatkan hasil darinya.  Ini sangat nyaman di sisi PresentationModel / ViewModel ketika Anda memanipulasi beberapa aliran data. </li></ul><br><p>  Kami memperhitungkan semua persyaratan di atas dan menemukan cara untuk menampilkan dialog secara reaktif, yang berhasil kami implementasikan di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxPM</a> kami (ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> terpisah tentang hal itu). </p><br><p>  Solusinya sendiri tidak memerlukan perpustakaan dan dapat dilakukan secara terpisah.  Dipandu oleh ide "dialog as state", Anda dapat mencoba membangun solusi berdasarkan ViewModel dan LiveData yang trendi.  Tetapi saya akan menyerahkan hak ini kepada pembaca, dan kemudian kita akan berbicara tentang solusi yang sudah jadi dari perpustakaan. </p><br><h1 id="reaktivnyy-sposob">  Metode reaktif </h1><br><p>  Saya akan menunjukkan bagaimana tugas awal diselesaikan dalam RxPM, tetapi pertama-tama beberapa kata tentang konsep-konsep kunci dari perpustakaan: </p><br><ul><li>  <strong>PresentationModel</strong> - menyimpan keadaan reaksi, berisi UI-logika, selamat dari belokan. </li><li>  <strong>Negara</strong> adalah <strong>keadaan</strong> reaktif.  Anda dapat menganggapnya sebagai pembungkus BehaviorRelay. </li><li>  <strong>Action</strong> - pembungkus di atas PublishRelay, berfungsi untuk mentransfer acara dari View ke PresentationModel. </li><li>  <strong>Negara</strong> dan <strong>Tindakan</strong> telah diamati dan konsumen. </li></ul><br><p>  Kelas <a href="">DialogControl</a> bertanggung jawab atas keadaan dialog.  Ini memiliki dua parameter: yang pertama untuk tipe data yang harus ditampilkan dalam dialog, yang kedua untuk tipe hasil.  Dalam contoh kami, tipe data akan menjadi Unit, tetapi bisa berupa pesan kepada pengguna atau tipe lainnya. </p><br><p>  DialogControl memiliki metode berikut: </p><br><ul><li>  <code>show(data: T)</code> - hanya memberikan perintah untuk ditampilkan. </li><li>  <code>showForResult(data: T): Maybe&lt;R&gt;</code> - menampilkan dialog dan membuka aliran untuk mendapatkan hasilnya. </li><li>  <code>sendResult(result: R)</code> - mengirim hasilnya, dipanggil dari sisi View. </li><li>  <code>dismiss()</code> - hanya menyembunyikan dialog. </li></ul><br><p>  DialogControl menyimpan status - apakah ada dialog di layar atau tidak (Ditampilkan / Tidak Ada).  Ini adalah tampilannya di kode kelas: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogControl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T, R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(pm: PresentationModel) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> displayed = pm.State&lt;Display&gt;(Absent) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = pm.Action&lt;R&gt;() <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Display</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Displayed</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T) : Display() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Absent : Display() } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Buat PresentationModel sederhana: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SamplePresentationModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresentationModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogResult</span></span></span><span class="hljs-class"> </span></span>{ CONFIRMED, CANCELED } <span class="hljs-comment"><span class="hljs-comment">//        enum    val confirmationDialog = dialogControl&lt;Unit, ConfirmationDialogResult&gt;() val buttonClicks = Action&lt;Unit&gt;() override fun onCreate() { super.onCreate() buttonClicks.observable .switchMapMaybe { //           confirmationDialog.showForResult(Unit) .filter { it == ConfirmationDialogResult.CONFIRMED } } .subscribe { //   } .untilDestroy() } }</span></span></code> </pre> <br><p>  Harap perhatikan bahwa pemrosesan klik, konfirmasi konfirmasi, dan pemrosesan tindakan diimplementasikan dalam rantai yang sama.  Ini memungkinkan Anda untuk membuat kode fokus dan tidak menyebarkan logika di beberapa panggilan balik. </p><br><p>  Selanjutnya, kita cukup mengikat DialogControl ke View menggunakan ekstensi bindTo. <br>  Kami mengumpulkan AlertDialog yang biasa, dan mengirim hasilnya melalui sendResult: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PmSupportActivity</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SamplePresentationModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">providePresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = SamplePresentationModel() <span class="hljs-comment"><span class="hljs-comment">//     View  PresentationModel override fun onBindPresentationModel(pm: SamplePresentationModel) { pm.confirmationDialog bindTo { data, dialogControl -&gt; AlertDialog.Builder(this@SampleActivity) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; dialogControl.sendResult(CONFIRMED) } .setNegativeButton("Cancel") { _, _ -&gt; dialogControl.sendResult(CANCELED) } .create() } button.clicks() bindTo pm.buttonClicks } }</span></span></code> </pre> <br><p>  Dalam skenario tipikal, hal seperti ini terjadi di bawah tenda: </p><br><ol><li>  Kami klik pada tombol, acara melalui Aksi "buttonClicks" masuk ke PresentationModel. </li><li>  Untuk acara ini, kami meluncurkan tampilan dialog melalui panggilan ke showForResult. </li><li>  Akibatnya, keadaan di DialogControl berubah dari Absen ke Ditampilkan. </li><li>  Ketika acara yang ditampilkan diterima, lambda yang kami lewati dalam ikatan bindTo disebut.  Objek dialog dibuat di dalamnya, yang kemudian ditampilkan. </li><li>  Pengguna menekan tombol Konfirmasi, pendengar menyala, dan hasil klik dikirim ke DialogControl dengan memanggil sendResult. </li><li>  Selanjutnya, hasilnya jatuh ke dalam "Aksi hasil" internal, dan status dari Perubahan yang ditampilkan ke Absen. </li><li>  Ketika acara Absen diterima, dialog saat ini ditutup. </li><li>  Acara dari "hasil" Tindakan jatuh ke aliran yang dibuka oleh panggilan untuk showForResult dan diproses oleh rantai di PresentationModel. </li></ol><br><p>  Perlu dicatat bahwa dialog ditutup bahkan ketika View dilepaskan dari PresentationModel.  Dalam hal ini, statusnya tetap Ditampilkan.  Itu akan diterima pada ikatan berikutnya dan dialog akan dipulihkan. </p><br><p>  Seperti yang Anda lihat, kebutuhan untuk DialogFragment hilang.  Dialog ditampilkan ketika tampilan dilampirkan ke PresentationModel dan disembunyikan ketika tampilan dilepaskan.  Karena kenyataan bahwa negara disimpan dalam DialogControl, yang pada gilirannya disimpan dalam PresentationModel, dialog dikembalikan setelah perangkat diputar. </p><br><h1 id="pishite-dialogi-pravilno">  Tulis dialog dengan benar </h1><br><p>  Kami telah memeriksa beberapa cara untuk menampilkan dialog.  Jika Anda masih menunjukkan cara pertama, maka saya mohon, jangan lakukan lagi.  Bagi pecinta MVP tidak ada yang tersisa selain menggunakan metode standar, yang dijelaskan dalam dokumentasi resmi.  Sayangnya, kecenderungan imperatifitas dari pola ini tidak memungkinkan untuk melakukan sebaliknya.  Yah, saya sarankan penggemar RxJava melihat lebih dekat pada metode reaktif dan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxPM</a> kami. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440284/">https://habr.com/ru/post/id440284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440274/index.html">Membangun Layanan Mata Uang Pribadi Menggunakan Exonum</a></li>
<li><a href="../id440276/index.html">Front end dan debugging ujung belakang</a></li>
<li><a href="../id440278/index.html">Alihkan Tinder ke Kubernetes</a></li>
<li><a href="../id440280/index.html">Ulasan Perangkat Lunak Bebas Android</a></li>
<li><a href="../id440282/index.html">Kerangka kerja web Python tercepat di 2019</a></li>
<li><a href="../id440286/index.html">Perlin noise, pembuatan konten prosedural, dan ruang yang menarik</a></li>
<li><a href="../id440288/index.html">Keamanan IOT. Masalah 1. Jam tangan pintar, pelacak kebugaran, dan timbangan</a></li>
<li><a href="../id440292/index.html">Buku ‚ÄúUnity in action. Pengembangan lintas platform dalam C #. Int 2. edisi ¬ª</a></li>
<li><a href="../id440294/index.html">MIDI-router di Raspberry Pi</a></li>
<li><a href="../id440296/index.html">6 Aplikasi untuk IoT Industri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>