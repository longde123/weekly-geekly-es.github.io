<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèª ‚Ü©Ô∏è üëµüèº Predicci√≥n f√≠sica del lado del cliente en Unity üíº üë®üèº‚Äçüî¨ ü§Ωüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 Cre√© una demostraci√≥n que muestra c√≥mo implementar la predicci√≥n del lado del cliente del movimiento f√≠sico de un jugador en Unity: GitHub . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Predicci√≥n f√≠sica del lado del cliente en Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="imagen"></div><br><h3>  TL; DR </h3><br>  Cre√© una demostraci√≥n que muestra c√≥mo implementar la predicci√≥n del lado del cliente del movimiento f√≠sico de un jugador en Unity: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h3>  Introduccion </h3><br>  A principios de 2012, escrib√≠ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> sobre c√≥mo implementar pron√≥sticos en el lado del cliente del movimiento f√≠sico de un jugador en Unity.  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Physics.Simulate (),</a> esa torpe soluci√≥n que describ√≠ ya no es necesaria.  La publicaci√≥n anterior sigue siendo una de las m√°s populares en mi blog, pero para la Unidad moderna esta informaci√≥n ya es incorrecta.  Por lo tanto, estoy lanzando la versi√≥n 2018. <br><br><h3>  ¬øQu√© hay del lado del cliente? </h3><br>  En los juegos competitivos multijugador, se debe evitar hacer trampa siempre que sea posible.  Por lo general, esto significa que se usa un modelo de red con un servidor autoritario: los clientes env√≠an la informaci√≥n ingresada al servidor, y el servidor convierte esta informaci√≥n en el movimiento de un jugador, y luego env√≠a una instant√°nea del estado del jugador al cliente.  En este caso, hay un retraso entre presionar la tecla y mostrar el resultado, lo cual es inaceptable para cualquier juego activo.  La predicci√≥n del lado del cliente es una t√©cnica muy popular que oculta el retraso, prediciendo cu√°l ser√° el movimiento resultante y ense√±√°ndolo inmediatamente al jugador.  Cuando el cliente recibe los resultados del servidor, los compara con lo que predijo el cliente, y si difieren, el pron√≥stico era err√≥neo y debe corregirse. <br><a name="habracut"></a><br>  Las instant√°neas recibidas del servidor siempre provienen del pasado con respecto al estado predicho del cliente (por ejemplo, si la transferencia de datos del cliente al servidor y viceversa toma 150 ms, entonces cada instant√°nea se retrasar√° al menos 150 ms).  Como resultado de esto, cuando el cliente necesita corregir el pron√≥stico incorrecto, debe retroceder a este punto en el pasado y luego reproducir toda la informaci√≥n ingresada en el espacio para volver a donde est√°.  Si el movimiento del jugador en el juego se basa en la f√≠sica, entonces Physics.Simulate () es necesario para simular varios ciclos en un cuadro.  Si solo se usan los Controladores de personaje (o el lanzamiento de c√°psulas, etc.) al mover al jugador, entonces puedes prescindir de Physics.Simulate (), y supongo que el rendimiento ser√° mejor. <br><br>  Usar√© Unity para recrear una demostraci√≥n de red llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Zen of Networked Physics de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Glenn Fiedler</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">",</a> que he disfrutado durante mucho tiempo.  El jugador tiene un cubo f√≠sico sobre el cual puede ejercer fuerza, empuj√°ndolo a la escena.  La demostraci√≥n simula varias condiciones de red, incluida la demora y la p√©rdida de paquetes. <br><br><h3>  Llegar al trabajo </h3><br>  Lo primero que debe hacer es desactivar la simulaci√≥n autom√°tica de f√≠sica.  Aunque Physics.Simulate () nos permite decirle al sistema f√≠sico cu√°ndo comenzar la simulaci√≥n, por defecto realiza la simulaci√≥n autom√°ticamente en funci√≥n de un delta de tiempo de proyecto fijo.  Por lo tanto, lo deshabilitaremos en <strong>Edici√≥n-&gt; Configuraci√≥n del proyecto-&gt; F√≠sica</strong> desmarcando la casilla " <strong>Simulaci√≥n autom√°tica</strong> ". <br><br>  Para comenzar, crearemos una implementaci√≥n simple para un solo usuario.  La entrada se muestrea (w, a, s, d para moverse y el espacio para saltar), y todo se reduce a las fuerzas simples aplicadas al Rigidbody usando AddForce (). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>El jugador se mueve mientras la red no est√° en uso</i> <br><br><h3>  Env√≠o de entrada al servidor </h3><br>  Ahora tenemos que enviar la entrada al servidor, que tambi√©n ejecutar√° este c√≥digo de movimiento, tomar√° una instant√°nea del estado del cubo y lo enviar√° de vuelta al cliente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Nada especial aqu√≠ hasta ahora, lo √∫nico a lo que quiero prestar atenci√≥n es agregar la variable tick_number.  Es necesario para que cuando el servidor env√≠e instant√°neas del estado del cubo al cliente, podamos averiguar qu√© tacto del cliente corresponde a este estado, de modo que podamos comparar este estado con el cliente predicho (que agregaremos un poco m√°s adelante). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Todo es simple: el servidor espera mensajes de entrada, cuando lo recibe, simula un ciclo de reloj.  Luego toma una instant√°nea del estado resultante del cubo y lo env√≠a de vuelta al cliente.  Puede observar que tick_number en el mensaje de estado es uno mayor que tick_number en el mensaje de entrada.  Esto se hace porque personalmente es intuitivamente m√°s conveniente para m√≠ pensar en el "estado del jugador en el tacto 100" como el "estado del jugador al <strong>comienzo del</strong> tacto 100".  Por lo tanto, el estado del jugador en la medida 100 en combinaci√≥n con la entrada del jugador en la medida 100 crea un nuevo estado para el jugador en la medida 101. <br><br><h1>  Estado <sub>n</sub> + Entrada <sub>n</sub> = Estado <sub>n + 1</sub> </h1><br>  No estoy diciendo que debas tomarlo de la misma manera, lo principal es la constancia del enfoque. <br><br>  Tambi√©n debe decirse que no <em>env√≠o</em> estos mensajes a trav√©s de un socket real, sino que los imito escribi√©ndolos en la cola, simulando el retraso y la p√©rdida de paquetes.  La escena contiene dos cubos f√≠sicos: uno para el cliente y otro para el servidor.  Al actualizar el cubo del cliente, desactivo el GameObject del cubo del servidor y viceversa. <br><br>  Sin embargo, no simulo el rebote de la red y la entrega de paquetes en el orden incorrecto, por lo que supongo que cada mensaje de entrada recibido es m√°s nuevo que el anterior.  Esta imitaci√≥n es necesaria para ejecutar simplemente el "cliente" y el "servidor" en una instancia de Unity, de modo que podamos combinar los cubos de servidor y cliente en una escena. <br><br>  Tambi√©n puede observar que si el mensaje de entrada se descarta y no llega al servidor, el servidor simula menos ciclos de reloj que el cliente y, por lo tanto, crear√° un estado diferente.  Esto es cierto, pero incluso si simulamos estas omisiones, la entrada podr√≠a ser incorrecta, lo que tambi√©n conducir√≠a a un estado diferente.  Nos ocuparemos de este problema m√°s tarde. <br><br>  Tambi√©n se debe agregar que en este ejemplo solo hay un cliente, lo que simplifica el trabajo.  Si tuvi√©ramos varios clientes, necesitar√≠amos a) al llamar a Physics.Simulate () para verificar que solo el cubo de un jugador est√© habilitado en el servidor, o b) si el servidor recibi√≥ informaci√≥n de varios cubos, sim√∫lelos todos juntos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Retraso 75 ms (150 ms ida y vuelta)</i> <i><br></i>  <i>0% paquetes perdidos</i> <i><br></i>  <i>Cubo amarillo - jugador del servidor</i> <i><br></i>  <i>Cubo azul: la √∫ltima instant√°nea recibida por el cliente</i> <br><br>  Todo se ve bien hasta ahora, pero fui un poco selectivo con lo que grab√© en el video para ocultar un problema bastante serio. <br><br><h3>  Fracaso de determinaci√≥n </h3><br>  Echa un vistazo ahora a esto: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Ay ...</i> <br><br>  Este video fue grabado sin perder paquetes, sin embargo, las simulaciones a√∫n var√≠an con la misma entrada.  No entiendo bien por qu√© sucede esto: PhysX deber√≠a ser bastante determinista, por lo que me parece sorprendente que las simulaciones a menudo diverjan.  Esto puede deberse al hecho de que constantemente habilito y deshabilito los cubos de GameObject, es decir, es posible que el problema disminuya al usar dos instancias diferentes de Unity.  Puede ser un error, si lo ve en el c√≥digo de GitHub, av√≠seme. <br><br>  Sea como fuere, los pron√≥sticos incorrectos son un hecho esencial en el pron√≥stico del lado del cliente, as√≠ que tratemos con ellos. <br><br><h3>  ¬øPuedo rebobinar? </h3><br>  El proceso es bastante simple: cuando el cliente predice el movimiento, guarda un b√∫fer de estado (posici√≥n y rotaci√≥n) y una entrada.  Despu√©s de recibir un mensaje de estado del servidor, compara el estado recibido con el estado predicho del b√∫fer.  Si difieren en un valor demasiado grande, redefinimos el estado del cubo del cliente en el pasado y luego simulamos nuevamente todas las medidas intermedias. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Los datos de entrada y estado almacenados en el b√∫fer se almacenan en un b√∫fer circular muy simple, donde el identificador de medida se usa como √≠ndice.  Y eleg√≠ el valor de 64 Hz para la frecuencia de reloj de la f√≠sica, es decir, un b√∫fer de 1024 elementos nos da espacio durante 16 segundos, y esto es mucho m√°s de lo que podemos necesitar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>La correcci√≥n est√° en marcha!</i> <br><br><h3>  Transferencia de entrada redundante </h3><br>  Los mensajes de entrada suelen ser muy peque√±os: los botones presionados se pueden combinar en un campo de bits que solo ocupa unos pocos bytes.  Todav√≠a hay un n√∫mero de medida en nuestro mensaje, que ocupa 4 bytes, pero podemos comprimirlos f√°cilmente usando un valor de 8 bits con un acarreo (tal vez el intervalo 0-255 ser√° demasiado peque√±o, podemos estar seguros y aumentarlo a 9 o 10 bits).  Sea como fuere, estos mensajes son bastante peque√±os, y esto significa que podemos enviar muchos datos de entrada en cada mensaje (en caso de que se hayan perdido los datos de entrada anteriores).  ¬øQu√© tan atr√°s deber√≠amos regresar?  Bueno, el cliente conoce el n√∫mero de medida del √∫ltimo mensaje de estado que recibi√≥ del servidor, por lo que no tiene sentido volver m√°s all√° de esta medida.  Tambi√©n necesitamos imponer un l√≠mite en la cantidad de datos de entrada redundantes enviados por el cliente.  No hice esto en mi demo, pero deber√≠a implementarse en el c√≥digo terminado. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Este es un cambio simple, el cliente simplemente escribe el n√∫mero de medida del √∫ltimo mensaje de estado recibido. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  El mensaje de entrada enviado por el cliente ahora contiene una lista de datos de entrada, no solo un elemento.  La parte con el n√∫mero de medida obtiene un nuevo valor; ahora es el n√∫mero de medida de la primera entrada de esta lista. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Cuando el servidor recibe un mensaje de entrada, conoce el n√∫mero de medida de la primera entrada y la cantidad de datos de entrada en el mensaje.  Por lo tanto, puede calcular la medida de la √∫ltima entrada en el mensaje.  Si esta √∫ltima medida es mayor o igual que el n√∫mero de medida del servidor, entonces sabe que el mensaje contiene al menos una entrada que el servidor a√∫n no ha visto.  Si es as√≠, simula todos los datos de entrada nuevos. <br><br>  Es posible que haya notado que <em>si</em> limitamos la cantidad de datos de entrada redundantes en el mensaje de entrada, con un n√∫mero suficientemente grande de mensajes de entrada perdidos, tendremos una brecha de simulaci√≥n entre el servidor y el cliente.  Es decir, el servidor puede simular la medida 100, enviar un mensaje de estado para iniciar la medida 101 y luego recibir un mensaje de entrada que comienza en la medida 105. En el c√≥digo anterior, el servidor ir√° a 105, no intentar√° simular medidas intermedias basadas en los √∫ltimos datos de entrada conocidos.  Si lo necesitas depende de tu decisi√≥n y de cu√°l deber√≠a ser el juego.  Personalmente, no forzar√≠a al servidor a especular y mover al jugador en el mapa debido al mal estado de la red.  Creo que es mejor dejar el reproductor en su lugar hasta que se restablezca la conexi√≥n. <br><br>  En la demostraci√≥n "Zen of Networked Physics" hay una funci√≥n para enviar "movimientos importantes" por parte del cliente, es decir, env√≠a datos de entrada redundantes solo cuando difiere de la entrada transmitida anteriormente.  Esto se puede llamar compresi√≥n delta de entrada, y con √©l puede reducir a√∫n m√°s el tama√±o de los mensajes de entrada.  Pero hasta ahora no lo he hecho, porque en esta demostraci√≥n no hay optimizaci√≥n de la carga de la red. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Antes de enviar datos de entrada redundantes: cuando se pierde el 25% de los paquetes, el movimiento del cubo es lento y se contrae, contin√∫a siendo devuelto.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Despu√©s de enviar datos de entrada redundantes: con una p√©rdida del 25% de los paquetes, todav√≠a hay una correcci√≥n de contracci√≥n, pero los cubos se mueven a una velocidad aceptable.</i> <br><br><h3>  Frecuencia variable de instant√°neas </h3><br>  En esta demostraci√≥n, la frecuencia con la que el servidor env√≠a instant√°neas al cliente var√≠a.  Con una frecuencia reducida, el cliente necesitar√° m√°s tiempo para recibir la correcci√≥n del servidor.  Por lo tanto, cuando el cliente se equivoca en el pron√≥stico, antes de recibir un mensaje de estado puede desviarse a√∫n m√°s, lo que conducir√° a una correcci√≥n m√°s notable.  Con una alta frecuencia de instant√°neas, la p√©rdida de paquetes es mucho menos importante, por lo que el cliente no tiene que esperar mucho para recibir la pr√≥xima instant√°nea. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frecuencia de instant√°nea 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frecuencia de instant√°nea 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Frecuencia de instant√°nea 2 Hz</i> <br><br>  Obviamente, cuanto mayor sea la frecuencia de las instant√°neas, mejor, por lo que debe enviarlas con la mayor frecuencia posible.  Pero tambi√©n depende de la cantidad de tr√°fico adicional, su costo, la disponibilidad de servidores dedicados, los costos inform√°ticos de los servidores, etc. <br><br><h3>  Correcci√≥n de suavizado </h3><br>  Creamos pron√≥sticos incorrectos y obtenemos correcciones desiguales con m√°s frecuencia de la que nos gustar√≠a.  Sin el acceso adecuado a la integraci√≥n de Unity / PhysX, apenas puedo depurar estos pron√≥sticos err√≥neos.  He dicho esto antes, pero repito una vez m√°s: si encuentra algo relacionado con la f√≠sica, en lo que estoy equivocado, h√°gamelo saber. <br><br>  ¬°Elud√≠ la soluci√≥n a este problema al pasar por alto las grietas con un buen alisado!  Cuando se produce una correcci√≥n, el cliente simplemente suaviza la posici√≥n y la rotaci√≥n del jugador en la direcci√≥n del estado correcto durante varios fotogramas.  El cubo f√≠sico en s√≠ mismo se corrige instant√°neamente (es invisible), pero tenemos un segundo cubo solo para visualizaci√≥n, que permite suavizar. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Cuando ocurre un pron√≥stico err√≥neo, el cliente rastrea la diferencia de posici√≥n / rotaci√≥n despu√©s de la correcci√≥n.  Si la distancia total de correcci√≥n de posici√≥n es m√°s de 2 metros, entonces el cubo simplemente se mueve bruscamente; el alisado a√∫n se ver√≠a mal, as√≠ que al menos vuelva al estado correcto lo m√°s r√°pido posible. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  En cada cuadro, el cliente realiza lerp / slerp hacia la posici√≥n / rotaci√≥n correcta en un 10%, este es un enfoque est√°ndar de ley de potencia para promediar el movimiento.  Depende de la velocidad de fotogramas, pero para los fines de nuestra demostraci√≥n esto es suficiente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms de retraso</i> <i><br></i>  <i>Perdi√≥ el 10% de los paquetes</i> <i><br></i>  <i>Sin suavizado, la correcci√≥n es muy notable.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms de retraso</i> <i><br></i>  <i>Perdi√≥ el 10% de los paquetes</i> <i><br></i>  <i>Con el suavizado, la correcci√≥n es mucho m√°s dif√≠cil de notar.</i> <br><br>  El resultado final funciona bastante bien, quiero crear una versi√≥n que realmente env√≠e paquetes, en lugar de imitarlos.  Pero al menos esto es una prueba de concepto para un sistema de pron√≥stico del lado del cliente con objetos f√≠sicos reales en Unity sin la necesidad de complementos f√≠sicos y similares. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432190/">https://habr.com/ru/post/es432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432180/index.html">C√≥mo impulsar tu carrera a trav√©s de GitHub</a></li>
<li><a href="../es432182/index.html">Recogemos correo sin sms ni registro</a></li>
<li><a href="../es432184/index.html">Identidades problem√°ticas entre probadores</a></li>
<li><a href="../es432186/index.html">Usando STP para crear canales p2p</a></li>
<li><a href="../es432188/index.html">Los piratas inform√°ticos APT28 atacaron buzones de correo electr√≥nico de cientos de empleados del ministerio checo</a></li>
<li><a href="../es432192/index.html">4 se√±ales de que no est√° listo para implementar una soluci√≥n de gesti√≥n de proyectos</a></li>
<li><a href="../es432196/index.html">Acerca de la composici√≥n de funciones en JavaScript</a></li>
<li><a href="../es432198/index.html">Delivery Manager: un nuevo papel en el mundo √°gil</a></li>
<li><a href="../es432200/index.html">C√≥mo Ivan investig√≥ la conversi√≥n de stands</a></li>
<li><a href="../es432202/index.html">Generando tipos de personajes sobre la marcha (o locos con Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>