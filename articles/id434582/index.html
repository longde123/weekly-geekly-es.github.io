<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ¼ â˜ğŸ½ â• Solusi arsitektur untuk gim seluler. Bagian 1: Model ğŸŒ‰ ğŸ”¯ ğŸ”ˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Epigraf: 
 - Bagaimana saya akan mengevaluasi jika Anda tidak tahu harus berbuat apa? 
 - Ya, akan ada layar dan tombol. 
 - Dima, Anda sekarang telah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solusi arsitektur untuk gim seluler. Bagian 1: Model</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434582/">  <i>Epigraf:</i> <i><br></i>  <i>- Bagaimana saya akan mengevaluasi jika Anda tidak tahu harus berbuat apa?</i> <i><br></i>  <i>- Ya, akan ada layar dan tombol.</i> <i><br></i>  <i>- Dima, Anda sekarang telah menggambarkan seluruh hidup saya dalam tiga kata!</i> <i><br></i>  <i>(c) Dialog nyata pada rapat umum di perusahaan game</i> <br><br><img src="https://habrastorage.org/webt/zp/ab/js/zpabjszvfb5gcancgd76i5trlz8.jpeg"><br><br>  Rangkaian kebutuhan dan solusi yang memenuhi mereka, yang akan saya bahas dalam artikel ini, dibentuk selama partisipasi saya di sekitar selusin proyek besar, pertama di Flash dan kemudian di Unity.  Proyek terbesar memiliki lebih dari 200.000 DAU dan menambah celengan saya dengan tantangan orisinal baru.  Di sisi lain, relevansi dan perlunya temuan sebelumnya dikonfirmasi. <br><br>  Dalam kenyataan pahit kita, setiap orang yang setidaknya pernah merancang proyek besar setidaknya dalam pikiran mereka memiliki ide sendiri tentang bagaimana melakukannya, dan sering siap untuk mempertahankan ide-ide mereka hingga tetes darah terakhir.  Bagi yang lain, itu membuat saya tersenyum, dan manajemen sering melihat semua ini sebagai kotak hitam besar, yang tidak pernah ditentang oleh siapa pun.  Tetapi bagaimana jika saya memberi tahu Anda bahwa solusi yang tepat akan membantu mengurangi penciptaan fungsionalitas baru sebanyak 2-3 kali, mencari kesalahan pada 5-10 kali yang lama, dan akan memungkinkan Anda melakukan banyak hal baru dan penting yang sebelumnya tidak dapat diakses?  Cukup dengan membiarkan arsitektur masuk ke hati Anda! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi arsitektur untuk gim seluler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Perintah dan antriannya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi arsitektur untuk gim seluler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: Lihat di dorongan jet</a> <br><a name="habracut"></a><br><br><h2>  Model </h2><br><h3>  Akses ke bidang </h3><br>  Sebagian besar programmer menyadari pentingnya menggunakan sesuatu seperti MVC.  Hanya sedikit orang yang menggunakan MVC murni dari buku sekelompok empat, tetapi semua keputusan kantor normal entah bagaimana mirip dengan pola semangat ini.  Hari ini kita akan berbicara tentang huruf pertama dari singkatan ini.  Karena sebagian besar pekerjaan pemrogram dalam game mobile adalah fitur baru dalam meta-game, diimplementasikan sebagai manipulasi dengan model, dan mengacaukan ribuan antarmuka ke dalam fitur ini.  Dan kenyamanan model memainkan peran kunci dalam pelajaran ini. <br><br>  Saya tidak memberikan kode lengkap, karena ini sedikit dofig, dan secara umum ini bukan tentang dia.  Saya akan mengilustrasikan alasan saya dengan contoh sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> money; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InventoryModel inventory; <span class="hljs-comment"><span class="hljs-comment">/* Using */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeTestChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ money = <span class="hljs-number"><span class="hljs-number">10</span></span>; inventory.capacity++; } }</code> </pre> <br>  Opsi ini sama sekali tidak cocok untuk kita, karena model tidak mengirimkan peristiwa tentang perubahan yang terjadi di dalamnya.  Jika informasi tentang bidang mana yang dipengaruhi oleh perubahan, dan mana yang tidak, dan mana yang perlu digambar ulang, dan mana yang tidak, programmer akan menentukan secara manual dalam satu atau lain bentuk - ini akan menjadi sumber utama kesalahan dan waktu yang dihabiskan.  Dan tidak perlu membuat mata terkejut. Di sebagian besar kantor besar tempat saya bekerja, programmer mengirim semua jenis InventoryUpdatedEvent sendiri, dan dalam beberapa kasus juga mengisinya secara manual.  Beberapa dari kantor-kantor ini menghasilkan jutaan, menurut Anda, terima kasih atau meskipun demikian? <br><br>  Kami akan menggunakan kelas kami sendiri ReactiveProperty &lt;T&gt; yang akan menyembunyikan di bawah kap semua manipulasi untuk mengirim pesan yang kami butuhkan.  Akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; money = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReactiveProperty&lt;InventoryModel&gt; inventory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveProperty&lt;InventoryModel&gt;(); <span class="hljs-comment"><span class="hljs-comment">/* Using */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeTestChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ money.Value = <span class="hljs-number"><span class="hljs-number">10</span></span>; inventory.Value.capacity.Value++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Text text)</span></span></span><span class="hljs-function"> </span></span>{ money.SubscribeWithState(text, (x, t) =&gt; t.text = x.ToString()); } }</code> </pre> <br>  Ini adalah versi pertama dari model.  Opsi ini sudah menjadi impian bagi banyak programmer, tetapi saya masih tidak menyukainya.  Hal pertama yang saya tidak suka adalah mengakses nilai itu rumit.  Saya berhasil menjadi bingung ketika menulis contoh ini, melupakan Nilai di satu tempat, dan manipulasi data inilah yang merupakan bagian terbesar dari semua yang dilakukan dan bingung dengan model.  Jika Anda menggunakan versi bahasa 4.x, Anda dapat melakukan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; money { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;();</code> </pre> <br>  tapi ini tidak menyelesaikan semua masalah.  Saya ingin menulis secara sederhana: inventory.capacity ++;.  Misalkan kita mencoba mendapatkan untuk setiap bidang model;  mengatur;  Tetapi untuk berlangganan acara, kita juga perlu akses ke ReactiveProperty itu sendiri.  Ketidaknyamanan yang jelas dan sumber kebingungan.  Terlepas dari kenyataan bahwa kita hanya perlu menunjukkan bidang mana yang akan kita pantau.  Dan di sini saya datang dengan manuver rumit yang saya sukai. <br><br>  Mari kita lihat apakah Anda menyukainya. <br><br>  Bukan ReactiveProperty itu sendiri yang dimasukkan ke dalam model spesifik yang diprogram oleh programmer yang menulis aturan, tetapi deskriptor statis PValue-nya, pewaris Properti yang lebih umum, itu mengidentifikasi bidang, dan di dalam tudung konstruktor Model tersembunyi penciptaan dan penyimpanan ReactiveProperty dari tipe yang diinginkan.  Bukan nama terbaik, tapi itu terjadi, lalu diganti namanya. <br><br>  Dalam kode, tampilannya seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PValue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; MONEY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PValue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> money { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MONEY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { MONEY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value) } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PModel&lt;InventoryModel&gt; INVENTORY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PModel&lt;InventoryModel&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InventoryModel inventory { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVENTORY.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { INVENTORY.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value) } } <span class="hljs-comment"><span class="hljs-comment">/* Using */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeTestChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ money = <span class="hljs-number"><span class="hljs-number">10</span></span>; inventory.capacity++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Text text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Get(MONEY).SubscribeWithState(text, (x, t) =&gt; t.text = x.ToString()); } }</code> </pre> <br>  Ini adalah opsi kedua.  Nenek moyang umum Model, tentu saja, rumit dengan mengorbankan menciptakan dan mengekstraksi Properti Reaktif nyata menurut deskriptornya, tetapi ini dapat dilakukan dengan sangat cepat dan tanpa refleksi, atau lebih tepatnya, menerapkan refleksi hanya sekali pada tahap inisialisasi kelas.  Dan ini adalah pekerjaan yang dilakukan sekali oleh pencipta mesin, dan kemudian akan digunakan oleh semua orang.  Selain itu, desain ini menghindari upaya yang tidak disengaja untuk memanipulasi ReactiveProperty itu sendiri alih-alih nilai yang tersimpan di dalamnya.  Pembuatan lapangan berantakan, tetapi dalam semua kasus itu persis sama, dan dapat dibuat dengan templat. <br><br>  Di akhir artikel ada polling pilihan mana yang paling Anda sukai. <br>  Semua yang dijelaskan di bawah ini dapat diimplementasikan di kedua versi. <br><br><h3>  Transaksi </h3><br>  Saya ingin programmer dapat mengubah bidang model hanya ketika ini diizinkan oleh pembatasan yang diadopsi dalam mesin, yaitu di dalam tim, dan tidak pernah lagi.  Untuk melakukan ini, setter harus pergi ke suatu tempat dan memeriksa apakah perintah transaksi saat ini terbuka, dan hanya kemudian memungkinkan informasi yang akan diedit dalam model.  Ini sangat diperlukan, karena pengguna mesin secara teratur mencoba melakukan sesuatu yang aneh untuk mem-bypass proses tipikal, mematahkan logika mesin dan menyebabkan kesalahan yang halus.  Saya melihat ini lebih dari sekali atau dua kali. <br><br>  Ada kepercayaan bahwa jika Anda membuat antarmuka terpisah untuk membaca data dari model dan untuk menulis, itu akan membantu.  Pada kenyataannya, model ini ditumbuhi dengan file tambahan dan operasi tambahan yang membosankan.  Pembatasan ini bersifat final. Pemrogram dipaksa, pertama, untuk mengetahui dan terus-menerus memikirkannya: "apa yang harus diberikan oleh masing-masing fungsi spesifik, model atau antarmuka", dan kedua, situasi juga muncul ketika pembatasan ini harus dielakkan, sehingga di pintu keluar kami memiliki d'Artagnan, yang membuat semuanya serba putih, dan banyak pengguna mesinnya, yang merupakan penjaga buruk dari Manajer Proyek, dan meskipun terus-menerus disalahgunakan, tidak ada yang berfungsi sebagaimana mestinya.  Oleh karena itu, saya lebih suka hanya menutup secara ketat kemungkinan kesalahan seperti itu.  Kurangi dosis konvensi, jadi untuk berbicara. <br><br>  Setter ReactiveProperty harus memiliki tautan ke tempat di mana keadaan transaksi saat ini harus diperiksa.  Katakanlah tempat ini adalah classCModelRoot.  Opsi termudah adalah meneruskannya ke konstruktor model secara eksplisit.  Versi kedua kode ketika memanggil RProperty menerima tautan ke ini secara eksplisit, dan dapat memperoleh semua informasi yang diperlukan dari sana.  Untuk versi pertama kode, Anda harus menjalankan bidang tipe ReactiveProperty di konstruktor dengan refleksi dan memberi mereka tautan ke sini untuk manipulasi lebih lanjut.  Sedikit ketidaknyamanan adalah perlunya membuat konstruktor eksplisit dengan parameter di setiap model, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelRoot gamestate)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gamestate)</span></span></span><span class="hljs-function"> </span></span>{} }</code> </pre> <br>  Tetapi untuk fitur model lainnya, sangat berguna bahwa model memiliki tautan ke model induk, membentuk konstruk yang saling terhubung.  Dalam contoh kita, ini akan menjadi player.inventory.Parent == pemain.  Dan kemudian konstruktor ini dapat dihindari.  Model mana pun akan bisa mendapatkan dan menyimpan tautan ke tempat magis dari orang tuanya, dan yang itu dari orang tuanya, dan seterusnya sampai orang tua berikutnya ternyata menjadi tempat magis itu.  Akibatnya, pada tingkat deklarasi, semua ini akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelRoot</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> locked { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Model Parent { get; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ModelRoot Root { get; } }</code> </pre> <br>  Semua keindahan ini akan terisi secara otomatis ketika model memasuki pohon gamestate.  Ya, model yang baru dibuat, yang belum sampai di sana, tidak akan dapat belajar tentang transaksi dan memblokir manipulasi dengan sendirinya, tetapi jika keadaan transaksi dilarang, itu tidak akan bisa masuk ke negara setelah itu, pembuat orangtua tidak akan mengizinkannya, sehingga integritas gamestate tidak akan terpengaruh.  Ya, ini akan membutuhkan pekerjaan tambahan pada tahap pemrograman mesin, tetapi di sisi lain, seorang programmer yang menggunakan mesin akan sepenuhnya menghilangkan kebutuhan untuk mengetahui dan memikirkannya sampai dia mencoba untuk melakukan sesuatu yang salah dan mendapatkan tangannya. <br><br>  Karena percakapan tentang transaktivitas telah dimulai, pesan tentang perubahan tidak boleh diproses segera setelah perubahan dilakukan, tetapi hanya ketika semua manipulasi dengan model dalam perintah saat ini selesai.  Ada dua alasan untuk ini, yang pertama adalah konsistensi data. Tidak semua status data konsisten secara internal. Mungkin Anda tidak dapat mencoba membuatnya.  Atau jika Anda tidak sabar, misalnya, untuk mengurutkan array atau mengubah beberapa variabel model dalam satu lingkaran.  Anda seharusnya tidak menerima ratusan pesan perubahan. <br><br>  Ada dua cara untuk melakukan ini.  Yang pertama adalah berlangganan pembaruan ke variabel dan menggunakan fungsi rumit yang menambahkan aliran akhir transaksi ke aliran perubahan dalam variabel dan hanya setelah itu akan melewatkan pesan.  Ini cukup mudah dilakukan jika Anda menggunakan UniRX, misalnya.  Tetapi opsi ini memiliki banyak kekurangan, khususnya memunculkan banyak gerakan yang tidak perlu.  Secara pribadi, saya suka pilihan lain. <br><br>  Setiap ReactiveProperty akan mengingat statusnya sebelum dimulainya transaksi dan keadaan saat ini.  Pesan tentang perubahan dan perbaikan perubahan hanya akan dilakukan di akhir transaksi.  Dalam kasus ketika objek perubahan adalah semacam koleksi, ini akan memungkinkan secara eksplisit untuk memasukkan informasi tentang perubahan yang telah terjadi dalam pesan yang dikirim. Misalnya, dua item dalam daftar ditambahkan, dan dua item seperti itu dihapus.  Alih-alih hanya mengatakan bahwa sesuatu telah berubah, dan memaksa penerima untuk menganalisis daftar seribu elemen panjangnya dalam mencari informasi yang perlu digambar ulang. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DispatchChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Command transaction)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RevertChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Opsi ini lebih memakan waktu pada tahap pembuatan mesin, tetapi kemudian biaya penggunaan lebih rendah.  Dan yang paling penting, itu membuka kemungkinan untuk perbaikan selanjutnya. <br><br><h3>  Informasi tentang perubahan yang dilakukan pada model </h3><br>  Saya ingin lebih dari model.  Setiap saat saya ingin dengan mudah dan nyaman melihat apa yang telah berubah dalam keadaan model sebagai hasil dari tindakan saya.  Misalnya, dalam formulir ini: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"player"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"money"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inventory"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"capacity"</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>}}}</code> </pre> <br>  Paling sering, berguna bagi programmer untuk melihat perbedaan antara keadaan model sebelum dimulainya perintah dan setelah berakhirnya, atau pada beberapa titik di dalam perintah.  Beberapa untuk kloning ini seluruh gamestate sebelum dimulainya tim, dan kemudian membandingkan.  Ini sebagian menyelesaikan masalah pada tahap debugging, tetapi sama sekali tidak mungkin untuk menjalankan ini di produk.  Kloning negara, yang menghitung perbedaan tidak signifikan antara kedua daftar, adalah operasi yang sangat mahal untuk dilakukan dengan bersin apa pun. <br><br>  Oleh karena itu, ReactiveProperty harus menyimpan tidak hanya kondisi saat ini, tetapi juga yang sebelumnya.  Ini memunculkan seluruh kelompok peluang yang sangat berguna.  Pertama, ekstraksi perbedaan dalam situasi seperti itu cepat, dan kita bisa dengan tenang membuang semuanya ke dalam makanan.  Kedua, Anda tidak bisa mendapatkan perbedaan besar, tetapi sedikit hash dari perubahan, dan membandingkannya dengan hash perubahan di gamestate lain yang sama.  Jika tidak setuju, Anda memiliki masalah.  Ketiga, jika eksekusi perintah jatuh dengan eksekusi, Anda selalu dapat membatalkan perubahan dan mencari tahu tentang kondisi yang belum terjamah pada saat transaksi dimulai.  Bersama dengan tim yang diterapkan pada negara bagian, informasi ini sangat berharga karena Anda dapat dengan mudah mereproduksi situasi secara akurat.  Tentu saja, untuk ini Anda harus memiliki fungsionalitas siap pakai untuk serialisasi yang nyaman dan deserialisasi keadaan permainan, tetapi Anda tetap akan membutuhkannya. <br><br><h3>  Serialisasi perubahan model </h3><br>  Mesin menyediakan serialisasi dan biner, dan di json - dan ini bukan kecelakaan.  Tentu saja, serialisasi biner memakan banyak ruang lebih sedikit dan bekerja lebih cepat, yang penting, terutama selama boot awal.  Tapi ini bukan format yang bisa dibaca manusia, dan di sini kami berdoa untuk kemudahan debugging.  Selain itu, ada jebakan lain.  Saat gim Anda masuk ke prod, Anda harus terus beralih dari versi ke versi.  Jika programmer Anda mengikuti beberapa tindakan pencegahan sederhana dan tidak menghapus apa pun dari kondisi permainan secara tidak perlu, Anda tidak akan merasakan transisi ini.  Dan dalam format biner, tidak ada nama string bidang untuk alasan yang jelas, dan jika versi tidak cocok, Anda harus membaca biner dengan versi lama negara, mengekspornya ke sesuatu yang lebih informatif, misalnya, json yang sama, kemudian mengimpornya ke negara baru, mengekspornya ke biner, tulis, dan hanya setelah semua ini bekerja lebih lanjut seperti biasa.  Akibatnya, dalam beberapa proyek, konfigurasi ditulis ke biner mengingat ukurannya yang siklope, dan mereka sudah lebih suka menyeret negara bolak-balik dalam bentuk json.  Nilai overhead dan pilih Anda. <br><br><pre> <code class="cpp hljs">[Flags] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ExportMode { all = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, changes = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, serverVerified = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    ,    } /**    */ public partial class Model { public bool GetHashCode(ExportMode mode, out int code); public bool Import(BinaryReader binarySerialization); public bool Import(JSONReader json); public void ExportAll(ExportMode mode, BinaryWriter binarySerialization); public void ExportAll(ExportMode mode, JSONWriter json); public bool Export(ExportMode mode, out Dictionary&lt;string, object&gt; data); }</span></span></code> </pre> <br>  Tanda tangan dari metode Ekspor (mode ExportMode, keluar Kamus &lt;string, objek&gt; data) agak mengkhawatirkan.  Dan masalahnya adalah ini: Ketika Anda membuat serial seluruh pohon, Anda dapat segera menulis ke aliran, atau dalam kasus kami, untuk JSONWriter, yang merupakan add-on sederhana untuk StringWriter.  Tetapi ketika Anda mengekspor perubahan, itu tidak sesederhana itu, karena ketika Anda pergi jauh ke dalam pohon dan pergi ke salah satu cabang, Anda masih tidak tahu apakah akan mengekspor sesuatu dari itu sama sekali.  Oleh karena itu, pada tahap ini saya datang dengan dua solusi, satu lebih sederhana, yang kedua lebih rumit dan ekonomis.  Yang lebih sederhana adalah ketika mengekspor hanya perubahan, Anda mengubah semua perubahan menjadi pohon dari Kamus &lt;string, objek&gt; dan Daftar &lt;objek].  Dan kemudian apa yang terjadi, beri makan serializer favorit Anda.  Ini adalah pendekatan sederhana yang tidak memerlukan menari dengan rebana.  Tetapi kekurangannya adalah bahwa dalam proses mengekspor perubahan ke tumpukan, tempat untuk koleksi satu kali akan dialokasikan.  Faktanya, tidak ada banyak ruang, karena ekspor lengkap ini menghasilkan pohon besar, dan perintah tipikal menyisakan sedikit perubahan pada pohon. <br><br>  Namun, banyak orang percaya bahwa memberi makan Pengumpul Sampah sebagai troll itu tidak perlu tanpa kebutuhan ekstrim.  Bagi mereka, dan untuk menenangkan hati nurani saya, saya menyiapkan solusi yang lebih kompleks: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExportAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExportMode mode, Type propertyType, JSONWriter writer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newModel = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExportMode mode, Stack&lt;Model&gt; ierarchyChanged = null)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExportChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExportMode mode, Type propertyType, JSONWriter writer, Queue&lt;Model&gt; ierarchyChanges = null)</span></span></span></span>; }</code> </pre> <br>  Inti dari metode ini adalah berjalan melewati pohon dua kali.  Untuk pertama kalinya, lihat semua model yang telah mengubah diri mereka sendiri, atau ada perubahan dalam model anak, dan tulis semuanya dalam Antrian &lt;Model&gt; ierarchyChanges persis dalam urutan di mana mereka muncul di pohon dalam keadaan saat ini.  Tidak banyak perubahan, antrian tidak akan lama.  Selain itu, tidak ada yang mencegah untuk menjaga Stack &lt;Model&gt; dan Antrian &lt;Model&gt; antara panggilan dan kemudian akan ada alokasi yang sangat sedikit selama panggilan. <br><br>  Dan sudah melewati yang kedua kalinya melalui pohon, akan mungkin untuk melihat bagian atas dari antrian setiap kali, dan memahami apakah perlu untuk masuk ke cabang pohon ini atau segera melanjutkan.  Ini memungkinkan JSONWriter untuk segera menulis tanpa mengembalikan hasil perantara lainnya. <br><br>  Sangat mungkin bahwa komplikasi ini tidak benar-benar diperlukan, karena nanti Anda akan melihat bahwa mengekspor perubahan ke pohon yang Anda butuhkan hanya untuk debugging atau ketika menabrak Exception.  Selama operasi normal, semuanya terbatas pada GetHashCode (mode ExportMode, kode int keluar) yang semua kesenangan ini sangat asing. <br><br>  Sebelum kita terus menyulitkan model kita, mari kita bicarakan ini. <br><br><h2>  Mengapa ini sangat penting? </h2><br>  Semua programmer mengatakan ini sangat penting, tetapi biasanya tidak ada yang percaya.  Mengapa <br><br>  Pertama, karena semua programmer mengatakan bahwa Anda perlu membuang yang lama dan menulis yang baru.  Itu saja, terlepas dari kualifikasi.  Tidak ada cara manajerial untuk mengetahui apakah ini benar atau tidak, dan eksperimen biasanya terlalu mahal.  Manajer akan dipaksa untuk memilih satu programmer dan memercayai penilaiannya.  Masalahnya adalah penasihat seperti itu biasanya adalah orang yang sudah lama bekerja sama dengan manajemen dan mengevaluasinya dengan apakah ia mampu merealisasikan idenya, dan semua gagasan terbaiknya sudah diwujudkan dalam kenyataan.  Jadi ini juga bukan cara yang ideal untuk mengetahui seberapa baik ide orang lain dan berbeda. <br><br>  Kedua, 80% dari semua game mobile menghasilkan kurang dari $ 500 dalam seluruh hidup mereka.  Oleh karena itu, pada awal proyek, manajemen memiliki masalah lain, arsitektur yang lebih penting.  Tetapi keputusan yang dibuat pada awal proyek ini menyandera orang dan tidak melepaskan dari enam bulan menjadi tiga tahun.  Proses refactoring dan beralih ke ide-ide lain dalam proyek yang sudah berjalan, yang juga memiliki klien, adalah bisnis yang sangat sulit, mahal dan berisiko.  Jika untuk sebuah proyek di awal, menginvestasikan tiga bulan dalam arsitektur normal sepertinya merupakan kemewahan yang tidak dapat diterima, lalu apa yang dapat Anda katakan tentang biaya menunda pembaruan dengan fitur baru selama beberapa bulan? <br><br>  Ketiga, meskipun gagasan â€œbagaimana seharusnyaâ€ itu sendiri baik dan ideal, tidak diketahui berapa lama implementasinya.  Ketergantungan waktu yang dihabiskan pada kesejukan programmer sangat tidak linier.  Seigneur akan membuat tugas sederhana tidak jauh lebih cepat daripada junior.  Satu setengah kali, mungkin.  Tetapi setiap programmer memiliki "batas kompleksitas" sendiri, di luar itu efektivitasnya turun secara dramatis.  Saya punya kasus dalam hidup saya ketika saya perlu mewujudkan tugas arsitektur yang agak rumit, dan bahkan sepenuhnya berkonsentrasi pada masalah dengan mematikan Internet di rumah dan memesan makanan siap saji selama sebulan tidak membantu.Tetapi dua tahun kemudian, setelah membaca buku-buku menarik dan menyelesaikan tugas-tugas terkait , Saya memecahkan masalah ini dalam tiga hari.  Saya yakin semua orang akan mengingat hal seperti itu dalam karier mereka.  Dan inilah tangkapannya!  Faktanya adalah bahwa jika ide cerdik datang ke pikiran Anda sebagaimana mestinya, maka kemungkinan besar ide baru ini ada di suatu tempat di batas kompleksitas pribadi Anda, dan mungkin bahkan sedikit di belakangnya.  Manajemen, setelah berulang kali membakarnya, mulai meniup ide baru.  Dan jika kamu membuat game untuk dirimu sendiri, hasilnya bisa lebih buruk, karena tidak akan ada yang menghentikanmu. <br><br>  Tetapi bagaimana, kemudian, apakah ada yang berhasil menggunakan solusi yang baik?  Ada beberapa cara. <br><br>  Pertama, setiap perusahaan ingin merekrut orang yang sudah jadi yang sudah melakukan ini dengan majikan sebelumnya.  Ini adalah cara paling umum untuk mengalihkan beban eksperimen ke orang lain. <br><br>  Kedua, perusahaan atau orang-orang yang membuat permainan sukses pertama mereka, menyeruput, dan memulai proyek berikutnya siap untuk perubahan. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketiga, jujur â€‹â€‹mengakui pada diri sendiri bahwa kadang-kadang Anda melakukan sesuatu bukan karena gaji, tetapi untuk kesenangan proses. Yang utama adalah mencari waktu untuk ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keempat, itu adalah serangkaian solusi dan perpustakaan yang terbukti, bersama dengan orang-orang, yang menjadi dana utama perusahaan game, dan ini adalah satu-satunya hal yang akan tetap ada di dalamnya ketika beberapa orang kunci berhenti dan pindah ke Australia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang terakhir, meskipun bukan alasan yang paling jelas: karena itu sangat bermanfaat. </font><font style="vertical-align: inherit;">Solusi yang baik menyebabkan pengurangan beberapa waktu untuk menulis fitur baru, men-debug mereka dan menangkap kesalahan. </font><font style="vertical-align: inherit;">Izinkan saya memberi Anda sebuah contoh: dua hari yang lalu, klien memiliki eksekusi dalam fitur baru, probabilitasnya adalah 1 dari 1000, yaitu, QA akan menyiksa untuk memperbanyaknya, dan jika Anda memberikannya, itu adalah 200 pesan kesalahan per hari. </font><font style="vertical-align: inherit;">Berapa lama waktu yang Anda perlukan untuk mereproduksi situasi dan menangkap klien pada breakpoint satu baris sebelum semuanya runtuh? </font><font style="vertical-align: inherit;">Sebagai contoh, saya punya 10 menit.</font></font><br><br><h2>  Model </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pohon Model </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelnya terdiri dari banyak objek. Pemrogram yang berbeda memutuskan secara berbeda bagaimana menghubungkan mereka bersama. Cara pertama adalah ketika model diidentifikasi oleh tempat di mana ia berada. Ini sangat mudah dan sederhana ketika referensi ke model milik satu tempat di ModelRoot. Mungkin bahkan dapat digeser dari satu tempat ke tempat lain, tetapi dua tautan dari tempat yang berbeda tidak pernah mengarah ke sana. Kami akan melakukan ini dengan memperkenalkan versi baru dari deskriptor ModelProperty yang akan menangani tautan dari satu model ke model lain yang berada di dalamnya. Dalam kode tersebut, akan terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PModel</span></span></span><span class="hljs-class">&lt;T&gt; :</span></span> Property&lt;T&gt; where T:Model {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerModel</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PModel&lt;InventoryModel&gt; INVENTORY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PModel&lt;InventoryModel&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InventoryModel inventory { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVENTORY.Value(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { INVENTORY.Value(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa bedanya? </font><font style="vertical-align: inherit;">Ketika model baru ditambahkan ke bidang ini, model yang ditambahkannya ditulis dalam bidang Induknya, dan ketika dihapus, bidang Induk direset. </font><font style="vertical-align: inherit;">Secara teori, semuanya baik-baik saja, tetapi ada banyak jebakan. </font><font style="vertical-align: inherit;">Yang pertama - programmer yang akan menggunakannya, bisa salah. </font><font style="vertical-align: inherit;">Untuk menghindari hal ini, kami memaksakan pemeriksaan tersembunyi pada proses ini, dari sudut yang berbeda:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memperbaiki PValue sehingga memeriksa jenis nilainya, dan bersumpah oleh para ahli ketika mencoba untuk menyimpan referensi ke model di dalamnya, menunjukkan bahwa untuk ini perlu menggunakan konstruksi yang berbeda, hanya agar tidak bingung. </font><font style="vertical-align: inherit;">Ini, tentu saja, adalah pemeriksaan runtime, tetapi bersumpah pada upaya pertama untuk memulai, jadi itu akan dilakukan.</font></font></li><li>   PModel       Parent  -  ,       .     .        ,  . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efek samping muncul dari ini, jika Anda perlu menggeser model seperti itu dari satu tempat ke tempat lain, Anda harus terlebih dahulu menghapusnya dari tempat pertama, dan baru kemudian menambahkannya ke tempat kedua - jika tidak maka cek akan memarahi Anda. Tetapi ini sebenarnya jarang terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena model terletak di satu tempat yang didefinisikan secara ketat dan memiliki referensi ke induknya, kami dapat menambahkan metode baru - ia dapat mengetahui ke arah mana ia berada di pohon ModelRoot. Ini sangat nyaman untuk debugging, tetapi juga diperlukan agar dapat diidentifikasi secara unik. Misalnya, cari model lain yang sama persis di gamestate lain yang sama, atau tunjukkan dalam perintah yang dikirimkan ke server tautan yang berisi model yang berisi perintah itu. Itu terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelPath</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Property[] properties; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] indexes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ModelPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ModelPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelRoot</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Model </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetByPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModelPath path)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan mengapa, pada kenyataannya, tidak mungkin memiliki objek berakar di satu tempat, dan untuk merujuknya dari yang lain? Dan karena Anda membayangkan bahwa Anda deserializing objek dari JSON, dan di sini Anda akan menemukan tautan ke objek yang berakar di tempat yang sama sekali berbeda. Dan masih belum ada tempat untuk itu, itu hanya akan dibuat melalui lantai deserialisasi. Ups Tolong jangan menawarkan deserialization multi-pass. Ini adalah batasan dari metode ini. Oleh karena itu, kami akan membuat metode kedua:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua model yang dibuat dengan metode kedua dibuat di satu tempat ajaib, dan di semua tempat lain hanya tautan gamestate yang dimasukkan. Selama deserialisasi, jika ada beberapa referensi ke objek, saat pertama kali Anda mengakses tempat ajaib, objek dibuat, dan dengan semua referensi berikutnya ke objek yang sama dikembalikan. Untuk mengimplementasikan fitur-fitur lain, kami berasumsi bahwa permainan dapat memiliki beberapa gamestate, jadi tempat ajaib seharusnya tidak menjadi satu yang umum, tetapi harus ditempatkan, misalnya, dalam gamestate. Untuk referensi ke model tersebut, kami menggunakan variasi lain dari deskriptor PPersistent. Model itu sendiri akan dibuat lebih spesial oleh Persistent: Model. Dalam kode, akan terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Persistent</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ID.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { ID.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ID = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelRoot</span></span></span><span class="hljs-class"> :</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextFreePersistentId { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NEXT_FREE_PERSISTENT_ID.Get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { NEXT_FREE_PERSISTENT_ID.Set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; NEXT_FREE_PERSISTENT_ID = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RProperty&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PDictionaryModel&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Persistent&gt; PERSISTENT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDictionaryModel&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Persistent&gt;() { notServerVerified = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt;      Id-. &lt;/summary&gt; public PersistentT Persistent&lt;PersistentT&gt;(int localId) where PersistentT : Persistent, new(); /// &lt;summary&gt; C    Id. &lt;/summary&gt; public PersistentT Persistent&lt;PersistentT&gt;() where PersistentT : Persistent, new(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit rumit, tetapi bisa digunakan. </font><font style="vertical-align: inherit;">Untuk meletakkan sedotan, Persistent dapat mengencangkan konstruktor dengan parameter ModelRoot, yang akan membangkitkan alarm jika mereka mencoba membuat model ini bukan melalui metode ModelRoot ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memiliki kedua opsi dalam kode saya, dan pertanyaannya adalah, mengapa kemudian menggunakan opsi pertama jika yang kedua sepenuhnya mencakup semua kasus yang mungkin? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jawabannya adalah bahwa keadaan permainan harus, pertama-tama, dapat dibaca oleh orang-orang. </font><font style="vertical-align: inherit;">Bagaimana kelihatannya jika, jika memungkinkan, opsi pertama digunakan?</font></font><br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"persistents"</span></span>:{}, <span class="hljs-attr"><span class="hljs-attr">"player"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"money"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inventory"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"capacity"</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>} } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang, bagaimana jadinya jika hanya opsi kedua yang digunakan: </font></font><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"persistents"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"1"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"money"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"inventory"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"capacity"</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>} }, <span class="hljs-attr"><span class="hljs-attr">"player"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk debug pribadi, saya lebih suka opsi pertama. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses Model Properties </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akses ke fasilitas penyimpanan reaktif untuk properti pada akhirnya ternyata disembunyikan di bawah kap model. Tidak terlalu jelas bagaimana membuatnya bekerja begitu cepat, tanpa terlalu banyak kode pada model akhir dan tanpa terlalu banyak refleksi. Mari kita lihat lebih dekat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal pertama yang berguna untuk diketahui tentang Kamus adalah membaca dari situ tidak membutuhkan banyak waktu yang konstan, terlepas dari ukuran kamus. Kami akan membuat kamus statis pribadi di Model di mana setiap jenis model diberikan deskripsi bidang mana yang ada di dalamnya dan kami akan mengaksesnya satu kali saat membuat model. Dalam konstruktor tipe, kita melihat apakah ada deskripsi untuk tipe kita. Jika tidak, kita buat, jika demikian, kita ambil yang selesai. Dengan demikian, deskripsi hanya akan dibuat sekali untuk setiap kelas. Saat membuat deskripsi, kami memasukkan setiap Properti statis (deskripsi bidang) data yang diekstraksi melalui refleksi - nama bidang, dan indeks tempat penyimpanan data untuk bidang ini dalam array. Dengan cara iniketika diakses melalui deskripsi lapangan, penyimpanannya akan dikeluarkan dari array pada indeks yang sebelumnya dikenal, yaitu, dengan cepat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam kode tersebut, akan terlihat seperti ini: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> :</span></span> IModelInternals { <span class="hljs-meta"><span class="hljs-meta">#region Properties protected static Dictionary</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Type, Property[]&gt; propertiesDictionary = new Dictionary&lt;Type, Property[]&gt;(); protected static Dictionary&lt;Type, Property[]&gt; propertiesForBinarySerializationDictionary = new Dictionary&lt;Type, Property[]&gt;(); protected Property[] _properties, _propertiesForBinarySerialization; protected BaseStorage[] _storages; public Model() { Type targetType = GetType(); if (!propertiesDictionary.ContainsKey(targetType)) RegisterModelsProperties(targetType, new List&lt;Property&gt;(), new List&lt;Property&gt;()); _properties = propertiesDictionary[targetType]; _storages = new BaseStorage[_properties.Length]; for (var i = 0; i &lt; _storages.Length; i++) _storages[i] = _properties[i].CreateStorage(); } private void RegisterModelsProperties(Type target, List&lt;Property&gt; registered, List&lt;Property&gt; registeredForBinary) { if (!propertiesDictionary.ContainsKey(target)) { if (target.BaseType != typeof(Model) &amp;&amp; typeof(Model).IsAssignableFrom(target.BaseType)) RegisterModelsProperties(target.BaseType, registered, registeredForBinary); var fields = target.GetFields(BindingFlags.Public | BindingFlags.Static); // | BindingFlags.DeclaredOnly List&lt;Property&gt; alphabeticSorted = new List&lt;Property&gt;(); for (int i = 0; i &lt; fields.Length; i++) { var field = fields[i]; if (typeof(Property).IsAssignableFrom(field.FieldType)) { var prop = field.GetValue(this) as Property; prop.Name = field.Name; prop.Parent = target; prop.storageIndex = registered.Count; registered.Add(prop); alphabeticSorted.Add(prop); } } alphabeticSorted.Sort((p1, p2) =&gt; String.Compare(p1.Name, p2.Name)); registeredForBinary.AddRange(alphabeticSorted); Property[] properties = new Property[registered.Count]; for (int i = 0; i &lt; registered.Count; i++) properties[i] = registered[i]; propertiesDictionary.Add(target, properties); properties = new Property[registered.Count]; for (int i = 0; i &lt; registeredForBinary.Count; i++) properties[i] = registeredForBinary[i]; propertiesForBinarySerializationDictionary.Add(target, properties); } else { registered.AddRange(propertiesDictionary[target]); registeredForBinary.AddRange(propertiesForBinarySerializationDictionary[target]); } } CastType IModelInternals.GetStorage&lt;CastType&gt;(Property property) { try { return (CastType)_storages[property.storageIndex]; } catch { UnityEngine.Debug.LogError(string.Format("{0}.GetStorage&lt;{1}&gt;({2})",GetType().Name, typeof(CastType).Name, property.ToString())); return null; } } #endregion }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desainnya sedikit sederhana, karena deskriptor properti statis yang dideklarasikan pada leluhur model ini mungkin sudah memiliki indeks penyimpanan terdaftar, dan urutan pengembalian properti dari Type.GetFields () tidak dijamin. Untuk pesanan dan agar properti tidak diinisialisasi ulang dalam dua kali, Anda perlu memonitor diri sendiri. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Properti Pengumpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian pohon model, orang bisa melihat konstruksi yang tidak disebutkan sebelumnya: PDictionaryModel &lt;int, Persistent&gt; - deskriptor untuk bidang yang berisi koleksi. Jelas bahwa kita harus membuat repositori kita sendiri untuk koleksi, yang menyimpan informasi tentang bagaimana koleksi terlihat sebelum awal transaksi dan seperti apa sekarang. Kerikil bawah laut di sini adalah ukuran Batu Guntur di bawah Peter I. Terdiri dari fakta bahwa, dengan memiliki dua kamus panjang, adalah tugas yang sangat mahal untuk menghitung perbedaan di antara mereka. Saya berasumsi bahwa model seperti itu harus digunakan untuk semua tugas yang berhubungan dengan meta, yang berarti mereka harus bekerja dengan cepat. Alih-alih menyimpan dua status, mengkloningnya, dan kemudian membandingkannya dengan mahal, saya membuat kait yang rumit - hanya kondisi kamus saat ini yang disimpan di toko. Dua kamus lainnya adalah nilai yang dihapus,dan nilai-nilai lama dari elemen yang diganti. Akhirnya, Set kunci baru yang ditambahkan ke kamus disimpan. Informasi ini mudah dan cepat diisi. Sangat mudah untuk menghasilkan semua perbedaan yang diperlukan dengannya, dan cukup untuk memulihkan keadaan sebelumnya jika perlu. Dalam kode, tampilannya seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DictionaryStorage</span></span></span><span class="hljs-class">&lt;TKey, TValues&gt; :</span></span> BaseStorage { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;TKey, TValues&gt; current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;TKey, TValues&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;TKey, TValues&gt; removed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;TKey, TValues&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;TKey, TValues&gt; changedValues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;TKey, TValues&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HashSet&lt;TKey&gt; newKeys = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;TKey&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak berhasil membuat repositori indah yang sama untuk Daftar, atau saya tidak punya cukup waktu, saya menyimpan dua salinan. Pengaya tambahan diperlukan untuk mencoba meminimalkan ukuran diff.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListStorage</span></span></span><span class="hljs-class">&lt;TValue&gt; :</span></span> BaseStorage { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;TValue&gt; current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TValue&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;TValue&gt; previouse = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TValue&gt;(); <span class="hljs-comment"><span class="hljs-comment">//        public List&lt;int&gt; order = new List&lt;int&gt;(); //       . }</span></span></code> </pre> <br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda benar-benar tahu apa yang ingin Anda terima dan caranya, Anda dapat menulis semua ini dalam beberapa minggu. Kecepatan pengembangan gim pada saat yang sama berubah begitu dramatis sehingga ketika saya mencobanya, saya bahkan tidak memulai gim pembuat gim sendiri tanpa mesin yang bagus. Hanya karena pada bulan pertama investasi untuk saya jelas terbayar. Tentu saja, ini hanya berlaku untuk meta. Gameplay harus dilakukan dengan cara lama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian selanjutnya dari artikel ini, saya akan berbicara tentang perintah, jaringan, dan memprediksi respons server. Dan saya juga memiliki beberapa pertanyaan untuk Anda yang sangat penting bagi saya. Jika jawaban Anda berbeda dari yang diberikan dalam tanda kurung, saya akan dengan senang hati membacanya di komentar atau mungkin Anda bahkan menulis artikel. Terima kasih sebelumnya atas jawabannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Proposal untuk kerja sama dan instruksi tentang berbagai kesalahan sintaksis, silakan di PM. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434582/">https://habr.com/ru/post/id434582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434570/index.html">Simulator online minimalis sirkuit DC dan AC linier</a></li>
<li><a href="../id434574/index.html">Animasi CSS Link Garis Bawah Murni</a></li>
<li><a href="../id434576/index.html">Bekerja dengan API KOMPAS-3D â†’ Pelajaran 14 â†’ Teks Multiline</a></li>
<li><a href="../id434578/index.html">Digital Hygiene: Aturan main</a></li>
<li><a href="../id434580/index.html">Statistik Pemanggang 2018</a></li>
<li><a href="../id434584/index.html">Datanya lucu (dan berikut ini beberapa contoh)</a></li>
<li><a href="../id434586/index.html">Pesawat Pribadi. Pahami dan tunggu</a></li>
<li><a href="../id434588/index.html">Menyimpulkan tahun 2018 di My Circle</a></li>
<li><a href="../id434590/index.html">$ ls -l / home / avitotech / new_year</a></li>
<li><a href="../id434592/index.html">Elon Musk berjanji untuk meliput Eropa dengan jaringan Tesla Supercharger tahun depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>