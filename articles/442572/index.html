<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüöí üë®üèø‚Äçü§ù‚Äçüë®üèæ üî• Usar la herramienta de configuraci√≥n de Datapath üë©üèΩ‚Äçüåæ üîÅ üë≤üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tenemos que dar el pen√∫ltimo paso en el desarrollo pr√°ctico de trabajar con UDB. Hoy no desarrollaremos usando el editor UDB automatizado, sino en mod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usar la herramienta de configuraci√≥n de Datapath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442572/"><img src="https://habrastorage.org/webt/fu/yo/23/fuyo230rbfhla_li8ryzzngttlw.jpeg"><br><br>  Tenemos que dar el pen√∫ltimo paso en el desarrollo pr√°ctico de trabajar con UDB.  Hoy no desarrollaremos usando el editor UDB automatizado, sino en modo semi-manual usando la herramienta de configuraci√≥n de Datapath.  Una muy buena ayuda para dominar esta herramienta es AN82156 - PSoC 3, PSoC 4 y PSoC 5LP - Dise√±o de componentes de PSoC Creator con UDB Datapaths.  En realidad, lo estudi√© yo mismo. <br><a name="habracut"></a><br>  Quiz√°s, mientras le√≠a nuestras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducciones de documentaci√≥n sobre UDB</a> , alguien intent√≥ reproducir el conocimiento desde all√≠ en la pr√°ctica y not√≥ que no toda la funcionalidad descrita en las publicaciones est√° disponible en el Editor de UDB.  Esto se debe al hecho de que los desarrolladores no comenzaron a colocar algunos mecanismos particularmente engorrosos en el Editor UDB.  Los autores de AN82156 argumentan que a trav√©s del Editor UDB no puede hacer lo siguiente: <br><br><ul><li>  organizar la entrada y salida de datos paralelos; </li><li>  organizar la gesti√≥n din√°mica de FIFO; </li><li>  implementar el inverso de la se√±al de reloj FIFO; </li><li>  implementar la funci√≥n CRC; </li><li>  implementar la funci√≥n PRS; </li><li>  implementar la elecci√≥n de la transferencia entrante; </li><li>  Implementar la migraci√≥n entrante din√°mica. </li></ul><br>  Por mi parte, agregar√© que no encontr√© c√≥mo implementar la permutaci√≥n de nibbles en el Editor UDB. <br><br>  Si se necesitan estas funciones en el proyecto, deber√° crear su propio c√≥digo Verilog.  Us√© espec√≠ficamente la palabra "crear" en lugar de "escribir".  Conocer este lenguaje de programaci√≥n es suficiente a nivel de lectura.  Quiero decir, debes entender qu√© dise√±o se necesita para qu√©.  Y poder escribir desde cero siempre es √∫til, pero esta habilidad no es necesaria para lo que se presenta en este art√≠culo. <br><br>  Como problema solucionable, eleg√≠ un estuche semisint√©tico.  En general, decid√≠ enviar algunos datos al puerto paralelo y, en particular, de lo que est√° a la mano, el LCD de texto tiene un puerto paralelo.  Lo saqu√© de la impresora 3D MZ3D hace tres a√±os cuando trasplant√© esta √∫ltima a STM32.  Por lo tanto, el caso es semisint√©tico: hoy en d√≠a, tales indicadores generalmente tienen una entrada I2C y no necesitan conectarse a trav√©s de una pila de cables en la vida real.  Sin embargo, los LCD modernos tambi√©n tienen puertos paralelos, por lo que todos pueden usarlos para repetir el experimento. <br><br>  Considere el esquema de cambio de pantalla tomado de reprap.org (esto no fue f√°cil, mi proveedor bloquea este sitio, as√≠ como tambi√©n otros t√©cnicos, motiv√°ndolo con el hecho de que vive en la misma IP que alguien bloqueado). <br><br><img src="https://habrastorage.org/webt/0x/th/ry/0xthryzxadx_9guzmhdyhrxnzty.png"><br><br>  Gran dise√±o!  En primer lugar, no tengo que pensar en leer: los datos en la pantalla LCD solo se pueden escribir (la l√≠nea R / W est√° conectada a tierra y no est√° disponible en el conector).  En segundo lugar, los datos vienen en un formato de 4 bits, lo que significa que no solo podemos calcular la salida paralela, sino tambi√©n verificar el funcionamiento de la funci√≥n de permutaci√≥n de mordisco. <br><br><h2>  Creaci√≥n de proyectos </h2><br>  Entonces, inicie PSoC Creator y seleccione <b>Archivo-&gt; Nuevo-&gt; Proyecto</b> : <br><br><img src="https://habrastorage.org/webt/pv/ma/tv/pvmatvfviveyo4fa822osy45p2c.png"><br><br>  A continuaci√≥n, elijo mi placa de pruebas: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  El siguiente es el diagrama vac√≠o: <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  Llamar√© al proyecto <b>LCDTest2</b> : <br><br><img src="https://habrastorage.org/webt/qs/3f/rl/qs3frlgxrnzqzqrzzfryptvjfqq.png"><br><br>  Ahora, como antes, vaya a la pesta√±a <b>Componentes</b> : <br><br><img src="https://habrastorage.org/webt/wq/nb/bo/wqnbboubijieyovk7akrat6piik.png"><br><br>  Y, una vez seleccionado el proyecto, presione el bot√≥n derecho del mouse y luego seleccione <b>Agregar elemento componente</b> . <br><br><img src="https://habrastorage.org/webt/hi/fu/hv/hifuhvearnltnfz2dvmhwtzgw4o.png"><br><br>  Y aqu√≠ tienes que elegir el <b>Asistente de s√≠mbolos</b> .  Dale un nombre ... Bueno, digamos <b>LCD4bit</b> . <br><br><img src="https://habrastorage.org/webt/59/f0/g3/59f0g3lya8ado4kcxgj6lcsxggk.png"><br><br>  Asign√© los siguientes puertos al s√≠mbolo: <br><br><img src="https://habrastorage.org/webt/6a/jr/uo/6ajruo1io2jusjunhameiumtb20.png"><br><br>  <b>clk</b> es la entrada del reloj.  Los puertos con un prefijo LCD son puertos LCD est√°ndar.  <b>hambre</b> : salidas que le dicen a la unidad DMA que hay espacio libre en FIFO, la idea se discuti√≥ en un art√≠culo sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control de LED RGB</a> .  Haga clic en Aceptar para obtener el personaje. <br><br><img src="https://habrastorage.org/webt/ze/fq/5z/zefq5z65eq0i4mq21y2d3jip7t4.png"><br><br>  Ahora, basado en este s√≠mbolo, se debe generar una plantilla Verilog.  Haga clic con el bot√≥n derecho del mouse cerca del s√≠mbolo y seleccione <b>Generar Verilog</b> en el men√∫ contextual. <br><br><img src="https://habrastorage.org/webt/h9/k7/oo/h9k7oogp_wqsdfugdg-8bdr_hru.png"><br><br>  Obtuvimos la plantilla que se muestra en la figura a continuaci√≥n (en forma de texto todav√≠a no tiene sentido): <br><br><img src="https://habrastorage.org/webt/ax/t9/k-/axt9k-s-zfi2kfd7qdz9pe-zlqq.png"><br><br>  Hemos creado un m√≥dulo y algunas secciones.  Pero todav√≠a no han creado Datapath.  Para agregarlo, vaya al √°rbol del proyecto, seleccione el archivo <b>LCD4bit.v</b> , presione el bot√≥n derecho del mouse y seleccione la <b>herramienta de configuraci√≥n de Datapath</b> en el men√∫ contextual que aparece: <br><br><img src="https://habrastorage.org/webt/z2/1g/5w/z21g5wom4_-yq_nmcjlhvb3irg0.png"><br><br>  Se abre una ventana ante nosotros, que por ahora solo mostrar√© parcialmente: <br><br><img src="https://habrastorage.org/webt/m0/fz/9i/m0fz9idl6xt5rimcittxpme2iea.png"><br><br>  Por favor, amor y favor, editor de Datapath.  Contiene todos los bits que se describieron en la traducci√≥n de la documentaci√≥n patentada.  Pero hay tantos de estos bits que en los primeros d√≠as lo mir√©, pero ten√≠a miedo de hacer algo.  Mira, mira y sal.  Y solo despu√©s de un tiempo, acostumbr√°ndose, comenz√≥ a intentar hacer algo.  En realidad, es por eso que traje solo una parte de la ventana.  ¬øPor qu√© asustar a todos por adelantado?  Mientras tanto, solo necesitamos crear un Datapath, por lo que seleccionamos el elemento de men√∫ <b>Editar-&gt; Nuevo Datapath</b> : <br><br><img src="https://habrastorage.org/webt/-n/dx/vj/-ndxvjk_wrpdjucuq0_c3jcqfai.png"><br><br>  ¬øQu√© opci√≥n elegir en el cuadro de di√°logo que aparece? <br><br><img src="https://habrastorage.org/webt/wf/ma/kf/wfmakfepho5l4h4nxffpua7wgok.png"><br><br>  La pregunta es un poco m√°s seria de lo que parece.  Perm√≠tanme incluso resaltar el siguiente p√°rrafo para que nadie quede atrapado (me sorprend√≠ a m√≠ mismo, y luego vi preguntas en la red de las que obtuve, y nadie realmente las respondi√≥, y la respuesta est√° en <b>AN82156</b> , solo necesita leerlo en diagonal, como dice all√≠ frase corta y discreta). <br><blockquote>  Si planea trabajar con datos paralelos, definitivamente debe elegir la opci√≥n CY_PSOC3_DP.  Ninguna otra opci√≥n contendr√° puertos para conectar datos paralelos. </blockquote>  Entonces  Deje que la instancia se llame LCD_DP: <br><br><img src="https://habrastorage.org/webt/tf/a3/hs/tfa3hsi-mu2ljvyeukwmprwlm_4.png"><br><br>  Haga clic en Aceptar y cierre la <b>herramienta de configuraci√≥n de Datapath por ahora</b> , aceptando guardar el resultado.  Volveremos aqu√≠ m√°s tarde. <br><br>  Nuestro c√≥digo Verilog se ha expandido.  Ahora tiene Datapath.  Su comienzo es completamente ilegible.  No da miedo, est√° configurado por la <b>herramienta de configuraci√≥n de Datapath</b> . <br><br><img src="https://habrastorage.org/webt/tz/d9/ur/tzd9urfa66hsfic2w9gsn6tkysu.png"><br><br>  Y gobernaremos el final de la descripci√≥n de Datapath.  Nuestro sitio se ve as√≠ <div class="spoiler">  <b class="spoiler_title">(desde este punto tiene sentido traer todo en forma de texto).</b> <div class="spoiler_text"><pre><code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(), /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre> <br></div></div><br>  Miedo  Ahora descubriremos qu√© es qu√©, dejar√° de dar miedo.  De hecho, hay tres grupos distintos en este texto.  Recordemos la traducci√≥n de la documentaci√≥n.  ¬øC√≥mo se ve√≠a la ruta de datos en la imagen?  Notar√© de inmediato en la figura los lugares a los que pertenecen los grupos "1", "2" y "3". <br><br><img src="https://habrastorage.org/webt/ji/xe/5x/jixe5x_fxqpx6kgybrjmakagpw4.png"><br><br>  En realidad, el primer grupo de puertos en el c√≥digo verilog son las entradas.  Compare los nombres en la salida del multiplexor de entrada ("1" en la figura) y los nombres de las se√±ales en el c√≥digo. <br><br>  Ahora todas las entradas son cero.  Tendremos que conectar la entrada del reloj y podemos reenviar hasta seis l√≠neas de entrada, como se hizo en el Editor UDB.  Estas entradas son: <br><br><pre> <code class="plaintext hljs"> /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0),</code> </pre><br>  El segundo grupo son las salidas.  Los nombres en el c√≥digo tambi√©n coinciden con los nombres de las entradas del multiplexor de salida "2": <br><br><pre> <code class="plaintext hljs"> /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(),</code> </pre><br>  Solo la especie Datapath dada tiene el tercer grupo (los otros no tienen ninguno, por lo tanto, no hay datos paralelos).  Estas son se√±ales internas de Datapath a trav√©s de las cuales puede encadenar independientemente o realizar otras acciones √∫tiles.  Los nombres en el c√≥digo tambi√©n coinciden con los nombres de las se√±ales internas dispersas en la figura.  A trav√©s de uno de ellos (el √∫ltimo en la lista, su nombre es <b>po</b> ) enviaremos datos paralelos directamente a las patas del chip. <br><br><pre> <code class="plaintext hljs"> /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre><br>  Entonces  A medida que trabajemos, tendremos que conectar algunas de estas entradas y salidas a nuestras propias entidades, y el resto, simplemente dejarlas en la forma en que las creamos. <br><br><h2>  Usando el editor UDB como referencia </h2><br>  Y ahora tenemos un espacio en blanco, sabemos d√≥nde y qu√© tenemos que escribir.  Queda por entender exactamente en qu√© entraremos all√≠.  Dio la casualidad de que uso el idioma Verilog no todos los d√≠as, por lo que, en t√©rminos generales, recuerdo todo, y escribir desde cero para m√≠ siempre es una situaci√≥n estresante.  Cuando el proyecto ya est√° en marcha, todo se recuerda, pero si despu√©s de un par de meses de inactividad empiezo algo desde cero, por supuesto, ya no recuerdo los detalles de sintaxis de este lenguaje en particular.  Por lo tanto, sugiero pedir al entorno de desarrollo que nos ayude. <br><br>  UDB Editor para autocontrol construye el c√≥digo Verilog.  Aprovechamos el hecho de que los componentes que no est√°n involucrados en el circuito principal no est√°n compilados, por lo que podemos crear un componente auxiliar en el editor UDB, y no entrar√° en el c√≥digo de salida.  Dibujaremos un aut√≥mata all√≠, haremos un ajuste aproximado de las entradas y salidas de Datapath, y luego simplemente transferiremos el texto generado autom√°ticamente a nuestro m√≥dulo verilog y modificaremos todo creativamente.  Esto es mucho m√°s simple que recordar los detalles de la sintaxis de Verilog y escribir todo desde cero (aunque quien use Verilog constantemente, por supuesto, ser√° m√°s f√°cil escribir desde cero: la finalizaci√≥n creativa, como veremos pronto, es simple, pero requiere tiempo) <br><br>  Entonces, comenzamos a hacer un componente auxiliar.  Con el movimiento habitual de la mano agregamos un nuevo elemento al proyecto: <br><br><img src="https://habrastorage.org/webt/to/d2/fg/tod2fgx1opcdho2edizges-vr3q.png"><br><br>  Este ser√° un documento UDB, llam√©moslo <b>UDBhelper</b> : <br><br><img src="https://habrastorage.org/webt/j3/wt/iu/j3wtiuj2htdr-ct4f7m_3z497oi.png"><br><br>  Es hora de pensar en la m√°quina, que colocaremos en la hoja creada.  Para hacer esto, debemos considerar qu√© diagrama de tiempo debemos formar con √©l: <br><br><img src="https://habrastorage.org/webt/rh/zj/da/rhzjdasl8ioia8n8okjuuaieft4.png"><br><br><img src="https://habrastorage.org/webt/dy/3a/0z/dy3a0zmkacoa4tvgaugebovdhqy.png"><br><br>  Entonces  Primero debe configurar la se√±al RS (ya que R / W est√° soldado a cero en el hardware).  A continuaci√≥n, espere tAS, luego eleve la se√±al E y configure los datos (la configuraci√≥n de datos con respecto al borde positivo E no est√° limitada).  Los datos deben estar en el bus no menos que tDSW, despu√©s de lo cual se debe eliminar la se√±al E. Los datos deben permanecer en el bus durante al menos tDHW, y RS durante al menos tAH. <br><br>  RS es el comando o el indicador de datos.  Si RS es cero, se escribe un comando, si es uno, se escriben los datos. <br><br>  Sugiero enviar comandos a trav√©s de <b>FIFO0</b> y datos a trav√©s de <b>FIFO1</b> .  En el marco de la tarea actual, esto no contradice nada.  Entonces la m√°quina de estados finitos propuesta por m√≠ tendr√° la siguiente forma: <br><br><img src="https://habrastorage.org/webt/jn/6y/6j/jn6y6jnzllwbwgmslak7nif1xmu.png"><br><br>  En el estado <b>inactivo</b> , la m√°quina a√∫n no tiene datos FIFO.  Si aparecieron datos en <b>FIFO0</b> , va a <b>LoadF0</b> , donde en el futuro recibir√° datos de <b>FIFO0</b> a A0. <br><br>  Mientras se transmiten los comandos, los datos no deben enviarse.  Por lo tanto, la condici√≥n para recibir datos tendr√° menor prioridad que la condici√≥n para recibir comandos. <br><br><img src="https://habrastorage.org/webt/og/gn/fl/oggnfl3tcjcxa8pzu64qcj3yzpa.png"><br><br>  Los datos se reciben en A1 en el estado <b>LoadF1</b> (desde <b>FIFO1</b> solo pueden ir al registro A1 y no pueden ir al registro A0), y luego se copian de A1 a A0 en el estado <b>A1toA0</b> . <br><br>  De cualquier manera que vayamos al punto de convergencia de las flechas, tenemos datos en A0.  Ya se env√≠an al puerto paralelo.  <b>Martillamos</b> E (en estado <b>E_UP1</b> ), <b>soltamos</b> E (en estado <b>E_DOWN1</b> ).  A continuaci√≥n, tendremos un estado para intercambiar nibbles ( <b>SWAP</b> ), despu√©s de lo cual E se eleva nuevamente ( <b>E_UP2</b> ).  Sobre esto, he agotado ocho estados que pueden codificarse en tres bits.  Y recordamos que la RAM de configuraci√≥n din√°mica de Datapath tiene solo tres entradas de direcci√≥n.  Se podr√≠an aplicar algunos trucos, pero el art√≠culo ya es grande.  Por lo tanto, solo la segunda vez colocaremos E en el estado <b>Inactivo</b> .  Entonces ocho estados son suficientes para nosotros. <br><br>  Tambi√©n colocamos Datapath en la hoja y asignamos sus entradas y salidas de una manera que es familiar en los art√≠culos anteriores.  Aqu√≠ est√°n las entradas: <br><br><img src="https://habrastorage.org/webt/ct/fn/0j/ctfn0jvexwfycfrdovbnatwv7ze.png"><br><br>  Aqu√≠ est√°n las salidas: <br><br><img src="https://habrastorage.org/webt/ct/mj/gd/ctmjgdzfvx-mz8qnzwbp6undlau.png"><br><br>  Nada nuevo, todo ya se ha descrito en art√≠culos anteriores del ciclo.  Entonces, tenemos un espacio en blanco, en base al cual podemos hacer algo por nuestra cuenta.  Es cierto, para asegurarnos de que todo est√© funcionando, necesitamos llevar nuestro sistema al nivel superior del proyecto, de lo contrario no se encontrar√°n errores.  Y en los experimentos iniciales sin errores no funcionar√°.  Por lo tanto, haremos una acci√≥n auxiliar m√°s. <br><br>  La descripci√≥n de c√≥mo se realiza el circuito va m√°s all√° de la descripci√≥n de trabajar con UDB.  Solo te mostrar√© qu√© circuito tengo.  Solo hay una unidad DMA: cuando se env√≠an comandos a la pantalla LCD, es necesario soportar grandes pausas, por lo que a√∫n es m√°s f√°cil hacerlo mediante programaci√≥n.  Para otras aplicaciones, simplemente puede poner el segundo bloque DMA por analog√≠a usando la se√±al <b>hungry0</b> . <br><br><img src="https://habrastorage.org/webt/mz/zd/g8/mzzdg80tinx_ffjjigxypmehj0w.png"><br><br>  Para cumplir con precisi√≥n el marco de tiempo, eleg√≠ una frecuencia de reloj igual a un megahercio.  Ser√≠a posible tomar una frecuencia y m√°s, pero los datos se transmiten a trav√©s de cables largos en condiciones de alta interferencia, por lo que es mejor tomarse el tiempo para configurar los datos antes y despu√©s de la puerta con un margen.  Si alguien repite mis experimentos en la misma placa de prueba, no use el puerto P3.2: un condensador est√° soldado a esta pata en la placa.  Mat√© durante media hora, hasta que descubr√≠ por qu√© no form√© un impulso E, que primero conect√© all√≠.  Lo lanc√© a P3.1, todo funcion√≥ de inmediato.  Mi bus de datos va a P3.7-P3.4, RS va a P3.3, por lo que E originalmente fue a P3.2 ... <br><br>  Bueno aqui.  Ahora, si intenta compilar el proyecto, obtenemos errores completamente predecibles <br><br><img src="https://habrastorage.org/webt/az/tm/fb/aztmfbvzsl52ghanjovqpva5_7o.png"><br><br>  Entonces el sistema est√° tratando de recolectar algo.  Pero ella todav√≠a no tiene nada que coleccionar.  Procedemos a copiar el c√≥digo.  Para hacer esto, en el Editor UDB, cambie a la pesta√±a Verilog (esta pesta√±a se encuentra debajo de la ventana con la hoja del Editor UDB): <br><br><img src="https://habrastorage.org/webt/kg/tk/fy/kgtkfyn1tssdt4-cjydawzl7vnw.png"><br><br>  ¬øQu√© es familiar all√≠?  Al final del texto est√° el cuerpo del aut√≥mata.  Comencemos la migraci√≥n desde all√≠. <br><br><div class="spoiler">  <b class="spoiler_title">Tambi√©n col√≥quelo debajo de Datapath:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== State Machine: SM ==================== */ always @ (posedge clock) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end E_Up1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Down1 ; end end E_Down1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= SWAP ; end end SWAP : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_UP2 ; end end E_UP2 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= Idle ; end end LoadF1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= A1toA0 ; end end A1toA0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Hay declaraciones en la parte superior de este c√≥digo (nombres para estados, cadenas para Datapath, un registro que codifica el estado de un aut√≥mata).  Los transferimos al <div class="spoiler">  <b class="spoiler_title">secci√≥n de nuestro c√≥digo:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire hungry0; wire F0empty; wire hungry1; wire F1empty; wire Datapath_1_d0_load; wire Datapath_1_d1_load; wire Datapath_1_f0_load; wire Datapath_1_f1_load; wire Datapath_1_route_si; wire Datapath_1_route_ci; wire [2:0] Datapath_1_select; reg [2:0] SM;</code> </pre><br></div></div><br>  Bueno y <br><br><div class="spoiler">  <b class="spoiler_title">el sitio de uni√≥n de se√±al es transferible:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Assignment of Combinatorial Variables ==================== */ assign Datapath_1_d0_load = (1'b0); assign Datapath_1_d1_load = (1'b0); assign Datapath_1_f0_load = (1'b0); assign Datapath_1_f1_load = (1'b0); assign Datapath_1_route_si = (1'b0); assign Datapath_1_route_ci = (1'b0); assign Datapath_1_select[0] = (SM[0]); assign Datapath_1_select[1] = (SM[1]); assign Datapath_1_select[2] = (SM[2]);</code> </pre><br></div></div><br>  Es hora de conectar Datapath.  El c√≥digo portado desde el editor UDB es bueno para la edici√≥n autom√°tica, pero no muy bueno para la edici√≥n manual.  All√≠, se crean cadenas que se conectan a las entradas de Datapath en un extremo y a las constantes en el otro.  Pero en el c√≥digo creado por la <b>Herramienta de configuraci√≥n de Datapath</b> (que hace todo para el trabajo manual), todas las entradas ya est√°n conectadas directamente a constantes cero.  As√≠ que conectar√© solo aquellas l√≠neas que no son constantes, pero cortar√© todo lo relacionado con el reenv√≠o de constantes del texto transferido.  La conexi√≥n result√≥ as√≠ (el color resalta los lugares que edit√© con respecto a los creados autom√°ticamente en la Herramienta de configuraci√≥n de Datapath): <br><br><img src="https://habrastorage.org/webt/-3/gk/fd/-3gkfd3bhnnc7wygbr6wpqoscyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(clk), /* input [02:00] */ .cs_addr(SM), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(hungry0), /* output */ .f0_blk_stat(F0empty), /* output */ .f1_bus_stat(hungry1), /* output */ .f1_blk_stat(F1empty),</code> </pre><br></div></div><br>  Los datos paralelos son un poco m√°s complicados.  Datapath tiene un puerto de ocho bits, y solo cuatro de ellos deben sacarse.  Por lo tanto, comenzamos el circuito auxiliar y conectamos solo la mitad a la salida: <br><br><pre> <code class="plaintext hljs">wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Y con√©ctelo as√≠: <br><br><img src="https://habrastorage.org/webt/km/aq/_a/kmaq_abi2kkprp406kne413j5u0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po( tempBus) // Parallel data port );</code> </pre><br></div></div><br>  Intentamos ensamblar (Shift + F6 o mediante el elemento de men√∫ <b>Build-&gt; Generate Application</b> ).  Obtenemos el error: <br><br><img src="https://habrastorage.org/webt/kw/ox/as/kwoxasreij4-snkxyvc63iqozxq.png"><br><br>  Tenemos puertos <b>hambriento0</b> y <b>hambriento1</b> (aparecieron al crear el componente), as√≠ como cadenas del mismo nombre (aparecieron al arrastrar desde la muestra).  Simplemente quite estas cadenas (dejando los puertos).  Y en alg√∫n lugar la se√±al del <b>reloj</b> se filtr√≥, y tenemos este circuito llamado <b>clk</b> . <br><br>  Despu√©s de eliminar todos los circuitos innecesarios (aquellos que inicialmente arrojaron constantes cero a las entradas de Datapath, as√≠ como <b>hungry0</b> y <b>hungry1</b> ), obtenemos el siguiente c√≥digo para el comienzo de nuestro archivo: <br><br><pre> <code class="plaintext hljs">// Your code goes here /* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire F0empty; wire F1empty; reg [2:0] SM; /* ==================== Assignment of Combinatorial Variables ==================== */ wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  Y al reemplazar el <b>reloj</b> con <b>clk</b> en el cuerpo de la m√°quina, al mismo tiempo arrojar√© todas las l√≠neas que son buenas para la generaci√≥n autom√°tica, pero con la edici√≥n manual solo crean confusi√≥n (todas las comparaciones que dan un resultado incondicional <b>VERDADERO</b> y as√≠ sucesivamente).  En particular, en el ejemplo a continuaci√≥n, puede tachar aproximadamente la mitad de las l√≠neas (y algunas de <b>inicio / final</b> son opcionales, a veces ser√°n necesarias, porque agregaremos acciones, las destaqu√©): <br><br><img src="https://habrastorage.org/webt/9s/e9/t1/9se9t15zkc1hux1qrpga3jbh7cm.png"><br><br>  Despu√©s de peinar de acuerdo con el principio anterior (y reemplazar el <b>reloj</b> con <b>clk</b> ), dicho cuerpo permanece <br><br><div class="spoiler">  <b class="spoiler_title">(se ha vuelto m√°s corto, lo que significa que es m√°s f√°cil de leer):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; end E_Down1 : begin SM &lt;= SWAP ; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Ahora, durante la compilaci√≥n, se nos dice que los <b>circuitos</b> <b>LCD_E</b> y <b>LCD_RS</b> no <b>est√°n</b> conectados. <br><br>  En realidad, esto es cierto: <br><br><img src="https://habrastorage.org/webt/cz/da/h7/czdah7nfkzmou2mr8-omzs_-hby.png"><br><br>  Ha llegado el momento de agregar acci√≥n a la m√°quina de estado.  Reemplazaremos las declaraciones de los puertos correspondientes a las cadenas no conectadas con <b>reg</b> , ya que las escribiremos en el cuerpo de la m√°quina (esta es la sintaxis del lenguaje Verilog, si escribimos, los datos deben hacer clic, para esto necesitamos un disparador, y est√° dada por la palabra clave <b>reg</b> ): <br><br><img src="https://habrastorage.org/webt/l5/vq/uj/l5vqujn7yirpf4dkorxzevy9ij4.png"><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module LCD4bit ( output hungry0, output hungry1, output [3:0] LCD_D, output reg LCD_E, output reg LCD_RS, input clk );</code> </pre><br></div></div><br>  Y llene la m√°quina con acciones.  Ya dije la l√≥gica anterior cuando estaba considerando el gr√°fico de transici√≥n del aut√≥mata, por lo que solo mostrar√© el resultado: <br><br><img src="https://habrastorage.org/webt/ij/t1/5i/ijt15itzdfznooyvlgz0sjlk5t4.png"><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; LCD_E &lt;= 1'b1; end E_Down1 : begin SM &lt;= SWAP ; LCD_E &lt;= 1'b0; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; LCD_E &lt;= 1; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  A partir de este momento, el proyecto comienza a ensamblarse.  Pero a√∫n no va a trabajar.  Hasta ahora, he dicho: "En este estado, cargaremos el registro desde FIFO", "En esto, A1 se copiar√° a A0", "Los nibbles se reorganizar√°n en esto".  En general, habl√© mucho, pero hasta ahora no ha habido acciones.  Ha llegado el momento de cumplirlos.  Vemos c√≥mo se codificaron los estados: <br><br><pre> <code class="plaintext hljs">localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111;</code> </pre><br>  <b>Vuelva a abrir la herramienta de configuraci√≥n de Datapath</b> : <br><br><img src="https://habrastorage.org/webt/eh/oh/sz/ehohszogw7vzyiup9cjumf4b3ii.png"><br><br>  Y comience a <b>editar las</b> l√≠neas <b>CFGRAM</b> .  Al editar, debe tener en cuenta el esquema Datapath, a saber: <br><br><img src="https://habrastorage.org/webt/cz/xr/vu/czxrvuaul7vkqilrqinrgzpu1fy.png"><br><br>  Los cuadros rojos en la figura siguiente (y las flechas en la figura anterior) resaltaron las √°reas corregidas (y la ruta de datos) para el estado <b>LoadF0</b> (c√≥digo 001, es decir, <b>Reg1</b> ).  Tambi√©n ingres√© comentarios manualmente.  El contenido de F0 debe entrar en A0. <br><br><img src="https://habrastorage.org/webt/4z/zv/kh/4zzvkhchg55gnp-39oag_d-bkt8.png"><br><br>  Con marcos y flechas verdes marqu√© la configuraci√≥n y la ruta para el estado LoadF1 (c√≥digo 010 - <b>Reg2</b> ). <br><br>  Con marcos azules y flechas marqu√© la configuraci√≥n y la ruta para el estado A1toA0 (c√≥digo 011 - <b>Reg3</b> ). <br><br>  Los cuadros y flechas morados <b>marqu√©</b> la configuraci√≥n y la ruta para el estado de SWAP (c√≥digo 110 - <b>Reg6</b> ). <br><br>  Finalmente, las flechas naranjas muestran la ruta de datos paralela.  Y no se toman medidas por ellos.  Siempre salen de la <b>SRCA</b> .  Casi siempre tenemos A0 seleccionado como <b>SRCA</b> : los datos provienen de A0.  Entonces, para redirigir los datos de entrada, tendr√≠amos que realizar muchas acciones auxiliares, pero no aceptamos ning√∫n dato, por lo que aqu√≠ no necesitamos estas acciones, y todos encontrar√°n su lista en <b>AN82156</b> .  Tampoco necesitamos editar ninguna configuraci√≥n est√°tica de Datapath, as√≠ que cierre la <b>herramienta de configuraci√≥n de Datapath</b> . <br><br>  Eso es todo.  Hardware concebido completado.  Comenzar a desarrollar c√≥digo C.  Para hacer esto, vaya a la pesta√±a <b>Fuente</b> y edite el archivo <b>main.c.</b> <br><br><img src="https://habrastorage.org/webt/fp/ia/7s/fpia7s4zyzaxy8mzmqxktib-obw.png"><br><br>  La inicializaci√≥n regular de LCD y la salida de caracteres "ABC" se ven as√≠ (le recuerdo que los comandos van a <b>FIFO0</b> , la documentaci√≥n necesita insertar pausas entre los equipos, y los datos van a <b>FIFO1</b> , no encontr√© nada sobre las pausas entre los datos): <br><br><pre> <code class="plaintext hljs"> volatile uint8_t* pFIFO0 = (uint8_t*) LCD4bit_1_LCD_DP__F0_REG; volatile uint8_t* pFIFO1 = (uint8_t*) LCD4bit_1_LCD_DP__F1_REG; pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x33; CyDelay (100); pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x20; CyDelay (5); pFIFO0[0] = 0x0C; //   CyDelay (50); pFIFO0[0] = 0x01; //   CyDelay (50); pFIFO1[0] = 'A'; pFIFO1[0] = 'B'; pFIFO1[0] = 'C';</code> </pre><br>  Que es  ¬øPor qu√© solo hay el primer personaje en la pantalla? <br><br><img src="https://habrastorage.org/webt/3g/tq/sr/3gtqsrr050bqbhaqi2ke9g1pg0w.png"><br><br>  Y si agrega demoras entre la salida de datos, todo est√° bien: <br><br><img src="https://habrastorage.org/webt/3b/he/2a/3bhe2a1_ioou2gktkqfzydumrne.png"><br><br>  El osciloscopio no tiene suficientes canales para tal trabajo.  Verificamos el trabajo en un analizador l√≥gico.  El proceso de grabaci√≥n de datos es el siguiente. <br><br><img src="https://habrastorage.org/webt/yr/y_/_j/yry__jhgasihbzmmrrr2cnsylaq.png"><br><br>  Todos los datos est√°n en su lugar (tres pares de paquetes).  El tiempo de instalaci√≥n y ajuste de datos se asigna en un volumen suficiente.  En general, desde el punto de vista de los diagramas de tiempo, todo se hace correctamente.  El problema cient√≠fico se resuelve, se forman los diagramas de tiempo deseados.  Aqu√≠ est√° la ingenier√≠a, no.  La raz√≥n de esto es la lentitud del procesador instalado en la pantalla LCD.  Entre bytes, agregue retrasos. <br><br>  Formaremos demoras usando un contador de siete bits, al mismo tiempo entrenaremos para agregarlo a dicho sistema.  Manteng√°monos en estado inactivo no menos de un tiempo determinado, y un contador de siete bits medir√° este tiempo para nosotros.  Y nuevamente, no escribiremos, sino que crearemos c√≥digo.  Por lo tanto, nuevamente vamos al componente auxiliar del Editor UDB y agregamos un contador a la hoja de trabajo, configurando sus par√°metros de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/gq/8c/qw/gq8cqwl0liu7mv9gpgm8-wngom0.png"><br><br>  Este contador siempre funcionar√° ( <b>Habilitar se establece</b> en 1).  Pero se cargar√° cuando la m√°quina est√© en el estado <b>E_UP2</b> (despu√©s de lo cual <b>caeremos</b> inmediatamente en el estado <b>inactivo</b> ).  La l√≠nea <b>Count7_1_tc se elevar√°</b> a 1 cuando el contador cuente a cero, lo que <b>crearemos</b> una condici√≥n adicional para salir del estado <b>inactivo</b> .  La figura tambi√©n contiene el valor del per√≠odo, pero no lo encontraremos en el c√≥digo Verilog.  Tendr√° que ser ingresado en el c√≥digo C.  Pero primero, transferimos el c√≥digo Verilog generado autom√°ticamente al cambiar a la pesta√±a Verilog.  En primer lugar, el contador debe estar conectado (vemos este c√≥digo al principio del archivo y tambi√©n lo movemos al principio): <br><br><pre> <code class="plaintext hljs">`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0" `include "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0\Count7_v1_0.v"</code> </pre><br>  Ya se ha descrito c√≥mo se realiza el refinamiento creativo de l√≠neas y constantes, as√≠ que solo mostrar√© el resultado.  Aqu√≠ est√°n las cadenas y las tareas agregadas como resultado (el resto establece las constantes, as√≠ que las tir√©): <br><br><pre> <code class="plaintext hljs">wire Count7_1_load; wire Count7_1_tc; assign Count7_1_load = (SM==E_UP2);</code> </pre><br>  Y aqu√≠ est√° el contador en s√≠, colocado al final del archivo.  Todas las constantes se asignan a los puertos directamente en esta declaraci√≥n: <br><br><pre> <code class="plaintext hljs"> Count7_v1_0 Count7_1 ( .en(1'b1), .load(Count7_1_load), .clock(clk), .reset(1'b0), .cnt(), .tc(Count7_1_tc)); defparam Count7_1.EnableSignal = 1; defparam Count7_1.LoadSignal = 1;</code> </pre><br>  Para permitir que este contador funcione, agregamos autom√°ticamente una condici√≥n adicional para salir del estado <b>Inactivo</b> : <br><br><img src="https://habrastorage.org/webt/pc/it/pd/pcitpdmqenlvq8pblarf3uh5h84.png"><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty &amp;Count7_1_tc ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end</code> </pre><br></div></div><br>  La API para el contador agregado de esta manera no se crea, por lo que agregamos dos l√≠neas m√°gicas a la funci√≥n <b>principal</b> , que form√© en la imagen y semejanza de lo que vi en la API de proyectos anteriores (la primera l√≠nea establece el valor cargado de la cuenta, la misma Carga, la segunda inicia el contador): <br><br><pre> <code class="plaintext hljs"> *((uint8_t*)LCD4bit_1_Count7_1_Counter7__PERIOD_REG) = 0x20; *((uint8_t*)LCD4bit_1_Count7_1_Counter7__CONTROL_AUX_CTL_REG) |= 0x20; // Start</code> </pre><br>  El analizador muestra que en el caso modificado el retraso es obvio: <br><br><img src="https://habrastorage.org/webt/ui/ey/ax/uieyax5yt3f0kpkhyyoikiishmq.png"><br><br>  La pantalla LCD tambi√©n tiene los tres caracteres. <br><br>  Pero la producci√≥n de caracteres program√°ticos en la vida real es inaceptable.  Solo agregarlos a FIFO se desbordar√°.  Espere a que el FIFO se vac√≠e, esto significa crear grandes demoras para el n√∫cleo del procesador.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procesador funciona a una frecuencia de 72 MHz, y los datos se emiten durante 7-8 ciclos de reloj a una frecuencia de 1 MHz. </font><font style="vertical-align: inherit;">Por lo tanto, en la vida real, el texto debe mostrarse usando DMA. </font><font style="vertical-align: inherit;">Aqu√≠ es donde el principio de "lanzamiento y olvido" es √∫til. </font><font style="vertical-align: inherit;">UDB generar√° todos los retrasos para el diagrama de temporizaci√≥n, y el controlador DMA determinar√° la disponibilidad de FIFO para recibirnos datos. </font><font style="vertical-align: inherit;">El n√∫cleo del procesador solo necesita formar una l√≠nea en la memoria y configurar DMA, despu√©s de lo cual puede realizar otras tareas sin preocuparse por la salida a la pantalla LCD.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue el siguiente c√≥digo:</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> static const char line[] = "This is a line"; /* Defines for DMA_D */ #define DMA_D_BYTES_PER_BURST 1 #define DMA_D_REQUEST_PER_BURST 1 /* Variable declarations for DMA_D */ /* Move these variable declarations to the top of the function */ uint8 DMA_D_Chan; uint8 DMA_D_TD[1]; /* DMA Configuration for DMA_D */ DMA_D_Chan = DMA_D_DmaInitialize(DMA_D_BYTES_PER_BURST, DMA_D_REQUEST_PER_BURST, HI16(line), HI16(LCD4bit_1_LCD_DP__F1_REG)); DMA_D_TD[0] = CyDmaTdAllocate(); CyDmaTdSetConfiguration(DMA_D_TD[0], sizeof(line)-1, CY_DMA_DISABLE_TD, CY_DMA_TD_INC_SRC_ADR); CyDmaTdSetAddress(DMA_D_TD[0], LO16((uint32)line), LO16((uint32)LCD4bit_1_LCD_DP__F1_REG)); CyDmaChSetInitialTd(DMA_D_Chan, DMA_D_TD[0]); CyDmaChEnable(DMA_D_Chan, 1);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En la pantalla tenemos: </font></font><br><br><img src="https://habrastorage.org/webt/i7/ny/vi/i7nyvipk7tg8w_jdflryw2s39uk.png"><br><br><h2>  Conclusi√≥n </h2><br>  ,     ,        UDB     ‚Äî Datapath Config Tool.  ,    UDB Editor,        UDB,     ,   UDB Editor.             ,    ,    ,     UDB Editor. <br><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442572/">https://habr.com/ru/post/442572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442560/index.html">Mash: multiproceso, corutinas, as√≠ncrono y espera</a></li>
<li><a href="../442562/index.html">C√≥mo enfriar equipos en un centro de datos: tres nuevas tecnolog√≠as</a></li>
<li><a href="../442566/index.html">Igual que en la luna: ingenier√≠a inversa de un m√≥dulo de amplificador operacional h√≠brido</a></li>
<li><a href="../442568/index.html">Semana de la seguridad 10: Vulnerabilidades del controlador NVIDIA</a></li>
<li><a href="../442570/index.html">Sigma gobierna. Arte o nuevo est√°ndar para SOC</a></li>
<li><a href="../442574/index.html">Se crea la base para una teor√≠a generalizada de las redes neuronales.</a></li>
<li><a href="../442576/index.html">Larga vida a los overclockers: c√≥mo la refrigeraci√≥n l√≠quida comenz√≥ a dominar en los centros de datos</a></li>
<li><a href="../442578/index.html">Lanzamiento de Linux 5.0</a></li>
<li><a href="../442580/index.html">Ingenier√≠a inversa de formato binario utilizando archivos Korg .SNG como ejemplo</a></li>
<li><a href="../442582/index.html">C√≥mo tratamos de mobbing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>