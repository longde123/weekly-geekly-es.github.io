<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤑 👩🏻‍🔧 🛰️ Aturan untuk memilih kerangka kerja JS 🤗 👿 🕚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 



- Artikel ini tidak membahas kerangka kerja JS dari daftar TOP-3. 
- Ketika mengembangkan kerangka JS non-TOP-3, Anda harus menyelesaikan u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aturan untuk memilih kerangka kerja JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456448/">  TL; DR <br><br><ul><li>  Artikel ini tidak membahas kerangka kerja JS dari daftar TOP-3. </li><li>  Ketika mengembangkan kerangka JS non-TOP-3, Anda harus menyelesaikan urutan besarnya lebih banyak masalah teknis daripada yang diharapkan pada awal pengembangan <br></li><li>  Kisah ini didasarkan pada peristiwa nyata. </li></ul><a name="habracut"></a><br>  Cerita dimulai dengan satu proyek kecil, yang awalnya dikembangkan berdasarkan perpustakaan backbone.js dan marionette.js.  Ini, tentu saja, adalah perpustakaan hebat yang memulai sejarah pengembangan aplikasi satu halaman.  Tetapi pada saat itu mereka lebih cenderung memiliki nilai historis daripada nilai praktis.  Saya hanya akan menyebutkan fakta bahwa untuk menampilkan tabel sederhana perlu dibuat: 1) modul dengan deskripsi model, 2) modul dengan deskripsi koleksi, 3) modul dengan definisi model tampilan, 4) modul dengan definisi koleksi tampilan, 4) template baris tabel, 5) tabel templat; 6) modul pengontrol.  Memiliki sekitar 10 entitas dalam aplikasi kecil - pada tahap awal Anda sudah memiliki lebih dari lima puluh modul kecil.  Dan ini baru permulaan.  Tapi sekarang bukan tentang itu. <br><br>  Pada titik tertentu, setelah enam bulan aplikasi, itu masih tidak muncul di hasil pencarian.  Menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prerender.io</a> ke proyek (yang kemudian menggunakan mesin phantom.js) membantu, tetapi tidak sepenting yang diharapkan.  Awan mulai berkumpul di atas aplikasi dan di atas saya, setelah itu saya menyadari bahwa saya perlu melakukan sesuatu dengan sangat cepat dan efisien, lebih disukai hari ini.  Tujuan yang saya tetapkan adalah ini: beralih ke rendering server.  Dengan backbone.js dan marionettejs, ini hampir mustahil.  Bagaimanapun, proyek rendr di backbone.js, yang dikembangkan di bawah arahan Spike Brehm (penulis gagasan aplikasi isomorfik / universal), mengumpulkan 58 kontributor dan 4.184 suka di github.com, dihentikan pada 2015, dan jelas tidak dimaksudkan untuk blitz satu hari .  Saya mulai mencari alternatif.  Saya mengecualikan kerangka JS TOP-3 dari pertimbangan segera, karena saya tidak punya cadangan waktu untuk pengembangan mereka.  Setelah pencarian singkat, saya menemukan kerangka kerja JS yang berkembang pesat, riot.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/riot</a> , yang saat ini memiliki 13.704 suka di github.com, dan, seperti yang saya harapkan, itu bisa saja mencapai yang pertama posisi (yang, bagaimanapun, tidak terjadi). <br><br>  Dan ya, saya menutup pertanyaan (meskipun tidak pada hari yang sama, tetapi untuk dua hari berikutnya dalam sehari) dengan mentransfer aplikasi ke server rendering menggunakan riot.js.  Dan pada hari yang sama ketika ini terjadi, situs tersebut pindah ke sepuluh halaman pertama hasil pencarian.  Dan dalam seminggu saya pergi ke halaman pertama, dari tempat itu tidak pergi selama beberapa tahun. <br><br>  Ini mengakhiri kisah sukses dan memulai sejarah kekalahan.  Proyek selanjutnya jauh lebih rumit.  Benar, ada poin positif yaitu 99% layar aplikasi ada di akun pribadi pengguna, jadi tidak perlu rendering server.  Terinspirasi oleh pengalaman sukses pertama menggunakan riot.js, saya mulai mempromosikan gagasan untuk mengkonsolidasikan kesuksesan dan menerapkan riot.js di frontend.  Kemudian bagi saya tampaknya, akhirnya, sebuah solusi ditemukan yang menggabungkan kesederhanaan dan fungsionalitas, seperti yang dijanjikan oleh dokumentasi riot.js.  Betapa salahnya aku! <br><br>  Masalah pertama yang saya temui ketika perlu menyediakan desainer tata letak HTML dengan semua alat pengembangan yang diperlukan.  Secara khusus, kami membutuhkan plug-in untuk editor kode, sebuah mesin yang memungkinkan untuk menempatkan komponen dan segera mengamati hasilnya, termasuk dengan kelebihan beban komponen (hot-reload).  Semua ini harus diberikan dalam bentuk siap untuk operasi industri dalam waktu dekat, dan semua ini tidak.  Akibatnya, tata letak aplikasi dimulai pada salah satu mesin templat tradisional, yang akibatnya menyebabkan tahap tidak berterima kasih menerjemahkan dokumen HTML ke riot.js. <br><br>  Namun, masalah utama yang muncul pada tahap ini bahkan tidak terkait dengan terjemahan tata letak dari format template ke komponen riot.js.  Tiba-tiba, ternyata riot.js memberikan pesan yang benar-benar tidak informatif tentang kesalahan kompilasi template, serta kesalahan runtime (ini berlaku untuk semua versi riot.js hingga versi 4.0, yang telah sepenuhnya didesain ulang).  Tidak ada informasi tidak hanya tentang baris di mana kesalahan terjadi, tetapi bahkan tentang nama file atau komponen di mana kesalahan terjadi.  Dimungkinkan untuk mencari kesalahan selama berjam-jam berturut-turut, dan tetap saja itu tidak dapat ditemukan.  Dan kemudian saya harus memutar kembali semua perubahan ke kondisi kerja terakhir. <br><br>  Berikut ini adalah masalah dengan perutean.  Routing di riot.js hampir keluar dari kotak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/route</a> - setidaknya dari pengembang yang sama.  Ini membuatnya berharap operasi bebas masalah.  Tetapi pada titik tertentu saya perhatikan bahwa beberapa halaman kelebihan beban tidak terduga.  Artinya, suatu kali transisi ke rute baru dapat terjadi dalam mode aplikasi satu halaman, dan lain kali transisi yang sama membebani seluruh dokumen HTML, seperti ketika bekerja dengan aplikasi web klasik.  Dalam kasus ini, tentu saja, keadaan internal hilang jika belum disimpan di server.  (Saat ini, pengembangan perpustakaan ini dihentikan dan tidak digunakan dengan riot.js 4.0.) <br><br>  Satu-satunya komponen sistem yang berfungsi seperti yang diharapkan adalah state manager minim flux-like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jimsparkman/RiotControl</a> .  Benar, untuk bekerja dengan komponen ini, perlu menunjuk dan membatalkan pendengar perubahan negara lebih sering daripada yang kita inginkan. <br><br>  Ide awal dari artikel ini adalah ini: untuk menunjukkan dengan contoh pengalaman kami sendiri dengan kerangka kerja kerusuhan.js tugas-tugas yang harus diselesaikan oleh pengembang, yang memutuskan (memutuskan) untuk mengembangkan aplikasi pada kerangka kerja JS bukan dari daftar TOP-3.  Namun, dalam proses persiapan, saya memutuskan untuk me-refresh beberapa halaman dari dokumentasi riot.js di ingatan saya, dan jadi saya belajar bahwa versi baru riot.js 4.0 dirilis, yang sepenuhnya (dari awal) didesain ulang, yang dapat ditemukan di artikel pengembang kerusuhan. js di medium.com: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">medium.com/@gianluca.guarini/every-revolution-begins-with-a-riot-js-first-6c6a4b090ee</a> .  Dari artikel ini saya belajar bahwa semua masalah utama yang membuat saya khawatir, dan yang akan saya bicarakan dalam artikel ini, telah dieliminasi.  Secara khusus, dalam riot.js versi 4.0: <br><br><ul><li>  kompiler sepenuhnya ditulis ulang (atau lebih tepatnya, itu pertama kali ditulis karena mesin yang digunakan untuk bekerja pada ekspresi reguler sebelumnya) - ini mempengaruhi, khususnya, isi informasi dari pesan kesalahan <br></li><li>  selain rendering server, hidrat ditambahkan pada klien - ini akhirnya memungkinkan kami untuk mulai menulis aplikasi universal tanpa rendering ganda (pertama kali di server dan di sana pada klien karena kurangnya fungsi hydrate () dalam versi yang lebih lama) </li><li>  menambahkan plugin untuk komponen overloading panas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/hot-reload</a> </li><li>  dan banyak perubahan bermanfaat lainnya </li></ul><br>  Ini bukan iklan, hanya latar belakang.  Bahkan, kesimpulan saya akan sangat ambigu dalam hal rekomendasi untuk digunakan, dan artikel secara umum tidak dikhususkan untuk kerangka kerja atau perpustakaan tertentu, tetapi untuk tugas-tugas yang perlu diselesaikan selama proses pengembangan. <br><br>  Sayangnya, pekerjaan yang dilakukan oleh pengembang riot.js belum dievaluasi dengan baik oleh komunitas.  Misalnya, server render perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/ssr</a> selama enam bulan yang telah berlalu sejak awal pengembangannya telah mengumpulkan tiga ko-kontributor dan tiga suka di github.com (tidak semua suka dibuat oleh kontributor, meskipun satu suka sama dengan kontributor). <br><br>  Oleh karena itu, dalam perjalanan lakon itu, dia mengubah arah artikel, dan bukannya memoir, dia mencoba untuk melakukan semua jalan lagi, memiliki sedikit lebih banyak pengetahuan dan pengalaman, versi perpustakaan yang lebih maju dan waktu luang tanpa batas. <br><br>  Jadi di sini kita mulai.  Misalnya, implementasi aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/gothinkster/realworld</a> dibuat.  Proyek ini telah dibahas lebih dari sekali tentang Habré.  Bagi mereka yang tidak mengenalnya, saya akan menjelaskan idenya secara singkat.  Pengembang proyek ini dengan bantuan bahasa dan kerangka kerja yang berbeda (atau tanpa mereka) memecahkan masalah yang sama: pengembangan mesin blog yang terlihat seperti versi sederhana dari medium.com dalam fungsi.  Ini adalah kompromi antara kompleksitas aplikasi nyata yang harus kita kembangkan setiap hari dan todo.app, yang tidak selalu memungkinkan kita untuk benar-benar mengevaluasi pekerjaan dengan pustaka atau kerangka kerja.  Proyek ini dihormati oleh pengembang.  Untuk mendukung hal di atas, saya dapat mengatakan bahwa bahkan ada satu implementasi dari Rich Harris (pengembang utama sveltejs) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/sveltejs/realworld</a> . <br><br><h3>  Lingkungan pengembangan </h3><br>  Tentu saja Anda siap untuk berperang, tetapi pikirkan tentang pengembang di sekitar Anda.  Dalam hal ini, fokuslah pada pertanyaan di mana lingkungan pengembangan rekan kerja Anda.  Jika tidak ada plugin untuk lingkungan pengembangan utama dan editor kode program untuk kerangka kerja yang akan Anda gunakan, maka Anda tidak akan didukung.  Sebagai contoh, saya menggunakan editor Atom untuk pengembangan.  Baginya ada plugin riot-tag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/syntax-highlight/tree/legacy</a> , yang belum diperbarui selama tiga tahun terakhir.  Dan di repositori yang sama ada sebuah plugin untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/syntax-highlight yang</a> sublim - ini saat ini dan mendukung versi saat ini riot.js 4.0. <br><br>  Namun, komponen riot.js adalah fragmen yang valid dari dokumen HTML di mana kode JS terkandung dalam tubuh elemen skrip.  Jadi semuanya hanya berfungsi jika Anda menambahkan tipe dokumen html untuk ekstensi * .riot.  Tentu saja, ini adalah keputusan yang dipaksakan, karena kalau tidak, mustahil untuk melanjutkan lebih jauh di sini. <br><br>  Kami mendapat sorotan sintaksis dalam editor teks, dan sekarang kami membutuhkan fungsionalitas yang lebih maju, yang biasa kami peroleh dari eslint.  Dalam kasus kami, komponen kode JS terdapat di badan elemen skrip, saya berharap menemukan dan menemukan plug-in untuk mengekstraksi kode JS dari dokumen HTML - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/BenoitZugmeyer/eslint-plugin-html</a> .  Setelah itu, konfigurasi eslint saya mulai terlihat seperti ini: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"parser"</span></span>: <span class="hljs-string"><span class="hljs-string">"babel-eslint"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"html"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"html/html-extensions"</span></span>: [<span class="hljs-string"><span class="hljs-string">".html"</span></span>, <span class="hljs-string"><span class="hljs-string">".riot"</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">"env"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"browser"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"node"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"es6"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"extends"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"globals"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Atomics"</span></span>: <span class="hljs-string"><span class="hljs-string">"readonly"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"SharedArrayBuffer"</span></span>: <span class="hljs-string"><span class="hljs-string">"readonly"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"parserOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ecmaVersion"</span></span>: <span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-attr"><span class="hljs-attr">"sourceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"module"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { } }</code> </pre> <br>  Kehadiran plug-in untuk penyorotan sintaks dan eslint mungkin bukan hal pertama yang mulai dipikirkan pengembang ketika memilih kerangka kerja JS.  Sementara itu, tanpa alat-alat ini, Anda mungkin menghadapi oposisi dari kolega dan eksodus massal mereka untuk alasan "baik" dari proyek.  Meskipun satu-satunya alasan yang benar-benar valid adalah mereka tidak nyaman bekerja tanpa arsenal pengembang penuh.  Dalam kasus riot.js, masalah diselesaikan dengan metode Columbus.  Dalam arti bahwa sebenarnya tidak ada plugin untuk riot.js, tetapi karena kekhasan sintaks templat riot.js, yang terlihat seperti sebuah fragmen dari dokumen HTML biasa, kami mencakup 99% fungsionalitas yang diperlukan menggunakan alat untuk bekerja dengan dokumen HTML. <br><br>  Selain sarana untuk menulis dan memvalidasi kode yang baru saja kami periksa, alat pengembang mencakup alat untuk perakitan cepat dan debugging proyek, pemuatan ulang komponen dan modul di browser web saat membuat perubahan pada proyek.  Kami akan mempertimbangkan bagian ini di bagian selanjutnya. <br><br><h3>  Perakitan proyek </h3><br>  Kami berhasil membiasakan diri dengan sebagian besar fitur yang diperlukan ketika membangun proyek, dan bahkan berhenti memikirkan apa yang mungkin berbeda.  Tapi bisa jadi sebaliknya.  Dan, jika Anda telah memilih kerangka kerja JS baru, disarankan untuk terlebih dahulu memastikan bahwa semuanya berfungsi seperti yang Anda harapkan.  Sebagai contoh, seperti yang telah saya sebutkan, masalah terbesar ketika mengembangkan versi riot.js yang lebih lama adalah kurangnya kompilasi pesan kesalahan dan informasi runtime tentang komponen di mana kesalahan ini terjadi.  Juga penting adalah kecepatan kompilasi.  Sebagai aturan, untuk mempercepat kecepatan kompilasi, dalam kerangka kerja yang dibangun dengan benar hanya bagian yang diubah yang dikompilasi ulang, sebagai akibatnya, waktu reaksi terhadap perubahan teks komponen minimal.  Ya, sangat bagus jika memuat ulang komponen yang panas didukung tanpa memuat ulang penuh laman di peramban web. <br><br>  Oleh karena itu, saya akan mencoba mendaftar daftar periksa, apa yang perlu Anda perhatikan ketika menganalisis alat membangun proyek: <br><br>  1. Kehadiran mode pengembangan dan aplikasi yang berfungsi <br>  Dalam mode pengembang: <br>  2. Pesan informatif tentang kesalahan kompilasi proyek (nama file sumber, nomor baris dalam file sumber, deskripsi kesalahan) <br>  3. Pesan informatif tentang kesalahan runtime (nama file sumber, nomor baris dalam file sumber, deskripsi kesalahan) <br>  4. Pemasangan kembali modul yang dimodifikasi dengan cepat <br>  5. Panas kelebihan komponen di browser <br>  Dalam mode operasi: <br>  6. Kehadiran versi dalam nama file (misalnya 4a8ee185040ac59496a2.main.js) <br>  7. Tata letak modul kecil dalam satu atau lebih modul (potongan) <br>  8. Pemecah kode menjadi potongan menggunakan impor dinamis <br><br>  Dalam riot.js versi 4.0, modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/riot/webpack-loader</a> muncul, yang sepenuhnya sesuai dengan daftar periksa yang diberikan.  Saya tidak akan mencantumkan semua fitur konfigurasi perakitan.  Satu-satunya hal yang saya ingin menarik perhatian Anda adalah bahwa dalam proyek tersebut saya menggunakan modul untuk express.js: webpack-dev-middleware dan webpack-hot-middleware, yang memungkinkan Anda untuk bekerja pada server yang berfungsi penuh segera, dari saat tata letak.  Ini, khususnya, memungkinkan pengembangan aplikasi web universal / isomorfik.  Saya menarik perhatian Anda pada fakta bahwa modul kelebihan modul hanya valid untuk browser web.  Pada saat yang sama, komponen yang diberikan di sisi server tetap tidak berubah.  Oleh karena itu, perlu untuk mendengarkan perubahannya, dan pada saat yang tepat, hapus semua kode yang di-cache oleh server dan muat kode dari modul yang diubah.  Cara melakukan ini untuk waktu yang lama, jadi saya hanya akan memberikan tautan ke implementasinya: <a href="">github.com/apapacy/realworld-riotjs-effector-universal-hot/blob/master/src/dev_server.js</a> <br><br><h3>  Routing </h3><br>  Mengutip Leo Tolstoy sedikit, kita dapat mengatakan bahwa semua mesin kerangka JS mirip satu sama lain, sementara semua perutean yang melekat padanya bekerja dengan cara mereka sendiri.  Saya sering menemukan klasifikasi kondisional dari router menjadi dua jenis: deklaratif dan imperatif.  Sekarang saya akan mencoba mencari tahu bagaimana klasifikasi seperti itu dibenarkan. <br><br>  Mari kita bertamasya singkat ke dalam sejarah.  Pada awal Internet, URL / URI cocok dengan nama file yang dihosting di server.  Kami membuka beberapa halaman sejarah sekaligus dan kami akan belajar tentang kedatangan Arsitektur Model 2 (MVC).  Dalam arsitektur ini, pengontrol depan muncul, yang melakukan fungsi routing.  Saya bertanya-tanya siapa yang pertama kali memutuskan dari pengontrol depan untuk memilih fungsi perutean di blok terpisah, yang kemudian mengirim permintaan ke salah satu dari banyak pengontrol dan belum menemukan jawaban.  Tampaknya mereka mulai melakukannya sekaligus. <br><br>  Yaitu, routing menentukan tindakan yang harus dilakukan pada server dan (secara transitif melalui controller) tampilan yang akan dihasilkan oleh controller.  Saat mentransfer perutean ke sisi klien (browser web), ide fungsi perutean dalam aplikasi sudah terbentuk.  Dan mereka yang terutama berfokus pada fakta bahwa perutean menentukan tindakan, mengembangkan perutean imperatif, dan mereka yang memperhatikan bahwa, pada akhirnya, perutean menentukan pandangan yang harus ditunjukkan kepada pengguna, mengembangkan perutean deklaratif. <br><br>  Yaitu, ketika mentransfer dari server ke klien untuk perutean, mereka "menggantung" dua fungsi yang menjadi ciri perutean server (memilih tindakan dan memilih tampilan).  Selain itu, tugas baru telah muncul - ini adalah navigasi melalui aplikasi satu halaman tanpa sepenuhnya memuat ulang dokumen HTML, bekerja dengan sejarah kunjungan dan banyak lagi.  Sebagai ilustrasi, saya akan memberikan kutipan dari dokumentasi router dari satu framework mega-popular: <br><br>  ... membuatnya mudah untuk membuat aplikasi SPA.  Termasuk fitur-fitur berikut <br><br><ul><li>  Rute / Tampilan Bersarang </li><li>  Konfigurasi Router Modular </li><li>  Akses ke parameter rute, kueri, wildcard </li><li>  Lihat animasi transisi berdasarkan Vue.js </li><li>  Kontrol navigasi yang nyaman </li><li>  Pembubuhan otomatis kelas CSS aktif untuk tautan </li><li>  Mode atau hash riwayat HTML5, dengan sakelar otomatis di IE9 </li><li>  Perilaku gulir khusus </li></ul><br>  Dalam opsi ini, perutean jelas kelebihan beban dengan fungsi dan perlu memikirkan kembali tugasnya di sisi klien.  Saya mulai mencari solusi yang cocok untuk tugas saya.  Sebagai kriteria utama, saya memperhitungkan perutean itu: <br><br><ol><li>  harus bekerja sama pada sisi klien web dan sisi server web untuk aplikasi web universal / isomorfik; </li><li>  harus bekerja dengan kerangka kerja apa pun (termasuk yang saya pilih) atau tanpa itu. </li></ol><br>  Dan saya menemukan perpustakaan seperti itu, ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/kriasoft/universal-router</a> .  Jika kami menjelaskan secara singkat ide perpustakaan ini, ia mengkonfigurasi rute yang mengambil string URL pada input dan memanggil fungsi asinkron pada output, yang meneruskan URL yang diuraikan sebagai parameter aktual.  Jujur, saya ingin bertanya: apakah hanya itu?  Dan bagaimana seharusnya semua orang bekerja dengan ini?  Dan kemudian saya menemukan artikel di medium.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">medium.com/@ippei.tanaka/universal-router-history-react-97ec79464573</a> , di mana opsi yang cukup baik diusulkan, dengan pengecualian mungkin menulis ulang metode sejarah push (), yang tidak Saya perlu dan yang saya hapus dari kode saya.  Akibatnya, operasi router di sisi klien didefinisikan kira-kira seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> routes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UniversalRouter([ { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/sign-in'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'login'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'sign-in'</span></span> } }) }, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/sign-up'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'login'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'sign-up'</span></span> } }) }, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { req, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span> } }) }, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/page/:page'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { req, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span> } }) }, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/feed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { req, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'feed'</span></span> } }) }, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/feed/page/:page'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'home'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { req, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'feed'</span></span> } }) }, ... { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'(.*)'</span></span>, <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">page</span></span>: <span class="hljs-string"><span class="hljs-string">'notFound'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">action</span></span>: <span class="hljs-string"><span class="hljs-string">'not-found'</span></span> } }) } ]) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = getRootComponent() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> history = createBrowserHistory() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> render = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (location) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> route = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> router.resolve(location) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">`./riot/pages/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${route.page}</span></span></span><span class="hljs-string">.riot`</span></span>) riot.register(route.page, component.default || component) root.update(route, root) } history.listen(render)</code> </pre><br>  Sekarang panggilan ke history.push () akan memulai perutean.  Untuk bernavigasi di dalam aplikasi, Anda juga perlu membuat komponen yang membungkus elemen HTML standar a (jangkar), tidak lupa untuk membatalkan perilaku standarnya: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">navigation-link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">props.href</span></span></span><span class="hljs-tag"> } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag"> }&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> history </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'../history'</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> { action (e) { e.preventDefault() history.push(</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.props.href) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">if</span></span></span><span class="javascript"> (</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.props.onclick) { </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.props.onclick.call(</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">, e) } e.stopPropagation() } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">navigation-link</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h3>  Manajemen status aplikasi </h3><br>  Awalnya, saya menyertakan perpustakaan mobx dalam proyek.  Semuanya bekerja seperti yang diharapkan.  Kecuali bahwa itu tidak cukup sesuai dengan tugas - studi yang saya atur di awal artikel.  Jadi saya beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/zerobias/effector</a> .  Ini adalah proyek yang sangat kuat.  Ini memberikan 100% fungsionalitas redux (hanya tanpa overhead besar) dan fungsionalitas 100% mobx (walaupun dalam hal ini akan diperlukan untuk menyandikan lebih sedikit, tetapi masih lebih sedikit jika dibandingkan dengan mobx tanpa dekorator) <br><br>  Deskripsi toko terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore, createEvent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'effector'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { request } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../agent'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { parseError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../utils'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileStore</span></span></span><span class="hljs-class"> </span></span>{ get store () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.profileStore.getState() } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.success = createEvent() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = createEvent() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateError = createEvent() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.init = createEvent() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.profileStore = createStore(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .on(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.init, (state, store) =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ ...store }</span></span></span><span class="hljs-function">)) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.success, (state, data</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ data })) .on(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error, (state, error) =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ error }</span></span></span><span class="hljs-function">)) .</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.updateError, (state, error</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...state, error })) } getProfile ({ req, author }) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request(req, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">`/profiles/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">decodeURIComponent</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(author)}</span></span></span><span class="hljs-string">`</span></span> }).then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.success(response.data.profile), error =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error(parseError(error)) ) } follow ({ author, method }) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, { method, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">`/profiles/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${author}</span></span></span><span class="hljs-string">/follow`</span></span> }).then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.success(response.data.profile), error =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error(parseError(error)) ) } }</code> </pre><br>  Perpustakaan ini menggunakan reduksi penuh (mereka disebut dalam dokumentasi efektor.js), yang banyak orang kekurangan dalam mobx, tetapi dengan upaya pengkodean yang jauh lebih sedikit daripada redux.  Tapi yang utama bukan itu.  Setelah menerima 100% fungsionalitas redux dan mobx, saya hanya menggunakan sepersepuluh dari fungsionalitas yang melekat pada effector.js.  Dari mana kita dapat menyimpulkan bahwa penggunaannya dalam proyek-proyek kompleks dapat secara signifikan memperkaya dana pengembang. <br><br><h3>  Pengujian </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Todo</a> <br><br><h3>  Kesimpulan </h3><br>  Jadi, pekerjaannya selesai.  Hasilnya disajikan dalam repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/apapacy/realworld-riotjs-effector-universal-hot</a> dan dalam artikel ini tentang Habré. <br>  Situs demo di sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">realworld-riot-effector-universal-hot-pnujtmugam.now.sh</a> <br><br>  Dan pada akhirnya saya akan membagikan kesan saya tentang perkembangan tersebut.  Mengembangkan riot.js versi 4.0 cukup nyaman.  Banyak konstruk lebih mudah ditulis daripada di Bereaksi.  Butuh waktu tepat dua minggu untuk berkembang tanpa fanatisme di jam-jam sesudahnya dan di akhir pekan.  Tapi ... Satu kecil tapi ... Keajaiban itu tidak terjadi lagi.  Perenderan server di Bereaksi adalah 20-30 kali lebih cepat.  Perusahaan menang lagi.  Namun, dua perutean menarik dan perpustakaan manajer negara diuji. <br><br>  apapacy@gmail.com <br>  17 Juni 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456448/">https://habr.com/ru/post/id456448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456434/index.html">Profesi Masa Depan: "Siapa yang Akan Anda Kerjakan di Mars?"</a></li>
<li><a href="../id456436/index.html">Tugas JS pendek untuk hari Senin</a></li>
<li><a href="../id456440/index.html">Petualangan Malvari yang Elusif, Bagian I</a></li>
<li><a href="../id456442/index.html">Masuk ke program sarjana St. Petersburg State University dengan dukungan Yandex dan JetBrains</a></li>
<li><a href="../id456446/index.html">Ceph - dari "di lutut" ke "produksi"</a></li>
<li><a href="../id456450/index.html">DO-RA.Avia untuk memantau radiasi kosmik dalam penerbangan</a></li>
<li><a href="../id456452/index.html">Contoh kode C ++ sebelum dan sesudah Rentang</a></li>
<li><a href="../id456462/index.html">Merakit perpustakaan komponen sudut sebagai komponen web</a></li>
<li><a href="../id456466/index.html">PHP generik hari ini (yah, hampir)</a></li>
<li><a href="../id456470/index.html">Jebakan dari Penerbit Paket WSUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>