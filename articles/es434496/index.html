<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíº üïç üï† Compromiso en dos fases y el futuro de los sistemas distribuidos üöô üë©üèø‚Äçüè´ ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, simulamos y examinamos un protocolo de confirmaci√≥n de dos fases usando TLA +. 

 El protocolo de confirmaci√≥n de dos fases es pr√°ct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compromiso en dos fases y el futuro de los sistemas distribuidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434496/">  En este art√≠culo, simulamos y examinamos un protocolo de confirmaci√≥n de dos fases usando TLA +. <br><br>  El protocolo de confirmaci√≥n de dos fases es pr√°ctico y se usa hoy en muchos sistemas distribuidos.  Sin embargo, es bastante corto.  Por lo tanto, podemos modelarlo r√°pidamente y aprender mucho.  De hecho, con este ejemplo ilustraremos qu√© resultado en sistemas distribuidos es <i>fundamentalmente imposible</i> . <br><br><h3>  El problema de compromiso bif√°sico </h3><br>  La transacci√≥n pasa a trav√©s de <b>los administradores de recursos (RM)</b> .  Todos los RM deben acordar si la transacci√≥n se <i>completar√°</i> o <i>cancelar√°</i> . <br><br>  Transaction Manager (TM) toma la decisi√≥n final: <b>comprometer</b> o <b>cancelar</b> .  La condici√≥n para el compromiso es la voluntad de comprometer todos los RM.  De lo contrario, la transacci√≥n deber√≠a cancelarse. <br><a name="habracut"></a><br><h3>  Algunas notas sobre modelado </h3><br>  Para simplificar, realizamos simulaciones en un modelo de memoria compartida, no en un sistema de mensajer√≠a.  Tambi√©n proporciona una validaci√≥n r√°pida del modelo.  Pero agregaremos no atomicidad a las acciones "leer desde el nodo vecino y actualizar el estado" para capturar un comportamiento interesante al enviar mensajes. <br><br>  RM solo puede leer el estado de TM y leer / actualizar su propio estado.  No puede leer el estado de otro administrador de recursos.  Un TM puede leer el estado de todos los nodos RM y leer / actualizar su propio estado. <br><br><h3>  Definiciones </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d93/803/abe/d93803abea49766a0fbd7bb1d168c2c1.png"><br><br>  Las l√≠neas 9-10 establecen el <code>rmState</code> inicial para que cada RM <code>working</code> y TM para <code>init</code> . <br><br>  El predicado <code>canCommit</code> es <code>true</code> si todos los RM est√°n "preparados" (listos para comprometerse).  Si RM existe en el estado final, el predicado <code>canAbort</code> vuelve <code>canAbort</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2a/8a9/11c/f2a8a911c47b672d4f95b1eb59d11e60.png"><br><br>  Modelado TM es simple.  El administrador de transacciones verifica la posibilidad de una confirmaci√≥n o cancelaci√≥n, y en consecuencia actualiza <code>tmState</code> . <br><br>  Existe la posibilidad de que TM no pueda hacer que <code>tmState</code> "inaccesible", pero solo si la constante <code>TMMAYFAIL</code> establece en <code>true</code> antes de validar el modelo.  En las etiquetas TLA + se determina el grado de atomicidad, es decir, su granularidad.  Mediante las etiquetas F1 y F2, indicamos que los operadores correspondientes se realizan de forma no at√≥mica (despu√©s de un tiempo indefinido) con respecto a los operadores anteriores. <br><br><h3>  Modelo RM </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/425/42e/e7a/42542ee7a105be00451a28460cafc502.png"><br><br>  El modelo RM tambi√©n es simple.  Dado que los estados "de trabajo" y "preparados" no son definitivos, RM elige de forma no determinista entre las acciones hasta que alcanza el estado final.  Un RM "en funcionamiento" puede entrar en un estado "interrumpido" o "preparado".  RM "preparado" espera un compromiso / cancelaci√≥n de TM - y act√∫a en consecuencia.  La siguiente figura muestra las posibles transiciones de estado para un RM.  Pero tenga en cuenta que tenemos varios RM, cada uno de los cuales pasa por sus estados a su propio ritmo sin conocer el estado de los otros RM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d9/b25/0bd/8d9b250bd8aeeba4807f08e1d52a2675.png"><br><br><h3>  Modelo de confirmaci√≥n en dos fases </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/4e6/b1c/62d4e6b1c2046535daddbeeba285c7ac.png"><br><br>  Necesitamos verificar la consistencia de nuestro compromiso de dos fases: para que no haya RM diferentes, uno de los cuales dice "compromiso" y el otro "aborto". <br><br>  El predicado <code>Completed</code> verifica que el protocolo no se cuelga para siempre: al final, cada RM alcanza el estado final de <code>committed</code> o <code>aborted</code> . <br><br>  Ahora estamos listos para probar el modelo de protocolo.  Inicialmente, configuramos <code>TMMAYFAIL=FALSE, RM=1..3</code> para iniciar el protocolo con tres RM y un TM, es decir, en una configuraci√≥n confiable.  Probar el modelo lleva 15 segundos y dice que no hay errores.  Tanto <code>Consistency</code> como <code>Completed</code> satisfechos con cualquier posible ejecuci√≥n de protocolo con cualquier alternancia de acciones de RM y acciones de TM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/c9e/ed0/c25c9eed093f51eb577cbbb97a4775b2.png"><br><br>  Ahora establezca <code>TMMAYFAIL=TRUE</code> y reinicie la verificaci√≥n.  El programa produce r√°pidamente el resultado opuesto, donde RM se atasc√≥ esperando una respuesta de un TM no disponible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/652/e12/7ec/652e127ec391fae452f651c27f2855db.png"><br><br>  Vemos que en el <code>State=4</code> transiciones RM2 se interrumpen, en el <code>State=7</code> transiciones RM3 se interrumpen, en el <code>State=8</code> TM pasa al estado "colgar" y cae al <code>State=9</code> .  En <code>State=10</code> sistema se congela porque RM1 permanece para siempre en un estado preparado, esperando la decisi√≥n de un TM ca√≠do. <br><br><h3>  Simulaci√≥n BTM </h3><br>  Para evitar congelaciones de transacciones, agregamos una TM de respaldo (BTM), que r√°pidamente toma el control si la TM principal no est√° disponible.  BTM usa la misma l√≥gica que TM para tomar decisiones.  Y por simplicidad, suponemos que el BTM nunca se bloquea. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/96f/842/43b96f8421fe04f10b8adbc573507c36.png"><br><br>  Cuando probamos el modelo con el proceso BTM agregado, recibimos un nuevo mensaje de error. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/369/151/826/369151826a6dbe641acb2ae81340b1ea.png"><br><br>  BTM no puede aceptar un compromiso porque nuestra condici√≥n original, <code>canCommit</code> establece que todos los <code>RMstates</code> deben estar "preparados" y no tiene en cuenta la condici√≥n de que algunos RM ya hayan recibido una decisi√≥n de compromiso del TM original antes de que TMB tome el control.  Es necesario reescribir las condiciones de <code>canCommit</code> teniendo en cuenta dicha situaci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/4cf/bd5/9ed4cfbd55de80c58a7068b246c2375b.png"><br><br>  √âxito!  Cuando probamos el modelo, logramos consistencia e integridad, ya que el BTM toma el control y completa la transacci√≥n si el TM cae.  <a href="">Aqu√≠ est√° el modelo 2PCwithBTM en TLA +</a> (BTM y la segunda l√≠nea de canCommit est√°n inicialmente sin comentarios) y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pdf correspondiente</a> . <br><br><h3>  ¬øQu√© pasa si RM tambi√©n falla? </h3><br>  Asumimos que RM es confiable.  Ahora cancele esta condici√≥n y vea c√≥mo se comporta el protocolo cuando falla RM.  Agregue el estado "inaccesible" al modelo de falla.  Para investigar el comportamiento y simular la p√©rdida intermitente de disponibilidad, permita que el RM de emergencia se recupere y contin√∫e trabajando leyendo su estado del registro.  Aqu√≠ hay otro diagrama de transici√≥n de estado RM con el estado "inaccesible" agregado y las transiciones marcadas en rojo.  Y a continuaci√≥n se muestra el modelo revisado para RM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/f05/b6c/ff1f05b6cd817bb0d4050de4e30f37b6.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/94d/91f/8da/94d91f8da2aa4674044a71330da06d4e.png"><br><br>  Tambi√©n es necesario refinar <code>canAbort</code> teniendo en cuenta el estado de indisponibilidad.  TM puede tomar la decisi√≥n de "colgar" si alguno de los servicios se encuentra en un estado interrumpido o inaccesible.  Si se omite esta condici√≥n, un RM ca√≠do y no restaurado interrumpir√° el progreso de la transacci√≥n.  Por supuesto, nuevamente, debe considerar el RM, que aprendi√≥ la decisi√≥n de completar la transacci√≥n de la fuente TM. <br><br><h3>  Verificaci√≥n del modelo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/973/f0f/bf7973f0fd5815dfec816ff93dc03f3c.png"><br><br>  Cuando probamos el modelo, ¬°hay un problema de inconsistencia!  ¬øC√≥mo pudo pasar esto?  Trazamos el rastro. <br><br>  Con <code>State=6</code> todos los RM est√°n en un estado preparado, TM tom√≥ la decisi√≥n de completar la transacci√≥n, RM1 vio esta decisi√≥n y cambi√≥ a la etiqueta RC, lo que significa que est√° listo para cambiar su estado a "completado".  (Recuerde RM1, esta arma disparar√° en el √∫ltimo acto).  Desafortunadamente, el TM cae en <code>State=7</code> , y RM2 deja de estar disponible en <code>State=8</code> .  En el noveno paso, el BTM de respaldo toma el control y lee el estado de los tres RM como "preparado, inaccesible, preparado", y decide cancelar la transacci√≥n en el d√©cimo paso.  ¬øRecuerdas RM1?  Decide completar la transacci√≥n porque recibi√≥ tal decisi√≥n del TM original y entra en estado <code>committed</code> en el paso 11.  En <code>State=13</code> RM3 cumple la decisi√≥n de abortar la transacci√≥n de BTM y entra en el estado <code>aborted</code> , y ahora hemos perdido la coherencia con RM1. <br><br>  En este caso, el BTM tom√≥ una decisi√≥n que violaba la <b>coherencia</b> .  Por otro lado, si hace que el BTM espere a que el RM deje el estado inaccesible, puede congelarse para siempre en caso de un accidente en el nodo, y esto violar√° la condici√≥n de <b>cumplimiento</b> (progreso). <br><br>  <a href="">Un archivo de modelo TLA + actualizado est√° disponible aqu√≠</a> , as√≠ como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">correspondiente pdf</a> . <br><br><h3>  Imposibilidad FLP </h3><br>  Entonces que paso?  Nos topamos con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teorema de Fisher, Lynch, Paterson (FLP)</a> sobre la imposibilidad de consenso en un sistema asincr√≥nico con fallas. <br><br>  En nuestro ejemplo, BTM no puede decidir correctamente si RM2 est√° en un estado fallido o no, y decide incorrectamente cancelar la transacci√≥n.  Si solo el TM original tomara la decisi√≥n, tal inexactitud en reconocer una falla no ser√≠a un problema.  RM obedecer√° cualquier decisi√≥n de TM, por lo que se mantendr√° la coherencia y el progreso. <br><br>  El problema es que tenemos dos objetos que toman decisiones: TM y BTM, observan el estado de RM en diferentes momentos y toman diferentes decisiones.  Tal asimetr√≠a de informaci√≥n es la ra√≠z de todo mal en los sistemas distribuidos. <br><br>  El problema no desaparece incluso con la expansi√≥n a una confirmaci√≥n trif√°sica.  <a href="">Aqu√≠ hay una confirmaci√≥n trif√°sica modelada en TLA +</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n pdf</a> ), y a continuaci√≥n se muestra un seguimiento de error que muestra que esta vez se ha violado el progreso (en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de Wikipedia sobre una confirmaci√≥n trif√°sica</a> , se describe una situaci√≥n cuando RM1 se congela despu√©s de recibir una decisi√≥n antes de la confirmaci√≥n, y la confirmaci√≥n RM2 y RM3 cometer, lo que viola la consistencia). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d3/6d8/06d/0d36d806d38003f3cd995bbefbc0802d.png"><br><br><h3>  Paxos est√° tratando de hacer del mundo un lugar mejor. </h3><br><img src="https://habrastorage.org/webt/q-/o_/wq/q-o_wq_jdl14y0ulz-nud8k4idw.jpeg"><br><br>  Pero no todo est√° perdido, la esperanza no ha muerto.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tenemos paxos</a> .  Act√∫a perfectamente dentro del marco del teorema de FLP.  La innovaci√≥n de Paxos es que <b>siempre</b> es <b>seguro</b> (incluso con detectores inexactos, ejecuci√≥n asincr√≥nica y fallas), y <b>finalmente completa la transacci√≥n</b> cuando el consenso se hace posible. <br><br>  Puede emular TM en un cl√∫ster con tres nodos Paxos, y esto resolver√° el problema de inconsistencia TM / BTM.  O, como Gray y Lampport mostraron en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo cient√≠fico sobre el consenso en la</a> confirmaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transacciones</a> , si RM usa el contenedor Paxos para almacenar sus decisiones simult√°neamente con la respuesta TM, esto elimina un paso adicional en el algoritmo de protocolo est√°ndar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434496/">https://habr.com/ru/post/es434496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434480/index.html">A√±o nuevo, artilugios, fuego</a></li>
<li><a href="../es434482/index.html">Otro a√±o de nuestro blog: resultados de 2018</a></li>
<li><a href="../es434486/index.html">Tarjetas de fidelidad. API de Google Pay para pases en ASP.NET</a></li>
<li><a href="../es434490/index.html">C√≥mo vimos el altavoz por corte por chorro de agua</a></li>
<li><a href="../es434494/index.html">Que leer Lista de ficci√≥n en ruso para 2017 y 2018</a></li>
<li><a href="../es434498/index.html">MVP and Dagger 2 - Esqueleto de la aplicaci√≥n de Android - Parte 1</a></li>
<li><a href="../es434500/index.html">Estafador llamado Jeanne o Watch Your Ears</a></li>
<li><a href="../es434502/index.html">C√≥mo los "arque√≥logos digitales" descubrieron una versi√≥n perdida de SimCity para NES y la restauraron</a></li>
<li><a href="../es434504/index.html">20 a√±os Fast Reports "El producto fue creado de una sola vez, simplemente alto ..."</a></li>
<li><a href="../es434506/index.html">Experiencia publicando una aplicaci√≥n de edici√≥n de video en Microsoft Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>