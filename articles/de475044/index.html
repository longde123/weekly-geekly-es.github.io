<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 👩 🎅🏾 Erstellen Sie Ihre eigenen Serverless basierend auf Fn 👩🏿‍✈️ 👵🏼 🔪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serverloses Computing ist einer der sichtbarsten Trends im Cloud Computing. Das Grundprinzip der Arbeit ist, dass die Infrastruktur nicht das Anliegen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie Ihre eigenen Serverless basierend auf Fn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/475044/"><p><img src="https://habrastorage.org/webt/q4/8m/gj/q48mgjqsr4hbppglzpibvajf8xw.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverloses Computing</a> ist einer der sichtbarsten Trends im Cloud Computing.  Das Grundprinzip der Arbeit ist, dass die Infrastruktur nicht das Anliegen von DevOps ist, sondern der Dienstleister.  Die Ressourcenskalierung passt sich automatisch der Auslastung an und weist eine hohe Änderungsrate auf. </p><br><p>  Ein weiteres gemeinsames Merkmal ist die Tendenz, Code zu minimieren und zu fokussieren. Daher wird serverloses Computing manchmal als "Funktion als Dienst" (FaaS) bezeichnet. </p><a name="habracut"></a><br><p>  In der Vergangenheit war Amazon der erste Cloud-Dienstleister, der FaaS mit AWS Lambda anbot, von dem der Name stammt.  Andere Cloud-Dienstleister bieten auch Analoga an: </p><br><ul><li>  Google Cloud-Funktionen </li><li>  Azure-Funktionen von Microsoft </li></ul><br><p>  Alle diese Unternehmen bieten serverloses Computing, automatische Skalierung und zahlen nur für tatsächlich genutzte Ressourcen. Gleichzeitig binden sie Kunden an ihr firmeneigenes Produkt.  Es gibt jedoch kostenlose Open Source-Alternativen für Serverless Computing.  Es ist erwähnenswert: </p><br><ul><li>  Die von IBM im Inkubator entwickelte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache OpenWhisk-Plattform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Cloud-Funktionen</a> als Teil des relativ umfangreichen Spring Framework-Ökosystems, das auch als Fassade von AWS Lambda, Azure Functions und OpenWhisk verwendet werden kann. </li><li>  Von Oracle unterstütztes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fn-Projekt</a> . </li></ul><br><p>  Alle sind völlig unabhängig von den Clouds, dh, sie werden in jeder Cloud installiert, einschließlich Ihrer eigenen, öffentlichen oder privaten, und natürlich in Exoscale. </p><br><h2 id="kak-proekt-fn-ustroen">  Wie das Fn-Projekt funktioniert </h2><br><p>  Fn basiert vollständig auf Docker und besteht aus zwei Hauptkomponenten: </p><br><ul><li>  CLI-Programm zur Verwaltung aller Aspekte der Fn-Infrastruktur und zur Interaktion mit dem Fn-Server </li><li>  Eigentlich ist der Fn-Server die übliche Anwendung, die in einem Container für Docker verpackt ist. </li></ul><br><p>  Die in Fn implementierten Funktionen werden auch in separaten Containern ausgeführt, sodass Sie viele Programmiersprachen unterstützen können, zum Beispiel ... Clojure! </p><br><p>  Argumente von Funktionen werden an die Standardeingabe (STDIN) übergeben, die Ergebnisse an die Standardausgabe (STDOUT).  Wenn die Argumente oder Rückgabewerte keine einfachen Werte sind (z. B. ein JSON-Objekt), können sie mithilfe der von Fn selbst bereitgestellten Abstraktionsschicht als Funktionsentwicklungskit (Function Development Kit, FDK) transformiert werden. </p><br><p>  Zur Vereinfachung stehen integrierte Vorlagen zur Verfügung, die die Bereitstellung von FaaS in einer umfangreichen Liste verschiedener Sprachen und ihrer Versionen (Go, verschiedene Versionen von Java, Python usw.) erleichtern. </p><br><p>  Das Erstellen von FaaS ist einfach, wenn Sie diesem Muster folgen: </p><br><ul><li>  Wir stellen die Funktion über die CLI Fn bereit: Auf der Grundlage der ausgewählten Vorlage wird eine Anwendungskonfigurationsdatei für Fn erstellt. </li><li> Wir rollen unsere eigene Funktion aus, wieder unter Verwendung der CLI Fn: Das Container-Image wird in einem bestimmten Repository abgelegt, woraufhin der Server über das Vorhandensein und die Platzierung dieses Images informiert wird. </li></ul><br><p><img src="https://habrastorage.org/webt/_0/ds/if/_0dsifqshganceaz5pks7ixl9gs.jpeg"><br>  <em>Funktionslieferprinzip in Fn</em> </p><br><h2 id="lokalnaya-ustanovka-i-testirovanie-besservernyh-funkciy">  Lokale Installation und Test von serverlosen Funktionen </h2><br><p>  Wir fahren mit der Installation von Fn auf dem lokalen Computer fort.  Docker wird zuerst installiert, wie von Fn gefordert.  Wir sollen auf Debian / Ubuntu sein: </p><br><pre><code class="plaintext hljs">$ sudo apt-get update $ sudo apt-get install docker.io</code> </pre> <br><p>  Nun, oder verwenden Sie den Paketmanager / Docker-Build, der Ihrem System entspricht.  Dann können Sie direkt zur Fn CLI-Installation gehen.  Zum Beispiel mit curl: </p><br><pre> <code class="plaintext hljs">$ curl -LSs https://raw.githubusercontent.com/fnproject/cli/master/install | sh</code> </pre> <br><p>  Wenn Sie OSX mit installiertem Homebrew ausführen, können Sie auch anders vorgehen: </p><br><pre> <code class="plaintext hljs">$ brew install fn ==&gt; Downloading https://homebrew.bintray.com/bottles/fn-0.5.8.high_sierra.bottle.tar.gz ==&gt; Downloading from https://akamai.bintray.com/b1/b1767fb00e2e69fd9da73427d0926b1d1d0003622f7ddc0dd3a899b2894781ff?__gda__=exp=1538038849~hmac=c702c9335e7785fcbacad1f29afa61244d02f2eebb ######################################################################## 100.0% ==&gt; Pouring fn-0.5.8.high_sierra.bottle.tar.gz /usr/local/Cellar/fn/0.5.8: 5 files, 16.7MB</code> </pre> <br><p>  Jetzt ist alles bereit für die erste Bereitstellung unserer Funktion über die CLI.  Der Einfachheit halber verwenden wir die integrierte Umgebung, um beispielsweise Node auszuführen: </p><br><pre> <code class="plaintext hljs">$ fn init --runtime node --trigger http hellonode Creating function at: /hellonode Function boilerplate generated. func.yaml created.</code> </pre> <br><p>  Ein neues <code>hellonode</code> Verzeichnis wird erstellt, um unsere Fn-Funktion mit einigen grundlegenden Konfigurationsdateien weiterzuentwickeln.  In dem neu erstellten Verzeichnis können Sie eine Anwendung erstellen, die den Standards der ausgewählten Sprache oder Laufzeit entspricht: </p><br><pre> <code class="plaintext hljs">#   node  : hellonode ├── func.js ├── func.yaml └── package.json #   Java11 : hellojava11 ├── func.yaml ├── pom.xml └── src ├── main │ └── java │ └── com │ └── example │ └── fn │ └── HelloFunction.java └── test └── java └── com └── example └── fn └── HelloFunctionTest.java</code> </pre> <br><p>  Fn erstellt die anfängliche Projektstruktur, erstellt eine <code>func.yaml</code> Datei mit den erforderlichen Einstellungen für Fn und installiert eine Vorlage für den Code in der von Ihnen ausgewählten Sprache. </p><br><p>  Im Falle der Node-Laufzeit bedeutet dies: </p><br><pre> <code class="plaintext hljs">$ cat hellonode/func.js const fdk=require('@fnproject/fdk'); fdk.handle(function(input){ let name = 'World'; if (input.name) { name = input.name; } return {'message': 'Hello ' + name} })</code> </pre> <br><p>  Jetzt werden wir unsere Funktion schnell vor Ort überprüfen, um zu sehen, wie alles funktioniert. </p><br><p>  Zuerst starten wir den Fn-Server.  Wie bereits erwähnt, ist der Fn-Server ein Docker-Container. Nach dem Start wird das Image aus der Docker-Registrierung abgerufen. </p><br><pre> <code class="plaintext hljs">$ fn start -d #      Unable to find image 'fnproject/fnserver:latest' locally latest: Pulling from fnproject/fnserver ff3a5c916c92: Pull complete 1a649ea86bca: Pull complete ce35f4d5f86a: Pull complete ... Status: Downloaded newer image for fnproject/fnserver:latest 668ce9ac0ed8d7cd59da49228bda62464e01bff2c0c60079542d24ac6070f8e5</code> </pre> <br><p>  Um unsere Funktion auszuführen, müssen Sie sie ausrollen.  Dies erfordert einen <code> </code> : In Fn müssen alle Anwendungen als Namespaces für verwandte Funktionen definiert werden. </p><br><p>  Fn CLI sucht im aktuellen Verzeichnis nach der Datei <code>func.yaml</code> , mit der die Funktion konfiguriert wird.  Also müssen Sie zuerst in unser <code>hellonode</code> Verzeichnis gehen. </p><br><pre> <code class="plaintext hljs">$ cd hellonode $ fn deploy --app fnexo --local #   ,   - fnexo. #  local      , #    Deploying hellonode to app: fnexo Bumped to version 0.0.2 Building image nfrankel/hellonode:0.0.3 . Updating function hellonode using image nfrankel/hellonode:0.0.3... Successfully created app: fnexo Successfully created function: hellonode with nfrankel/hellonode:0.0.3 Successfully created trigger: hellonode-trigger</code> </pre> <br><p>  Wie Sie der Ausgabe des Befehls entnehmen können, wird ein neues Container-Image für Docker erstellt, das unsere Funktion enthält.  Die Funktion kann jetzt aufgerufen werden, und wir haben zwei Möglichkeiten, dies zu tun: </p><br><ul><li>  Verwenden Sie den Befehl fn <code>invoke</code> </li><li>  direkt über <code>http</code> anrufen </li></ul><br><p>  Das Aufrufen von <code>invoke</code> über Fn emuliert einfach die HTTP-Arbeit für Tests, was für eine schnelle Überprüfung praktisch ist: </p><br><pre> <code class="plaintext hljs">$ fn invoke fnexo hellonode #   hellonode  fnexo {"message":"Hello World"}</code> </pre> <br><p>  Um die Funktion direkt aufzurufen, müssen Sie die vollständige URL kennen: </p><br><pre> <code class="plaintext hljs">$ curl http://localhost:8080/t/fnexo/hellonode-trigger {"message":"Hello World"}</code> </pre> <br><p>  Der Fn-Server stellt seine Funktionen über Port 8080 bereit, und es scheint, dass die URL der Funktion mit dem Schema <code>t/app/function</code> übereinstimmt, jedoch nicht vollständig.  Über HTTP wird die Funktion nicht direkt aufgerufen, sondern über den sogenannten Trigger, der den Funktionsaufruf nach seinem Namen „startet“.  Trigger werden im Projekt <code>`func.yml</code> definiert: </p><br><pre> <code class="plaintext hljs">schema_version: 20180708 name: hellonode version: 0.0.3 runtime: node entrypoint: node func.js format: json triggers: - name: hellonode-trigger type: http source: /hellonode-trigger # URL </code> </pre> <br><p>  Wir können den Namen des Triggers so ändern, dass er mit dem Namen der Funktion übereinstimmt. Dies vereinfacht alles: </p><br><pre> <code class="plaintext hljs">triggers: - name: hellonode-trigger type: http source: /hellonode #    </code> </pre> <br><p>  Dann starten wir die Auslieferung der Funktion erneut und rufen sie vom neuen Trigger aus auf: </p><br><pre> <code class="plaintext hljs">$ fn deploy --app fnexo hellonode --local $ curl http://localhost:8080/t/fnexo/hellonode {"message":"Hello World"}</code> </pre> <br><p>  Alles arbeitet!  Es ist Zeit, umfassende Experimente zu starten und unser FaaS auf dem Server zu veröffentlichen! </p><br><h2 id="ustanovka-servisov-besservernyh-funkciy-na-sobstvennoy-infrastrukture">  Serverlose Funktionsdienste auf Ihrer eigenen Infrastruktur installieren </h2><br><p>  Lassen Sie uns schnell eine virtuelle Maschine mithilfe der CLI-Exoskala installieren.  Wenn Sie es noch nicht eingerichtet haben, können Sie es mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseres Leitfadens schnell starten</a> .  Dies ist ein cooles Tool, mit dem Sie Ihre Produktivität weiter steigern können.  <strong>Vergessen Sie nicht, dass Sie eine Regel konfigurieren müssen, um Port 8080 in der Sicherheitsgruppe zu öffnen!</strong>  Die folgenden Befehle starten eine saubere virtuelle Maschine, die bereit ist, unsere Funktionen zu hosten: </p><br><pre> <code class="plaintext hljs">$ exo firewall create fn-securitygroup $ exo firewall add fn-securitygroup ssh --my-ip $ exo firewall add fn-securitygroup -p tcp -P 8080-8080 -c 0.0.0.0/0 $ exo vm create fn-server -s fn-securitygroup</code> </pre> <br><p>  Dann können Sie in die virtuelle Maschine ssh und den Remote-Fn-Server installieren: </p><br><pre> <code class="plaintext hljs">$ exo ssh fn-server The authenticity of host '185.19.30.175 (185.19.30.175)' can't be established. ECDSA key fingerprint is SHA256:uaCKRYeX4cvim+Gr8StdPvIQ7eQgPuOKdnj5WI3gI9Q. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '185.19.30.175' (ECDSA) to the list of known hosts. Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)</code> </pre> <br><p>  Installieren Sie dann Docker und den Fn-Server auf dieselbe Weise wie auf dem lokalen Computer. Starten Sie den Server: </p><br><pre> <code class="plaintext hljs">$ sudo apt-get update $ sudo apt-get install docker.io $ sudo systemctl start docker $ curl -LSs https://raw.githubusercontent.com/fnproject/cli/master/install | sh $ sudo fn start ... ______ / ____/___ / /_ / __ \ / __/ / / / / /_/ /_/ /_/ v0.3.643</code> </pre> <br><p>  Fn ist bereit für Features!  Für die gezielte Übertragung von Funktionen auf einen Remote-Server verwenden wir den Befehl <code>deploy</code> vom lokalen Computer, wobei das Flag <code>--local</code> wird. </p><br><p>  Außerdem müssen Sie in Fn den Speicherort des Fn-Servers und der Docker-Registrierung angeben.  Diese Parameter können über die Umgebungsvariablen <code>FN_API_URL</code> bzw. <code>FN_REGISTRY</code> wird jedoch eine bequemere Möglichkeit zum einfachen Verwalten der Erstellung und Verwaltung von Konfigurationen für die Bereitstellung angeboten. </p><br><p>  In Bezug auf Fn wird die Konfiguration für die Bereitstellung als <code>context</code> .  Der folgende Befehl erstellt den Kontext: </p><br><pre> <code class="plaintext hljs">$ fn create context exoscale --provider default --api-url http://185.19.30.175:8080 --registry nfrankel</code> </pre> <br><p>  Sie können die verfügbaren Kontexte folgendermaßen anzeigen: </p><br><pre> <code class="plaintext hljs">$ fn list contexts CURRENT NAME PROVIDER API URL REGISTRY default default http://localhost:8080/ exoscale default http://185.19.30.175:8080 nfrankel</code> </pre><br><p>  Und wechseln Sie zu dem gerade erstellten Kontext: </p><br><pre> <code class="plaintext hljs"> $ fn use context exoscale Now using context: exoscale</code> </pre> <br><p>  Ab diesem Zeitpunkt werden durch die Bereitstellung von Fn-Funktionen Docker-Bilder unter Verwendung des ausgewählten Kontos auf DockerHub (in meinem Fall <code>nfrankel</code> ) <code>nfrankel</code> und der Remote-Server (in diesem Beispiel <code>http://185.19.30.175:8080</code> ) über den Speicherort und die Version benachrichtigt Das letzte Bild mit Ihrer Funktion. </p><br><pre> <code class="plaintext hljs">$ fn deploy --app fnexo . #       hellonode Deploying function at: /. Deploying hellonode to app: fnexo Bumped to version 0.0.5 Building image nfrankel/hellonode:0.0.5 .</code> </pre> <br><p>  Endlich: </p><br><pre> <code class="plaintext hljs">$ curl http://185.19.30.175:8080/t/fnexo/hellonode {"message":"Hello World"}</code> </pre> <br><p><img src="https://habrastorage.org/webt/vl/8c/mt/vl8cmtjvwj7t9tazi7mlaaexoxi.jpeg"><br>  <em>Funktionslebenszyklus im Serverless Computing basierend auf Fn</em> </p><br><h2 id="preimuschestva-besservernyh-vychisleniy-na-svoih-moschnostyah">  Die Vorteile von Serverless Computing in seinen Einrichtungen </h2><br><p>  Serverless Computing ist eine praktische Lösung für die schnelle Implementierung unabhängiger Anwendungsteile, die mit komplexeren Anwendungen oder Mikrodiensten interagieren. </p><br><p>  Dies liegt häufig an den versteckten Kosten für die Bindung an den ausgewählten Lieferanten, die je nach Anwendungsfall und Volumen zu höheren Kosten und einer geringeren Flexibilität in der Zukunft führen können. </p><br><p>  In diesem Fall leiden auch Multi-Cloud- und Hybrid-Cloud-Architekturen, da Sie sich leicht in einer Situation befinden, in der Sie serverloses Computing einsetzen möchten. Aufgrund von Unternehmensrichtlinien ist dies jedoch möglicherweise nicht möglich. </p><br><p>  Fn ist recht einfach zu bedienen, es kann fast die gleiche FaaS-Schnittstelle mit geringen Kosten bieten.  Der Provider wird nicht mehr gebunden, sondern kann lokal oder in einem geeigneten Cloud-Lösungsanbieter Ihrer Wahl installiert werden.  Es besteht auch die Freiheit, eine Programmiersprache zu wählen. </p><br><p>  Im Artikel werden nur die Grundlagen von Fn vorgestellt. Das Erstellen einer eigenen Laufzeitumgebung ist jedoch recht einfach. Die allgemeine Architektur kann mithilfe des Fn-Lastenausgleichs oder durch Platzieren von Fn hinter einem Proxy zum Schutz erweitert werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475044/">https://habr.com/ru/post/de475044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475028/index.html">Bemerkungen zur Anwendung von ML im Geschäftsverkehr auf ŽijemeIT-Aktien</a></li>
<li><a href="../de475032/index.html">Gartner Hype Cycle 2019: Nachbesprechung</a></li>
<li><a href="../de475034/index.html">Grafik im Browser für Arduino und STM32</a></li>
<li><a href="../de475036/index.html">Cassandra-Migration zu Kubernetes: Funktionen und Lösungen</a></li>
<li><a href="../de475038/index.html">Der erste Satz "Angewandte Mathematik und Informatik" an der HSE in St. Petersburg: Wer sind sie und wie arbeiten sie mit ihnen?</a></li>
<li><a href="../de475046/index.html">Rechtfertigt der Zweck die Mittel? (!) Schwarz und Grau SEO</a></li>
<li><a href="../de475048/index.html">Intuitive Erklärung des Hypothesentests und p-Wert</a></li>
<li><a href="../de475050/index.html">ESport - spielen, engagieren</a></li>
<li><a href="../de475054/index.html">SAP auf Microsoft Azure Tour in Moskau</a></li>
<li><a href="../de475058/index.html">Die Stadt schläft ein, die Bewohner von Habrowsk wachen auf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>