<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💵 ⛸️ 👍🏻 体验200万次无头会议 🙆🏻 👇🏼 🧑🏿‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2018年6月4日发布在无浏览器的企业博客上。 

 我们很高兴地宣布，我们最近突破了200万个会话的界限！ 这些是数百万个生成的屏幕截图，打印的PDF和经过测试的网站。 我们已经完成了无头浏览器几乎可以想到的所有事情。 

 虽然很高兴达到这样的里程碑，但是在路上显然存在很多重叠和问题。 由于收到...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>体验200万次无头会议</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413547/">  <font color="gray">2018年6月4日发布在无浏览器的企业博客上。</font> <br><br> 我们很高兴地宣布，我们最近突破了<b>200万个会话</b>的界限！ 这些是<i>数百万个</i>生成的屏幕截图，打印的PDF和经过测试的网站。 我们已经完成了无头浏览器几乎可以想到的所有事情。 <br><br> 虽然很高兴达到这样的里程碑，但是在路上显然存在<i>很多</i>重叠和问题。 由于收到的大量流量，我想退后一步，并提出在生产中启动无头浏览器（和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">puppeteer</a> ）的一般建议。 <br><br> 这里有一些技巧。 <br><a name="habracut"></a><br><h1>  1.完全不要使用无头浏览器 </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/85f/438/cae85f438e0037a0f87f1ae6619cfc33.png"><br><br><h3> 无头的Chrome资源消耗 </h3><br> 绝对<i>不要以无头模式启动浏览器</i> 。 特别是在与您的应用程序相同的基础结构上（请参见上文）。 无头浏览器就像Rick and Morty的Misix先生一样，变幻莫测，繁琐繁衍。 浏览器几乎可以做的所有事情（内插和运行JavaScript除外）都可以使用简单的Linux工具完成。 如果您的目标是，Cheerio库和其他库提供了一个优雅的Node API，用于通过HTTP请求和抓取来检索数据。 <br><br> 例如，您可以选择一个页面（假设它是某种HTML），并使用以下简单命令将其抓取： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cheerio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'cheerio'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fetch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPrice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(url); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> res.test(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $ = cheerio.load(html); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $(<span class="hljs-string"><span class="hljs-string">'buy-now.price'</span></span>).text(); } getPrice(<span class="hljs-string"><span class="hljs-string">'https://my-cool-website.com/'</span></span>);</code> </pre> <br> 显然，该脚本并不涵盖所有使用情况，如果您阅读了本文，则很可能必须使用无头浏览器。 因此，让我们开始吧。 <br><br><h1>  2.不要不必要地启动无头浏览器 </h1><br> 我们遇到了许多用户，即使不使用浏览器（打开连接），它们仍试图保持浏览器运行。 尽管这可能是加快会话速度的好策略，但它会在几个小时后崩溃。 很大程度上是因为浏览器<i>喜欢</i>连续缓存所有内容并逐渐消耗内存。 一旦您停止大量使用浏览器，请立即将其关闭！ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> puppeteer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://www.example.com/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// More stuff ...page.click() page.type() browser.close(); // &lt;- Always do this! }</span></span></code> </pre> <br> 在无浏览器中，我们通常为用户自己解决此错误，始终为会话设置某种计时器，并在断开WebSocket的连接时关闭浏览器。 但是，如果您不使用我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker备份映像</a> ，请确保确保<i>自动</i>关闭浏览器，因为当一切在深夜降临时，浏览器会令人不快。 <br><br><h1>  3.您的朋友<code>page.evaluate</code> </h1><br><blockquote> 请注意诸如babel或typescript之类的编译器，因为它们喜欢创建帮助器函数并假定可以使用闭包对其进行访问。 也就是说，.evaluate回调<i>可能无法</i>正常工作。 </blockquote><br>  Puppeteer有许多不错的方法，例如在Node环境中存储DOM选择器和其他东西。 尽管非常方便，但是如果页面上的某些内容迫使此DOM节点发生<i>突变</i> ，您可以轻松地将自己<i>击倒</i> 。 这可能不是很酷，但实际上最好在浏览器<i>的上下文中在浏览</i>器端完成所有工作。 通常，这意味着需要加载<code>page.evaulate</code>来完成所有需要完成的工作。 <br><br> 例如，代替这样的事情（ <i>三个</i>异步操作）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $anchor = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.$(<span class="hljs-string"><span class="hljs-string">'a.buy-now'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> link = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> $anchor.getProperty(<span class="hljs-string"><span class="hljs-string">'href'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> $anchor.click(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> link;</code> </pre> <br> 最好这样做（一个异步操作）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.evaluate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'a.buy-now'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = $anchor.href; $anchor.click(); });</code> </pre> <br> 将动作包装到<code>evaluate</code>调用中的另一个优点是可移植性：可以在浏览器中运行该代码以进行验证，而不必尝试重写Node代码。 当然，始终建议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用调试器</a>以减少开发时间。 <br><br> 一个简单的经验法则是计算<code>await</code>次数， <code>then</code>计算代码中的<code>await</code>次数。 如果不止一个，那么最好在<code>page.evaluate</code>调用中运行代码。 原因是所有异步操作都在Node运行时和浏览器之间来回移动，这意味着常量JSON序列化和反序列化。 尽管没有那么多的解析（因为所有内容都由WebSockets支持），但它仍然占用时间，最好将其用于其他方面。 <br><br><h1>  4.并行化浏览器，而不是网页 </h1><br> 因此，我们意识到启动浏览器并不好，我们仅在紧急情况下才需要这样做。 下一个技巧是每个浏览器仅运行一个会话。 尽管实际上可以通过并行处理<code>pages</code>来节省资源，但是如果一页掉下来，可能会使整个浏览器崩溃。 另外，不能保证每个页面都非常干净（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如我们所见</a> ，Cookie和存储可能会令人头疼）。 <br><br> 相反： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> puppeteer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Launch one browser and capture the promise const launch = puppeteer.launch(); const runJob = async (url) { // Re-use the browser here const browser = await launch; const page = await browser.newPage(); await page.goto(url); const title = await page.title(); browser.close(); return title; };</span></span></code> </pre> <br> 最好这样做： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> puppeteer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> runJob = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (url) { <span class="hljs-comment"><span class="hljs-comment">// Launch a clean browser for every "job" const browser = puppeteer.launch(); const page = await browser.newPage(); await page.goto(url); const title = await page.title(); browser.close(); return title; };</span></span></code> </pre> <br> 每个新的浏览器实例都会获得一个干净的<code>--user-data-dir</code> （ <a href="">除非另有说明</a> ）。 也就是说，它被完全处理为新的会话。 如果Chrome由于某种原因崩溃，它将不会拉动其他会话。 <br><br><h1>  5.队列和并发限制 </h1><br> 无浏览器的主要功能之一是能够巧妙地限制并行化和排队。 因此，客户端应用程序只运行<code>puppeteer.connect</code> ，但他们不考虑队列实现。 这样可以避免大量问题，主要是与Chrome并发实例吞噬了应用程序的所有可用资源有关。 <br><br> 最好和最简单的方法是获取Docker映像并使用必要的参数运行它： <br><br><pre> <code class="hljs pgsql"># Pull <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Puppeteer@<span class="hljs-number"><span class="hljs-number">1.4</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> support $ docker pull browserless/chrome:<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-puppeteer<span class="hljs-number"><span class="hljs-number">-1.4</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> $ docker run -e "MAX_CONCURRENT_SESSIONS=10" browserless/chrome:<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-puppeteer<span class="hljs-number"><span class="hljs-number">-1.4</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br> 这将并发请求的数量限制为十个（包括调试会话等）。 该队列由变量<code>MAX_QUEUE_LENGTH</code>配置。 通常，您每GB内存可以执行大约10个并发请求。  CPU利用率的百分比因不同的任务而异，但是基本上您将需要大量的RAM。 <br><br><h1>  6.不要忘了<code>page.waitForNavigation</code> </h1><br> 我们遇到的最常见的问题之一是开始加载页面并随后突然终止脚本的操作。 这是因为触发<code>pageload</code>的动作通常会导致吞噬后续工作。 要解决该问题，通常需要调用页面加载操作-等待页面加载后立即执行。 <br><br> 例如，这样的<code>console.log</code>不能在一个地方工作（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://chrome.browserless.io/%3Fscript%3Dawait%2520page.goto(%2527">请参阅demo</a> ）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.click(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.title(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(title);</code> </pre> <br> 但是它<i>可以</i>在另一个环境中工作（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://chrome.browserless.io/%3Fscript%3Dawait%2520page.goto(%2527">请参阅演示</a> ）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); page.click(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.waitForNavigation(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.title(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(title);</code> </pre> <br> 您可以<a href="">在此处</a>阅读有关waitForNavigation的更多信息。 此函数具有与<code>page.goto</code>大致相同的接口参数，但仅具有“ wait”部分。 <br><br><h1>  7.使用Docker来满足您的所有需求。 </h1><br>  Chrome需要大量依赖项才能正常运行。 真的很多 即使在安装完所有内容后，您也需要担心字体和幻像处理之类的问题。 因此，理想的是使用某种容器将所有内容放入其中。  Docker几乎是专门为此任务设计的，因为您可以限制可用资源的数量并将其隔离。 如果要创建自己的<code>Dockerfile</code> ，请检查以下所有必需的依赖项： <br><br><pre> <code class="hljs tex"># Dependencies needed for packages downstream RUN apt-get update &amp;&amp; apt-get install -y <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>unzip <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fontconfig <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>locales <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>gconf-service <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libasound2 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libatk1.0-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libc6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libcairo2 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libcups2 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libdbus-1-3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libexpat1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libfontconfig1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libgcc1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libgconf-2-4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libgdk-pixbuf2.0-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libglib2.0-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libgtk-3-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libnspr4 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libpango-1.0-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libpangocairo-1.0-0 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libstdc++6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libx11-6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libx11-xcb1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxcb1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxcomposite1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxcursor1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxdamage1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxext6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxfixes3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxi6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxrandr2 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxrender1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxss1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libxtst6 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ca-certificates <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fonts-liberation <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libappindicator1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>libnss3 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>lsb-release <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>xdg-utils <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>wget</code> </pre> <br> 并且为了避免僵尸进程（在Chrome中很常见），最好使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dumb-init之</a>类的东西来正确运行： <br><br><pre> <code class="hljs powershell">ADD https://github.com/Yelp/dumb<span class="hljs-literal"><span class="hljs-literal">-init</span></span>/releases/download/v1.<span class="hljs-number"><span class="hljs-number">2.0</span></span>/dumb<span class="hljs-literal"><span class="hljs-literal">-init_1</span></span>.<span class="hljs-number"><span class="hljs-number">2.0</span></span>_amd64 /usr/local/bin/dumb<span class="hljs-literal"><span class="hljs-literal">-init</span></span> RUN chmod +x /usr/local/bin/dumb<span class="hljs-literal"><span class="hljs-literal">-init</span></span></code> </pre> <br> 如果您想了解更多信息，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们的Dockerfile</a> 。 <br><br><h1>  8.记住两个不同的运行时。 </h1><br> 请记住，有<i>两个</i> JavaScript运行时（节点和浏览器），这很有用。 这对于分离任务非常有用，但是不可避免地会造成混乱，因为某些方法将需要显式的链接传递而不是吊装。 <br><br> 例如，使用<code>page.evaluate</code> 。 在协议的最深处，是<a href="">对该函数</a>的<a href=""><i>字面意义进行</i>字符串化，并将其转移到Chrome</a> 。 因此，诸如关闭和升降机之类的东西<i>根本无法工作</i> 。 如果需要将一些引用或值传递给评估调用，只需将它们添加为将被正确处理的参数即可。 <br><br> 因此，不是通过闭包引用<code>selector</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// `selector` here is `undefined` since we're in the browser context const clicked = await page.evaluate(() =&gt; document.querySelector(anchor).click());</span></span></code> </pre> <br> 更好的传递参数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Here we add a `selector` arg and pass in the reference in `evaluate` const clicked = await page.evaluate((selector) =&gt; document.querySelector(selector).click(), anchor);</span></span></code> </pre> <br>  <code>page.evaluate</code>可以在<code>page.evaluate</code>函数中添加一个或多个参数，因为它在此处是可变的。 一定要利用这一点！ <br><br><h1> 未来 </h1><br> 我们对无头浏览器的未来以及它们可以实现的所有自动化都非常乐观。 我们希望通过使用puppeteer和无浏览器之类的强大工具，可以更轻松，更快地调试和运行生产中的无头自动化。 不久，我们将为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帐户</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a>启动<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">即付即用计费</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a> ，这将帮助您更好地应对无聊的工作！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413547/">https://habr.com/ru/post/zh-CN413547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413529/index.html">为什么新的i-SENSYS设备可以被称为革命性的</a></li>
<li><a href="../zh-CN413531/index.html">本书“为开发人员提供统一性。 移动多平台游戏»</a></li>
<li><a href="../zh-CN413539/index.html">一个基于模糊逻辑的简单控制器。 创建和定制</a></li>
<li><a href="../zh-CN413543/index.html">Angular CLI 6：为什么需要它以及如何使用它</a></li>
<li><a href="../zh-CN413545/index.html">幽默的品牌-为什么并不总是那么好</a></li>
<li><a href="../zh-CN413549/index.html">网络开发讲座</a></li>
<li><a href="../zh-CN413551/index.html">滚动和注意力（2018年研究）</a></li>
<li><a href="../zh-CN413553/index.html">注册商REG.RU剥夺了合作伙伴对7万个域名的访问权，并为自己提供了服务</a></li>
<li><a href="../zh-CN413555/index.html">分布式系统中的安全互操作性</a></li>
<li><a href="../zh-CN413557/index.html">NewSQL：SQL到处都行不通</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>