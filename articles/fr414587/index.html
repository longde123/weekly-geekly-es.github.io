<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬛️ 👨‍🔧 👩🏻‍🤝‍👨🏿 Drone autonome bricolage avec contrôle sur Internet. Partie 2 sur les logiciels 🤟🏿 🔒 ⏸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'une continuation de l'histoire d'un drone autonome. La première partie a parlé de matériel, celle-ci parlera de logiciel. Pour commencer, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Drone autonome bricolage avec contrôle sur Internet. Partie 2 sur les logiciels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414587/">  Il s'agit d'une continuation de l'histoire d'un drone autonome.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie a</a> parlé de matériel, celle-ci parlera de logiciel.  Pour commencer, un petit programme pédagogique sur l'interaction de l'opérateur avec l'hélicoptère.  Voici une disposition typique pour la plupart des drones auto-assemblés: <br><br><img src="https://habrastorage.org/webt/f6/jn/na/f6jnnadl96jkvjtcngwxhxogkcu.png" alt="image"><br><br>  Et voici le schéma des drones avancés: <br><br><img src="https://habrastorage.org/webt/gz/5t/bg/gz5tbg7qqv82_5t86usnrsyhgsg.png" alt="image"><br><a name="habracut"></a><br>  Voici comment fonctionnent les drones jouets, qui sont contrôlés depuis un smartphone: <br><br><img src="https://habrastorage.org/webt/zr/tu/7r/zrtu7r2febul6zxzy2uzrkpf8rq.png" alt="image"><br><br>  Vous pouvez contrôler le drone via Internet (si vous avez une carte SIM avec une adresse IP statique): <br><br><img src="https://habrastorage.org/webt/ae/d1/yk/aed1yk46dzosxybjpglxk6bwu5i.png" alt="image"><br><br>  Ou alors si l'adresse IP est dynamique: <br><br><img src="https://habrastorage.org/webt/v2/x_/jo/v2x_jo1dtumefo_wekedrufda0o.png" alt="image"><br><br>  Pour la fiabilité et la redondance des canaux de communication, cette dernière option peut être développée dans un tel état: <br><br><img src="https://habrastorage.org/webt/x6/yz/ho/x6yzhoievpeggh8ya7jo8cmxvo4.png" alt="image"><br><br>  Ensuite, je décrirai le processus de configuration du contrôleur de vol Emlid Navio 2 et du micro-ordinateur Raspberry Pi 3. <br><br><img src="https://habrastorage.org/webt/7g/lr/cv/7glrcvssoyxvii2swoekbsrkuf8.jpeg" alt="image"><br>  Mais, avec des modifications mineures, ces paramètres conviennent à tout contrôleur de vol, avec lequel vous pouvez communiquer via le protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAVLink</a> en conjonction avec n'importe quel ordinateur sur une famille de systèmes d'exploitation Linux. <br><br><img src="https://habrastorage.org/webt/bq/6c/my/bq6cmyprlzet6b8w4kemu_nn_ao.png" alt="image"><br><br>  <b><u>Important!</u></b>  <b><u>Le réglage doit être effectué hors tension sur les régulateurs de vitesse afin que les moteurs ne démarrent pas accidentellement.</u></b> <br><br><h3>  Logiciel de contrôle des drones pour PC et tablettes </h3><br>  Pour contrôler l'UAV, des programmes spéciaux GCS (Ground Control Station) sont utilisés.  Plus loin dans le texte, j'utiliserai cette abréviation.  J'ai aimé le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QGroundControl</a> , un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GCS</a> multi-plateforme open source (Windows, Linux, MacOS, iOS, Android) qui est devenu une partie du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DroneCode</a> .  Mais il existe des alternatives, gratuites et commerciales: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">APM Planner</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MissionPlanner</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UgCS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LibrePilot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenPilot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tower</a> (DroidPlanner) pour Android, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAVPilot</a> (iOS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SidePilot</a> (iOS).  Ainsi que la console <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAVProxy</a> . <br><br><h3>  Installer une image de système d'exploitation sur une carte SD </h3><br>  Pour un fonctionnement normal du pilote automatique, il est fortement recommandé d'utiliser des cartes SD «rapides» (classe 10).  Les cartes mémoire lentes n'ont pas le temps de sauvegarder les journaux du pilote automatique même à basse fréquence, ce qui fait qu'elles s'avèrent tordues ou pas écrites du tout.  La preuve de cela peut être une erreur « <i>Pas de battement de cœur IO</i> », qui peut être observée dans la console MAVLink (comment regarder la console MAVLink est décrite ci-dessous).  Lors de l'achat, regardez la possibilité d'écrire des vidéos 4K: ce sera très probablement une SD rapide.  Malheureusement, je l'ai découvert après la chute du drone, alors qu'il était nécessaire d'analyser les journaux et d'en découvrir la raison.  Les journaux étaient illisibles pour plusieurs GCS.  La raison de l'arrêt des moteurs pendant le vol s'est avérée être banale: j'ai oublié de régler la tension minimale sur la batterie dans les paramètres de fonctionnement à sécurité intégrée. <br><br>  Alors, téléchargez l'image Raspbian Stretch terminée avec Ardupilot et ROS pré-installés d'Emlid à partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page d'instructions d'origine</a> .  Et nous l'écrivons sur une carte mémoire en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Etcher</a> ou tout autre programme similaire. <br><br>  Afin de connecter Raspberry à votre réseau WiFi immédiatement après la mise sous tension, vous devez modifier le fichier <i>wpa_supplicant.conf</i> à la racine de la carte SD.  Il doit contenir les lignes suivantes: <br><br><pre><code class="bash hljs">network={ ssid=<span class="hljs-string"><span class="hljs-string">"_wifi_"</span></span> psk=<span class="hljs-string"><span class="hljs-string">"_wifi_"</span></span> }</code> </pre> <br>  Vous pouvez également le configurer sans WiFi en connectant un ordinateur à une seule plaque au routeur avec un câble Ethernet.  Retirez maintenant la carte SD du PC, insérez-la dans le Raspberry et allumez-la.  Après une demi-minute, il devrait apparaître dans le panneau d'administration du routeur sur la page des appareils connectés ( <i>nom d'hôte</i> navio). <br><br><h3>  Mise à jour du kit de distribution et installation des packages nécessaires </h3><br>  Ouvrez le client SSH et connectez-vous à Raspberry (adresse IP navio locale au lieu de <i>RASPBERRY_IP_ADDRESS</i> ): <br><br><pre> <code class="bash hljs">ssh pi@RASPBERRY_IP_ADDRESS</code> </pre> <br>  Mot de passe standard: <i>framboise</i> .  Tout d'abord, il est nécessaire d'étendre le système de fichiers de l'OS à l'ensemble du volume de la carte SD: <br><br><pre> <code class="bash hljs">sudo raspi-config --expand-rootfs</code> </pre> <br>  et redémarrez: <br><br><pre> <code class="bash hljs">sudo reboot</code> </pre> <br>  Après le redémarrage, connectez-vous à nouveau et mettez à jour la distribution: <br><br><pre> <code class="bash hljs">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y</code> </pre> <br>  Installez des packages supplémentaires: <br><br><pre> <code class="bash hljs">sudo apt-get install autoconf automake libtool pkg-config libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libraspberrypi-dev gstreamer1.0-tools gstreamer1.0-plugins-good gstreamer1.0-plugins-bad</code> </pre> <br>  et compilez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wrapper gst-rpicamsrc</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gstreamer</a> et la caméra native Raspicam: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/thaytan/gst-rpicamsrc.git rpicamsrc <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rpicamsrc chmod +x autogen.sh ./autogen.sh --prefix=/usr --libdir=/usr/lib/arm-linux-gnueabihf/ make sudo make install</code> </pre> <br>  Vérifiez si la caméra fonctionne (le fichier vidéo test.h264 est créé): <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc bitrate=1000000 ! filesink location=test.h264</code> </pre> <br>  Si gstreamer démarre, attendez quelques secondes que la vidéo soit enregistrée.  Vous pouvez interrompre le processus en appuyant sur <i>Ctrl + C.</i>  S'il y a de la vidéo, alors la caméra fonctionne. <br><br><h3>  Configurer et lancer Ardupilot </h3><br>  Les sorties de nouvelles versions d'Ardupilot sont un peu en retard dans l'assemblage d'Emlid.  Si la fonctionnalité nécessaire est disponible dans la dernière version, vous pouvez l'installer à partir de la source à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aide de cette instruction</a> . <br><br>  Les développeurs de Navio ont ajouté un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilitaire d'outil Emlid</a> simple et pratique à leurs capteurs pour vérifier les capteurs et configurer Ardupilot.  Tout d'abord, vérifiez si le Raspberry voit le contrôleur Navio: <br><br><pre> <code class="bash hljs">emlidtool info</code> </pre> <br>  Si en réponse à cette commande produit quelque chose comme: <br><br><pre> <code class="bash hljs">Vendor: Emlid Limited Product: Navio 2 Issue: Emlid 2018-06-05 831f3b08594f2da17dccae980a2e3659115ef71f Kernel: 4.14.34-emlid-v7+ RCIO firmware: 0xcaec2284</code> </pre> <br>  cela signifie qu'il voit.  Vérifiez l'état des capteurs (affichez la liste et l'état): <br><br><pre> <code class="bash hljs">emlidtool <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  et pilotes de contrôleur PWM dans le noyau Linux: <br><br><pre> <code class="bash hljs">cat /sys/kernel/rcio/status/alive</code> </pre> <br>  0 = ne fonctionne pas, 1 = fonctionne. <br><br>  Le micrologiciel du contrôleur PWM est mis à jour comme suit: <br><br><pre> <code class="bash hljs">sudo emlidtool rcio update</code> </pre> <br>  Configurez maintenant Ardupilot: <br><br><pre> <code class="bash hljs">sudo emlidtool ardupilot</code> </pre> <br>  Une interface graphique texte avec des menus pas à pas s'ouvrira dans le terminal.  Nous sélectionnons l'hélicoptère de la dernière version, type <i>arducopter</i> , démarrage automatique au démarrage ( <i>Au démarrage: activer</i> ), démarrer après la configuration ( <i>Ardupilot: démarrer</i> ). <br><br><img src="https://habrastorage.org/webt/w8/p7/yn/w8p7ynlxvrqybsaqrdkqxbk68yy.png" alt="image"><br><br>  Nous quittons via l'élément de menu <i>Quitter</i> . <br><br>  Vérifiez si Ardupilot a démarré: <br><br><pre> <code class="bash hljs">sudo systemctl status arducopter</code> </pre> <br>  Veuillez noter que le fichier de démarrage dans systemd s'appelle <u>arducopter</u> , car l'option <i>copter a</i> été configurée. <br><br>  Nous devons maintenant configurer l'Ardupilot pour qu'il nous envoie de la télémétrie.  Pour ce faire, modifiez le fichier de configuration: <br><br><pre> <code class="bash hljs">sudo nano /etc/default/arducopter</code> </pre> <br>  Il doit contenir les lignes suivantes: <br><br><pre> <code class="bash hljs">TELEM1=<span class="hljs-string"><span class="hljs-string">"-A udp:127.0.0.1:14550"</span></span> ARDUPILOT_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TELEM1</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Enregistrez le fichier ( <i>Ctrl + X</i> , puis <i>Y</i> ) et redémarrez Ardupilot: <br><br><pre> <code class="bash hljs">sudo systemctl daemon-reload sudo systemctl restart arducopter</code> </pre> <br>  Vous pouvez vérifier l'état du processus Ardupilot avec la commande suivante: <br><br><pre> <code class="bash hljs">sudo systemctl status arducopter</code> </pre> <br>  Avec ces paramètres, Ardupilot transmettra la télémétrie (paquets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAVLink</a> ) au port UDP local 14550. Ensuite, le script <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MAVProxy</a> (description ci-dessous) prendra la télémétrie à partir de là et l'enverra à GCS ou au script, ainsi que des paquets avec des commandes dans la direction opposée. <br><br>  Au lieu de l'adresse et du port locaux, vous pouvez enregistrer l'adresse IP d'un PC ou d'une tablette sur le réseau local et les paquets y seront immédiatement diffusés. <br><br><img src="https://habrastorage.org/webt/8p/no/vv/8pnovvpynimp8tvucgtqnbvqhls.png" alt="image"><br><br>  Cependant, cette approche est justifiée si les données de télémétrie ne sont utilisées nulle part ailleurs et que le périphérique avec GCS a une adresse IP statique.  Sinon, chaque fois que vous devez enregistrer un nouvel Ardupilot dans les paramètres.  Pour communiquer avec le pilote automatique via TCP, plusieurs GCS avec des adresses dynamiques et certains autres scripts sur l'ordinateur de bord pourraient simultanément, il est plus pratique d'utiliser MAVProxy. <br><br><img src="https://habrastorage.org/webt/lt/gu/o6/ltguo6ghxcrnv8syshno6arbwi8.png" alt="image"><br><br>  Ce script (écrit en Python) peut recevoir des paquets MAVLink vers une adresse UDP locale et les relayer vers plusieurs adresses IP locales ou distantes, à la fois via UDP et TCP.  Les paquets sont envoyés dans les deux directions à l'Ardupilot® GCS.  De plus, MAVProxy est un GCS à part entière, mais avec une interface texte. <br><br><h3>  MAVProxy </h3><br>  MAVProxy est déjà installé dans l'image Navio.  Il peut également être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installé</a> sur un PC (Windows, Linux, MacOS) pour une communication ultérieure avec le pilote automatique en mode console. <br><br>  Après vous être assuré que Ardupilot fonctionne, exécutez le script MAVProxy sur Raspberry avec cette commande: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550</code> </pre> <br>  Le <i>paramètre --master = udp: 127.0.0.1: 14550</i> définit la source de données du script.  Il s'agit du port UDP local qui a été enregistré dans le fichier de configuration Ardupilot.  Après avoir exécuté la commande, MAVProxy se connectera à ce port et affichera les messages du pilote automatique, comme le mien: <br><br><pre> <code class="bash hljs">pi@navio:~ $ mavproxy.py --master=udp:127.0.0.1:14550 Connect udp:127.0.0.1:14550 source_system=255 Failed to load module: No module named adsb. Use <span class="hljs-string"><span class="hljs-string">'set moddebug 3'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the MAVProxy console to <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> traceback Log Directory: Telemetry <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>: mav.tlog Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> heartbeat from 127.0.0.1:14550 MAV&gt; online system 1 STABILIZE&gt; Mode STABILIZE fence breach GPS lock at 0 meters APM: APM:Copter V3.5.5 (88a1ecdd) APM: Frame: UNKNOWN APM: PreArm: RC Roll not configured APM: PreArm: Compass not calibrated APM: PreArm: 3D Accel calibration needed APM: PreArm: check firmware or FRAME_CLASS APM: PreArm: Throttle below Failsafe</code> </pre> <br>  Étant donné que le pilote automatique n'a pas encore été calibré et n'est pas entièrement réglé, les messages en parlent également avec éloquence.  Dans ce mode, vous pouvez communiquer avec le pilote automatique via des commandes.  Si le drone était entièrement réglé, une telle séquence de deux commandes conduirait au démarrage des moteurs et au drone de décoller à une hauteur de 20 m: <br><br><pre> <code class="bash hljs">arm throttle takeoff 20</code> </pre> <br>  Un pilote automatique non calibré ne volera pas, mais affichera des messages avec les raisons pour lesquelles il ne peut pas le faire. <br><br><h3>  Etablir la communication avec le drone sur le réseau local </h3><br>  Arrêtez le script ( <i>Ctrl + C</i> ) et exécutez-le à nouveau sous cette forme: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550 --out=tcpin:0.0.0.0:5762</code> </pre> <br>  Avec le paramètre supplémentaire <i>--out = tcpin: 0.0.0.0: 5762,</i> MAVProxy écoutera sur le port 5762 les connexions TCP entrantes de GCS.  Dès que le GCS se connecte, les paquets de données commenceront à se déplacer entre le drone et le GCS.  Essayons de nous connecter depuis un PC: <br><br><img src="https://habrastorage.org/webt/8e/zz/eb/8ezzebgztbjr6nkllbyefkdots0.png" alt="image"><br><br>  Si la connexion est réussie, GCS affichera un tas de messages avec une demande de calibrer les capteurs et charger les paramètres embarqués avec leurs valeurs actuelles: <br><br><img src="https://habrastorage.org/webt/mz/gy/co/mzgycobpds-e3bk7i5szgplvvey.png" alt="image"><br><br><img src="https://habrastorage.org/webt/i1/bx/ms/i1bxms-du1v9tbqpemtfv-sgodw.png" alt="image"><br><br><h3>  Calibration des capteurs et réglage des paramètres du pilote automatique </h3><br>  L'étalonnage du pilote automatique peut être effectué dans presque tous les GCS.  La documentation Ardupilot le décrit en détail.  Tout d'abord, nous définissons le type de cadre.  J'ai une configuration standard à 4 moteurs, c'est donc le <i>Quad X.</i> <br><br><img src="https://habrastorage.org/webt/mv/gc/bi/mvgcbi8augohhzhrcfrnosuia-s.png" alt="image"><br><br>  Le premier vol est encore mieux fait en mode manuel.  Nous connectons et calibrons la radiocommande (récepteur et émetteur). <br><br><img src="https://habrastorage.org/webt/dj/ay/xw/djayxw3ulzuaabk4ubn3qavp0d4.png" alt="image"><br><br>  Reste à calibrer l'accéléromètre et la boussole. <br><br><img src="https://habrastorage.org/webt/bm/rs/1r/bmrs1rhiwgxu2udg11td3t8slak.png" alt="image"><br><br>  Pour qu'Ardupilot puisse voir et prendre en compte les données des capteurs externes, définissez les paramètres nécessaires: <br><br>  Pour <u>PX4Flow</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étalonnage du capteur lui-même et mise à jour du firmware</a> ) <br><br> <code>FLOW_ENABLE = 1 (Enabled) <br> FLOW_ADDR = 0 (0 =     042)</code> <br> <br>  Pour altimètre laser <u>VL53L0X</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> ) <br><br> <code>RNGFND_TYPE = 16 (VL53L0X) <br> RNGFND_ORIENT = 25 (  ) <br> RNGFND_ADDR = 41 (I2C-   ).   - 0x29,     = 41. <br> RNGFND_SCALING = 1 <br> RNGFND_MIN_CM = 5 <br> RNGFND_MAX_CM = 120 <br> RNGFND_GNDCLEAR = 15 (    ,     )</code> <br> <br>  Pour <u>IRLock</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions détaillées</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki IR-Lock</a> ) <br><br> <code>PLND_ENABLED = 1 <br> PLND_TYPE = 2 <br> PLND_BUS = 1</code> <br> <br>  Pour sonar vue de face ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> ) <br><br> <code>RNGFND2_TYPE = 2 (MaxbotixI2C sonar) <br> RNGFND2_ORIENT = 0 (  ) <br> RNGFND2_MAX_CM = 700 (   )</code> <br> <br>  Liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complète des options d'</a> Ardupilot. <br><br>  Redémarrez maintenant Ardupilot à partir du menu GCS, reconnectez-vous à la carte et ouvrez la fenêtre MAVLink Inspector pour voir les données des capteurs. <br><br><img src="https://habrastorage.org/webt/6z/x_/8z/6zx_8zmfbc4nflyaxyz-h2yv8zs.png" alt="image"><br><br>  Malheureusement, les lectures d'IR-Lock ne sont pas visibles ici, pour l'analyse de son travail, vous devrez consulter les journaux de bord.  La procédure à suivre est décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Il reste à configurer les paramètres de sécurité et vous pouvez démarrer le drone: <br><br><img src="https://habrastorage.org/webt/ex/jp/x-/exjpx-pjkbvzmugdr-r1ujqpziw.png" alt="image"><br><br>  Comment configurer la suspension gyroscopique et contrôler la caméra principale en détail J'écrirai dans l'un des articles suivants, les principaux points sont décrits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  Diffusion vidéo </h3><br>  Vérifions le fonctionnement de la diffusion vidéo sur le réseau WiFi.  Avec cette commande, vous pouvez exécuter la vidéo dans un port TCP sur Raspberry en utilisant l'utilitaire natif de raspivid pour la caméra Raspicam: <br><br><pre> <code class="bash hljs">raspivid -t 0 -hf -fps 25 -w 640 -h 480 -o - | gst-launch-1.0 fdsrc ! h264parse ! rtph264pay config-interval=1 pt=96 ! gdppay ! tcpserversink host=0.0.0.0 port=5001</code> </pre> <br>  Mais cette commande fait la même chose, en utilisant uniquement le wrapper rpi-camsrc précédemment compilé pour gstreamer: <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc sensor-mode=4 ! h264parse ! rtph264pay config-interval=1 pt=96 ! gdppay ! tcpserversink host=0.0.0.0 port=5001</code> </pre> <br>  Dans les deux cas, la diffusion h264 est disponible à l'adresse IP Raspberry sur le port 5001. <br><br>  Vous pouvez le voir en exécutant une telle commande sur votre PC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gstreamer</a> doit être installé), au lieu de <i>RPI_ADDRESS,</i> spécifiez l'adresse Raspberry sur le réseau: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v tcpclientsrc host=RPI_ADDRESS port=5001 ! gdpdepay ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  En conséquence, la fenêtre avec la vidéo devrait s'ouvrir. <br><br>  Presque tous les GCS ont un lecteur vidéo intégré qui peut afficher un flux vidéo RTSP.  Pour créer un serveur RTSP à partir d'un Raspberry, vous pouvez utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lecteur de</a> console <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VLC</a> .  Installation: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc</code> </pre> <br>  La diffusion vidéo commence comme suit: <br><br><pre> <code class="bash hljs">raspivid -o - -t 0 -n -w 320 -h 240 -fps 25 | cvlc -vvv stream:///dev/stdin --sout <span class="hljs-string"><span class="hljs-string">'#rtp{sdp=rtsp://:8554/live}'</span></span> :demux=h264</code> </pre> <br>  La vidéo est disponible à (au lieu de <i>RPI_ADDRESS</i> , adresse Raspberry): <br><br> <code>rtsp://RPI_ADDRESS:8554/live</code> <br> <br>  Configuration de GCS: <br><br><img src="https://habrastorage.org/webt/uk/x8/hu/ukx8huklwh9kxu5glz289xkzenq.png" alt="image"><br><br><img src="https://habrastorage.org/webt/7r/og/gw/7roggwghpf_arhxggulllplkr6i.png" alt="image"><br><br>  L'adresse de flux peut être utilisée pour connecter plusieurs lecteurs sur différents appareils, mais comme la capture et la diffusion vidéo pour Raspberry sont un processus très long, il est préférable pour plusieurs consommateurs de vidéo d'utiliser un serveur externe (description ci-dessous). <br><br><h3>  Télémétrie sur Internet </h3><br>  Pour que GCS se connecte via Internet à un drone avec une adresse IP dynamique, un serveur intermédiaire avec une IP statique est requis sur lequel le script MAVProxy sera lancé.  À ces fins, j'ai profité d'une location de serveur cloud auprès d'un des fournisseurs bien connus.  Pour MAVProxy, la configuration la plus minimale convient, mais comme je vais utiliser le même serveur pour relayer la vidéo, j'ai choisi l'option avec un peu plus de mémoire (un cœur et 1 Go de mémoire, Ubuntu 18.04).  Pour un délai minimum dans le passage des données entre la carte et le GCS, le serveur doit être situé à la proximité géographique maximale du drone et du GCS. <br><br><img src="https://habrastorage.org/webt/eu/yl/3i/euyl3i1m1s5zjyjl5suhj0gw4sg.png" alt="image"><br><br>  Installez MAVProxy sur le serveur.  Premières dépendances: <br><br><pre> <code class="bash hljs">sudo apt-get install python-dev python-opencv python-wxgtk3.0 python-pip python-matplotlib python-pygame python-lxml python-yaml</code> </pre> <br>  puis le script lui-même via PIP: <br><br><pre> <code class="bash hljs">sudo pip install MAVProxy</code> </pre> <br>  écrivez le chemin: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"export PATH=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$HOME</span></span></span><span class="hljs-string">/.local/bin"</span></span> &gt;&gt; ~/.bashrc</code> </pre> <br>  et exécutez le script avec les paramètres suivants: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:0.0.0.0:15001 --out=tcpin:0.0.0.0:15002</code> </pre> <br>  MAVProxy écoute sur le port 15001 pour les paquets de télémétrie entrants du drone via UDP, et le port 15002 pour la connexion TCP entrante de GCS. <br><br>  Exécutez MAVProxy sur Raspberry avec un paramètre de plus, afin que la télémétrie soit également diffusée sur le serveur (au lieu de <i>SERVER_IP l'</i> adresse de votre serveur): <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550 --out=tcpin:0.0.0.0:5762 --out=udpout:SERVER_IP:15001</code> </pre> <br>  Après avoir démarré le script sur l'ordinateur de bord, les messages du pilote automatique apparaîtront dans la console du serveur.  Comme mentionné ci-dessus, MAVProxy est un GCS à part entière avec une interface texte et dans cet état, il est déjà possible de modifier les paramètres et de contrôler le drone via des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commandes</a> dans la console du serveur. <br><br>  Connectez le GCS sur le PC ou la tablette au serveur.  Les paramètres de connexion sont les mêmes que pour le réseau local, mais au lieu de l'adresse IP Raspberry, nous spécifions l'adresse du serveur et le port 15002. <br><br><img src="https://habrastorage.org/webt/8m/ed/rc/8medrcfonj1lsyr1wvufdi2elom.png" alt="image"><br><br>  Vous pouvez maintenant connecter un modem USB 4G à Raspberry et évaluer le délai de réaction de l'horizon à l'écran. <br><br><h3>  Vidéo Internet </h3><br><img src="https://habrastorage.org/webt/7i/w2/ow/7iw2owafcz4bjjmwu116q9tr65i.png" alt="image"><br><br>  Pour relayer la vidéo, installez le lecteur VLC sur le serveur: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc</code> </pre> <br>  Après l'installation, exécutez-le en tant que relais à partir du port UDP 5001 dans le canal RTSP <i><b>SERVER_IP: 8554 / live</b></i> : <br><br><pre> <code class="bash hljs">cvlc -vvv udp://@:5001 --sout <span class="hljs-string"><span class="hljs-string">'#rtp{sdp=rtsp://:8554/live}'</span></span> :demux=h264</code> </pre> <br>  À bord, nous allons commencer la diffusion vidéo de la caméra vers le serveur via UDP (au lieu de l'adresse du serveur <i>SERVER_IP</i> ): <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc bitrate=1000000 ! video/x-h264,width=640,height=480,framerate=25/1 ! h264parse ! udpsink host=SERVER_IP port=5001</code> </pre> <br>  L'adresse de flux peut désormais être utilisée comme source vidéo dans les paramètres GCS ou ouverte dans n'importe quel lecteur prenant en charge ce protocole. <br><br>  Vous pouvez maintenant planifier l'itinéraire de vol et lancer le drone via Internet, après l'avoir allumé, par exemple, à l'aide de l'assistant téléphonique. <br><br>  De toute évidence, en raison du temps de trajet relativement long de la vidéo et de la télémétrie sur le réseau, cette méthode ne convient guère aux vols FPV en mode manuel entre les obstacles. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/43rqRE9f1hA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Sujets pour les publications suivantes: <br><br><ul><li>  Options pour charger automatiquement le drone dans mon nichoir et auquel je me suis arrêté. </li><li>  Implémentation de GCS basé sur le Web en utilisant MAVProxy, NodeJS, socket.io et un serveur multimédia pour gérer plusieurs drones simultanément. </li><li>  Canaux de communication redondants et systèmes de sauvetage par drone </li><li>  Vision industrielle et lidars pour éviter les collisions avec des obstacles </li></ul><br>  À suivre ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414587/">https://habr.com/ru/post/fr414587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414577/index.html">Devilution: projet de reverse engineering Diablo</a></li>
<li><a href="../fr414579/index.html">Google AI a appris à prédire quand un patient mourra (mais tout n'est pas si sombre)</a></li>
<li><a href="../fr414581/index.html">Où est son bouton?! Comment une simple personne peut-elle décharger des données de Kibana et Elasticsearch et ne pas forcer les développeurs</a></li>
<li><a href="../fr414583/index.html">RIT ++, Tech RaDarts et tout-tout-tout</a></li>
<li><a href="../fr414585/index.html">Comment mon String.getBytes (UTF_8) s'est cassé et ce que j'en ai fait</a></li>
<li><a href="../fr414593/index.html">Comparaison de C # et JavaScript. Les bases</a></li>
<li><a href="../fr414595/index.html">Blocage de Roskomnadzor par l'hymne de la Fédération de Russie</a></li>
<li><a href="../fr414597/index.html">Demandez à Ethan: Dans quelle mesure les civilisations extraterrestres peuvent-elles se rapprocher?</a></li>
<li><a href="../fr414605/index.html">Mini empires</a></li>
<li><a href="../fr414609/index.html">Le PWA (Progressive Web Apps) 2018 peut-il être une concurrence digne des applications natives?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>