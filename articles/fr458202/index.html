<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèø üë©üèø‚Äçüî¨ üë®üèª‚Äç‚öñÔ∏è Jetez un ≈ìil √† SObjectizer si vous souhaitez utiliser Actors ou CSP dans votre projet C ++ üòÇ üë®üèª‚Äçüç≥ üóÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelques mots sur SObjectizer et son histoire 


 SObjectizer est un framework C ++ plut√¥t petit qui simplifie le d√©veloppement d'applications multith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jetez un ≈ìil √† SObjectizer si vous souhaitez utiliser Actors ou CSP dans votre projet C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458202/"><p><img src="https://habrastorage.org/webt/qq/0_/at/qq0_atvjcf2gb0uklnpqjbl31hw.jpeg"></p><br><h1 id="a-few-words-about-sobjectizer-and-its-history">  Quelques mots sur SObjectizer et son histoire </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SObjectizer</a> est un framework C ++ plut√¥t petit qui simplifie le d√©veloppement d'applications multithread.  SObjectizer permet √† un d√©veloppeur d'utiliser des approches issues des mod√®les Actor, Publish-Subscribe et Communicating Sequential Processes (CSP).  Il s'agit d'un projet OpenSource distribu√© sous licence BSD-3-CLAUSE. </p><br><p>  SObjectizer a une longue histoire.  SObjectizer lui-m√™me est n√© en 2002 en tant que projet SObjectizer-4.  Mais il √©tait bas√© sur les id√©es du pr√©c√©dent Objectizer SCADA qui avait √©t√© d√©velopp√© entre 1995 et 2000. SObjectizer-4 √©tait open source en 2006, mais son √©volution a √©t√© arr√™t√©e peu de temps apr√®s.  Une nouvelle version de SObjectizer avec le nom SObjectizer-5 a √©t√© lanc√©e en 2010 et a √©t√© open source en 2013. L'√©volution de SObjectizer-5 est toujours en cours et SObjectizer-5 a incorpor√© de nombreuses nouvelles fonctionnalit√©s depuis 2013. </p><br><p>  SObjectizer est plus ou moins connu dans le segment russe d'Internet, mais presque inconnu en dehors de l'exUSSR.  C'est parce que le SObjectizer a √©t√© principalement utilis√© pour des projets locaux dans les pays exUSSR et de nombreux articles, pr√©sentations et discussions sur SObjectizer sont en russe. </p><br><h1 id="a-niche-for-sobjectizer-and-similar-tools">  Une niche pour SObjectizer et des outils similaires </h1><br><p>  Le multithreading est utilis√© aussi bien en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">informatique parall√®le</a> qu'en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">informatique concurrente</a> .  Mais il y a une grande diff√©rence entre l'informatique parall√®le et simultan√©e.  Et, en cons√©quence, il existe des outils cibl√©s pour l'informatique parall√®le, et il existe des outils pour l'informatique concurrente, et ils sont diff√©rents. </p><a name="habracut"></a><br><p>  En gros, l'informatique parall√®le consiste √† utiliser plusieurs c≈ìurs pour r√©duire les temps de calcul.  Par exemple, le transcodage d'un fichier vid√©o d'un format √† un autre peut prendre une heure sur un c≈ìur de processeur, mais seulement 15 minutes sur quatre c≈ìurs de processeur.  Des outils comme OpenMP, Intel TBB, HPX ou cpp-taskflow sont con√ßus pour √™tre utilis√©s dans l'informatique parall√®le.  Et ces outils prennent en charge les approches appropri√©es pour ce domaine, comme la programmation bas√©e sur les t√¢ches ou le flux de donn√©es. </p><br><p>  L'informatique concurrente consiste √† traiter de nombreuses t√¢ches (probablement diff√©rentes) en m√™me temps.  Le serveur de base de donn√©es ou le courtier MQ peuvent √™tre de bons exemples: un serveur doit accepter une connexion, lire et analyser les donn√©es des connexions accept√©es, g√©rer les demandes re√ßues (effectuer plusieurs actions pour chaque demande), envoyer des r√©ponses, etc.  √Ä strictement parler, il n'est pas n√©cessaire d'utiliser le multithreading dans le calcul simultan√©: toutes ces t√¢ches peuvent √™tre effectu√©es sur un seul thread de travail.  Mais l'utilisation du multithreading et de plusieurs c≈ìurs de processeur peut rendre votre application plus performante, √©volutive et r√©active. </p><br><p>  Des approches comme Actor Model ou CSP sont con√ßues pour traiter de l'informatique concurrente.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">projet InfineSQL</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Yandex Message-Queue</a> sont de bons exemples d'utilisation des acteurs dans le domaine de l'informatique concurrente.  Ces deux projets utilisent des acteurs √† l'int√©rieur. </p><br><p>  Les outils tels que SObjectizer, QP / C ++ ou CAF, qui prennent en charge le mod√®le d'acteur, sont utiles pour r√©soudre les t√¢ches de la zone de calcul simultan√©.  Cela signifie que l'utilisation de SObjectizer ne vous donnera probablement rien dans des t√¢ches telles que la conversion de flux vid√©o.  Mais vous pouvez obtenir un r√©sultat tr√®s diff√©rent en impl√©mentant un courtier de messages au-dessus de SObjectizer. </p><br><h2 id="disclaimer">  Clause de non-responsabilit√© </h2><br><p>  L'utilisation de mod√®les Actor ou CSP peut vous apporter d'√©normes avantages dans certaines t√¢ches, mais rien ne garantit que ces mod√®les conviennent √† votre probl√®me particulier.  Le discours sur l'applicabilit√© des mod√®les Actor ou CSP d√©passe le cadre de cet article.  Supposons que le mod√®le Actor ou / et CSP s'applique √† vos t√¢ches et que vous savez comment les utiliser efficacement. </p><br><h1 id="what-sobjectizer-can-give-to-a-user">  Quel SObjectizer peut apporter √† un utilisateur? </h1><br><h2 id="shared-nothing-and-fire-and-forget-principles-just-out-of-box">  Des principes de partage de rien et d'incendie et d'oubli tout juste sortis de la bo√Æte </h2><br><p>  L'utilisation des acteurs suppose l'absence de donn√©es partag√©es.  Chaque acteur poss√®de ses donn√©es et ces donn√©es ne sont visibles par personne d'autre.  C'est <em>un principe de partage rien</em> qui est bien connu dans le d√©veloppement d'applications distribu√©es, par exemple.  Dans une application multithread, le principe du partage de rien a un avantage important: il permet d'√©viter des probl√®mes dangereux pour le travail avec des donn√©es partag√©es comme les blocages et les courses de donn√©es. </p><br><p>  L'interaction entre les acteurs (agents) dans SObjectizer est effectu√©e uniquement via des messages asynchrones.  Un agent envoie un message √† un autre agent et cette op√©ration ne bloque pas l'exp√©diteur (dans un cas courant). </p><br><p>  L'interaction asynchrone permet d'utiliser un autre principe utile: <em>tirer et oublier</em> .  Lorsqu'un agent a besoin d'une op√©ration, il envoie (d√©clenche) un message et continue son travail.  Dans la plupart des cas, le message sera re√ßu et trait√©. </p><br><p>  Par exemple, il peut y avoir un agent qui lit les connexions accept√©es et analyse les donn√©es entrantes.  Si l'ensemble de la PDU est lu et analys√©, l'agent envoie simplement cette PDU √† un autre agent-processeur et revient √† la lecture / analyse de nouvelles donn√©es entrantes. </p><br><h2 id="dispatchers">  R√©partiteurs </h2><br><p>  Les r√©partiteurs sont l'une des pierres angulaires de SObjectizer.  Les r√©partiteurs fournissent un contexte de travail (aka thread de travail) sur lequel un agent traitera les messages entrants.  Au lieu de cr√©er manuellement des threads de travail (ou des pools de threads), un utilisateur cr√©e des r√©partiteurs et leur lie des agents.  Un utilisateur peut cr√©er autant de r√©partiteurs dans une application qu'il le souhaite. </p><br><p>  La meilleure chose avec les r√©partiteurs et les agents dans SObjectizer est la s√©paration des concepts: les r√©partiteurs sont responsables de la gestion du contexte de travail et des propres files d'attente de messages, les agents ex√©cutent la logique d'application et ne se soucient pas du contexte de travail.  Il permet de d√©placer un agent d'un r√©partiteur √† un autre litt√©ralement par un clic.  Hier, un agent a travaill√© sur le r√©partiteur one_thread, aujourd'hui nous pouvons le relier au r√©partiteur active_obj, et demain nous pouvons le relier au r√©partiteur thread_pool.  Sans changer de ligne dans l'impl√©mentation de l'agent. </p><br><p>  Il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">huit types de r√©partiteurs dans SObjectizer-5.6.0</a> (et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">un autre</a> peut √™tre trouv√© dans le projet compagnon so5extra): des tr√®s simples (one_thread ou thread_pool) aux plus sophistiqu√©s (comme adv_thread_pool ou prio_dedicated_threads :: one_per_prio).  Et un utilisateur peut √©crire son propre r√©partiteur pour des conditions sp√©cifiques. </p><br><h2 id="hierarchical-state-machines-are-built-in-functionality">  Les machines √† √©tats hi√©rarchiques sont des fonctionnalit√©s int√©gr√©es </h2><br><p>  Les agents (acteurs) dans SObjectizer sont des machines √† √©tats: la r√©action sur un message entrant d√©pend de l'√©tat actuel de l'agent.  SObjectizer prend en charge la plupart des fonctionnalit√©s des machines √† √©tats hi√©rarchiques (HSM): √©tats imbriqu√©s, historique profond et peu profond pour un √©tat, gestionnaires on_enter / on_exit, limites de temps pour rester dans un √©tat.  Seuls les √©tats orthogonaux ne sont pas pris en charge dans SObjectizer maintenant (nous n'avons pas vu la n√©cessit√© de cette fonctionnalit√© dans nos projets, et personne ne nous a demand√© d'ajouter la prise en charge de cette fonctionnalit√©). </p><br><h2 id="csp-like-channels-just-out-of-box">  Canaux de type CSP juste sortis de leur bo√Æte </h2><br><p> Il n'est pas n√©cessaire d'utiliser les agents de SObjectizer (alias acteurs).  L'application enti√®re peut √™tre d√©velopp√©e simplement en utilisant des objets <code>std::thread</code> et les cha√Ænes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SObjectizer (aussi appel√©es canaux CSP)</a> .  Dans ce cas, le d√©veloppement d'applications avec SObjectizer sera quelque peu similaire au d√©veloppement en langage Go (y compris un analogue de la construction <code>select</code> de Go qui permet d'attendre les messages de plusieurs canaux). </p><br><p>  Les cha√Ænes de SObjectizer peuvent avoir une caract√©ristique tr√®s importante: un m√©canisme de contre-pression int√©gr√©.  Si un utilisateur cr√©e une cha√Æne de taille limit√©e et essaie ensuite de pousser un message dans la cha√Æne compl√®te, l'op√©ration d'envoi peut bloquer l'exp√©diteur pendant un certain temps.  Il permet de r√©soudre un probl√®me c√©l√®bre avec un producteur rapide et un consommateur lent. </p><br><p>  Les mchains de SObjectizer ont une autre caract√©ristique int√©ressante: une mchain peut √™tre utilis√©e comme un outil de distribution de charge tr√®s simple.  Plusieurs threads peuvent attendre la <em>r√©ception</em> de la m√™me cha√Æne en m√™me temps.  Si un nouveau message est envoy√© √† cette cha√Æne, un seul thread lira et traitera ce message. </p><br><h2 id="only-a-part-of-an-application-can-use-sobjectizer">  Seule une partie d'une application peut utiliser SObjectizer </h2><br><p>  Il n'est pas n√©cessaire d'utiliser SObjectizer dans chaque partie d'une application.  Seule une partie d'une application peut √™tre d√©velopp√©e √† l'aide de SObjectizer.  Donc, si vous utilisez d√©j√† Qt ou wxWidgets ou Boost.Asio comme framework principal pour votre application, il est possible d'utiliser SObjectize dans un seul sous-module de votre application. </p><br><p>  Nous avions de l'exp√©rience sur l'utilisation de SObjectizer pour le d√©veloppement de biblioth√®ques qui masquent l'utilisation de SObjectizer comme d√©tail d'impl√©mentation.  L'API publique de ces biblioth√®ques n'a pas du tout r√©v√©l√© la pr√©sence de SObjectizer.  SObjectizer √©tait enti√®rement sous le contr√¥le d'une biblioth√®que: la biblioth√®que a d√©marr√© et arr√™t√© SObjectizer selon ses besoins.  Ces biblioth√®ques ont √©t√© utilis√©es dans des applications qui ignoraient totalement la pr√©sence de SObjectizer. </p><br><p>  Si SObjectizer n'est utilis√© que dans une partie d'une application, il y a une t√¢che de communication entre les parties SObjectizer et non SObjectizer de l'application.  Cette t√¢che est facilement r√©solue: les messages d'une partie non SObjectizer vers une partie SObjectizer peuvent √™tre envoy√©s via le m√©canisme ordinaire de remise de messages SObjectizer.  Les messages dans la direction oppos√©e peuvent √™tre transmis via des cha√Ænes. </p><br><h2 id="you-can-run-several-instances-of-sobjectizer-at-the-same-time">  Vous pouvez ex√©cuter plusieurs instances de SObjectizer en m√™me temps </h2><br><p>  SObjectizer permet d'ex√©cuter plusieurs instances de SObjectizer (appel√©es SObjectizer Environment) dans une m√™me application en m√™me temps.  Chaque environnement SObjectizer sera ind√©pendant des autres environnements de ce type. </p><br><p>  Cette fonctionnalit√© est inestimable dans les situations o√π vous devez cr√©er une application √† partir de plusieurs modules ind√©pendants.  Certains modules peuvent utiliser SObjectizer, d'autres non.  Les modules qui n√©cessitent SObjectizer peuvent ex√©cuter sa copie de SObjectizer Environment et qui n'auront pas d'influence sur les autres modules de l'application. </p><br><h2 id="timers-are-part-of-sobjectizer">  Les minuteries font partie de SObjectizer </h2><br><p>  La prise en charge des minuteries sous forme de messages retard√©s et p√©riodiques est une autre des pierres angulaires de SObjectizer.  SObjectizer poss√®de plusieurs impl√©mentations de m√©canismes de temporisation (timer_wheel, timer_heap et timer_list) et peut g√©rer des dizaines, des centaines et des milliers de millions de temporisateurs dans une application.  Un utilisateur peut choisir le m√©canisme de temporisation le plus appropri√© pour une application.  De plus, un utilisateur peut fournir sa propre impl√©mentation de timer_thread / timer_manager si aucun des standards n'est appropri√© aux conditions de l'utilisateur. </p><br><h2 id="sobjectizer-has-various-customization-points-and-tuning-options">  SObjectizer dispose de divers points de personnalisation et d'options de r√©glage </h2><br><p>  SObjectizer permet la personnalisation de plusieurs m√©canismes importants.  Par exemple, un utilisateur peut s√©lectionner l'une des impl√©mentations standard de timer_thread (ou timer_manager).  Ou peut fournir sa propre impl√©mentation.  Un utilisateur peut s√©lectionner une impl√©mentation d'objets de verrouillage utilis√©s par les files d'attente de messages dans les r√©partiteurs de SObjectizer.  Ou peut fournir sa propre impl√©mentation. </p><br><p>  Un utilisateur peut impl√©menter son propre r√©partiteur.  Un utilisateur peut impl√©menter sa propre bo√Æte de message.  Un utilisateur peut impl√©menter sa propre enveloppe de message.  Un utilisateur peut impl√©menter son propre event_queue_hook.  Et ainsi de suite. </p><br><h1 id="where-sobjectizer-can-or-cant-be-used">  O√π SObjectizer peut ou ne peut pas √™tre utilis√©? </h1><br><p>  Il est beaucoup plus facile de dire o√π SObjectizer ne peut pas √™tre utilis√© pour des raisons objectives.  Nous commen√ßons donc la discussion en √©num√©rant ces zones, puis nous donnerons quelques exemples de l'utilisation de SObjectizer dans le pass√© (et pas seulement dans le pass√©). </p><br><h2 id="where-sobjectizer-cant-be-used">  O√π SObjectizer ne peut pas √™tre utilis√©? </h2><br><h3 id="tasks-related-to-parallel-computing">  T√¢ches li√©es au calcul parall√®le </h3><br><p>  Comme cela a √©t√© dit ci-dessus, les mod√®les Actor et CSP ne sont pas un bon choix pour le calcul haute performance et d'autres domaines du calcul parall√®le.  Donc, si vous devez plusieurs matrices ou transcoder des flux vid√©o, des outils comme OpenMP, Intel TBB, cpp-taskflow, HPX ou MPI conviendront mieux. </p><br><h3 id="hard-real-time-systems">  Syst√®mes durs en temps r√©el </h3><br><p>  Malgr√© le fait que SObjectizer ait ses racines dans les syst√®mes SCADA, l'impl√©mentation actuelle de SObjectizer (aka SObjectizer-5) ne peut pas √™tre utilis√©e dans les syst√®mes durs en temps r√©el.  C'est principalement en raison de l'utilisation de la m√©moire dynamique dans la mise en ≈ìuvre de SObjectizer: les messages sont des objets allou√©s dynamiquement (cependant, SObjectizer peut utiliser des objets pr√©allou√©s comme messages), les r√©partiteurs utilisent la m√©moire dynamique pour les files d'attente de messages, m√™me les d√©lais pour les √©tats de l'agent utilisent des objets allou√©s dynamiquement pour effectuer un contr√¥le horaire. </p><br><p>  Malheureusement, le terme ¬´temps r√©el¬ª est largement surutilis√© dans le monde moderne.  On parle souvent de services Web en temps r√©el, comme ¬´application Web en temps r√©el¬ª ou ¬´analyse Web en temps r√©el¬ª, etc.  Le terme "en ligne" ou "en direct" est plus appropri√© pour de telles applications que le terme "en temps r√©el", m√™me sous une forme "douce en temps r√©el".  Ainsi, si nous parlons de quelque chose comme "une application Web en temps r√©el", SObjectizer peut facilement √™tre utilis√© dans de tels syst√®mes "en temps r√©el". </p><br><h3 id="constrained-embedded-systems">  Syst√®mes embarqu√©s contraints </h3><br><p>  SObjectizer s'appuie sur la biblioth√®que standard C ++: <code>std::thread</code> est utilis√© pour la gestion des threads, <code>std::atomic</code> , <code>std::mutex</code> , <code>std::condition_variable</code> sont utilis√©s pour la synchronisation des donn√©es, RTTI et <code>dynamic_cast</code> sont utilis√©s √† l'int√©rieur de SObjectizer (par exemple , <code>std::type_index</code> sont utilis√©s pour l'identification du type de message), les exceptions C ++ sont utilis√©es pour le rapport d'erreurs. </p><br><p>  Cela signifie que SObjectizer ne peut pas √™tre utilis√© dans des environnements o√π de telles fonctionnalit√©s de la biblioth√®que standard ne sont pas disponibles.  Par exemple, dans le d√©veloppement de syst√®mes embarqu√©s contraints o√π seule une partie de C ++ et C ++ stdlib peut √™tre utilis√©e. </p><br><h2 id="where-sobjectizer-was-used-in-the-past">  O√π SObjectizer √©tait utilis√© dans le pass√©? </h2><br><p>  Maintenant, nous essayons de parler bri√®vement de certains cas d'utilisation de l'utilisation de SObjectizer dans le pass√© (et pas seulement dans le pass√©).  Malheureusement, ce ne sont pas des informations compl√®tes car il y a des probl√®mes. </p><br><p>  Tout d'abord, nous ne connaissons pas tous les usages de SObjectizer.  SObjectizer est un logiciel gratuit qui peut √™tre utilis√© m√™me dans des projets propri√©taires.  Donc, certaines personnes obtiennent simplement SObjectizer et l'utilisent sans fournir de commentaires pour nous.  Parfois, nous acqu√©rons des informations sur l'utilisation de SObjectizer (mais sans aucun d√©tail), parfois nous ne savons rien. </p><br><p>  Le deuxi√®me probl√®me est la permission de partager des informations sur l'utilisation de SObjectizer dans un projet particulier.  Nous avons re√ßu cette autorisation tr√®s rarement, dans la plupart des cas, les utilisateurs de SObjectizer ne veulent pas ouvrir les d√©tails de mise en ≈ìuvre de leurs projets (parfois nous comprenons les raisons, parfois non). </p><br><p>  Nous nous excusons du fait que les informations fournies semblent si rares et ne contiennent aucun d√©tail.  N√©anmoins, il existe quelques exemples d'utilisation de SObjectizer: </p><br><ul><li>  Passerelle d'agr√©gation SMS / USSD qui g√®re plus de 500 millions de messages par mois; </li><li>  une partie du syst√®me servant aux paiements en ligne via les distributeurs automatiques de billets d'une des plus grandes banques russes; </li><li>  mod√©lisation par simulation des processus √©conomiques (dans le cadre de la recherche doctorale); </li><li>  acquisition de donn√©es distribu√©es et syst√®me analytique.  Donn√©es collect√©es sur des points r√©partis dans le monde entier par les commandes du n≈ìud central.  MQTT a √©t√© utilis√© comme moyen de transport pour le contr√¥le et la distribution des donn√©es acquises; </li><li>  environnement de test pour v√©rifier le syst√®me de contr√¥le en temps r√©el des √©quipements ferroviaires; </li><li>  syst√®me de contr√¥le automatique des d√©cors de th√©√¢tre.  Plus de d√©tails peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ; </li><li>  composants de la plateforme de gestion des donn√©es dans un syst√®me de publicit√© en ligne. </li></ul><br><h1 id="a-taste-of-sobjectizer">  Un avant-go√ªt de SObjectizer </h1><br><p>  Voyons quelques exemples simples pour prendre un avant-go√ªt de SObjectizer.  Ce sont des exemples tr√®s simples qui, nous l'esp√©rons, ne n√©cessitent pas d'explications suppl√©mentaires √† l'exclusion des commentaires dans le code. </p><br><h2 id="the-traditional-hello-world-example-in-actor-models-style">  L'exemple traditionnel "Hello, World" dans le style de l'acteur mod√®le </h2><br><p>  L'exemple le plus simple avec un seul agent qui r√©agit au message <code>hello</code> et termine son travail: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'hello' message. so_subscribe_self().event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register an instance of demo agent. auto mbox = env.introduce_coop([](so_5::coop_t &amp; coop) { auto * a = coop.make_agent&lt;demo&gt;(); return a-&gt;so_direct_mbox(); }); // Send hello message to registered agent. so_5::send&lt;hello&gt;(mbox, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><h2 id="another-version-of-hello-world-with-agents-and-publishsubscribe-model">  Une autre version de "Hello, World" avec des agents et un mod√®le Publish / Subscribe </h2><br><p>  L'exemple le plus simple avec plusieurs agents, tous r√©agissent √† la m√™me instance de message <code>hello</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::string_literals; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { const std::string name_; void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: demo(context_t ctx, std::string name, so_5::mbox_t board) : agent_t{std::move(ctx)} , name_{std::move(name)} { // Create a subscription for hello message from board. so_subscribe(board).event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Mbox to be used for speading hello message. auto board = env.create_mbox(); // Create several agents in separate coops. for(const auto &amp; n : {"Alice"s, "Bob"s, "Mike"s}) env.register_agent_as_coop(env.make_agent&lt;demo&gt;(n, board)); // Spread hello message to all subscribers. so_5::send&lt;hello&gt;(board, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><p>  Si nous ex√©cutons cet exemple, nous pouvons recevoir quelque chose comme √ßa: </p><br><pre> <code class="plaintext hljs">Alice: greeting received: Hello, World! Bob: greeting received: Hello, World! Mike: greeting received: Hello, World!</code> </pre> <br><h2 id="hello-world-example-in-csp-style">  Exemple "Hello, World" en style CSP </h2><br><p>  Regardons un exemple de SObjectizer sans aucun acteur, juste <code>std::thread</code> et des canaux de type CSP. </p><br><h3 id="very-simple-version">  Version tr√®s simple </h3><br><p>  Il s'agit d'une version tr√®s simple qui ne pr√©sente pas d'exception: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Channel to be used. auto ch = so_5::create_mchain(sobj); std::thread demo_thread{demo_thread_func, ch}; // Send a greeting. so_5::send&lt;hello&gt;(ch, "Hello, World!"); // Wait for demo thread. demo_thread.join(); }</span></span></span></span></code> </pre> <br><h3 id="more-robust-but-still-simple-version">  Version plus robuste, mais toujours simple </h3><br><p>  Il s'agit d'une version modifi√©e de l'exemple ci-dessus avec l'ajout d'une s√©curit√© d'exception: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Demo thread. We need object now, but thread will be started later. std::thread demo_thread; // Auto-joiner for the demo thread. auto demo_joiner = so_5::auto_join(demo_thread); // Channel to be used. This channel will be automatically closed // in the case of an exception. so_5::mchain_master_handle_t ch_handle{ so_5::create_mchain(sobj), so_5::mchain_props::close_mode_t::retain_content }; // Now we can run demo thread. demo_thread = std::thread{demo_thread_func, *ch_handle}; // Send a greeting. so_5::send&lt;hello&gt;(*ch_handle, "Hello, World!"); // There is no need to wait for something explicitly. }</span></span></span></span></code> </pre> <br><h2 id="a-rather-simple-hsm-example-blinking_led">  Un exemple HSM assez simple: blinking_led </h2><br><p>  Ceci est un exemple standard de la distribution de SObjectizer.  L'agent principal de cet exemple est un HSM qui peut √™tre d√©crit par le graphique suivant: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eca/679/59d/eca67959d472d154ce57878d4ffe0120.png" alt="statechart clignotant"></p><br><p>  Le code source de l'exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class blinking_led final : public so_5::agent_t { state_t off{ this }, blinking{ this }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; public : struct turn_on_off final : public so_5::signal_t {}; blinking_led( context_t ctx ) : so_5::agent_t{ ctx } { this &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ std::cout &lt;&lt; "ON" &lt;&lt; std::endl; } ) .on_exit( []{ std::cout &lt;&lt; "off" &lt;&lt; std::endl; } ) .time_limit( std::chrono::milliseconds{1500}, blink_off ); blink_off .time_limit( std::chrono::milliseconds{750}, blink_on ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { auto m = env.introduce_coop( []( so_5::coop_t &amp; coop ) { auto led = coop.make_agent&lt; blinking_led &gt;(); return led-&gt;so_direct_mbox(); } ); auto pause = []( unsigned int v ) { std::this_thread::sleep_for( std::chrono::seconds{v} ); }; std::cout &lt;&lt; "Turn blinking on for 10s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 10 ); std::cout &lt;&lt; "Turn blinking off for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Turn blinking on for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Stopping..." &lt;&lt; std::endl; env.stop(); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br><h2 id="timers-overload-control-for-an-agent-and-active_obj-dispatcher">  Minuteries, contr√¥le de surcharge pour un agent et r√©partiteur active_obj </h2><br><p>  Le contr√¥le de surcharge est l'un des principaux probl√®mes des acteurs: les files d'attente de messages pour les acteurs sont g√©n√©ralement illimit√©es, ce qui peut entra√Æner une croissance incontr√¥l√©e des files d'attente si un producteur de messages rapide envoie des messages plus rapidement que le destinataire peut les g√©rer.  L'exemple suivant montre les fonctionnalit√©s de SObjectizer comme <em>limites de messages</em> .  Il permet de limiter le nombre de messages dans la file d'attente de l'agent et de d√©fendre le destinataire des messages redondants. </p><br><p>  Cet exemple montre √©galement l'utilisation du temporisateur sous la forme d'un message p√©riodique.  La liaison des agents au r√©partiteur active_obj y est √©galement indiqu√©e.  La liaison avec ce r√©partiteur signifie que chaque agent de la coop√©rative travaillera sur son propre thread de travail (par exemple, un agent devient un objet actif). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::chrono_literals; // Message to be sent to the consumer. struct task { int task_id_; }; // An agent for utilization of unhandled tasks. class trash_can final : public so_5::agent_t { public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'task' message. // Event-handler is specified in the form of a lambda-function. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "unhandled task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; }); } }; // The consumer of 'task' messages. class consumer final : public so_5::agent_t { public: // We need the constructor. consumer(context_t ctx, so_5::mbox_t trash_mbox) : so_5::agent_t{ctx + // Only three 'task' messages can wait in the queue. limit_then_redirect&lt;task&gt;(3, // All other messages will go to that mbox. [trash_mbox]{ return trash_mbox; })} { // Define a reaction to incoming 'task' message. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "handling task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; std::this_thread::sleep_for(75ms); }); } }; // The producer of 'test' messages. class producer final : public so_5::agent_t { const so_5::mbox_t dest_; so_5::timer_id_t task_timer_; int id_counter_{}; // Type of periodic signal to produce new 'test' message. struct generate_next final : public so_5::signal_t {}; void on_next(mhood_t&lt;generate_next&gt;) { // Produce a new 'task' message. so_5::send&lt;task&gt;(dest_, id_counter_); ++id_counter_; // Should the work be stopped? if(id_counter_ &gt;= 10) so_deregister_agent_coop_normally(); } public: producer(context_t ctx, so_5::mbox_t dest) : so_5::agent_t{std::move(ctx)} , dest_{std::move(dest)} {} void so_define_agent() override { so_subscribe_self().event(&amp;producer::on_next); } // This method will be automatically called by SObjectizer // when agent starts its work inside SObjectizer Environment. void so_evt_start() override { // Initiate a periodic message with no initial delay // and repetition every 25ms. task_timer_ = so_5::send_periodic&lt;generate_next&gt;(*this, 0ms, 25ms); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register coop with agents. // All agents will be bound to active_obj dispatcher and will // work on separate threads. env.introduce_coop( so_5::disp::active_obj::make_dispatcher(env).binder(), [](so_5::coop_t &amp; coop) { auto * trash = coop.make_agent&lt;trash_can&gt;(); auto * handler = coop.make_agent&lt;consumer&gt;(trash-&gt;so_direct_mbox()); coop.make_agent&lt;producer&gt;(handler-&gt;so_direct_mbox()); }); }); }</span></span></span></span></code> </pre> <br><p>  Si nous ex√©cutons cet exemple, nous pouvons voir la sortie suivante: </p><br><pre> <code class="plaintext hljs">handling task: 0 handling task: 1 unhandled task: 5 unhandled task: 6 handling task: 2 unhandled task: 8 unhandled task: 9 handling task: 3 handling task: 4 handling task: 7</code> </pre> <br><p>  Cette sortie montre que plusieurs messages qui ne peuvent pas entrer dans la limite d√©finie sont rejet√©s et redirig√©s vers un autre r√©cepteur. </p><br><h2 id="more-examples">  Plus d'exemples </h2><br><p>  Un exemple plus ou moins similaire au code des applications r√©elles peut √™tre trouv√© dans notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">projet de d√©monstration Shrimp</a> .  Un autre ensemble d'exemples int√©ressants peut √™tre trouv√© dans cette mini-s√©rie sur le "probl√®me des philosophes de la restauration" classique: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">partie 1</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">partie 2</a> .  Et, bien s√ªr, il y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">a beaucoup d'exemples dans SObjectizer lui-m√™me</a> . </p><br><h1 id="what-about-the-performance">  Et la performance? </h1><br><p>  La r√©ponse est tr√®s simple: elle est plus que suffisante pour nous.  SObjectizer peut distribuer des millions de messages par seconde, et la vitesse r√©elle d√©pend des types de r√©partiteurs utilis√©s, des types de messages, du profil de charge, du mat√©riel / OS / compilateur utilis√©, etc.  Dans une application r√©elle, nous n'utilisons g√©n√©ralement qu'une fraction de la vitesse de SObjectizer. </p><br><p>  Les performances de SObjectizer pour votre t√¢che particuli√®re d√©pendent fortement de votre t√¢che, de la solution particuli√®re de cette t√¢che, de votre mat√©riel ou de votre environnement virtuel, de la version de votre compilateur et de votre syst√®me d'exploitation.  La meilleure fa√ßon de trouver une r√©ponse √† cette question est donc de cr√©er votre propre benchmark qui sera sp√©cifique √† votre t√¢che et de l'exp√©rimenter. </p><br><p>  Si vous voulez des nombres de certains benchmarks synth√©tiques, il y a quelques programmes dans le dossier test / so_5 / bench de la distribution SObjectizer. </p><br><h2 id="a-note-about-comparison-with-different-tools">  Une note sur la comparaison avec diff√©rents outils </h2><br><p>  Nous pensons qu'un jeu de benchmarking comparant la vitesse de diff√©rents outils est un jeu de marketing.  Nous avons fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">une tentative</a> dans le pass√© mais nous nous sommes vite rendu compte que ce n'√©tait qu'une perte de temps.  Nous ne jouons donc pas √† ce jeu maintenant.  Nous passons notre temps et nos ressources uniquement sur des benchmarks qui nous permettent de v√©rifier l'absence de d√©gradation des performances, de r√©soudre certains cas d'angle (comme les performances des mbox MPMC avec une grande quantit√© d'abonn√©s ou les performances d'un agent avec des centaines de milliers d'abonnements), pour acc√©l√©rer certaines op√©rations sp√©cifiques √† SObjectizer (comme l'enregistrement / le d√©senregistrement d'une coop√©rative). </p><br><p>  Nous laissons donc la comparaison de la vitesse √† ceux qui aiment ce jeu et qui ont le temps de le jouer. </p><br><h1 id="why-sobjectizer-does-look-exactly-as-it-is">  Pourquoi SObjectizer a exactement la m√™me apparence? </h1><br><p>  Il existe plusieurs "frameworks d'acteurs" pour C ++, et tous ont un aspect diff√©rent.  Il semble qu'il ait des raisons objectives: chaque cadre a ses caract√©ristiques uniques et cible des objectifs diff√©rents.  De plus, les acteurs en C ++ peuvent √™tre impl√©ment√©s tr√®s diff√©remment.  Donc, la question principale n'est pas "pourquoi le framework X ne ressemble pas au framework Y?", Mais "pourquoi le framework X ressemble √† ce qu'il est?" </p><br><p>  Nous allons maintenant essayer de d√©crire bri√®vement les raisons des principales fonctionnalit√©s de SObjectizer.  Nous esp√©rons que cela permettra une meilleure compr√©hension des capacit√©s de SObjectizer.  Mais avant de commencer, il est n√©cessaire de mentionner une chose tr√®s importante: SObjectizer n'a jamais √©t√© une exp√©rience.  Il a √©t√© cr√©√© pour r√©soudre le travail r√©el et a √©volu√© en fonction de l'exp√©rience de la vie r√©elle. </p><br><h2 id="agents-are-objects-of-classes-derived-from-agent_t">  Les agents sont des objets de classes d√©riv√©es de agent_t </h2><br><p>  Les agents (ou acteurs) dans SObjectzer sont des objets de classes d√©finies par l'utilisateur qui doivent √™tre d√©riv√©es d'une classe sp√©ciale <code>agent_t</code> .  Cela peut sembler redondant dans de minuscules exemples de jouets, mais notre exp√©rience montre que cette approche simplifie consid√©rablement le d√©veloppement de logiciels r√©els o√π les agents ont g√©n√©ralement la taille sur plusieurs centaines de lignes (vous pouvez voir l'un des exemples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> , mais ce blog est en Russe).  Parfois m√™me en plusieurs milliers de lignes. </p><br><p>  L'exp√©rience nous montre qu'un simple agent avec la premi√®re version en cent lignes devient beaucoup plus gros et complexe au cours des prochaines ann√©es d'√©volution.  Ainsi, apr√®s cinq ans, vous pouvez trouver un monstre en mille lignes avec des dizaines de m√©thodes. </p><br><p>  L'utilisation des classes nous permet de g√©rer la complexit√© des agents.  Nous pouvons utiliser l'h√©ritage des classes.  Et nous pouvons √©galement utiliser des classes de mod√®les.  Ce sont des techniques tr√®s utiles qui simplifient consid√©rablement le d√©veloppement de familles d'agents ayant une logique similaire √† l'int√©rieur. </p><br><h2 id="messages-as-objects-of-user-structsclasses">  Messages en tant qu'objets de structures / classes d'utilisateurs </h2><br><p>  Les messages dans SObjectizer sont des objets de structures ou de classes d√©finies par l'utilisateur.  Il y a au moins deux raisons √† cela: </p><br><ul><li>  le d√©veloppement de SObjectizer-5 a commenc√© en 2010 alors que C ++ 11 n'√©tait pas encore standardis√©.  Donc, au d√©but, nous ne pouvions pas utiliser de telles fonctionnalit√©s de C ++ 11 comme mod√®les variadic et classe <code>std::tuple</code> .  Le seul choix que nous avions √©tait l'utilisation d'un objet d'une classe h√©rit√©e d'une classe sp√©ciale <code>message_t</code> .  D√©sormais, il n'est plus n√©cessaire de d√©river le type de message de <code>message_t</code> , mais SObjectizer enveloppe de toute fa√ßon un objet utilisateur dans un objet d√©riv√© de <code>message_t</code> sous le capot; </li><li>  le contenu d'un message peut facilement √™tre modifi√© sans modification des signatures des gestionnaires d'√©v√©nements.  Et il y a un contr√¥le √† partir d'un compilateur: si vous supprimez un champ d'un message ou changez son type, le compilateur vous informera d'un acc√®s incorrect √† ce champ. </li></ul><br><p>  L'utilisation de messages comme objets permet √©galement de travailler avec des messages pr√©allou√©s et de stocker un message re√ßu dans un conteneur et de le renvoyer plus tard. </p><br><h2 id="coops-of-agents">  Des coop√©ratives d'agents </h2><br><p>  Une coop√©rative d'agents est probablement l'une des fonctionnalit√©s uniques de SObjectizer.  Une coop√©rative est un groupe d'agents qui doivent √™tre ajout√©s et supprim√©s de SObjectizer de mani√®re transactionnelle.  Cela signifie que si une coop√©rative contient trois agents, tous ces agents doivent √™tre ajout√©s √† SObjectizer avec succ√®s ou aucun d'entre eux ne doit √™tre ajout√©.  De m√™me, les trois agents doivent √™tre supprim√©s de SObjectizer ou les trois agents doivent poursuivre leur travail. </p><br><p>  Le besoin dans les coop√©ratives a √©t√© d√©couvert peu apr√®s le d√©but de la vie de SObjectizer.  Il est devenu √©vident que les agents seraient cr√©√©s par des groupes et non par des instances uniques.  Coops a √©t√© invent√© pour simplifier la vie d'un d√©veloppeur: il n'est pas n√©cessaire de contr√¥ler la cr√©ation du prochain agent et de supprimer les agents pr√©c√©demment cr√©√©s si la cr√©ation d'un nouvel agent √©choue. </p><br><p>  Une coop√©rative peut √©galement √™tre consid√©r√©e comme un superviseur en mode tout-en-un: si un agent de la coop√©rative tombe en panne, la coop√©rative enti√®re sera supprim√©e de SObjectizer Environment et d√©truite (un utilisateur peut r√©agir √† cela et recr√©er la coop√©rative √† nouveau). </p><br><h2 id="message-boxes">  Bo√Ætes de messages </h2><br><p>  Les bo√Ætes de message sont une autre fonctionnalit√© unique de SObjectizer.  Les messages dans SObjectizer sont envoy√©s √† une bo√Æte de message (mbox), pas directement √† un agent.  Il peut y avoir un r√©cepteur derri√®re la mbox, ou il peut y avoir un million d'abonn√©s, ou il n'y a personne. </p><br><p>  Mboxes nous permet de prendre en charge les fonctionnalit√©s de base du mod√®le Publish-Subscribe.  Une mbox peut √™tre consid√©r√©e comme un courtier MQ et le type de message peut √™tre consid√©r√© comme un sujet. </p><br><p>  Mboxes nous permet √©galement de mettre en ≈ìuvre diverses formes int√©ressantes de livraison de messages.  Par exemple, il existe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">mbox √† tour de r√¥le</a> qui r√©partit les messages entre les abonn√©s de mani√®re √† tour de r√¥le.  Il existe √©galement une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">mbox conserv√©e</a> qui contient le dernier message envoy√© et le renvoie automatiquement √† chaque nouvel abonn√©.  Il existe √©galement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">simple wrapper autour de libmosquitto</a> qui permet d'utiliser MQTT comme transport pour une application distribu√©e. </p><br><h2 id="agents-as-hsm">  Agents comme HSM </h2><br><p>  Les agents dans SObjectizer sont des machines √† √©tats.  C'√©tait d√®s le d√©but simplement parce que SObjectizer a des racines dans le domaine SCADA, o√π les machines √† √©tats sont activement utilis√©es.  Mais il est rapidement devenu √©vident que les agents sous la forme d'une machine d'√©tat peuvent √™tre utiles m√™me dans des niches diff√©rentes (comme les applications de t√©l√©communications et de finance). </p><br><p>  La prise en charge des machines √† √©tats hi√©rarchiques (par exemple, les gestionnaires on_enter / on_exit, les √©tats imbriqu√©s, les limites de temps, etc.) a √©t√© ajout√©e apr√®s un certain temps d'utilisation de SObjectizer en production.  Et cette fonctionnalit√© a fait de SObjectizer un outil encore plus puissant et pratique. </p><br><h2 id="usage-of-c-exceptions">  Utilisation d'exceptions C ++ </h2><br><p>  Les exceptions C ++ sont utilis√©es dans SObjectizer comme principal m√©canisme de rapport d'erreurs.  Malgr√© le fait que l'utilisation de l'exception C ++ peut parfois √™tre co√ªteuse, nous avons d√©cid√© d'utiliser des exceptions au lieu de codes d'erreur. </p><br><p>  Nous avons eu une exp√©rience n√©gative avec les codes d'erreur dans SObjectizer-4, o√π les exceptions n'√©taient pas utilis√©es.  Cela a conduit √† l'ignorance des erreurs dans le code d'application et parfois des actions importantes n'ont pas √©t√© effectu√©es en raison d'une erreur lors de la cr√©ation d'une nouvelle coop√©rative ou de l'envoi d'un message.  Mais cette erreur a √©t√© ignor√©e et ce fait a √©t√© d√©couvert beaucoup plus tard. </p><br><p>  L'utilisation d'exceptions C ++ dans SObjectizer-5 permet d'√©crire du code plus correct et plus robuste.  Dans des cas habituels, les exceptions sont lev√©es tr√®s rarement par SObjectizer, de sorte que l'utilisation d'exceptions n'a aucun impact n√©gatif sur les performances de SObjectizer ou les performances des applications √©crites par-dessus SObjectizer. </p><br><h2 id="no-support-for-distributed-applications-out-of-box">  Pas de support pour les applications distribu√©es "out of box" </h2><br><p>  SObjectzer-5 n'a pas de support int√©gr√© pour les applications distribu√©es.  Cela signifie que SObjectizer distribue des messages juste √† l'int√©rieur d'un processus.  Si vous devez organiser la distribution de messages inter-processus ou inter-notes, vous devez int√©grer une sorte de IPC dans votre application. </p><br><p>  Ce n'est pas parce que nous ne pouvons pas impl√©menter une forme d'IPC dans SObjectizer.  Nous l'avions d√©j√† dans SObjectizer-4.  Et parce que nous avons une telle exp√©rience, nous avons d√©cid√© de ne pas le faire dans SObjectizer-5.  Nous avons appris qu'il n'y a pas un seul type d'IPC qui s'adapte parfaitement √† diff√©rentes conditions. </p><br><p>  Si vous souhaitez avoir une bonne communication inter-n≈ìuds dans votre application, vous devez s√©lectionner les protocoles sous-jacents appropri√©s.  Par exemple, si vous devez diffuser des millions de petits paquets avec des donn√©es de courte dur√©e (comme la distribution de la mesure des conditions m√©t√©orologiques actuelles), vous devez utiliser un IPC.  Mais si vous devez transf√©rer d'√©normes BLOB (comme des flux vid√©o 4K / 8K ou des archives contenant des donn√©es financi√®res √† l'int√©rieur), vous devez utiliser un autre type IPC. </p><br><p>  Et nous ne parlons pas d'interop√©rabilit√© avec des logiciels √©crits dans diff√©rentes langues ... </p><br><p>  Vous pouvez croire qu'un certain ¬´cadre d'acteur¬ª universel peut vous fournir un IPC qui conviendra √† diff√©rentes conditions.  Mais nous savons que ce ne sont que des conneries de marketing.  Notre exp√©rience nous montre qu'il est beaucoup plus simple et beaucoup plus s√ªr d'ajouter l'IPC dont vous avez besoin dans votre application, puis de s'appuyer sur les id√©es, les besoins et les connaissances des auteurs d'un "framework d'acteur" tiers. </p><br><p>  SObjectizer permet d'incorporer diff√©rents types d'IPC sous la forme de mbox personnalis√©es.  Cela permet donc de cacher le fait de la distribution des messages sur un r√©seau aux utilisateurs d'un SObjectizer. </p><br><h1 id="instead-of-the-conclusion">  Au lieu de la conclusion </h1><br><p>  Le framework SObjectizer n'est pas un grand, mais ce n'est pas un petit.  Il est donc impossible de donner au lecteur une impression assez profonde sur SObjectizer dans un seul aper√ßu.  Pour cette raison, nous vous invitons √† jeter un ≈ìil au projet SObjectizer. </p><br><p>  SObjectizer lui-m√™me vit sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GitHub</a> .  Il y a le Wiki du projet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GitHub</a> et nous vous recommandons de commencer √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SObjectizer 5.6 Basics</a> , puis d'aller aux articles de la s√©rie approfondie.  Pour ceux qui veulent aller plus loin, nous pouvons recommander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Regardons sous la</a> section <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">hotte de SObjectizer</a> . </p><br><p>  Si vous avez des questions, vous pouvez nous les poser dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">le groupe SObjectizer</a> sur les groupes Google. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458202/">https://habr.com/ru/post/fr458202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458168/index.html">Sommaire des actualit√©s de l'apprentissage automatique et de l'intelligence artificielle de juin</a></li>
<li><a href="../fr458176/index.html">La barri√®re des exaflops sera franchie en 2021</a></li>
<li><a href="../fr458180/index.html">Serveur DHCP de basculement bas√© sur Kea</a></li>
<li><a href="../fr458186/index.html">WAL dans PostgreSQL: 1. Cache tampon</a></li>
<li><a href="../fr458188/index.html">Comment j'ai fait un r√©seau social en 2019</a></li>
<li><a href="../fr458204/index.html">Comment √©valuer les performances de stockage sur Linux: analyse comparative √† l'aide d'outils ouverts</a></li>
<li><a href="../fr458206/index.html">Sublime Text 3 pour la mise en page du site. Personnalisez l'apparence et installez les plugins. Guide du d√©butant</a></li>
<li><a href="../fr458208/index.html">√âv√©nements num√©riques √† Moscou du 01 juillet au 07 juillet</a></li>
<li><a href="../fr458218/index.html">Chirurgie maxillo-faciale ou pas? Telle est la question</a></li>
<li><a href="../fr458222/index.html">Briser un jeu de m√©moire: toute une histoire de d√©tective</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>