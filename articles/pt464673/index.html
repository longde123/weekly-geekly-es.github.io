<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🃏 👩🏾‍🤝‍👩🏼 👋🏾 TinyFL - driver de lanterna de microcontrolador 🔘 💇🏾 ✊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr! 


 Quero contar uma história sobre como entrei nas mãos de um farol chinês em um LED Cree XM-L e o que aconteceu a seguir. 



 Antecedentes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TinyFL - driver de lanterna de microcontrolador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464673/"><p>  Oi Habr! </p><br><p>  Quero contar uma história sobre como entrei nas mãos de um farol chinês em um LED Cree XM-L e o que aconteceu a seguir. </p><br><p><img src="https://habrastorage.org/webt/ec/vx/uq/ecvxuq8hlp8-x_b6iacutkxyrmo.jpeg"></p><a name="habracut"></a><br><h2 id="predystoriya">  Antecedentes </h2><br><p>  Era uma vez, eu pedi uma lanterna com um LED brilhante de um site chinês.  A lanterna acabou sendo bastante ergonômica (embora pudesse ser mais fácil), mas seu motorista deixou muito a desejar. </p><br><p>  Brilhou bastante, mas o motorista tinha apenas três modos - muito brilhante, brilhante e estroboscópico, alternando entre os quais era feito com o toque de um botão.  Para ligar e desligar a lanterna, era necessário selecionar esses três modos de cada vez.  Além disso, essa lanterna, quando ligada, descarregou a bateria até o fim - então um par de minhas 18650 latas entrou em descarga profunda. </p><br><p>  Tudo isso era desconfortável e irritante, então, em algum momento, decidi fazer o meu motorista para isso, que será a história seguinte. </p><br><div class="spoiler">  <b class="spoiler_title">Lanterna com um driver antigo</b> <div class="spoiler_text"><p>  <em>Aqui está uma lanterna, provavelmente muitos já lidaram com</em> <br><img src="https://habrastorage.org/webt/lp/8j/cy/lp8jcyodmsrehdop-qawqouaw-g.jpeg"></p><br><p>  <em>Parece que o driver original</em> <br><img src="https://habrastorage.org/webt/g-/cr/-w/g-cr-w88dmljau5oknxtpcxbrmu.jpeg"></p></div></div><br><h2 id="tehnicheskoe-zadanie">  Termos de Referência </h2><br><p>  Como você sabe, para obter um bom resultado, qualquer desenvolvimento deve ter boas especificações técnicas, por isso tentarei formulá-lo por mim mesmo.  Portanto, o motorista deve: </p><br><ul><li>  Para poder ligar / desligar pressionando rapidamente um botão (um botão sem fixação).  Talvez essa seja a principal razão pela qual tudo isso começou. </li><li>  Tenha um controle de brilho suave (contínuo), desde o mais brilhante - "turbo" até "luar" quando o diodo estiver pouco iluminado.  O brilho deve mudar uniformemente. </li><li>  Lembre-se do brilho definido para o tempo livre. </li><li>  Monitore a carga da bateria, avisando quando estiver quase descarregada (cerca de 3,3V) e desligando quando estiver completamente descarregada (cerca de 2,9V).  Para baterias diferentes, esses parâmetros podem ser diferentes.  Consequentemente, a tensão operacional deve estar na faixa de 2,7 a 4,5V. </li><li>  Tem 2 modos especiais - farol de emergência e estroboscópio (bem, por que não?) </li><li>  Para poder ligar / desligar o LED traseiro (isso é verdade ao andar de bicicleta à noite, é algo como uma luz indicadora). </li><li>  Tenha proteção contra polaridade reversa e eletricidade estática.  Não necessariamente, mas será uma boa adição, porque no escuro você pode colocar a bateria do lado errado. </li><li>  Seja menor que o tamanho do driver original, mas tenha a mesma pegada.  O motorista chinês é simplesmente enorme, tornando-o maior não será fácil. </li></ul><br><p>  Bem, se a lanterna estiver modificada, por que não montar um carregador com um conector micro-USB?  Eu sempre tenho um cabo e um carregamento USB à mão e preciso procurar uma fonte de alimentação nativa. </p><br><h2 id="zhelezo">  Ferro </h2><br><p>  Eu tenho alguma experiência com o Arduino, por isso foi decidido fazer um driver na família AVR MK.  Eles são amplamente disponíveis, fáceis de programar e têm modos de baixo consumo de energia (suspensão). </p><br><p>  O microcontrolador Attiny13a foi escolhido como o "cérebro" do motorista - é um dos Atmel MCs mais baratos (agora absorvidos pelo Microchip), tem tudo a bordo - um GPIO para conectar um botão e um LED, um temporizador para gerar um sinal PWM, um ADC para medir tensão e EEPROM para salvar os parâmetros.  Apenas 1 KB de memória flash está disponível (mas quanto é necessário para uma lanterna), além de 64 B de RAM e a mesma quantidade de EEPROM. <br>  O Attiny13 está disponível em várias opções de caixa, em particular no DIP-8, que podem ser inseridas diretamente em uma tábua de pão regular com um passo de 2,54 mm. </p><br><p>  Como apenas 3 fios vão da parte de trás à cabeça da lanterna, o botão é forçado a encurtar até o chão (sobre a impossibilidade de encurtar para mais - mais tarde), você terá que ligar o LED mais - o que significa que você precisa de um poste de canal P.  Eu peguei o AO3401 como um transistor, mas você pode usar o SI2323, é mais caro, mas tem menos resistência de canal aberto (40 mOhm, enquanto o AO3401 tem 60 mOhm, a 4,5 V), portanto, o driver aquece menos. </p><br><p>  <em>Das palavras às ações, coleciono em uma tábua de pão uma versão preliminar</em> <br><img src="https://habrastorage.org/webt/6g/tx/89/6gtx89n9apulzr9kwouv9v-vkn8.jpeg"></p><br><p>  Atualmente, ele é alimentado diretamente pelo programador, com uma tensão de 5 V (na verdade menor devido a perdas no cabo USB).  Em vez do LED, o XM-L até o momento colocou um LED regular nas pernas e colocou um transistor fraco com uma tensão de limiar alta. <br>  Em seguida, no programa Altium Designer, foi desenhado um diagrama, que eu suplementei com proteção contra polaridade reversa e ESD. </p><br><p><img src="https://habrastorage.org/webt/nt/cv/re/ntcvrepefjh36tyfclmcwze_e4o.png"></p><br><div class="spoiler">  <b class="spoiler_title">Descrição detalhada e finalidade de todos os componentes</b> <div class="spoiler_text"><h4 id="obyazatelnye-komponenty">  Pré-requisitos: </h4><br><p>  U1 - Microcontrolador Attiny13a no pacote 8S1 (índice SSU) </p><br><p>  C1 - capacitor de desacoplamento para alimentação do microcontrolador, deve estar na região de 0,1 microfarads, caso 1206 ou 0805, coeficiente de temperatura X7R </p><br><p>  R1-R2 é um divisor de resistor para medir a tensão da bateria, qualquer classificação pode ser definida, aqui a relação principal (750K / 220K, relação de divisão 4,41) e a corrente de fuga, que será maior se as classificações forem aumentadas (na corrente é de cerca de 4 μA).  Como um ION interno é usado (1,1 V, de acordo com a folha de dados, pode estar entre 1,0 V - 1,2 V), a tensão máxima na saída do divisor não deve ser maior que 1 V. Com um divisor 750/220, a tensão máxima permitida na entrada do divisor será de 4,41 V, o que mais do que suficiente para todos os tipos de baterias de lítio. <br>  Eu calculei o divisor usando esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">calculadora</a> . </p><br><p>  R3 - protege a saída da porta do microcontrolador de um curto-circuito (se PB1 for repentinamente puxado para o VCC, uma grande corrente fluirá através do pino e o MC poderá queimar) </p><br><p>  R4 - puxar o RESET MK para ligar, sem ele, é possível reiniciar a partir de captadores. </p><br><p>  Q1 - Transistor de efeito de campo de canal P no pacote SOT-23, instalei o AO3401, mas qualquer outro com uma pinagem adequada (por exemplo, SI2323) </p><br><p>  R7 é um resistor limitador de corrente.  Como a porta do transistor possui uma certa capacidade, ao carregar essa capacidade, uma grande corrente pode passar através do pino e o pino pode falhar.  Você pode configurá-lo na região de 100-220 Ohms (não deve mais ser, o transistor começará a ficar em um estado semi-fechado por um longo tempo e, como resultado, aquecerá mais). </p><br><p>  R6 - obturador do resistor para alimentação.  No caso de PB0 entrar em um estado de alta impedância, a lógica 1 será instalada através desse resistor na porta Q1 e o transistor será fechado.  Isso pode ocorrer devido a um erro no código ou no modo de programação. </p><br><p>  D2 - diodo "travado" - permite que a tensão "caia" (quando o LED acende por um curto período para brilho total) para alimentar o MK do capacitor por um tempo, mas também protege contra polaridade reversa. <br>  Você pode colocar qualquer diodo Schottky no pacote SOD323 com uma queda de tensão mínima, coloquei BAT60. </p><br><p>  Inicialmente, a proteção contra polaridade reversa da fonte de alimentação era feita no transistor de efeito de campo (isso pode ser visto nas placas feitas por pilhagem).  Um recurso desagradável surgiu após a fiação - quando a carga foi ligada, ocorreu uma queda de tensão e o MK reiniciou, pois o trabalhador de campo não limita a corrente na direção oposta.  No começo, soldei um capacitor eletrolítico de 200 uF entre o VCC e o GND, mas não gostei dessa solução devido ao seu tamanho.  Eu tive que soldar o transistor e colocar um diodo em seu lugar, pois o SOT-23 e o SOD-323 têm dimensões semelhantes. </p><br><p>  Total, no circuito, existem apenas 10 componentes necessários para a instalação. </p><br><h4 id="neobyazatelnye-komponenty">  Componentes opcionais: </h4><br><p>  R5 e D1 são responsáveis ​​pela luz de fundo (LED2).  A classificação mínima de R5 é 100 ohms.  Quanto maior a classificação, mais fraco o LED traseiro fica aceso (acende no modo constante, sem PWM).  D1 - qualquer LED no caso 1206, eu coloquei verde, porque  visualmente eles são mais brilhantes nas mesmas correntes do que outros. </p><br><p>  D3 e D4 são diodos de proteção (TVS), usei PESD5V0 (5.0V) no pacote SOD323.  D3 protege contra sobretensão por energia, D4 - por um botão.  Se o botão estiver coberto por uma membrana, não haverá um significado especial nela.  Provavelmente vale a pena usar diodos de proteção bidirecionais; caso contrário, quando a polaridade for revertida, a corrente fluirá através deles e eles queimarão (consulte o CVC de um diodo de proteção bidirecional). </p><br><p>  C2 - um capacitor de tântalo no caso A (semelhante a 1206), faz sentido configurá-lo quando o driver estiver instável (a tensão de alimentação pode ser comprimida nas altas correntes de comutação do LED) </p><br><p>  Todos os resistores do tamanho 0603 (para mim, esse é um limite adequado para solda manual) </p></div></div><br><p>  Tudo está claro com os componentes, você pode fazer uma placa de circuito impresso de acordo com o esquema acima. <br>  A primeira coisa a fazer é construir um modelo 3D da futura placa, juntamente com os furos - IMHO, no Altium Designer, esta é a maneira mais conveniente de determinar a geometria da PCB. <br>  Eu medi as dimensões do driver antigo e seus orifícios de montagem - a placa deve ser anexada a eles, mas com dimensões menores (para versatilidade, de repente você precisa construí-la em outro lugar). <br>  Um mínimo razoável aqui ficou em torno de 25x12,5 mm (proporção 2: 1), com dois orifícios com um diâmetro de 2 mm para fixação na carcaça da lâmpada com parafusos nativos. </p><br><p>  Fiz um modelo 3D no SolidWorks e depois exportei para o Altium Designer como STEP. <br>  Depois coloquei os componentes na placa, fiz os contatos nos cantos (é mais conveniente e mais fácil soldar o chão), Attiny13 colocado no centro, o transistor mais próximo dos contatos do LED. <br>  Espalhei as faixas de força, coloquei os componentes restantes e separamos as faixas de sinal.  Por conveniência de conectar a memória, criei contatos separados, que duplicam os contatos da bateria. <br>  Fiz toda a fiação (com exceção de um jumper) na camada superior - para poder fazer uma placa em casa com o LUT. <br>  A largura mínima dos caminhos do sinal é de 0,254 mm / 10 mil; os de potência têm largura máxima sempre que possível. </p><br><p>  <em>É assim que a placa com fio fica no Altium Designer</em> <br><img src="https://habrastorage.org/webt/yu/i4/bo/yui4bosmzwqjagvmj_clljr09ck.png"></p><br><p>  O Altium Designer tem a oportunidade de ver como a placa ficará em 3D (para isso, você precisa de modelos para todos os componentes, alguns dos quais você teve que construir por conta própria). <br>  Talvez alguém aqui diga que o modo 3D não é necessário para o rastreador, mas, para mim, pessoalmente, é uma função conveniente que facilita a colocação de componentes para facilitar a soldagem. </p><br><p><img src="https://habrastorage.org/webt/my/jk/1r/myjk1rvgvm50odtu4iy77czuy3i.png"></p><br><p>  No momento da redação deste artigo, foram feitas três versões do quadro - a primeira para LUT, a segunda para fabricação industrial e a terceira final com algumas correções. </p><br><h2 id="izgotovlenie-plat">  Tomada de placa </h2><br><h3 id="samodelnyy-sposob">  Maneira caseira </h3><br><p>  LUT - tecnologia de passar a laser, um método para produzir placas de circuito usando gravura em uma máscara obtida pela conversão de toner de papel em cobre.  Esse método é ótimo para placas simples de um lado, como este driver. <br>  A rede possui muitos artigos sobre essa tecnologia, portanto não entrarei em detalhes, mas apenas mostrarei brevemente como faço. </p><br><p>  Primeiro, você precisa preparar um modelo que será impresso em papel térmico.  Eu exporto a camada top_layer para PDF, recebo uma imagem vetorial. </p><br><p><img src="https://habrastorage.org/webt/lq/f3/dm/lqf3dmub3ivxcx3y32uijk9dy2a.png"></p><br><p>  Como a placa é pequena, faz sentido pegar um pedaço de PCB com dimensões várias vezes maiores e fazer o que a indústria chama de painéis. <br>  Para esses fins, o CorelDraw é muito conveniente, mas você pode usar qualquer outro editor de vetores. <br>  Coloco cópias dos modelos no documento, faço intervalos de 0,5 a 1 mm entre as placas (depende do método de separação, mais adiante), as placas devem estar localizadas simetricamente - caso contrário, será difícil separá-las. </p><br><p>  Pego um pedaço de PCB unilateral com dimensões ligeiramente maiores que o painel montado, limpo e desengordurante (prefiro esfregar com uma borracha e depois com álcool).  Imprimo um modelo para gravar em papel térmico (aqui é importante não esquecer de espelhar o modelo). <br>  Com a ajuda de um ferro e a paciência, afagando suavemente no papel, eu o traduzo para textolite.  Espero até esfriar e, com cuidado, retiro o papel. <br>  Áreas livres de cobre (não revestidas com toner) podem ser envernizadas ou coladas (quanto menor a área de cobre, mais rápida será a reação de ataque). </p><br><p>  <em>Um painel tão doméstico - um grande número de placas pode compensar defeitos de fabricação</em> <br><img src="https://habrastorage.org/webt/ob/f-/fk/obf-fkjp7lq5fcrxrr_x7rprgw8.jpeg"></p><br><p>  Veneno as placas com ácido cítrico em uma solução de peróxido de hidrogênio, essa é a maneira mais acessível, embora seja bastante lenta. <br>  As proporções são as seguintes: para 100 ml de peróxido a 3% são 30 g de ácido cítrico e cerca de 5 g de sal, tudo é misturado e vertido em um recipiente com textolito. <br>  O aquecimento da solução acelerará a reação, mas poderá causar a descolagem do toner. </p><br><p>  <em>Magia química desconhecida começa: o cobre é coberto por bolhas e a solução assume uma tonalidade azul</em> <br><img src="https://habrastorage.org/webt/bc/jh/pz/bcjhpzjgqcrcmqq1wr8j_def1yw.jpeg"></p><br><p>  Depois de algum tempo, pego a placa gravada e limpo o toner.  Como não consigo lavá-lo com solventes, removo-o mecanicamente com papel de esmeril de grão fino. </p><br><p>  Agora resta estanhar a placa - isso ajudará na solda e protegerá o cobre da oxidação e facilitará a solda.  Prefiro estanhar com a liga Rose - essa liga derrete a uma temperatura de cerca de 95 graus, o que permite que seja estanhada em água fervente (sim, talvez não seja a composição mais confiável para estanhar, mas para placas de circuito caseiras). </p><br><p><img src="https://habrastorage.org/webt/a5/fs/lk/a5fslka8zacdyhd2mrfad4irlx0.jpeg"></p><br><p>  Após estanhar, perfuro uma prancha (para contatos, uso brocas de metal duro f1.0, para jumpers - f0.7), perfuro com uma dremel por falta de outra ferramenta.  Não gosto de cortar textólito por causa da poeira, portanto, após a perfuração, corto as tábuas com uma faca de escritório - em ambos os lados faço vários cortes em uma linha e depois a corto.  Isso lembra o método de corte em V usado na indústria, apenas há uma incisão feita por um moinho. </p><br><p>  <em>Parece uma placa pronta para soldar</em> <br><img src="https://habrastorage.org/webt/xw/3v/6n/xw3v6ns0nrje-n8saj5gobrvces.jpeg"></p><br><p>  Quando a placa estiver pronta, você poderá começar a conectar os componentes.  Primeiro, soldo um pouco (resistores 0603), depois tudo o mais.  Como os resistores são adjacentes ao MK, a soldagem na ordem inversa pode ser problemática.  Após a solda, verifico se há um curto-circuito na alimentação do driver, após o qual já é possível iniciar o firmware MK. </p><br><p>  <em>Drivers prontos para baixar o firmware</em> <br><img src="https://habrastorage.org/webt/4u/au/jk/4uaujk48pqllmzplxcxuy_yfig8.jpeg"></p><br><h3 id="promyshlennyy-sposob">  Maneira industrial </h3><br><p>  O LUT é rápido e acessível, mas a tecnologia tem suas desvantagens (como quase todos os métodos de fabricação de PP “domésticos”).  É problemático fazer uma placa de dupla face, as faixas podem ser gravadas e você só pode sonhar em metalizar os orifícios. </p><br><p>  Felizmente, os empreendedores chineses há muito oferecem serviços para a fabricação de placas de circuito impresso de forma industrial. <br>  Curiosamente, uma placa de camada única chinesa custará mais do que uma placa de duas camadas, então decidi adicionar uma segunda camada (inferior) à placa de circuito impresso.  Os caminhos de energia e o solo são duplicados nessa camada.  Além disso, tornou-se possível fazer um dissipador de calor a partir do transistor (polígonos de cobre na camada inferior), o que permitirá ao motorista trabalhar em correntes mais altas. </p><br><p>  <em>A camada inferior do quadro no Altium Designer</em> <br><img src="https://habrastorage.org/webt/x0/hf/b9/x0hfb9uk6flm6d7pat30fzm9lyu.png"></p><br><p>  Para este projeto, decidi pedir uma placa de circuito impresso no site da PcbWay.  O site possui uma calculadora conveniente para calcular o custo das placas, dependendo de seus parâmetros, tamanhos e quantidade.  Após calcular o custo, baixei o arquivo gerber criado anteriormente no Altium Designer, os chineses o verificaram e a placa foi para a produção. </p><br><p>  Fazer um conjunto de 10 placas TinyFL me custou US $ 5.  Ao registrar um novo usuário, um desconto de US $ 5 é concedido no primeiro pedido, por isso paguei apenas pelo frete, que também custa algo em torno de US $ 5. <br>  Nesse site, há a oportunidade de colocar o projeto em domínio público; portanto, se alguém quiser solicitar esses painéis, você pode simplesmente adicionar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse projeto</a> à cesta. </p><br><p>  Depois de algumas semanas, as mesmas diretorias vieram até mim, apenas <del>  bonita </del>  fabricado industrialmente.  Eles só podem ser descompactados e preenchidos com o firmware. </p><br><p><img src="https://habrastorage.org/webt/lp/j7/jk/lpj7jktyacb_h-atbtpze-9qzcw.jpeg"></p><br><h2 id="programma-proshivka">  Programa (firmware) </h2><br><p>  A principal dificuldade que surgiu ao escrever o firmware do driver, está associada ao tamanho extremamente pequeno da memória flash - o Attiny13 possui apenas 1024 bytes. <br>  Além disso, como a mudança de brilho é suave, uma tarefa não trivial era alterá-la uniformemente - para isso, tivemos que fazer a correção gama. </p><br><h4 id="algoritm-upravleniya-drayverom">  Algoritmo de controle do motorista </h4><br><p>  O motorista liga com um breve toque no botão, e desliga por ele. <br>  O modo de brilho selecionado é armazenado durante o desligamento. </p><br><p>  Se durante a operação você pressionar duas vezes um botão (clique duplo), o LED adicional será ligado / desligado. <br>  Com uma pressão longa durante a operação, o brilho da lâmpada muda gradualmente.  Pressionar repetidamente muda de direção (mais forte / mais fraco). </p><br><p>  O driver verifica periodicamente a voltagem da bateria e, se for menor que os valores definidos, avisa o usuário sobre uma descarga e depois desliga para evitar uma descarga profunda. </p><br><div class="spoiler">  <b class="spoiler_title">Uma descrição mais detalhada do algoritmo do driver</b> <div class="spoiler_text"><ol><li>  Quando a energia é fornecida ao MK, os periféricos são configurados e o MK entra em suspensão (se STARTSLEEP estiver definido).  Quando a energia é fornecida ao driver, os dois LEDs piscam um certo número de vezes se STARTBLINKS estiver definido. </li><li>  Dormir  Attiny13 adormece no modo de desligamento (este é o modo mais econômico, de acordo com a folha de dados, o consumo de MK será de ~ 1 μA), do qual só pode sair por qualquer interrupção.  Nesse caso, é uma interrupção INT0 - pressionando um botão (configurando PC1 para 0 lógico). <br>  No PC1, uma flexão interna fraca deve ser ativada.  O ADC e o comparador são os principais consumidores de corrente de toda a periferia e, portanto, também precisam ser desligados.  Durante o sono, o conteúdo dos registradores e da RAM é armazenado; portanto, a EEPROM não é necessária para lembrar o brilho. </li><li>  Após o sono, os periféricos e o PWM são ligados e o driver entra em um ciclo sem fim, no qual o botão é monitorado e a voltagem da bateria é verificada periodicamente. </li><li>  Se o botão for pressionado, a hora é pressionada. <br>  4.1  Se a pressão for curta, é esperado um clique duplo (se BTN_DBCLICK estiver definido). <br>  Se fosse, os comutadores LED2 adicionais <br>  Caso contrário, vá para o passo 2 (suspensão) <br>  4.2  Se a pressão for longa (maior que BTN_ONOFF_DELAY) - o modo de controle de brilho será ativado.  Neste modo: <br><ul><li>  A direção da mudança é invertida (mais / menos) e a% de preenchimento PWM muda enquanto o botão é pressionado. </li><li>   /  (RATE_MAX / RATE_MIN),   ; </li><li>   n- (AUXMODES_DELAY)     ,   .    —  (   25 ,  8 )    (     50,  1 ).        ,     -    . </li></ul></li><li>       —    ADC2,     . <br><ul><li>      BAT_WARNING –   </li><li>   BAT_WARNING –    ,    . -     . ,         5 . </li><li>   BAT_SHUTDOWN —    .2 (). </li></ul></li></ol></div></div><br><h4 id="upravlenie-yarkostyu-svetodioda">    </h4><br><p>  ,      —   ,     -     ,  . -    ,     ,       .     P-  ,        ,    — ,  .               . <br>      rate, 255 rate = 100% . <br>    1.2      1,     1200000/256 = 4.7 .     (  ),         (,   ,  ,   ).  ,      9.6 (CKSEL[1:0]=10, CKDIV8=1)  4.8  (CKSEL[1:0]=01, CKDIV8=1),      8   4  ,       . </p><br><p> ,         ,         .     ,      (      )      ,         ,  ,               1.5 ,   2        (   Cree XM-L   — 3 ). <br>               ,     (rate=255)     3.          ,        .   ,    RATE_MAX     .   ,     SI2323DS      4 ,     2 ,     . </p><br><h4 id="gamma-korrekciya"> - </h4><br><p>      .     ,   5-10%       ,     75-100%      .     ,   n   ,  ,            ,        . </p><br><p>   ,          -.    ,       1      12   .       ,      rate_step_array.  , ,       . </p><br><h4 id="kontrol-napryazheniya-batarei">    </h4><br><p>  n- (      BAT_PERIOD)    .   ,    VIN      R1-R2,       PB4 (  ADC2   ). </p><br><p>        ,    ,      Vref,          1.1 .        —     ,      (,  1.1       1023  255,   8- ).   ,        6   ,  255     1.1 ,   4.33  (  4.03),      . </p><br><p>     ,        .    BAT_WARNING       (  ,    —    BAT_INFO_STEP,   ),    BAT_SHUTDOWN  . <br>         , ..    ,      . </p><br><p> ,     ,      . ,   4.03  R1 = 1M  R2 = 330,    R = 1330K     4  = 3 . <br>      ()    1 .      ,    ,     (  -       —  ). </p><br><h4 id="vnesenie-izmeneniy-v-proshivku">     </h4><br><p>   ,       Arduino    C/C++. <br>      ,          (defines)   flashlight.h. <br>        Arduino IDE   Attiny13(a)  Atmel Studio –   ,  Arduino IDE,   . </p><br><div class="spoiler"> <b class="spoiler_title">Arduino IDE</b> <div class="spoiler_text"><p>      Attiny13  IDE.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br>      Tools&gt;Board Attiny13(a)    Tools&gt;Frequency 1.2MHz. <br> ""      .ino,       —      .   ,   —      Arduino IDE.       - ,    .cpp. <br>       ,  ,          *.hex.        . </p></div></div><br><div class="spoiler"> <b class="spoiler_title">Atmel Studio</b> <div class="spoiler_text"><p>    IDE    flashlight.atsln,   —   flashlight.h   ()  flashlight.cpp   . <br>         —    . <br>        F7,   ( ,   ,  ).   debug  flashlight.hex,        . </p></div></div><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><p>          USBASP     AVRDUDEPROG.      GUI   avrdude,      —      .       (   Attiny13(a),    Fuses    read.   ,      ,   .     programm,      .       flashlight.h </p><br><p> Para fazer upload do firmware, vá para a guia Programa, selecione o arquivo de firmware compilado no formato HEX (flashlight.hex) na linha Flash e clique em Programa.  O status do firmware será exibido na janela abaixo.  Se o download não for bem-sucedido, pode ser um mau contato, acontece. Vale a pena tentar novamente.  A propósito, por esse motivo, o parâmetro STARTBLINKS foi estabelecido - um único piscar de LED2 no momento de fornecer energia ao motorista serve como uma indicação do contato do motorista com o programador. <br>  Em vez do USBASP, você pode usar o Arduino para baixar o firmware, mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </p><br><p>  <em>Programador USBASP conectado ao driver através de um clipe com um loop</em> <br><img src="https://habrastorage.org/webt/7f/b2/sy/7fb2syr5zqnwqejhoqpxqqa_-vw.jpeg"></p><br><p>  Para conectar o USBASP a um tinka, eu uso um clipe para um SOIC de 8 pinos.  Não é um dispositivo muito conveniente, você precisa atormentar 10 minutos antes de capturar o contato (talvez eu tenha encontrado um clipe com defeito).  Também existem adaptadores SOIC-DIP nos quais o microcircuito é inserido antes da soldagem e o firmware é derramado - essa opção é mais conveniente, mas a capacidade de programar o circuito do driver é perdida (ou seja, atualiza o firmware após a soldagem do MK na placa). <br>  Se tudo isso não estiver lá, você poderá simplesmente soldar os fios nos terminais do MK, que serão conectados ao Arduino. </p></div></div><br><h4 id="kalibrovka">  Calibração </h4><br><p>  As correntes que passam pelo driver e pelo LED não devem exceder os valores máximos.  Para o LED XM-L, isso é 3 A, para o driver depende do transistor usado, por exemplo, para SI2323, a corrente máxima é de cerca de 4 A, mas é melhor operar em correntes mais baixas devido ao aquecimento excessivo.  Para reduzir a corrente com brilho máximo, é usado o parâmetro RATE_MAX (#define RATE_MAX xx, em que xx é o brilho máximo de 0 a 255). <br>  A calibração do ADC não é um procedimento obrigatório, mas se você deseja que o driver monitore com precisão a tensão limite, será necessário mexer nela. </p><br><p>  Os cálculos não fornecerão alta precisão das medições, pois, primeiro, os resistores podem variar dentro da tolerância (geralmente de 1 a 5%) e, segundo, o íon interno pode ter uma dispersão de 1,0 a 1,2 V. <br>  Portanto, a única maneira aceitável é definir o valor nas unidades ADC (BAT_WARNING e BAT_SHUTDOWN), selecionando-o experimentalmente para o desejado.  Para fazer isso, você precisará de paciência, um programador e uma fonte de energia ajustável. <br>  Defino o valor BAT_PERIOD como 1000 no firmware (verificando a tensão uma vez por segundo) e reduzi gradualmente a tensão de alimentação.  Quando o motorista começou a avisar sobre a descarga, deixei o valor atual de BAT_WARNING conforme necessário. <br>  Essa não é a maneira mais conveniente, talvez no futuro você precise executar um procedimento de calibração automática salvando os valores na EEPROM. </p><br><h2 id="sborka-fonarika">  Lanterna de montagem </h2><br><p>  Quando a placa estiver pronta e o firmware inundado, você poderá finalmente colocá-la no lugar do driver antigo.  Tirei a solda do driver antigo e soldei um novo em seu lugar. </p><br><div class="spoiler">  <b class="spoiler_title">O novo driver está conectado em vez do antigo, de acordo com este esquema</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ar/7c/6j/ar7c6jgy4zprzi6crl9aogualo8.png"></p></div></div><br><p>  Depois de verificar se havia um curto-circuito na fonte de alimentação, conectei a fonte de alimentação e verifiquei a operabilidade.  Depois montei a placa de carregamento (TP4056), para isso tive que fazer um furo no conector de carregamento com um pouco de dremel e fixá-lo com cola quente (era importante que a cola não caísse no conector, seria difícil tirá-lo dali). </p><br><p>  Não prendi a placa com parafusos, porque a rosca do estojo quebrou devido a torções repetidas, mas simplesmente derramou cola sobre ela, também colou os fios nos locais de solda para que não se desgastassem.  Decidi cobrir o motorista e o carregador com verniz acrílico incolor, isso deve ajudar contra a corrosão. </p><br><p><img src="https://habrastorage.org/webt/5g/qs/do/5gqsdoxgldinymg3njvlpsmnxz8.jpeg"></p><br><h2 id="testirovanie-i-raschet-stoimosti-izgotovleniya">  Teste e cálculo de custos de fabricação </h2><br><p>  Após todas as operações, foi possível começar a testar os drivers.  A corrente foi medida com um multímetro convencional, conectando-o ao circuito aberto da fonte de alimentação. </p><br><p>  Consumo de energia do driver antigo (medido em 4,04 V): </p><br><ol><li>  Durante o sono - não medido </li><li>  Modo máximo: 0,60 A </li><li>  Modo médio: 0,30 A </li><li>  Estroboscópio: 0,28 A </li></ol><br><p>  Consumo de energia do novo driver (medido em 4,0 V): </p><br><ol><li>  No modo de suspensão, consome cerca de 4 μA, o que é muito menor do que a corrente de descarga automática de uma bateria de íons de lítio.  A corrente principal neste modo flui através de um divisor de resistor. </li><li>  No modo mínimo, o “luar” é de cerca de 5-7 mA, se assumirmos que a capacidade de uma célula 18650 é de cerca de 2500 mA * h, obteremos cerca de <strong>20 dias de operação contínua</strong> .  O próprio MK consome em algum lugar de 1,2 a 1,5 mA (a uma frequência operacional de 1,2 MHz). </li><li>  No modo máximo, "turbo" - consome cerca de 1,5 A; nesse modo, ele funciona por cerca de uma hora e meia.  O LED nessas correntes começa a ficar muito quente; portanto, este modo não se destina à operação a longo prazo. </li><li>  Farol de emergência - consome uma média de cerca de 80 mA; nesse modo, a lanterna funciona até 30 horas. </li><li>  Estroboscópio - consome cerca de 0,35 A, trabalha até 6 horas. </li></ol><br><h4 id="cena-voprosa">  Preço de emissão </h4><br><p>  Se você comprar componentes no Chip e Deep, serão produzidos cerca de 100 rublos (60 rublos Attiny13, ~ 40 rublos no restante do pó solto).  Faz sentido encomendar da China, se várias peças forem feitas - então, em termos de uma peça, será mais barato, os chineses geralmente vendem em lotes de 10 peças ou mais. <br>  As taxas serão liberadas a um preço na região de 300 rublos por 10 peças (sem entrega), se encomendadas na China. <br>  A fiação e piscando um driver leva cerca de uma hora. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  A lanterna chinesa se tornou muito mais conveniente, embora agora eu tenha reclamações sobre sua mecânica - a parte frontal é muito pesada e o foco não é realmente necessário. <br>  No futuro, pretendo fazer uma versão desse driver para lanternas com um botão liga / desliga (com fixação).  É verdade que estou confuso com a abundância de tais projetos.  Você acha que vale a pena fazer outro? </p><br><p>  <em>Driver de close-up (versão 2_t)</em> <br><img src="https://habrastorage.org/webt/2f/sd/sl/2fsdslzywcu7izjgclyshshwjvy.jpeg"></p><br><p>  <strong>UPD</strong> : Adicionado suporte para o Arduino IDE. </p><br><p>  O código fonte do firmware, o circuito e a fiação da placa estão agora no github, você pode baixá-lo aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/madcatdev/tinyfl_t</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464673/">https://habr.com/ru/post/pt464673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464657/index.html">Cornija elétrica para engenharia reversa AM82TV</a></li>
<li><a href="../pt464659/index.html">Segurança de aplicativos ou Como incorporar segurança no desenvolvimento personalizado. Experiência pessoal na AGIMA</a></li>
<li><a href="../pt464661/index.html">A quem confiar o projeto de instalações técnicas de reequipamento e reconstrução</a></li>
<li><a href="../pt464665/index.html">Particionando no SQL Server</a></li>
<li><a href="../pt464671/index.html">Receba SMS regulares para mensageiros instantâneos Viber e Telegram (usando gateways GoIP)</a></li>
<li><a href="../pt464675/index.html">Análise dos mecanismos de localização da interface do aplicativo no Splunk</a></li>
<li><a href="../pt464677/index.html">Investimentos na bolsa de valores e custos associados: quanto custam os serviços de uma corretora</a></li>
<li><a href="../pt464679/index.html">Voxgun - um serviço para criar conteúdo de vídeo profissional sem nenhum esforço extra</a></li>
<li><a href="../pt464685/index.html">Telégrafo óptico, rede de microondas e torre Tesla: torres de comunicação incomuns</a></li>
<li><a href="../pt464687/index.html">Se você quer salvar o mundo, o veganismo não é uma opção</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>