<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏜️ 👩🏿‍🤝‍👨🏽 👩🏾‍🤝‍👩🏼 Jahr des Abenteuers mit Graphen-Python 🧥 ⛎ 📜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jahr des Abenteuers mit Graphen-Python 





 Hallo allerseits, ich bin ein Python-Entwickler. Letztes Jahr habe ich mit Graphen-Python + Django ORM g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jahr des Abenteuers mit Graphen-Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461939/"><h1 id="god-priklyucheniy-s-graphene-python">  Jahr des Abenteuers mit Graphen-Python </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c77/e6d/8c3/c77e6d8c390320295743710d11babfac.png" alt="Bild"></p><br><p> Hallo allerseits, ich bin ein Python-Entwickler.  Letztes Jahr habe ich mit Graphen-Python + Django ORM gearbeitet und während dieser Zeit versucht, ein Werkzeug zu entwickeln, um die Arbeit mit Graphen bequemer zu machen.  Als Ergebnis habe ich eine kleine <code>graphene-framework</code> Codebasis und eine Reihe von Regeln erhalten, die ich gerne teilen möchte. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/getpro/habr/post_images/458/645/f18/458645f180f8fff23bcbd543065d8c11.png" alt="Bild"></p><br><p>  Was ist Graphen-Python? </p><br><p>  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphene-python.org</a> dann: </p><br><blockquote>  Graphen-Python ist eine Bibliothek zum einfachen Erstellen von GraphQL-APIs mit Python.  Seine Hauptaufgabe besteht darin, eine einfache, aber gleichzeitig erweiterbare API bereitzustellen, um das Leben der Programmierer zu erleichtern. </blockquote><p>  <strong>Seine Hauptaufgabe besteht darin, eine einfache, aber gleichzeitig erweiterbare API bereitzustellen, um das Leben der Programmierer zu erleichtern.</strong> </p><br><p>  Ja, in Wirklichkeit ist Graphen einfach und erweiterbar, aber es scheint mir zu einfach für große und schnell wachsende Anwendungen.  Eine kurze Dokumentation (ich habe stattdessen den Quellcode verwendet - er ist viel ausführlicher) sowie das Fehlen von Standards zum Schreiben von Code machen diese Bibliothek nicht zur besten Wahl für Ihre nächste API. </p><br><p>  Wie dem auch sei, ich entschied mich, es im Projekt zu verwenden und stieß glücklicherweise auf eine Reihe von Problemen, nachdem ich die meisten gelöst hatte (dank der reichhaltigen undokumentierten Eigenschaften von Graphen).  Einige meiner Lösungen sind rein architektonisch und können ohne mein Framework sofort verwendet werden.  Der Rest von ihnen benötigt jedoch noch eine Codebasis. </p><br><p>  Dieser Artikel ist keine Dokumentation, sondern in gewissem Sinne eine kurze Beschreibung meines Weges und der Probleme, die ich auf die eine oder andere Weise gelöst habe, mit einer kurzen Begründung für meine Wahl.  In diesem Teil habe ich mich mit Mutationen und damit verbundenen Dingen befasst. </p><br><p>  Der Zweck dieses Artikels ist es, <strong>ein aussagekräftiges Feedback zu erhalten</strong> , daher werde ich auf Kritik in den Kommentaren warten! </p><br><p>  <em>Hinweis: Bevor Sie den Artikel weiterlesen, empfehle ich Ihnen dringend, sich mit GraphQL vertraut zu machen.</em> </p><br><hr><br><h2 id="mutacii">  Mutationen </h2><br><blockquote>  Die meisten Diskussionen über GraphQL konzentrieren sich auf das Abrufen von Daten, aber jede Plattform mit Selbstachtung erfordert auch eine Möglichkeit, die auf dem Server gespeicherten Daten zu ändern. </blockquote><p>  Beginnen wir mit Mutationen. </p><br><p>  Betrachten Sie den folgenden Code: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.Mutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> post_id = graphene.ID(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) title = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) content = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) image_urls = graphene.List(graphene.String, required=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) allow_comments = graphene.Boolean(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) contact_email = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) ok = graphene.Boolean(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) errors = graphene.List(graphene.String, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, info, post_id, title, content, image_urls, allow_comments, contact_email)</span></span></span><span class="hljs-function">:</span></span> errors = [] <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: post = get_post_by_id(post_id) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> PostNotFound: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdatePostMutation(ok=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, errors=[<span class="hljs-string"><span class="hljs-string">'post_not_found'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> info.context.user.is_authenticated: errors.append(<span class="hljs-string"><span class="hljs-string">'not_authenticated'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(title) &lt; TITLE_MIN_LENGTH: errors.append(<span class="hljs-string"><span class="hljs-string">'title_too_short'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_email(contact_email): errors.append(<span class="hljs-string"><span class="hljs-string">'contact_email_not_valid'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> post.owner != info.context.user: errors.append(<span class="hljs-string"><span class="hljs-string">'not_post_owner'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Post.objects.filter(title=title).exists(): errors.append(<span class="hljs-string"><span class="hljs-string">'title_already_taken'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> errors: post = Utils.update_post(post, title, content, image_urls, allow_comments, contact_email) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdatePostMutation(ok=bool(errors), errors=errors)</code> </pre> <br><p>  <code>UpdatePostMutation</code> ändert den Beitrag mit der angegebenen <code>id</code> unter Verwendung der übertragenen Daten und gibt Fehler zurück, wenn einige Bedingungen nicht erfüllt sind. </p><br><p>  Man muss sich nur diesen Code ansehen, da er sichtbar wird, dass er nicht erweiterbar und nicht unterstützbar ist, weil: </p><br><ol><li>  Zu viele Argumente der <code>mutate</code> Funktion, deren Anzahl sich erhöhen kann, selbst wenn wir weitere zu bearbeitende Felder hinzufügen möchten. </li><li>  Damit Mutationen auf der Client-Seite gleich aussehen, müssen sie <code>errors</code> und <code>ok</code> , damit ihr Status und was immer zu verstehen ist. </li><li>  Suchen und Abrufen eines <em>Objekts</em> in <code>mutate</code> Funktion.  Die Mutationsfunktion arbeitet mit Fasten, und wenn sie nicht vorhanden ist, sollte die Mutation nicht auftreten. </li><li>  Überprüfen von Berechtigungen in einer Mutation.  Eine Mutation sollte nicht auftreten, wenn der Benutzer nicht das Recht dazu hat (einen Beitrag bearbeiten). </li><li>  Ein nutzloses erstes Argument (eine <em>Wurzel</em> , die für Felder der obersten Ebene immer <code>None</code> , was unsere Mutation ist). </li><li>  Eine unvorhersehbare Reihe von Fehlern: Wenn Sie keinen Quellcode oder keine Dokumentation haben, wissen Sie nicht, welche Fehler diese Mutation zurückgeben kann, da sie nicht im Schema berücksichtigt werden. </li><li>  Es gibt zu viele Vorlagenfehlerprüfungen, die direkt in der <code>mutate</code> werden, bei der <em>die</em> Daten geändert werden, und nicht eine Vielzahl von Prüfungen.  Die ideale <code>mutate</code> sollte aus einer Zeile bestehen - einem Aufruf der Nachbearbeitungsfunktion. </li></ol><br><p>  Kurz gesagt, <strong><code>mutate</code> sollte Daten ändern</strong> , anstatt sich um Aufgaben von Drittanbietern wie den Zugriff auf Objekte und die Überprüfung von Eingaben zu kümmern.  Unser Ziel ist es, zu etwas zu gelangen wie: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(post, info, input)</span></span></span><span class="hljs-function">:</span></span> post = Utils.update_post(post, **input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdatePostMutation(post=post)</code> </pre> <br><p>  Schauen wir uns nun die obigen Punkte an. </p><br><hr><br><h3 id="polzovatelskie-tipy">  Benutzerdefinierte Typen </h3><br><p>  Das <code>email</code> Feld wird als Zeichenfolge übergeben, während es sich um eine <em>Zeichenfolge eines bestimmten Formats handelt</em> .  Jedes Mal, wenn die API eine E-Mail empfängt, muss sie ihre Richtigkeit überprüfen.  Die beste Lösung wäre also, einen benutzerdefinierten Typ zu erstellen. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Email</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.String)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre> <br><p>  Dies mag offensichtlich erscheinen, ist aber erwähnenswert. </p><br><hr><br><h3 id="vhodnye-tipy">  Eingabetypen </h3><br><p>  Verwenden Sie Eingabetypen für Ihre Mutationen.  Auch wenn sie an anderen Orten nicht wiederverwendet werden können.  Dank der Eingabetypen werden Abfragen kleiner, sodass sie leichter zu lesen und schneller zu schreiben sind. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostInput</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.InputObjectType)</span></span></span><span class="hljs-class">:</span></span> title = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) content = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) image_urls = graphene.List(graphene.String, required=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) allow_comments = graphene.Boolean(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) contact_email = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  An: </p><br><pre> <code class="plaintext hljs">mutation( $post_id: ID!, $title: String!, $content: String!, $image_urls: String!, $allow_comments: Boolean!, $contact_email: Email! ) { updatePost( post_id: $post_id, title: $title, content: $content, image_urls: $image_urls, allow_comments: $allow_comments, contact_email: $contact_email, ) { ok } }</code> </pre> <br><p>  Nachher: </p><br><pre> <code class="plaintext hljs">mutation($id: ID!, $input: UpdatePostInput!) { updatePost(id: $id, input: $input) { ok } }</code> </pre> <br><p>  Der Mutationscode ändert sich zu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.Mutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) id = graphene.ID(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) ok = graphene.Boolean(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) errors = graphene.List(graphene.String, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, info, input, id)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... if not errors: post = Utils.update_post(post, **input.__dict__) return UpdatePostMutation(errors=errors)</span></span></code> </pre> <br><hr><br><h3 id="bazovyy-klass-mutaciy">  Basismutationsklasse </h3><br><p>  Wie in Absatz 2 erwähnt, <em>müssen Mutationen <code>errors</code> und <code>ok</code> damit ihr Status und die Ursachen immer verstanden werden können</em> .  Es ist einfach genug, wir erstellen eine Basisklasse: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutationPayload</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.ObjectType)</span></span></span><span class="hljs-class">:</span></span> ok = graphene.Boolean(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) errors = graphene.List(graphene.String, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) query = graphene.Field(<span class="hljs-string"><span class="hljs-string">'main.schema.Query'</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_ok</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, info)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.errors <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> []) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_errors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, info)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.errors <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, info)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}</code> </pre> <br><p>  Ein paar Anmerkungen: </p><br><ul><li>  Die Methode " <code>resolve_ok</code> " ist <code>resolve_ok</code> , sodass wir nicht selbst " <code>ok</code> berechnen müssen. </li><li>  Das <code>query</code> ist die <code>Query</code> , mit der Sie Daten direkt innerhalb der Mutationsanforderung abfragen können (Daten werden nach Abschluss der Mutation angefordert). <br><pre> <code class="plaintext hljs">mutation($id: ID!, $input: PostUpdateInput!) { updatePost(id: $id, input: $input) { ok query { profile { totalPosts } } } }</code> </pre> </li></ul><br><p>  Dies ist sehr praktisch, wenn der Client nach Abschluss der Mutation einige Daten aktualisiert und den Unterstützer nicht auffordern möchte, diesen gesamten Satz zurückzugeben.  Je weniger Code Sie schreiben, desto einfacher ist die Wartung.  Ich habe diese Idee <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier übernommen</a> . </p><br><p>  Mit der Basismutationsklasse wird der Code zu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MutationPayload, graphene.Mutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) id = graphene.ID(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, info, input, id)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre> <br><hr><br><h3 id="kornevye-mutacii">  Wurzelmutationen </h3><br><p>  Unsere Mutationsanfrage sieht jetzt so aus: </p><br><pre> <code class="plaintext hljs">mutation($id: ID!, $input: PostUpdateInput!) { updatePost(id: $id, input: $input) { ok } }</code> </pre> <br><p>  Es ist keine gute Praxis, alle Mutationen in einem globalen Bereich zu enthalten.  Hier sind einige Gründe warum: </p><br><ol><li>  Mit der wachsenden Anzahl von Mutationen wird es immer schwieriger, die gewünschte Mutation zu finden. </li><li>  Aufgrund eines Namespace ist es erforderlich, "den Namen seines Moduls" in den Namen der Mutation aufzunehmen, z. B. " <strong><code>Post</code></strong> <code>update</code> . </li><li>  Sie müssen <code>id</code> als Argument an die Mutation übergeben. </li></ol><br><p>  Ich schlage vor, <em>Wurzelmutationen zu verwenden</em> .  Ihr Ziel ist es, diese Probleme zu lösen, indem Mutationen in separate Bereiche unterteilt und Mutationen von der Logik des Zugriffs auf Objekte und der Zugriffsrechte auf diese befreit werden. </p><br><p>  Die neue Anfrage sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">mutation($id: ID!, $input: PostUpdateInput!) { post(id: $id) { update(input: $input) { ok } } }</code> </pre> <br><p>  Die Anforderungsargumente bleiben gleich.  Jetzt wird die Änderungsfunktion innerhalb des <code>post</code> "aufgerufen", wodurch die folgende Logik implementiert werden kann: </p><br><ol><li>  Wenn <code>id</code> nicht an <code>post</code> , wird <code>{}</code> .  Auf diese Weise können Sie weiterhin Mutationen innerhalb durchführen.  Wird für Mutationen verwendet, für die kein Stammelement erforderlich ist (z. B. zum Erstellen von Objekten). </li><li>  Wenn <code>id</code> wird, wird das entsprechende Element abgerufen. </li><li>  Wenn das Objekt nicht gefunden wird, wird <code>None</code> zurückgegeben, und dies schließt die Anforderung ab. Die Mutation wird nicht aufgerufen. </li><li>  Wenn das Objekt gefunden wird, überprüfen Sie die Rechte des Benutzers, um es zu bearbeiten. </li><li>  Wenn der Benutzer keine Rechte hat, wird <code>None</code> zurückgegeben und die Anforderung abgeschlossen. Die Mutation wird nicht aufgerufen. </li><li>  Wenn der Benutzer Rechte hat, wird das gefundene Objekt zurückgegeben und die Mutation erhält es als root - das erste Argument. </li></ol><br><p>  Daher ändert sich der Mutationscode zu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MutationPayload, graphene.Mutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(post, info, input)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> post <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> errors = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> info.context.user.is_authenticated: errors.append(<span class="hljs-string"><span class="hljs-string">'not_authenticated'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(title) &lt; TITLE_MIN_LENGTH: errors.append(<span class="hljs-string"><span class="hljs-string">'title_too_short'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Post.objects.filter(title=title).exists(): errors.append(<span class="hljs-string"><span class="hljs-string">'title_already_taken'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> errors: post = Utils.update_post(post, **input.__dict__) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdatePostMutation(errors=errors)</code> </pre> <br><ul><li>  Die Wurzel der Mutation - das erste Argument - ist jetzt ein Objekt vom Typ <code>Post</code> , über das die Mutation durchgeführt wird. </li><li>  Die Autorisierungsprüfung wurde in den Stammmutationscode verschoben. </li></ul><br><p>  Wurzelmutationscode: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostMutationRoot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MutationRoot)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> model = Post has_permission = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> post, user: post.owner == user update = UpdatePostMutation.Field()</code> </pre> <br><hr><br><h3 id="interfeys-oshibok">  Fehlerschnittstelle </h3><br><p>  Um eine Reihe von Fehlern vorhersehbar zu machen, müssen sie im Design berücksichtigt werden. </p><br><ul><li>  Da Mutationen mehrere Fehler zurückgeben können, sollten Fehler eine Liste sein. </li><li>  Da Fehler durch verschiedene Typen dargestellt werden, muss für eine bestimmte Mutation eine bestimmte <code>Union</code> Fehlern existieren. </li><li>  Damit die Fehler einander ähnlich bleiben, müssen sie die Schnittstelle <code>ErrorInterface</code> . <code>ErrorInterface</code> wir sie <code>ErrorInterface</code> .  Lassen Sie es zwei Felder enthalten: <code>ok</code> und <code>message</code> . </li></ul><br><p>  Daher müssen Fehler vom Typ <code>[SomeMutationErrorsUnion]!</code>  .  Alle Untertypen von <code>SomeMutationErrorsUnion</code> müssen <code>ErrorInterface</code> implementieren. </p><br><p>  Wir bekommen: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.ObjectType)</span></span></span><span class="hljs-class">:</span></span> message = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, default_value=<span class="hljs-string"><span class="hljs-string">'not_authenticated'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> interfaces = [ErrorInterface, ] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitleTooShort</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.ObjectType)</span></span></span><span class="hljs-class">:</span></span> message = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, default_value=<span class="hljs-string"><span class="hljs-string">'title_too_short'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> interfaces = [ErrorInterface, ] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitleAlreadyTaken</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.ObjectType)</span></span></span><span class="hljs-class">:</span></span> message = graphene.String(required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, default_value=<span class="hljs-string"><span class="hljs-string">'title_already_taken'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> interfaces = [ErrorInterface, ] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutationErrors</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.Union)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> types = [NotAuthenticated, TitleIsTooShort, TitleAlreadyTaken, ]</code> </pre> <br><p>  Es sieht gut aus, aber es gibt zu viel Code.  Wir verwenden die Metaklasse, um diese Fehler im laufenden Betrieb zu generieren: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostErrors</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=ErrorMetaclass)</span></span></span><span class="hljs-class">:</span></span> errors = [ <span class="hljs-string"><span class="hljs-string">'not_authenticated'</span></span>, <span class="hljs-string"><span class="hljs-string">'title_too_short'</span></span>, <span class="hljs-string"><span class="hljs-string">'title_already_taken'</span></span>, ] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutationErrors</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(graphene.Union)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> types = [PostErrors.not_authenticated, PostErrors.title_too_short, PostErrors.title_already_taken, ]</code> </pre> <br><p>  Fügen Sie der Mutation die Deklaration der zurückgegebenen Fehler hinzu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MutationPayload, graphene.Mutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput() errors = graphene.List(UpdatePostMutationErrors, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(post, info, input)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre> <br><hr><br><h3 id="proverka-na-nalichie-oshibok">  Auf Fehler prüfen </h3><br><p>  Es scheint mir, dass sich die <code>mutate</code> nur um die <em>Mutation der Daten</em> kümmern sollte.  Um dies zu erreichen, müssen Sie den Code für diese Funktion auf Fehler überprüfen. </p><br><p>  Ohne die Implementierung ist hier das Ergebnis: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(DefaultMutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> root_required = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> authentication_required = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-comment"><span class="hljs-comment">#   ,    True   # An iterable of tuples (error_class, checker) checks = [ ( PostErrors.title_too_short, lambda post, input: len(input.title) &lt; TITLE_MIN_LENGTH ), ( PostErrors.title_already_taken, lambda post, input: Post.objects.filter(title=input.title).exists() ), ] def mutate(post, info, input): post = Utils.update_post(post, **input.__dict__) return UpdatePostMutation()</span></span></code> </pre> <br><p>  Vor dem Starten der <code>mutate</code> Funktion wird jeder <em>Checker</em> (das zweite Element der Mitglieder des <code>checks</code> Arrays) aufgerufen.  Wenn <code>True</code> zurückgegeben wird, wird der entsprechende Fehler gefunden.  Wenn keine Fehler gefunden werden, wird die <code>mutate</code> Funktion aufgerufen. </p><br><p>  Ich werde erklären: </p><br><ul><li>  Überprüfungsfunktionen verwenden dieselben Argumente wie <code>mutate</code> . </li><li>  Validierungsfunktionen sollten <code>True</code> wenn ein Fehler gefunden wird. </li><li>  Berechtigungsprüfungen und das Vorhandensein des Stammelements sind recht allgemein gehalten und in den <code>Meta</code> Flags aufgeführt. </li><li>  <code>authentication_required</code> fügt eine Berechtigungsprüfung hinzu, wenn <code>True</code> . </li><li>  <code>root_required</code> fügt eine Prüfung " <code>root is not None</code> " hinzu. </li><li>  <code>UpdatePostMutationErrors</code> nicht mehr erforderlich.  Abhängig von den Fehlerklassen des <code>checks</code> Arrays wird im <code>checks</code> eine Vereinigung möglicher Fehler erstellt. </li></ul><br><hr><br><h3 id="dzheneriki">  Generika </h3><br><p>  <code>DefaultMutation</code> im letzten Abschnitt verwendete <code>pre_mutate</code> fügt eine <code>pre_mutate</code> Methode hinzu, mit der Sie die Eingabeargumente ändern können, bevor Sie nach Fehlern <code>pre_mutate</code> und dementsprechend die Mutation aufrufen. </p><br><p>  Es gibt auch ein generisches Starter-Kit, das den Code kürzer macht und das Leben erleichtert. <br>  <em>Hinweis: Derzeit ist der generische Code spezifisch für Django ORM</em> </p><br><h4 id="createmutation">  Kreatemutation </h4><br><p>  Benötigt einen der <code>model</code> oder <code>create_function</code> .  Standardmäßig sieht <code>create_function</code> aus: </p><br><pre> <code class="python hljs">model._default_manager.create(**data, owner=user)</code> </pre> <br><p>  Dies mag unsicher aussehen, aber vergessen Sie nicht, dass es in graphql eine integrierte Typprüfung sowie Mutationen gibt. </p><br><p>  Es bietet auch eine <code>post_mutate</code> Methode, die nach <code>create_function</code> mit Argumenten <code>(instance_created, user)</code> aufgerufen wird, deren Ergebnis an den Client zurückgegeben wird. </p><br><h4 id="updatemutation">  Updatemutation </h4><br><p>  Ermöglicht das <code>update_function</code> .  Default: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default_update_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(instance, user=None, **data)</span></span></span><span class="hljs-function">:</span></span> instance.__dict__.update(data) instance.save() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance</code> </pre> <br><p>  <code>root_required</code> ist standardmäßig <code>True</code> . </p><br><p>  Es bietet auch eine <code>post_mutate</code> Methode, die nach <code>update_function</code> mit Argumenten <code>(instance_updated, user)</code> aufgerufen wird, deren Ergebnis an den Client zurückgegeben wird. </p><br><p>  Und das brauchen wir! </p><br><p>  Endgültiger Code: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpdatePostMutation</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(UpdateMutation)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arguments</span></span></span><span class="hljs-class">:</span></span> input = UpdatePostInput() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> checks = [ ( PostErrors.title_too_short, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> post, input: len(input.title) &lt; TITLE_MIN_LENGTH ), ( PostErrors.title_already_taken, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> post, input: Post.objects.filter(title=input.title).exists() ), ]</code> </pre> <br><h4 id="deletemutation">  DeleteMutation </h4><br><p>  Ermöglicht das <code>delete_function</code> .  Default: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default_delete_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(instance, user=None, **data)</span></span></span><span class="hljs-function">:</span></span> instance.delete()</code> </pre> <br><hr><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Dieser Artikel berücksichtigt nur einen Aspekt, obwohl er meiner Meinung nach der komplexeste ist.  Ich habe einige Gedanken zu Resolvern und Typen sowie zu allgemeinen Dingen in Graphen-Python. </p><br><p>  Es fällt mir schwer, mich selbst als erfahrenen Entwickler zu bezeichnen, daher freue ich mich über Feedback und Vorschläge. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Den Quellcode finden Sie hier</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461939/">https://habr.com/ru/post/de461939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461923/index.html">JetBrains Open Day in St. Petersburg: Video</a></li>
<li><a href="../de461927/index.html">Aktives Ranking-Lernen</a></li>
<li><a href="../de461929/index.html">Überwachen und Überprüfen des SSD-Status unter Linux</a></li>
<li><a href="../de461935/index.html">So arbeiten Sie mit Postgres in Go: Praktiken, Funktionen, Nuancen</a></li>
<li><a href="../de461937/index.html">Parkinson-Gesetz und wie man es bricht</a></li>
<li><a href="../de461941/index.html">Massieren Sie es</a></li>
<li><a href="../de461945/index.html">Die Zusammenfassung der Ereignisse für HR-Fachkräfte im Bereich IT für August 2019</a></li>
<li><a href="../de461949/index.html">AppCode 2019.2: Swift 5.1, Analyse der Codeabdeckung durch Tests, Anzeige von zerlegtem Code und mehr</a></li>
<li><a href="../de461951/index.html">Veeam-Plug-In zur Sicherung und Wiederherstellung von SAP-HANA-Datenbanken</a></li>
<li><a href="../de461955/index.html">Tauschen Sie Token aus oder wie Sie das Krypto-Portfolio im Jahr 2019 stärken können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>