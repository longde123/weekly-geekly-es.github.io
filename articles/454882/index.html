<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçó üíµ üê§ La arquitectura de una situaci√≥n excepcional: punto 2 de 4 ‚ô†Ô∏è üë®üèΩ‚Äçüîß üôáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Supongo que uno de los problemas m√°s importantes en este tema es construir una arquitectura de manejo de excepciones en su aplicaci√≥n. Esto es interes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La arquitectura de una situaci√≥n excepcional: punto 2 de 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454882/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Supongo que uno de los problemas m√°s importantes en este tema es construir una arquitectura de manejo de excepciones en su aplicaci√≥n.  Esto es interesante por muchas razones.  Y la raz√≥n principal, creo, es una aparente simplicidad, con la que no siempre sabes qu√© hacer.  Todas las construcciones b√°sicas como <code>IEnumerable</code> , <code>IDisposable</code> , <code>IObservable</code> , etc.  tener esta propiedad y usarla en todas partes.  Por un lado, su simplicidad tienta a usar estos constructos en diferentes situaciones.  Por otro lado, est√°n llenos de trampas que quiz√°s no puedas sacar.  Es posible que al observar la cantidad de informaci√≥n que cubrimos tenga una pregunta: ¬øqu√© tiene de especial las situaciones excepcionales? </p><br><p>  Sin embargo, para sacar conclusiones sobre la construcci√≥n de la arquitectura de las clases de excepci√≥n, debemos aprender algunos detalles sobre su clasificaci√≥n.  Porque antes de construir un sistema de tipos que sea claro para el usuario del c√≥digo, un programador debe determinar cu√°ndo elegir el tipo de error y cu√°ndo detectar o saltear excepciones.  Entonces, clasifiquemos las situaciones excepcionales (no los tipos de excepciones) en funci√≥n de varias caracter√≠sticas. </p><a name="habracut"></a><br><h3 id="based-on-a-theoretical-possibility-to-catch-a-future-exception">  Basado en una posibilidad te√≥rica para atrapar una futura excepci√≥n. </h3><br><p>  Con base en esta caracter√≠stica, podemos dividir las excepciones en aquellas que definitivamente ser√°n capturadas y aquellas que probablemente no ser√°n capturadas.  ¬øPor qu√© digo <em>altamente probable</em> ?  Porque siempre habr√° alguien que tratar√° de atrapar una excepci√≥n mientras esto sea innecesario. </p><br><p>  Primero, describamos el primer grupo de excepciones: aquellas que deber√≠an detectarse. </p><br><p>  En caso de tales excepciones, nosotros, por un lado, decimos a nuestro subsistema que llegamos a un estado en el que no tiene sentido realizar m√°s acciones con nuestros datos.  Por otro lado, queremos decir que no sucedi√≥ nada desastroso y podemos encontrar la salida de la situaci√≥n simplemente atrapando la excepci√≥n.  Esta propiedad es muy importante ya que define la criticidad de un error y da confianza de que si detectamos una excepci√≥n y eliminamos recursos, simplemente podemos proceder con el c√≥digo. </p><br><p>  El segundo grupo trata con excepciones que, aunque puede parecer extra√±o, no tienen que ser atrapadas.  Se pueden usar solo para el registro de errores, pero no para corregir una situaci√≥n.  El ejemplo m√°s simple es <code>ArgumentException</code> y <code>NullReferenceException</code> .  De hecho, en una situaci√≥n ordinaria no necesita atrapar, por ejemplo, <code>ArgumentNullException</code> porque en este caso la fuente de un error es exactamente usted.  Si detecta una excepci√≥n, admite que cometi√≥ un error y pas√≥ algo inaceptable a un m√©todo: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  En este m√©todo intentamos atrapar <code>ArgumentNullException</code> .  Pero creo que esto es extra√±o, ya que pasar los argumentos correctos a un m√©todo es totalmente nuestra preocupaci√≥n.  Reaccionar despu√©s del evento ser√≠a incorrecto: lo mejor que puede hacer en tal situaci√≥n es verificar los datos pasados ‚Äã‚Äãpor adelantado antes de llamar a un m√©todo o incluso construir dicho c√≥digo donde es imposible obtener par√°metros incorrectos. </p><br><p>  Otro grupo de situaciones excepcionales son los errores fatales.  Si alg√∫n cach√© est√° defectuoso y el trabajo de un subsistema es incorrecto, es un error fatal y el c√≥digo m√°s cercano en la pila no lo detectar√° con seguridad: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } cache (CacheCorruptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  <code>CacheCorruptedException</code> es una excepci√≥n que significa que "el cach√© del disco duro es inconsistente".  Luego, si la causa de tal error es fatal para el subsistema de cach√© (por ejemplo, no hay derechos de acceso a archivos de cach√©), el siguiente c√≥digo no puede recrear el cach√© utilizando la instrucci√≥n <code>RecreateCache</code> y, por lo tanto, detectar esta excepci√≥n es un error en s√≠ mismo. </p><br><h3 id="based-on-the-area-where-an-exceptional-situation-is-actually-catched">  Basado en el √°rea donde se detecta una situaci√≥n excepcional </h3><br><p>  Otra cuesti√≥n es si debemos detectar algunas excepciones o pasarlas a alguien que comprenda mejor la situaci√≥n.  En otras palabras, debemos establecer √°reas de responsabilidad.  Examinemos el siguiente c√≥digo: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  ¬øCu√°l de las dos estrategias es m√°s apropiada?  El √°rea de responsabilidad es muy importante.  Inicialmente, puede parecer que el trabajo y la consistencia de <code>WildInvestment</code> dependen completamente de <code>WildStrategy</code> .  Por lo tanto, si <code>WildInvestment</code> simplemente ignora esta excepci√≥n, ir√° al nivel superior y no deber√≠amos hacer nada.  Sin embargo, tenga en cuenta que, en t√©rminos de arquitectura, el m√©todo <code>Main</code> detecta una excepci√≥n de un nivel mientras llama al m√©todo desde otro.  ¬øC√≥mo se ve en t√©rminos de uso?  Bueno, as√≠ es como se ve: </p><br><ul><li>  la responsabilidad de esta excepci√≥n nos fue transferida a nosotros; </li><li>  el usuario de esta clase no est√° seguro de que esta excepci√≥n se haya pasado previamente a trav√©s de un conjunto de m√©todos a prop√≥sito; </li><li>  comenzamos a crear nuevas dependencias de las que nos deshacemos llamando a una capa intermedia. </li></ul><br><p>  Sin embargo, hay otra conclusi√≥n resultante de esta: deber√≠amos usar <code>catch</code> en el m√©todo <code>DoSomethingWild</code> .  Y esto es un poco extra√±o para nosotros: <code>WildInvestment</code> casi no depende de algo.  Quiero decir que si <code>PlayRussianRoulette</code> no funcion√≥, lo mismo suceder√° con <code>DoSomethingWild</code> : no tiene c√≥digos de retorno, pero tiene que jugar a la ruleta.  Entonces, ¬øqu√© podemos hacer en una situaci√≥n tan desesperada?  La respuesta es realmente simple: estar en otro nivel <code>DoSomethingWild</code> deber√≠a lanzar su propia excepci√≥n que pertenece a este nivel y envolverla en <code>InnerException</code> como la fuente original de un problema: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Al incluir una excepci√≥n en otra, transferimos el problema de un nivel de aplicaci√≥n a otro y hacemos que su trabajo sea m√°s predecible en t√©rminos de un consumidor de esta clase: el m√©todo <code>Main</code> . </p><br><h3 id="based-on-reuse-issues">  Basado en problemas de reutilizaci√≥n </h3><br><p>  A menudo nos sentimos demasiado vagos para crear un nuevo tipo de excepci√≥n, pero cuando decidimos hacerlo, no siempre est√° claro en qu√© tipo basarnos.  Pero son precisamente estas decisiones las que definen toda la arquitectura de situaciones excepcionales.  Echemos un vistazo a algunas soluciones populares y saquemos algunas conclusiones. </p><br><p>  Al elegir el tipo de excepci√≥n, podemos usar una soluci√≥n hecha previamente, es decir, encontrar una excepci√≥n con el nombre que tenga un sentido similar y usarla.  Por ejemplo, si obtuvimos una entidad a trav√©s de un par√°metro y no nos gusta esta entidad, podemos lanzar <code>InvalidArgumentException</code> , indicando la causa de un error en Message.  Este escenario se ve bien, especialmente porque <code>InvalidArgumentException</code> est√° en el grupo de excepciones que no se pueden detectar.  Sin embargo, la elecci√≥n de <code>InvalidDataException</code> ser√° incorrecta si trabaja con algunos tipos de datos.  Es porque este tipo est√° en el √°rea <code>System.IO</code> , que probablemente no es con lo que se trata.  Por lo tanto, casi siempre ser√° un error buscar un tipo existente en lugar de desarrollar uno solo.  Casi no hay excepciones para una gama general de tareas.  Pr√°cticamente todos son para situaciones espec√≠ficas y si los reutiliza en otros casos, violar√° gravemente la arquitectura de situaciones excepcionales.  Adem√°s, una excepci√≥n de un tipo en particular (por ejemplo, <code>System.IO.InvalidDataException</code> ) puede confundir a un usuario: por un lado, ver√° que la excepci√≥n pertenece al espacio de nombres <code>System.IO</code> , mientras que por otro lado se lanza desde Un espacio de nombres completamente diferente.  Si este usuario comienza a pensar en las reglas para lanzar esta excepci√≥n, puede ir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencesource.microsoft.com</a> y encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">todos los lugares donde se lanza</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  El usuario entender√° que <del>  alguien es todo pulgares </del>  este tipo de excepci√≥n lo confundi√≥ ya que el m√©todo que arroj√≥ esta excepci√≥n no se ocup√≥ de la compresi√≥n. </p><br><p>  Adem√°s, en t√©rminos de reutilizaci√≥n, simplemente puede crear una excepci√≥n y declarar el campo <code>ErrorCode</code> en √©l.  Eso parece una buena idea.  Simplemente lanza la misma excepci√≥n, configura el c√≥digo y usa solo un <code>catch</code> para lidiar con las excepciones, aumentando la estabilidad de una aplicaci√≥n, nada m√°s.  Sin embargo, creo que deber√≠a repensar esta posici√≥n.  Por supuesto, este enfoque hace la vida m√°s f√°cil por un lado.  Sin embargo, por otro lado, descarta la posibilidad de detectar un subgrupo de excepciones que tienen alguna caracter√≠stica com√∫n.  Por ejemplo, <code>ArgumentException</code> que une un mont√≥n de excepciones por herencia.  Otra desventaja grave es un c√≥digo excesivamente grande e ilegible que debe organizar el filtrado basado en c√≥digo de error.  Sin embargo, introducir un tipo abarcador con un c√≥digo de error ser√° m√°s apropiado cuando un usuario no tenga que preocuparse por especificar un error. </p><br><pre> <code class="plaintext hljs">public class ParserException { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Al c√≥digo que protege la llamada del analizador no le importa por qu√© fall√≥ el an√°lisis: le interesa el error como tal.  Sin embargo, si la causa del error se vuelve importante despu√©s de todo, un usuario siempre puede obtener el c√≥digo de error de la propiedad <code>ErrorCode</code> .  Y realmente no tiene que buscar las palabras necesarias en una subcadena de <code>Message</code> . </p><br><p>  Si no elegimos reutilizar, podemos crear un tipo de excepci√≥n para cada situaci√≥n.  Por un lado, suena l√≥gico: un tipo de error, un tipo de excepci√≥n.  Sin embargo, no exagere: tener demasiados tipos de excepciones causar√° el problema de atraparlos, ya que el c√≥digo de un m√©todo de llamada se sobrecargar√° con bloques de <code>catch</code> .  Porque necesita procesar todos los tipos de excepciones que desea pasarle.  Otra desventaja es puramente arquitect√≥nica.  Si no utiliza excepciones, confunde a quienes las utilizar√°n: pueden tener muchas cosas en com√∫n, pero se detectar√°n por separado. </p><br><p>  Sin embargo, hay grandes escenarios para introducir tipos separados para situaciones espec√≠ficas.  Por ejemplo, cuando el error no afecta a toda una entidad, sino a un m√©todo espec√≠fico.  Entonces, este tipo de error deber√≠a ocupar un lugar tan importante en la jerarqu√≠a de la herencia que a nadie se le ocurrir√≠a atraparlo junto con otra cosa: por ejemplo, a trav√©s de una rama separada de la herencia. </p><br><p>  Adem√°s, si combina ambos enfoques, puede obtener un poderoso conjunto de instrumentos para trabajar con un grupo de errores: puede introducir un tipo abstracto com√∫n y heredar casos espec√≠ficos de √©l.  La clase base (nuestro tipo com√∫n) debe obtener una propiedad abstracta, dise√±ada para almacenar un c√≥digo de error, mientras que los herederos especificar√°n este c√≥digo anulando esta propiedad. </p><br><pre> <code class="plaintext hljs">public abstract class ParserException { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Usando este enfoque obtenemos algunas propiedades maravillosas: </p><br><ul><li>  por un lado, seguimos capturando excepciones usando un tipo base (com√∫n); </li><li>  Por otro lado, incluso detectando excepciones con este tipo de base todav√≠a podemos identificar una situaci√≥n espec√≠fica; </li><li>  Adem√°s, podemos detectar excepciones a trav√©s de un tipo espec√≠fico en lugar de un tipo base sin usar la estructura plana de clases. </li></ul><br><p>  Creo que es muy conveniente. </p><br><h3 id="based-on-belonging-to-a-specific-group-of-behavioral-situations">  Basado en pertenecer a un grupo espec√≠fico de situaciones de comportamiento </h3><br><p>  ¬øQu√© conclusiones podemos sacar con base en el razonamiento anterior?  Tratemos de definirlos. </p><br><p>  En primer lugar, ¬øqu√© significa una situaci√≥n?  Por lo general, hablamos de clases y objetos en t√©rminos de entidades con alg√∫n estado interno y podemos realizar acciones en estas entidades.  Por lo tanto, el primer tipo de situaci√≥n de comportamiento incluye acciones en alguna entidad.  A continuaci√≥n, si observamos un gr√°fico de objetos desde el exterior, veremos que est√° representado l√≥gicamente como una combinaci√≥n de grupos funcionales: el primer grupo se ocupa del almacenamiento en cach√©, el segundo trabaja con bases de datos, el tercero realiza c√°lculos matem√°ticos.  Diferentes capas pueden atravesar todos estos grupos, por ejemplo, capas de registro de estados internos, registro de procesos y rastreo de llamadas a m√©todos.  Las capas pueden abarcar varios grupos funcionales.  Por ejemplo, puede haber una capa de un modelo, una capa de controladores y una capa de presentaci√≥n.  Estos grupos pueden estar en una asamblea o en diferentes, pero cada grupo puede crear sus propias situaciones excepcionales. </p><br><p>  Entonces, podemos construir una jerarqu√≠a para los tipos de situaciones excepcionales basadas en la pertenencia de estos tipos a uno u otro grupo o capa.  Por lo tanto, permitimos que un c√≥digo de captura navegue f√°cilmente entre estos tipos en la jerarqu√≠a. </p><br><p>  Examinemos el siguiente c√≥digo: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Como es  Creo que el espacio de nombres es una forma perfecta de agrupar naturalmente los tipos de excepciones en funci√≥n de las situaciones de comportamiento: todo lo que pertenece a grupos particulares debe permanecer all√≠, incluidas las excepciones.  Adem√°s, cuando obtiene una excepci√≥n particular, ver√° el nombre de su tipo y tambi√©n su espacio de nombres que especificar√° un grupo al que pertenece.  ¬øRecuerdas la mala reutilizaci√≥n de <code>InvalidDataException</code> que se define realmente en el espacio de nombres <code>System.IO</code> ?  El hecho de que pertenezca a este espacio de nombres significa que este tipo de excepci√≥n se puede lanzar desde clases que est√°n en el espacio de nombres <code>System.IO</code> o en una m√°s anidada.  Pero la excepci√≥n real fue lanzada desde un espacio completamente diferente, confundiendo a una persona que maneja el problema.  Sin embargo, si coloca los tipos de excepciones y los tipos que arrojan estas excepciones en los mismos espacios de nombres, mantiene la arquitectura de los tipos coherente y facilita a los desarrolladores la comprensi√≥n de los motivos de lo que sucede. </p><br><p>  ¬øCu√°l es la segunda forma de agrupar en el nivel de c√≥digo?  Herencia: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerException(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Tenga en cuenta que para las entidades de aplicaci√≥n habituales, heredan el comportamiento y los tipos de datos y grupos que pertenecen a un <em>solo grupo de entidades</em> .  Sin embargo, para excepciones, heredan y se agrupan en funci√≥n de un <em>solo grupo de situaciones</em> , porque la esencia de una excepci√≥n no es una entidad sino un problema. </p><br><p>  Combinando estos dos m√©todos de agrupaci√≥n podemos sacar las siguientes conclusiones: </p><br><ul><li>  debe haber un tipo de base de excepciones dentro de la <code>Assembly</code> que se generar√° en esta asamblea.  Este tipo de excepciones debe estar en un espacio de nombres ra√≠z del ensamblado.  Esta ser√° la primera capa de agrupaci√≥n. </li><li>  Adem√°s, puede haber uno o varios espacios de nombres dentro de un ensamblado.  Cada uno de ellos divide el ensamblaje en zonas funcionales, definiendo los grupos de situaciones que aparecen en este ensamblaje.  Estas pueden ser zonas de controladores, entidades de bases de datos, algoritmos de procesamiento de datos, etc.  Para nosotros, estos espacios de nombres significan tipos de agrupaci√≥n basados ‚Äã‚Äãen su funci√≥n.  Sin embargo, en t√©rminos de excepciones, se agrupan en funci√≥n de problemas dentro del mismo ensamblado; </li><li>  las excepciones deben heredarse de tipos en el mismo espacio de nombres de nivel superior.  Esto garantiza que el usuario final comprender√° sin ambig√ºedades las situaciones y no detectar√° excepciones basadas en tipos <em>incorrectos</em> .  Admito, ser√≠a extra√±o atrapar <code>global::Finiki.Logistics.OhMyException</code> por <code>catch(global::Legacy.LoggerExeption exception)</code> , mientras que el siguiente c√≥digo parece absolutamente apropiado: </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something is wrong in the parser } catch (FinancialPipeExceptionBase exception) { // Something else is wrong. Looks critical because we don't know the real reason }</code> </pre><br><p>  Aqu√≠, el c√≥digo de usuario llama a un m√©todo de biblioteca que, como sabemos, puede arrojar <code>XmlParserServiceException</code> en alguna situaci√≥n.  Y, como sabemos, esta excepci√≥n se refiere al espacio de nombres heredado <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> , lo que significa que puede haber otras excepciones, esta vez el microservicio <code>XmlParserService</code> crea solo una excepci√≥n, pero pueden aparecer otras excepciones en el futuro.  Como tenemos una convenci√≥n para crear tipos de excepciones, sabemos de qu√© entidad se heredar√° esta nueva excepci√≥n y ponemos una <code>catch</code> por adelantado.  Eso nos permite omitir todas las cosas irrelevantes para nosotros. </p><br><p>  ¬øC√≥mo construir tal jerarqu√≠a de tipos? </p><br><ul><li>  En primer lugar, debemos crear una clase base para un dominio.  Llam√©moslo una clase base de dominio.  En este caso, un dominio es una palabra que abarca una serie de conjuntos, combin√°ndolos en funci√≥n de alguna caracter√≠stica: registro, l√≥gica de negocios, IU.  Me refiero a zonas funcionales de una aplicaci√≥n que son lo m√°s grandes posible. </li><li>  A continuaci√≥n, deber√≠amos introducir una clase base adicional para las excepciones que deben <code>catch</code> : todas las excepciones que se <code>catch</code> utilizando la palabra clave <code>catch</code> se heredar√°n de esta clase base; </li><li>  Todas las excepciones que indican errores fatales deben heredarse directamente de una clase base de dominio.  As√≠ los separaremos de los atrapados en el nivel de arquitectura; <br>  - Divida el dominio en √°reas funcionales basadas en espacios de nombres y declare el tipo base de excepciones que se lanzar√°n desde cada √°rea.  Aqu√≠ es necesario usar el sentido com√∫n: si una aplicaci√≥n tiene un alto grado de anidaci√≥n de espacio de nombres, no debe hacer un tipo base para cada nivel de anidaci√≥n.  Sin embargo, si hay una ramificaci√≥n a nivel de anidamiento cuando un grupo de excepciones va a un espacio de nombres y otro grupo va a otro espacio de nombres, es necesario usar dos tipos b√°sicos para cada subgrupo; </li><li>  Se deben heredar excepciones especiales de los tipos de excepciones que pertenecen a √°reas funcionales </li><li>  Si se puede combinar un grupo de excepciones especiales, es necesario hacerlo en un tipo base m√°s: por lo tanto, puede atraparlos m√°s f√°cilmente; </li><li>  Si supone que el grupo se ver√° atrapado con mayor frecuencia utilizando una clase base, introduzca el Modo mixto con C√≥digo de error. </li></ul><br><h3 id="based-on-the-source-of-an-error">  Basado en la fuente de un error </h3><br><p>  La fuente de un error puede ser otra base para combinar excepciones en un grupo.  Por ejemplo, si dise√±a una biblioteca de clases, las siguientes cosas pueden formar grupos de fuentes: </p><br><ul><li>  llamada de c√≥digo inseguro con un error.  Esta situaci√≥n puede resolverse envolviendo una excepci√≥n o un c√≥digo de error en su propio tipo de excepci√≥n mientras guarda los datos devueltos (por ejemplo, el c√≥digo de error original) en una propiedad p√∫blica de la excepci√≥n; </li><li>  una llamada de c√≥digo por dependencias externas, que ha arrojado excepciones que nuestra biblioteca no puede detectar ya que est√°n m√°s all√° de su √°rea de responsabilidad.  Este grupo puede incluir excepciones de los m√©todos de aquellas entidades que fueron aceptadas como los par√°metros de un m√©todo actual o excepciones del constructor de una clase cuyo m√©todo ha llamado dependencia externa.  Por ejemplo, un m√©todo de nuestra clase ha llamado un m√©todo de otra clase, cuya instancia fue devuelta a trav√©s de par√°metros de otro m√©todo.  Si una excepci√≥n indica que somos la fuente de un problema, deber√≠amos generar nuestra propia excepci√≥n al tiempo que conservamos la original en <code>InnerExcepton</code> .  Sin embargo, si entendemos que el problema ha sido causado por una dependencia externa, ignoramos esta excepci√≥n como perteneciente a un grupo de dependencias externas m√°s all√° de nuestro control; </li><li>  nuestro propio c√≥digo que fue puesto accidentalmente en un estado inconsistente.  Un buen ejemplo es el an√°lisis de texto: sin dependencias externas, sin transferencia a <code>unsafe</code> mundo <code>unsafe</code> , pero se produce un problema de an√°lisis. </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454882/">https://habr.com/ru/post/454882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454872/index.html">Space Invaders: ahora en 512 bytes (ensamblador x86)</a></li>
<li><a href="../454874/index.html">Un poco sobre la multitarea en microcontroladores</a></li>
<li><a href="../454876/index.html">Sobre el dise√±o de un sistema flexible de habilidades de personajes en juegos</a></li>
<li><a href="../454878/index.html">Estudiamos MITRE ATT & CK. Matrices m√≥viles: acceso a dispositivos. Parte 3</a></li>
<li><a href="../454880/index.html">"Fuera de temporada" en la vida de un profesional independiente: ¬øc√≥mo sobrevivir y sobrevivir?</a></li>
<li><a href="../454884/index.html">Nombre de prueba legible en JS y el patr√≥n de comportamiento</a></li>
<li><a href="../454892/index.html">Moto Simulacros de aws</a></li>
<li><a href="../454894/index.html">WWDC 2019 :: qu√© ver</a></li>
<li><a href="../454896/index.html">¬øPor qu√© cambi√© freelance a un equipo remoto?</a></li>
<li><a href="../454898/index.html">Programar es m√°s que codificar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>