<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßî üïí ‚ò£Ô∏è OSPF (Parte Um) üó°Ô∏è üç• üöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo foi escrito para mim mesmo, para que, se necess√°rio, atualize rapidamente minha mem√≥ria e entenda a teoria. Eu decidi public√°-lo, talvez s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OSPF (Parte Um)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418391/"> Este artigo foi escrito para mim mesmo, para que, se necess√°rio, atualize rapidamente minha mem√≥ria e entenda a teoria.  Eu decidi public√°-lo, talvez seja √∫til para algu√©m, ou talvez eu esteja enganado em alguma coisa. <br><br>  Neste artigo, tentaremos entender a teoria do protocolo OSPF.  N√£o vamos nos aprofundar na hist√≥ria e no processo de cria√ß√£o do protocolo; essas informa√ß√µes s√£o abundantes em quase todos os artigos sobre OSPF.  Vamos tentar entender com mais detalhes como o OSPF funciona e como ele constr√≥i sua tabela de roteamento.  √â importante fornecer uma defini√ß√£o geral do protocolo: <br><br>  <b>O OSPF</b> (Open Shortest Path First) √© um protocolo de roteamento din√¢mico baseado na tecnologia do estado do link e usa o algoritmo Dijkstra para encontrar o caminho mais curto. <br><br>  Surge imediatamente a pergunta: o que √© a tecnologia de rastreamento de canais?  Eu acho que esse nome n√£o √© totalmente bem-sucedido.  Aconteceu que existem dois tipos de protocolos de roteamento din√¢mico: Link-state e Distance-Vector.  Considere seus princ√≠pios de trabalho: <br><br>  Nos protocolos de vetor de dist√¢ncia, o roteador reconhece as informa√ß√µes de rota por meio de roteadores conectados diretamente ao mesmo segmento de rede.  Ou seja, o roteador tem informa√ß√µes sobre a topologia apenas dentro dos limites dos roteadores vizinhos e n√£o tem id√©ia de como a topologia por tr√°s desses roteadores √© organizada, concentrando-se apenas nas m√©tricas.  Nos protocolos Link-state, cada roteador n√£o deve conhecer facilmente as melhores rotas para todas as redes remotas, mas tamb√©m deve ter na mem√≥ria um mapa de rede completo com todas as conex√µes existentes entre outros roteadores, inclusive.  Isso √© conseguido atrav√©s da constru√ß√£o de uma base especial de LSDB, mas mais sobre isso posteriormente. <br><a name="habracut"></a><br>  Ent√£o, vamos come√ßar como √© constru√≠do o LSDB a partir do qual o roteador aprende sobre todas as rotas?  Constru√≠mos a topologia inicial para o estudo.  √â assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea4/c83/539/ea4c835392207c07ca33dd8ec883a707.jpg" alt="imagem"><br><br>  Vamos configurar o OSPF.  Onde o OSPF come√ßa?  C estabelecendo uma vizinhan√ßa entre roteadores - depois de ativar o OSPF nas interfaces do roteador, os roteadores come√ßam a enviar mensagens de sauda√ß√£o.  Esta mensagem √© enviada para o endere√ßo multicast - 224.0.0.5 a cada 10 segundos (Hello Timer).  Ativaremos o OSPF no roteador vIOS1 primeiro. <br><br>  Vamos ver como √© o pacote Hello: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/3bf/881/6ca3bf881cddaf569bdfb54bd3913666.jpg" alt="imagem"><br><br>  Na mensagem, √© importante prestar aten√ß√£o a campos como ID da √°rea, roteador OSPF de origem.  Quando o processo OSPF √© iniciado, o ID do roteador √© selecionado, o que √© necess√°rio para identificar o roteador entre outros roteadores OSPF.  As regras para escolher este par√¢metro s√£o as seguintes: <br><br>  1. Configurado por um comando especial de identifica√ß√£o de roteador ABCD - no formato de endere√ßo IP. <br>  2. Uma interface de loopback e v√°rias interfaces com endere√ßos diferentes est√£o configuradas: <br><br><ul><li>  O endere√ßo atribu√≠do √† interface de loopback ser√° o ID do roteador. </li></ul><br>  3. Configurou v√°rias interfaces de loopback com v√°rios endere√ßos IP em cada um: <br><br><ul><li>  O endere√ßo IP mais alto atribu√≠do a qualquer uma das interfaces de loopback ser√° o ID do roteador. </li></ul><br>  4. Configurou v√°rias interfaces com um endere√ßo IP em cada uma: <br><br><ul><li>  O maior endere√ßo IP de todas as interfaces ativas ser√° o ID do roteador. </li></ul><br>  Agora vamos para o campo ID da √°rea - este √© um conceito mais importante e fundamental no OSPF.  Para trabalhar com um grande n√∫mero de roteadores, o OSPF usa zonas.  Cada uma das interfaces do roteador deve pertencer a qualquer zona.  Em nossa topologia, as interfaces Gi0 / 0 dos roteadores vIOS1, vIOS2, vIOS3, vIOS4 pertencem √† zona 0. A √°rea 0 √© chamada Backbone e √© o centro de todas as outras zonas.  Cada outra zona deve estar conectada √† zona de Backbone (o link virtual ainda n√£o √© considerado).  Em uma an√°lise mais aprofundada, esses conceitos se tornar√£o mais claros. <br><br>  Ent√£o, ativamos o OSPF no vIOS1 e ele come√ßou a enviar pacotes Hello a cada 10 segundos.  Ative o OSPF no vIOS2 e veja como os relacionamentos vizinhos s√£o estabelecidos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c3/721/8d4/9c37218d473f4f96d9c762300ed21bd1.jpg" alt="imagem"><br><br>  Ent√£o, monitoramos cuidadosamente a sequ√™ncia de mensagens.  Primeiro, o Hello envia apenas o roteador 1.1.1.1 (192.168.1.1), assim que ativar o OSPF em 192.168.1.2, um pacote Hello ser√° enviado.  O vIOS1 e o vIOS2 receber√£o pacotes Hello um do outro e, para que o bairro ocorra, √© importante que os seguintes par√¢metros sejam id√™nticos na configura√ß√£o do OSPF nos dois roteadores: <br><br><ul><li>  Intervalo Hello - frequ√™ncia de envio de mensagens Hello </li><li>  Intervalo de falha do roteador - o per√≠odo ap√≥s o qual o vizinho √© considerado indispon√≠vel se n√£o houver um Ol√°. </li><li>  ID da √°rea - a vizinhan√ßa pode ser estabelecida apenas atrav√©s de interfaces em uma zona. </li><li>  Autentica√ß√£o - a senha usada para autentica√ß√£o e o tipo de autentica√ß√£o, se houver. </li><li>  Sinalizador de √°rea de stub - um sinalizador opcional que √© definido em todos os roteadores que pertencem √† √°rea de stub </li></ul><br>  Se voc√™ observar o pacote Hello mostrado acima, todos esses par√¢metros ser√£o indicados no pacote Hello.  Assim que um dos roteadores (vIOS1) recebe um novo pacote Hello e verifica todas as condi√ß√µes, ele envia imediatamente um pacote Hello onde indica o endere√ßo do novo roteador (vIOS2) no campo Vizinho Ativo, o vIOS2 se recebe e se v√™ no campo vizinho, adiciona o vIOS1 aos vizinhos e enviar√° o pacote unicast para 192.168.1.1 (vIOS1), onde o indicar√° como vizinho.  Por assim dizer, eles se tornaram vizinhos e agora a divers√£o come√ßa - a troca de informa√ß√µes e a constru√ß√£o do LSDB b√°sico.  Sobre o estabelecimento de um bairro, aconselho voc√™ a ler o seguinte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> . <br><br>  A base do LSDB conter√° informa√ß√µes sobre rotas e esse LSDB ap√≥s o estabelecimento da vizinhan√ßa deve ser id√™ntico em todos os roteadores na mesma zona.  E, antes de tudo, os roteadores ap√≥s o estabelecimento de uma vizinhan√ßa iniciam o processo de sincroniza√ß√£o dos bancos de dados entre si (vIOS1 com vIOS2).  Como voc√™ pode ver, tudo come√ßa com a troca de mensagens DB Description (DBD).  Para deixar mais claro, vamos falar sobre os tipos de mensagens que o OSPF usa: <br><br><ul><li>  Ol√° - usado para descobrir vizinhos, verificar par√¢metros, criar rela√ß√µes de vizinhan√ßa com eles e monitorar a disponibilidade. </li><li>  DBD (Database Description) - Verifica o status da sincroniza√ß√£o do banco de dados nos roteadores. </li><li>  Solicita√ß√£o de estado do link (LSR) - solicita registros espec√≠ficos sobre o status dos canais do roteador para o roteador para sincroniza√ß√£o. </li><li>  Atualiza√ß√£o do estado do link (LSU) - envia registros de status de canal espec√≠ficos em resposta a uma solicita√ß√£o. </li><li>  Confirma√ß√£o de estado do link (LSAck) - confirma o recebimento de outros tipos de pacotes. </li></ul><br>  Tamb√©m √© importante introduzir um conceito como o LSA: <br><br>  <b>An√∫ncio de estado de link (LSA)</b> - uma unidade de dados que descreve o estado local de um roteador ou rede.  Muitos dos LSAs que descrevem roteadores e redes formam um Link State Database (LSDB).  O LSDB consiste em v√°rios tipos de LSA.  Muito detalhado sobre cada LSA est√° escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste</a> artigo.  As mensagens DBD usam muitos sinalizadores para determinar o estado da sincroniza√ß√£o, e essas mensagens cont√™m informa√ß√µes sobre seu pr√≥prio banco de dados.  Ou seja, o vIOS1 informa nessas mensagens que, no meu banco de dados, h√° informa√ß√µes sobre redes como 192.168.0 / 24, 1.1.1.0/24 (LSA tipo 1) e o vIOS2, por sua vez, informa que possui registros sobre Redes: 192.168.2.0/24, 2.2.2.0/24 (LSA tipo 1).  Ap√≥s receber as mensagens DBD, cada roteador envia o LSAck como confirma√ß√£o da mensagem recebida e compara as informa√ß√µes no banco de dados vizinho com as suas.  Se for constatado que n√£o h√° informa√ß√µes dispon√≠veis, o roteador envia uma solicita√ß√£o LS, onde solicita informa√ß√µes completas sobre qualquer LSA.  Por exemplo, o vIOS1 solicitou o LS Request do vIOS2, o vIOS2 responde com o LS Update, que j√° cont√©m informa√ß√µes detalhadas sobre cada rota.  Abaixo est√° a atualiza√ß√£o LS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a79/2cc/672/a792cc672c63e0a95c5b17951567b565.jpg" alt="imagem"><br><br>  Como voc√™ pode ver, neste post, o vIOS2 fala sobre as sub-redes conhecidas por ele e as informa√ß√µes associadas a elas.  Al√©m disso, o vIOS1 fala sobre seu LSDB.  E, no final, os roteadores t√™m o mesmo LSDB.  Ap√≥s a conclus√£o do processo, o algoritmo do Dijkstra (primeiro caminho mais curto) √© iniciado.  Ele calcula todas as rotas conhecidas do LSDB e coloca as melhores na tabela de roteamento.  O melhor com a m√©trica mais baixa, mas mais sobre isso mais tarde. <br><br>  Vamos pensar na pergunta: o que acontece se ativarmos o OSPF no vIOS3?  Como o vIOS3 precisar√° criar o LSDB e sincroniz√°-lo com outros roteadores, surge a pergunta com quem exatamente sincronizar?  Com vIOS1 ou vIOS2?  Com cada um individualmente?  Qu√£o ideal √© isso?  Portanto, no OSPF existe um roteador designado por DR.  Introduzimos este conceito: <br><br>  <b>Roteador dedicado (roteador designado, DR)</b> - gerencia o processo de distribui√ß√£o do LSA na rede.  Cada roteador de rede estabelece um relacionamento de vizinhan√ßa com o DR.  As informa√ß√µes sobre altera√ß√µes na rede s√£o enviadas pelo DR, o roteador que detectou essa altera√ß√£o e o DR √© respons√°vel por garantir que essas informa√ß√µes sejam enviadas para os outros roteadores na rede. <br><br>  Em outras palavras, se um novo roteador aparecer no segmento de rede, ele sincronizar√° seu LSDB com o DR.  Tamb√©m √© importante observar que n√£o apenas os novos, mas todos os outros roteadores informar√£o o DR sobre isso quando a rede mudar ou uma nova rota aparecer, e o restante receber√° essas informa√ß√µes do DR.  Mas ent√£o surgem perguntas - O que acontecer√° se o DR falhar?  Como o DR √© selecionado? <br><br>  Quando falha, um novo DR deve ser selecionado.  Novas rela√ß√µes de vizinhan√ßa devem ser formadas e, at√© que os bancos de dados do roteador sejam sincronizados com o novo banco de dados de DR, a rede n√£o estar√° dispon√≠vel para o encaminhamento de pacotes.  Para eliminar essa desvantagem, selecione BDR - Roteador designado para backup: <br><br>  <b>Roteador designado de backup (BDR).</b>  Cada roteador de rede estabelece um relacionamento de vizinhan√ßa n√£o apenas com o DR, mas tamb√©m com o BDR.  DR e BDR tamb√©m estabelecem rela√ß√µes de vizinhan√ßa entre si.  Quando o DR falha, o BDR se torna o DR e executa todas as suas fun√ß√µes.  Como os roteadores de rede estabeleceram rela√ß√µes de vizinhan√ßa com os BDRs, o tempo de indisponibilidade da rede √© minimizado.  Assim, em nossa rede, obtemos n√£o apenas DR, mas tamb√©m BDR.  Outros roteadores receber√£o e reportar√£o informa√ß√µes relevantes sobre a rede somente atrav√©s deles.  DR e BDR s√≥ podem ser selecionados em um segmento, n√£o em uma zona!  Ou seja, para os roteadores vIOS1, vIOS2, vIOS3, vIOS4, um DR e BDR ser√£o selecionados e, por exemplo, entre o vIOS e o vIOS1, seu DR e BDR ser√£o determinados em rela√ß√£o ao segmento de rede, mesmo se estiverem na mesma √°rea 0. Para comunica√ß√£o com DR e BDR, os roteadores usam um endere√ßo multicast de 224.0.0.6. <br><br>  A pr√≥xima pergunta √©: Como o DR / BDR √© selecionado?  Os seguintes crit√©rios se aplicam: <br><br><ol><li>  DR: roteador de prioridade mais alta da interface OSPF. </li><li>  BDR: roteador com a segunda maior prioridade da interface OSPF. </li><li>  Se as prioridades das interfaces OSPF forem iguais, o ID do roteador mais alto ser√° usado para fazer a sele√ß√£o.  Como dissemos, os roteadores definem seu ID de roteador.  No in√≠cio, quando o OSPF foi lan√ßado no vIOS1 e vIOS2, al√©m de estabelecer uma vizinhan√ßa, tamb√©m ocorreram elei√ß√µes para DR / BDR.  O VIOS2 com o ID - 2.2.2.2 venceu nesta disputa, quando o vIOS1 teve o ID - 1.1.1.1.  O vIOS1 foi selecionado como o BDR.  √â importante observar que o processo de sele√ß√£o de DR e BDR n√£o ocorre imediatamente ap√≥s o recebimento dos primeiros pacotes Hello do segundo roteador.  Para fazer isso, h√° um timer especial igual ao intervalo morto do roteador - 40 segundos.  Se durante esse per√≠odo um pacote Hello com o melhor ID n√£o for recebido, uma sele√ß√£o ser√° feita com base nos pacotes Hello existentes. </li></ol><br>  Somente agora podemos voltar √† pergunta - o que acontecer√° se ativarmos o OSPF no vIOS3?  Ap√≥s ativar o OSPF, o vIOS3 come√ßar√° a enviar e ouvir pacotes Hello.  Ele receber√° pacotes Hello dos vIOS1 e vIOS2, que indicar√£o quais roteadores s√£o DR e BDR e entender√£o com quem eles devem sincronizar o LSDB.  √â importante observar que, quando um roteador com um ID melhor aparece, o DR / BDR n√£o muda at√© que um deles trate.  Depois disso, o vIOS3 come√ßa a sincronizar seu LSDB com esses roteadores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8e/8b2/35a/f8e8b235a0eb24d311d6b745dac5910e.jpg" alt="imagem"><br><br>  Ap√≥s receber novas informa√ß√µes do vIOS3, o DR envia mensagens LS Update para todos os roteadores para o endere√ßo 224.0.0.5, para o qual outros roteadores, ap√≥s receberem um pacote, enviam o LS Acknowledge para o DR, mas para o endere√ßo 224.0.0.6 (endere√ßo para DR / BDR). <br><br>  De acordo com o mesmo esquema, tamb√©m conectamos o vIOS4.  Ap√≥s a sincroniza√ß√£o, todos os roteadores t√™m o mesmo LSDB.  Vamos ver a apar√™ncia dos estados vizinhos do vIOS3.  Mostre o comando ip ospf neighbour: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/3eb/51f/bf23eb51f7a7ab94f64be8726dae9370.jpg" alt="imagem"><br><br>  Como podemos ver, o DR √© 2.2.2.2, o BDR √© 1.1.1.1 e 2WAY / DROTHER √© selecionado com o vIOS4.  Os estados de vizinhan√ßa foram mencionados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acima</a> . <br><br>  E aqui est√£o os estados vizinhos no vIOS1 com o bairro estabelecido com o vIOS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3c/583/7e7/f3c5837e7b1d99243357857cc4cb1352.jpg" alt="imagem"><br><br>  Como voc√™ pode ver, ele tem dois DRs porque tem um vizinho em outro segmento da rede. <br><br><h3>  Multizones </h3><br>  Considere como o OSPF funciona quando v√°rias zonas s√£o usadas.  Mude nossa topologia adicionando novos roteadores: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/b16/f0c/54cb16f0c9293e15b65544b3b89573a4.jpg" alt="imagem"><br><br>  Para come√ßar, configuraremos o OSPF no vIOS1 e no vIOS para que suas interfaces Gi0 / 1 no vIOS e no vIOS1 estejam na zona 1. Vamos ver o que muda.  O vIOS1 agora possui interfaces na √Årea 0 (Gi0 / 0) e na √Årea 1 (Gi0 / 0).  Esse roteador √© chamado ABR - Area Border Router (abaixo, damos uma defini√ß√£o mais correta de ABR).  O ABR enviar√° informa√ß√µes de rota de uma zona para outra.  Isso √© feito atrav√©s do LSA tipo 3: <br><br>  <b>LSA tipo 3 - Resumo da rede LSA</b> - an√∫ncio resumido do status dos canais de rede: <br><br><ul><li>  Propaga√ß√£o por roteadores de borda </li><li>  An√∫ncio descreve rotas para redes fora da √°rea local </li><li>  Cont√©m informa√ß√µes sobre redes e o custo do caminho para essas redes, mas n√£o envia informa√ß√µes sobre a topologia de rede </li><li>  Por padr√£o, o roteador de borda envia um an√∫ncio separado para cada rede que conhece.  Se necess√°rio, na rede ABR pode ser resumido </li><li>  ID do estado do link - n√∫mero da rede de destino. </li></ul><br>  Na sua ess√™ncia, entre zonas, o princ√≠pio de opera√ß√£o do protocolo se assemelha ao do protocolo vetor de dist√¢ncia, transmitindo apenas informa√ß√µes de rota com m√©tricas.  Aqui est√° a atualiza√ß√£o LS do vIOS1 na √°rea 0, que cont√©m 3 partes do tipo 3 do LSA: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/681/fa8/3f3681fa87bb1a94778d4bec031f37a1.jpg" alt="imagem"><br><br>  Na sua ess√™ncia, a estrutura do LSA Tipo 3 n√£o √© muito diferente do LSA Tipo 1, mas eles afetam o protocolo de maneiras diferentes.  Quando um LSA atualizado √© recebido ou se algum LSA tipo 1 e 2 √© perdido, o SPF (algoritmo de caminho mais curto) √© reiniciado e recalcula o LSDB. <br><br>  Ap√≥s o recebimento do LSA Tipo 3, esse processo n√£o ocorre - √© obtida uma rota com uma m√©trica no LSA Tipo 3. Esse LSA armazena dados pelos quais o ABR recebeu uma determinada rota (o ABR √© especificado no campo Advertising Router) e uma m√©trica para atingir esse ABR j√° est√° dispon√≠vel no LSDB.  Assim, a m√©trica do LSA Tipo 3 √© resumida com a m√©trica da rota para o ABR e obtemos a rota finalizada sem reiniciar o SPF.  Esse processo √© chamado de <b>c√°lculo do SPF parcial</b> .  Isso √© muito importante porque em redes grandes, os tamanhos de LSDB podem ser muito grandes e a execu√ß√£o de SPFs geralmente n√£o √© boa.  Al√©m disso, a cria√ß√£o do LSA tipo 3 sugere que alterar e recalcular os LSDBs √© uma √°rea.  O ABR apenas relata que, com alguma rota, o que mudou. <br><br>  Tamb√©m √© importante observar que qualquer rota de uma zona diferente de zero para qualquer zona diferente de zero passa pela √Årea 0. Se houver um ABR, ele n√£o poder√° ser conectado √† √Årea 0 (exclu√≠mos a op√ß√£o com link virtual).  A √°rea 0 √© o n√∫cleo que conecta todas as outras zonas e fornece roteamento entre as zonas.  A defini√ß√£o de ABR √© assim: <br><br>  <b>Roteador de borda (ABR)</b> - conecta uma ou mais zonas √† zona de tronco e atua como um gateway para o tr√°fego entre zonas.  Um roteador de borda sempre tem pelo menos uma interface na zona de tronco.  Para cada zona conectada, o roteador mant√©m um banco de dados de status do canal separado. <br>  Lidamos com o estabelecimento do bairro, a cria√ß√£o de LSDB e SPF, com a zona habitual.  Agora, vejamos a converg√™ncia e resposta do OSPF √†s mudan√ßas na topologia. <br><br>  Vamos dar uma olhada em nossa topologia e imaginar que o vIOS3 parou de funcionar (o estado dos canais n√£o mudou).  Isso ajudar√° na reconstru√ß√£o da topologia do Dead Interval Timer - 40 segundos.  Se durante esse intervalo, o roteador n√£o receber um pacote Hello de um vizinho, o bairro entrar√° em colapso.  No nosso caso, o DR enviar√° o LS Update com o LSA Tipo 2, o que indica que n√£o h√° vIOS3 entre os roteadores conectados; isso far√° com que o SPF inicie e conte novamente o LSDB sem o LSA recebido do vIOS3.  √â importante observar que, em um roteador vIOS4 comum, mesmo o esgotamento do temporizador de intervalo morto e a perda de proximidade com o vIOS3 n√£o levam ao rec√°lculo da topologia, √© a mensagem LS Update com LSA Type 2 que inicia esse processo. <br><br>  <b>LSA tipo 2 - LSA de rede -</b> An√∫ncio de status de <b>link de rede</b> : <br><br><ul><li>  Distribu√≠do por DR em v√°rias redes de acesso </li><li>  O LSA de rede n√£o √© criado para redes nas quais o DR n√£o est√° selecionado </li><li>  Distribu√≠do apenas dentro de uma zona </li><li>  ID do estado do link - endere√ßo IP da interface DR </li></ul><br>  Portanto, a desconsidera√ß√£o dos dados que pararam de funcionar ocorre com a ajuda desta mensagem.  √â essa indica√ß√£o de vizinhos que √© o gatilho para descartar rotas irrelevantes. <br><br>  Ligue o vIOS3 novamente e estabele√ßa a vizinhan√ßa novamente.  O pr√≥ximo experimento ser√° uma rea√ß√£o √† desativa√ß√£o da interface Gi0 / 1 no vIOS3.  Assim que o vIOS3 detecta quedas de links, ele envia instantaneamente o LS Update para o DR para o endere√ßo 224.0.0.6, onde √© relatado que determinadas rotas ca√≠ram ao definir um sinalizador no LSA - LS Age igual a 3600 segundos.  Para o LSDB, essa √© a idade m√°xima e todos os LSAs com idade m√°xima n√£o s√£o levados em considera√ß√£o no SPF; portanto, eles n√£o estar√£o na tabela de roteamento.  A quest√£o √©: quando o Age LSA atinge naturalmente o Max Age, o que acontece?  Para fazer isso, o OSPF possui LSRefreshTime - igual √† metade da Idade m√°xima, a cada 1800 segundos, a atualiza√ß√£o do LS √© enviada do roteador para atualizar os dados do timer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43a/dd0/8c4/43add08c439f2826bb85e434a2280ae5.jpg" alt="imagem"><br><br>  Al√©m disso, ap√≥s o processamento da atualiza√ß√£o LS, o DR envia o LS LS para todos os outros roteadores para o endere√ßo 224.0.0.5.  Assim que os roteadores obt√™m novas informa√ß√µes - eles enviam o LSAck.  Isso garante uma boa converg√™ncia no OSPF. <br><br><h3>  Escolhendo a melhor rota </h3><br>  O roteador seleciona a melhor rota com base no menor valor m√©trico.  No entanto, o OSPF tamb√©m leva em considera√ß√£o v√°rios outros fatores ao escolher uma rota.  Nesse caso, a origem da rota e seu tipo s√£o importantes.  A sele√ß√£o de rota priorit√°ria √© a seguinte: <br><br><ul><li>  Rotas internas de uma zona (intra-√°rea) </li><li>  Rotas entre zonas (entre √°reas) </li><li>  Rotas externas tipo 1 (E1) </li><li>  Rotas externas tipo 2 (E2) </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora o custo da rota E2 n√£o seja alterado ao transferi-lo por zonas (o custo do caminho para o ASBR n√£o √© adicionado), quando o custo das rotas E2 coincide, o custo do caminho para o ASBR que anuncia a rota √© comparado. A m√©trica √© levada em considera√ß√£o quando voc√™ precisa escolher as rotas do mesmo tipo. Como m√©trica, √© usado um conceito como custo. √â calculado pela f√≥rmula: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cost = largura de banda de refer√™ncia / largura de banda de link. Largura de banda de refer√™ncia - a base da largura de banda. Por padr√£o, na Cisco, √© igual a 100Mbit. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preven√ß√£o de Loop ABR.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como dissemos acima, entre zonas, o princ√≠pio da opera√ß√£o OSPF √© semelhante ao protocolo de vetor de dist√¢ncia. </font><font style="vertical-align: inherit;">Usando os mecanismos de preven√ß√£o de loop, podemos concluir que o caminho n√£o ideal √© escolhido. </font><font style="vertical-align: inherit;">Por exemplo, entre zonas, existe uma regra como Split Horizon a partir de protocolos de vetor de dist√¢ncia. </font><font style="vertical-align: inherit;">Considere isso como um exemplo, se </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/318/d56/328/318d56328823c86abf8df0b5439e76b7.jpg" alt="imagem"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alterarmos </font><font style="vertical-align: inherit;">nossa topologia na borda das zonas 0 e 4 da seguinte forma: </font><font style="vertical-align: inherit;">ent√£o o vIOS18 escolher√° um caminho n√£o ideal com a m√©trica 100 atrav√©s da interface Gi0 / 0. </font><font style="vertical-align: inherit;">Isso ocorre devido ao fato de que o vIOS18 n√£o levar√° em considera√ß√£o o LSA Tipo 3 recebido e n√£o da zona 0. Al√©m disso, a regra acima pro√≠be transferir esse LSA Tipo 3 de volta para a zona 0.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418391/">https://habr.com/ru/post/pt418391/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418381/index.html">Novidades do DevTools no Chrome vers√£o 68</a></li>
<li><a href="../pt418383/index.html">Anima√ß√µes para Android baseadas em Kotlin e RxJava</a></li>
<li><a href="../pt418385/index.html">Como montei um computador para jogos antigos</a></li>
<li><a href="../pt418387/index.html">F√≠sicos dialogam sobre a alma</a></li>
<li><a href="../pt418389/index.html">RabbitMQ vs. Kafka: Usando Kafka em aplicativos orientados a eventos</a></li>
<li><a href="../pt418393/index.html">[Sexta-feira] Como serramos 3D na Web</a></li>
<li><a href="../pt418395/index.html">Elon Musk: geradores locais de campo eletromagn√©tico proteger√£o colonos em Marte</a></li>
<li><a href="../pt418397/index.html">Gerenciamento de sexta-feira: Webinars gratuitos do Skillbox</a></li>
<li><a href="../pt418399/index.html">Na onda da Selectel FM</a></li>
<li><a href="../pt418401/index.html">Como eu n√£o me tornei voc√™: um post de amor para administradores de sistemas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>