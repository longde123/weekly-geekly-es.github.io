<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔈 ⛵️ ™️ 以@Implement为例的编译时注释 🔬 👨🏾‍🎤 🙌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们都喜欢在编译阶段捕获错误，而不是运行时异常。 修复它们的最简单方法是，编译器本身会显示所有需要修复的位置。 尽管大多数问题只能在程序启动时才能检测到，但我们仍在尝试尽快做到这一点。  在类的初始化块中，在对象的构造函数中，在方法的第一次调用中，等等。 有时我们很幸运，即使在编译阶段，我们也知道足...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>以@Implement为例的编译时注释</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br> 我们都喜欢在编译阶段捕获错误，而不是运行时异常。 修复它们的最简单方法是，编译器本身会显示所有需要修复的位置。 尽管大多数问题只能在程序启动时才能检测到，但我们仍在尝试尽快做到这一点。 <a name="habracut"></a> 在类的初始化块中，在对象的构造函数中，在方法的第一次调用中，等等。 有时我们很幸运，即使在编译阶段，我们也知道足以检查程序是否存在某些错误。 <br><br> 在本文中，我想分享编写这样一个测试的经验。 更准确地说，就像编译器一样，创建可以引发错误的注释。 通过在RuNet中没有太多关于此主题的信息来判断，上述的快乐情况并不常见。 <br><br> 我将描述通用的验证算法，以及我花费时间和神经细胞的所有步骤和细微差别。 <br><br><h3> 问题陈述 </h3><br> 在本节中，我将给出一个使用此注释的示例。 如果您已经知道要执行的检查，则可以安全地跳过它。 我相信这不会影响演示文稿的完整性。 <br><br> 现在，我们将谈论更多关于提高代码的可读性，而不是修复错误。 可以说一个例子，来自生活，或者来自我的业余爱好项目。 <br><br> 假设有一个UnitManager类，它实际上是单元的集合。 它具有添加，删除，获取单位等的方法。 添加新单元时，管理员将为其分配一个ID。  id的生成委托给RotateCounter类，该类返回给定范围内的数字。 而且有一个小问题，RotateCounter无法知道所选ID是否可用。 根据依赖关系反转的原理，您可以创建一个接口，在我的例子中是RotateCounter.IClient，它具有单个方法isValueFree（），该方法接收id，如果id可用则返回true。 然后，UnitManager实现此接口，创建RotateCounter的实例，并将其作为客户端传递给自身。 <br><br> 我就是这样做的。 但是，在写完几天后打开了UnitManager的源代码后，当我看到isValueFree（）方法不符合UnitManager的逻辑时，我陷入了混乱。 如果可以指定哪个接口实现此方法，则将更加简单。 例如，在我来自Java的C＃中，显式接口实现有助于解决此问题。 在这种情况下，首先，您只能在显式转换为接口的情况下调用该方法。 其次，在这种情况下更重要的是，在方法签名中明确指出了接口名称（并且没有访问修饰符），例如： <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br> 一种解决方案是添加带有实现此方法的接口名称的注释。 类似于<code>@Override</code> ，仅具有接口。 我同意，您可以使用匿名内部类。 在这种情况下，就像在C＃中一样，不能仅在对象上调用该方法，您可以立即看到其实现的接口。 但是，这将增加代码量，因此会降低可读性。 是的，您需要以某种方式从类中获取它-创建一个getter或public字段（毕竟，Java中也没有重载强制转换语句）。 不错的选择，但我不喜欢它。 <br><br> 起初，我认为在Java中，就像在C＃中一样，注释是完整的类，可以从它们继承。 在这种情况下，您只需要创建一个从<code>@Override</code>继承的注释即可。 但是事实并非如此，在编译阶段，我不得不涉足令人惊奇而又令人恐惧的检查世界。 <br><br><div class="spoiler">  <b class="spoiler_title">UnitManager示例代码</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3> 一点理论 </h3><br> 我将立即进行保留，以上所有方法都是实例，因此，为了简便起见，我将使用类型名称和不带参数的方法名称来表示方法名称： <code>&lt;_&gt;.&lt;_&gt;()</code> 。 <br><br> 在编译阶段对元素的处理涉及特殊的处理器类。 这些是继承自<code>javax.annotation.processing.AbstractProcessor</code>类（您可以简单地实现<code>javax.annotation.processing.Processor</code>接口）。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关处理器的更多信息。 其中最重要的方法是过程。 在其中我们可以获取所有带注释元素的列表并进行必要的检查。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br> 起初，我非常天真，我认为在编译阶段使用类型的工作是从反射的角度进行的，但是……没有。 一切都基于那里的元素。 <br><br>  <b>元素</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.element.Element</a> ）-使用该语言的大多数结构元素的主界面。 元素的后代可以更精确地确定特定元素的属性（有关详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> ）： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.type.TypeMirror</a> ）与类&lt;？&gt;类似，由getClass（）方法返回。 例如，可以将它们进行比较以找出元素类型是否匹配。 您可以使用<code>Element.asType()</code>方法获取它。 此类型还返回一些类型操作，例如<code>TypeElement.getSuperclass()</code>或<code>TypeElement.getInterfaces()</code> 。 <br><br>  <b>类型</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.util.Types</a> ）-我建议您仔细看一下此类。 您可以在那找到很多有趣的东西。 本质上，这是一组用于处理类型的实用程序。 例如，它允许您从TypeMirror检索TypeElement。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.type.TypeKind</a> ）-一个枚举，使您可以澄清类型信息，检查类型是否为数组（ARRAY），自定义类型（DECLARED），类型变量（TYPEVAR）等。 您可以通过<code>TypeMirror.getKind()</code>获得它 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ElementKind</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.element.ElementKind</a> ）-枚举，使您可以澄清有关元素的信息，检查元素是否是数据包（PACKAGE），类（CLASS），方法（METHOD），接口（INTERFACE）等。 <br><br>  <b>Name</b> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javax.lang.model.element.Name</a> ）-使用元素名称的接口，可以通过<code>Element.getSimpleName()</code>获得。 <br><br> 基本上，这些类型足以让我编写验证算法。 <br><br> 我想指出另一个有趣的功能。  Eclipse中Element接口的实现位于org.eclipse ...包中，例如，表示方法的元素的类型为<code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> 。 这使我想到了这些接口是由每个IDE独立实现的。 <br><br><h3> 验证算法 </h3><br> 首先，您需要创建注释本身。 关于它的文章已经很多了（例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a> ），因此我将不对其进行详细介绍。 我只能说对于我们的示例，我们需要添加两个注释<code>@Target</code>和<code>@Retention</code> 。 第一个指示我们的注释只能应用于该方法，第二个指示该注释将仅存在于源代码中。 <br><br> 必须指定注释，该接口实现注释方法（注释所应用的方法）。 这可以通过两种方式完成：要么使用字符串指定接口的全名，例如<code>@Implement("com.ds.IInterface")</code> ，要么直接传递接口类： <code>@Implement(IInterface.class)</code> 。 第二种方法显然更好。 在这种情况下，编译器将监视正确的接口名称。 顺便说一句，如果调用此成员<b>值（），</b>则在向方法中添加注释时，无需显式指定此参数的名称。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br> 然后，乐趣开始了-创建处理器。 在处理方法中，我们获得所有带注释元素的列表。 然后，我们获得注释本身及其含义-指定的接口。 通常，处理器类框架如下所示： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br> 我想指出的是，您不能只获得那样的价值注释。 当您尝试调用<code>annotation.value()</code> ，将抛出<b>MirroredTypeException</b> ，但是从中可以获得TypeMirror。 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>这种作弊方法以及正确的价值收据： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br> 检查本身包括三个部分，如果其中至少一个失败，则需要显示错误消息并继续下一个注释。 顺便说一句，您可以使用以下方法显示错误消息： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br> 第一步是检查值注释是否为接口。 这里的一切都很简单： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br> 接下来，您需要检查带注释的方法所在的类是否实际上实现了指定的接口。 一开始，我愚蠢地用手进行了这项测试。 但是，然后，根据好的建议，我查看了<b>Types，</b>并在其中找到<code>Types.isSubtype()</code>方法，该方法将检查整个继承树，如果存在指定的接口，则返回true。 重要的是，与第一个选项不同，它可以与泛型类型一起使用。 <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br> 最后，您需要确保该接口具有与带注释的方法具有相同签名的方法。 我想使用<code>Types.isSubsignature()</code>方法，但是，不幸的是，如果该方法具有类型参数，它将无法正常工作。 因此，我们卷起袖子，用手写下所有支票。 我们又有三个。 好吧，更准确地说，方法签名由三部分组成：方法的名称，返回值的类型和参数列表。 您需要遍历接口的所有方法，并找到通过所有三项检查的方法。 最好不要忘记该方法可以从另一个接口继承并递归地对基础接口执行相同的检查。 <br><br> 调用必须放在process方法的循环末尾，如下所示： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  HaveMethod（）方法本身看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br> 看到问题了吗？ 不行吗 她在那里。 事实是，我找不到一种方法来获取通用接口的实际类型参数。 例如，我有一个实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Predicate</a>接口的类： <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br> 分析类中的方法时，参数的类型为<code>String</code> ，而在接口中为<code>T</code> ，并且所有尝试获取<code>String</code>而不是<code>String</code>尝试都不会导致任何结果。 最后，我没有想到的就是忽略类型参数。 该检查将通过任何实际的类型参数传递，即使它们不匹配。 幸运的是，如果该方法没有默认实现，并且未在基类中实现，则编译器将引发错误。 但是，如果有人知道如何解决这个问题，我将非常感谢您的提示。 <br><br><h3> 连接到Eclipse </h3><br> 就个人而言，我爱Eclipce，在我的实践中我只使用它。 因此，我将描述如何将处理器连接到此IDE。 为了使Eclipse能够看到处理器，您需要将其打包到单独的.JAR中，批注本身也将包含在其中。 在这种情况下，您需要在项目中创建<b>META-INF / services</b>文件夹，并在其中创建<b>javax.annotation.processing.Processor</b>文件<b>，</b>并指定处理器类的全名： <code>ds.magic.annotations.compileTime.ImplementProcessor</code> ，在我的示例中。 为了以防万一，我将提供一个屏幕截图，但是当对我没有任何帮助时，我几乎开始对项目的结构感到不快。 <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="图片"><br><br> 接下来，收集.JAR并将其连接到您的项目，首先将其作为常规库，以使注释在代码中可见。 然后，我们连接处理器（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处有</a>更多详细信息）。 为此，请打开<b>项目属性，</b>然后选择： <br><br><ol><li>  Java编译器-&gt;注释处理，然后选中“启用注释处理”框。 </li><li>  Java编译器-&gt;注释处理-&gt;工厂路径，选中“启用项目特定设置”复选框。 然后单击“添加JAR ...”，然后选择以前创建的JAR文件。 </li><li> 同意重建项目。 </li></ol><br><h3> 总结 </h3><br> 所有这些以及在Eclipse项目中都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>看到。 在撰写本文时，如果可以将注释称为该类，则只有两个类：Implement.java和ImplementProcessor.java。 我想您已经猜到了他们的目的。 <br><br> 也许这个注释对某些人似乎没有用。 也许是。 但就我个人而言，当方法名称不太适合该类目的时，我自己使用它而不是<code>@Override</code> 。 到目前为止，我还没有摆脱她的愿望。 总的来说，我为自己做了一个注释，这篇文章的目的是展示我正在攻击的耙子。 我希望我做到了。 谢谢您的关注。 <br><br>  PS。 感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">ohotNik_alex</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Comdiv的</a>用户在修复错误方面的帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414715/">https://habr.com/ru/post/zh-CN414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414705/index.html">全球扬声器构造的杰作：Monitor Audio从织物到金属和复合材料的创新之路</a></li>
<li><a href="../zh-CN414707/index.html">区块链分析，或者为什么混频器中断？</a></li>
<li><a href="../zh-CN414709/index.html">沙漠狮子与自省</a></li>
<li><a href="../zh-CN414711/index.html">西班牙足球应用程式La Liga使其使用者成为非自愿诈骗者</a></li>
<li><a href="../zh-CN414713/index.html">交叉反馈周</a></li>
<li><a href="../zh-CN414717/index.html">2018 4K电视：最佳选择的建议</a></li>
<li><a href="../zh-CN414719/index.html">四轮好，二轮好</a></li>
<li><a href="../zh-CN414723/index.html">编程竞赛：贸易</a></li>
<li><a href="../zh-CN414725/index.html">正面变化：为什么将质子流打入五米厚的混凝土墙</a></li>
<li><a href="../zh-CN414727/index.html">加密货币法即将在俄罗斯启动：它将对市场参与者产生什么变化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>