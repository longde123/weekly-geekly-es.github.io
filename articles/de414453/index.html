<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÖ ü§õüèº ü•† Implementieren Sie den Pfadfinder f√ºr KI-Agenten mit NavMesh üßö üêã üêì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dem Pfad folgen und den Verkehr kontrollieren 
 Manchmal brauchen wir KI-Charaktere, um die Spielwelt zu durchstreifen und einem grob definierten oder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementieren Sie den Pfadfinder f√ºr KI-Agenten mit NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="Bild"></div><br><h2>  Dem Pfad folgen und den Verkehr kontrollieren </h2><br>  Manchmal brauchen wir KI-Charaktere, um die Spielwelt zu durchstreifen und einem grob definierten oder genau definierten Pfad zu folgen.  In einem Rennspiel m√ºssen KI-Gegner beispielsweise die Stra√üe entlang fahren, und in RTS m√ºssen sich die Einheiten zum gew√ºnschten Punkt bewegen k√∂nnen, sich entlang des Gel√§ndes bewegen und die Position des anderen ber√ºcksichtigen. <br><br>  Um intelligent zu wirken, m√ºssen KI-Agenten bestimmen k√∂nnen, was sie tun. Wenn sie den gew√ºnschten Punkt nicht erreichen k√∂nnen, m√ºssen sie in der Lage sein, die effektivste Route zu zeichnen und ihren Weg zu √§ndern, wenn Hindernisse auf dem Weg erscheinen. <br><br>  Das Vermeiden von Hindernissen ist ein einfaches Verhalten, mit dem KI-Einheiten Zielpunkte erreichen k√∂nnen.  Es ist wichtig zu beachten, dass das in diesem Beitrag implementierte Verhalten f√ºr Verhaltensweisen wie die Crowd-Simulation gilt, bei denen das Hauptziel jedes Agenten darin besteht, andere Agenten zu meiden und das Ziel zu erreichen.  Sie bestimmen nicht den effizientesten und k√ºrzesten Weg. <br><br><h2>  Technische Anforderungen </h2><br>  Erfordert die Installation von Unity 2017 auf einem System mit Windows 7 SP1 +, 8, 10 oder Mac OS X 10.9+.  Der Code in diesem Artikel funktioniert nicht unter Windows XP und Vista, und Serverversionen von Windows und OS X wurden nicht getestet. <br><br>  Die Codedateien f√ºr diesen Beitrag finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Sehen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">dieses Video</a> an, um den Code in Aktion zu lernen. <br><a name="habracut"></a><br><h2>  Navigationsnetz </h2><br>  Lassen Sie uns herausfinden, wie der integrierte Unity-Navigationsnetzgenerator verwendet wird, der die Suche nach Pfaden f√ºr KI-Agenten erheblich vereinfachen kann.  In den fr√ºhen Phasen von Unity 5.x stand die NavMesh-Funktion allen Benutzern zur Verf√ºgung, einschlie√ülich Benutzern mit Personal Edition-Lizenzen, obwohl sie fr√ºher nur f√ºr Unity Pro verf√ºgbar war.  Vor der Ver√∂ffentlichung von 2017.1 wurde das System aktualisiert, um einen komponentenbasierten Workflow bereitzustellen. Da jedoch ein zus√§tzliches herunterladbares Paket erforderlich ist, das zum Zeitpunkt des Schreibens nur in der Vorschau-Version verf√ºgbar ist, werden wir den standardm√§√üigen szenenbasierten Workflow einhalten.  Keine Sorge, die Konzepte beider Ans√§tze sind √§hnlich, und wenn die fertige Implementierung schlie√ülich 2017.x erreicht, sollten keine wesentlichen √Ñnderungen vorgenommen werden. <br><br>  Weitere Informationen zum NavMesh-Komponentensystem in Unity auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Jetzt werden wir alle M√∂glichkeiten untersuchen, die dieses System uns bieten kann.  Um nach KI-Pfaden zu suchen, muss die Szene in einem bestimmten Format dargestellt werden.  Auf einer 2D-Karte wird ein zweidimensionales Gitter (Array) verwendet, um mithilfe des A * -Algorithmus nach Pfaden zu suchen.  KI-Agenten m√ºssen wissen, wo sich die Hindernisse befinden, insbesondere statische.  Der Umgang mit Kollisionen zwischen sich dynamisch bewegenden Objekten ist ein weiteres Problem, das allgemein als Lenkverhalten bezeichnet wird.  Unity verf√ºgt √ºber ein integriertes Tool zum Generieren von NavMesh, das die Szene in einem Kontext darstellt, in dem KI-Agenten den optimalen Pfad zum Ziel finden k√∂nnen.  √ñffnen Sie zun√§chst ein Demo-Projekt und rufen Sie die NavMesh-Szene auf. <br><br><h3>  Studienkarte </h3><br>  Nach dem √ñffnen der NavMesh-Demoszene sollte es wie im Screenshot aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Hindernis- und Hang-Szene</em> <br><br>  Dies ist unsere Sandbox zum Erkl√§ren und Testen der Funktionalit√§t des NavMesh-Systems.  Das allgemeine Schema √§hnelt einem Spiel im Genre RTS (Echtzeitstrategie).  Wir fahren einen blauen Panzer.  Klicken Sie auf verschiedene Punkte, damit sich der Tank auf sie zubewegt.  Die gelbe Anzeige ist das aktuelle Ziel des Tanks. <br><br><h3>  Navigation statisch </h3><br>  Zun√§chst m√ºssen Sie sagen, dass Sie die gesamte in NavMesh gebackene Geometrie in der Szene als <b>Navigationsstatik</b> markieren sollten.  M√∂glicherweise haben Sie dies bereits im Unity-Beleuchtungskartensystem gesehen.  Um Spielobjekte statisch zu machen, ist es sehr einfach, das Kontrollk√§stchen <b>Statisch</b> f√ºr alle ihre Eigenschaften (Navigation, Beleuchtung, Keulen, Stapeln usw.) zu aktivieren oder die Eigenschaften in der Dropdown-Liste anzugeben.  Das Kontrollk√§stchen befindet sich in der oberen rechten Ecke des Inspektors ausgew√§hlter Objekte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Eigenschaftsnavigation statisch</em> <br><br>  Dies kann einzeln f√ºr verschiedene Objekte erfolgen. Wenn Sie √ºber eine integrierte Hierarchie von Spielobjekten verf√ºgen, wenden Sie den Parameter auf das √ºbergeordnete Objekt an. Anschlie√üend bietet Unity an, ihn auf alle untergeordneten Objekte anzuwenden. <br><br><h3>  Braten eines Navigationsnetzes </h3><br>  F√ºr die gesamte Szene werden die Navigationsoptionen von navmesh √ºber das <b>Navigationsfenster</b> angewendet.  Dieses Fenster kann ge√∂ffnet werden, indem Sie zu <b>Fenster</b> | gehen  <b>Navigation</b>  Wie jedes andere Fenster kann es f√ºr freie Bewegung getrennt oder fixiert werden.  In unseren Screenshots wird es als angedockte Registerkarte neben der Hierarchie angezeigt. Sie k√∂nnen dieses Fenster jedoch an einer beliebigen Stelle platzieren. <br><br>  Wenn Sie das Fenster √∂ffnen, sehen Sie einzelne Registerkarten.  Es wird ungef√§hr so ‚Äã‚Äãaussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Navigationsfenster</em> <br><br>  In unserem Fall zeigt der vorherige Screenshot die Registerkarte Backen. In Ihrem Editor kann jedoch standardm√§√üig jede Registerkarte ausgew√§hlt werden. <br><br>  Schauen wir uns die einzelnen Registerkarten an, beginnend von links und nach rechts.  Beginnen wir mit der Registerkarte " <b>Agenten"</b> , die wie im Screenshot dargestellt aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Registerkarte "Agenten"</em> <br><br>  Wenn Sie an einem anderen Projekt arbeiten, stellen Sie m√∂glicherweise fest, dass einige der Einstellungen von denen abweichen, die wir f√ºr das im Screenshot gezeigte Beispielprojekt festgelegt haben.  Oben auf der Registerkarte befindet sich eine Liste, in der Sie neue Agententypen hinzuf√ºgen k√∂nnen, indem Sie auf die Schaltfl√§che <b>+</b> klicken.  Sie k√∂nnen zus√§tzliche Agenten entfernen, indem Sie sie ausw√§hlen und auf die Schaltfl√§che <b>-</b> klicken.  Das Fenster zeigt deutlich, was verschiedene Einstellungen beim √Ñndern tun.  Mal sehen, was jede der Einstellungen bewirkt: <br><br><ul><li>  Name: Name des Agententyps, der in der Dropdown-Liste Agententypen angezeigt wird. </li><li>  Radius: Sie k√∂nnen sich das als den ‚Äûpers√∂nlichen Raum‚Äú eines Agenten vorstellen.  Agenten werden versuchen, einen zu engen Kontakt mit anderen Agenten basierend auf diesem Wert zu vermeiden, da er zur Vermeidung verwendet wird. </li><li>  H√∂he: Wie Sie vielleicht erraten haben, legt diese Einstellung die H√∂he des Agenten fest, den er zur vertikalen Vermeidung verwendet (z. B. beim Passieren unter Objekten). </li><li>  Schritth√∂he: Dieser Wert bestimmt, auf welche H√∂he der Agent klettern kann. </li><li>  Max. Steigung: Wie wir im n√§chsten Abschnitt sehen werden, bestimmt dieser Wert den maximalen Winkel, unter dem der Agent klettern kann.  Mit diesem Parameter k√∂nnen Sie die steilen H√§nge der Karte f√ºr den Agenten unzug√§nglich machen. </li></ul><br>  Als n√§chstes haben wir die Registerkarte <b>Bereiche</b> , die wie in diesem Screenshot gezeigt aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Wie Sie im Screenshot sehen k√∂nnen, bietet Unity verschiedene Arten von Bereichen, die nicht ge√§ndert werden k√∂nnen: <b>Begehbar</b> , <b>Nicht begehbar</b> und <b>Springen</b> .  Zus√§tzlich zum Benennen und Erstellen neuer Bereiche k√∂nnen Sie diesen Bereichen die Kosten f√ºr das Verschieben zuweisen. <br><br>  Bereiche dienen zwei Zwecken: Bereiche f√ºr den Agenten zug√§nglich oder unzug√§nglich machen und Bereiche im Hinblick auf die Reisekosten als weniger w√ºnschenswert markieren.  Sie k√∂nnen beispielsweise ein Rollenspiel entwickeln, in dem D√§monenfeinde keine Gebiete betreten k√∂nnen, die als ‚Äûgeweihter Boden‚Äú gekennzeichnet sind.  Sie k√∂nnen einige Bereiche der Karte auch als ‚ÄûSumpf‚Äú oder ‚ÄûSumpf‚Äú markieren, was der Agent aufgrund der hohen Umzugskosten vermeiden wird. <br><br>  Die dritte Registerkarte Backen ist wahrscheinlich die wichtigste.  Sie k√∂nnen NavMesh selbst f√ºr die Szene erstellen.  Sie sollten bereits mit einigen Optionen vertraut sein.  Die Registerkarte Backen sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Tab backen</em> <br><br>  Die Optionen f√ºr die Agentengr√∂√üe auf dieser Registerkarte bestimmen, wie Agenten mit der Umgebung interagieren, w√§hrend die Optionen auf der Registerkarte <b>Agenten</b> die Interaktionen mit anderen Agenten und sich bewegenden Objekten steuern.  Sie steuern jedoch dieselben Parameter, sodass wir sie √ºberspringen.  <b>Drop Height</b> und <b>Jump Distance</b> steuern, wie weit der Agent ‚Äûspringen‚Äú kann, um den Teil von NavMesh zu erreichen, der nicht direkt mit dem Teil zusammenh√§ngt, in dem sich der Agent gerade befindet.  Wir werden dies im Folgenden genauer betrachten. Wenn Sie sich also nicht sicher sind, k√∂nnen Sie diese Parameter immer noch nicht untersuchen. <br><br>  Dar√ºber hinaus gibt es erweiterte Optionen, die normalerweise standardm√§√üig ausgeblendet sind.  Um diese Optionen zu erweitern, klicken Sie einfach auf das Dropdown-Dreieck neben der √úberschrift <b>Erweitert</b> .  <b>Die manuelle Voxelgr√∂√üe</b> kann als ‚ÄûQualit√§tseinstellung‚Äú angesehen werden.  Je kleiner die Gr√∂√üe, desto mehr Details werden im Netz gespeichert.  <b>Min Region Area wird</b> verwendet, um Backplattformen oder Oberfl√§chen unterhalb des ausgew√§hlten Schwellenwerts zu √ºberspringen.  <b>H√∂he</b> Netz gibt uns detailliertere vertikale Daten beim Backen eines Netzes.  Mit dieser Option k√∂nnen Sie beispielsweise beim Treppensteigen die korrekte Position des Agenten beibehalten. <br><br>  Mit der Schaltfl√§che <b>L√∂schen werden</b> alle NavMesh-Daten der Szene gel√∂scht, und mit der Schaltfl√§che Backen wird ein Netz f√ºr die Szene erstellt.  Der Backvorgang ist ziemlich schnell.  Solange Sie ein Fenster ausgew√§hlt haben, k√∂nnen Sie die Erzeugung von NavMesh mit der Schaltfl√§che Backen im Szenenfenster beobachten.  Klicken wir auf die Schaltfl√§che <b>Backen</b> , um die Ergebnisse anzuzeigen.  In unserer Beispielszene erhalten wir etwas √Ñhnliches wie diesen Screenshot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Die blauen Bereiche zeigen NavMesh.  Im Folgenden werden wir darauf zur√ºckkommen.  Fahren wir in der Zwischenzeit mit der letzten Registerkarte fort - <b>Objekt</b> , das folgenderma√üen aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Die drei im vorherigen Screenshot gezeigten Schaltfl√§chen - <b>Alle</b> , <b>Netz-Renderer</b> und <b>Terrains</b> - werden als Szenenfilter verwendet.  Sie sind n√ºtzlich, wenn Sie in komplexen Szenen mit vielen Objekten in der Hierarchie arbeiten.  Durch Auswahl einer Option wird der entsprechende Typ aus der Hierarchie herausgefiltert, sodass die Auswahl vereinfacht wird.  Mit den Schaltfl√§chen k√∂nnen Sie Ihre Szene auf der Suche nach Objekten durchsuchen, die Sie als statische Navigation markieren m√∂chten. <br><br><h3>  Verwenden des Nav Mesh Agent </h3><br>  Nachdem wir die Szene mit NavMesh eingerichtet haben, muss der Agent diese Informationen verwenden k√∂nnen.  Zum Gl√ºck hat Unity eine <b>Nav Mesh Agent-</b> Komponente, die Sie auf einen Charakter ziehen k√∂nnen.  In unserer Beispielszene gibt es ein Spielobjekt namens <b>Tank</b> , an das bereits eine Komponente angeh√§ngt ist.  Schauen Sie sich die Hierarchie an und Sie werden ungef√§hr Folgendes sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Hier gibt es einige Parameter, und wir werden nicht alles ber√ºcksichtigen, da sie ziemlich klar sind und die Beschreibung in der offiziellen Unity-Dokumentation zu finden ist.  Aber wir werden die wichtigsten Dinge erw√§hnen: <br><br><ul><li>  <strong>Agententyp</strong> : Erinnern Sie sich an die Registerkarte <strong>Agenten</strong> im <strong>Navigationsfenster</strong> ?  Hier k√∂nnen zuweisbare Agententypen ausgew√§hlt werden. </li><li>  <strong>Auto-Traverse-Off-Mesh-Link</strong> : Mit dieser Option k√∂nnen Agenten automatisch die <strong>Off-Mesh-Link-</strong> Funktion verwenden, die im Folgenden <strong>erl√§utert</strong> wird. </li><li>  <strong>Bereichsmaske</strong> : Hier k√∂nnen Sie die Bereiche ausw√§hlen, die auf der Registerkarte <strong>Bereiche</strong> des <strong>Navigationsfensters</strong> konfiguriert wurden. </li></ul><br>  Das ist alles.  Diese Komponente erledigt 90% der harten Arbeit f√ºr uns: Wegbereiter, Vermeidung von Hindernissen und so weiter.  Sie m√ºssen lediglich den Zielpunkt an den Agenten √ºbertragen.  Schauen wir uns dieses Problem an. <br><br><h3>  Zielpunkteinstellung </h3><br>  Nachdem wir den KI-Agenten eingerichtet haben, m√ºssen wir ihm sagen, wohin er gehen soll.  In unserem Beispielprojekt gibt es ein Skript namens <b>Target.cs</b> , das genau diese Aufgabe ausf√ºhrt. <br><br>  Dies ist eine einfache Klasse, die drei Dinge tut: <br><br><ul><li>  "Schie√üt" den Strahl von der Kamera zur Mausposition in der Welt </li><li>  Aktualisiert die Markerposition </li><li>  Aktualisiert die Zieleigenschaft f√ºr alle NavMesh-Agenten. </li></ul><br>  Der Code ist recht einfach.  Die ganze Klasse ist wie folgt: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Die folgenden Aktionen werden hier ausgef√ºhrt: In der <b>Start-</b> Methode initialisieren wir das <b>navAgents-</b> Array mit der <b>FindObjectsOfType ()</b> -Methode. <br><br>  Die <b>UpdateTargets ()</b> -Methode durchl√§uft unser <b>navAgents-</b> Array und legt den Zielpunkt f√ºr sie im angegebenen <b>Vector3 fest</b> .  Dies ist der Schl√ºssel zum Code.  Sie k√∂nnen einen beliebigen Mechanismus verwenden, um den Zielpunkt <b>abzurufen. Damit sich</b> der Agent dorthin bewegen kann, legen Sie <b>einfach das</b> Feld <b>NavMeshAgent.destination fest</b> .  Der Agent erledigt den Rest. <br><br>  In unserem Beispiel werden Klicks zum Bewegen verwendet. Wenn also ein Spieler auf die Maus klickt, geben wir den Strahl von der Kamera in Richtung des Mauszeigers in die Welt frei. Wenn er sich mit etwas schneidet, weisen wir dem neuen <b>targetPosition-</b> Agenten einen Kollisionspunkt zu.  Wir passen auch die Zielmarkierung entsprechend an, um das Ziel im Spiel einfach zu visualisieren. <br><br>  Um den Vorgang zu testen, m√ºssen Sie NavMesh gem√§√ü der Beschreibung im vorherigen Abschnitt backen, dann den Wiedergabemodus starten und einen beliebigen Bereich auf der Karte ausw√§hlen.  Wenn Sie mehrmals klicken, k√∂nnen Sie feststellen, dass der Agent einige Bereiche nicht erreichen kann - die oberen Bereiche der roten W√ºrfel, die obere Plattform und die Plattform am unteren Bildschirmrand. <br><br>  Rote W√ºrfel sind zu hoch.  Der Hang, der zur h√∂chsten Plattform f√ºhrt, ist f√ºr unsere <b>Max Slope-</b> Einstellungen zu scharf, und der Agent kann ihn nicht erklimmen.  Die folgenden Screenshots zeigen, wie sich die Einstellungen f√ºr die maximale Neigung auf NavMesh auswirken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh mit maximaler Steigung = 45</i> <br><br>  Wenn Sie den Wert f√ºr die maximale <b>Steigung</b> in etwa <b>51</b> √§ndern und dann erneut auf die Schaltfl√§che Backen klicken, um NavMesh erneut zu backen, lauten die Ergebnisse wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh mit maximaler Steigung = 51</em> <br><br>  Wie Sie sehen, k√∂nnen wir das Level-Design anpassen und so ganze Bereiche unzug√§nglich machen, indem wir einen einzelnen Parameter √§ndern.  Dies kann beispielsweise n√ºtzlich sein, wenn Sie eine Plattform oder einen Sims haben, f√ºr deren Klettern ein Seil, eine Leiter oder ein Aufzug erforderlich ist.  Oder vielleicht eine besondere F√§higkeit, zum Beispiel die F√§higkeit zu klettern? <br><br><h3>  Anwendung Off Mesh Links </h3><br>  Sie werden vielleicht feststellen, dass es in unserer Szene zwei Pausen gibt.  Unser Agent kann in den ersten gelangen, aber der am unteren Bildschirmrand ist zu weit entfernt.  Diese Berechnungen sind nicht v√∂llig willk√ºrlich.  <strong>Off-Mesh-Links bilden im</strong> Wesentlichen eine Br√ºcke zwischen den Zwischenr√§umen zwischen nicht verwandten NavMesh-Segmenten.  Diese Links sind im Editor zu sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Blaue Kreise mit Verbindungslinien sind Verbindungen.</i> <br><br>  Unity kann diese Links auf zwei Arten erzeugen.  Das erste haben wir schon √ºberlegt.  Erinnern Sie sich an den <b>Sprungdistanzwert</b> auf der Registerkarte Backen des <b>Navigationsfensters</b> ?  Unity verwendet diesen Wert automatisch, um diese Links beim Backen von NavMesh zu generieren.  Versuchen Sie, den Wert in unserer Testszene auf 5 zu √§ndern und erneut zu backen.  Sehen Sie - die Plattformen sind jetzt verbunden?  Dies liegt daran, dass die Netze jetzt innerhalb des neu angegebenen Schwellenwerts liegen. <br><br>  √Ñndern Sie den Wert erneut auf 2 und backen Sie.  Schauen wir uns nun den zweiten Weg an.  Erstellen Sie die Kugeln, mit denen die beiden Plattformen verbunden werden.  Platzieren Sie sie ungef√§hr wie im Screenshot gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Sie k√∂nnen bereits sehen, was passiert, aber lassen Sie uns den Prozess analysieren, der es ihnen erm√∂glicht, eine Verbindung herzustellen.  In unserem Fall habe ich die Kugel am rechten <b>Anfang</b> und die Kugel am linken <b>Ende genannt</b> .  Sie werden bald verstehen warum.  Als N√§chstes habe ich der Plattform auf der rechten Seite die <b>Off Mesh Link-</b> Komponente hinzugef√ºgt (relativ zum vorherigen Screenshot).  Sie werden feststellen, dass die Komponente <b>Start-</b> und Endfelder hat.  Wie Sie vielleicht erraten haben, ziehen wir die zuvor erstellten Kugeln in die entsprechenden Slots - die Startkugel im <b>Startfeld</b> und die Endkugel im Endfeld.  Der Inspektor sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  Der Wert von <b>Cost Override wird</b> ber√ºcksichtigt, wenn er einen positiven Wert erh√§lt.  Bei Verwendung dieser Beziehung wird ein Kostenfaktor angewendet, im Gegensatz zu einem kosteng√ºnstigeren Weg zum Ziel. <br><br>  <b>Bi Directional,</b> wenn true, erm√∂glicht es dem Agenten, sich in beide Richtungen zu bewegen.  Um Links mit Einwegverkehr zu erstellen, k√∂nnen Sie diesen Wert deaktivieren.  Der Wert <b>Aktiviert wird</b> entsprechend seinem Namen verwendet.  Bei false ignoriert der Agent diese Zuordnung.  Sie k√∂nnen es ein- und ausschalten, um Spielszenarien zu erstellen, in denen ein Spieler beispielsweise einen Schalter dr√ºcken muss, um eine Verbindung zu aktivieren. <br><br>  Um diese Beziehung zu erm√∂glichen, ist kein erneutes Backen erforderlich.  Schauen Sie sich Ihr NavMesh an und Sie werden sehen, dass es genau so aussieht wie im Screenshot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Wie Sie sehen k√∂nnen, wird die kleinere L√ºcke immer noch automatisch verbunden, und jetzt haben wir eine neue Verbindung, die von der <b>Off Mesh Link-</b> Komponente zwischen den beiden Kugeln generiert wird.  Starten Sie den Wiedergabemodus und klicken Sie auf die entfernte Plattform.  Wie erwartet kann der Agent jetzt zur nicht verbundenen Plattform navigieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Auf den Ebenen Ihres Spiels m√ºssen Sie m√∂glicherweise diese Parameter √§ndern, um die gew√ºnschten Ergebnisse zu erzielen. Eine Kombination dieser Funktionen bietet Ihnen jedoch ein praktisches, vorgefertigtes Werkzeug.  Mit der NavMesh-Funktion k√∂nnen Sie schnell ein einfaches Spiel erstellen. <br><br>  <em>Dieses Tutorial ist Teil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Unity 2017 Game AI Programming - Dritte Ausgabe</a> von Ray Barrera, Aung Sithu Kyaw und Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414453/">https://habr.com/ru/post/de414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414443/index.html">Funktionen von Funktionsaufrufen in C ++</a></li>
<li><a href="../de414445/index.html">Verbesserung von Zimbra mit der Zextras Suite</a></li>
<li><a href="../de414447/index.html">Sorten aller Zeiten</a></li>
<li><a href="../de414449/index.html">Wie man sich mit allen Betreibern im Stadion anfreundet und es nicht mit Hunderten von Antennen s√§t</a></li>
<li><a href="../de414451/index.html">"Testerkalender" f√ºr Juni. Der Tester muss den Fehler erkennen, Caner lesen und den Umzug organisieren.</a></li>
<li><a href="../de414455/index.html">Algorithmus zur Erzeugung von Farbpaletten</a></li>
<li><a href="../de414459/index.html">Detektoren und Deskriptoren von singul√§ren Punkten FAST, BRIEF, ORB</a></li>
<li><a href="../de414463/index.html">AI selbst hat gelernt, wie man einen Zauberw√ºrfel baut</a></li>
<li><a href="../de414465/index.html">Meta Crush Saga: Spiel zur Kompilierungszeit</a></li>
<li><a href="../de414467/index.html">Beitr√§ge von der Minsk C ++ Konferenz CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>