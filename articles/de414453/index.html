<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 🤛🏼 🥠 Implementieren Sie den Pfadfinder für KI-Agenten mit NavMesh 🧚 🐋 🐓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dem Pfad folgen und den Verkehr kontrollieren 
 Manchmal brauchen wir KI-Charaktere, um die Spielwelt zu durchstreifen und einem grob definierten oder...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementieren Sie den Pfadfinder für KI-Agenten mit NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="Bild"></div><br><h2>  Dem Pfad folgen und den Verkehr kontrollieren </h2><br>  Manchmal brauchen wir KI-Charaktere, um die Spielwelt zu durchstreifen und einem grob definierten oder genau definierten Pfad zu folgen.  In einem Rennspiel müssen KI-Gegner beispielsweise die Straße entlang fahren, und in RTS müssen sich die Einheiten zum gewünschten Punkt bewegen können, sich entlang des Geländes bewegen und die Position des anderen berücksichtigen. <br><br>  Um intelligent zu wirken, müssen KI-Agenten bestimmen können, was sie tun. Wenn sie den gewünschten Punkt nicht erreichen können, müssen sie in der Lage sein, die effektivste Route zu zeichnen und ihren Weg zu ändern, wenn Hindernisse auf dem Weg erscheinen. <br><br>  Das Vermeiden von Hindernissen ist ein einfaches Verhalten, mit dem KI-Einheiten Zielpunkte erreichen können.  Es ist wichtig zu beachten, dass das in diesem Beitrag implementierte Verhalten für Verhaltensweisen wie die Crowd-Simulation gilt, bei denen das Hauptziel jedes Agenten darin besteht, andere Agenten zu meiden und das Ziel zu erreichen.  Sie bestimmen nicht den effizientesten und kürzesten Weg. <br><br><h2>  Technische Anforderungen </h2><br>  Erfordert die Installation von Unity 2017 auf einem System mit Windows 7 SP1 +, 8, 10 oder Mac OS X 10.9+.  Der Code in diesem Artikel funktioniert nicht unter Windows XP und Vista, und Serverversionen von Windows und OS X wurden nicht getestet. <br><br>  Die Codedateien für diesen Beitrag finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Sehen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">dieses Video</a> an, um den Code in Aktion zu lernen. <br><a name="habracut"></a><br><h2>  Navigationsnetz </h2><br>  Lassen Sie uns herausfinden, wie der integrierte Unity-Navigationsnetzgenerator verwendet wird, der die Suche nach Pfaden für KI-Agenten erheblich vereinfachen kann.  In den frühen Phasen von Unity 5.x stand die NavMesh-Funktion allen Benutzern zur Verfügung, einschließlich Benutzern mit Personal Edition-Lizenzen, obwohl sie früher nur für Unity Pro verfügbar war.  Vor der Veröffentlichung von 2017.1 wurde das System aktualisiert, um einen komponentenbasierten Workflow bereitzustellen. Da jedoch ein zusätzliches herunterladbares Paket erforderlich ist, das zum Zeitpunkt des Schreibens nur in der Vorschau-Version verfügbar ist, werden wir den standardmäßigen szenenbasierten Workflow einhalten.  Keine Sorge, die Konzepte beider Ansätze sind ähnlich, und wenn die fertige Implementierung schließlich 2017.x erreicht, sollten keine wesentlichen Änderungen vorgenommen werden. <br><br>  Weitere Informationen zum NavMesh-Komponentensystem in Unity auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Jetzt werden wir alle Möglichkeiten untersuchen, die dieses System uns bieten kann.  Um nach KI-Pfaden zu suchen, muss die Szene in einem bestimmten Format dargestellt werden.  Auf einer 2D-Karte wird ein zweidimensionales Gitter (Array) verwendet, um mithilfe des A * -Algorithmus nach Pfaden zu suchen.  KI-Agenten müssen wissen, wo sich die Hindernisse befinden, insbesondere statische.  Der Umgang mit Kollisionen zwischen sich dynamisch bewegenden Objekten ist ein weiteres Problem, das allgemein als Lenkverhalten bezeichnet wird.  Unity verfügt über ein integriertes Tool zum Generieren von NavMesh, das die Szene in einem Kontext darstellt, in dem KI-Agenten den optimalen Pfad zum Ziel finden können.  Öffnen Sie zunächst ein Demo-Projekt und rufen Sie die NavMesh-Szene auf. <br><br><h3>  Studienkarte </h3><br>  Nach dem Öffnen der NavMesh-Demoszene sollte es wie im Screenshot aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Hindernis- und Hang-Szene</em> <br><br>  Dies ist unsere Sandbox zum Erklären und Testen der Funktionalität des NavMesh-Systems.  Das allgemeine Schema ähnelt einem Spiel im Genre RTS (Echtzeitstrategie).  Wir fahren einen blauen Panzer.  Klicken Sie auf verschiedene Punkte, damit sich der Tank auf sie zubewegt.  Die gelbe Anzeige ist das aktuelle Ziel des Tanks. <br><br><h3>  Navigation statisch </h3><br>  Zunächst müssen Sie sagen, dass Sie die gesamte in NavMesh gebackene Geometrie in der Szene als <b>Navigationsstatik</b> markieren sollten.  Möglicherweise haben Sie dies bereits im Unity-Beleuchtungskartensystem gesehen.  Um Spielobjekte statisch zu machen, ist es sehr einfach, das Kontrollkästchen <b>Statisch</b> für alle ihre Eigenschaften (Navigation, Beleuchtung, Keulen, Stapeln usw.) zu aktivieren oder die Eigenschaften in der Dropdown-Liste anzugeben.  Das Kontrollkästchen befindet sich in der oberen rechten Ecke des Inspektors ausgewählter Objekte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Eigenschaftsnavigation statisch</em> <br><br>  Dies kann einzeln für verschiedene Objekte erfolgen. Wenn Sie über eine integrierte Hierarchie von Spielobjekten verfügen, wenden Sie den Parameter auf das übergeordnete Objekt an. Anschließend bietet Unity an, ihn auf alle untergeordneten Objekte anzuwenden. <br><br><h3>  Braten eines Navigationsnetzes </h3><br>  Für die gesamte Szene werden die Navigationsoptionen von navmesh über das <b>Navigationsfenster</b> angewendet.  Dieses Fenster kann geöffnet werden, indem Sie zu <b>Fenster</b> | gehen  <b>Navigation</b>  Wie jedes andere Fenster kann es für freie Bewegung getrennt oder fixiert werden.  In unseren Screenshots wird es als angedockte Registerkarte neben der Hierarchie angezeigt. Sie können dieses Fenster jedoch an einer beliebigen Stelle platzieren. <br><br>  Wenn Sie das Fenster öffnen, sehen Sie einzelne Registerkarten.  Es wird ungefähr so ​​aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Navigationsfenster</em> <br><br>  In unserem Fall zeigt der vorherige Screenshot die Registerkarte Backen. In Ihrem Editor kann jedoch standardmäßig jede Registerkarte ausgewählt werden. <br><br>  Schauen wir uns die einzelnen Registerkarten an, beginnend von links und nach rechts.  Beginnen wir mit der Registerkarte " <b>Agenten"</b> , die wie im Screenshot dargestellt aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Registerkarte "Agenten"</em> <br><br>  Wenn Sie an einem anderen Projekt arbeiten, stellen Sie möglicherweise fest, dass einige der Einstellungen von denen abweichen, die wir für das im Screenshot gezeigte Beispielprojekt festgelegt haben.  Oben auf der Registerkarte befindet sich eine Liste, in der Sie neue Agententypen hinzufügen können, indem Sie auf die Schaltfläche <b>+</b> klicken.  Sie können zusätzliche Agenten entfernen, indem Sie sie auswählen und auf die Schaltfläche <b>-</b> klicken.  Das Fenster zeigt deutlich, was verschiedene Einstellungen beim Ändern tun.  Mal sehen, was jede der Einstellungen bewirkt: <br><br><ul><li>  Name: Name des Agententyps, der in der Dropdown-Liste Agententypen angezeigt wird. </li><li>  Radius: Sie können sich das als den „persönlichen Raum“ eines Agenten vorstellen.  Agenten werden versuchen, einen zu engen Kontakt mit anderen Agenten basierend auf diesem Wert zu vermeiden, da er zur Vermeidung verwendet wird. </li><li>  Höhe: Wie Sie vielleicht erraten haben, legt diese Einstellung die Höhe des Agenten fest, den er zur vertikalen Vermeidung verwendet (z. B. beim Passieren unter Objekten). </li><li>  Schritthöhe: Dieser Wert bestimmt, auf welche Höhe der Agent klettern kann. </li><li>  Max. Steigung: Wie wir im nächsten Abschnitt sehen werden, bestimmt dieser Wert den maximalen Winkel, unter dem der Agent klettern kann.  Mit diesem Parameter können Sie die steilen Hänge der Karte für den Agenten unzugänglich machen. </li></ul><br>  Als nächstes haben wir die Registerkarte <b>Bereiche</b> , die wie in diesem Screenshot gezeigt aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Wie Sie im Screenshot sehen können, bietet Unity verschiedene Arten von Bereichen, die nicht geändert werden können: <b>Begehbar</b> , <b>Nicht begehbar</b> und <b>Springen</b> .  Zusätzlich zum Benennen und Erstellen neuer Bereiche können Sie diesen Bereichen die Kosten für das Verschieben zuweisen. <br><br>  Bereiche dienen zwei Zwecken: Bereiche für den Agenten zugänglich oder unzugänglich machen und Bereiche im Hinblick auf die Reisekosten als weniger wünschenswert markieren.  Sie können beispielsweise ein Rollenspiel entwickeln, in dem Dämonenfeinde keine Gebiete betreten können, die als „geweihter Boden“ gekennzeichnet sind.  Sie können einige Bereiche der Karte auch als „Sumpf“ oder „Sumpf“ markieren, was der Agent aufgrund der hohen Umzugskosten vermeiden wird. <br><br>  Die dritte Registerkarte Backen ist wahrscheinlich die wichtigste.  Sie können NavMesh selbst für die Szene erstellen.  Sie sollten bereits mit einigen Optionen vertraut sein.  Die Registerkarte Backen sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Tab backen</em> <br><br>  Die Optionen für die Agentengröße auf dieser Registerkarte bestimmen, wie Agenten mit der Umgebung interagieren, während die Optionen auf der Registerkarte <b>Agenten</b> die Interaktionen mit anderen Agenten und sich bewegenden Objekten steuern.  Sie steuern jedoch dieselben Parameter, sodass wir sie überspringen.  <b>Drop Height</b> und <b>Jump Distance</b> steuern, wie weit der Agent „springen“ kann, um den Teil von NavMesh zu erreichen, der nicht direkt mit dem Teil zusammenhängt, in dem sich der Agent gerade befindet.  Wir werden dies im Folgenden genauer betrachten. Wenn Sie sich also nicht sicher sind, können Sie diese Parameter immer noch nicht untersuchen. <br><br>  Darüber hinaus gibt es erweiterte Optionen, die normalerweise standardmäßig ausgeblendet sind.  Um diese Optionen zu erweitern, klicken Sie einfach auf das Dropdown-Dreieck neben der Überschrift <b>Erweitert</b> .  <b>Die manuelle Voxelgröße</b> kann als „Qualitätseinstellung“ angesehen werden.  Je kleiner die Größe, desto mehr Details werden im Netz gespeichert.  <b>Min Region Area wird</b> verwendet, um Backplattformen oder Oberflächen unterhalb des ausgewählten Schwellenwerts zu überspringen.  <b>Höhe</b> Netz gibt uns detailliertere vertikale Daten beim Backen eines Netzes.  Mit dieser Option können Sie beispielsweise beim Treppensteigen die korrekte Position des Agenten beibehalten. <br><br>  Mit der Schaltfläche <b>Löschen werden</b> alle NavMesh-Daten der Szene gelöscht, und mit der Schaltfläche Backen wird ein Netz für die Szene erstellt.  Der Backvorgang ist ziemlich schnell.  Solange Sie ein Fenster ausgewählt haben, können Sie die Erzeugung von NavMesh mit der Schaltfläche Backen im Szenenfenster beobachten.  Klicken wir auf die Schaltfläche <b>Backen</b> , um die Ergebnisse anzuzeigen.  In unserer Beispielszene erhalten wir etwas Ähnliches wie diesen Screenshot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Die blauen Bereiche zeigen NavMesh.  Im Folgenden werden wir darauf zurückkommen.  Fahren wir in der Zwischenzeit mit der letzten Registerkarte fort - <b>Objekt</b> , das folgendermaßen aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Die drei im vorherigen Screenshot gezeigten Schaltflächen - <b>Alle</b> , <b>Netz-Renderer</b> und <b>Terrains</b> - werden als Szenenfilter verwendet.  Sie sind nützlich, wenn Sie in komplexen Szenen mit vielen Objekten in der Hierarchie arbeiten.  Durch Auswahl einer Option wird der entsprechende Typ aus der Hierarchie herausgefiltert, sodass die Auswahl vereinfacht wird.  Mit den Schaltflächen können Sie Ihre Szene auf der Suche nach Objekten durchsuchen, die Sie als statische Navigation markieren möchten. <br><br><h3>  Verwenden des Nav Mesh Agent </h3><br>  Nachdem wir die Szene mit NavMesh eingerichtet haben, muss der Agent diese Informationen verwenden können.  Zum Glück hat Unity eine <b>Nav Mesh Agent-</b> Komponente, die Sie auf einen Charakter ziehen können.  In unserer Beispielszene gibt es ein Spielobjekt namens <b>Tank</b> , an das bereits eine Komponente angehängt ist.  Schauen Sie sich die Hierarchie an und Sie werden ungefähr Folgendes sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Hier gibt es einige Parameter, und wir werden nicht alles berücksichtigen, da sie ziemlich klar sind und die Beschreibung in der offiziellen Unity-Dokumentation zu finden ist.  Aber wir werden die wichtigsten Dinge erwähnen: <br><br><ul><li>  <strong>Agententyp</strong> : Erinnern Sie sich an die Registerkarte <strong>Agenten</strong> im <strong>Navigationsfenster</strong> ?  Hier können zuweisbare Agententypen ausgewählt werden. </li><li>  <strong>Auto-Traverse-Off-Mesh-Link</strong> : Mit dieser Option können Agenten automatisch die <strong>Off-Mesh-Link-</strong> Funktion verwenden, die im Folgenden <strong>erläutert</strong> wird. </li><li>  <strong>Bereichsmaske</strong> : Hier können Sie die Bereiche auswählen, die auf der Registerkarte <strong>Bereiche</strong> des <strong>Navigationsfensters</strong> konfiguriert wurden. </li></ul><br>  Das ist alles.  Diese Komponente erledigt 90% der harten Arbeit für uns: Wegbereiter, Vermeidung von Hindernissen und so weiter.  Sie müssen lediglich den Zielpunkt an den Agenten übertragen.  Schauen wir uns dieses Problem an. <br><br><h3>  Zielpunkteinstellung </h3><br>  Nachdem wir den KI-Agenten eingerichtet haben, müssen wir ihm sagen, wohin er gehen soll.  In unserem Beispielprojekt gibt es ein Skript namens <b>Target.cs</b> , das genau diese Aufgabe ausführt. <br><br>  Dies ist eine einfache Klasse, die drei Dinge tut: <br><br><ul><li>  "Schießt" den Strahl von der Kamera zur Mausposition in der Welt </li><li>  Aktualisiert die Markerposition </li><li>  Aktualisiert die Zieleigenschaft für alle NavMesh-Agenten. </li></ul><br>  Der Code ist recht einfach.  Die ganze Klasse ist wie folgt: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Die folgenden Aktionen werden hier ausgeführt: In der <b>Start-</b> Methode initialisieren wir das <b>navAgents-</b> Array mit der <b>FindObjectsOfType ()</b> -Methode. <br><br>  Die <b>UpdateTargets ()</b> -Methode durchläuft unser <b>navAgents-</b> Array und legt den Zielpunkt für sie im angegebenen <b>Vector3 fest</b> .  Dies ist der Schlüssel zum Code.  Sie können einen beliebigen Mechanismus verwenden, um den Zielpunkt <b>abzurufen. Damit sich</b> der Agent dorthin bewegen kann, legen Sie <b>einfach das</b> Feld <b>NavMeshAgent.destination fest</b> .  Der Agent erledigt den Rest. <br><br>  In unserem Beispiel werden Klicks zum Bewegen verwendet. Wenn also ein Spieler auf die Maus klickt, geben wir den Strahl von der Kamera in Richtung des Mauszeigers in die Welt frei. Wenn er sich mit etwas schneidet, weisen wir dem neuen <b>targetPosition-</b> Agenten einen Kollisionspunkt zu.  Wir passen auch die Zielmarkierung entsprechend an, um das Ziel im Spiel einfach zu visualisieren. <br><br>  Um den Vorgang zu testen, müssen Sie NavMesh gemäß der Beschreibung im vorherigen Abschnitt backen, dann den Wiedergabemodus starten und einen beliebigen Bereich auf der Karte auswählen.  Wenn Sie mehrmals klicken, können Sie feststellen, dass der Agent einige Bereiche nicht erreichen kann - die oberen Bereiche der roten Würfel, die obere Plattform und die Plattform am unteren Bildschirmrand. <br><br>  Rote Würfel sind zu hoch.  Der Hang, der zur höchsten Plattform führt, ist für unsere <b>Max Slope-</b> Einstellungen zu scharf, und der Agent kann ihn nicht erklimmen.  Die folgenden Screenshots zeigen, wie sich die Einstellungen für die maximale Neigung auf NavMesh auswirken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh mit maximaler Steigung = 45</i> <br><br>  Wenn Sie den Wert für die maximale <b>Steigung</b> in etwa <b>51</b> ändern und dann erneut auf die Schaltfläche Backen klicken, um NavMesh erneut zu backen, lauten die Ergebnisse wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh mit maximaler Steigung = 51</em> <br><br>  Wie Sie sehen, können wir das Level-Design anpassen und so ganze Bereiche unzugänglich machen, indem wir einen einzelnen Parameter ändern.  Dies kann beispielsweise nützlich sein, wenn Sie eine Plattform oder einen Sims haben, für deren Klettern ein Seil, eine Leiter oder ein Aufzug erforderlich ist.  Oder vielleicht eine besondere Fähigkeit, zum Beispiel die Fähigkeit zu klettern? <br><br><h3>  Anwendung Off Mesh Links </h3><br>  Sie werden vielleicht feststellen, dass es in unserer Szene zwei Pausen gibt.  Unser Agent kann in den ersten gelangen, aber der am unteren Bildschirmrand ist zu weit entfernt.  Diese Berechnungen sind nicht völlig willkürlich.  <strong>Off-Mesh-Links bilden im</strong> Wesentlichen eine Brücke zwischen den Zwischenräumen zwischen nicht verwandten NavMesh-Segmenten.  Diese Links sind im Editor zu sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Blaue Kreise mit Verbindungslinien sind Verbindungen.</i> <br><br>  Unity kann diese Links auf zwei Arten erzeugen.  Das erste haben wir schon überlegt.  Erinnern Sie sich an den <b>Sprungdistanzwert</b> auf der Registerkarte Backen des <b>Navigationsfensters</b> ?  Unity verwendet diesen Wert automatisch, um diese Links beim Backen von NavMesh zu generieren.  Versuchen Sie, den Wert in unserer Testszene auf 5 zu ändern und erneut zu backen.  Sehen Sie - die Plattformen sind jetzt verbunden?  Dies liegt daran, dass die Netze jetzt innerhalb des neu angegebenen Schwellenwerts liegen. <br><br>  Ändern Sie den Wert erneut auf 2 und backen Sie.  Schauen wir uns nun den zweiten Weg an.  Erstellen Sie die Kugeln, mit denen die beiden Plattformen verbunden werden.  Platzieren Sie sie ungefähr wie im Screenshot gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Sie können bereits sehen, was passiert, aber lassen Sie uns den Prozess analysieren, der es ihnen ermöglicht, eine Verbindung herzustellen.  In unserem Fall habe ich die Kugel am rechten <b>Anfang</b> und die Kugel am linken <b>Ende genannt</b> .  Sie werden bald verstehen warum.  Als Nächstes habe ich der Plattform auf der rechten Seite die <b>Off Mesh Link-</b> Komponente hinzugefügt (relativ zum vorherigen Screenshot).  Sie werden feststellen, dass die Komponente <b>Start-</b> und Endfelder hat.  Wie Sie vielleicht erraten haben, ziehen wir die zuvor erstellten Kugeln in die entsprechenden Slots - die Startkugel im <b>Startfeld</b> und die Endkugel im Endfeld.  Der Inspektor sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  Der Wert von <b>Cost Override wird</b> berücksichtigt, wenn er einen positiven Wert erhält.  Bei Verwendung dieser Beziehung wird ein Kostenfaktor angewendet, im Gegensatz zu einem kostengünstigeren Weg zum Ziel. <br><br>  <b>Bi Directional,</b> wenn true, ermöglicht es dem Agenten, sich in beide Richtungen zu bewegen.  Um Links mit Einwegverkehr zu erstellen, können Sie diesen Wert deaktivieren.  Der Wert <b>Aktiviert wird</b> entsprechend seinem Namen verwendet.  Bei false ignoriert der Agent diese Zuordnung.  Sie können es ein- und ausschalten, um Spielszenarien zu erstellen, in denen ein Spieler beispielsweise einen Schalter drücken muss, um eine Verbindung zu aktivieren. <br><br>  Um diese Beziehung zu ermöglichen, ist kein erneutes Backen erforderlich.  Schauen Sie sich Ihr NavMesh an und Sie werden sehen, dass es genau so aussieht wie im Screenshot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Wie Sie sehen können, wird die kleinere Lücke immer noch automatisch verbunden, und jetzt haben wir eine neue Verbindung, die von der <b>Off Mesh Link-</b> Komponente zwischen den beiden Kugeln generiert wird.  Starten Sie den Wiedergabemodus und klicken Sie auf die entfernte Plattform.  Wie erwartet kann der Agent jetzt zur nicht verbundenen Plattform navigieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Auf den Ebenen Ihres Spiels müssen Sie möglicherweise diese Parameter ändern, um die gewünschten Ergebnisse zu erzielen. Eine Kombination dieser Funktionen bietet Ihnen jedoch ein praktisches, vorgefertigtes Werkzeug.  Mit der NavMesh-Funktion können Sie schnell ein einfaches Spiel erstellen. <br><br>  <em>Dieses Tutorial ist Teil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Unity 2017 Game AI Programming - Dritte Ausgabe</a> von Ray Barrera, Aung Sithu Kyaw und Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414453/">https://habr.com/ru/post/de414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414443/index.html">Funktionen von Funktionsaufrufen in C ++</a></li>
<li><a href="../de414445/index.html">Verbesserung von Zimbra mit der Zextras Suite</a></li>
<li><a href="../de414447/index.html">Sorten aller Zeiten</a></li>
<li><a href="../de414449/index.html">Wie man sich mit allen Betreibern im Stadion anfreundet und es nicht mit Hunderten von Antennen sät</a></li>
<li><a href="../de414451/index.html">"Testerkalender" für Juni. Der Tester muss den Fehler erkennen, Caner lesen und den Umzug organisieren.</a></li>
<li><a href="../de414455/index.html">Algorithmus zur Erzeugung von Farbpaletten</a></li>
<li><a href="../de414459/index.html">Detektoren und Deskriptoren von singulären Punkten FAST, BRIEF, ORB</a></li>
<li><a href="../de414463/index.html">AI selbst hat gelernt, wie man einen Zauberwürfel baut</a></li>
<li><a href="../de414465/index.html">Meta Crush Saga: Spiel zur Kompilierungszeit</a></li>
<li><a href="../de414467/index.html">Beiträge von der Minsk C ++ Konferenz CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>