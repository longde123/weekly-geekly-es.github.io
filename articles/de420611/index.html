<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëá üë®üèæ‚Äçüåæ üë®üèª‚Äçüé® Modellierung der Quantenverschr√§nkung in C # üìî üé† üëç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Da das Thema der Quantenverschr√§nkung immer h√§ufiger auftaucht, wollte ich etwas tiefer gehen. Nach den Kommentaren zu Artikeln √ºber Quantenverschr√§nk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modellierung der Quantenverschr√§nkung in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  Da das Thema der Quantenverschr√§nkung immer h√§ufiger auftaucht, wollte ich etwas tiefer gehen.  Nach den Kommentaren zu Artikeln √ºber Quantenverschr√§nkung zu urteilen, werden diese Informationen f√ºr mich allein nicht n√ºtzlich sein.  Nun, unter Ber√ºcksichtigung der Tatsache, dass Programmcode f√ºr die meisten von uns viel praktischer ist als alle Allegorien, wurde beschlossen, mein Verst√§ndnis in Form von Code darzustellen. <br><a name="habracut"></a><br>  Dieser Artikel erweitert den Artikel eines anderen Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Quantum Entanglement for Dummies"</a> (ich empfehle ihn zu lesen, er hat mir sehr geholfen).  In seinem Artikel gab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">indomit</a> ein Beispiel f√ºr ein Programm, das das Problem der Theorie der verborgenen Parameter klar demonstriert, aber kein Beispiel f√ºr einen Code f√ºr Teilchen in √úberlagerung geben konnte.  In diesem Artikel werden wir versuchen, zwei F√§lle zu simulieren: <br><br><ol><li>  Wie sich verschr√§nkte Teilchen im Determinismus verhalten w√ºrden, wenn der Zustand der Teilchen vor der Messung festgestellt wird, k√∂nnen wir ihn einfach nicht messen, ohne Verzerrungen einzuf√ºhren (die Theorie der verborgenen Parameter).  Wir bekommen die Zahlen und sehen die Diskrepanz mit der Praxis. </li><li>  Wir werden ein Modell von verschr√§nkten Partikeln in √úberlagerung schreiben (der Zustand der Partikel wird vor der Messung nicht definiert).  Nehmen wir an, wie das Partikel im Inneren programmiert ist, dh wir passen seinen Code an die experimentell erhaltenen Daten an. </li></ol><br>  Der Artikel basiert auf der popul√§ren Erkl√§rung des Ph√§nomens der Quantenverschr√§nkung von Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Minins Paradoxon erkl√§rt</b> <div class="spoiler_text">  F√ºr den popul√§ren Bericht des Paradoxons schl√§gt D. Mermin vor, ein einfaches Ger√§t zu konstruieren [23].  Das Ger√§t sollte aus einem Partikelemitter und zwei Detektoren bestehen.  Zu jedem von ihnen werden zwei identische Partikel emittiert.  Nachdem der Detektor ein Partikel gefangen hat, gibt er eine bin√§re Antwort (0 oder 1), abh√§ngig vom Partikel und seinem dreistelligen Abstimmschalter.  Das Erkennen eines Partikelpaares sollte die gleichen Antworten geben: <br><br><ol><li>  Immer wenn Detektoren auf die gleiche Weise konfiguriert werden. </li><li>  Laut Statistik in der H√§lfte der F√§lle, wenn sie zuf√§llig konfiguriert werden. </li></ol><br>  Die erste Eigenschaft erfordert, dass alle Detektoren dieselbe Codierung verwenden. Die Schalterposition ist ‚àà {1,2,3} ‚Ü¶ Antwort ‚àà {0,1} ohne zuf√§lliges Element.  Das hei√üt, sie m√ºssen im Voraus vereinbaren, welche der Antworten 0 oder 1 auf die Schalterposition geben, und f√ºr jedes Partikel eine von acht m√∂glichen Funktionen 000, 001, 010, 011, 100, 101, 110 und 111 ausw√§hlen. Die Auswahl von 000 oder 111 f√ºhrt zu zu 100% √úbereinstimmung der Messwerte der Detektoren, unabh√§ngig von der Position des Steuerknopfs.  Wenn die Detektoren eine der sechs verbleibenden Funktionen implementieren, wird in 2/3 der F√§lle eine der Ziffern durch einen zuf√§llig abgestimmten Schalter gezogen, die andere mit einer Wahrscheinlichkeit von 1/3.  Die Wahrscheinlichkeit des Zusammentreffens der beiden Antworten betr√§gt (‚Öî) ¬≤ + (‚Öì) ¬≤ = 5/9.  Unabh√§ngig davon, um welchen Automatenalgorithmus es sich handelt, √ºberschreitet die Korrelation zwangsl√§ufig 50%, was die zweite Anforderung verletzt. <br><br>  <i>Da eine solche Maschine jedoch noch gebaut werden kann (z. B. durch Positionieren der Polarisatoren bei 120 ¬∞ wie in B√∂hms Experiment), kann es auch in versteckter Form keinen Determinismus (Parameter) geben.</i>  <i>Stattdessen werden Antwortkorrelationen aufrechterhalten, indem Informationen schneller als bei der zweiten Messung von einem ‚Äûgemessenen‚Äú Partikel zu einem anderen √ºbertragen werden.</i> <br><br>  Von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier genommen</a> . <br></div></div><br>  Leider mache ich weder beruflich noch auf Amateurebene Physik, ich gebe nicht vor, fehlerfrei zu sein.  Das Hauptziel des Artikels ist es zu demonstrieren, wie ein Modell f√ºr diejenigen verst√§ndlich gemacht werden kann, die mit Programmierung vertraut sind.  Wenn jemand professionell in diesem Bereich arbeitet, versuchen Sie, anstatt Vorw√ºrfe zu machen, genauere Interaktionsmodelle zu schreiben, die auf meinem Artikel basieren. <br><br><h2>  [Update] Erl√§uterung der Beschreibung von Mermin </h2><br>  Obwohl seit dem Schreiben des Artikels mehrere Monate vergangen sind und niemand darauf zur√ºckkommen wird, habe ich beschlossen, eine Klarstellung vorzunehmen, um mein Gewissen zu beruhigen. <br><br>  Ich ging etwas tiefer und kam zu dem Schluss, dass die Beschreibung nach Mermin stark vereinfacht ist und Versuche, sie mit realen physikalischen Experimenten zu verkn√ºpfen, <i>bedeutungslos sind</i> . <br><br>  Anfangs habe ich versucht, den Artikel mit einem echten Experiment mit zirkularer Polarisation zu verkn√ºpfen, und dabei habe ich einen Fehler gemacht.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ARad</a> versuchte, eine Bindung zu realen physikalischen Experimenten zu entwickeln, schrieb √ºber die gemachten Fehler und schlug sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine eigene Version des Codes vor</a> (die auch keinem physikalischen Experiment entspricht). <br><br>  Damit der Artikel zumindest einen Sinn ergibt, wurde beschlossen, alle imagin√§ren Verkn√ºpfungen zu realen physikalischen Experimenten zu entfernen und einfach <i>die Beschreibung von Mermin im Code zu erl√§utern</i> und visueller zu gestalten.  Echte Experimente sind komplizierter und um sie zu simulieren, m√ºssen Sie viel mehr Zeit aufwenden. <br><br>  In der ersten Version des Artikels haben wir akzeptiert, dass im ersten Experiment (die Position der Sensoren stimmt √ºberein) die Partikel ein Spiegelergebnis ergeben, aber in der urspr√ºnglichen Beschreibung nach Mermin stimmt das Messergebnis mit der gleichen Position der Sensoren immer √ºberein.  Dies ist <i>behoben</i> . <br><br>  Zus√§tzlich werde ich eine "Erkl√§rung f√ºr eine Erkl√§rung" dieses Mermin selbst hinzuf√ºgen, da es nicht eindeutig geschrieben ist: <br><br><blockquote>  Das hei√üt, sie m√ºssen im Voraus vereinbaren, welche der Antworten 0 oder 1 der Schalterposition geben, und f√ºr jedes Teilchen eine von acht m√∂glichen Funktionen 000, 001, 010, 011, 100, 101, 110 und 111 ausw√§hlen. <br></blockquote><br>  Der Ausdruck "acht m√∂gliche Funktionen" ist nicht eindeutig.  Acht m√∂gliche Varianten des <i>m√∂glichen</i> Einflusses von Partikeln auf den Sensor werden diskutiert.  Der Sensor hat drei Positionen (siehe die vollst√§ndige Beschreibung oben).  Wenn wir glauben, dass der Zustand zweier Partikel √ºbereinstimmt und im Voraus festgelegt wird, k√∂nnen wir im Voraus bestimmen, welche Antwort (0 oder 1) wir m√∂glicherweise f√ºr jede der drei Positionen des Schalters erhalten (obwohl wir nur eine von drei Optionen ‚Äûmessen‚Äú k√∂nnen). <br><br><blockquote>  Wenn Sie 000 oder 111 ausw√§hlen, stimmen die Detektorwerte unabh√§ngig von der Position des Abstimmknopfs zu 100% √ºberein. </blockquote><br>  Wenn Partikel einen Wert annehmen k√∂nnen, bei dem wir m√∂glicherweise eine Antwort von ‚Äû1‚Äú f√ºr jede Schalterposition (sowie 0 f√ºr jede Schalterposition) erhalten k√∂nnen, ergibt das zweite Experiment in diesen F√§llen eine 100% ige √úbereinstimmung.  Um sich 50% zu n√§hern, k√∂nnen diese Optionen ausgeschlossen werden. <br><br><blockquote>  Wenn die Detektoren eine der sechs verbleibenden Funktionen implementieren, wird in 2/3 der F√§lle eine der Ziffern durch einen zuf√§llig abgestimmten Schalter gezogen, die andere mit einer Wahrscheinlichkeit von 1/3. </blockquote><br>  Dies bedeutet, dass in jedem der 6 Tripel (001, 010, 011, 100, 101, 110) nur zwei der drei Ziffern √ºbereinstimmen (in der ersten Version sind zwei der drei "0" und eine der drei "1"). ) <br><br>  Um die Wahrscheinlichkeit einzusch√§tzen, erstellen wir eine Tabelle f√ºr den ersten Fall <b>001</b> : <br><br><table><tbody><tr><th>  Sensorposition 1 </th><th>  Sensorposition 2 </th><th>  Stimmen die Ma√üe √ºberein? </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  Es ist ersichtlich, dass in f√ºnf F√§llen von neun Messungen zusammenfallen.  Die gleiche Wahrscheinlichkeit gilt f√ºr jede dieser sechs Optionen (schlie√ülich sind in jeder von ihnen die beiden Zahlen gleich). <br><br><h2>  Messungen </h2><br>  In jedem der Modelle (sowohl deterministisch als auch √ºberlagert) werden wir zwei Experimente mit verschr√§nkten Partikeln durchf√ºhren, die den ersten und zweiten Bedingungen gem√§√ü Mermin entsprechen: <br><br><ol><li>  Stellen Sie zun√§chst beide Sensoren auf die gleiche Position.  In diesem Fall erhalten wir 100% identische Ergebnisse (wenn das erste Photon den Polarisator passiert, passiert das zugeh√∂rige Photon auch den Polarisator im gleichen Winkel). </li><li>  Dann werden wir die Position der Sensoren zuf√§llig einstellen. </li></ol><br>  Hier ist der Code f√ºr das erste Experiment: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Hier ist der Code f√ºr das zweite Experiment: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Die gleichen Tests werden f√ºr alle Partikelmodelle durchgef√ºhrt, nur der Partikelcode ist f√ºr das deterministische Modell und das √úberlagerungsmodell unterschiedlich (mehr dazu weiter unten). <br><br><h2>  Deterministisches Modell </h2><br>  Achtung!  Siehe UPDATE am Ende des Artikels! <br><br>  F√ºr diejenigen, die den Code sofort ausf√ºhren m√∂chten, kann dies √ºber den Browser erfolgen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Nach Minins Erkl√§rung haben wir also ein Quantenteilchen mit drei Parametern: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Da das Modell deterministisch ist, werden alle Parameter des Partikels zum Zeitpunkt seiner Erstellung, dh direkt im Konstruktor, initialisiert.  Die einzige Bedingung ist, dass die Messung nur einmal erlaubt ist! <br><br>  Weiter.  Ein Paar verwickelter Partikel: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  Es ist ersichtlich, dass die Werte jedes der Partikel zum Zeitpunkt der Erzeugung eines Paares verschr√§nkter Partikel eingestellt werden und die Parameter des zweiten Partikels den Parametern des ersten Partikels entsprechen (ohne dies k√∂nnen wir den ersten Test nicht bestehen).  Wir verwenden Zufallszahlen, aber je nach Modell h√§ngen die Parameter von den Faktoren zum Zeitpunkt des Verwickelns ab (aufgrund des Roulettes h√§ngt dies von einer Reihe von Faktoren zum Zeitpunkt des Aufdrehens ab). <br><br>  Vollst√§ndiger Beispielcode: <br><br><div class="spoiler">  <b class="spoiler_title">C # -Code des deterministischen Modells (fest)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Sie k√∂nnen es √ºber den Browser starten (noch einmal den Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Nach dem Start sind dies die Ergebnisse: <br><br><blockquote>  Versuch Nr. 1: 100% der Werte stimmten √ºberein <br>  Versuch Nr. 2: 55.6700% der Werte stimmten √ºberein <br></blockquote><br>  Der erste bestandene Test entspricht dem, was in der Realit√§t passiert.  Aber die zweite - passt nicht zusammen, da sie 50% bekommen sollten! <br><br>  Infolgedessen mussten die Physiker zu dem Schluss kommen, dass die Theorie der verborgenen Parameter falsch ist.  Und damit wird das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Lokalit√§t</a> widerlegt und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Kausalit√§t</a> sogar ersch√ºttert. <br><br><h2>  √úberlagerungsmodell </h2><br>  Sofort ein Link zu einem Beispielcode f√ºr diejenigen, die Besonderheiten lieben (kann in einem Browser gestartet werden): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Um die w√§hrend der Experimente erhaltenen Ergebnisse zu erkl√§ren, mussten komplexere Modelle verwendet werden.  In modernen Modellen wird der Zustand der Partikelparameter vor der Messung nicht definiert, und verschr√§nkte Partikel selbst k√∂nnen sich sofort (√ºber die Lichtgeschwindigkeit hinaus) gegenseitig beeinflussen.  So sieht unser Partikelmodell jetzt aus: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Erstens sind die Parameter nullbar (sie spielen m√∂glicherweise keine Rolle) und wir setzen sie nicht im Konstruktor.  Zweitens die CreateSuperluminalChannelWith-Methode zum Einstellen des Superlichtkanals zwischen Partikeln, d.h.  Jetzt kann ein Teilchen unabh√§ngig von der Entfernung sofort den Zustand eines anderen Teilchens erhalten.  Nun, und vor allem, jetzt wird der Zustand eines Partikels <i>erst zum Zeitpunkt der Messung</i> (Aufruf der GetValue-Methode) festgestellt und h√§ngt davon ab, ob ein anderes Partikel, das damit zusammenh√§ngt, gemessen wurde. <br><br>  Das Innere der GetValue-Methode ist reine Spekulation.  Niemand wei√ü, wie das Partikel im Inneren angeordnet ist, aber wir wissen, dass es einfach so funktioniert: 100% Fehlanpassungen bei Messung desselben Parameters und 50% Fehlanpassungen bei Messung von Parametern in zuf√§lliger Reihenfolge. <br><br>  In meiner Version des Codes pr√ºft ein Partikel durch einen √ºberluminalen Kanal, ob die Messung damit verwechselt wird, und verh√§lt sich wie folgt: <br><br><ol><li>  Wenn der gemessene Parameter eines anderen Partikels derselbe ist, den wir messen m√∂chten, ergibt sich der gleiche Wert. </li><li>  Wenn der Parameter unterschiedlich ist, gibt er in 1/4 der F√§lle den gleichen Wert und in 3/4 der F√§lle den entgegengesetzten Wert (da wir 50/50 erhalten). </li></ol><br>  Wenn die Messung nicht durchgef√ºhrt wurde, verwendet das Partikel eine echte Zuf√§lligkeit, um seinen Wert festzulegen, dh ein Kausalzusammenhang wird verletzt (der Wert war vor der Messung nicht vorhanden und die Messung selbst hat seinen Wert nicht bestimmt). <br><br>  <i>√úbrigens!</i>  <i>Sie k√∂nnen diese Funktion auf andere Weise umschreiben, damit die Testergebnisse identisch sind.</i>  <i>Trotzdem wei√ü niemand, wie das Elementarteilchen angeordnet ist und wie 50% f√ºr den zweiten Test erreicht werden.</i> <i><br></i> <br>  Ein Paar verschr√§nkter Partikel ist einfacher geworden, da zum Zeitpunkt der Verschr√§nkung keine Werte festgelegt sind (Werte wurden noch nicht bestimmt): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Vollst√§ndiger Beispielcode: <br><br><div class="spoiler">  <b class="spoiler_title">√úberlagerungsmodell in C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Ergebnisse: <br><br><blockquote>  Versuch Nr. 1: 100% der Werte stimmten √ºberein <br>  Versuch Nr. 2: 49,77700% der Werte stimmten √ºberein <br></blockquote><br>  F√ºhren Sie im Browser aus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Schlussfolgerungen </h2><br>  Ich h√§tte gerne mehr Interpretationen, wie die von Mermin.  Basierend auf dieser Interpretation habe ich es geschafft, visuelle Modelle bestehender Theorien zu erstellen und sogar ein alternatives Modell vorzuschlagen, und diese Modelle sind nicht allegorisch - Sie k√∂nnen sie ausf√ºhren und sehen, wie sie funktionieren. <br><br>  Leider habe ich nicht die Zeitressourcen f√ºr ein tieferes Wissen √ºber die Quantenphysik und ich hoffe, dass diejenigen, die es wissen, meinem Beispiel folgen und genauere Arbeitsmodelle geben k√∂nnen. <br><br>  <b>UPDATE</b> <br>  Minins Erkl√§rung bezieht sich nicht auf das Design von Detektoren.  Aus eigener Initiative f√ºgte ich A, B und C eine Erkl√§rung als Projektion des Spins auf die X-, Y- und Z-Achse hinzu.  Das hei√üt, ich wollte in den Kommentaren zum Code eine Bindung zu physikalischen Ph√§nomenen hinzuf√ºgen, damit er nicht so trocken wird.  Und ich habe mich geirrt ... <br><br>  Der Artikel wird korrigiert und alle vergeblichen Versuche, Minins Erkl√§rung mit realen physikalischen Experimenten zu verkn√ºpfen, werden gel√∂scht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420611/">https://habr.com/ru/post/de420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420599/index.html">Dreizehn Dinge, die Lem vorausgesehen hat</a></li>
<li><a href="../de420603/index.html">Statistiken des Besitzers von Tesla Model S.</a></li>
<li><a href="../de420605/index.html">√úberblick √ºber den Algorithmus f√ºr Vorstellungsgespr√§che - Set-Generierung</a></li>
<li><a href="../de420607/index.html">Digitale Veranstaltungen in Moskau vom 20. bis 26. August</a></li>
<li><a href="../de420609/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 327 (13. - 19. August 2018)</a></li>
<li><a href="../de420613/index.html">11 Bibliotheken (Komponentens√§tze) f√ºr React Native, √ºber die Sie 2018 Bescheid wissen sollten</a></li>
<li><a href="../de420615/index.html">JavaScript: Objekte erkunden</a></li>
<li><a href="../de420617/index.html">Webdesign-Handbuch f√ºr Entwickler</a></li>
<li><a href="../de420619/index.html">Responsive Images: CSS-Tricks, die Zeit sparen</a></li>
<li><a href="../de420623/index.html">Verteilte C ++ - Anwendungen mit minimalem Aufwand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>