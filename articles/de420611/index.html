<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 👨🏾‍🌾 👨🏻‍🎨 Modellierung der Quantenverschränkung in C # 📔 🎠 👍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Da das Thema der Quantenverschränkung immer häufiger auftaucht, wollte ich etwas tiefer gehen. Nach den Kommentaren zu Artikeln über Quantenverschränk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modellierung der Quantenverschränkung in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  Da das Thema der Quantenverschränkung immer häufiger auftaucht, wollte ich etwas tiefer gehen.  Nach den Kommentaren zu Artikeln über Quantenverschränkung zu urteilen, werden diese Informationen für mich allein nicht nützlich sein.  Nun, unter Berücksichtigung der Tatsache, dass Programmcode für die meisten von uns viel praktischer ist als alle Allegorien, wurde beschlossen, mein Verständnis in Form von Code darzustellen. <br><a name="habracut"></a><br>  Dieser Artikel erweitert den Artikel eines anderen Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Quantum Entanglement for Dummies"</a> (ich empfehle ihn zu lesen, er hat mir sehr geholfen).  In seinem Artikel gab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">indomit</a> ein Beispiel für ein Programm, das das Problem der Theorie der verborgenen Parameter klar demonstriert, aber kein Beispiel für einen Code für Teilchen in Überlagerung geben konnte.  In diesem Artikel werden wir versuchen, zwei Fälle zu simulieren: <br><br><ol><li>  Wie sich verschränkte Teilchen im Determinismus verhalten würden, wenn der Zustand der Teilchen vor der Messung festgestellt wird, können wir ihn einfach nicht messen, ohne Verzerrungen einzuführen (die Theorie der verborgenen Parameter).  Wir bekommen die Zahlen und sehen die Diskrepanz mit der Praxis. </li><li>  Wir werden ein Modell von verschränkten Partikeln in Überlagerung schreiben (der Zustand der Partikel wird vor der Messung nicht definiert).  Nehmen wir an, wie das Partikel im Inneren programmiert ist, dh wir passen seinen Code an die experimentell erhaltenen Daten an. </li></ol><br>  Der Artikel basiert auf der populären Erklärung des Phänomens der Quantenverschränkung von Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Minins Paradoxon erklärt</b> <div class="spoiler_text">  Für den populären Bericht des Paradoxons schlägt D. Mermin vor, ein einfaches Gerät zu konstruieren [23].  Das Gerät sollte aus einem Partikelemitter und zwei Detektoren bestehen.  Zu jedem von ihnen werden zwei identische Partikel emittiert.  Nachdem der Detektor ein Partikel gefangen hat, gibt er eine binäre Antwort (0 oder 1), abhängig vom Partikel und seinem dreistelligen Abstimmschalter.  Das Erkennen eines Partikelpaares sollte die gleichen Antworten geben: <br><br><ol><li>  Immer wenn Detektoren auf die gleiche Weise konfiguriert werden. </li><li>  Laut Statistik in der Hälfte der Fälle, wenn sie zufällig konfiguriert werden. </li></ol><br>  Die erste Eigenschaft erfordert, dass alle Detektoren dieselbe Codierung verwenden. Die Schalterposition ist ∈ {1,2,3} ↦ Antwort ∈ {0,1} ohne zufälliges Element.  Das heißt, sie müssen im Voraus vereinbaren, welche der Antworten 0 oder 1 auf die Schalterposition geben, und für jedes Partikel eine von acht möglichen Funktionen 000, 001, 010, 011, 100, 101, 110 und 111 auswählen. Die Auswahl von 000 oder 111 führt zu zu 100% Übereinstimmung der Messwerte der Detektoren, unabhängig von der Position des Steuerknopfs.  Wenn die Detektoren eine der sechs verbleibenden Funktionen implementieren, wird in 2/3 der Fälle eine der Ziffern durch einen zufällig abgestimmten Schalter gezogen, die andere mit einer Wahrscheinlichkeit von 1/3.  Die Wahrscheinlichkeit des Zusammentreffens der beiden Antworten beträgt (⅔) ² + (⅓) ² = 5/9.  Unabhängig davon, um welchen Automatenalgorithmus es sich handelt, überschreitet die Korrelation zwangsläufig 50%, was die zweite Anforderung verletzt. <br><br>  <i>Da eine solche Maschine jedoch noch gebaut werden kann (z. B. durch Positionieren der Polarisatoren bei 120 ° wie in Böhms Experiment), kann es auch in versteckter Form keinen Determinismus (Parameter) geben.</i>  <i>Stattdessen werden Antwortkorrelationen aufrechterhalten, indem Informationen schneller als bei der zweiten Messung von einem „gemessenen“ Partikel zu einem anderen übertragen werden.</i> <br><br>  Von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier genommen</a> . <br></div></div><br>  Leider mache ich weder beruflich noch auf Amateurebene Physik, ich gebe nicht vor, fehlerfrei zu sein.  Das Hauptziel des Artikels ist es zu demonstrieren, wie ein Modell für diejenigen verständlich gemacht werden kann, die mit Programmierung vertraut sind.  Wenn jemand professionell in diesem Bereich arbeitet, versuchen Sie, anstatt Vorwürfe zu machen, genauere Interaktionsmodelle zu schreiben, die auf meinem Artikel basieren. <br><br><h2>  [Update] Erläuterung der Beschreibung von Mermin </h2><br>  Obwohl seit dem Schreiben des Artikels mehrere Monate vergangen sind und niemand darauf zurückkommen wird, habe ich beschlossen, eine Klarstellung vorzunehmen, um mein Gewissen zu beruhigen. <br><br>  Ich ging etwas tiefer und kam zu dem Schluss, dass die Beschreibung nach Mermin stark vereinfacht ist und Versuche, sie mit realen physikalischen Experimenten zu verknüpfen, <i>bedeutungslos sind</i> . <br><br>  Anfangs habe ich versucht, den Artikel mit einem echten Experiment mit zirkularer Polarisation zu verknüpfen, und dabei habe ich einen Fehler gemacht.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ARad</a> versuchte, eine Bindung zu realen physikalischen Experimenten zu entwickeln, schrieb über die gemachten Fehler und schlug sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine eigene Version des Codes vor</a> (die auch keinem physikalischen Experiment entspricht). <br><br>  Damit der Artikel zumindest einen Sinn ergibt, wurde beschlossen, alle imaginären Verknüpfungen zu realen physikalischen Experimenten zu entfernen und einfach <i>die Beschreibung von Mermin im Code zu erläutern</i> und visueller zu gestalten.  Echte Experimente sind komplizierter und um sie zu simulieren, müssen Sie viel mehr Zeit aufwenden. <br><br>  In der ersten Version des Artikels haben wir akzeptiert, dass im ersten Experiment (die Position der Sensoren stimmt überein) die Partikel ein Spiegelergebnis ergeben, aber in der ursprünglichen Beschreibung nach Mermin stimmt das Messergebnis mit der gleichen Position der Sensoren immer überein.  Dies ist <i>behoben</i> . <br><br>  Zusätzlich werde ich eine "Erklärung für eine Erklärung" dieses Mermin selbst hinzufügen, da es nicht eindeutig geschrieben ist: <br><br><blockquote>  Das heißt, sie müssen im Voraus vereinbaren, welche der Antworten 0 oder 1 der Schalterposition geben, und für jedes Teilchen eine von acht möglichen Funktionen 000, 001, 010, 011, 100, 101, 110 und 111 auswählen. <br></blockquote><br>  Der Ausdruck "acht mögliche Funktionen" ist nicht eindeutig.  Acht mögliche Varianten des <i>möglichen</i> Einflusses von Partikeln auf den Sensor werden diskutiert.  Der Sensor hat drei Positionen (siehe die vollständige Beschreibung oben).  Wenn wir glauben, dass der Zustand zweier Partikel übereinstimmt und im Voraus festgelegt wird, können wir im Voraus bestimmen, welche Antwort (0 oder 1) wir möglicherweise für jede der drei Positionen des Schalters erhalten (obwohl wir nur eine von drei Optionen „messen“ können). <br><br><blockquote>  Wenn Sie 000 oder 111 auswählen, stimmen die Detektorwerte unabhängig von der Position des Abstimmknopfs zu 100% überein. </blockquote><br>  Wenn Partikel einen Wert annehmen können, bei dem wir möglicherweise eine Antwort von „1“ für jede Schalterposition (sowie 0 für jede Schalterposition) erhalten können, ergibt das zweite Experiment in diesen Fällen eine 100% ige Übereinstimmung.  Um sich 50% zu nähern, können diese Optionen ausgeschlossen werden. <br><br><blockquote>  Wenn die Detektoren eine der sechs verbleibenden Funktionen implementieren, wird in 2/3 der Fälle eine der Ziffern durch einen zufällig abgestimmten Schalter gezogen, die andere mit einer Wahrscheinlichkeit von 1/3. </blockquote><br>  Dies bedeutet, dass in jedem der 6 Tripel (001, 010, 011, 100, 101, 110) nur zwei der drei Ziffern übereinstimmen (in der ersten Version sind zwei der drei "0" und eine der drei "1"). ) <br><br>  Um die Wahrscheinlichkeit einzuschätzen, erstellen wir eine Tabelle für den ersten Fall <b>001</b> : <br><br><table><tbody><tr><th>  Sensorposition 1 </th><th>  Sensorposition 2 </th><th>  Stimmen die Maße überein? </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  Es ist ersichtlich, dass in fünf Fällen von neun Messungen zusammenfallen.  Die gleiche Wahrscheinlichkeit gilt für jede dieser sechs Optionen (schließlich sind in jeder von ihnen die beiden Zahlen gleich). <br><br><h2>  Messungen </h2><br>  In jedem der Modelle (sowohl deterministisch als auch überlagert) werden wir zwei Experimente mit verschränkten Partikeln durchführen, die den ersten und zweiten Bedingungen gemäß Mermin entsprechen: <br><br><ol><li>  Stellen Sie zunächst beide Sensoren auf die gleiche Position.  In diesem Fall erhalten wir 100% identische Ergebnisse (wenn das erste Photon den Polarisator passiert, passiert das zugehörige Photon auch den Polarisator im gleichen Winkel). </li><li>  Dann werden wir die Position der Sensoren zufällig einstellen. </li></ol><br>  Hier ist der Code für das erste Experiment: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Hier ist der Code für das zweite Experiment: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Die gleichen Tests werden für alle Partikelmodelle durchgeführt, nur der Partikelcode ist für das deterministische Modell und das Überlagerungsmodell unterschiedlich (mehr dazu weiter unten). <br><br><h2>  Deterministisches Modell </h2><br>  Achtung!  Siehe UPDATE am Ende des Artikels! <br><br>  Für diejenigen, die den Code sofort ausführen möchten, kann dies über den Browser erfolgen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Nach Minins Erklärung haben wir also ein Quantenteilchen mit drei Parametern: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Da das Modell deterministisch ist, werden alle Parameter des Partikels zum Zeitpunkt seiner Erstellung, dh direkt im Konstruktor, initialisiert.  Die einzige Bedingung ist, dass die Messung nur einmal erlaubt ist! <br><br>  Weiter.  Ein Paar verwickelter Partikel: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  Es ist ersichtlich, dass die Werte jedes der Partikel zum Zeitpunkt der Erzeugung eines Paares verschränkter Partikel eingestellt werden und die Parameter des zweiten Partikels den Parametern des ersten Partikels entsprechen (ohne dies können wir den ersten Test nicht bestehen).  Wir verwenden Zufallszahlen, aber je nach Modell hängen die Parameter von den Faktoren zum Zeitpunkt des Verwickelns ab (aufgrund des Roulettes hängt dies von einer Reihe von Faktoren zum Zeitpunkt des Aufdrehens ab). <br><br>  Vollständiger Beispielcode: <br><br><div class="spoiler">  <b class="spoiler_title">C # -Code des deterministischen Modells (fest)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Sie können es über den Browser starten (noch einmal den Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Nach dem Start sind dies die Ergebnisse: <br><br><blockquote>  Versuch Nr. 1: 100% der Werte stimmten überein <br>  Versuch Nr. 2: 55.6700% der Werte stimmten überein <br></blockquote><br>  Der erste bestandene Test entspricht dem, was in der Realität passiert.  Aber die zweite - passt nicht zusammen, da sie 50% bekommen sollten! <br><br>  Infolgedessen mussten die Physiker zu dem Schluss kommen, dass die Theorie der verborgenen Parameter falsch ist.  Und damit wird das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Lokalität</a> widerlegt und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip der Kausalität</a> sogar erschüttert. <br><br><h2>  Überlagerungsmodell </h2><br>  Sofort ein Link zu einem Beispielcode für diejenigen, die Besonderheiten lieben (kann in einem Browser gestartet werden): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Um die während der Experimente erhaltenen Ergebnisse zu erklären, mussten komplexere Modelle verwendet werden.  In modernen Modellen wird der Zustand der Partikelparameter vor der Messung nicht definiert, und verschränkte Partikel selbst können sich sofort (über die Lichtgeschwindigkeit hinaus) gegenseitig beeinflussen.  So sieht unser Partikelmodell jetzt aus: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Erstens sind die Parameter nullbar (sie spielen möglicherweise keine Rolle) und wir setzen sie nicht im Konstruktor.  Zweitens die CreateSuperluminalChannelWith-Methode zum Einstellen des Superlichtkanals zwischen Partikeln, d.h.  Jetzt kann ein Teilchen unabhängig von der Entfernung sofort den Zustand eines anderen Teilchens erhalten.  Nun, und vor allem, jetzt wird der Zustand eines Partikels <i>erst zum Zeitpunkt der Messung</i> (Aufruf der GetValue-Methode) festgestellt und hängt davon ab, ob ein anderes Partikel, das damit zusammenhängt, gemessen wurde. <br><br>  Das Innere der GetValue-Methode ist reine Spekulation.  Niemand weiß, wie das Partikel im Inneren angeordnet ist, aber wir wissen, dass es einfach so funktioniert: 100% Fehlanpassungen bei Messung desselben Parameters und 50% Fehlanpassungen bei Messung von Parametern in zufälliger Reihenfolge. <br><br>  In meiner Version des Codes prüft ein Partikel durch einen überluminalen Kanal, ob die Messung damit verwechselt wird, und verhält sich wie folgt: <br><br><ol><li>  Wenn der gemessene Parameter eines anderen Partikels derselbe ist, den wir messen möchten, ergibt sich der gleiche Wert. </li><li>  Wenn der Parameter unterschiedlich ist, gibt er in 1/4 der Fälle den gleichen Wert und in 3/4 der Fälle den entgegengesetzten Wert (da wir 50/50 erhalten). </li></ol><br>  Wenn die Messung nicht durchgeführt wurde, verwendet das Partikel eine echte Zufälligkeit, um seinen Wert festzulegen, dh ein Kausalzusammenhang wird verletzt (der Wert war vor der Messung nicht vorhanden und die Messung selbst hat seinen Wert nicht bestimmt). <br><br>  <i>Übrigens!</i>  <i>Sie können diese Funktion auf andere Weise umschreiben, damit die Testergebnisse identisch sind.</i>  <i>Trotzdem weiß niemand, wie das Elementarteilchen angeordnet ist und wie 50% für den zweiten Test erreicht werden.</i> <i><br></i> <br>  Ein Paar verschränkter Partikel ist einfacher geworden, da zum Zeitpunkt der Verschränkung keine Werte festgelegt sind (Werte wurden noch nicht bestimmt): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Vollständiger Beispielcode: <br><br><div class="spoiler">  <b class="spoiler_title">Überlagerungsmodell in C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Ergebnisse: <br><br><blockquote>  Versuch Nr. 1: 100% der Werte stimmten überein <br>  Versuch Nr. 2: 49,77700% der Werte stimmten überein <br></blockquote><br>  Führen Sie im Browser aus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Schlussfolgerungen </h2><br>  Ich hätte gerne mehr Interpretationen, wie die von Mermin.  Basierend auf dieser Interpretation habe ich es geschafft, visuelle Modelle bestehender Theorien zu erstellen und sogar ein alternatives Modell vorzuschlagen, und diese Modelle sind nicht allegorisch - Sie können sie ausführen und sehen, wie sie funktionieren. <br><br>  Leider habe ich nicht die Zeitressourcen für ein tieferes Wissen über die Quantenphysik und ich hoffe, dass diejenigen, die es wissen, meinem Beispiel folgen und genauere Arbeitsmodelle geben können. <br><br>  <b>UPDATE</b> <br>  Minins Erklärung bezieht sich nicht auf das Design von Detektoren.  Aus eigener Initiative fügte ich A, B und C eine Erklärung als Projektion des Spins auf die X-, Y- und Z-Achse hinzu.  Das heißt, ich wollte in den Kommentaren zum Code eine Bindung zu physikalischen Phänomenen hinzufügen, damit er nicht so trocken wird.  Und ich habe mich geirrt ... <br><br>  Der Artikel wird korrigiert und alle vergeblichen Versuche, Minins Erklärung mit realen physikalischen Experimenten zu verknüpfen, werden gelöscht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420611/">https://habr.com/ru/post/de420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420599/index.html">Dreizehn Dinge, die Lem vorausgesehen hat</a></li>
<li><a href="../de420603/index.html">Statistiken des Besitzers von Tesla Model S.</a></li>
<li><a href="../de420605/index.html">Überblick über den Algorithmus für Vorstellungsgespräche - Set-Generierung</a></li>
<li><a href="../de420607/index.html">Digitale Veranstaltungen in Moskau vom 20. bis 26. August</a></li>
<li><a href="../de420609/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 327 (13. - 19. August 2018)</a></li>
<li><a href="../de420613/index.html">11 Bibliotheken (Komponentensätze) für React Native, über die Sie 2018 Bescheid wissen sollten</a></li>
<li><a href="../de420615/index.html">JavaScript: Objekte erkunden</a></li>
<li><a href="../de420617/index.html">Webdesign-Handbuch für Entwickler</a></li>
<li><a href="../de420619/index.html">Responsive Images: CSS-Tricks, die Zeit sparen</a></li>
<li><a href="../de420623/index.html">Verteilte C ++ - Anwendungen mit minimalem Aufwand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>