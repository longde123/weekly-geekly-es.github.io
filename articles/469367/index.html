<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üï£ üé† Ejecute pruebas unitarias localmente en STM32CubeIDE en Windows ‚ôâÔ∏è üßõüèª ‚ÅâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Todos conocen los beneficios de las pruebas unitarias. En primer lugar, escribir pruebas al mismo tiempo que el c√≥digo le permite det...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ejecute pruebas unitarias localmente en STM32CubeIDE en Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469367/"><h3 id="vvedenie">  Introduccion </h3><br><p><img src="https://habrastorage.org/webt/8f/3q/2r/8f3q2rt_-eycgp3_ejr_hfwqnva.png" align="left" width="200">  Todos conocen los beneficios de las pruebas unitarias.  En primer lugar, escribir pruebas al mismo tiempo que el c√≥digo le permite detectar errores antes y no perder tiempo posteriormente en la depuraci√≥n compleja que consume mucho tiempo.  En el caso del desarrollo integrado, las pruebas unitarias tienen caracter√≠sticas relacionadas, en primer lugar, con el hecho de que el c√≥digo se ejecuta en alg√∫n lugar profundo de las entra√±as del dispositivo y es bastante dif√≠cil interactuar con √©l, y en segundo lugar, el c√≥digo est√° fuertemente vinculado al hardware de destino. . </p><br><p>  Si hay fragmentos en el proyecto que no dependen del hardware y al mismo tiempo implementan una l√≥gica bastante compleja, para ellos el uso de pruebas unitarias dar√° el mayor beneficio.  Por ejemplo, puede ser la implementaci√≥n de un protocolo de transferencia de datos, varios c√°lculos o una m√°quina de estado de control. </p><br><p>  Hay tres formas de ejecutar pruebas unitarias para plataformas integradas: </p><a name="habracut"></a><br><ol><li>  Inicie directamente en la plataforma de destino.  En este caso, puedes trabajar con el equipo del dispositivo, y el c√≥digo funcionar√° exactamente igual que en condiciones de combate.  Sin embargo, para las pruebas necesitar√° acceso f√≠sico al dispositivo.  Adem√°s, el ciclo de prueba ser√° bastante largo debido a la necesidad de descargar constantemente el c√≥digo al dispositivo. </li><li>  Corriendo en un emulador.  Este m√©todo es bueno principalmente porque le permite trabajar incluso cuando la plataforma de destino no est√° disponible (por ejemplo, porque a√∫n no se ha hecho).  Las desventajas son la precisi√≥n limitada en la reproducci√≥n del comportamiento del hierro (y el mundo circundante), as√≠ como la dificultad de crear dicho emulador. </li><li>  Ejecutando en la m√°quina host (localmente).  No funcionar√° con el equipo (puede usar trozos de prueba en su lugar), pero las pruebas comenzar√°n y funcionar√°n r√°pidamente, y no necesita acceso al dispositivo de destino.  Un buen ejemplo para usar este m√©todo es probar la implementaci√≥n de un algoritmo computacional en el microcontrolador, que en s√≠ mismo no depende del hardware, sino que usa los datos del sensor del dispositivo.  Probar un algoritmo con una fuente de datos real ser√° muy inconveniente, es mucho mejor registrar estas mediciones una vez y ejecutar pruebas que ya est√©n en los datos almacenados.  Este script ejecutar√° pruebas localmente y se discutir√° m√°s adelante. </li></ol><br><p>  Esta publicaci√≥n proporciona una forma de configurar pruebas unitarias en el entorno STM32CubeIDE, basado en Eclipse y destinado al desarrollo de controladores de la familia STM32.  El lenguaje de desarrollo es C, pero las pruebas mismas est√°n escritas en C ++.  Las pruebas se ejecutar√°n en una m√°quina host de Windows con Cygwin.  Como marco de prueba, se utiliza Google Test.  Los resultados se mostrar√°n en una ventana de complemento especial para pruebas unitarias, y se pueden iniciar con un bot√≥n del proyecto para STM32: </p><br><p><img src="https://habrastorage.org/webt/mo/_j/gw/mo_jgwdlc6e3qqzjkcbsxrslvaq.png"></p><br><p>  El m√©todo descrito es adecuado para otros entornos de desarrollo basados ‚Äã‚Äãen Eclipse, a menos que, por supuesto, los buenos fabricantes los hayan cortado demasiado por conveniencia de los desarrolladores.  Este m√©todo tambi√©n funcionar√° con CubeIDE en Linux, sin la necesidad de molestarse con Cygwin. </p><br><h3 id="vam-ponadobyatsya">  Necesitar√°s </h3><br><ol><li>  Cygwin 3.0.7 x86 (dado que las pruebas son para un microcontrolador de 32 bits, tambi√©n utilizaremos un entorno de 32 bits en una plataforma de 64 bits) </li><li>  STM32CubeIDE 1.0.2 para Windows. </li><li>  Google Test Framework 1.8.1 </li></ol><br><h3 id="ustanovka-cygwin-i-stm32cubeide">  Instale Cygwin y STM32CubeIDE </h3><br><h4 id="cygwin">  Cygwin </h4><br><p>  Instale Cygwin, versi√≥n x86.  En el instalador, seleccione paquetes adicionales: gcc-core, g ++, binutils, automake, autoconf, cmake, libtool, gdb, make.  Puede instalar las √∫ltimas versiones estables de paquetes. </p><br><p><img src="https://habrastorage.org/webt/xc/fj/6v/xcfj6v0wun10fgdbskuccodkqqk.png"></p><br><p>  Tambi√©n necesita registrar variables de entorno: </p><br><p>  <strong>RUTA:</strong> ...; C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ bin;  C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib <br>  <strong>classpath:</strong> C: \ &lt;path_to_Cygwin&gt; \ Cygwin \ lib </p><br><h4 id="stm32cubeide">  STM32CubeIDE </h4><br><p>  El entorno se instala como de costumbre.  Es recomendable instalar CubeIDE despu√©s de Cygwin, porque en este caso Cube recoger√° la cadena de herramientas Cygwin existente. </p><br><p>  Primero, cree un proyecto C ++ para la plataforma x86 Cygwin.  Lo necesitaremos para, en primer lugar, verificar la funcionalidad de la cadena de herramientas y, en segundo lugar, lo utilizaremos como "donante" de la configuraci√≥n del ensamblaje para el proyecto principal. </p><br><p>  Elija Archivo&gt; Nuevo&gt; Proyecto C / C ++.  Seleccione C ++ Managed Build.  Creamos un proyecto de tipo hello world para la cadena de herramientas Cygwin GCC: </p><br><p><img src="https://habrastorage.org/webt/jc/ny/1n/jcny1ntttq4rzapxeth3-s2emim.png"></p><br><p>  A continuaci√≥n, deber√° elegir qu√© configuraciones de ensamblaje crear.  Solo depurar es suficiente. <br>  Ahora puede verificar que el proyecto se est√° ejecutando seleccionando Proyecto&gt; Construir todo.  Tambi√©n es recomendable verificar la depuraci√≥n en Cygwin ejecutando Ejecutar&gt; Depurar como&gt; Aplicaci√≥n C / C ++ local.  La aplicaci√≥n mostrar√° "Hello world" en la consola dentro de CubeIDE. </p><br><p>  Para que el depurador muestre l√≠neas ejecutables en archivos de c√≥digo fuente, debe configurar la visualizaci√≥n de rutas.  En la ventana Ventana&gt; Preferencias, en la pesta√±a C / C ++&gt; Depurar, seleccione Ruta de b√∫squeda de origen y agregue una nueva pantalla: Agregar&gt; Asignaci√≥n de ruta.  En la ventana, debe nombrar algo como una nueva pantalla y agregar l√≠neas para los discos que est√°n en el sistema: </p><br><ul><li>  \ cygdrive \ c - C: \ </li><li>  \ cygdrive \ g - G: \ </li></ul><br><p><img src="https://habrastorage.org/webt/fe/ro/2h/fero2hpb7i_n1cjf4sie1nfdndm.png"></p><br><p><img src="https://habrastorage.org/webt/cc/y3/4e/ccy34eo_dtfubifpmfnmkgzkjgu.png"></p><br><p>  Para una hermosa ejecuci√≥n de prueba, tambi√©n necesitamos un complemento para Eclipse con soporte para pruebas unitarias para C ++.  Se instala directamente desde STM32CubeIDE: men√∫ Ayuda&gt; Instalar nuevo software, luego seleccione el Eclipse Repository e instale el complemento C / C ++ Unit Testing Support. </p><br><p><img src="https://habrastorage.org/webt/67/eh/ns/67ehnsuupvabu-i1vvkp6dfz4yc.png"></p><br><h3 id="sborka-biblioteki-google-test">  Crea la biblioteca de pruebas de Google </h3><br><p>  El c√≥digo fuente de la biblioteca se puede tomar en: <a href="">https://github.com/google/googletest/tree/release-1.8.1</a> <br>  Descomprima las fuentes, vaya al directorio googletest-release-1.8.1 con el terminal Cygwin y ejecute: </p><br><pre><code class="bash hljs">cmake . make</code> </pre> <br><p>  Despu√©s de un ensamblaje exitoso, el archivo de la biblioteca est√°tica estar√° en ./googlemock/lib/libgtest.a, y los archivos de encabezado estar√°n en el directorio ./googletest/include/gtest/.  Deber√°n copiarse en nuestro proyecto (o escribir la ruta a estos archivos en la configuraci√≥n del proyecto). </p><br><h3 id="sozdanie-proekta-dlya-stm32">  Crear un proyecto para STM32 </h3><br><p>  Dise√±o para placa de depuraci√≥n STM32L476G-DISCO.  El ejemplo no ser√° demasiado sofisticado: hay dos LED en el tablero, perm√≠tales mostrar un contador binario de 00 a 11. Implementaremos un m√≥dulo separado para el contador, descrito en un par de archivos .h y .c, y escribiremos una prueba para ello. <br>  El proyecto se puede crear como de costumbre, utilizando el configurador de cubos, lo principal es asegurarse de que los pines PB2 y PE8 est√©n configurados como salidas digitales.  Al crear un proyecto, ser√≠a mejor especificar el tipo: C ++, esto ser√° necesario para compilar las pruebas (el compilador de C seguir√° compilando el c√≥digo principal).  La conversi√≥n de un proyecto desde C ser√° posible m√°s tarde, haciendo clic en el nombre del proyecto RMB y seleccionando "Convertir a C ++". </p><br><p>  Para la compilaci√≥n bajo MK y para las pruebas, necesitamos dos configuraciones de ensamblaje diferentes.  En estas configuraciones, se recopilar√°n diferentes conjuntos de archivos: los principales obtendr√°n los m√≥dulos para trabajar con hardware y los m√≥dulos probados, y el de prueba obtendr√° los mismos m√≥dulos probados y archivos de prueba.  Por lo tanto, crearemos diferentes directorios en la ra√≠z del proyecto: aplicaci√≥n con el c√≥digo de aplicaci√≥n para MK (simplemente puede cambiar el nombre del directorio Src que cre√≥ Cube), Com√∫n para m√≥dulos que no dependen del hierro (que probaremos) y Pruebas para pruebas.  Los directorios se pueden excluir del ensamblaje haciendo clic en RMB en su nombre, men√∫ Configuraci√≥n de recursos&gt; Excluir de compilaci√≥n. </p><br><p>  Agregue nuestro m√≥dulo contador al directorio com√∫n: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo led_counter</b> <div class="spoiler_text"><p>  (led_counter.h): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED_COUNTER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; void Led_Counter_Init(); uint8_t Led_Counter_Get_Next(); #endif /* LED_COUNTER_H_ */</span></span></span></span></code> </pre> <br><p>  led_counter.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> static uint8_t led_cnt_state = 0; void Led_Counter_Init() { led_cnt_state = 0; } uint8_t Led_Counter_Get_Next() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(++led_cnt_state &gt; 3) led_cnt_state = 0; return led_cnt_state; }</span></span></code> </pre> </div></div><br><p>  Los directorios Com√∫n y Pruebas deben agregarse a la ruta de b√∫squeda para incluir archivos: propiedades del proyecto (Propiedades)&gt; C / C ++ General&gt; Rutas y s√≠mbolos&gt; Incluye. </p><br><p>  A√±adir a trabajar con LED principales </p><br><div class="spoiler">  <b class="spoiler_title">Fragmento main.c</b> <div class="spoiler_text"><p>  main.c: </p><br><pre> <code class="cpp hljs">‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span><span class="hljs-meta"> ‚Ä¶ int main(void) { ‚Ä¶ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN WHILE */</span></span></span><span class="hljs-meta"> Led_Counter_Init(); uint8_t led_state = 0; while (1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END WHILE */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 3 */</span></span></span><span class="hljs-meta"> led_state = Led_Counter_Get_Next(); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, led_state &amp; (1&lt;&lt;0)); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, led_state &amp; (1&lt;&lt;1)); HAL_Delay(500); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 3 */</span></span></span><span class="hljs-meta"> ‚Ä¶ }</span></span></code> </pre> </div></div><br><p>  El proyecto debe compilarse y ejecutarse, y los LED deben parpadear. </p><br><h3 id="napisanie-testov">  Pruebas de escritura </h3><br><p>  Ahora eso para lo que todo comenz√≥. </p><br><p>  Cree una nueva configuraci√≥n de compilaci√≥n a trav√©s de las propiedades del proyecto: Propiedades&gt; Compilaci√≥n C / C ++&gt; Configuraci√≥n&gt; Administrar configuraciones.  CubeIDE simplemente no le permitir√° crear una configuraci√≥n para compilar en Cygwin, as√≠ que c√≥piela del proyecto que creamos anteriormente: </p><br><p><img src="https://habrastorage.org/webt/4d/ro/kd/4drokdgkom2o6z18duo1v_tbmwi.png"></p><br><p>  Ahora debe cambiar a esta configuraci√≥n y configurar las rutas a los archivos de origen y los archivos de encabezado.  En las propiedades del proyecto en la pesta√±a Rutas y s√≠mbolos que prescribimos (al agregar una entrada, es mejor poner un toque en el campo "agregar a todos los idiomas"): </p><br><ul><li>  Incluye - Pruebas / Inc, Com√∫n / Inc </li><li>  Bibliotecas - gtest </li><li>  Rutas de la biblioteca - Pruebas / Lib </li><li>  Ubicaci√≥n de origen - / &lt;prj_name&gt; / Common y / &lt;prj_name&gt; / Tests (reemplace &lt;prj_name&gt; con el nombre del proyecto) </li></ul><br><p>  Luego, copie la biblioteca gtest - el archivo .a al directorio Tests / Lib en el proyecto, y los archivos de encabezado en la carpeta gtest - a la carpeta Tests / Inc.  En la carpeta Pruebas, cree un nuevo archivo main.cpp en el que se ejecutar√°n las pruebas.  Sus contenidos son est√°ndar: </p><br><p>  main.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Unit tests main file */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS(); }</span></span></code> </pre> <br><p>  Adem√°s, para probar la configuraci√≥n, crearemos una prueba que verificar√° que el tama√±o del puntero sea de 32 bits en nuestro entorno (queremos asegurarnos de que sea el mismo que en el microcontrolador, para esto configuramos Cygwin de 32 bits). </p><br><p>  Cree el siguiente archivo de prueba test_platform.cpp: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> TEST(PlatformTest, TestPointerSize) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Check pointer size is 32 bit ASSERT_EQ(sizeof(void*)*8, 32U); }</span></span></span></span></code> </pre> <br><p>  Ahora, si el proyecto se ejecuta como la aplicaci√≥n C ++ habitual, la salida de depuraci√≥n contendr√° un mensaje de Google Test que indica que todas las pruebas han pasado. </p><br><p>  La estructura del proyecto deber√≠a verse as√≠: <br><img src="https://habrastorage.org/webt/ev/ld/g2/evldg2fj_pqta199knozgvzicu8.png"></p><br><p>  Ahora escribiremos pruebas para nuestro m√≥dulo contador LED.  Los archivos de prueba se pueden ubicar en la carpeta Pruebas: </p><br><div class="spoiler">  <b class="spoiler_title">test_led_counter.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gtest/gtest.h"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"led_counter.h"</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Test fixture class LedCounterTest: public ::testing::Test { protected: void SetUp() { Led_Counter_Init(); } }; // Check initial value TEST_F(LedCounterTest, TestInitialValue) { Led_Counter_Init(); ASSERT_EQ(Led_Counter_Get_Next(), 1); } // Check how value is incremented TEST_F(LedCounterTest, TestIncrementValue) { Led_Counter_Init(); unsigned int val = Led_Counter_Get_Next(); for(int i=0;i&lt;1;i++) { ASSERT_EQ(Led_Counter_Get_Next(), ++val); } } // Check how value return to 0 after 3 TEST_F(LedCounterTest, TestZeroCrossing) { Led_Counter_Init(); for(int i=0;i&lt;3;i++) { Led_Counter_Get_Next(); } ASSERT_EQ(Led_Counter_Get_Next(), 0); }</span></span></span></span></code> </pre> </div></div><br><p>  Para que los resultados de la prueba se muestren en una hermosa ventana, debe crear una nueva configuraci√≥n de inicio en el men√∫ Ejecutar&gt; Configuraciones de depuraci√≥n.  El complemento instalado le permite crear configuraciones de tipo C / C ++ Unit.  Cr√©elo, llame a Ejecutar pruebas, seleccione la configuraci√≥n de ensamblaje "Prueba" utilizada y desactive la casilla de verificaci√≥n "detener al iniciar en" en la pesta√±a Depurador.  Despu√©s de eso, se puede iniciar la configuraci√≥n. </p><br><p>  Para que aparezca una ventana con los resultados, selecci√≥nela en Ventana&gt; Mostrar vista&gt; Otro&gt; C / C ++&gt; Unidad C / C ++. </p><br><p><img src="https://habrastorage.org/webt/ip/qd/cr/ipqdcrsjl0iohvf1yq4_99xwieq.png"></p><br><p>  Hecho  Ahora el proyecto se puede compilar y ejecutar bajo el MK de destino como de costumbre.  Cuando necesite ejecutar pruebas locales, cuando ejecute la configuraci√≥n Ejecutar pruebas, el proyecto se reconstruir√° autom√°ticamente para x86, el entorno ejecutar√° las pruebas y mostrar√° el resultado. </p><br><h3 id="literatura">  Literatura </h3><br><ol><li>  J. Grenning.  Desarrollo guiado por pruebas para C. incrustado: trabajo fundamental en pruebas unitarias de sistemas embebidos y en la aplicaci√≥n de la metodolog√≠a TDD. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://uncannier.com/unit-testing-of-embedded-firmware-part-1-software-confucius/</a> - Prueba unitaria del c√≥digo del microcontrolador x86 en Texas Instruments Code Composer Studio, marco CppUTest </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://blog.atollic.com/why-running-your-embedded-arm-cortex-code-on-a-host-pc-is-a-good-thing</a> : un art√≠culo sobre por qu√© podr√≠a ser √∫til ejecutar c√≥digo para un microcontrolador en una plataforma de escritorio </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469367/">https://habr.com/ru/post/469367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469351/index.html">Intel Comet Lake-U y Comet Lake-Y: hasta 6 n√∫cleos para port√°tiles delgados y ligeros</a></li>
<li><a href="../469353/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 317 (23 y 29 de septiembre)</a></li>
<li><a href="../469355/index.html">Un aburrido tutorial de NumPy</a></li>
<li><a href="../469357/index.html">¬°Corre, Gopher, corre! - de qu√© hablaremos en GolangConf</a></li>
<li><a href="../469361/index.html">Dolor y l√°grimas en Svelte 3</a></li>
<li><a href="../469369/index.html">Eventos digitales en Mosc√∫ del 30 de septiembre al 06 de octubre</a></li>
<li><a href="../469371/index.html">Descripci√≥n del enfoque para organizar y probar c√≥digo usando Redux Thunk</a></li>
<li><a href="../469373/index.html">Los resultados del proyecto para crear una interfaz neuronal para pacientes completamente paralizados han cuestionado</a></li>
<li><a href="../469375/index.html">¬øPor qu√© Mozilla, Coil y Creative Commons asignan $ 100 millones para proyectos de c√≥digo abierto?</a></li>
<li><a href="../469379/index.html">Aplicaci√≥n de m√©todos formales de validaci√≥n de modelos para IU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>