<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèº üèæ üë®üèº‚Äçüíª Comparando o mesmo projeto em Rust, Haskell, C ++, Python, Scala e OCaml üöÖ üêë üë®‚Äçüë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo semestre da universidade, escolhi o curso de compila√ß√£o CS444 . L√°, cada grupo de 1 a 3 pessoas precisava escrever um compilador a partir de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparando o mesmo projeto em Rust, Haskell, C ++, Python, Scala e OCaml</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"> No √∫ltimo semestre da universidade, escolhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o curso de compila√ß√£o CS444</a> .  L√°, cada grupo de 1 a 3 pessoas precisava escrever um compilador a partir de um subconjunto substancial de Java no x86.  Idioma para escolher um grupo.  Essa foi uma rara oportunidade para comparar implementa√ß√µes de grandes programas da mesma funcionalidade, escritas por programadores muito competentes em diferentes idiomas, e comparar a diferen√ßa de design e escolha de idioma.  Essa compara√ß√£o deu origem a muitos pensamentos interessantes.  Essa compara√ß√£o controlada de idiomas √© raramente vista.  N√£o √© perfeito, mas muito melhor do que a maioria das hist√≥rias subjetivas nas quais as opini√µes das pessoas sobre linguagens de programa√ß√£o se baseiam. <br><br>  Criamos nosso compilador Rust, e primeiro eu o comparei com o projeto da equipe Haskell.  Eu esperava que o programa deles fosse muito mais curto, mas acabou sendo do mesmo tamanho ou maior.  O mesmo vale para o OCaml.  Depois, comparei-o com o compilador C ++, e era de se esperar que o compilador fosse cerca de 30% maior, principalmente devido a cabe√ßalhos, falta de tipos de soma e correspond√™ncia de padr√µes.  A compara√ß√£o a seguir foi com minha amiga, que fez o compilador sozinha em Python e usou menos da metade do c√≥digo comparado a n√≥s, devido ao poder da metaprograma√ß√£o e dos tipos din√¢micos.  Outro amigo tinha um programa Scala menor.  O que mais me surpreendeu foi a compara√ß√£o com outra equipe que tamb√©m usava o Rust, mas eles tiveram tr√™s vezes mais c√≥digo devido a diferentes decis√µes de design.  No final, a maior diferen√ßa na quantidade de c√≥digo estava no mesmo idioma! <br><a name="habracut"></a><br>  Vou explicar por que considero isso uma boa compara√ß√£o, fornecer algumas informa√ß√µes sobre cada projeto e explicar alguns motivos para diferen√ßas no tamanho do compilador.  Tamb√©m tirarei conclus√µes de cada compara√ß√£o.  Sinta-se √† vontade para usar esses links para acessar a se√ß√£o de interesse: <br><br><h1>  Conte√∫do </h1><br><ul><li>  Por que acho isso significativo <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferrugem (base de compara√ß√£o)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Haskell</a> : 1,0-1,6 tamanhos, dependendo de como voc√™ conta, por raz√µes interessantes <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++</a> : 1,4 tamanhos por raz√µes √≥bvias <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python</a> : tamanho 0.5 devido a metaprograma√ß√£o sofisticada! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferrugem (outro grupo)</a> : tr√™s vezes o tamanho devido a um design diferente! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Scala</a> : 0,7 tamanhos <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OCaml</a> : tamanho 1.0-1.6, dependendo de como voc√™ conta, semelhante ao Haskell </li></ul><br><h1>  Por que acho isso significativo </h1><br>  Antes de voc√™ dizer que a quantidade de c√≥digo (comparei as seq√º√™ncias de caracteres e os bytes) √© uma m√©trica terr√≠vel, quero observar que, nesse caso, ele pode fornecer um bom entendimento.  Pelo menos, este √© o exemplo mais bem controlado em que equipes diferentes escrevem o mesmo grande programa que ouvi ou li. <br><br><ul><li>  Ningu√©m (inclusive eu) sabia que eu mediria esse par√¢metro; portanto, ningu√©m tentou reproduzir m√©tricas; todos tentaram terminar o projeto de maneira r√°pida e correta. <br></li><li>  Todos (com exce√ß√£o do projeto Python, que discutirei mais adiante) implementaram o programa com o √∫nico objetivo de passar no mesmo conjunto de testes automatizados no mesmo per√≠odo de tempo, para que os resultados n√£o possam ser muito distorcidos por grupos que resolvem problemas diferentes. <br></li><li>  O projeto foi conclu√≠do em alguns meses, com a equipe, e deveria expandir gradualmente e passar em testes conhecidos e desconhecidos.  Isso significa que foi √∫til escrever um c√≥digo limpo e claro. <br></li><li>  Al√©m de passar nos testes do curso, o c√≥digo n√£o ser√° usado para mais nada, ningu√©m ir√° l√™-lo e, sendo um compilador para um subconjunto limitado de Java no assembler de texto, n√£o ser√° √∫til. <br></li><li>  Nenhuma biblioteca diferente da biblioteca padr√£o √© permitida e nenhum auxiliar para an√°lise, mesmo que eles estejam na biblioteca padr√£o.  Isso significa que a compara√ß√£o n√£o pode ser distorcida pelas poderosas bibliotecas do compilador que apenas alguns comandos possuem. <br></li><li>  N√£o foram apenas testes p√∫blicos, mas tamb√©m secretos.  Eles come√ßaram uma vez ap√≥s a entrega final.  Isso significava que havia um incentivo para escrever seu pr√≥prio c√≥digo de teste e garantir que o compilador fosse confi√°vel, correto e lidasse com situa√ß√µes complexas de borda. <br></li><li>  Embora todos os participantes sejam estudantes, considero-os programadores bastante competentes.  Cada um deles fez est√°gios por pelo menos dois anos, principalmente em empresas de alta tecnologia, √†s vezes at√© trabalhando em compiladores.  Quase todos est√£o programados por 7 a 13 anos e s√£o entusiastas que l√™em muito na Internet fora de seus cursos. <br></li><li>  O c√≥digo gerado n√£o foi levado em considera√ß√£o, mas os arquivos gramaticais e o c√≥digo que gerou o outro c√≥digo foram levados em considera√ß√£o. </li></ul><br>  Portanto, acho que a quantidade de c√≥digo fornece uma compreens√£o decente de quanto esfor√ßo ser√° necess√°rio para apoiar cada projeto, se for de longo prazo.  Penso que n√£o h√° muita diferen√ßa entre os projetos que tamb√©m permite refutar algumas declara√ß√µes extraordin√°rias que li, por exemplo, que o compilador Haskell ter√° mais da metade do tamanho do C ++ devido √† linguagem. <br><br><a name="1"></a><h1>  Ferrugem (base de compara√ß√£o) </h1><br>  Eu e um de meus camaradas escrevemos mais de 10 mil linhas em Rust antes e o terceiro colega escreveu, talvez, 500 linhas em algumas hackathons.  Nosso compilador saiu em 6806 linhas de <code>wc -l</code> , 5900 linhas de origem (sem espa√ßos e coment√°rios) e 220 KB <code>wc -c</code> . <br><br>  Descobri que em outros projetos essas propor√ß√µes s√£o mais ou menos respeitadas, com algumas exce√ß√µes, que observarei.  No restante do artigo, quando me refiro a strings ou somas, quero dizer <code>wc -l</code> , mas isso n√£o importa (a menos que note a diferen√ßa), e voc√™ pode converter com um coeficiente. <br><br>  Escrevi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro artigo descrevendo nosso design</a> , que passou em todos os testes p√∫blicos e secretos.  Ele tamb√©m cont√©m alguns recursos adicionais que criamos para nos divertir, n√£o para passar nos testes, que provavelmente adicionaram cerca de 400 linhas.  Ele tamb√©m possui cerca de 500 linhas de nossos testes de unidade. <br><br><a name="2"></a><h1>  Haskell </h1><br>  A equipe do Haskell incluiu dois de meus amigos que escreveram talvez algumas linhas de Haskell cada um, al√©m de ler muito conte√∫do on-line sobre o Haskell e outras linguagens funcionais semelhantes, como OCaml e Lean.  Eles tinham outro colega de equipe que eu n√£o conhecia muito bem, mas parece que um programador forte usou Haskell antes. <br><br>  Seu compilador totalizou 9.750 linhas de <code>wc -l</code> , 357 KB e 7777 linhas de c√≥digo (SLOC).  Essa equipe tamb√©m possui as √∫nicas diferen√ßas significativas entre essas propor√ß√µes: o compilador √© 1,4 vezes maior que o nosso nas linhas, 1,3 vezes no SLOC e 1,6 vezes em bytes.  Eles n√£o implementaram nenhuma fun√ß√£o adicional, passaram 100% dos testes p√∫blicos e secretos. <br><br>  √â importante observar que a inclus√£o de testes afetou principalmente essa equipe.  Como eles abordaram cuidadosamente a exatid√£o do c√≥digo, inclu√≠ram 1.600 linhas de testes.  Eles capturaram v√°rias situa√ß√µes lim√≠trofes que nossa equipe n√£o detectou, mas esses casos simplesmente n√£o foram verificados pelos testes do curso.  Portanto, sem testes nos dois lados (6,3 mil linhas versus 8,1 mil linhas), o compilador √© apenas 30% a mais que o nosso. <br><br>  Aqui, eu tendem a bytes como uma medida mais razo√°vel da compara√ß√£o de volumes, porque em um projeto Haskell, em m√©dia, existem linhas mais longas, pois ele n√£o possui um grande n√∫mero de linhas de um par√™ntese de fechamento e o <code>rustfmt</code> n√£o <code>rustfmt</code> cadeias de fun√ß√µes de linha √∫nica em v√°rias linhas. <br><br>  Depois de vasculhar um de meus colegas de equipe, chegamos √† seguinte explica√ß√£o para essa diferen√ßa: <br><br><ul><li>  Utilizamos um analisador lexical manuscrito e um m√©todo de descida recursiva, e eles usaram um gerador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NFA</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DFA</a> e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisador LR</a> e, em seguida, um passe para converter a √°rvore de an√°lise em AST ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore de sintaxe abstrata</a> , representa√ß√£o mais conveniente do c√≥digo).  Isso deu a eles significativamente mais c√≥digo: 2677 linhas em compara√ß√£o com o 1705, cerca de 1000 linhas a mais. <br></li><li>  Eles usaram o fant√°stico AST gen√©rico, que passou para v√°rios par√¢metros de tipo √† medida que mais informa√ß√µes eram adicionadas em cada passagem.  Essa e outras fun√ß√µes auxiliares para reescrita provavelmente explicam por que o c√≥digo AST √© cerca de 500 linhas mais longo que a nossa implementa√ß√£o, onde coletamos literais de estrutura e alteramos os campos <code>Option&lt;_&gt;</code> para adicionar informa√ß√µes √† medida que avan√ßamos. <br></li><li>  Eles ainda t√™m cerca de 400 linhas de c√≥digo durante a gera√ß√£o, as quais est√£o associadas principalmente √† maior abstra√ß√£o necess√°ria para gerar e combinar o c√≥digo de uma maneira puramente funcional, onde simplesmente usamos linhas de muta√ß√£o e escrita. </li></ul><br>  Essas diferen√ßas mais testes explicam todas as diferen√ßas de volume.  De fato, nossos arquivos para constantes dobr√°veis ‚Äã‚Äãe resolu√ß√£o de contexto s√£o muito pr√≥ximos.  Mas, ainda assim, h√° alguma diferen√ßa nos bytes devido √†s linhas mais longas: provavelmente porque √© necess√°rio mais c√≥digo para reescrever a √°rvore inteira em cada passagem. <br><br>  Como resultado, deixando de lado as decis√µes de design, Rust e Haskell s√£o igualmente expressivas, talvez com uma ligeira vantagem, Rust, devido √† capacidade de usar facilmente a muta√ß√£o quando for conveniente.  Tamb√©m foi interessante saber que minha escolha do m√©todo de descida recursiva e do analisador lexical manuscrito valeu a pena: era um risco que contradiz as recomenda√ß√µes e instru√ß√µes do professor, mas decidi que era mais f√°cil e correto. <br><br>  Os f√£s de Haskell argumentar√£o que essa equipe provavelmente n√£o tirou o m√°ximo proveito dos recursos de Haskell e, se eles conhecessem melhor o idioma, poderiam fazer um projeto com menos c√≥digo.  Concordo que algu√©m como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Edward Kmett</a> pode escrever o mesmo compilador em uma quantidade muito menor.  De fato, a equipe de meu amigo n√£o usou muitas abstra√ß√µes super avan√ßadas avan√ßadas e bibliotecas combinadoras sofisticadas, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lentes</a> .  No entanto, tudo isso afeta a legibilidade do c√≥digo.  Todas as pessoas da equipe s√£o programadores experientes, eles sabiam que Haskell era capaz de coisas muito bizarras, mas decidiram n√£o us√°-las porque decidiram que entend√™-las levaria mais tempo do que economizariam e tornariam o c√≥digo mais dif√≠cil para os outros entenderem.  Isso parece um compromisso real para mim, e a afirma√ß√£o de que Haskell √© magicamente adequado para compiladores entra em algo como "Haskell requer qualifica√ß√µes extremamente altas para escrever compiladores se voc√™ n√£o se importa com o suporte de c√≥digo para pessoas que tamb√©m n√£o s√£o muito adeptas de Haskell". <br><br>  Tamb√©m √© interessante notar que, no in√≠cio de cada projeto, o professor diz que os alunos podem usar qualquer idioma que funcione em um servidor universit√°rio, mas alerta que as equipes de Haskell s√£o diferentes das demais: elas t√™m a maior dispers√£o nas notas.  Muitas pessoas superestimam suas habilidades e as equipes Haskell t√™m as notas mais ruins, embora outras se saiam bem como meus amigos. <br><br><a name="3"></a><h1>  C ++ </h1><br>  Ent√£o eu conversei com meu amigo da equipe C ++.  Eu conhecia apenas uma pessoa nessa equipe, mas o C ++ √© usado em v√°rios cursos da nossa universidade, portanto, provavelmente todos na equipe tinham experi√™ncia em C ++. <br><br>  Seu projeto consistiu em 8733 linhas e 280 KB, n√£o incluindo o c√≥digo de teste, mas incluindo cerca de 500 linhas de fun√ß√µes adicionais.  O que o torna 1,4 vezes maior que o nosso c√≥digo sem testes, que tamb√©m possui cerca de 500 linhas de fun√ß√µes adicionais.  Eles passaram em 100% dos testes p√∫blicos, mas apenas 90% dos testes secretos.  Presumivelmente, porque eles n√£o implementaram os arrays vtables sofisticados exigidos pela especifica√ß√£o, que ocupam talvez de 50 a 100 linhas de c√≥digo. <br><br>  N√£o me aprofundei muito nessas diferen√ßas de tamanho.  Eu acho que isso se deve principalmente a: <br><br><ul><li>  Eles usam o analisador LR e o reescritor de √°rvores em vez do m√©todo de descida recursiva. <br></li><li>  A falta de tipos de soma e compara√ß√µes de padr√µes em C ++, amplamente utilizados e muito √∫teis. <br></li><li>  A necessidade de duplicar todas as assinaturas nos arquivos de cabe√ßalho, o que n√£o √© o caso no Rust. </li></ul><br>  Tamb√©m comparamos o tempo de compila√ß√£o.  No meu laptop, a compila√ß√£o de depura√ß√£o limpa de nosso compilador leva 9,7 s, a vers√£o limpa 12,5 se a depura√ß√£o incremental compila 3,5 s.  Meu amigo n√£o tinha hor√°rios dispon√≠veis para sua compila√ß√£o C ++ (usando make paralelo), mas ele disse que os n√∫meros s√£o semelhantes, com a ressalva de que eles colocam implementa√ß√µes de muitas fun√ß√µes pequenas nos arquivos de cabe√ßalho para reduzir a duplica√ß√£o de assinaturas ao custo de um tempo mais longo (ou seja, portanto, n√£o consigo medir a sobrecarga da linha de rede nos arquivos de cabe√ßalho). <br><br><a name="4"></a><h1>  Python </h1><br>  Meu amigo, um bom programador, decidiu fazer o projeto sozinho em Python.  Ela tamb√©m implementou recursos mais avan√ßados (por divers√£o) do que qualquer outra equipe, incluindo uma vis√£o SSA intermedi√°ria com aloca√ß√£o de registros e outras otimiza√ß√µes.  Por outro lado, como funcionava sozinho e implementava muitas fun√ß√µes adicionais, prestava menos aten√ß√£o √† qualidade do c√≥digo, por exemplo, lan√ßando exce√ß√µes indiferenciadas para todos os erros (dependendo de backtraces para depura√ß√£o) em vez de implementar tipos de erro e mensagens correspondentes, como n√≥s <br><br>  Seu compilador consistia em 4581 linhas e passou em todos os testes p√∫blicos e secretos.  Ela tamb√©m implementou fun√ß√µes mais avan√ßadas do que qualquer outro comando, mas √© dif√≠cil determinar quanto c√≥digo extra foi necess√°rio, porque muitas das fun√ß√µes adicionais eram vers√µes mais poderosas de coisas simples que todos precisavam implementar, como dobrar constantes e gerar c√≥digo.  Fun√ß√µes adicionais s√£o provavelmente de 1000 a 2000 linhas, pelo menos, por isso tenho certeza de que o c√≥digo dela √© pelo menos duas vezes mais expressivo que o nosso. <br><br>  Uma grande parte dessa diferen√ßa √© provavelmente a digita√ß√£o din√¢mica.  Somente em nosso <code>ast.rs</code> 500 linhas de defini√ß√µes de tipos e muitos outros tipos definidos em outras partes do compilador.  Tamb√©m estamos sempre limitados ao pr√≥prio sistema de tipos.  Por exemplo, precisamos de uma infraestrutura para adicionar ergonomicamente novas informa√ß√µes ao AST √† medida que passamos e as acessamos mais tarde.  Enquanto estiver no Python, voc√™ pode apenas definir novos campos nos n√≥s AST. <br><br>  A metaprograma√ß√£o poderosa tamb√©m explica parte da diferen√ßa.  Por exemplo, embora ela tenha usado um analisador LR em vez de um m√©todo de descida recursiva, no meu caso, acho que foi necess√°rio menos c√≥digo porque, em vez de passar por uma reescrita em √°rvore, sua gram√°tica LR inclu√≠a partes do c√≥digo Python para criar o AST, que o gerador poderia transformar em fun√ß√µes Python usando <code>eval</code> .  Parte do motivo pelo qual n√£o usamos o analisador LR √© que a constru√ß√£o de um AST sem reescrever a √°rvore exigir√° muita cerim√¥nia (cria√ß√£o de arquivos Rust ou macros de procedimento) para associar a gram√°tica a fragmentos do c√≥digo Rust. <br><br>  Outro exemplo do poder da metaprograma√ß√£o e da digita√ß√£o din√¢mica √© o arquivo <code>visit.rs</code> 400 linhas, que √© basicamente um c√≥digo repetitivo que implementa um visitante em v√°rias estruturas AST.  No Python, isso pode ser uma fun√ß√£o curta de cerca de 10 linhas que introspecta recursivamente os campos de um n√≥ AST e os visita (usando o atributo <code>__dict__</code> ). <br><br>  Como um f√£ do Rust e das linguagens de tipo estaticamente em geral, estou inclinado a observar que o sistema de tipos √© muito √∫til para evitar erros e desempenho.  A metaprograma√ß√£o incomum tamb√©m pode dificultar a compreens√£o de como o c√≥digo funciona.  No entanto, essa compara√ß√£o me surpreendeu pelo fato de eu n√£o esperar que a diferen√ßa na quantidade de c√≥digo fosse t√£o grande.  Se a diferen√ßa como um todo est√° realmente perto de ter que escrever o dobro do c√≥digo, ainda acho que Rust √© um compromisso adequado, mas ainda assim metade do c√≥digo √© um argumento e, no futuro, tendem a fazer algo em Ruby / Python se voc√™ s√≥ precisa criar rapidamente algo sozinho e jog√°-lo fora. <br><br><a name="5"></a><h1>  Ferrugem (outro grupo) </h1><br>  A compara√ß√£o mais interessante para mim foi com meu amigo, que tamb√©m estava fazendo um projeto em Rust com um colega de equipe (que eu n√£o conhecia).  Meu amigo teve uma boa experi√™ncia de ferrugem.  Ele contribuiu para o desenvolvimento do compilador Rust e leu muito.  N√£o sei nada sobre o camarada dele. <br><br>  Seu projeto consistiu em 17.211 linhas brutas, 15k linhas de origem e 637 KB, sem incluir o c√≥digo de teste e o c√≥digo gerado.  N√£o possu√≠a fun√ß√µes adicionais e passou em apenas 4 dos 10 testes secretos e 90% dos testes p√∫blicos para gera√ß√£o de c√≥digo, porque eles n√£o tinham tempo suficiente antes do prazo para implementar partes mais bizarras da especifica√ß√£o.  O programa deles √© tr√™s vezes maior que o nosso, escrito no mesmo idioma e com menos funcionalidade! <br><br>  Esse resultado foi realmente incr√≠vel para mim e ofuscou todas as diferen√ßas entre os idiomas que estudei at√© agora.  Portanto, comparamos as listas de tamanhos de arquivo <code>wc -l</code> e tamb√©m verificamos como cada um de n√≥s implementou algumas coisas espec√≠ficas que resultaram em diferentes tamanhos de c√≥digo. <br><br>  Parece que tudo se resume √† ado√ß√£o consistente de v√°rias decis√µes de design.  Por exemplo, o front-end (an√°lise lexical, an√°lise, constru√ß√£o de AST) leva 7597 linhas contra o nosso 2164. Eles usaram o analisador lexical do DFA e o analisador LALR (1), mas outros grupos fizeram coisas semelhantes sem tanto c√≥digo.  Observando o arquivo weeder, notei v√°rias decis√µes de design diferentes das nossas: <br><br><ul><li>  Eles decidiram usar uma √°rvore de an√°lise totalmente digitada em vez de uma √°rvore de an√°lise padr√£o, uniforme e baseada em string.  Provavelmente, isso exigiu muito mais defini√ß√µes de tipo e c√≥digo de convers√£o adicional no est√°gio de an√°lise ou um analisador mais complexo. <br></li><li>  Eles usaram implementa√ß√µes tryfrom para converter entre analisar tipos de √°rvores e tipos AST para valid√°-los.  Isso leva a muitos blocos de <code>impl</code> 10 a 20 linhas.  Para isso, usamos fun√ß√µes que retornam tipos de <code>Result</code> , que geram menos linhas e tamb√©m nos libertam um pouco da estrutura de tipos, simplificando a parametriza√ß√£o e a reutiliza√ß√£o.  Algumas das coisas que, para n√≥s, eram ramifica√ß√µes de linha <code>match</code> , tinham blocos de <code>impl</code> 10 linhas. <br></li><li>  Nossos tipos s√£o estruturados para reduzir copiar e colar.  Por exemplo, eles usaram campos separados <code>is_abstract</code> , <code>is_native</code> e <code>is_static</code> , nos quais o c√≥digo de verifica√ß√£o de restri√ß√£o teve que ser copiado duas vezes: uma para m√©todos com tipo de vazio e outra para m√©todos com tipo de retorno, com pequenas modifica√ß√µes.  Embora nosso <code>void</code> fosse apenas um tipo especial, criamos uma taxonomia de modificadores com <code>mode</code> e <code>visibility</code> que aplicavam restri√ß√µes no n√≠vel de tipo e erros de restri√ß√£o eram gerados por padr√£o para o operador de correspond√™ncia, que convertia os conjuntos de modificadores em <code>mode</code> e <code>visibility</code> . </li></ul><br>  Eu n√£o olhei para o c√≥digo das passagens da an√°lise do compilador, mas elas tamb√©m s√£o √≥timas.  Conversei com meu amigo e parece que eles n√£o implementaram nada parecido com a infraestrutura dos visitantes, como a nossa.  Eu acho que, junto com outras diferen√ßas menores de design, explica a diferen√ßa de tamanho desta parte.  O visitante permite que nossas passagens de an√°lise se concentrem apenas nas partes do AST necess√°rias, em vez de corresponderem ao padr√£o em toda a estrutura do AST.  Isso economiza muito c√≥digo. <br><br>  A parte deles para a gera√ß√£o de c√≥digo consiste em 3594 linhas, e a nossa - 1560. Olhei para o c√≥digo e parece que quase toda a diferen√ßa √© que eles escolheram uma estrutura de dados intermedi√°ria para instru√ß√µes do assembler, onde usamos apenas a formata√ß√£o de string para sa√≠da direta do assembler .  Eles tiveram que definir tipos e fun√ß√µes de sa√≠da para todas as instru√ß√µes e tipos de operandos usados.  Isso tamb√©m significava que as instru√ß√µes de montagem da constru√ß√£o exigiam mais c√≥digo.  Onde t√≠nhamos um operador de formato com instru√ß√µes curtas, como <code>mov ecx, [edx]</code> , eles precisavam de um operador <code>rustfmt</code> gigante, dividido em 6 linhas, que constru√≠ram uma instru√ß√£o com <code>rustfmt</code> tipos aninhados intermedi√°rios para operandos que incluem at√© 6 n√≠veis de colchetes aninhados.  Tamb√©m poder√≠amos emitir blocos de instru√ß√µes relacionadas, como um pre√¢mbulo de fun√ß√£o, em uma instru√ß√£o de formato √∫nico, onde eles precisavam especificar a constru√ß√£o completa para cada instru√ß√£o. <br><br>  Nossa equipe estava pensando em usar uma abstra√ß√£o como a deles.  Era mais f√°cil ser capaz de produzir uma montagem de texto ou emitir diretamente o c√≥digo da m√°quina, mas isso n√£o era um requisito do curso.  O mesmo poderia ser feito com menos c√≥digo e melhor desempenho usando a <code>X86Writer</code> X86Writer com m√©todos como <code>push(reg: Register)</code> .  Tamb√©m levamos em conta que isso poderia simplificar a depura√ß√£o e o teste, mas percebemos que a visualiza√ß√£o do assembler de texto gerado √© realmente mais f√°cil de ler e testar usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">snapshot testing</a> se voc√™ inserir coment√°rios livremente.  Mas n√≥s (aparentemente corretamente) previmos que seria necess√°rio muito c√≥digo adicional, e n√£o havia nenhum benef√≠cio real, dadas as nossas reais necessidades, portanto n√£o nos preocupamos. <br><br>  √â bom comparar isso com a representa√ß√£o intermedi√°ria que a equipe de C ++ usou como uma fun√ß√£o extra, o que levou apenas 500 linhas extras.  Eles usaram uma estrutura muito simples (para defini√ß√µes simples de tipo e c√≥digo de constru√ß√£o) que usava opera√ß√µes pr√≥ximas ao que o Java exigia.  Isso significava que sua representa√ß√£o intermedi√°ria era muito menor (e, portanto, exigia menos c√≥digo de constru√ß√£o) do que o assembler resultante, uma vez que muitas opera√ß√µes de linguagem, como chamadas e convers√µes, foram expandidas em muitas instru√ß√µes do assembler.  Eles tamb√©m dizem que isso realmente ajudou na depura√ß√£o, pois eliminou muito lixo e melhorou a legibilidade.  Uma apresenta√ß√£o de n√≠vel superior tamb√©m permitiu que algumas otimiza√ß√µes simples fossem feitas em sua representa√ß√£o intermedi√°ria.  A equipe do C ++ criou um design muito bom, que os fez muito mais bem com muito menos c√≥digo. <br><br>  Em geral, parece que o motivo comum para a tr√≠plice diferen√ßa de volume se deve √† ado√ß√£o consistente de v√°rias decis√µes de design, grandes e pequenas, na dire√ß√£o de mais c√≥digo.  Eles implementaram uma s√©rie de abstra√ß√µes que n√≥s n√£o fizemos - adicionaram mais c√≥digo e pularam algumas de nossas abstra√ß√µes, o que reduz a quantidade de c√≥digo. <br><br>  Esse resultado realmente me surpreendeu.  Eu sabia que as decis√µes de design s√£o importantes, mas n√£o teria adivinhado antecipadamente que elas levariam a diferen√ßas desse tamanho, uma vez que s√≥ examinava pessoas que considero fortes programadores competentes.  De todos os resultados da compara√ß√£o, este √© o mais significativo para mim.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provavelmente me ajudou a ler muito sobre como escrever compiladores antes de fazer este curso, para que eu pudesse usar projetos inteligentes que outras pessoas criaram e descobriram que funcionam bem, como visitantes do AST e o m√©todo de descida recursiva, embora n√£o tenham sido ensinados no nosso curso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que realmente me fez pensar √© o custo da abstra√ß√£o. As abstra√ß√µes podem facilitar a expans√£o futura ou proteger contra alguns tipos de erros, mas precisam ser levadas em considera√ß√£o, pois voc√™ pode obter tr√™s vezes mais c√≥digo para entender e refatorar, tr√™s vezes mais lugares poss√≠veis para erros e menos tempo para testes e mais desenvolvimento. Nosso curso de treinamento foi diferente do mundo real: sab√≠amos com certeza que nunca tocar√≠amos no c√≥digo ap√≥s o desenvolvimento, isso elimina os benef√≠cios da abstra√ß√£o proativa. No entanto, se eu tivesse que escolher qual compilador estender com uma fun√ß√£o arbitr√°ria que voc√™ dir√° mais adiante, eu escolheria a nossa, mesmo sem considerar minha familiaridade com ela. S√≥ porque ele tem muito menos c√≥digo para entender e eu poderia escolher a melhor abstra√ß√£o para os requisitos (por exemplo,representa√ß√£o intermedi√°ria do comando C ++) quando conhe√ßo os requisitos espec√≠ficos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al√©m disso, na minha opini√£o, a taxonomia das abstra√ß√µes foi refor√ßada: existem aquelas que reduzem o c√≥digo, levando em conta apenas os requisitos atuais, como nosso modelo de visitante, e h√° abstra√ß√µes que adicionam c√≥digo, mas fornecem os benef√≠cios de extensibilidade, depura√ß√£o ou corre√ß√£o. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m conversei com um amigo que fez um projeto no Scala no semestre anterior, mas o projeto e os testes foram exatamente os mesmos. </font><font style="vertical-align: inherit;">O compilador consistia em 4141 linhas e ~ 160 KB de c√≥digo, sem contar os testes. </font><font style="vertical-align: inherit;">Eles passaram em 8 dos 10 testes secretos e 100% de testes abertos e n√£o implementaram nenhuma fun√ß√£o adicional. </font><font style="vertical-align: inherit;">Assim, comparado √†s nossas linhas 5906 sem fun√ß√µes e testes adicionais, o compilador √© 30% menor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dos pequenos fatores de design foi uma abordagem diferente para a an√°lise. O curso permitiu o uso de uma ferramenta de linha de comando para o gerador de tabelas LR. Ningu√©m o usou, exceto esse time. Isso os impediu de implementar o gerador de tabelas LR. Eles tamb√©m conseguiram evitar escrever gram√°tica LR com um script Python de 150 linhas que rasparam a p√°gina da gram√°tica Java encontrada na Internet e a traduziram para o formato de entrada do gerador. Eles ainda precisavam fazer algum tipo de √°rvore em Scala, mas, em geral, o est√°gio de an√°lise chegou a 1073 linhas em compara√ß√£o com o nosso 1443, embora nosso m√©todo de descida por gradiente aqui desse uma vantagem em volume em compara√ß√£o com todas as outras equipes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O restante do compilador tamb√©m era menor que o nosso, sem grandes diferen√ßas √≥bvias de design, embora eu n√£o tenha me aprofundado no c√≥digo. </font><font style="vertical-align: inherit;">Suspeito que isso se deva a diferen√ßas na expressividade de Scala e Rust. </font><font style="vertical-align: inherit;">Scala e Rust t√™m recursos de programa√ß√£o semelhantes √∫teis para compiladores, como correspond√™ncia de padr√µes, mas a mem√≥ria gerenciada do Scala salva o c√≥digo necess√°rio para que o verificador de empr√©stimo trabalhe no Rust. </font><font style="vertical-align: inherit;">Al√©m disso, Scala tem um a√ß√∫car sint√°tico mais variado que o Rust.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OCaml </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todos os membros de nossa equipe passam por um est√°gio na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jane Street</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (empresa de com√©rcio de tecnologia - aprox. Por.), Fiquei especialmente interessado em ver o resultado de outros ex-estagi√°rios da Jane Street que escolheram o OCaml para escrever o compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O compilador era de 10.914 linhas e 377 KB, incluindo uma pequena quantidade de c√≥digo de teste e nenhum recurso adicional. Eles passaram em 9/10 testes secretos e todos os testes p√∫blicos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como outros grupos, parece que a principal diferen√ßa de tamanho se deve ao uso do analisador LR e da reescrita em √°rvore para an√°lise, bem como do pipeline de convers√£o regex-&gt; NFA-&gt; DFA para an√°lise lexical. O front-end (an√°lise lexical, an√°lise, constru√ß√£o AST) √© de 5548 linhas e o nosso - 2164, com propor√ß√µes semelhantes para bytes. Eles tamb√©m usaram </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para seu analisador, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">com a expectativa de</font></a><font style="vertical-align: inherit;"> que ele fosse semelhante aos nossos testes de instant√¢neo, que colocam a sa√≠da esperada fora do c√≥digo; portanto, seus testes de analisador fizeram ~ 600 linhas do total e a nossa - cerca de 200.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso deixa 5366 linhas para o restante do compilador (461 linhas s√£o arquivos de interface com declara√ß√µes de tipo) e 4642 para n√≥s, a diferen√ßa √© de apenas 15%, se contarmos seus arquivos de interface e quase o mesmo tamanho, se n√£o contar. </font><font style="vertical-align: inherit;">Parece que, al√©m de nossas solu√ß√µes de design de an√°lise, Rust e OCaml parecem igualmente expressivos, exceto que o OCaml precisa de arquivos front-end e o Rust n√£o.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclus√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, estou muito feliz por ter feito essa compara√ß√£o, aprendi muito e fiquei surpreso v√°rias vezes. </font><font style="vertical-align: inherit;">Penso que a conclus√£o geral √© que as decis√µes de design s√£o muito mais importantes que a linguagem, mas a linguagem √© importante porque fornece ferramentas para a implementa√ß√£o de projetos diferentes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456638/">https://habr.com/ru/post/pt456638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456622/index.html">Como criar um sistema operacional certificado de acordo com a prote√ß√£o classe I</a></li>
<li><a href="../pt456624/index.html">Ferramentas √∫teis em Python</a></li>
<li><a href="../pt456630/index.html">Introdu√ß√£o ao Airflow para gerenciar Spark Jobs no ivi: esperan√ßas e muletas</a></li>
<li><a href="../pt456632/index.html">Estamos construindo o quarto andar de modelos C ++ no RESTinio. Por que e como?</a></li>
<li><a href="../pt456634/index.html">Receitas Nginx: CAS (Servi√ßo Central de Autoriza√ß√£o)</a></li>
<li><a href="../pt456640/index.html">An√°lise do concurso de intelig√™ncia competitiva no PHDays 9</a></li>
<li><a href="../pt456642/index.html">A primeira gradua√ß√£o do programa de mestrado JetBrains Corporate e da Universidade ITMO</a></li>
<li><a href="../pt456644/index.html">Impressora fotopol√≠mero 3D de baixo custo e mais longa aparece no Kickstarter</a></li>
<li><a href="../pt456646/index.html">Indulg√™ncia - como se livrar da d√≠vida para tarefas</a></li>
<li><a href="../pt456650/index.html">Escolhendo um oscilosc√≥pio de bolso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>