<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😜 👨‍🚀 😞 Chromium不仅是浏览器，而且还是一个很好的框架 🥇 💯 🕒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大多数人已经习惯了Chromium既是浏览器又是其他浏览器的基础的事实。 直到最近，我也这样认为，但是，研究了这个主题几个月之后，我开始发现另一个奇妙的世界。 铬是一个巨大的生态系统，其中包含所有内容：依赖系统，跨平台构建系统以及几乎所有情况下的组件。 那么，为什么不尝试使用所有这些功能来创建自己的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chromium不仅是浏览器，而且还是一个很好的框架</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/455956/"><img src="https://habrastorage.org/webt/ue/ye/xv/ueyexvk-uewnyghxhvtud7vugrq.jpeg"><br><br> 大多数人已经习惯了Chromium既是浏览器又是其他浏览器的基础的事实。 直到最近，我也这样认为，但是，研究了这个主题几个月之后，我开始发现另一个奇妙的世界。 铬是一个巨大的生态系统，其中包含所有内容：依赖系统，跨平台构建系统以及几乎所有情况下的组件。 那么，为什么不尝试使用所有这些功能来创建自己的应用程序呢？ <br><br> 在Kat之下，有一个有关如何开始执行此操作的小指南。 <br><a name="habracut"></a><br><h2> 环境准备 </h2><br> 在我将使用Ubuntu 18.04的文章中，可以在文档中找到其他操作系统的过程： <br><br><ul><li>  <a href="">的Linux</a> <br></li><li>  <a href="">窗户</a> <br></li><li>  <a href="">Mac电脑</a> <br></li></ul><br> 以下步骤需要Git和Python。 如果尚未安装，则必须使用以下命令安装它们： <br><br><pre><code class="bash hljs">sudo apt install git python</code> </pre> <br><h3> 设置depot_tools </h3><br>  <code>depot_tools</code>是Chromium开发工具箱。 要安装它，您必须执行以下操作： <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</code> </pre> <br> 并将路径添加到PATH环境变量中： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH</span></span></span><span class="hljs-string">:/path/to/depot_tools"</span></span></code> </pre> <br> 重要：如果将<code>depot_tools</code>下载到您的主文件夹中，请不要在<code>PATH</code>变量中使用<code>~</code> ，否则可能会出现问题。 您必须使用<code>$HOME</code>变量： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${HOME}</span></span></span><span class="hljs-string">/depot_tools"</span></span></code> </pre> <br><h3> 代码检索 </h3><br> 首先，您需要为源创建一个文件夹。 例如，在主目录中（大约需要30 GB的可用空间）： <br><br><pre> <code class="bash hljs">mkdir ~/chromium &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/chromium</code> </pre> <br> 之后，您可以使用来自<code>depot_tools</code>的<code>fetch</code>实用程序下载源： <br><br><pre> <code class="bash hljs">fetch --nohooks --no-history chromium</code> </pre> <br> 现在，您可以去喝茶/咖啡，因为操作过程并不很快。 对于实验，不需要历史记录，因此使用<code>--no-history</code>标志。 故事会更长。 <br><br><h3> 依赖安装 </h3><br> 所有源都在<code>src</code>文件夹中，请转到它： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> src</code> </pre> <br> 现在，您需要使用脚本放置所有依赖项： <br><br><pre> <code class="bash hljs">./build/install-build-deps.sh</code> </pre> <br> 并运行钩子： <br><br><pre> <code class="bash hljs">gclient runhooks</code> </pre> <br> 这样就完成了环境的准备。 <br><br><h2> 建立系统 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ninja被</a>用作Chromium的主要装配系统， <a href="">GN</a>实用程序用于生成<code>.ninja</code>文件。 <br><br> 为了了解如何使用这些工具，我建议创建一个测试实用程序示例。 为此，请在<code>src</code>文件夹中创建一个<code>example</code>子文件夹： <br><br><pre> <code class="bash hljs">mkdir example</code> </pre> <br> 然后，在<code>src/example</code>文件夹中，创建<code>BUILD.gn</code>文件，其中包含： <br><br><pre> <code class="cpp hljs">executable(<span class="hljs-string"><span class="hljs-string">"example"</span></span>) { sources = [ <span class="hljs-string"><span class="hljs-string">"example.cc"</span></span>, ] }</code> </pre> <br>  <code>BUILD.gn</code>由目标（可执行文件<code>example</code> ）和构建目标所需的文件列表组成。 <br><br> 下一步是创建<code>example.cc</code>文件本身。 首先，我建议制作一个经典的应用程序“ Hello world”： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main(int argc, char **argv) { std::cout &lt;&lt; "Hello world" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br> 源代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 为了使GN了解新项目，请在<code>src</code>中的<code>BUILD.gn</code>文件中，在<code>deps</code>部分中添加<code>"//example"</code>行： <br><br><pre> <code class="cpp hljs">... group(<span class="hljs-string"><span class="hljs-string">"gn_all"</span></span>) { testonly = <span class="hljs-literal"><span class="hljs-literal">true</span></span> deps = [ <span class="hljs-string"><span class="hljs-string">":gn_visibility"</span></span>, <span class="hljs-string"><span class="hljs-string">"//base:base_perftests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//base:base_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//base/util:base_util_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//chrome/installer"</span></span>, <span class="hljs-string"><span class="hljs-string">"//chrome/updater"</span></span>, <span class="hljs-string"><span class="hljs-string">"//net:net_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//services:services_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//services/service_manager/public/cpp"</span></span>, <span class="hljs-string"><span class="hljs-string">"//skia:skia_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//sql:sql_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//third_party/flatbuffers:flatbuffers_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//tools/binary_size:binary_size_trybot_py"</span></span>, <span class="hljs-string"><span class="hljs-string">"//tools/ipc_fuzzer:ipc_fuzzer_all"</span></span>, <span class="hljs-string"><span class="hljs-string">"//tools/metrics:metrics_metadata"</span></span>, <span class="hljs-string"><span class="hljs-string">"//ui/base:ui_base_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//ui/gfx:gfx_unittests"</span></span>, <span class="hljs-string"><span class="hljs-string">"//url:url_unittests"</span></span>, # ↓↓↓↓↓↓↓↓ <span class="hljs-string"><span class="hljs-string">"//example"</span></span>, ] ...</code> </pre> <br> 现在，您需要返回到<code>src</code>文件夹并使用以下命令生成项目： <br><br><pre> <code class="bash hljs">gn gen out/Default</code> </pre> <br>  GN还允许您为受支持的IDE之一准备项目： <br><br><ul><li> 蚀 <br></li><li> 与 <br></li><li>  vs2013 <br></li><li>  vs2015 <br></li><li>  vs2017 <br></li><li>  vs2019 <br></li><li>  Xcode的 <br></li><li>  qtcreator <br></li><li>  json <br></li></ul><br> 可以使用以下命令获取更多信息： <br><br><pre> <code class="bash hljs">gn <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> gen</code> </pre> <br> 例如，要在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QtCreator中</a>使用<code>example</code>项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>您需要运行以下命令： <br><br><pre> <code class="bash hljs">gn gen --ide=qtcreator --root-target=example out/Default</code> </pre> <br> 之后，您可以在QtCreator中打开项目： <br><br><pre> <code class="bash hljs">qtcreator out/Default/qtcreator_project/all.creator</code> </pre> <br> 最后一步是使用Ninja构建项目： <br><br><pre> <code class="bash hljs">autoninja -C out/Default example</code> </pre> <br> 组装系统的简要介绍可以完成。 <br><br> 可以使用以下命令启动该应用程序： <br><br><pre> <code class="bash hljs">./out/Default/example</code> </pre> <br> 并查看Hello world。 实际上，您可以撰写有关Chromium中装配系统的另一篇文章。 也许不是一个。 <br><br><h2> 使用命令行 </h2><br> 作为使用Chromium代码库作为框架的第一个示例，我建议使用命令行。 <br><br> 任务： <i>以Chromium样式显示传递给应用程序的所有参数。</i> <br> 要使用命令行，需要在example.cc中包含头文件： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include "base/command_line.h"</span></span></code> </pre> <br> 同样，我们也不要忘记在<code>BUILD.gn</code>添加对<code>base</code>项目的<code>BUILD.gn</code> 。  <code>BUILD.gn</code>应该看起来像这样： <br><br><pre> <code class="cpp hljs">executable(<span class="hljs-string"><span class="hljs-string">"example"</span></span>) { sources = [ <span class="hljs-string"><span class="hljs-string">"example.cc"</span></span>, ] deps = [ <span class="hljs-string"><span class="hljs-string">"//base"</span></span>, ] }</code> </pre> <br> 现在，您需要的所有内容都将连接到<code>example</code> 。 <br><br> 为了使用命令行，Chromium提供了一个单例<code>base::CommandLine</code> 。 要获得链接，您需要使用静态方法<code>base::CommandLine::ForCurrentProcess</code> ，但是首先您需要使用<code>base::CommandLine::Init</code>方法对其进行<code>base::CommandLine::Init</code> ： <br><br><pre> <code class="cpp hljs">base::CommandLine::Init(argc, argv); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *cmd_line = base::CommandLine::ForCurrentProcess();</code> </pre> <br> 使用<code>GetSwitches</code>方法将在命令行<code>GetSwitches</code>应用程序并以<code>-</code>开头的所有参数作为<code>base::SwitchMap</code> （本质<code>map&lt;string, string&gt;</code>是<code>map&lt;string, string&gt;</code> ） <code>GetSwitches</code> 。 所有其他参数都以<code>base::StringVector</code> （本质上是<code>vectr&lt;strig&gt;</code> ）返回。 这些知识足以实现该任务的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;sw : cmd_line-&gt;GetSwitches()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Switch "</span></span> &lt;&lt; sw.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; sw.second &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;arg: cmd_line-&gt;GetArgs()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Arg "</span></span> &lt;&lt; arg &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br> 完整版本可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 要构建和运行该应用程序，您需要运行： <br><br><pre> <code class="bash hljs">autoninja -C out/Default example ./out/Default/example arg1 --sw1=val1 --sw2 arg2</code> </pre> <br> 屏幕将显示： <br><br><pre> <code class="bash hljs">Switch sw1: val1 Switch sw2: Arg arg1 Arg arg2</code> </pre> <br><h2> 联网 </h2><br> 作为今天的第二个也是最后一个示例，我建议使用Chromium的网络部分。 <br><br> 任务： <i>显示作为参数传递的URL的内容</i> 。 <br><br><h3> 铬网络子系统 </h3><br> 网络子系统非常大且复杂。 对HTTP，HTTPS，FTP和其他数据资源的请求的入口点是<code>URLRequest</code> ，它已经确定了要使用哪个客户端。 简化图如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d6/b9f/e45/7d6b9fe45ac8c5a47d51e4522735e5eb.png"><br><br>  <i>完整版本可以在<a href="">文档中</a>找到。</i> <br><br> 要创建<code>URLRequest</code>必须使用<code>URLRequestContext</code> 。 创建上下文是一个相当复杂的操作，因此建议使用<code>URLRequestContextBuilder</code> 。 它将使用默认值初始化所有必需的变量，但是，如果需要，可以将它们更改为自己的变量，例如： <br><br><pre> <code class="cpp hljs">net::URLRequestContextBuilder context_builder; context_builder.DisableHttpCache(); context_builder.SetSpdyAndQuicEnabled(<span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">/* http2 */</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">/* quic */</span></span>); context_builder.SetCookieStore(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>);</code> </pre> <br><h3> 多线程 </h3><br>  Chromium网络堆栈旨在在多线程环境中工作，因此您不能跳过本主题。 在Chromium中使用多线程的基本对象是： <br><br><ul><li>  Task-要执行的任务，在Chromium中是<code>base::Callback</code>类型的函数，可以使用<code>base::Bind</code>创建。 <br></li><li> 任务队列-要执行的任务队列。 <br></li><li> 物理线程-操作系统线程（POSIX上的<code>pthread</code>或Windows上的<code>CreateThread()</code>上的跨平台包装器。 在<code>base::PlatformThread</code>类中实现，请勿直接使用。 <br></li><li>  base :: Thread-一个真正的线程，它不断地处理来自专用任务队列的消息； 不建议直接创建它们。 <br></li><li> 线程池-具有公共任务队列的线程池。 在<code>base::ThreadPool</code>类中实现。 通常，创建一个实例。 使用<code>base/task/post_task.h</code>函数将任务发送给它。 <br></li><li> 序列或虚拟线程-使用实际线程并可以在它们之间切换的虚拟线程。 <br></li><li> 任务运行器-用于设置任务的接口，在<code>base::TaskRunner</code> 。 <br></li><li> 顺序任务运行程序-用于设置任务的界面，可确保任务按照到达时的顺序执行。 在<code>base::SequencedTaskRunner</code>类中实现。 <br></li><li> 单线程任务运行程序-与上一个任务运行程序相似，但保证所有任务将在一个OS线程中执行。 在<code>base::SingleThreadTaskRunner</code> 。 <br></li></ul><br><h3> 实作 </h3><br> 某些Chromium组件要求存在<code>base::AtExitManager</code>这是一个类，允许您注册在应用程序终止时必须执行的操作。 使用它非常简单，您需要在堆栈上创建一个对象： <br><br><pre> <code class="cpp hljs">base::AtExitManager exit_manager;</code> </pre> <br> 当<code>exit_manager</code>超出范围时，将执行所有已注册的回调。 <br><br> 现在，您需要注意网络子系统所有必需的多线程组件的可用性。 为此，创建一个<code>Thread pool</code> ，类型为<code>TYPE_IO</code> <code>Message loop</code> （用于处理网络消息）和<code>Run loop</code> （主程序循环）： <br><br><pre> <code class="cpp hljs">base::ThreadPool::CreateAndStartWithDefaultParams(<span class="hljs-string"><span class="hljs-string">"downloader"</span></span>); base::<span class="hljs-function"><span class="hljs-function">MessageLoop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base::MessageLoop::TYPE_IO)</span></span></span></span>; base::RunLoop run_loop;</code> </pre> <br> 接下来，使用<code>Context builder</code>创建一个<code>Context</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = net::URLRequestContextBuilder().Build();</code> </pre> <br> 要发送请求，必须使用<code>ctx</code>对象的<code>CreateRequest</code>方法创建<code>URLRequest</code>对象。 传递了以下参数： <br><br><ul><li>  URL，类型为GURL的字符串； <br></li><li> 优先权 <br></li><li> 处理事件的委托。 <br></li></ul><br> 委托是实现<code>net::URLRequest::Delegate</code>接口的类。 对于此任务，它可能看起来像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDelegate</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> net::URLRequest::Delegate { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base::Closure quit_closure)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quit_closure_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(quit_closure))</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buf_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base::MakeRefCounted&lt;net::IOBuffer&gt;(BUF_SZ))</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReceivedRedirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest *request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net::RedirectInfo &amp;redirect_info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *defer_redirect)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"redirect to "</span></span> &lt;&lt; redirect_info.new_url &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAuthRequired</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest* request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net::AuthChallengeInfo&amp; auth_info)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"auth req"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCertificateRequested</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest *request, net::SSLCertRequestInfo *cert_request_info)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cert req"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSSLCertificateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest* request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net_error, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net::SSLInfo&amp; ssl_info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fatal)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cert err"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnResponseStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest *request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> net_error)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"resp started"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> n = request-&gt;Read(buf_.get(), BUF_SZ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"resp read "</span></span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == net::ERR_IO_PENDING) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnReadCompleted(request, n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(buf_-&gt;data(), n) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReadCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(net::URLRequest *request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes_read)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"completed"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; quit_closure_.Run(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: base::Closure quit_closure_; scoped_refptr&lt;net::IOBuffer&gt; buf_; };</code> </pre> <br> 所有主要逻辑都在<code>OnResponseStarted</code>事件<code>OnResponseStarted</code> ：减去响应的内容，直到发生错误或没有要读取的内容为止。 由于读取响应后，您需要完成应用程序，因此委托人必须有权访问将中断主<code>Run loop</code>的函数，在这种情况下，将使用<code>base::Closure</code>类型的回调。 <br><br> 现在一切就绪，可以发送请求了： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MyDelegate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(run_loop.QuitClosure())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req = ctx-&gt;CreateRequest(GURL(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]), net::RequestPriority::DEFAULT_PRIORITY, &amp;delegate); req-&gt;Start();</code> </pre> <br> 为了开始处理请求，您需要运行<code>Run loop</code> ： <br><br><pre> <code class="cpp hljs">run_loop.Run();</code> </pre> <br> 完整版本可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 要构建和运行该应用程序，您需要运行： <br><br><pre> <code class="bash hljs">autoninja -C out/Default example out/Default/example <span class="hljs-string"><span class="hljs-string">"https://example.com/"</span></span></code> </pre> <br><h2> 决赛 </h2><br> 实际上，在Chromium中，您可以找到许多有用的多维数据集和积木，您可以从中构建应用程序。 它在不断发展，一方面是一个优点，另一方面，对API进行定期更改不会让您放松。 例如，在最新版本中，幸运的是将<code>base::TaskScheduler</code>更改为<code>base::ThreadPool</code> ，而无需更改API。 <br><br>  PS我们正在寻找我们团队中领先的C ++程序员！ 如果您感到自己有力量，那么我们在这里描述了我们的愿望： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">team.mail.ru/vacancy/4641/</a> 。 还有一个“响应”按钮。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455956/">https://habr.com/ru/post/zh-CN455956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455944/index.html">与自由职业者一起工作。 学习四处走动</a></li>
<li><a href="../zh-CN455946/index.html">Google Play上的禁止内容-生存任务</a></li>
<li><a href="../zh-CN455948/index.html">RAMBleed：在34小时内检索RSA密钥</a></li>
<li><a href="../zh-CN455950/index.html">最稀有和最昂贵的编程语言。 第二部分</a></li>
<li><a href="../zh-CN455952/index.html">Roslyn的代码生成</a></li>
<li><a href="../zh-CN455958/index.html">不断发展的细胞自动机</a></li>
<li><a href="../zh-CN455960/index.html">开发人员离开的原因：8个原因</a></li>
<li><a href="../zh-CN455962/index.html">数据科学与热带会议</a></li>
<li><a href="../zh-CN455966/index.html">英国排名前五的移动应用开发公司</a></li>
<li><a href="../zh-CN455968/index.html">我用25万卢布（1个零件）在太阳能电池板上做一个半齿轮</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>