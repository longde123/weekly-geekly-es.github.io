<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàöÔ∏è ‚õ≥Ô∏è ü•© Kubernetes Containerd-Integration ersetzt Docker f√ºr die Produktion üïé üëµüèæ üìï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Wir haben mehr als einmal √ºber Containerd und andere Laufzeiten f√ºr Kubernetes geschrieben. Die neue Ver√∂ffentlichung ist eine √úberse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Containerd-Integration ersetzt Docker f√ºr die Produktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/414875/"><img src="https://habrastorage.org/webt/bw/-e/lu/bw-elulxcq_ts7y7ln0cjnwyxng.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Wir haben mehr als einmal √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Containerd</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> Laufzeiten f√ºr Kubernetes geschrieben.</i>  <i>Die neue Ver√∂ffentlichung ist eine √úbersetzung der j√ºngsten Ank√ºndigung eines wichtigen Meilensteins in der Entwicklung von Containerd, die im offiziellen Blog des Kubernetes-Projekts ver√∂ffentlicht wurde.</i>  <i>Der Text wurde von Mitarbeitern von Google und IBM verfasst, die (nat√ºrlich zusammen mit Docker Inc) erheblich zur Verbesserung von Containerd beitragen.</i> <br><br>  Zu Beginn des Blogs haben wir in der Notiz " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Containerd bringt mehr Container-Laufzeitoptionen f√ºr Kubernetes"</a> eine Alpha-Version der Integration von Containerd in Kubernetes vorgestellt.  Die n√§chsten 6 Monate der Entwicklung f√ºhrten dazu, dass die Integration √∂ffentlich verf√ºgbar wurde!  Dies bedeutet, dass Sie jetzt <a href="">Containerd 1.1</a> als Laufzeit f√ºr Container in Kubernetes-Clustern in der Produktion verwenden k√∂nnen. <br><br>  Containerd 1.1 funktioniert mit Kubernetes Version 1.10 und h√∂her und unterst√ºtzt alle Kubernetes-Funktionen.  In der Kubernetes-Testinfrastruktur entspricht die Abdeckung von Containerd-Integrationstests auf der Google Cloud Platform der Integration mit Docker (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test-Dashboard</a> ). <a name="habracut"></a><br><br><blockquote>  ‚ÄûWir freuen uns, dass Containerd diesen wichtigen Meilenstein schnell erreicht.  Bei Alibaba Cloud haben wir von Anfang an begonnen, Containerd aktiv einzusetzen, und dank seiner Betonung auf Einfachheit und Zuverl√§ssigkeit wurde Containerd zur Standard-Container-Engine in seinem Produkt Serverless Kubernetes, das hohe Anforderungen an Leistung und Stabilit√§t stellt.  Containerd wird zweifellos der Hauptmotor der Container-√Ñra sein und zur Entwicklung von Innovationen f√ºhren. ‚Äú  <i>- Xinwei, ein Vollzeitingenieur von Alibaba Cloud</i> </blockquote><br><h2>  Architektonische Verbesserungen </h2><br>  Die Architektur f√ºr die Integration von Containerd in Kubernetes wurde zweimal ge√§ndert.  Jeder seiner Evolutionsschritte stabilisierte und verbesserte die Effizienz des Stapels. <br><br><h3>  Containerd 1.0 - CRI-Containerd (nicht mehr vorhanden) </h3><br><img src="https://habrastorage.org/webt/8q/n4/2o/8qn42ofstq8qrrucp5txrrb2wze.png"><br><br>  In Containerd 1.0 wurde der Cri-Containerd-Daemon f√ºr die Interaktion zwischen <i>Kubelet</i> und Containerd ben√∂tigt <i>(wir haben dar√ºber am Ende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Artikels geschrieben</a> - <b>ca. Transl.</b> )</i> .  Dieser Daemon hat Anforderungen an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container Runtime Interface (CRI)</a> von <i>Kubelet bereitgestellt</i> und Containerd verwendet, um Container und Container-Images ordnungsgem√§√ü zu verwalten.  Dieser Ansatz eliminierte eine zus√§tzliche Verkn√ºpfung im Stapel im Vergleich zur Docker CRI-Implementierung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockershim</a> ) - <i>siehe Abbildung oben</i> . <br><br>  Cri-Containerd und Containerd 1.0 waren jedoch zwei separate D√§monen, die √ºber GRPC interagierten.  Ein zus√§tzlicher Daemon in diesem Bundle erschwerte den Benutzern das Verst√§ndnis des Ger√§ts und der Bereitstellung und verursachte unn√∂tigen Overhead f√ºr die Interaktion. <br><br><h3>  Containerd 1.1 - CRI Plugin (aktuelle Version) </h3><br><img src="https://habrastorage.org/webt/sc/hl/uw/schluwslee8y_n4kihjgseh0kpw.png"><br><br>  In Containerd 1.1 wurde der Cri-Containerd-Daemon in das Containerd-CRI-Plugin √ºbernommen.  Dieses Plugin ist in Containerd 1.1 integriert und standardm√§√üig aktiviert.  Im Gegensatz zu Cri-Containerd interagiert das Plugin mit Containerd, indem es die erforderlichen Funktionen direkt aufruft.  Die neue Architektur hat die Integration stabiler und produktiver gemacht und eine weitere Verbindung (GRPC) aus dem Stapel entfernt.  Jetzt kann Containerd 1.1 direkt in Kubernetes verwendet werden, und der Cri-Containerd-Daemon wird nicht mehr ben√∂tigt. <br><br><h2>  Leistung </h2><br>  Eines der Hauptziele von Containerd 1.1 war die Verbesserung der Leistung.  Optimierungen wurden im Bereich der Startzeit und der vom D√§mon verwendeten Ressourcen durchgef√ºhrt. <br><br>  Die folgenden Ergebnisse sind ein Vergleich von Containerd 1.1 und Docker 18.03 CE.  Integration Containerd 1.1 verwendet das integrierte CRI-Plugin, und die Integration f√ºr Docker 18.03 CE funktioniert mit Dockershim.  Die Ergebnisse wurden mithilfe des Kubernetes- <a href="">Knotenleistungs-</a> Benchmarks generiert, der Teil der <a href="">e2e-Tests f√ºr K8s-Knoten ist</a> .  Die meisten Vergleichsdaten sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node Performance Dashboard</a> √∂ffentlich verf√ºgbar. <br><br><h3>  Verz√∂gerung des Herdstarts </h3><br>  Die Ergebnisse des <i>105-Pod-Batch-Startbenchmarks</i> zeigen, dass die Integration von Containerd 1.1 beim Starten des Pods weniger Verz√∂gerungen aufweist als Docker 18.03 CE mit Dockershim (je kleiner desto besser). <br><br><img src="https://habrastorage.org/webt/1e/20/re/1e20rewi6uzg9ixrkmfsybifidk.png"><br><br><h3>  CPU und Speicher </h3><br>  Im Leerlauf verbraucht die Integration von Containerd 1.1 mit 105 Herden weniger Prozessor und Speicher als die Integration von Docker 18.03 CE mit Dockershim.  Die Ergebnisse k√∂nnen abh√§ngig von der Anzahl der auf dem Knoten gestarteten Herde variieren - die Anzahl von 105 Herden wird ausgew√§hlt, weil  Der Standardwert ist jetzt der Maximalwert f√ºr benutzerdefinierte Herde auf dem Knoten. <br><br>  Wie aus den folgenden Grafiken <i>ersichtlich ist,</i> verbraucht die Integration von Containerd 1.1 in <i>Kubelet</i> 30,89% weniger CPU und 11,30% weniger RSS-Speicher (residente <i>Satzgr√∂√üe</i> ) sowie 12,78% weniger RSS-Speicher, der von der Container-Laufzeit verbraucht wird . <br><br><img src="https://habrastorage.org/webt/ic/w6/rf/icw6rfbsd1rqn6byqbzosaalkim.png"><br><br><h3>  <i>Erg√§nzung durch den √úbersetzer</i> </h3><br>  <i>Es ist zu beachten, dass sich eine weitere alternative L√∂sung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O</a> , weiterentwickelt.</i>  <i>Insbesondere auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Source Summit Japan 2018 in</a> diesen Tagen pr√§sentierte ein Mitarbeiter von NTT einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> mit einem umfassenden Vergleich bestehender ausf√ºhrbarer Umgebungen f√ºr Container.</i>  <i>Und hier ist eine seiner Folien, die ihre Leistung vergleicht:</i> <br><br><img src="https://habrastorage.org/webt/q8/vv/zf/q8vvzfa4zw7ydge80hhj_higkhi.png"><br><br><h2>  crictl </h2><br>  Die Container Runtime Console Interface (CLI) ist ein n√ºtzliches Tool zum Erkennen von Problemen im System und in der Anwendung.  Wenn Sie Docker als Containerumgebung in Kubernetes verwenden, rufen Systemadministratoren manchmal die Kubernetes-Site auf, um Docker-Befehle auszuf√ºhren und Informationen √ºber das System und / oder die Anwendung zu sammeln.  Beispielsweise k√∂nnen sie <code>docker ps</code> und <code>docker inspect</code> , um den Status des Prozesses zu √ºberpr√ºfen, <code>docker images</code> , um eine Liste der Bilder auf dem Knoten <code>docker info</code> , <code>docker info</code> , um die Konfiguration der Laufzeit f√ºr Container usw. abzurufen. <br><br>  F√ºr Containerd und alle anderen CRI-kompatiblen Umgebungen wie Dockershim empfehlen wir die Verwendung von <i>crictl</i> als CLI-Alternative zu Docker-Konsolenbefehlen, um Probleme auf Pods, Containern und Container-Images zu analysieren, die auf Kubernetes-Knoten gehostet werden. <br><br>  <i>crictl</i> ist ein Dienstprogramm, das √§hnliche Funktionen wie die Docker-CLI bietet und f√ºr alle Laufzeitumgebungen f√ºr mit CRI kompatible Container gleich gut funktioniert.  Es befindet sich im Repository von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-inkubator / cri-tools</a> .  Die aktuelle Version ist <a href="">cri-tools v1.11.0</a> <i>(die Version wurde f√ºr die aktuelle Version vor 3 Tagen anstelle von <a href="">v1.0.0-beta.1</a> , angegeben im Originalartikel, <b>ca. √ºbersetzt</b> ) <a href="">korrigiert</a></i> .  Obwohl das Dienstprogramm <i>crictl</i> der Docker-CLI √§hnelt und einen einfachen √úbergang f√ºr Benutzer bietet, handelt es sich nicht um eine vollst√§ndige Kopie davon.  Einige wichtige Unterschiede werden nachstehend beschrieben. <br><br><h3>  Eingeschr√§nkte Verwendung: crictl ist ein Tool zur Fehlerbehebung </h3><br>  <i>crictl ist</i> kein Ersatz f√ºr <code>kubectl</code> oder <code>kubectl</code> - seine Verwendung beschr√§nkt sich auf den Umfang der Problemidentifizierung und -analyse.  Die Docker-Konsolenoberfl√§che bietet eine Vielzahl von Befehlen und ist daher ein sehr n√ºtzliches Entwicklungswerkzeug.  Dies ist jedoch nicht die beste Option zur Fehlerbehebung auf Kubernetes-Knoten.  Einige Docker-Befehle (z. B. <code>docker network</code> und <code>docker build</code> ) sind f√ºr Kubernetes unbrauchbar, und einige (z. B. <code>docker rename</code> ) k√∂nnen alles besch√§digen.  Der Zweck von <i>crictl</i> besteht darin, gen√ºgend Befehle bereitzustellen, um Probleme auf Knoten zu identifizieren, die in Produktionsumgebungen sicher verwendet werden k√∂nnen. <br><br><h3>  Kubernetes Fokus </h3><br>  <i>crictl</i> bietet eine verst√§ndlichere Containeransicht in der Kubernetes-Welt.  Die Docker-Konsolenschnittstelle funktioniert nicht mit grundlegenden Kubernetes-Konzepten wie unter (pod) und Namespace ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namespace</a> ), wodurch die visuelle Darstellung von Containern und Herden verhindert wird <i>(die Bedeutung dieses Problems ist bereits im √úberwachungskontext zutreffend, √ºber den wir k√ºrzlich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Bericht gesprochen haben</a> - <b>Hinweis . perev.</b> )</i> .  Ein solches Beispiel ist <code>docker ps</code> das obskure, lange Namen f√ºr Docker-Container und eine Liste von Pausencontainern zusammen mit Anwendungscontainern anzeigt: <br><br><img src="https://habrastorage.org/webt/4w/ne/cs/4wnecsys4wdvacswvpxcfgmhtj8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pausencontainer</a> sind jedoch Teil der Herdimplementierung, wobei f√ºr jeden Herd ein solcher Container verwendet wird.  Sie sollten nicht angezeigt werden, wenn Container angezeigt werden, die Teil des Herdes sind. <br><br>  <i>crictl</i> wurde dagegen f√ºr Kubernetes erstellt.  Das Dienstprogramm bietet verschiedene Befehlss√§tze f√ºr Herde und Container.  Beispielsweise zeigt <code>crictl pods</code> Informationen zu <code>crictl pods</code> , und <code>crictl ps</code> zeigt nur Informationen zu Anwendungscontainern an.  Alle Daten werden in einer Tabellenansicht formatiert: <br><br><img src="https://habrastorage.org/webt/fq/su/ck/fqsuckdyowdo74u-u88okijpjsk.png"><br><br><img src="https://habrastorage.org/webt/iy/xg/tf/iyxgtfzobswe9woyeay9lqylwsy.png"><br><br>  Ein weiteres Beispiel - in <code>crictl pods</code> gibt es ein Argument - <code>--namespace</code> , mit dem Pods nach in Kubernetes definierten Namespaces <code>--namespace</code> werden k√∂nnen: <br><br><img src="https://habrastorage.org/webt/ib/gq/3u/ibgq3udmdsf_wbjdw5lto57ckqa.png"><br><br>  Weitere Informationen zur Verwendung von crictl mit Containerd finden Sie hier: <br><br><ul><li>  <a href="">Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Video bei asciinema</a> . </li></ul><br><h2>  Aber was ist mit der Docker Engine? </h2><br>  Wir h√∂ren oft die folgende Frage: "Bedeutet der Wechsel zu Containerd, dass ich die Docker Engine nicht mehr verwenden kann?", Und die kurze Antwort darauf lautet "NEIN". <br><br>  Docker Engine basiert auf Containerd.  Die n√§chste Version der Docker Community Edition (Docker CE) wird Containerd Version 1.1 verwenden.  Dementsprechend wird es ein eingebautes und standardm√§√üig aktiviertes CRI-Plugin haben.  Dies bedeutet, dass Benutzer die M√∂glichkeit haben, weiterhin mit der Docker Engine f√ºr andere typische Szenarien zu arbeiten sowie Kubernetes so zu konfigurieren, dass das zugrunde liegende Containerd verwendet wird, das mit der Docker Engine geliefert wird und gleichzeitig von der Docker Engine auf demselben Host verwendet wird.  Schauen Sie sich das folgende Architekturdiagramm an, das zeigt, wie Docker Engine und <i>Kubelet</i> denselben Container verwenden: <br><br><img src="https://habrastorage.org/webt/qj/f2/r2/qjf2r2vn_j4odysnyxytokycz9u.png"><br><br>  Da Containerd sowohl von <i>Kubelet</i> als auch von der Docker Engine verwendet wird, erhalten Benutzer, die sich f√ºr die Integration in Containerd entscheiden, nicht nur alle neuen Funktionen f√ºr Kubernetes, Verbesserungen der Leistung und Stabilit√§t, sondern auch die Option, die Docker Engine wie zuvor f√ºr andere Anforderungen zu verwenden. <br><br>  Der <a href="">Namespace-</a> Mechanismus in Containerd stellt sicher, dass <i>Kubelet</i> und die Docker Engine keinen Zugriff auf Container und Images haben, die nicht von ihnen erstellt wurden.  Dies bedeutet, dass sie sich nicht gegenseitig st√∂ren sowie: <br><br><ul><li>  Benutzer, die den <code>docker ps</code> eingeben, sehen die in Kubernetes erstellten Container nicht.  Verwenden Sie dazu <code>crictl ps</code> .  Umgekehrt sehen Benutzer keine Container, die in der Docker-CLI auf Kubernetes oder im Befehl <code>crictl ps</code> .  Die <code>crictl run</code> <code>crictl create</code> und <code>crictl run</code> dienen nur zur Fehlerbehebung.  Das manuelle Ausf√ºhren von Herden oder Containern mit <code>crictl</code> auf Produktionsknoten wird nicht empfohlen. </li><li>  Benutzer, die den <code>docker images</code> docker images eingeben, sehen die Bilder von Kubernetes nicht.  Verwenden Sie dazu den Befehl <code>crictl images</code> .  Umgekehrt sieht Kubernetes die Bilder nicht, die mit den Befehlen <code>docker pull</code> , <code>docker load</code> und <code>docker build</code> .  Verwenden Sie dazu den Befehl <code>crictl pull</code> sowie <code><a href="">ctr</a> cri load</code> , wenn Sie das Bild laden m√∂chten. </li></ul><br><h2>  Zusammenfassung </h2><br><ul><li>  Containerd 1.1 bietet native CRI-Unterst√ºtzung.  Es kann direkt von Kubernetes verwendet werden. </li><li>  Containerd 1.1 ist produktionsbereit. </li><li>  Containerd 1.1 bietet eine gute Leistung in Bezug auf die Startzeit des Pods und die Auslastung der Systemressourcen. </li><li>  crictl ist ein Konsolen-Dienstprogramm (CLI) f√ºr die Kommunikation mit Containerd 1.1 und anderen Laufzeitumgebungen f√ºr Container, die CRI entsprechen, um Probleme auf dem Knoten zu identifizieren. </li><li>  Containerd 1.1 wird in der n√§chsten stabilen Version von Docker CE enthalten sein.  Benutzer haben die M√∂glichkeit, in F√§llen, die nicht von Kubernetes stammen, weiterhin mit Docker zu arbeiten und Kubernetes so zu konfigurieren, dass das zugrunde liegende Containerd verwendet wird, das Teil von Docker ist. </li></ul><br>  Wir m√∂chten uns bei allen von Google, IBM, Docker, ZTE, ZJU und einzelnen Entwicklern bedanken, die dazu beigetragen und alles m√∂glich gemacht haben! <br><br>  Eine detaillierte Liste der √Ñnderungen in Containerd 1.1 finden Sie in den <a href="">Versionshinweisen</a> . <br><br><h2>  Wie man es versucht </h2><br>  Anweisungen zum Einrichten eines Kubernetes-Clusters zur Verwendung von Containerd als Standardlaufzeit: <br><br><ul><li>  f√ºr einen Cluster auf GCE, der mit <code>kube-up.sh</code> , - <a href="">hier</a> ; </li><li>  einen Cluster mit vielen Knoten mit Ansible und kubeadm installieren - <a href="">hier</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> zum Erstellen eines Clusters von Grund auf in Google Cloud finden Sie unter " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes the Hard Way</a> ". </li><li>  zur manuellen Installation aus dem Tarball-Archiv - <a href="">hier</a> ; </li><li>  zur Installation mit LinuxKit auf einer lokalen virtuellen Maschine - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br><h2>  Wie man dazu beitr√§gt </h2><br>  Containerd CRI-Plugin - Ein Open Source-Projekt auf GitHub, das Teil von Containerd ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/containerd/cri</a> .  Alle vorgeschlagenen √Ñnderungen sind in Form von Ideen, Tickets und Korrekturen willkommen.  Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> f√ºr Entwickler ist ein guter Ausgangspunkt, um √Ñnderungen vorzunehmen. <br><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O - eine Alternative zu Docker zum Starten von Containern in Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was und warum macht Docker Moby, um sich in Kubernetes zu integrieren?"</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vier CNCF-Releases 1.0 und wichtige Ank√ºndigungen zu Kubernetes mit der KubeCon 2017</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum brauchen wir Containerd und warum wurde es von Docker getrennt?</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die Essenz des Moby-Projekts und warum wurde Moby / Moby pl√∂tzlich zum Haupt-Docker-Repository?</a>  "" </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414875/">https://habr.com/ru/post/de414875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414865/index.html">iMaterialist Furniture Challenge oder 50 Stuhlfarben</a></li>
<li><a href="../de414867/index.html">ThinkingHome.Migrator - versionierte Migration des Datenbankschemas auf der .NET Core-Plattform</a></li>
<li><a href="../de414869/index.html">Verschwindende Rahmenbedingungen</a></li>
<li><a href="../de414871/index.html">Der Staubsturm auf dem Mars erreichte das planetare Ausma√ü, sogar die Neugier war betroffen</a></li>
<li><a href="../de414873/index.html">IDisposable - dass deine Mutter nicht √ºber die Freigabe von Ressourcen gesprochen hat. Teil 1</a></li>
<li><a href="../de414877/index.html">Ein ungew√∂hnliches Objektiv f√ºr eine normale Kamera oder wie man aufh√∂rt, √ºber den Fokus nachzudenken</a></li>
<li><a href="../de414879/index.html">Warum 2 Extruder in einem 3D-Drucker?</a></li>
<li><a href="../de414881/index.html">Ein bisschen Backstage VK</a></li>
<li><a href="../de414883/index.html">Erinnerungen klangen neu: BBC hat das Soundarchiv des RemArc-Projekts aktualisiert</a></li>
<li><a href="../de414885/index.html">Wir besch√§ftigen uns mit Fehlern und ‚ÄûKr√ºcken‚Äú im einheitlichen staatlichen Register der juristischen Personen - dem staatlichen Register der juristischen Personen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>