<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈚️ ⛳️ 🥩 Kubernetes Containerd-Integration ersetzt Docker für die Produktion 🕎 👵🏾 📕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Wir haben mehr als einmal über Containerd und andere Laufzeiten für Kubernetes geschrieben. Die neue Veröffentlichung ist eine Überse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Containerd-Integration ersetzt Docker für die Produktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/414875/"><img src="https://habrastorage.org/webt/bw/-e/lu/bw-elulxcq_ts7y7ln0cjnwyxng.png"><br><br>  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Wir haben mehr als einmal über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Containerd</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> Laufzeiten für Kubernetes geschrieben.</i>  <i>Die neue Veröffentlichung ist eine Übersetzung der jüngsten Ankündigung eines wichtigen Meilensteins in der Entwicklung von Containerd, die im offiziellen Blog des Kubernetes-Projekts veröffentlicht wurde.</i>  <i>Der Text wurde von Mitarbeitern von Google und IBM verfasst, die (natürlich zusammen mit Docker Inc) erheblich zur Verbesserung von Containerd beitragen.</i> <br><br>  Zu Beginn des Blogs haben wir in der Notiz " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Containerd bringt mehr Container-Laufzeitoptionen für Kubernetes"</a> eine Alpha-Version der Integration von Containerd in Kubernetes vorgestellt.  Die nächsten 6 Monate der Entwicklung führten dazu, dass die Integration öffentlich verfügbar wurde!  Dies bedeutet, dass Sie jetzt <a href="">Containerd 1.1</a> als Laufzeit für Container in Kubernetes-Clustern in der Produktion verwenden können. <br><br>  Containerd 1.1 funktioniert mit Kubernetes Version 1.10 und höher und unterstützt alle Kubernetes-Funktionen.  In der Kubernetes-Testinfrastruktur entspricht die Abdeckung von Containerd-Integrationstests auf der Google Cloud Platform der Integration mit Docker (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test-Dashboard</a> ). <a name="habracut"></a><br><br><blockquote>  „Wir freuen uns, dass Containerd diesen wichtigen Meilenstein schnell erreicht.  Bei Alibaba Cloud haben wir von Anfang an begonnen, Containerd aktiv einzusetzen, und dank seiner Betonung auf Einfachheit und Zuverlässigkeit wurde Containerd zur Standard-Container-Engine in seinem Produkt Serverless Kubernetes, das hohe Anforderungen an Leistung und Stabilität stellt.  Containerd wird zweifellos der Hauptmotor der Container-Ära sein und zur Entwicklung von Innovationen führen. “  <i>- Xinwei, ein Vollzeitingenieur von Alibaba Cloud</i> </blockquote><br><h2>  Architektonische Verbesserungen </h2><br>  Die Architektur für die Integration von Containerd in Kubernetes wurde zweimal geändert.  Jeder seiner Evolutionsschritte stabilisierte und verbesserte die Effizienz des Stapels. <br><br><h3>  Containerd 1.0 - CRI-Containerd (nicht mehr vorhanden) </h3><br><img src="https://habrastorage.org/webt/8q/n4/2o/8qn42ofstq8qrrucp5txrrb2wze.png"><br><br>  In Containerd 1.0 wurde der Cri-Containerd-Daemon für die Interaktion zwischen <i>Kubelet</i> und Containerd benötigt <i>(wir haben darüber am Ende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Artikels geschrieben</a> - <b>ca. Transl.</b> )</i> .  Dieser Daemon hat Anforderungen an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container Runtime Interface (CRI)</a> von <i>Kubelet bereitgestellt</i> und Containerd verwendet, um Container und Container-Images ordnungsgemäß zu verwalten.  Dieser Ansatz eliminierte eine zusätzliche Verknüpfung im Stapel im Vergleich zur Docker CRI-Implementierung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockershim</a> ) - <i>siehe Abbildung oben</i> . <br><br>  Cri-Containerd und Containerd 1.0 waren jedoch zwei separate Dämonen, die über GRPC interagierten.  Ein zusätzlicher Daemon in diesem Bundle erschwerte den Benutzern das Verständnis des Geräts und der Bereitstellung und verursachte unnötigen Overhead für die Interaktion. <br><br><h3>  Containerd 1.1 - CRI Plugin (aktuelle Version) </h3><br><img src="https://habrastorage.org/webt/sc/hl/uw/schluwslee8y_n4kihjgseh0kpw.png"><br><br>  In Containerd 1.1 wurde der Cri-Containerd-Daemon in das Containerd-CRI-Plugin übernommen.  Dieses Plugin ist in Containerd 1.1 integriert und standardmäßig aktiviert.  Im Gegensatz zu Cri-Containerd interagiert das Plugin mit Containerd, indem es die erforderlichen Funktionen direkt aufruft.  Die neue Architektur hat die Integration stabiler und produktiver gemacht und eine weitere Verbindung (GRPC) aus dem Stapel entfernt.  Jetzt kann Containerd 1.1 direkt in Kubernetes verwendet werden, und der Cri-Containerd-Daemon wird nicht mehr benötigt. <br><br><h2>  Leistung </h2><br>  Eines der Hauptziele von Containerd 1.1 war die Verbesserung der Leistung.  Optimierungen wurden im Bereich der Startzeit und der vom Dämon verwendeten Ressourcen durchgeführt. <br><br>  Die folgenden Ergebnisse sind ein Vergleich von Containerd 1.1 und Docker 18.03 CE.  Integration Containerd 1.1 verwendet das integrierte CRI-Plugin, und die Integration für Docker 18.03 CE funktioniert mit Dockershim.  Die Ergebnisse wurden mithilfe des Kubernetes- <a href="">Knotenleistungs-</a> Benchmarks generiert, der Teil der <a href="">e2e-Tests für K8s-Knoten ist</a> .  Die meisten Vergleichsdaten sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node Performance Dashboard</a> öffentlich verfügbar. <br><br><h3>  Verzögerung des Herdstarts </h3><br>  Die Ergebnisse des <i>105-Pod-Batch-Startbenchmarks</i> zeigen, dass die Integration von Containerd 1.1 beim Starten des Pods weniger Verzögerungen aufweist als Docker 18.03 CE mit Dockershim (je kleiner desto besser). <br><br><img src="https://habrastorage.org/webt/1e/20/re/1e20rewi6uzg9ixrkmfsybifidk.png"><br><br><h3>  CPU und Speicher </h3><br>  Im Leerlauf verbraucht die Integration von Containerd 1.1 mit 105 Herden weniger Prozessor und Speicher als die Integration von Docker 18.03 CE mit Dockershim.  Die Ergebnisse können abhängig von der Anzahl der auf dem Knoten gestarteten Herde variieren - die Anzahl von 105 Herden wird ausgewählt, weil  Der Standardwert ist jetzt der Maximalwert für benutzerdefinierte Herde auf dem Knoten. <br><br>  Wie aus den folgenden Grafiken <i>ersichtlich ist,</i> verbraucht die Integration von Containerd 1.1 in <i>Kubelet</i> 30,89% weniger CPU und 11,30% weniger RSS-Speicher (residente <i>Satzgröße</i> ) sowie 12,78% weniger RSS-Speicher, der von der Container-Laufzeit verbraucht wird . <br><br><img src="https://habrastorage.org/webt/ic/w6/rf/icw6rfbsd1rqn6byqbzosaalkim.png"><br><br><h3>  <i>Ergänzung durch den Übersetzer</i> </h3><br>  <i>Es ist zu beachten, dass sich eine weitere alternative Lösung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O</a> , weiterentwickelt.</i>  <i>Insbesondere auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Source Summit Japan 2018 in</a> diesen Tagen präsentierte ein Mitarbeiter von NTT einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> mit einem umfassenden Vergleich bestehender ausführbarer Umgebungen für Container.</i>  <i>Und hier ist eine seiner Folien, die ihre Leistung vergleicht:</i> <br><br><img src="https://habrastorage.org/webt/q8/vv/zf/q8vvzfa4zw7ydge80hhj_higkhi.png"><br><br><h2>  crictl </h2><br>  Die Container Runtime Console Interface (CLI) ist ein nützliches Tool zum Erkennen von Problemen im System und in der Anwendung.  Wenn Sie Docker als Containerumgebung in Kubernetes verwenden, rufen Systemadministratoren manchmal die Kubernetes-Site auf, um Docker-Befehle auszuführen und Informationen über das System und / oder die Anwendung zu sammeln.  Beispielsweise können sie <code>docker ps</code> und <code>docker inspect</code> , um den Status des Prozesses zu überprüfen, <code>docker images</code> , um eine Liste der Bilder auf dem Knoten <code>docker info</code> , <code>docker info</code> , um die Konfiguration der Laufzeit für Container usw. abzurufen. <br><br>  Für Containerd und alle anderen CRI-kompatiblen Umgebungen wie Dockershim empfehlen wir die Verwendung von <i>crictl</i> als CLI-Alternative zu Docker-Konsolenbefehlen, um Probleme auf Pods, Containern und Container-Images zu analysieren, die auf Kubernetes-Knoten gehostet werden. <br><br>  <i>crictl</i> ist ein Dienstprogramm, das ähnliche Funktionen wie die Docker-CLI bietet und für alle Laufzeitumgebungen für mit CRI kompatible Container gleich gut funktioniert.  Es befindet sich im Repository von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-inkubator / cri-tools</a> .  Die aktuelle Version ist <a href="">cri-tools v1.11.0</a> <i>(die Version wurde für die aktuelle Version vor 3 Tagen anstelle von <a href="">v1.0.0-beta.1</a> , angegeben im Originalartikel, <b>ca. übersetzt</b> ) <a href="">korrigiert</a></i> .  Obwohl das Dienstprogramm <i>crictl</i> der Docker-CLI ähnelt und einen einfachen Übergang für Benutzer bietet, handelt es sich nicht um eine vollständige Kopie davon.  Einige wichtige Unterschiede werden nachstehend beschrieben. <br><br><h3>  Eingeschränkte Verwendung: crictl ist ein Tool zur Fehlerbehebung </h3><br>  <i>crictl ist</i> kein Ersatz für <code>kubectl</code> oder <code>kubectl</code> - seine Verwendung beschränkt sich auf den Umfang der Problemidentifizierung und -analyse.  Die Docker-Konsolenoberfläche bietet eine Vielzahl von Befehlen und ist daher ein sehr nützliches Entwicklungswerkzeug.  Dies ist jedoch nicht die beste Option zur Fehlerbehebung auf Kubernetes-Knoten.  Einige Docker-Befehle (z. B. <code>docker network</code> und <code>docker build</code> ) sind für Kubernetes unbrauchbar, und einige (z. B. <code>docker rename</code> ) können alles beschädigen.  Der Zweck von <i>crictl</i> besteht darin, genügend Befehle bereitzustellen, um Probleme auf Knoten zu identifizieren, die in Produktionsumgebungen sicher verwendet werden können. <br><br><h3>  Kubernetes Fokus </h3><br>  <i>crictl</i> bietet eine verständlichere Containeransicht in der Kubernetes-Welt.  Die Docker-Konsolenschnittstelle funktioniert nicht mit grundlegenden Kubernetes-Konzepten wie unter (pod) und Namespace ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namespace</a> ), wodurch die visuelle Darstellung von Containern und Herden verhindert wird <i>(die Bedeutung dieses Problems ist bereits im Überwachungskontext zutreffend, über den wir kürzlich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Bericht gesprochen haben</a> - <b>Hinweis . perev.</b> )</i> .  Ein solches Beispiel ist <code>docker ps</code> das obskure, lange Namen für Docker-Container und eine Liste von Pausencontainern zusammen mit Anwendungscontainern anzeigt: <br><br><img src="https://habrastorage.org/webt/4w/ne/cs/4wnecsys4wdvacswvpxcfgmhtj8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pausencontainer</a> sind jedoch Teil der Herdimplementierung, wobei für jeden Herd ein solcher Container verwendet wird.  Sie sollten nicht angezeigt werden, wenn Container angezeigt werden, die Teil des Herdes sind. <br><br>  <i>crictl</i> wurde dagegen für Kubernetes erstellt.  Das Dienstprogramm bietet verschiedene Befehlssätze für Herde und Container.  Beispielsweise zeigt <code>crictl pods</code> Informationen zu <code>crictl pods</code> , und <code>crictl ps</code> zeigt nur Informationen zu Anwendungscontainern an.  Alle Daten werden in einer Tabellenansicht formatiert: <br><br><img src="https://habrastorage.org/webt/fq/su/ck/fqsuckdyowdo74u-u88okijpjsk.png"><br><br><img src="https://habrastorage.org/webt/iy/xg/tf/iyxgtfzobswe9woyeay9lqylwsy.png"><br><br>  Ein weiteres Beispiel - in <code>crictl pods</code> gibt es ein Argument - <code>--namespace</code> , mit dem Pods nach in Kubernetes definierten Namespaces <code>--namespace</code> werden können: <br><br><img src="https://habrastorage.org/webt/ib/gq/3u/ibgq3udmdsf_wbjdw5lto57ckqa.png"><br><br>  Weitere Informationen zur Verwendung von crictl mit Containerd finden Sie hier: <br><br><ul><li>  <a href="">Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Video bei asciinema</a> . </li></ul><br><h2>  Aber was ist mit der Docker Engine? </h2><br>  Wir hören oft die folgende Frage: "Bedeutet der Wechsel zu Containerd, dass ich die Docker Engine nicht mehr verwenden kann?", Und die kurze Antwort darauf lautet "NEIN". <br><br>  Docker Engine basiert auf Containerd.  Die nächste Version der Docker Community Edition (Docker CE) wird Containerd Version 1.1 verwenden.  Dementsprechend wird es ein eingebautes und standardmäßig aktiviertes CRI-Plugin haben.  Dies bedeutet, dass Benutzer die Möglichkeit haben, weiterhin mit der Docker Engine für andere typische Szenarien zu arbeiten sowie Kubernetes so zu konfigurieren, dass das zugrunde liegende Containerd verwendet wird, das mit der Docker Engine geliefert wird und gleichzeitig von der Docker Engine auf demselben Host verwendet wird.  Schauen Sie sich das folgende Architekturdiagramm an, das zeigt, wie Docker Engine und <i>Kubelet</i> denselben Container verwenden: <br><br><img src="https://habrastorage.org/webt/qj/f2/r2/qjf2r2vn_j4odysnyxytokycz9u.png"><br><br>  Da Containerd sowohl von <i>Kubelet</i> als auch von der Docker Engine verwendet wird, erhalten Benutzer, die sich für die Integration in Containerd entscheiden, nicht nur alle neuen Funktionen für Kubernetes, Verbesserungen der Leistung und Stabilität, sondern auch die Option, die Docker Engine wie zuvor für andere Anforderungen zu verwenden. <br><br>  Der <a href="">Namespace-</a> Mechanismus in Containerd stellt sicher, dass <i>Kubelet</i> und die Docker Engine keinen Zugriff auf Container und Images haben, die nicht von ihnen erstellt wurden.  Dies bedeutet, dass sie sich nicht gegenseitig stören sowie: <br><br><ul><li>  Benutzer, die den <code>docker ps</code> eingeben, sehen die in Kubernetes erstellten Container nicht.  Verwenden Sie dazu <code>crictl ps</code> .  Umgekehrt sehen Benutzer keine Container, die in der Docker-CLI auf Kubernetes oder im Befehl <code>crictl ps</code> .  Die <code>crictl run</code> <code>crictl create</code> und <code>crictl run</code> dienen nur zur Fehlerbehebung.  Das manuelle Ausführen von Herden oder Containern mit <code>crictl</code> auf Produktionsknoten wird nicht empfohlen. </li><li>  Benutzer, die den <code>docker images</code> docker images eingeben, sehen die Bilder von Kubernetes nicht.  Verwenden Sie dazu den Befehl <code>crictl images</code> .  Umgekehrt sieht Kubernetes die Bilder nicht, die mit den Befehlen <code>docker pull</code> , <code>docker load</code> und <code>docker build</code> .  Verwenden Sie dazu den Befehl <code>crictl pull</code> sowie <code><a href="">ctr</a> cri load</code> , wenn Sie das Bild laden möchten. </li></ul><br><h2>  Zusammenfassung </h2><br><ul><li>  Containerd 1.1 bietet native CRI-Unterstützung.  Es kann direkt von Kubernetes verwendet werden. </li><li>  Containerd 1.1 ist produktionsbereit. </li><li>  Containerd 1.1 bietet eine gute Leistung in Bezug auf die Startzeit des Pods und die Auslastung der Systemressourcen. </li><li>  crictl ist ein Konsolen-Dienstprogramm (CLI) für die Kommunikation mit Containerd 1.1 und anderen Laufzeitumgebungen für Container, die CRI entsprechen, um Probleme auf dem Knoten zu identifizieren. </li><li>  Containerd 1.1 wird in der nächsten stabilen Version von Docker CE enthalten sein.  Benutzer haben die Möglichkeit, in Fällen, die nicht von Kubernetes stammen, weiterhin mit Docker zu arbeiten und Kubernetes so zu konfigurieren, dass das zugrunde liegende Containerd verwendet wird, das Teil von Docker ist. </li></ul><br>  Wir möchten uns bei allen von Google, IBM, Docker, ZTE, ZJU und einzelnen Entwicklern bedanken, die dazu beigetragen und alles möglich gemacht haben! <br><br>  Eine detaillierte Liste der Änderungen in Containerd 1.1 finden Sie in den <a href="">Versionshinweisen</a> . <br><br><h2>  Wie man es versucht </h2><br>  Anweisungen zum Einrichten eines Kubernetes-Clusters zur Verwendung von Containerd als Standardlaufzeit: <br><br><ul><li>  für einen Cluster auf GCE, der mit <code>kube-up.sh</code> , - <a href="">hier</a> ; </li><li>  einen Cluster mit vielen Knoten mit Ansible und kubeadm installieren - <a href="">hier</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> zum Erstellen eines Clusters von Grund auf in Google Cloud finden Sie unter " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes the Hard Way</a> ". </li><li>  zur manuellen Installation aus dem Tarball-Archiv - <a href="">hier</a> ; </li><li>  zur Installation mit LinuxKit auf einer lokalen virtuellen Maschine - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br><h2>  Wie man dazu beiträgt </h2><br>  Containerd CRI-Plugin - Ein Open Source-Projekt auf GitHub, das Teil von Containerd ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/containerd/cri</a> .  Alle vorgeschlagenen Änderungen sind in Form von Ideen, Tickets und Korrekturen willkommen.  Diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> für Entwickler ist ein guter Ausgangspunkt, um Änderungen vorzunehmen. <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O - eine Alternative zu Docker zum Starten von Containern in Kubernetes</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was und warum macht Docker Moby, um sich in Kubernetes zu integrieren?"</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vier CNCF-Releases 1.0 und wichtige Ankündigungen zu Kubernetes mit der KubeCon 2017</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum brauchen wir Containerd und warum wurde es von Docker getrennt?</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die Essenz des Moby-Projekts und warum wurde Moby / Moby plötzlich zum Haupt-Docker-Repository?</a>  "" </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414875/">https://habr.com/ru/post/de414875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414865/index.html">iMaterialist Furniture Challenge oder 50 Stuhlfarben</a></li>
<li><a href="../de414867/index.html">ThinkingHome.Migrator - versionierte Migration des Datenbankschemas auf der .NET Core-Plattform</a></li>
<li><a href="../de414869/index.html">Verschwindende Rahmenbedingungen</a></li>
<li><a href="../de414871/index.html">Der Staubsturm auf dem Mars erreichte das planetare Ausmaß, sogar die Neugier war betroffen</a></li>
<li><a href="../de414873/index.html">IDisposable - dass deine Mutter nicht über die Freigabe von Ressourcen gesprochen hat. Teil 1</a></li>
<li><a href="../de414877/index.html">Ein ungewöhnliches Objektiv für eine normale Kamera oder wie man aufhört, über den Fokus nachzudenken</a></li>
<li><a href="../de414879/index.html">Warum 2 Extruder in einem 3D-Drucker?</a></li>
<li><a href="../de414881/index.html">Ein bisschen Backstage VK</a></li>
<li><a href="../de414883/index.html">Erinnerungen klangen neu: BBC hat das Soundarchiv des RemArc-Projekts aktualisiert</a></li>
<li><a href="../de414885/index.html">Wir beschäftigen uns mit Fehlern und „Krücken“ im einheitlichen staatlichen Register der juristischen Personen - dem staatlichen Register der juristischen Personen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>