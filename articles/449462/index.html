<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💞 🙍🏼 👶 Uso de mecanismos de token criptográfico PKCS # 11 en lenguajes de script 👰🏼 👉🏾 👼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En sus comentarios sobre el artículo "Una utilidad multiplataforma de habla inglesa para ver certificados rusos calificados x509", Pas notó muy correc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de mecanismos de token criptográfico PKCS # 11 en lenguajes de script</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449462/"><img src="https://habrastorage.org/webt/zf/pt/t6/zfptt6z2xd1tfn_xoovblv2gpuk.png" align="left">  En sus comentarios sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> "Una utilidad multiplataforma de habla inglesa para ver certificados rusos calificados x509", <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Pas</a> notó muy correctamente los tokens PKCS # 11 que "todos pueden contar por sí mismos".  Sí, los tokens son en realidad computadoras criptográficas.  Y es natural querer usar estas computadoras en lenguajes de script, ya sea Python, Perl o Ruby.  Ya hemos considerado de alguna manera el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso de tokens PKCS # 11</a> con soporte para la criptografía rusa en Python para firmar y encriptar documentos, para crear una solicitud de certificado: <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/2c8/cc8/fad2c8cc898827d22442885cc9513afd.png" alt="imagen"><br><br>  Aquí continuamos la discusión sobre el lenguaje Tcl.  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> anterior, cuando analizamos ver y validar certificados almacenados en tokens / tarjetas inteligentes PKCS # 11, utilizamos el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TclPKCS11 versión 0.9.9</a> para acceder a ellos (certificados).  Como ya se señaló, desafortunadamente, el paquete fue desarrollado para la criptografía RSA y teniendo en cuenta el estándar PKCS # 11 v.2.20.  Hoy, el estándar PKCS # 11 v.2.40 ya se usa y es el comité técnico de criptografía TK-26 el que se guía por él, emitiendo recomendaciones para fabricantes nacionales de tokens / tarjetas inteligentes que admiten la criptografía rusa.  Y con todo esto dicho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha aparecido</a> un nuevo paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TclPKCS11 versión 1.0.1</a> .  Haremos una reserva de inmediato para guardar todas las interfaces criptográficas para RSA en la nueva versión del paquete TclPKCS11 v.10.1.  La biblioteca de paquetes está escrita en lenguaje C. <br><br>  Entonces, ¿qué hay de nuevo en el paquete?  En primer lugar, se agregó un comando que le permite obtener una lista de mecanismos criptográficos compatibles con el token conectado: <br><br><pre><code class="plaintext hljs">::pki::pkcs11::listmechs &lt;handl&gt; &lt;slotid&gt;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> se muestra cómo obtener una lista de ranuras con tokens conectados (procedimiento - proc :: slots_with_token): <br><br><pre> <code class="plaintext hljs">proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] }</code> </pre> <br>  Toma un guión simple: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path . package require pki::pkcs11 #      RuToken set lib "/usr/local/lib64/librtpkcs11ecp_2.0.so" &lt;source lang="bash"&gt;set handle [pki::pkcs11::loadmodule $lib] #    #       set labslot [::slots_with_token $handle] if {[llength $labslot] == 0} { puts "     " exit } set slotid 0 set lmech [pki::pkcs11::listmechs $handle $slotid] set i 0 foreach mm $lmech { #   if {[string first "GOSTR3410" $mm] != -1} { puts -nonewline "[lindex $mm 0] " if {$i == 2} {puts "";set i 0} else { incr i} } } puts "\n" exit</code> </pre> <br>  Este script le permite obtener una lista de los mecanismos de criptografía GOSTR3410 compatibles con los tokens de la familia RuToken.  Para comenzar, tomemos, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Pas</a> escribió en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> , "Rutoken Light amada por todo tipo de EDO": <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken Lite 0 {ruToken Lite } $</code> </pre> <br>  Y, naturalmente, resulta que él no es compatible con ningún mezanismo GOST, lo que debía probarse.  Tomamos otro token Rutoken EDS: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken ECP } 0 {ruToken ECP } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 $</code> </pre> <br>  Sí, este token admite la criptografía rusa, pero solo la firma de GOST R 34.10-2001, que está casi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuera de uso</a> .  Pero si toma el token Rutoken EDS-2.0, entonces todo estará bien, es compatible con GOST R 34.10-2012 con claves de 256 y 512 bits de largo: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = RuTokenECP20 0 {RuTokenECP20 } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_512_KEY_PAIR_GEN CKM_GOSTR3410_512 CKM_GOSTR3410_12_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 CKM_GOSTR3410_WITH_GOSTR3411_12_256 CKM_GOS TR3410_WITH_GOSTR3411_12_512 $</code> </pre><br><img src="https://habrastorage.org/webt/1y/za/nm/1yzanmwujk76deyqsdqgw8kge3u.png" align="left">  Si hablamos sobre el soporte de la criptografía rusa, incluidos los algoritmos de cifrado de saltamontes y magma, con uno u otro token, entonces es más compatible con el software y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> tokens en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> , y esto es natural: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = LS11SW2016_LIN_64 0 {LS11SW2016_LIN_64 }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Listado de mecanismos</b> <div class="spoiler_text">  CKM_GOSTR3410_KEY_PAIR_GEN <br>  CKM_GOSTR3410_512_KEY_PAIR_GEN <br>  CKM_GOSTR3410 <br>  CKM_GOSTR3410_512 <br>  CKM_GOSTR3410_WITH_GOSTR3411 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_256 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_512 <br>  CKM_GOSTR3410_DERIVE <br>  CKM_GOSTR3410_12_DERIVE <br>  CKM_GOSR3410_2012_VKO_256 <br>  CKM_GOSR3410_2012_VKO_512 <br>  CKM_KDF_4357 <br>  CKM_KDF_GOSTR3411_2012_256 <br>  CKM_KDF_TREE_GOSTR3411_2012_256 <br>  CKM_GOSTR3410_KEY_WRAP <br>  CKM_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_LISSI_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_GOST_GENERIC_SECRET_KEY_GEN <br>  CKM_GOST_CIPHER_KEY_GEN <br>  CKM_GOST_CIPHER_ECB <br>  CKM_GOST_CIPHER_CBC <br>  CKM_GOST_CIPHER_CTR <br>  CKM_GOST_CIPHER_OFB <br>  CKM_GOST_CIPHER_CFB <br>  CKM_GOST_CIPHER_OMAC <br>  CKM_GOST_CIPHER_KEY_WRAP <br>  CKM_GOST_CIPHER_ACPKM_CTR <br>  CKM_GOST_CIPHER_ACPKM_OMAC <br>  CKM_GOST28147_KEY_GEN <br>  CKM_GOST28147 <br>  CKM_GOST28147_KEY_WRAP <br>  CKM_GOST28147_PKCS8_KEY_WRAP <br>  CKM_GOST_CIPHER_PKCS8_KEY_WRAP <br>  CKM_GOST28147_ECB <br>  CKM_GOST28147_CNT <br>  CKM_GOST28147_MAC <br>  CKM_KUZNYECHIK_KEY_GEN <br>  CKM_KUZNYECHIK_ECB <br>  CKM_KUZNYECHIK_CBC <br>  CKM_KUZNYECHIK_CTR <br>  CKM_KUZNYECHIK_OFB <br>  CKM_KUZNYECHIK_CFB <br>  CKM_KUZNYECHIK_OMAC <br>  CKM_KUZNYECHIK_KEY_WRAP <br>  CKM_KUZNYECHIK_ACPKM_CTR <br>  CKM_KUZNYECHIK_ACPKM_OMAC <br>  CKM_MAGMA_KEY_GEN <br>  CKM_MAGMA_ECB <br>  CKM_MAGMA_CBC <br>  CKM_MAGMA_CTR <br>  CKM_MAGMA_OFB <br>  CKM_MAGMA_CFB <br>  CKM_MAGMA_OMAC <br>  CKM_MAGMA_KEY_WRAP <br>  CKM_MAGMA_ACPKM_CTR <br>  CKM_MAGMA_ACPKM_OMAC <br>  CKM_GOSTR3411 <br>  CKM_GOSTR3411_12_256 <br>  CKM_GOSTR3411_12_512 <br>  CKM_GOSTR3411_HMAC <br>  CKM_GOSTR3411_12_256_HMAC <br>  CKM_GOSTR3411_12_512_HMAC <br>  CKM_PKCS5_PBKD2 <br>  CKM_PBA_GOSTR3411_WITH_GOSTR3411_HMAC <br>  CKM_TLS_GOST_KEY_AND_MAC_DERIVE <br>  CKM_TLS_GOST_PRE_MASTER_KEY_GEN <br>  CKM_TLS_GOST_MASTER_KEY_DERIVE <br>  CKM_TLS_GOST_PRF <br>  CKM_TLS_GOST_PRF_2012_256 <br>  CKM_TLS_GOST_PRF_2012_512 <br>  CKM_TLS12_MASTER_KEY_DERIVE <br>  CKM_TLS12_KEY_AND_MAC_DERIVE <br>  CKM_TLS_MAC <br>  CKM_TLS_KDF <br>  CKM_TLS_TREE_GOSTR3411_2012_256 <br>  CKM_EXTRACT_KEY_FROM_KEY <br>  CKM_SHA_1 <br>  CKM_MD5 <br></div></div><br><pre> <code class="plaintext hljs">$</code> </pre> <br>  Pasamos a la siguiente nueva característica agregada al paquete: <br><br><pre> <code class="plaintext hljs">set listcertsder [pki::pkcs11::listcertsder $handle $slotid]</code> </pre> <br>  Esta función devuelve una lista de certificados almacenados por ningún token.  La pregunta surge naturalmente, pero ¿en qué se diferencia de la función existente pki :: pkcs11 :: listcerts? <br><br>  En primer lugar, la nueva función no usa el paquete :: pki.  Uno de los elementos devueltos es un elemento cert_der que contiene el certificado completo.  Esto es conveniente, por ejemplo, al exportar un certificado o al recibir su huella digital.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Anteriormente,</a> tenía que recoger el certificado completo del certificado tbs y su firma.  Una lista completa de los artículos devueltos para cada certificado es claramente visible al imprimir el contenido de un certificado: <br><br><pre> <code class="plaintext hljs">. . . array set derc [[pki::pkcs11::listcertsder $handle $slotid] 0] parray derc derc(cert_der) = 3082064a … derc(pkcs11_handle) = pkcsmod0 derc(pkcs11_id) = 5882d64386211cf3a8367d2f87659f9330e5605d derc(pkcs11_label) = Thenderbird-60   derc(pkcs11_slotid) = 0 derc(type) = pkcs11 . . .</code> </pre> <br>  El elemento pkcs11_id almacena el atributo CKA_ID del valor del hash SHA-1 de la clave pública.  El elemento cert_der es el CKA_VALUE del certificado, pkcs11_label es CKA_LABEL. <br><br>  El elemento pkcs11_id (CKA_ID en la terminología del estándar PKCS # 11) es, junto con la biblioteca pkcs11_handle, y el identificador de ranura con el token pkcs11_slotid un elemento clave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para acceder a</a> claves y certificados almacenados en tokens. <br><br>  Entonces, si queremos cambiar la etiqueta (pkcs11_label) del certificado o las claves, ejecutamos un comando de la forma: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::rname &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  Para eliminar un certificado o claves de un token, un comando del formulario <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  La lista de elementos clave se puede formar de la siguiente manera: <br><br><pre> <code class="plaintext hljs">set listparam {} lappend listparam pkcs11_handle lappend listparam $handle lappend listparam pkcs11_slotid lappend listparam $pkcs11_slotid lappend listparam pkcs11_id lappend listparam $pkcs11_id</code> </pre> <br>  etc. <br>  La llamada a la función en este caso se ve así (eliminaremos el certificado y sus claves): <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete all $listparam</code> </pre> <br>  El lector probablemente ya ha adivinado que esta lista se puede organizar como un diccionario de dictados: <br><br><pre> <code class="plaintext hljs">set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid) dict set listparam pkcs11_id $pkcs11_id</code> </pre> <br>  Hay otras formas, por ejemplo, a través de una matriz. <br><br>  Una vez más, observamos que los elementos pkcs11_handle y pkcs11_slotid siempre deben estar presentes en la lista de elementos clave, que identifican de forma única el token conectado.  El resto de la composición está determinada por una función específica. <br><br>  La siguiente función se utiliza para instalar el certificado en el token: <br><br><pre> <code class="plaintext hljs">set pkcs11_id_cert [::pki::pkcs11::importcert &lt;cert_der_hex&gt; &lt;  &gt;</code> </pre> <br>  La función devuelve el valor CKA_ID en hexadecimal.  La lista de parámetros clave determina el token en el que se ubicará el certificado: <br><br><pre> <code class="plaintext hljs">{pkcs11_handle &lt;handle&gt; pkcs11_slotid &lt;slotid&gt;}</code> </pre><br>  El siguiente es nuestro cálculo de hash.  En la criptografía rusa de hoy se utilizan tres tipos de funciones hash: <br>  - GOST R 34.11-94 <br>  - GOST R 34 .11-2012 con un valor hash de 256 bits (stribog256) <br>  - GOST R 34 .11-2012 con un valor hash de 512 bits (stribog512) <br>  Para determinar qué hash admite el token, tenemos la función pki :: pkcs11 :: listmechs. <br><br>  La función de cálculo hash tiene la siguiente forma: <br><br><pre> <code class="plaintext hljs">set &lt;&gt; [pki::pkcs11::digest &lt;gostr3411|stribog256|stribog512|sha1&gt; &lt;  &gt; &lt;  &gt;]</code> </pre> <br>  Tenga en cuenta que el resultado del cálculo del cálculo se presenta en hexadecimal: <br><pre> <code class="plaintext hljs">. . . set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid set res_hex [pki::pkcs11::digest stribog256 0123456789 $listparam] puts $res_hex 086f2776f33aae96b9a616416b9d1fe9a049951d766709dbe00888852c9cc021</code> </pre><br>  Para la verificación, tomemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openssl con soporte para la criptografía rusa</a> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>|/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_s tatic dgst -md_gost12_256 (stdin)= 086f2776f33aae96b9a616416b9d1fe9a0499 51d766709dbe00888852c9 cc021 $</code> </pre> <br>  Como puede ver, el resultado es idéntico. <br><br>  Para verificar una firma electrónica, ya sea un certificado o una lista de certificados revocados o un documento firmado en un formato, ahora solo necesitamos la función de verificación de firma: <br><br><pre> <code class="plaintext hljs">set result [pki::pkcs11::verify &lt; &gt; &lt; &gt; &lt;  &gt;]]</code> </pre> <br>  Si la firma pasó la verificación, se devuelve 1; de lo contrario, 0. Para verificar la firma electrónica, se requiere la firma del documento en sí, el hash del documento, determinado por el tipo de firma, y ​​la clave pública con la que se creó la firma, con todos los parámetros (valor, tipo y parámetros). .  Toda la información sobre la clave en forma de publickeyinfo asn1 debe incluirse en la lista de elementos clave: <br><blockquote>  lpkar (pkcs11_handle) = pkcsmod0 <br>  lpkar (pkcs11_slotid) = 0 <br>  lpkar (pubkeyinfo) = 301f06082a85030701010101301306072a85030202240 <br>  006082a8503070101020203430004407d9306687af5a8e63af4b09443ed2e03794be <br>  10eba6627bf5fb3da1bb474a3507d2ce2cd24b63c727a02521897d1dd6edbdc7084d <br>  8886a39289c3f81bdf2e179 </blockquote>  La estructura de clave pública ASN1 se toma del certificado firmante: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_hex} { array set ret [list] set wholething [binary format H* $cert_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  Se encuentra el texto del script para verificar la firma electrónica de los certificados de un archivo <div class="spoiler">  <b class="spoiler_title">aqui</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 #set pkcs11_module "/usr/local/lib/libcackey.so" #set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } # PEM  DER proc ::cert_to_der {data} { if {[string first "-----BEGIN CERTIFICATE-----" $data] != -1} { set data [string map {"\r\n" "\n"} $data] } array set parsed_cert [::pki::_parse_pem $data "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"] if {[string range $parsed_cert(data) 0 0 ] == "0" } { #   DER- "0" == 0x30 set asnblock $parsed_cert(data) } else { set asnblock "" } return $asnblock } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\nverify_cert_with_pkcs11 &lt;file with certificate&gt; \[&lt;file with CA certificate&gt;\]\n" } } set countcert [llength $argv] if { $countcert &lt; 1 || $countcert &gt; 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } #  cert_user puts "Loading user certificate: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with certificate user: $file" exit } set cert_user [cert_to_der $cert_user] if {$cert_user == ""} { puts "User certificate bad" exit } catch {array set cert_parse [::pki::x509::parse_cert $cert_user]} if {![info exists cert_parse]} { puts "User certificate bad" exit } #parray cert_parse if {$countcert == 1} { if {$cert_parse(issuer) != $cert_parse(subject)} { puts "Bad usage: not self signed certificate" } else { set cert_CA $cert_user } } else { set fileca [lindex $argv 1] if {![file exists $fileca]} { usage 1 "File $fileca not exist" exit } #  cert_CA puts "Loading CA certificate: $fileca" set fd [open $fileca] chan configure $fd -translation binary set cert_CA [read $fd] close $fd if {$cert_CA == "" } { usage 1 "Bad file with certificate CA=$fileca" exit } set cert_CA [cert_to_der $cert_CA] if {$cert_CA == ""} { puts "CA certificate bad" exit } } foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid } } #    #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA] catch {array set cert_parse_CA [::pki::x509::parse_cert $cert_CA]} #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA_256] #array set cert_parse_CA [::pki::x509::parse_cert $CA_12_512] if {![info exists cert_parse_CA]} { puts "CA certificate bad" exit } ############################### set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set tbs_cert [binary format H* $cert_parse(cert)] #puts "SIGN_ALGO1=$cert_parse(signature_algo)" catch {set signature_algo_number [::pki::_oid_name_to_number $cert_parse(signature_algo)]} if {![info exists signature_algo_number]} { set signature_algo_number $cert_parse(signature_algo) } #puts "SIGN_ALGO=$signature_algo_number" switch -- $signature_algo_number { "1.2.643.2.2.3" - "1 2 643 2 2 3" { # "GOST R 34.10-2001 with GOST R 34.11-94" set digest_algo "gostr3411" } "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" { # "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set digest_algo "stribog256" } "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" { # "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set digest_algo "stribog512" } default { puts "  :$signature_algo_number" exit } } #   tbs-!!!! set digest_hex [pki::pkcs11::digest $digest_algo $tbs_cert $aa] puts "digest_hex=$digest_hex" puts [string length $digest_hex] # asn-   #    binary scan $cert_CA H* cert_CA_hex array set infopk [pki::pkcs11::pubkeyinfo $cert_CA_hex [list pkcs11_handle $handle pkcs11_slotid $token_slotid]] parray infopk set lpk [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] # pybkeyinfo     lappend lpk "pubkeyinfo" #lappend lpk $pubinfo lappend lpk $infopk(pubkeyinfo) array set lpkar $lpk parray lpkar puts "Enter PIN user for you token \"$token_slotlabel\":" #set password "01234567" gets stdin password if { [pki::pkcs11::login $handle $token_slotid $password] == 0 } { puts "Bad password" exit } if {[catch {set verify [pki::pkcs11::verify $digest_hex $cert_parse(signature) $lpk]} res] } { puts $res exit } if {$verify != 1} { puts "BAD SIGNATURE=$verify" } else { puts "SIGNATURE OK=$verify" } puts "!" exit</code> </pre> <br></div></div><br>  Guarde el script en un archivo e intente ejecutarlo: <br><br><pre> <code class="bash hljs">$./verify_cert_with_pkcs11.tcl Copyright(C) Orlov Vladimir (http://museum.lissi-crypto.ru/) Usage: verify_cert_with_pkcs11 &lt;file with certificate&gt; &lt;file with CA certificate&gt; $</code> </pre> <br>  Uno se pregunta, ¿qué pasa con los certificados en el token?  Primero, resolvimos el problema del uso de máquinas criptográficas PKCS # 11.  Los usamos  Y para emitir un certificado con un token, existe una función del paquete pki :: pkcs11 :: listcertsder, que le permite seleccionar el certificado deseado y verificarlo.  Esto se puede considerar como tarea. <br><br>  La aparición de la nueva versión del paquete TclPKCS11v.1.0.1 permitió refinar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilidad de visualización de</a> certificados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">al</a> agregar las funciones de importar un certificado para un token, eliminar certificados y claves asociadas de un token, cambiar las etiquetas de certificados y claves, etc. <br><br><img src="https://habrastorage.org/webt/tn/7x/e8/tn7xe89tddtvfw0r6vmtqe2oeaa.png"><br><br>  La característica más importante agregada es la verificación de firma digital del certificado: <br><br><img src="https://habrastorage.org/webt/v8/sf/sr/v8sfsrp3tyghuwkyvseltrdtrsy.png"><br><br>  El atento lector notó correctamente que no se dijo nada sobre la generación del par de claves.  Esta característica también se agrega al paquete TclPKCS11: <br><br><pre> <code class="plaintext hljs">array set genkey [pki::pkcs11::keypair &lt; &gt; &lt;&gt; &lt;  &gt;]</code> </pre> <br>  Cómo se utilizan las funciones del paquete TclPKCS11, por supuesto, se puede encontrar en el código fuente de la utilidad. <br><br>  La función de generar un par de claves se discutirá en detalle en el próximo artículo, cuando la utilidad creará una solicitud de un certificado calificado con la generación de un par de claves en el token PKCS # 11, el mecanismo para obtener un certificado en un centro de certificación ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CA</a> ) e importarlo en un token: <br><br><img src="https://habrastorage.org/webt/zn/c4/zu/znc4zukmmtywwnpo4ycwze4zseo.png"><br><br>  En el mismo artículo, se considerará la función de firmar un documento.  Este será el último artículo de esta serie.  A continuación, se planea una serie de artículos para apoyar la criptografía rusa en el lenguaje de scripts Ruby, que ahora está de moda.  Hasta pronto! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449462/">https://habr.com/ru/post/449462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449450/index.html">Svelte 3: repensando la reactividad</a></li>
<li><a href="../449452/index.html">Los desarrolladores web escriben código inseguro por defecto</a></li>
<li><a href="../449454/index.html">Cómo Microsoft Kaizala permite a Indian Railways reunir a 3 millones de empleados de atención médica</a></li>
<li><a href="../449458/index.html">La actualización de Windows 10 "Actualización de mayo de 2019" no se instalará cuando ... las unidades USB y las tarjetas de memoria estén conectadas a la PC</a></li>
<li><a href="../449460/index.html">Datos del museo Art. El mouse manipulador de información gráfica</a></li>
<li><a href="../449464/index.html">Widget vk.com sin demanda establece un contador de mail.ru en el sitio</a></li>
<li><a href="../449466/index.html">Pausas en juegos HTML5</a></li>
<li><a href="../449468/index.html">Cómo el "truco ético" del fabricante de software de juego se convirtió en una pesadilla completa</a></li>
<li><a href="../449472/index.html">Cataclysm Dark Days Ahead, Análisis estático y panecillos</a></li>
<li><a href="../449476/index.html">Un nuevo tipo de almacenamiento SSD reducirá el consumo de energía en el centro de datos: cómo funciona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>