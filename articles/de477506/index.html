<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌧️ 🧕🏾 🤭 Entwicklung einer mobilen Anwendung ohne Server ☄️ 👨🏿‍🔬 👨🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sehr oft befinden sich Entwickler bei der Entwicklung mobiler Anwendungen (möglicherweise dasselbe Problem wie bei Webanwendungen) in einer Situation,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung einer mobilen Anwendung ohne Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/477506/">  Sehr oft befinden sich Entwickler bei der Entwicklung mobiler Anwendungen (möglicherweise dasselbe Problem wie bei Webanwendungen) in einer Situation, in der das Backend nicht funktioniert oder die erforderlichen Methoden nicht zur Verfügung stellt. <br><br>  Diese Situation kann aus verschiedenen Gründen auftreten.  Am häufigsten wird jedoch zu Beginn der Entwicklung das Backend einfach nicht geschrieben und der Client startet ohne es.  In diesem Fall verzögert sich der Entwicklungsbeginn um 2-4 Monate <br><br>  Manchmal fährt der Server nur herunter (stürzt ab), manchmal hat er keine Zeit, die erforderlichen Methoden zu implementieren, manchmal gibt es Datenprobleme usw.  All diese Probleme haben dazu geführt, dass wir einen kleinen Mocker-Service geschrieben haben, mit dem Sie das echte Backend ersetzen können. <br><br><img src="https://habrastorage.org/webt/xj/8e/it/xj8eitbqje5bpz5trubpbzav_qa.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Wie bin ich dazu gekommen?</b> <div class="spoiler_text"> Wie bin ich dazu gekommen?  Mein erstes Jahr bei der Firma war zu Ende und sie haben mich in ein brandneues E-Commerce-Projekt gesteckt.  Der Manager sagte, dass das Projekt in 4 Monaten abgeschlossen sein muss, aber das Backend-Team (auf Kundenseite) wird erst nach 1,5 Monaten mit der Entwicklung beginnen.  Und in dieser Zeit müssen wir schon viele UI-Features werfen. <br><br>  Ich schlug vor, ein Moch-Backend zu schreiben (bevor ich iOS-Entwickler wurde, spielte ich mit .NET in der Uni).  Die Implementierungsidee war einfach: Gemäß einer bestimmten Spezifikation mussten Stub-Methoden geschrieben werden, die Daten aus vorbereiteten JSON-Dateien entnehmen.  Sie entschieden sich dafür. <br><br>  Nach 2 Wochen fuhr ich in den Urlaub und dachte: "Warum erstelle ich das nicht automatisch?"  Für zwei Wochen Urlaub habe ich einen Anschein eines Interpreters geschrieben, der die APIBlueprint-Spezifikation verwendet und daraus die .NET-Webanwendung (C # -Code) generiert. <br><br>  Als Ergebnis erschien die erste Version dieses Dings und wir lebten fast 2,5 Monate davon.  Ich kann keine reellen Zahlen nennen, wie sehr uns das geholfen hat, aber ich erinnere mich, wie sie im Nachhinein gesagt haben, dass es ohne dieses System keine Veröffentlichung geben würde. <br><br>  Jetzt, nach einigen Jahren, habe ich die Fehler, die ich gemacht habe (und es gab viele), berücksichtigt und das Instrument komplett neu geschrieben. <br><br>  Nutzen Sie diese Gelegenheit - vielen Dank an Kollegen, die mit Feedback und Ratschlägen zur Seite standen.  Und auch an die Führer, die all meine „technischen Beliebigkeiten“ ertragen haben. <br></div></div><br><h3>  Einleitung </h3><br>  In der Regel sieht jede Client-Server-Anwendung folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/fs/bh/xa/fsbhxawsxnmbtygz0pxuc7-nbri.png"><br><br>  Jeder Bildschirm hat mindestens 1 Abfrage (und oft mehr).  Wenn wir tief in die Bildschirme vordringen, müssen wir immer mehr Anfragen stellen.  Manchmal können wir den Übergang erst dann durchführen, wenn der Server uns mitteilt, dass die Schaltfläche angezeigt werden soll.  Das heißt, die mobile Anwendung ist nicht nur während ihrer unmittelbaren Arbeit, sondern auch in der Entwicklungsphase stark an den Server gebunden.  Betrachten Sie den abstrakten Produktentwicklungszyklus: <br><br><img src="https://habrastorage.org/webt/xc/o6/pm/xco6pm2ekp91qzev1lgowrriyle.png"><br><br><ol><li>  Zuerst entwerfen wir.  Wir zerlegen, beschreiben und diskutieren. </li><li>  Nachdem wir die Aufgaben und Anforderungen erhalten haben, beginnen wir mit der Entwicklung.  Wir schreiben den Code, den Schriftsatz usw. </li><li>  Nachdem wir etwas implementiert haben, wird eine Baugruppe vorbereitet, die manuell getestet wird und in der die Anwendung auf verschiedene Fälle überprüft wird. </li><li>  Wenn bei uns alles in Ordnung ist und die Prüfer die Montage testen, geht es an den Kunden, der die Abnahme vornimmt. </li></ol><br>  Jeder dieser Prozesse ist sehr wichtig.  Vor allem letzteres, da der Kunde verstehen muss, in welchem ​​Stadium wir wirklich sind, und manchmal dem Management oder den Investoren über die Ergebnisse Bericht erstatten muss.  Solche Meldungen erfolgen in der Regel auch in Form einer Demonstration einer mobilen Anwendung.  In meiner Praxis gab es einen Fall, in dem ein Kunde nur die Hälfte des MVP vorführte, der nur mit Mokas funktionierte.  Die Mok-App sieht aus wie die Gegenwart und quakt wie die Gegenwart.  Es ist also real (: <br>  Dies ist jedoch ein rosa Traum.  Schauen wir uns an, was wirklich passiert, wenn wir keinen Server haben. <br><br><img src="https://habrastorage.org/webt/v6/gp/vp/v6gpvpbngkjv_mk4mnalkbxulpe.png"><br><br><ol><li>  Der Entwicklungsprozess wird langsamer und schmerzhafter, da wir normalerweise keine Dienste schreiben können und auch nicht alle Fälle überprüfen können. Wir müssen Stubs schreiben, die später entfernt werden müssen. </li><li>  Nachdem wir die Montage mit Kummer in zwei Hälften geschafft haben, kommt es zu Testern, die sich das ansehen und nicht verstehen, was sie damit anfangen sollen.  Sie können nichts überprüfen, die Hälfte funktioniert überhaupt nicht, da kein Server vorhanden ist.  Infolgedessen verpassen sie viele Fehler: sowohl logische als auch visuelle. </li><li>  Nun, nachdem "wie sie ausgesehen haben könnten", müssen Sie die Montage dem Kunden übergeben und dann beginnt die unangenehmste.  Der Kunde kann das Werk nicht wirklich bewerten, er sieht 1-2 Fälle von allen möglichen und kann es sicher nicht seinen Investoren zeigen. </li></ol><br>  Im Allgemeinen geht alles bergab.  Und solche Situationen kommen leider fast immer vor: Manchmal ist für einige Monate, manchmal für ein halbes Jahr kein Server vorhanden, manchmal kommt der Server gerade erst zu spät, oder Sie müssen schnell die Grenzfälle überprüfen, die mithilfe von Datenmanipulationen auf einem realen Server reproduziert werden können. <br><br>  Zum Beispiel möchten wir überprüfen, wie sich die Anwendung verhält, wenn die Zahlung des Benutzers länger als das Fälligkeitsdatum ist.  Es ist sehr schwierig (und lang), eine solche Situation auf dem Server zu reproduzieren, und wir müssen dies künstlich tun. <br><br>  Daher gibt es folgende Probleme: <br><br><ol><li>  Der Server fehlt vollständig.  Aus diesem Grund ist es unmöglich zu entwerfen, zu testen und zu präsentieren. </li><li>  Der Server hat keine Zeit, was die Entwicklung stört und das Testen beeinträchtigen kann. </li><li>  Wir möchten Grenzfälle testen, und der Server kann dies nicht ohne lange Gesten zulassen. </li><li>  Beeinflussen Sie das Testen und die Präsentation von Bedrohungen. </li><li>  Der Server stürzt ab (einmal, während der stabilen Entwicklung, haben wir den Server für 3,5 Tage verloren). </li></ol><br>  Um diese Probleme zu bekämpfen, wurde Mocker erstellt. <br><br><h3>  Arbeitsprinzip </h3><br>  Mocker ist ein kleiner Webdienst, der irgendwo gehostet wird, den Datenverkehr auf einem bestimmten Port überwacht und mit vorbereiteten Daten auf bestimmte Netzwerkanforderungen antworten kann. <br><br>  Die Reihenfolge ist wie folgt: <br><br>  1. Der Client sendet eine Anfrage. <br>  2. Mocker erhält die Anfrage. <br>  3. Mocker findet den gewünschten Spott. <br>  4. Mocker gibt den gewünschten Mock zurück. <br><br>  Wenn mit den Punkten 1,2 und 4 alles klar ist, wirft 3 Fragen auf. <br><br>  Um zu verstehen, wie der Service das für den Kunden notwendige Mock findet, betrachten wir zunächst die Struktur des Mocks selbst. <br><br>  Mock ist eine JSON-Datei im folgenden Format: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span> }</code> </pre> <br>  Lassen Sie uns jedes Feld separat analysieren. <br><br><h4>  url </h4><br>  Dieser Parameter wird verwendet, um die URL der Anforderung anzugeben, auf die der Client zugreift. <br><br>  Wenn eine mobile Anwendung beispielsweise eine Anforderung an die URL <code>host.dom/path/to/endpoint</code> , müssen Sie im Feld url <code>host.dom/path/to/endpoint</code> . <br>  Das heißt, dieses Feld speichert den <b>relativen Pfad zum Endpunkt</b> . <br><br>  Dieses Feld sollte im URL-Vorlagenformat formatiert sein, dh die folgenden Formate sind zulässig: <br><br><ol><li>  <code>/path/to/endpoint</code> - normale URL-Adresse.  Wenn die Anfrage eingeht, vergleicht der Dienst die Zeilen zeichenweise. </li><li>  <code>/path/to/endpoint/{number}</code> - URL mit Pfadmuster.  Ein Mock mit einer solchen URL antwortet auf jede Anfrage, die diesem Muster entspricht. </li><li>  <code>/path/to/endpoint/data?param={value}</code> - URL mit Parameter-Pattern.  Ein Mock mit einer solchen URL löst eine Anfrage mit den angegebenen Parametern aus.  Wenn einer der Parameter nicht in der Anforderung enthalten ist, stimmt er außerdem nicht mit der Vorlage überein. </li></ol><br>  Indem Sie die URL-Parameter steuern, können Sie eindeutig festlegen, dass ein bestimmter Mock zu einer bestimmten URL zurückkehrt. <br><br><h4>  Methode </h4><br>  Dies ist die erwartete http-Methode.  Zum Beispiel <code>POST</code> oder <code>GET</code> . <br>  Die Zeichenfolge darf nur Großbuchstaben enthalten. <br><br><h4>  statusCode </h4><br>  Dies ist der http-Statuscode für die Antwort.  Das heißt, durch Anfordern dieses Mocks erhält der Client eine Antwort mit dem im Feld statusCode aufgezeichneten Status. <br><br><h4>  Antwort </h4><br>  Dieses Feld enthält das JSON-Objekt, das im Hauptteil der Antwort auf seine Anforderung an den Client gesendet wird. <br><br><h4>  Anfrage </h4><br>  Dies ist der Hauptteil der Anforderung, von dem erwartet wird, dass er vom Client empfangen wird. Dies wird verwendet, um die gewünschte Antwort abhängig vom Hauptteil der Anforderung zu geben.  Zum Beispiel, wenn wir die Antworten in Abhängigkeit von den Anforderungsparametern ändern möchten. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/auth"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"token"</span></span>: <span class="hljs-string"><span class="hljs-string">"cbshbg52rebfzdghj123dsfsfasd"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Valid"</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/auth"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bad credentials"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Invalid"</span></span> } }</code> </pre><br>  Wenn der Client eine Anfrage an den Body sendet: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Valid"</span></span> }</code> </pre><br>  Dann erhält er als Antwort: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"token"</span></span>: <span class="hljs-string"><span class="hljs-string">"cbshbg52rebfzdghj123dsfsfasd"</span></span> }</code> </pre><br>  Und falls wir überprüfen möchten, wie die Anwendung funktioniert, wenn das Passwort falsch eingegeben wurde, wird eine Anfrage mit dem Text gesendet: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Invalid"</span></span> }</code> </pre><br>  Dann erhält er als Antwort: <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bad credentials"</span></span> }</code> </pre><br>  Und wir können den Fall mit dem falschen Passwort überprüfen.  Und so auch in allen anderen Fällen. <br><br>  Und jetzt werden wir herausfinden, wie das Gruppieren und Suchen nach dem gewünschten MOQ funktioniert. <br><br><img src="https://habrastorage.org/webt/3g/r4/yj/3gr4yj1z0c4pamlfipuvnoculhg.png"><br><br>  Um schnell und einfach nach dem gewünschten Mok zu suchen, lädt der Server alle Mokas in den Speicher und gruppiert sie richtig.  Das Bild oben zeigt ein Beispiel für die Gruppierung. <br><br>  Der Server kombiniert verschiedene Mokas nach <b>URL</b> und <b>Methode</b> .  Dies ist unter anderem notwendig, damit wir auf einer URL viele verschiedene Moks erstellen können. <br><br>  Zum Beispiel möchten wir, dass durch ständiges Ziehen von Pull-To-Refresh unterschiedliche Antworten kommen und sich der Status des Bildschirms ständig ändert (um alle Grenzfälle zu überprüfen). <br><br>  Dann können wir mit der gleichen <b>Methode</b> und den gleichen <b>URL-</b> Parametern viele verschiedene Moks erstellen, die der Server (wiederum) iterativ an uns zurückgibt. <br>  Lassen Sie uns zum Beispiel solche Mokas haben: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"product"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"gdshfjshhkfhsdgfhshdjgfhjkshdjkfsfgbjsfgskdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">100000000000</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre><br>  Wenn wir dann zum ersten Mal die Methode GET / products aufrufen, erhalten wir zuerst die Antwort: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"product"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }</code> </pre><br>  Wenn wir das zweite Mal aufrufen, wechselt der Iteratorzeiger zum nächsten Element und kehrt zu uns zurück: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"gdshfjshhkfhsdgfhshdjgfhjkshdjkfsfgbjsfgskdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">100000000000</span></span> }</code> </pre><br>  Und wir können überprüfen, wie sich die Anwendung verhält, wenn wir große Werte erhalten.  Usw. <br><br>  Wenn wir zum letzten Element gelangen und die Methode erneut aufrufen, wird das erste Element wieder zu uns zurückkehren, da der Iterator zum ersten Element zurückkehrt. <br><br><h3>  Proxy zwischenspeichern </h3><br>  Mocker kann im Caching-Proxy-Modus arbeiten.  Das heißt, wenn ein Dienst eine Anfrage von einem Client empfängt, entnimmt er die Adresse des Hosts, auf dem sich der reale Server befindet, und das Schema (zur Bestimmung des Protokolls).  Dann nimmt es die empfangene Anfrage (mit all ihren Headern, wenn die Methode eine Authentifizierung erfordert, ist es in Ordnung, dass Ihre <code>Authorization: Bearer ...</code> übertragen wird) und schneidet die Serviceinformationen daraus (derselbe <code>host</code> und das selbe <code>scheme</code> ) aus und sendet die Anfrage an den realen Server. <br><br>  Nach Erhalt der Antwort mit dem 200. Code speichert Mocker die Antwort in der Mock-Datei (ja, Sie können sie dann kopieren oder ändern) und gibt an den Client zurück, was er vom realen Server erhalten hat.  Darüber hinaus wird die Datei nicht nur an einem zufälligen Ort gespeichert, sondern auch so organisiert, dass Sie sie manuell bearbeiten können. Mocker sendet beispielsweise eine Anfrage an die folgende URL: <code>hostname.dom/main/products/loans/info</code> .  Dann wird ein <code>hostname.dom</code> Ordner erstellt, und in diesem wird ein Hauptordner erstellt, in dem sich ein Produktordner befindet. <br><br>  Um doppelte Mocks zu vermeiden, wird der Name auf Basis der <b>http-Methode</b> (GET, PUT ...) und eines <b>Hashes aus dem Antworttext des realen Servers gebildet</b> .  In diesem Fall wird eine bestimmte Antwort einfach überschrieben, wenn bereits eine falsche Antwort vorliegt. <br><br>  Diese Funktion kann für jede Anforderung einzeln aktiviert werden.  Fügen Sie dazu der Anfrage drei Header hinzu: <br><br><pre> <code class="plaintext hljs">X-Mocker-Redirect-Is-On: "true", X-Mocker-Redirect-Host: "hostaname.ex:1234", X-Mocker-Redirect-Scheme: "http"</code> </pre><br><h3>  Explizite Angabe des Pfades zu den Mocks </h3><br>  Manchmal möchten Sie, dass Mocker nur die Mokas zurückgibt, die wir möchten, und nicht alle, die im Projekt enthalten sind. <br><br>  Besonders relevant für Tester.  Es wäre für sie praktisch, für jeden der Testfälle einen vorbereiteten Satz von Mokas zu haben.  Und dann wählt QA während des Tests nur den Ordner aus, den es benötigt, und arbeitet leise, da keine Geräusche mehr von den Mocks von Drittanbietern zu hören sind. <br><br>  Das ist jetzt möglich.  Um diese Funktion zu aktivieren, müssen Sie einen speziellen Header verwenden: <br><br><pre> <code class="plaintext hljs">X-Mocker-Specific-Path: path</code> </pre><br>  Lassen Sie beispielsweise Mocker eine solche Ordnerstruktur im Stammverzeichnis haben <br><br><pre> <code class="plaintext hljs">root/ block_card_test_case/ mocks.... main_test_case/ blocked_test_case/ mocks...</code> </pre><br>  Wenn Sie einen Testfall über gesperrte Karten ausführen müssen, dann <br> <b><code>X-Mocker-Specific-Path: block_card_test_case</code></b> <br>  Wenn Sie einen Testfall ausführen müssen, der mit dem Sperren des Hauptbildschirms zusammenhängt, dann <br> <b><code>X-Mocker-Specific-Path: main_test_case/blocked_test_case</code></b> <br> <br><h3>  Schnittstelle </h3><br>  Zuerst haben wir mit Mokas direkt über ssh gearbeitet, aber mit der Zunahme der Anzahl von Mokas und Benutzern haben wir auf eine bequemere Option umgestellt.  Jetzt verwenden wir CloudCommander. <br>  Im Docker-Compose-Beispiel wird eine Bindung zum Mocker-Container hergestellt. <br><br>  Es sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/g8/ix/y2/g8ixy2mxaomzvo7zwknzhjf33jw.png"><br><br>  Nun, der Bonus ist ein Web-Editor, mit dem Sie Moki direkt über den Browser hinzufügen / ändern können. <br><br><img src="https://habrastorage.org/webt/2o/_d/ut/2o_dutkmga1j_dkuwor2isr4jxq.png"><br><br>  Dies ist auch eine vorübergehende Lösung.  In den Plänen, von der Arbeit mit Moks über das Dateisystem auf irgendeine Datenbank zu verzichten.  Dementsprechend ist es möglich, die Mokas selbst von der GUI zu dieser DB zu steuern. <br><br><h3>  Bereitstellung </h3><br>  Die einfachste Methode zum Bereitstellen von Mocker ist die Verwendung von Docker.  Darüber hinaus wird durch die Bereitstellung des Dienstes über den Docker automatisch eine webbasierte Schnittstelle bereitgestellt, über die die Arbeit mit Mokas bequemer ist.  Dateien, die für die Bereitstellung über Docker benötigt werden, befinden sich im Repository. <br><br>  Wenn Ihnen diese Option jedoch nicht zusagt, können Sie den Service unabhängig von der Quelle zusammenstellen.  Genug dafür: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/LastSprint/mocker.git cd mocker go build .</code> </pre><br>  Dann müssen Sie eine Konfigurationsdatei ( <a href="">Beispiel</a> ) schreiben und den Dienst starten: <br><br><pre> <code class="plaintext hljs">mocker config.json</code> </pre><br><h3>  Bekannte Probleme </h3><br><ul><li>  Nach jeder neuen Datei müssen Sie <code>curl mockerhost.dom/update_models</code> damit der Dienst die Dateien erneut liest.  Ich habe keine schnelle und elegante Möglichkeit gefunden, es anders zu aktualisieren </li><li>  Manchmal treten in CloudCommander Fehler auf (oder ich habe etwas falsch gemacht), und die Bearbeitung von Moki, die über die Weboberfläche erstellt wurden, ist nicht möglich.  Es wird durch Löschen des Browser-Cache behandelt. </li><li>  Der Dienst funktioniert nur mit <code>application/json</code> .  Die Pläne unterstützen die <code>form-url-encoding</code> . </li></ul><br><h3>  Zusammenfassung </h3><br>  Mocker ist ein Webdienst, der die Probleme bei der Entwicklung von Client-Server-Anwendungen löst, wenn der Server aus irgendeinem Grund nicht bereit ist. <br><br>  Mit dem Dienst können Sie viele verschiedene Mocks zu einer einzelnen URL erstellen, Request und Response durch explizite Angabe von Parametern in der URL miteinander verbinden oder den erwarteten Anforderungshauptteil direkt festlegen.  Der Dienst verfügt über eine webbasierte Oberfläche, die das Leben der Benutzer erheblich vereinfacht. <br><br>  Jeder Benutzer des Dienstes kann unabhängig den erforderlichen Endpunkt und die von ihm benötigte Anforderung hinzufügen.  In diesem Fall ist es auf dem Client ausreichend, die Konstante durch die Hostadresse zu ersetzen, um zu einem echten Server zu wechseln. <br><br>  Ich hoffe, dieser Artikel wird Menschen helfen, die unter ähnlichen Problemen leiden, und vielleicht werden wir zusammenarbeiten, um dieses Tool zu entwickeln. <br><br>  <a href="https://github.com/LastSprint/mocker">GitHub-Repository</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477506/">https://habr.com/ru/post/de477506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477496/index.html">Cracked Glass Mask - Ist es eine geplante PR?</a></li>
<li><a href="../de477498/index.html">Wir sammeln Protokolle von Nginx mit nginx-clickhouse, senden sie an Clickhouse und zeigen sie in Grafana an</a></li>
<li><a href="../de477500/index.html">Anwendungsmodell (Avalanche - Anwendungsframework für Java)</a></li>
<li><a href="../de477502/index.html">Fernarbeit eines gesunden Arbeitgebers</a></li>
<li><a href="../de477504/index.html">Die besten Praktiken für die App-Entwicklung, die es im Jahr 2020 zu befolgen gilt</a></li>
<li><a href="../de477508/index.html">Radarwarner: Noch ein paar Worte zur Ethik und viele Worte zu Gesetzen</a></li>
<li><a href="../de477510/index.html">Automatische Sicherung und Wiederherstellung von dynamischen Adresslisten auf Mikrotik</a></li>
<li><a href="../de477512/index.html">Schlacht von L2TP, RRAS gegen SoftEther</a></li>
<li><a href="../de477514/index.html">Hardware-Testautomatisierung für eingebettete Systeme</a></li>
<li><a href="../de477518/index.html">Knochenmikroarchitektur als Basis für ultraleichte und langlebige Materialien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>