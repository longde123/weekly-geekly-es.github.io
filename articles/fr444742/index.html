<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∂ üë®‚Äçüë¶ ‚≠êÔ∏è Index dans PostgreSQL - 5 (GiST) üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ ‚öúÔ∏è üêõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles pr√©c√©dents, nous avons discut√© du moteur d'indexation PostgreSQL, de l'interface des m√©thodes d'acc√®s et de deux m√©thodes d'acc√®s: l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  Dans les articles pr√©c√©dents, nous avons discut√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL, de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface des m√©thodes d'acc√®s</a> et de deux m√©thodes d'acc√®s: l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">index de hachage</a> et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescence B.</a>  Dans cet article, nous d√©crirons les index GiST. <br><br><h1>  Gist </h1><br>  GiST est l'abr√©viation de "arbre de recherche g√©n√©ralis√©".  Il s'agit d'un arbre de recherche √©quilibr√©, tout comme "l'arbre b" discut√© pr√©c√©demment. <br><br>  Quelle est la diff√©rence?  L'index "Btree" est strictement li√© √† la s√©mantique de comparaison: la prise en charge des op√©rateurs "sup√©rieur", "moins" et "√©gal" est tout ce dont il est capable (mais tr√®s capable!) Cependant, les bases de donn√©es modernes stockent les types de donn√©es pour lesquels ces op√©rateurs n'a aucun sens: g√©odonn√©es, documents texte, images, ... <br><br>  La m√©thode d'indexation GiST vient √† notre aide pour ces types de donn√©es.  Il permet de d√©finir une r√®gle pour distribuer des donn√©es de type arbitraire √† travers un arbre √©quilibr√© et une m√©thode pour utiliser cette repr√©sentation pour l'acc√®s par un op√©rateur.  Par exemple, l'index GiST peut "accueillir" l'arbre R pour les donn√©es spatiales avec prise en charge des op√©rateurs de position relative (situ√©s √† gauche, √† droite, contient, etc.) ou l'arbre RD pour les ensembles prenant en charge les op√©rateurs d'intersection ou d'inclusion. <br><br>  Gr√¢ce √† l'extensibilit√©, une m√©thode totalement nouvelle peut √™tre cr√©√©e √† partir de z√©ro dans PostgreSQL: √† cette fin, une interface avec le moteur d'indexation doit √™tre impl√©ment√©e.  Mais cela n√©cessite non seulement la pr√©m√©ditation de la logique d'indexation, mais √©galement le mappage des structures de donn√©es aux pages, la mise en ≈ìuvre efficace des verrous et la prise en charge d'un journal d'√©criture anticip√©e.  Tout cela suppose de hautes comp√©tences de d√©veloppeur et un gros effort humain.  GiST simplifie la t√¢che en prenant en charge les probl√®mes de bas niveau et en offrant sa propre interface: plusieurs fonctions relatives non pas aux techniques, mais au domaine d'application.  En ce sens, nous pouvons consid√©rer GiST comme un cadre pour la construction de nouvelles m√©thodes d'acc√®s. <br><a name="habracut"></a><br><h2>  La structure </h2><br>  GiST est un arbre √† hauteur √©quilibr√©e compos√© de pages de n≈ìuds.  Les n≈ìuds sont constitu√©s de lignes d'index. <br><br>  Chaque ligne d'un n≈ìud feuille (ligne feuille), en g√©n√©ral, contient un <em>pr√©dicat</em> (expression bool√©enne) et une r√©f√©rence √† une ligne de table (TID).  Les donn√©es index√©es (cl√©) doivent respecter ce pr√©dicat. <br><br>  Chaque ligne d'un n≈ìud interne (ligne interne) contient √©galement un <em>pr√©dicat</em> et une r√©f√©rence √† un n≈ìud enfant, et toutes les donn√©es index√©es du sous-arbre enfant doivent respecter ce pr√©dicat.  En d'autres termes, le pr√©dicat d'une ligne interne <em>inclut</em> les pr√©dicats de toutes les lignes enfants.  Ce trait important de l'index GiST remplace l'ordre simple de l'arbre B. <br><br>  La recherche dans l'arborescence GiST utilise une <em>fonction de coh√©rence</em> sp√©cialis√©e ("coh√©rente") - l'une des fonctions d√©finies par l'interface et impl√©ment√©e √† sa mani√®re pour chaque famille d'op√©rateurs prise en charge. <br><br>  La fonction de coh√©rence est appel√©e pour une ligne d'index et d√©termine si le pr√©dicat de cette ligne est coh√©rent avec le pr√©dicat de recherche (sp√©cifi√© comme " <em>expression d'op√©rateur de champ index√©</em> ").  Pour une ligne interne, cette fonction d√©termine en fait s'il faut descendre jusqu'au sous-arbre correspondant, et pour une ligne feuille, la fonction d√©termine si les donn√©es index√©es r√©pondent au pr√©dicat. <br><br>  La recherche commence par un n≈ìud racine, comme une recherche d'arbre normale.  La fonction de coh√©rence permet de savoir dans quels n≈ìuds enfants il est logique d'entrer (il peut y en avoir plusieurs) et lesquels non.  L'algorithme est ensuite r√©p√©t√© pour chaque n≈ìud enfant trouv√©.  Et si le n≈ìud est feuille, la ligne s√©lectionn√©e par la fonction de coh√©rence est renvoy√©e comme l'un des r√©sultats. <br><br>  La recherche est la profondeur d'abord: l'algorithme essaie d'abord d'atteindre un n≈ìud feuille.  Cela permet de renvoyer les premiers r√©sultats d√®s que possible (ce qui peut √™tre important si l'utilisateur n'est int√©ress√© que par plusieurs r√©sultats plut√¥t que par tous). <br><br>  Notons une fois de plus que la fonction de coh√©rence n'a rien √† voir avec les op√©rateurs "sup√©rieurs", "inf√©rieurs" ou "√©gaux".  La s√©mantique de la fonction de coh√©rence peut √™tre tr√®s diff√©rente et, par cons√©quent, l'indice n'est pas suppos√© renvoyer des valeurs dans un certain ordre. <br><br>  Nous ne discuterons pas des algorithmes d'insertion et de suppression de valeurs dans GiST: quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions d'interface</a> suppl√©mentaires effectuent ces op√©rations.  Il y a cependant un point important.  Lorsqu'une nouvelle valeur est ins√©r√©e dans l'index, la position de cette valeur dans l'arborescence est s√©lectionn√©e de sorte que les pr√©dicats de ses lignes parentes soient √©tendus le moins possible (id√©alement, pas du tout √©tendus).  Mais lorsqu'une valeur est supprim√©e, le pr√©dicat de la ligne parent n'est plus r√©duit.  Cela ne se produit que dans des cas comme ceux-ci: une page est divis√©e en deux (lorsque la page n'a pas assez d'espace pour l'insertion d'une nouvelle ligne d'index) ou l'index est recr√©√© √† partir de z√©ro (avec la commande REINDEX ou VACUUM FULL).  Par cons√©quent, l'efficacit√© de l'index GiST pour les donn√©es changeant fr√©quemment peut se d√©grader avec le temps. <br><br>  De plus, nous consid√©rerons quelques exemples d'index pour divers types de donn√©es et propri√©t√©s utiles de GiST: <br><br><ul><li>  Points (et autres entit√©s g√©om√©triques) et recherche des voisins les plus proches. </li><li>  Intervalles et contraintes d'exclusion. </li><li>  Recherche plein texte. </li></ul><br><h2>  Arbre R pour les points </h2><br>  Nous allons illustrer ce qui pr√©c√®de par l'exemple d'un index pour les points dans un plan (nous pouvons √©galement construire des index similaires pour d'autres entit√©s g√©om√©triques).  Un arbre B standard ne convient pas √† ce type de donn√©es car aucun op√©rateur de comparaison n'est d√©fini pour les points. <br><br>  L'id√©e de R-tree est de diviser le plan en rectangles qui couvrent au total tous les points index√©s.  Une ligne d'index stocke un rectangle, et le pr√©dicat peut √™tre d√©fini comme ceci: "le point recherch√© se trouve dans le rectangle donn√©". <br><br>  La racine de l'arbre R contiendra plusieurs grands rectangles (pouvant se croiser).  Les n≈ìuds enfants contiendront des rectangles de plus petite taille qui sont int√©gr√©s dans le parent et couvrent au total tous les points sous-jacents. <br><br>  En th√©orie, les n≈ìuds terminaux doivent contenir des points index√©s, mais le type de donn√©es doit √™tre le m√™me dans toutes les lignes d'index et, par cons√©quent, les rectangles sont √† nouveau stock√©s, mais ¬´r√©duits¬ª en points. <br><br>  Pour visualiser une telle structure, nous fournissons des images pour trois niveaux de l'arborescence R.  Les points sont les coordonn√©es des a√©roports (similaires √† celles du tableau "a√©roports" de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base de donn√©es de d√©monstration</a> , mais davantage de donn√©es sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">openflights.org</a> sont fournies). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Niveau un: deux grands rectangles se croisant sont visibles.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Niveau deux: les grands rectangles sont divis√©s en zones plus petites.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Niveau trois: chaque rectangle contient autant de points que pour tenir une page d'index.</em> <br><br>  Consid√©rons maintenant un exemple tr√®s simple "√† un niveau": <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Avec ce fractionnement, la structure de l'index se pr√©sentera comme suit: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  L'index cr√©√© peut √™tre utilis√© pour acc√©l√©rer la requ√™te suivante, par exemple: "trouver tous les points contenus dans le rectangle donn√©".  Cette condition peut √™tre formalis√©e comme suit: <code>p &lt;@ box '(2,1),(6,3)'</code> (op√©rateur <code>&lt;@</code> de la famille "points_ops" signifie "contenu dans"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  La fonction de coh√©rence de l'op√©rateur (" <em>indexed-field</em> &lt;@ <em>expression</em> ", o√π <em>indexed-field</em> est un point et l' <em>expression</em> est un rectangle) est d√©finie comme suit.  Pour une ligne interne, elle renvoie ¬´oui¬ª si son rectangle coupe le rectangle d√©fini par l' <em>expression</em> .  Pour une ligne feuille, la fonction renvoie "oui" si son point (rectangle "r√©duit") est contenu dans le rectangle d√©fini par l'expression. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  La recherche commence par le n≈ìud racine.  Le rectangle (2,1) - (7,4) coupe avec (1,1) - (6,3), mais ne coupe pas avec (5,5) - (8,8), par cons√©quent, il n'y a pas besoin pour descendre au deuxi√®me sous-arbre. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  En atteignant un n≈ìud feuille, nous passons par les trois points qui y sont contenus et retournons deux d'entre eux comme r√©sultat: (3.2) et (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Internes </h3><br>  Malheureusement, le "pageinspect" habituel ne permet pas d'examiner l'index GiST.  Mais une autre voie est disponible: l'extension "gevel".  Il n'est pas inclus dans la livraison standard, consultez donc <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les instructions d'installation</a> . <br><br>  Si tout est bien fait, trois fonctions seront √† votre disposition.  Tout d'abord, nous pouvons obtenir des statistiques: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Il est clair que la taille de l'index sur les coordonn√©es de l'a√©roport est de 690 pages et que l'index se compose de quatre niveaux: la racine et deux niveaux internes ont √©t√© montr√©s dans les figures ci-dessus, et le quatri√®me niveau est feuille. <br><br>  En fait, l'indice pour huit mille points sera beaucoup plus petit: ici, il a √©t√© cr√©√© avec un facteur de remplissage de 10% pour plus de clart√©. <br><br>  Deuxi√®mement, nous pouvons produire l'arbre d'index: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Et troisi√®mement, nous pouvons produire les donn√©es stock√©es dans des lignes d'index.  Notez la nuance suivante: le r√©sultat de la fonction doit √™tre converti en type de donn√©es requis.  Dans notre situation, ce type est "bo√Æte" (un rectangle englobant).  Par exemple, notez cinq lignes au niveau sup√©rieur: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  En fait, les chiffres fournis ci-dessus ont √©t√© cr√©√©s uniquement √† partir de ces donn√©es. <br><br><h2>  Op√©rateurs de recherche et de commande </h2><br>  Les op√©rateurs discut√©s jusqu'√† pr√©sent (tels que <code>&lt;@</code> dans le pr√©dicat <code>p &lt;@ box '(2,1),(7,4)'</code> ) peuvent √™tre appel√©s op√©rateurs de recherche car ils sp√©cifient les conditions de recherche dans une requ√™te. <br><br>  Il existe √©galement un autre type d'op√©rateur: les op√©rateurs de commande.  Ils sont utilis√©s pour les sp√©cifications de l'ordre de tri dans la clause ORDER BY au lieu des sp√©cifications conventionnelles des noms de colonne.  Voici un exemple d'une telle requ√™te: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> est ici une expression qui utilise un op√©rateur de classement <code>&lt;-&gt;</code> , qui d√©note la distance d'un argument √† l'autre.  La signification de la requ√™te est de renvoyer deux points les plus proches du point (4.7).  Une recherche comme celle-ci est connue sous le nom de k-NN - recherche du plus proche voisin. <br><br>  Pour prendre en charge les requ√™tes de ce type, une m√©thode d'acc√®s doit d√©finir une <em>fonction de distance</em> suppl√©mentaire et l'op√©rateur de commande doit √™tre inclus dans la classe d'op√©rateur appropri√©e (par exemple, la classe "points_ops" pour les points).  La requ√™te ci-dessous montre les op√©rateurs, ainsi que leurs types ("s" - recherche et "o" - classement): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Le nombre de strat√©gies est √©galement montr√©, avec leur signification expliqu√©e.  Il est clair qu'il existe bien plus de strat√©gies que pour "btree", seules certaines d'entre elles √©tant support√©es pour les points.  Diff√©rentes strat√©gies peuvent √™tre d√©finies pour d'autres types de donn√©es. <br><br>  La fonction distance est appel√©e pour un √©l√©ment d'index, et elle doit calculer la distance (en tenant compte de la s√©mantique de l'op√©rateur) √† partir de la valeur d√©finie par l'expression (" <em>expression d'op√©rateur de commande de champ index√©</em> ") √† l'√©l√©ment donn√©.  Pour un √©l√©ment feuille, il s'agit simplement de la distance √† la valeur index√©e.  Pour un √©l√©ment interne, la fonction doit renvoyer le minimum des distances aux √©l√©ments feuille enfant.  √âtant donn√© que parcourir toutes les lignes enfants serait assez co√ªteux, la fonction est autoris√©e √† sous-estimer la distance de mani√®re optimiste, mais au d√©triment de l'efficacit√© de la recherche.  Cependant, la fonction n'est jamais autoris√©e √† surestimer la distance car cela perturbera le travail de l'index. <br><br>  La fonction distance peut renvoyer des valeurs de n'importe quel type triable (pour ordonner les valeurs, PostgreSQL utilisera la s√©mantique de comparaison de la famille d'op√©rateurs appropri√©e de la m√©thode d'acc√®s "btree", comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crit pr√©c√©demment</a> ). <br><br>  Pour les points dans un plan, la distance est interpr√©t√©e dans un sens tr√®s courant: la valeur de <code>(x1,y1) &lt;-&gt; (x2,y2)</code> est √©gale √† la racine carr√©e de la somme des carr√©s des diff√©rences des abscisses et des ordonn√©es.  La distance entre un point et un rectangle englobant est consid√©r√©e comme la distance minimale entre le point et ce rectangle ou z√©ro si le point se trouve √† l'int√©rieur du rectangle.  Il est facile de calculer cette valeur sans parcourir les points enfants, et la valeur n'est certainement pas sup√©rieure √† la distance √† un point enfant. <br><br>  Consid√©rons l'algorithme de recherche pour la requ√™te ci-dessus. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  La recherche commence par le n≈ìud racine.  Le n≈ìud contient deux rectangles de d√©limitation.  La distance √† (1,1) - (6,3) est de 4,0 et √† (5,5) - (8,8) est de 1,0. <br><br>  Les n≈ìuds enfants sont parcourus dans l'ordre d'augmentation de la distance.  De cette fa√ßon, nous descendons d'abord au n≈ìud enfant le plus proche et calculons les distances aux points (nous afficherons les nombres sur la figure pour la visibilit√©): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Cette information suffit pour renvoyer les deux premiers points, (5,5) et (7,8).  Puisque nous sommes conscients que la distance aux points qui se trouvent dans le rectangle (1,1) - (6,3) est de 4,0 ou plus, nous n'avons pas besoin de descendre jusqu'au premier n≈ìud enfant. <br><br>  Et si nous devions trouver les <em>trois</em> premiers points? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Bien que le deuxi√®me n≈ìud enfant contienne tous ces points, nous ne pouvons pas retourner (8,6) sans regarder dans le premier n≈ìud enfant car ce n≈ìud peut contenir des points plus proches (depuis 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  Pour les lignes internes, cet exemple clarifie les exigences de la fonction de distance.  En s√©lectionnant une distance plus petite (4,0 au lieu de 4,5) pour la deuxi√®me ligne, nous avons r√©duit l'efficacit√© (l'algorithme a inutilement commenc√© √† examiner un n≈ìud suppl√©mentaire), mais n'a pas bris√© l'exactitude de l'algorithme. <br><br>  Jusqu'√† r√©cemment, GiST √©tait la seule m√©thode d'acc√®s capable de traiter les op√©rateurs de commande.  Mais la situation a chang√©: la m√©thode d'acc√®s RUM (√† discuter plus loin) a d√©j√† rejoint ce groupe de m√©thodes, et il n'est pas improbable qu'un bon vieil arbre B les rejoigne: un patch d√©velopp√© par Nikita Glukhov, notre coll√®gue, est en cours discut√© par la communaut√©. <br><blockquote>  Depuis mars 2019, le support k-NN est ajout√© pour SP-GiST dans le prochain PostgreSQL 12 (√©galement √©crit par Nikita).  Le patch pour B-tree est toujours en cours. <br></blockquote><br><h2>  Arborescence R pour les intervalles </h2><br>  Un autre exemple d'utilisation de la m√©thode d'acc√®s GiST est l'indexation des intervalles, par exemple les intervalles de temps (type "tsrange").  Toute la diff√©rence est que les n≈ìuds internes contiendront des intervalles de d√©limitation au lieu de rectangles de d√©limitation. <br><br>  Prenons un exemple simple.  Nous allons louer un chalet et enregistrer les intervalles de r√©servation dans un tableau: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  L'index peut √™tre utilis√© pour acc√©l√©rer la requ√™te suivante, par exemple: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> op√©rateur <code>&amp;&amp;</code> pour les intervalles indique l'intersection;  par cons√©quent, la requ√™te doit renvoyer tous les intervalles intersectant celui sp√©cifi√©.  Pour un tel op√©rateur, la fonction de coh√©rence d√©termine si l'intervalle donn√© intersecte avec une valeur dans une ligne interne ou feuille. <br><br>  Notez qu'il ne s'agit pas d'obtenir des intervalles dans un certain ordre, bien que les op√©rateurs de comparaison soient d√©finis pour les intervalles.  Nous pouvons utiliser l'index "btree" pour les intervalles, mais dans ce cas, nous devrons nous passer de la prise en charge d'op√©rations comme celles-ci: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Sauf l'√©galit√©, qui est contenue dans la classe d'op√©rateur pour la m√©thode d'acc√®s "btree".) <br><br><h3>  Internes </h3><br>  On peut regarder √† l'int√©rieur en utilisant la m√™me extension "gevel".  Nous devons seulement nous rappeler de changer le type de donn√©es dans l'appel √† gist_print: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Contrainte d'exclusion </h2><br>  L'index GiST peut √™tre utilis√© pour prendre en charge les contraintes d'exclusion (EXCLUDE). <br><br>  La contrainte d'exclusion garantit que les champs donn√©s de deux lignes de table ne se "correspondent" pas en fonction de certains op√©rateurs.  Si l'op√©rateur "√©gal" est choisi, nous obtenons exactement la contrainte unique: les champs donn√©s de deux lignes quelconques ne sont pas √©gaux. <br><br>  La contrainte d'exclusion est prise en charge par l'index, ainsi que la contrainte unique.  Nous pouvons choisir n'importe quel op√©rateur pour que: <br><br><ol><li>  Il est pris en charge par la m√©thode d'index - propri√©t√© "can_exclude" (par exemple, "btree", GiST ou SP-GiST, mais pas GIN). </li><li>  Elle est commutative, c'est-√†-dire que la condition est remplie: a op√©rateur b = b op√©rateur a. </li></ol><br>  Voici une liste de strat√©gies appropri√©es et d'exemples d'op√©rateurs (les op√©rateurs, comme nous nous en souvenons, peuvent avoir des noms diff√©rents et ne pas √™tre disponibles pour tous les types de donn√©es): <br><br><ul><li>  Pour "btree": <br><ul><li>  "√âgale" <code>=</code> </li></ul></li><li>  Pour GiST et SP-GiST: <br><ul><li>  "Intersection" <code>&amp;&amp;</code> </li><li>  "Co√Øncidence" <code>~=</code> </li><li>  Adjacence <code>-|-</code> </li></ul></li></ul><br>  Notez que nous pouvons utiliser l'op√©rateur d'√©galit√© dans une contrainte d'exclusion, mais ce n'est pas pratique: une contrainte unique sera plus efficace.  C'est exactement pourquoi nous n'avons pas abord√© les contraintes d'exclusion lorsque nous avons discut√© des arbres B. <br><br>  Donnons un exemple d'utilisation d'une contrainte d'exclusion.  Il est raisonnable de ne pas autoriser de r√©servations pour des intervalles qui se croisent. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Une fois que nous avons cr√©√© la contrainte d'exclusion, nous pouvons ajouter des lignes: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Mais une tentative d'ins√©rer un intervalle d'intersection dans la table entra√Ænera une erreur: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Extension "Btree_gist" </h3><br>  Compliquons le probl√®me.  Nous d√©veloppons notre modeste activit√©, et nous allons louer plusieurs chalets: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Nous devons changer la contrainte d'exclusion afin que les num√©ros de maison soient pris en compte.  GiST, cependant, ne prend pas en charge l'op√©ration d'√©galit√© pour les nombres entiers: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Dans ce cas, l'extension " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">btree_gist</a> " sera utile, ce qui ajoute la prise en charge GiST des op√©rations inh√©rentes aux arbres B.  GiST, √† terme, peut prendre en charge tous les op√©rateurs, alors pourquoi ne devrions-nous pas lui apprendre √† prendre en charge les op√©rateurs ¬´plus grands¬ª, ¬´moins¬ª et ¬´√©gaux¬ª? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Maintenant, nous ne pouvons toujours pas r√©server le premier chalet pour les m√™mes dates: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Cependant, nous pouvons r√©server le second: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Mais sachez que bien que GiST puisse en quelque sorte prendre en charge les op√©rateurs "sup√©rieurs", "inf√©rieurs" et "√©gaux", B-tree le fait toujours mieux.  Il ne vaut donc la peine d'utiliser cette technique que si l'index GiST est essentiellement n√©cessaire, comme dans notre exemple. <br><br><h2>  Arbre RD pour la recherche en texte int√©gral </h2><br><h3>  √Ä propos de la recherche en texte int√©gral </h3><br>  Commen√ßons par une introduction minimaliste √† la recherche en texte int√©gral de PostgreSQL (si vous √™tes au courant, vous pouvez ignorer cette section). <br><br>  La t√¢che de recherche en texte int√©gral consiste √† s√©lectionner dans l'ensemble de documents les documents qui <em>correspondent √†</em> la requ√™te de recherche.  (S'il existe de nombreux documents correspondants, il est important de trouver <em>la meilleure correspondance</em> , mais nous n'en dirons rien √† ce stade.) <br><br>  √Ä des fins de recherche, un document est converti en un type sp√©cialis√© "tsvector", qui contient des <em>lex√®mes</em> et leurs positions dans le document.  Les lex√®mes sont des mots convertis au format appropri√© pour la recherche.  Par exemple, les mots sont g√©n√©ralement convertis en minuscules et les terminaisons variables sont coup√©es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Nous pouvons √©galement voir que certains mots (appel√©s <em>mots vides</em> ) sont totalement supprim√©s ("l√†", "√©tait", "un", "et", "il") car ils se produisent probablement trop souvent pour que leur recherche ait un sens.  Toutes ces conversions peuvent certainement √™tre configur√©es, mais c'est une autre histoire. <br><br>  Une requ√™te de recherche est repr√©sent√©e avec un autre type: "tsquery".  En gros, une requ√™te consiste en un ou plusieurs lex√®mes joints par des connecteurs: "et" &amp;, "ou" |, "pas"! .. Nous pouvons √©galement utiliser des parenth√®ses pour clarifier la priorit√© des op√©rations. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Un seul op√©rateur de correspondance <code>@@</code> est utilis√© pour la recherche en texte int√©gral. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Cette information suffit pour l'instant.  Nous approfondirons un peu la recherche en texte int√©gral dans un prochain article qui pr√©sente l'index GIN. <br><br><h3>  Arbres RD </h3><br>  Pour une recherche de texte int√©gral rapide, d'une part, la table doit stocker une colonne de type "tsvector" (pour √©viter d'effectuer une conversion co√ªteuse √† chaque fois lors de la recherche) et d'autre part, un index doit √™tre construit sur cette colonne.  GiST est l'une des m√©thodes d'acc√®s possibles pour cela. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Il est, certes, commode de confier un d√©clencheur √† la derni√®re √©tape (conversion du document en "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  Comment l‚Äôindice doit-il √™tre structur√©?  L'utilisation directe de R-tree n'est pas une option car on ne sait pas comment d√©finir un "rectangle englobant" pour les documents.  Mais nous pouvons appliquer une certaine modification de cette approche pour les ensembles, un soi-disant arbre RD (RD signifie "Russian Doll").  Un ensemble est consid√©r√© comme un ensemble de lex√®mes dans ce cas, mais en g√©n√©ral, un ensemble peut √™tre n'importe lequel. <br><br>  Une id√©e des arbres RD est de remplacer un rectangle englobant par un ensemble englobant, c'est-√†-dire un ensemble contenant tous les √©l√©ments des ensembles enfants. <br><br>  Une question importante se pose de savoir comment repr√©senter les ensembles dans les lignes d'index.  La mani√®re la plus simple consiste simplement √† √©num√©rer tous les √©l√©ments de l'ensemble.  Cela pourrait ressembler √† ceci: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Ensuite, par exemple, pour l'acc√®s par la condition <code>doc_tsv @@ to_tsquery('sit')</code> nous ne pouvions descendre que vers les n≈ìuds qui contiennent le lex√®me "sit": <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Cette repr√©sentation pr√©sente des probl√®mes √©vidents.  Le nombre de lex√®mes dans un document peut √™tre assez important, les lignes d'index auront donc une grande taille et entreront dans TOAST, ce qui rend l'index beaucoup moins efficace.  M√™me si chaque document a peu de lex√®mes uniques, l'union des ensembles peut toujours √™tre tr√®s grande: plus la racine est √©lev√©e, plus les lignes d'index sont grandes. <br><br>  Une repr√©sentation comme celle-ci est parfois utilis√©e, mais pour d'autres types de donn√©es.  Et la recherche en texte int√©gral utilise une autre solution, plus compacte - un soi-disant <em>arbre de signature</em> .  Son id√©e est bien connue de tous ceux qui ont trait√© du filtre Bloom. <br><br>  Chaque lex√®me peut √™tre repr√©sent√© avec sa <em>signature</em> : une cha√Æne de bits d'une certaine longueur o√π tous les bits sauf un sont nuls.  La position de ce bit est d√©termin√©e par la valeur de la fonction de hachage du lex√®me (nous avons discut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©demment des</a> fonctions internes des fonctions de hachage). <br><br>  La signature du document est le OU au niveau du bit des signatures de tous les lex√®mes de document. <br><br>  Supposons les signatures de lex√®mes suivantes: <br><br><pre> pourrait 1000000
 jamais 0001000
 bon 0000010
 mani 0000100
 feuille 0000100
 0100000 le plus √©l√©gant
 asseoir 0010000
 fente 0001000
 refendeur 0000001
 au 0000010
 quiconque 0010000
</pre><br>  Ensuite, les signatures des documents sont comme celles-ci: <br><br><pre> Une feuille peut-elle refendre des feuilles fendues?  0001101
 Combien de feuilles une fente-feuille peut-elle refendre?  1001101
 J'ai fendu une feuille, une feuille que j'ai fendue.  0001100
 Sur une feuille fendue, je m'assois.  0011110
 Celui qui a fendu les feuilles est un bon refendeur de feuilles.  0011111
 Je suis une d√©coupeuse de feuilles.  0000101
 J'ai fendu des draps.  0001100
 Je suis la d√©coupeuse de feuilles la plus √©l√©gante qui ait jamais fendu des feuilles.  0101101
 Elle fend le drap sur lequel elle est assise.  0011100
</pre><br>  L'arbre d'index peut √™tre repr√©sent√© comme suit: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Les avantages de cette approche sont √©vidents: les lignes d'index ont des tailles √©gales et un tel index est compact.  Mais un inconv√©nient est √©galement clair: la pr√©cision est sacrifi√©e √† la compacit√©. <br><br>  Consid√©rons la m√™me condition <code>doc_tsv @@ to_tsquery('sit')</code> .  Et calculons la signature de la requ√™te de recherche de la m√™me mani√®re que pour le document: 0010000 dans ce cas.  La fonction de coh√©rence doit renvoyer tous les n≈ìuds enfants dont les signatures contiennent au moins un bit de la signature de requ√™te: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Comparez avec la figure ci-dessus: nous pouvons voir que l'arbre est devenu jaune, ce qui signifie que des faux positifs se produisent et que des n≈ìuds excessifs sont pass√©s pendant la recherche.  Ici, nous avons ramass√© le lex√®me "qui que ce soit", dont la signature √©tait malheureusement la m√™me que la signature du lex√®me "assis".  Il est important qu'aucun faux n√©gatif ne puisse se produire dans le motif, c'est-√†-dire que nous sommes s√ªrs de ne pas manquer les valeurs n√©cessaires. <br><br>  En outre, il peut arriver que diff√©rents documents obtiennent √©galement les m√™mes signatures: dans notre exemple, les documents malchanceux sont "je tranche une feuille, une feuille je tranche" et "je tranche des feuilles" (les deux portent la signature 0001100).  Et si une ligne d'index feuille ne stocke pas la valeur de "tsvector", l'index lui-m√™me donnera des faux positifs.  Bien s√ªr, dans ce cas, la m√©thode demandera au moteur d'indexation de rev√©rifier le r√©sultat avec la table, de sorte que l'utilisateur ne verra pas ces faux positifs.  Mais l'efficacit√© de la recherche peut √™tre compromise. <br><br>  En fait, une signature fait 124 octets dans l'impl√©mentation actuelle au lieu de 7 bits dans les figures, donc les probl√®mes ci-dessus sont beaucoup moins susceptibles de se produire que dans l'exemple.  Mais en r√©alit√©, beaucoup plus de documents sont √©galement index√©s.  Pour r√©duire en quelque sorte le nombre de faux positifs de la m√©thode d'indexation, l'impl√©mentation devient un peu d√©licate: le "tsvector" index√© est stock√© dans une ligne d'index feuille, mais seulement si sa taille n'est pas grande (un peu moins de 1/16 de une page, soit environ un demi-kilo-octet pour les pages de 8 Ko). <br><br><h3>  Exemple </h3><br>  Pour voir comment l'indexation fonctionne sur des donn√©es r√©elles, prenons l'archive des e-mails "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La version utilis√©e dans l'exemple</a> contient 356125 messages avec la date d'envoi, le sujet, l'auteur et le texte: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Ajout et remplissage de la colonne de type "tsvector" et construction de l'index.  Ici, nous joindrons trois valeurs dans un vecteur (sujet, auteur et texte du message) pour montrer que le document n'a pas besoin d'√™tre un champ, mais peut √™tre compos√© de parties arbitraires totalement diff√©rentes. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Comme nous pouvons le voir, un certain nombre de mots ont √©t√© supprim√©s en raison d'une taille trop grande.  Mais l'index est finalement cr√©√© et peut prendre en charge les requ√™tes de recherche: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Nous pouvons voir qu'avec 898 lignes correspondant √† la condition, la m√©thode d'acc√®s a renvoy√© 7859 lignes suppl√©mentaires qui ont √©t√© filtr√©es en rev√©rifiant avec la table.  Cela d√©montre un impact n√©gatif de la perte de pr√©cision sur l'efficacit√©. <br><br><h3>  Internes </h3><br>  Pour analyser le contenu de l'index, nous utiliserons √† nouveau l'extension "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Les valeurs du type sp√©cialis√© "gtsvector" qui sont stock√©es dans des lignes d'index sont en fait la signature plus, peut-√™tre, la source "tsvector".  Si le vecteur est disponible, la sortie contient le nombre de lex√®mes (mots uniques), sinon, le nombre de vrais et faux bits dans la signature. <br><br>  Il est clair que dans le n≈ìud racine, la signature a d√©g√©n√©r√© en "tous les uns", c'est-√†-dire qu'un niveau d'index est devenu absolument inutile (et un autre est devenu presque inutile, avec seulement quatre faux bits). <br><br><h2>  Propri√©t√©s </h2><br>  Examinons les propri√©t√©s de la m√©thode d'acc√®s GiST (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont √©t√© fournies plus t√¥t</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  Le tri des valeurs et la contrainte unique ne sont pas pris en charge.  Comme nous l'avons vu, l'index peut √™tre construit sur plusieurs colonnes et utilis√© dans les contraintes d'exclusion. <br><br>  Les propri√©t√©s de couche d'index suivantes sont disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Et les propri√©t√©s les plus int√©ressantes sont celles de la couche de colonne.  Certaines propri√©t√©s sont ind√©pendantes des classes d'op√©rateurs: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (Le tri n'est pas pris en charge; l'index ne peut pas √™tre utilis√© pour rechercher un tableau; les valeurs NULL sont prises en charge.) <br><br>  Mais les deux propri√©t√©s restantes, "distance_orderable" et "returnable", d√©pendront de la classe d'op√©rateur utilis√©e.  Par exemple, pour les points, nous obtiendrons: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  La premi√®re propri√©t√© indique que l'op√©rateur de distance est disponible pour rechercher les voisins les plus proches.  Et le second indique que l'index peut √™tre utilis√© pour l'analyse uniquement par index.  Bien que les lignes d'index des feuilles stockent des rectangles plut√¥t que des points, la m√©thode d'acc√®s peut renvoyer ce qui est n√©cessaire. <br><br>  Voici les propri√©t√©s des intervalles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Pour les intervalles, la fonction de distance n'est pas d√©finie et par cons√©quent, la recherche des voisins les plus proches n'est pas possible. <br><br>  Et pour la recherche plein texte, nous obtenons: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  La prise en charge de l'analyse d'index uniquement a √©t√© perdue car les lignes de feuille peuvent contenir uniquement la signature sans les donn√©es elles-m√™mes.  Cependant, il s'agit d'une perte mineure car personne ne s'int√©resse de toute fa√ßon √† la valeur de type "tsvector": cette valeur est utilis√©e pour s√©lectionner des lignes, alors que c'est le texte source qui doit √™tre affich√©, mais qui est de toute fa√ßon manquant dans l'index. <br><br><h2>  Autres types de donn√©es </h2><br>  Enfin, nous mentionnerons quelques autres types qui sont actuellement pris en charge par la m√©thode d'acc√®s GiST en plus des types g√©om√©triques d√©j√† discut√©s (par exemple de points), des intervalles et des types de recherche en texte int√©gral. <br><br>  Parmi les types standard, il s'agit du type " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inet</a> " pour les adresses IP.  Tout le reste est ajout√© via des extensions: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cube</a> fournit le type de donn√©es "cube" pour les cubes multidimensionnels.  Pour ce type, tout comme pour les types g√©om√©triques dans un plan, la classe d'op√©rateur GiST est d√©finie: R-tree, prenant en charge la recherche des plus proches voisins. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seg</a> fournit le type de donn√©es "seg" pour les intervalles avec des limites sp√©cifi√©es avec une certaine pr√©cision et ajoute la prise en charge de l'index GiST pour ce type de donn√©es (arbre R). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intarray</a> √©tend les fonctionnalit√©s des tableaux entiers et leur prend en charge GiST.  Deux classes d'op√©rateurs sont impl√©ment√©es: "gist__int_ops" (arbre RD avec une repr√©sentation compl√®te des cl√©s dans les lignes d'index) et "gist__bigint_ops" (arbre RD de signature).  La premi√®re classe peut √™tre utilis√©e pour les petits tableaux, et la seconde - pour les plus grandes tailles. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ltree</a> ajoute le type de donn√©es ¬´ltree¬ª pour les structures arborescentes et la prise en charge GiST pour ce type de donn√©es (RD-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_trgm</a> ajoute une classe d'op√©rateur sp√©cialis√©e "gist_trgm_ops" pour l'utilisation des trigrammes dans la recherche en texte int√©gral.  Mais cela doit √™tre discut√© plus loin, avec l'indice GIN. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444742/">https://habr.com/ru/post/fr444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444728/index.html">Comme j'ai √©crit et publi√© un livre sur l'Universit√© d'√âtat de Moscou, ou 12 erreurs critiques</a></li>
<li><a href="../fr444730/index.html">Pourquoi la technologie sans serveur est une r√©volution dans la gestion des produits</a></li>
<li><a href="../fr444732/index.html">Optimisation des performances apache2</a></li>
<li><a href="../fr444734/index.html">Habraseminar: de vraies histoires sur le marketing de contenu</a></li>
<li><a href="../fr444738/index.html">Pixel art: du brouillon √† l'actif du jeu</a></li>
<li><a href="../fr444744/index.html">Envoi de courrier √† l'aide de PHP</a></li>
<li><a href="../fr444746/index.html">Nous vous invitons au MskDotNet Meetup # 34 √† Raiffeisenbank upd Broadcast</a></li>
<li><a href="../fr444748/index.html">3 qualit√©s cl√©s d'un chef de produit performant: Yuri Golikov, VP Engineering Wrike</a></li>
<li><a href="../fr444752/index.html">L'histoire de SXSW: comment tout a commenc√©</a></li>
<li><a href="../fr444756/index.html">La DARPA d√©veloppera un moteur nucl√©aire de fus√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>