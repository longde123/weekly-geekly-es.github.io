<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 ☮️ ☑️ Bypass Pitfall Angular dan Penghematan Waktu 🔶 🎗️ 💆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan Angular, Anda dapat melakukan apa saja. Atau hampir semuanya. Tetapi kadang-kadang “hampir” yang berbahaya ini mengarah pada fakta bahwa pengem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bypass Pitfall Angular dan Penghematan Waktu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459304/">  Dengan Angular, Anda dapat melakukan apa saja.  Atau hampir semuanya.  Tetapi kadang-kadang “hampir” yang berbahaya ini mengarah pada fakta bahwa pengembang membuang-buang waktu dengan menciptakan solusi, atau mencoba memahami mengapa sesuatu terjadi, atau mengapa sesuatu tidak berfungsi seperti yang diharapkan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/bl/sj/vq/blsjvqaqs4fhtnqmscwlw7lx0zs.jpeg"></a> <br><br>  Penulis artikel yang kami terjemahkan hari ini mengatakan ia ingin berbagi kiat yang akan membantu pengembang Angular menghemat waktu.  Dia akan berbicara tentang perangkap Angular, yang dia (dan bukan hanya dia) memiliki kesempatan untuk bertemu. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1</font>  <font color="#3AC1EF">Arahan khusus yang Anda terapkan tidak berfungsi</font> </h2><br>  Jadi, Anda menemukan arahan pihak ketiga yang bagus dan memutuskan untuk menggunakannya dengan elemen standar di templat Angular.  Hebat!  Mari kita coba lakukan ini: <br><br><pre><code class="javascript hljs">&lt;span awesomeTooltip=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Anda memulai aplikasi ... Dan tidak ada yang terjadi.  Anda, seperti programmer normal dan berpengalaman lainnya, memeriksa konsol Alat Pengembang Chrome.  Dan Anda tidak melihat apa pun di sana.  Arahan tidak berfungsi dan Angular diam. <br><br>  Kemudian beberapa kepala cemerlang dari tim Anda memutuskan untuk menempatkan arahan dalam tanda kurung. <br><br><pre> <code class="javascript hljs">&lt;span [awesomeTooltip]=<span class="hljs-string"><span class="hljs-string">"'Tooltip text'"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Setelah itu, setelah kehilangan sedikit waktu, kami melihat yang berikut di konsol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/532/4aa/95f/5324aa95f7aa2d0d1a20e74f93953eb1.png"></div><br>  <i><font color="#999999">Begini masalahnya: kami hanya lupa mengimpor modul dengan arahan</font></i> <br><br>  Sekarang penyebab masalahnya cukup jelas: kami hanya lupa mengimpor modul direktif ke modul aplikasi Angular. <br>  Ini mengarah pada aturan penting: jangan pernah gunakan arahan tanpa tanda kurung. <br><br>  Anda dapat bereksperimen dengan arahan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">2</font>  <font color="#3AC1EF">ViewChild mengembalikan undefined</font> </h2><br>  Misalkan Anda membuat tautan ke elemen entri teks yang dijelaskan dalam templat Angular. <br><br><pre> <code class="javascript hljs">&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> name=<span class="hljs-string"><span class="hljs-string">"fname"</span></span> #inputTag&gt;</code> </pre> <br>  Anda akan pergi, menggunakan fungsi RxJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fromEvent</a> , untuk membuat aliran ke mana apa yang dimasukkan ke dalam bidang akan jatuh.  Untuk melakukan ini, Anda memerlukan tautan ke bidang input, yang dapat diperoleh menggunakan dekorator Angular <code>ViewChild</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{    @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) inputTag: ElementRef;    ngAfterViewInit(){        <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputTag.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyUp'</span></span>)    } ...   }</code> </pre> <br>  Di sini, menggunakan fungsi RxJS <code>fromEvent</code> , kami membuat aliran ke mana data yang dimasukkan ke dalam bidang akan jatuh. <br>  Uji kode ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f0/504/558/4f0504558e9daf73a87d78da7f00fb04.png"></div><br>  <i><font color="#999999">Kesalahan</font></i> <br><br>  Apa yang terjadi <br><br>  Bahkan, aturan berikut ini berlaku di sini: jika <code>ViewChild</code> mengembalikan yang <code>undefined</code> , cari <code>*ngIf</code> di templat. <br><br><pre> <code class="javascript hljs">&lt;div *ngIf=<span class="hljs-string"><span class="hljs-string">"someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Di sini dia adalah pelakunya. <br><br>  Selain itu, periksa template untuk arahan struktural lain atau <code>ng-template</code> atas elemen masalah. <br>  Pertimbangkan kemungkinan solusi untuk masalah ini. <br><br><h3>  <font color="#3AC1EF">▍Variant untuk memecahkan masalah №1</font> </h3><br>  Anda bisa menyembunyikan elemen template jika tidak membutuhkannya.  Dalam hal ini, elemen akan selalu terus ada dan <code>ViewChild</code> akan dapat mengembalikan tautan ke sana di kait <code>ngAfterViewInit</code> . <br><br><pre> <code class="javascript hljs">&lt;div [hidden]=<span class="hljs-string"><span class="hljs-string">"!someCondition"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fname"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inputTag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Variant untuk memecahkan masalah №2</font> </h3><br>  Cara lain untuk mengatasi masalah ini adalah dengan menggunakan setter. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{   @ViewChild(<span class="hljs-string"><span class="hljs-string">'inputTag'</span></span>) set inputTag(input: ElementRef|<span class="hljs-literal"><span class="hljs-literal">null</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(input);  }  doSomething(input) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input$ = keysfromEvent(input.nativeElement, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>);    ...  } }</code> </pre> <br>  Di sini, segera setelah Angular memberikan nilai tertentu ke properti <code>inputTag</code> , kami membuat aliran dari data yang dimasukkan di bidang input. <br><br>  Berikut adalah beberapa sumber daya bermanfaat yang terkait dengan masalah ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca bahwa hasil <code>ViewChild</code> di Angular 8 bisa statis dan dinamis. </li><li>  Jika Anda kesulitan bekerja dengan RxJs - lihat kursus video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . </li></ul><br><h2>  <font color="#3AC1EF">Nomor 3</font>  <font color="#3AC1EF">Eksekusi kode ketika memperbarui daftar yang dihasilkan dengan * ngFor (setelah elemen muncul di DOM)</font> </h2><br>  Misalkan Anda memiliki beberapa arahan khusus yang menarik untuk mengatur daftar yang dapat digulir.  Anda akan menerapkannya ke daftar yang dibuat menggunakan <code>*ngFor</code> Angular <code>*ngFor</code> . <br><br><pre> <code class="javascript hljs">&lt;div *ngFor=<span class="hljs-string"><span class="hljs-string">"let item of itemsList; let i = index;"</span></span>     [customScroll]     &gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"list-item"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>   &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br>  Biasanya, dalam kasus seperti itu, ketika memperbarui daftar, Anda perlu memanggil sesuatu seperti <code>scrollDirective.update</code> untuk mengkonfigurasi perilaku pengguliran, dengan mempertimbangkan perubahan yang telah terjadi dalam daftar. <br><br>  Tampaknya ini bisa dilakukan dengan menggunakan pengait <code>ngOnChanges</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnChanges</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  ngOnChanges(changes) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changes.itemsList) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update();    }  } ... }</code> </pre> <br>  Benar, di sini kita dihadapkan dengan masalah.  Pengait dipanggil sebelum browser menampilkan daftar yang diperbarui.  Akibatnya, perhitungan ulang parameter direktif untuk menggulir daftar dilakukan dengan tidak benar. <br><br>  Bagaimana cara melakukan panggilan tepat setelah <code>*ngFor</code> selesai bekerja? <br><br>  Anda dapat melakukan ini dengan mengikuti 3 langkah sederhana ini: <br><br><h3>  <font color="#3AC1EF">▍Langkah nomor 1</font> </h3><br>  Letakkan tautan ke elemen tempat <code>*ngFor</code> ( <code>#listItems</code> ) <code>#listItems</code> . <br><br><pre> <code class="javascript hljs">&lt;div [customScroll]&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"let item of items"</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">listItems</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{item}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Langkah nomor 2</font> </h3><br>  Dapatkan daftar elemen-elemen ini menggunakan dekorator <code>ViewChildren</code> Angular.  Ini mengembalikan entitas tipe <code>QueryList</code> . <br><br><h3>  <font color="#3AC1EF">▍Langkah nomor 3</font> </h3><br>  Kelas <code>QueryList</code> memiliki properti <a href="">perubahan</a> hanya baca yang <code>QueryList</code> acara setiap kali daftar berubah. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{  @Input() itemsList = [];   @ViewChild(CustomScrollDirective) scroll: CustomScrollDirective;  @ViewChildren(<span class="hljs-string"><span class="hljs-string">'listItems'</span></span>) listItems: QueryList&lt;any&gt;;  private sub: Subscription;   ngAfterViewInit() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sub = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listItems.changes.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scroll.update())  } ... }</code> </pre> <br>  Sekarang masalahnya teratasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat bereksperimen dengan contoh yang sesuai. <br><br><h2>  <font color="#3AC1EF">Nomor 4</font>  <font color="#3AC1EF">Masalah dengan ActivatedRoute.queryParam yang Terjadi Ketika Kueri Dapat Dijalankan Tanpa Parameter</font> </h2><br>  Kode berikut akan membantu kami memahami inti dari masalah ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app-routing.module.ts const routes: Routes = [    {path: '', redirectTo: '/home', pathMatch: 'full'},    {path: 'home', component: HomeComponent},  ];   @NgModule({    imports: [RouterModule.forRoot(routes)], //  #1    exports: [RouterModule]  })  export class AppRoutingModule { }    //app.module.ts  @NgModule({    ...    bootstrap: [AppComponent] //  #2  })  export class AppModule { }   // app.component.html  &lt;router-outlet&gt;&lt;/router-outlet&gt; //  #3    // app.component.ts  export class AppComponent implements OnInit {    title = 'QueryTest';     constructor(private route: ActivatedRoute) { }     ngOnInit() {      this.route.queryParams          .subscribe(params =&gt; {            console.log('saveToken', params); //  #4          });    }  }</span></span></code> </pre> <br>  Beberapa fragmen dari kode ini dibuat komentar seperti <code> #x</code> .  Pertimbangkan mereka: <br><br><ol><li>  Dalam modul utama aplikasi, kami mendefinisikan rute dan menambahkan <code>RouterModule</code> sana.  Rute dikonfigurasikan sehingga jika rute tidak disediakan dalam URL, kami mengarahkan pengguna ke halaman <code>/home</code> . </li><li>  Sebagai komponen untuk mengunduh, kami menentukan dalam modul utama <code>AppComponent</code> . </li><li>  <code>AppComponent</code> menggunakan <code>&lt;router-outlet&gt;</code> untuk menampilkan komponen rute yang sesuai. </li><li>  Sekarang yang paling penting.  Kami perlu mendapatkan <code>queryParams</code> untuk rute dari URL </li></ol><br>  Misalkan kita mendapat URL berikut: <br><br><pre> <code class="javascript hljs">https:<span class="hljs-comment"><span class="hljs-comment">//localhost:4400/home?accessToken=someTokenSequence</span></span></code> </pre> <br>  Dalam hal ini, <code>queryParams</code> akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: <span class="hljs-string"><span class="hljs-string">'someTokenSequence'</span></span>}</code> </pre> <br>  Mari kita lihat pekerjaan semua ini di browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29f/aef/ae5/29faefae56d8e01e314cb6eab9fae6dc.png"></div><br>  <i><font color="#999999">Menguji aplikasi yang mengimplementasikan sistem perutean</font></i> <br><br>  Di sini Anda mungkin memiliki pertanyaan tentang esensi masalah.  Kami mendapat parameter, semuanya berfungsi seperti yang diharapkan ... <br><br>  Lihatlah screenshot browser di atas, dan apa yang ditampilkan di konsol.  Di sini Anda dapat melihat bahwa objek <code>queryParams</code> dikeluarkan dua kali.  Objek pertama kosong, dikeluarkan selama proses inisialisasi router Angular.  Hanya setelah itu kita mendapatkan objek yang berisi parameter permintaan (dalam kasus kami - <code>{accessToken: 'someTokenSequence'}</code> ). <br><br>  Masalahnya adalah bahwa jika tidak ada parameter permintaan di URL, router tidak akan mengembalikan apa pun.  Artinya - setelah mengeluarkan objek kosong pertama, objek kedua, juga kosong, yang bisa menunjukkan tidak adanya parameter, tidak akan dikeluarkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e16/1b7/8be/e161b78be5051b1ee9f9ca1ec2c9d31a.png"></div><br>  <i><font color="#999999">Saat menjalankan permintaan tanpa parameter, objek kedua tidak dikeluarkan</font></i> <br><br>  Akibatnya, ternyata jika kode mengharapkan objek kedua dari mana ia dapat menerima data permintaan, maka itu tidak akan diluncurkan jika tidak ada parameter permintaan di URL. <br><br>  Bagaimana cara mengatasi masalah ini?  Di sini, RxJ dapat membantu kami.  Kami akan membuat dua objek yang dapat diamati berdasarkan <code>ActivatedRoute.queryParams</code> .  Seperti biasa - pertimbangkan solusi langkah demi langkah untuk masalah tersebut. <br><br><h3>  <font color="#3AC1EF">▍Langkah nomor 1</font> </h3><br>  Objek yang dapat diamati pertama, <code>paramsInUrl$</code> , akan <code>paramsInUrl$</code> data jika <code>queryParams</code> tidak kosong: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );     ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Langkah nomor 2</font> </h3><br>  Objek yang dapat diamati kedua, <code>noParamsInUrl$</code> , akan <code>noParamsInUrl$</code> nilai kosong hanya jika tidak ada parameter permintaan yang ditemukan di URL: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {                 ...        <span class="hljs-comment"><span class="hljs-comment">//   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );            ...    } }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Langkah nomor 3</font> </h3><br>  Sekarang gabungkan objek yang diamati menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabungan</a> RxJS: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">'QueryTest'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private route: ActivatedRoute,                private locationService: Location) {    }    ngOnInit() {             <span class="hljs-comment"><span class="hljs-comment">//            //              const paramsInUrl$ = this.route.queryParams.pipe(            filter(params =&gt; Object.keys(params).length &gt; 0)        );        //   ,     ,   URL        //             const noParamsInUrl$ = this.route.queryParams.pipe(            filter(() =&gt; !this.locationService.path().includes('?')),            map(() =&gt; ({}))        );        const params$ = merge(paramsInUrl$, noParamsInUrl$);        params$.subscribe(params =&gt; {            console.log('saveToken', params);        });    } }</span></span></code> </pre> <br>  Sekarang <code>param$</code> object yang diamati <code>param$</code> nilai hanya sekali - terlepas dari apakah sesuatu <code>queryParams</code> dalam <code>queryParams</code> (objek dengan parameter kueri <code>queryParams</code> ) atau tidak (objek kosong <code>queryParams</code> ). <br><br>  Anda dapat bereksperimen dengan kode ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">No. 5.</font>  <font color="#3AC1EF">Halaman Lambat</font> </h2><br>  Misalkan Anda memiliki komponen yang menampilkan beberapa data yang diformat: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of items"&gt;     &lt;span&gt;{{formatItem(item)}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts export class HomeComponent {    items = [1, 2, 3, 4, 5, 6];    mouseCoordinates = {};    formatItem(item) {              //           const t = Array.apply(null, Array(5)).map(() =&gt; 1);             console.log('formatItem');        return item + '%';    } }</span></span></code> </pre> <br>  Komponen ini memecahkan dua masalah: <br><br><ol><li>  Ini menampilkan array elemen (diasumsikan bahwa operasi ini dilakukan sekali).  Selain itu, memformat apa yang ditampilkan dengan memanggil metode <code>formatItem</code> . </li><li>  Ini menampilkan koordinat mouse (nilai ini jelas akan sangat sering diperbarui). </li></ol><br>  Anda tidak mengharapkan komponen ini memiliki masalah kinerja.  Karena itu, jalankan uji kinerja hanya untuk mematuhi semua formalitas.  Namun, beberapa keanehan muncul selama tes ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/015/97d/621/01597d6210a35f37a8030702c0b71753.png"></div><br>  <i><font color="#999999">Banyak panggilan formatItem dan beban CPU yang cukup banyak</font></i> <br><br>  Ada apa?  Tetapi kenyataannya adalah bahwa ketika Angular menggambar ulang templat, ia memanggil semua fungsi dari templat (dalam kasus kami, fungsi <code>formatItem</code> ).  Akibatnya, jika ada perhitungan berat yang dilakukan dalam fungsi templat, ini akan membuat prosesor tertekan dan memengaruhi cara pengguna melihat laman terkait. <br><br>  Bagaimana cara memperbaikinya?  Cukup dengan melakukan perhitungan yang dilakukan dalam <code>formatItem</code> sebelumnya, dan menampilkan data yang sudah siap di halaman. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// home.component.html &lt;div class="wrapper" (mousemove)="mouseCoordinates = {x: $event.x, y: $event.y}"&gt;  &lt;div *ngFor="let item of displayedItems"&gt;    &lt;span&gt;{{item}}&lt;/span&gt;  &lt;/div&gt; &lt;/div&gt; {{mouseCoordinates | json}} // home.component.ts @Component({    selector: 'app-home',    templateUrl: './home.component.html',    styleUrls: ['./home.component.sass'] }) export class HomeComponent implements OnInit {    items = [1, 2, 3, 4, 5, 6];    displayedItems = [];    mouseCoordinates = {};    ngOnInit() {        this.displayedItems = this.items.map((item) =&gt; this.formatItem(item));    }    formatItem(item) {        console.log('formatItem');        const t = Array.apply(null, Array(5)).map(() =&gt; 1);        return item + '%';    } }</span></span></code> </pre> <br>  Sekarang tes kinerja terlihat jauh lebih baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/f49/118/2cef4911810ce0a506dd0697ee801119.png"></div><br>  <i><font color="#999999">Hanya 6 panggilan formatItem dan beban prosesor yang rendah</font></i> <br><br>  Sekarang aplikasi bekerja lebih baik.  Tetapi solusi yang digunakan di sini memiliki beberapa fitur yang tidak selalu menyenangkan: <br><br><ul><li>  Karena kami menampilkan koordinat mouse di templat, acara <code>mousemove</code> masih memicu pemeriksaan perubahan.  Tapi, karena kita membutuhkan koordinat mouse, kita tidak bisa menyingkirkan ini. </li><li>  Jika pengendali acara <code>mousemove</code> hanya perlu melakukan beberapa perhitungan (yang tidak mempengaruhi apa yang ditampilkan pada halaman), maka untuk mempercepat aplikasi, Anda dapat melakukan hal berikut: <br><br><ol><li>  Anda dapat menggunakan <code>NgZone.runOutsideOfAngular</code> di dalam fungsi event handler.  Ini mencegah pemeriksaan perubahan dari mulai ketika peristiwa <code>mousemove</code> (ini hanya akan mempengaruhi penangan ini). </li><li>  Anda dapat mencegah patch zone.js untuk beberapa acara dengan menggunakan baris kode berikut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfills.ts</a> .  Ini akan memengaruhi seluruh aplikasi Angular. </li></ol></li></ul><br><pre> <code class="javascript hljs">* (<span class="hljs-built_in"><span class="hljs-built_in">window</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).__zone_symbol__UNPATCHED_EVENTS = [<span class="hljs-string"><span class="hljs-string">'scroll'</span></span>, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br>  Jika Anda tertarik pada masalah peningkatan kinerja aplikasi Angular - di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - bahan yang berguna tentang ini. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Sekarang Anda telah membaca artikel ini, 5 alat baru akan muncul di gudang pengembang Angular Anda yang dengannya Anda dapat memecahkan beberapa masalah umum.  Kami harap tips yang Anda temukan di sini membantu Anda menghemat waktu. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda tahu sesuatu yang membantu Anda menghemat waktu saat mengembangkan aplikasi Angular? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459304/">https://habr.com/ru/post/id459304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459294/index.html">Apa yang lebih penting: untuk mengetahui bahasa pemrograman atau untuk dapat memecahkan masalah bisnis?</a></li>
<li><a href="../id459296/index.html">Harga JavaScript 2019</a></li>
<li><a href="../id459298/index.html">Sudut: status pada 2019</a></li>
<li><a href="../id459300/index.html">Quasar 1.0: alat berguna baru untuk pengembang Vue dan tidak hanya untuk mereka</a></li>
<li><a href="../id459302/index.html">Mencoba ulang permintaan HTTP yang gagal di Angular</a></li>
<li><a href="../id459306/index.html">Perenderan server di lingkungan tanpa server</a></li>
<li><a href="../id459308/index.html">SEO tidak berfungsi di 2019?</a></li>
<li><a href="../id459310/index.html">Alat uji otomatisasi atau penguji steroid seluler</a></li>
<li><a href="../id459312/index.html">Dear Agile, aku muak berpura-pura</a></li>
<li><a href="../id459314/index.html">Visualisasikan dan hadapi Hash Match Join</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>