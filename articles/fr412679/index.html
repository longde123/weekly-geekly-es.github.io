<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß üßïüèæ üí∑ Cr√©ation d'une application Android pour la reconnaissance de texte en 10 minutes. Mobile Vision CodeLab ü¶ç üß¶ ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Version vid√©o du tutoriel 
 
 

 La reconnaissance optique de caract√®res ( OCR ) offre √† l'ordinateur la possibilit√© de lire du texte dans une image, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'une application Android pour la reconnaissance de texte en 10 minutes. Mobile Vision CodeLab</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412679/"><h2>  Version vid√©o du tutoriel </h2><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mIEfqtn9nts" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<p> <em>La reconnaissance optique de caract√®res</em> ( <strong>OCR</strong> ) offre √† l'ordinateur la possibilit√© de lire du texte dans une image, permettant aux applications de comprendre les signes, les articles, les d√©pliants, les pages de texte, les menus ou tout autre √©l√©ment sous forme de texte.  <code>Mobile Vision Text API</code> fournit aux d√©veloppeurs <code>Android</code> une fonction <code>OCR</code> puissante et fiable qui prend en charge la plupart <code>Android</code> appareils <code>Android</code> et n'augmente pas la taille de votre application. </p><br><p>  Dans ce didacticiel, vous allez cr√©er une application dans laquelle tout le texte tombant dans le cadre sera reconnu et lu pendant le processus d'enregistrement vid√©o. <a name="habracut"></a></p><br><p>  Nous avons √©galement publi√© des articles sur d'autres fonctionnalit√©s de Mobile Vision: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reconnaissance d'objets et d'√©motions humaines</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reconnaissance faciale</a> ; </li></ul><br><p>  Le code source peut √™tre t√©l√©charg√© <a href="">ici</a> . </p><br><p>  Ou clonez le r√©f√©rentiel <code>GitHub</code> partir de la ligne de commande: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/googlesamples/android-vision.git</code> </pre> <br><p>  Le r√©f√©rentiel <code>visionSamples</code> contient de nombreux exemples de projets li√©s √† <code>Mobile Vision</code> .  Seuls deux sont utilis√©s dans cette le√ßon: </p><br><ul><li> <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <strong>ocr-codelab / ocr-reader-start</strong> est le code initial que vous utiliserez dans cette le√ßon. </li><li> <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <strong>ocr-codelab / ocr-reader-complete</strong> - le code complet pour l'application termin√©e.  Vous pouvez l'utiliser pour d√©panner ou aller directement √† l'application de travail. </li></ul><br><h2>  Mise √† jour des services Google Play </h2><br><p>  Vous devrez peut-√™tre mettre √† niveau votre version install√©e de <code>Google Repository</code> pour utiliser l' <code>Mobile Vision Text API</code> . </p><br><p>  Ouvrez <code>Android Studio</code> et ouvrez le <code>SDK Manager</code> : </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/c24/18f/c09c2418f842d747bb135a7d868c4931.png" width="240" height="117"><br><p><br>  Assurez-vous que le <code>Google Repository</code> jour.  Ce doit √™tre au moins la version <code>26</code> . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/55f/a3f/0ee/55fa3f0ee048bc97f5b14b9fff7734ea.png" width="750" height="502"><br><p></p><br><h2>  Ajouter une d√©pendance aux services Google Play et cr√©er une application de lancement </h2><br><p>  Vous pouvez maintenant ouvrir le projet de d√©marrage: </p><br><ol><li><p>  Choisissez un r√©pertoire de lancement <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <code>ocr-reader</code> partir du code t√©l√©charg√© ( <strong>Fichier</strong> &gt; <strong>Ouvrir</strong> &gt; <code>ocr-codelab/ocr-reader-start</code> ). </p><br></li><li><p>  Ajoutez la d√©pendance des <code>Google Play Services</code> √† l'application.  Sans cette d√©pendance, l' <code>Text API</code> ne sera pas disponible. </p><br></li></ol><br><p>  Le projet peut indiquer l'absence du <strong>fichier entier / google_play_services_version</strong> et donner une erreur.  C'est normal, nous le corrigerons √† l'√©tape suivante. </p><br><p>  Ouvrez le fichier <code>build.gradle</code> dans le module d' <code>app</code> et modifiez le bloc de d√©pendance pour y inclure la d√©pendance <code>play-services-vision</code> .  Lorsque tout est pr√™t, le fichier devrait ressembler √† ceci: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">implementation</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: [<span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>]) implementation <span class="hljs-string"><span class="hljs-string">'com.android.support:support-v4:26.1.0'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'com.android.support:design:26.1.0'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'com.google.android.gms:play-services-vision:15.0.0'</span></span> }</code> </pre> <br><ol><li><p>  Cliquez sur <img src="https://habrastorage.org/getpro/habr/post_images/f7d/f74/7c5/f7df747c534410a9c0391d47de0bb0e3.png" width="21" height="21">  Bouton de synchronisation <code>Gradle</code> . </p><br></li><li><p>  Cliquez sur <img src="https://habrastorage.org/getpro/habr/post_images/82f/7df/0d1/82f7df0d1dce3d570e7c35d7d8fb4575.png" width="22" height="23">  bouton de d√©marrage. </p><br></li></ol><br><p>  Apr√®s quelques secondes, vous verrez l'√©cran Lire le texte, mais ce n'est qu'un √©cran noir. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/e98/6dc/c41e986dc883fb67fe0caf0760e99378.png" width="349" height="621"><br><p><br>  Rien ne se passe actuellement car <code>CameraSource</code> pas configur√©.  Faisons-le. </p><br><p>  Si vous ne r√©ussissez pas, vous pouvez ouvrir un projet <strong><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d51/ef8/1e8d51ef802bcde6a7d36bf83490b24d.png" width="22" height="22"></strong>  <code>ocr-reader-complete</code> et assurez-vous qu'il fonctionne correctement.  Ce projet est une version pr√™te √† l'emploi de la le√ßon, et si cette version ne fonctionne pas, vous devez v√©rifier que tout est en ordre avec votre appareil et <code>Android Studio</code> param√®tres d' <code>Android Studio</code> . </p><br><h2>  Configurer TextRecognizer et CameraSource </h2><br><p>  Pour commencer, nous allons cr√©er notre <code>TextRecognizer</code> .  Cet objet d√©tecteur traite les images et d√©termine le texte qui appara√Æt √† l'int√©rieur.  Apr√®s l'initialisation, <code>TextRecognizer</code> peut √™tre utilis√© pour d√©tecter du texte dans tous les types d'images.  Recherchez la m√©thode <code>createCameraSource</code> et cr√©ez un <code>TextRecognizer</code> : </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCameraSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> autoFocus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useFlash)</span></span></span><span class="hljs-function"> </span></span>{ Context context = getApplicationContext(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if the TextRecognizer is operational. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the mCameraSource using the TextRecognizer. }</span></span></code> </pre> <br><p>  <code>TextRecognizer</code> maintenant pr√™t √† <code>TextRecognizer</code> .  Cependant, il se peut que cela ne fonctionne pas encore.  Si l'appareil ne dispose pas de suffisamment de m√©moire ou si <code>Google Play Services</code> ne peuvent pas charger les d√©pendances <code>OCR</code> , l'objet <code>TextRecognizer</code> ne fonctionnera pas.  Avant de commencer √† l'utiliser pour la reconnaissance de texte, nous devons v√©rifier qu'il est pr√™t.  Nous ajouterons cette v√©rification √† <code>createCameraSource</code> apr√®s avoir initialis√© <code>TextRecognizer</code> : </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if the TextRecognizer is operational. if (!textRecognizer.isOperational()) { Log.w(TAG, "Detector dependencies are not yet available."); // Check for low storage. If there is low storage, the native library will not be // downloaded, so detection will not become operational. IntentFilter lowstorageFilter = new IntentFilter(Intent.ACTION_DEVICE_STORAGE_LOW); boolean hasLowStorage = registerReceiver(null, lowstorageFilter) != null; if (hasLowStorage) { Toast.makeText(this, R.string.low_storage_error, Toast.LENGTH_LONG).show(); Log.w(TAG, getString(R.string.low_storage_error)); } }</span></span></code> </pre> <br><p>  Maintenant que nous avons v√©rifi√© que <code>TextRecognizer</code> pr√™t √† l'emploi, nous pouvons l'utiliser pour reconna√Ætre des cadres individuels.  Mais nous voulons faire quelque chose de plus int√©ressant: lire le texte en mode vid√©o.  Pour ce faire, nous allons cr√©er une <code>CameraSource</code> pr√©-configur√©e pour contr√¥ler la cam√©ra.  Nous devons d√©finir une haute r√©solution pour la prise de vue et activer la mise au point automatique pour faire face √† la t√¢che de reconnaissance des petits textes.  Si vous √™tes s√ªr que vos utilisateurs regarderont de gros blocs de texte, par exemple des signes, vous pouvez utiliser une r√©solution inf√©rieure, puis le traitement des cadres sera plus rapide: </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Create the cameraSource using the TextRecognizer. cameraSource = new CameraSource.Builder(getApplicationContext(), textRecognizer) .setFacing(CameraSource.CAMERA_FACING_BACK) .setRequestedPreviewSize(1280, 1024) .setRequestedFps(15.0f) .setFlashMode(useFlash ? Camera.Parameters.FLASH_MODE_TORCH : null) .setFocusMode(autoFocus ? Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO : null) .build();</span></span></code> </pre> <br><p>  Voici √† quoi devrait ressembler la m√©thode <code>createCameraSource</code> : </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCameraSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> autoFocus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useFlash)</span></span></span><span class="hljs-function"> </span></span>{ Context context = getApplicationContext(); <span class="hljs-comment"><span class="hljs-comment">// Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. // Check if the TextRecognizer is operational. if (!textRecognizer.isOperational()) { Log.w(TAG, "Detector dependencies are not yet available."); // Check for low storage. If there is low storage, the native library will not be // downloaded, so detection will not become operational. IntentFilter lowstorageFilter = new IntentFilter(Intent.ACTION_DEVICE_STORAGE_LOW); boolean hasLowStorage = registerReceiver(null, lowstorageFilter) != null; if (hasLowStorage) { Toast.makeText(this, R.string.low_storage_error, Toast.LENGTH_LONG).show(); Log.w(TAG, getString(R.string.low_storage_error)); } } // Create the cameraSource using the TextRecognizer. cameraSource = new CameraSource.Builder(getApplicationContext(), textRecognizer) .setFacing(CameraSource.CAMERA_FACING_BACK) .setRequestedPreviewSize(1280, 1024) .setRequestedFps(15.0f) .setFlashMode(useFlash ? Camera.Parameters.FLASH_MODE_TORCH : null) .setFocusMode(autoFocus ? Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO : null) .build(); }</span></span></code> </pre> <br><p>  Si vous ex√©cutez l'application, vous verrez que la vid√©o a commenc√©!  Mais pour traiter les images de la cam√©ra, nous devons ajouter ce dernier <code>TODO</code> √† <code>createCameraSource</code> : cr√©er un <code>Processor</code> pour traiter le texte √† son arriv√©e. </p><br><h2>  Cr√©ation de OcrDetectorProcessor </h2><br><p>  Votre application peut d√©sormais d√©tecter du texte sur des cadres individuels √† l'aide de la m√©thode de d√©couverte de <code>TextRecognizer</code> .  Ainsi, vous pouvez trouver du texte, par exemple, sur une photo.  Mais pour lire le texte directement pendant l'enregistrement vid√©o, vous devez impl√©menter un <code>Processor</code> qui traitera le texte d√®s qu'il appara√Ætra √† l'√©cran. </p><br><p>  Acc√©dez √† la classe <code>OcrDetectorProcessor</code> impl√©mentez l'interface <code>Detector.Processor</code> : </p><br><p>  <em>OcrDetectorProcessor.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OcrDetectorProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Detector</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextBlock</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GraphicOverlay&lt;OcrGraphic&gt; graphicOverlay; OcrDetectorProcessor(GraphicOverlay&lt;OcrGraphic&gt; ocrGraphicOverlay) { graphicOverlay = ocrGraphicOverlay; } }</code> </pre> <br><p>  Pour impl√©menter cette interface, vous devez remplacer deux m√©thodes.  Le premier, <code>receiveDetections</code> , re√ßoit les <code>TextBlocks</code> de <code>TextRecognizer</code> lorsqu'ils sont d√©tect√©s.  La seconde, <code>release</code> , est utilis√©e pour lib√©rer des ressources lorsqu'un <code>TextRecognizer</code> d√©truit.  Dans ce cas, il suffit d'effacer le canevas graphique, ce qui entra√Ænera la suppression de tous les objets <code>OcrGraphic</code> . </p><br><p>  Nous obtiendrons <code>TextBlocks</code> et <code>OcrGraphic</code> objets <code>OcrGraphic</code> pour chaque bloc de texte d√©tect√© par le processeur.  Nous impl√©mentons la logique de leur dessin dans l'√©tape suivante. </p><br><p>  <em>OcrDetectorProcessor.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiveDetections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Detector.Detections&lt;TextBlock&gt; detections)</span></span></span><span class="hljs-function"> </span></span>{ graphicOverlay.clear(); SparseArray&lt;TextBlock&gt; items = detections.getDetectedItems(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.size(); ++i) { TextBlock item = items.valueAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; item.getValue() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Log.d(<span class="hljs-string"><span class="hljs-string">"Processor"</span></span>, <span class="hljs-string"><span class="hljs-string">"Text detected! "</span></span> + item.getValue()); OcrGraphic graphic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OcrGraphic(graphicOverlay, item); graphicOverlay.add(graphic); } } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ graphicOverlay.clear(); }</code> </pre> <br><p>  Maintenant que le processeur est pr√™t, nous devons configurer <code>textRecognizer</code> pour l'utiliser.  Revenez au dernier <code>TODO</code> restant dans la m√©thode <code>OcrCaptureActivity</code> dans <code>OcrCaptureActivity</code> : </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Create the TextRecognizer TextRecognizer textRecognizer = new TextRecognizer.Builder(context).build(); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set the TextRecognizer's Processor. textRecognizer.setProcessor(new OcrDetectorProcessor(graphicOverlay));</span></span></code> </pre> <br><p>  Ex√©cutez maintenant l'application.  √Ä ce stade, lorsque vous passez la cam√©ra sur du texte, vous verrez les messages de d√©bogage "Texte d√©tect√©!"  dans <code>Android Monitor Logcat</code> !  Mais ce n'est pas une fa√ßon tr√®s visuelle de visualiser ce que <code>TextRecognizer</code> voit, non? </p><br><p>  Dans l'√©tape suivante, nous allons dessiner ce texte √† l'√©cran. </p><br><h2>  Dessin de texte √† l'√©cran </h2><br><p>  <code>OcrGraphic</code> m√©thode <code>draw</code> dans <code>OcrGraphic</code> .  Nous devons comprendre s'il y a du texte dans l'image, convertir les coordonn√©es de ses bordures en cadres de toile, puis dessiner √† la fois les bordures et le texte. </p><br><p>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Draw the text onto the canvas. if (text == null) { return; } // Draws the bounding box around the TextBlock. RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); canvas.drawRect(rect, rectPaint); // Render the text at the bottom of the box. canvas.drawText(text.getValue(), rect.left, rect.bottom, textPaint); }</span></span></code> </pre> <br><p>  Lancez l'application et testez-la sur cet exemple de texte: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9f9/62d/41d/9f962d41d7ee963958a8bbc2f88b97ec.png" width="663" height="169"><br><p>  Vous devriez voir qu'un cadre appara√Æt √† l'√©cran avec du texte dedans!  Vous pouvez jouer avec la couleur du texte en utilisant <code>TEXT_COLOR</code> . </p><br><p>  Et √ßa? </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8f2/09a/d7c/8f209ad7cd7ae77245abaa3250ea91d2.png" width="621" height="441"><br><p>  Le cadre autour du texte semble correct, mais le texte est en bas. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/0ef/ec1/8dc0efec1d11dadff02a2ca7aa83d752.png" width="351" height="622"><br><p><br>  En effet, le moteur transf√®re tout le texte qu'il reconna√Æt dans le <code>TextBlock</code> comme une seule phrase, m√™me s'il voit une phrase divis√©e en plusieurs lignes.  Si vous avez besoin d'obtenir toute l'offre, c'est tr√®s pratique.  Mais que faire si vous voulez savoir o√π se trouve chaque ligne de texte individuelle? </p><br><p>  Vous pouvez obtenir des <code>Lines</code> partir d'un <code>TextBlock</code> en appelant <code>getComponents</code> , puis, en triant chaque ligne, vous pouvez facilement obtenir son emplacement et le texte qu'il <code>getComponents</code> .  Cela vous permet de dessiner du texte √† l'endroit o√π il appara√Æt r√©ellement. </p><br><p>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Draw the text onto the canvas. if (text == null) { return; } // Draws the bounding box around the TextBlock. RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); canvas.drawRect(rect, rectPaint); // Break the text into multiple lines and draw each one according to its own bounding box. List&lt;? extends Text&gt; textComponents = text.getComponents(); for(Text currentText : textComponents) { float left = translateX(currentText.getBoundingBox().left); float bottom = translateY(currentText.getBoundingBox().bottom); canvas.drawText(currentText.getValue(), left, bottom, textPaint); } }</span></span></code> </pre> <br><p>  Essayez √† nouveau ce texte: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/8f2/09a/d7c/8f209ad7cd7ae77245abaa3250ea91d2.png" width="655" height="465"><br><p>  Super!  Vous pouvez m√™me diviser le texte trouv√© en composants encore plus petits, en fonction de vos besoins.  Vous pouvez appeler <code>getComponents</code> sur chaque ligne et obtenir des <code>Elements</code> (mots latins).  Il est possible de configurer <code>textSize</code> sorte que le texte occupe autant d'espace que le texte r√©el √† l'√©cran. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/102/3e0/2d2/1023e02d2d8659ec0a4d51662241037e.png" width="349" height="620"><br><p></p><br><h2>  Lire du texte lorsque vous cliquez dessus </h2><br><p>  Maintenant, le texte de la cam√©ra est converti en lignes structur√©es et ces lignes s'affichent √† l'√©cran.  Faisons autre chose avec eux. </p><br><p>  En utilisant l' <code>TextToSpeech API</code> int√©gr√©e √† <code>Android</code> et la m√©thode <code>OcrGraphic</code> dans <code>OcrGraphic</code> , nous pouvons apprendre √† l'application √† parler √† voix haute lorsque vous cliquez sur le texte. </p><br><p>  Tout d'abord, impl√©mentons la m√©thode <code>OcrGraphic</code> dans <code>OcrGraphic</code> .  Nous avons juste besoin de v√©rifier si les coordonn√©es <code>x</code> et <code>y</code> sont dans les limites du texte affich√©. <br>  <em>OcrGraphic.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Check if this graphic's text contains this point. if (text == null) { return false; } RectF rect = new RectF(text.getBoundingBox()); rect = translateRect(rect); return rect.contans(x, y); }</span></span></code> </pre> <br><p>  Vous remarquerez peut-√™tre qu'il y a beaucoup en commun avec la m√©thode <code>Draw</code> !  Dans ce projet, vous devriez √™tre en mesure de r√©utiliser le code, mais ici, nous laissons tout comme pour le simple exemple. </p><br><p>  Passons maintenant √† la m√©thode <code>onTap</code> dans <code>OcrCaptureActivity</code> et traitons le clic sur le texte, s'il y en a un √† cet endroit. </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the text when the user taps on screen. OcrGraphic graphic = graphicOverlay.getGraphicAtLocation(rawX, rawY); TextBlock text = null; if (graphic != null) { text = graphic.getTextBlock(); if (text != null &amp;&amp; text.getValue() != null) { Log.d(TAG, "text data is being spoken! " + text.getValue()); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the string. } else { Log.d(TAG, "text data is null"); } } else { Log.d(TAG,"no text detected"); } return text != null; }</span></span></code> </pre> <br><p>  Vous pouvez ex√©cuter l'application et vous assurer que cliquer sur le texte est r√©ellement trait√© via <code>Android Monitor Logcat</code> . </p><br><p>  Faisons parler notre application!  Allez au d√©but de l' <code>Activity</code> et trouvez la m√©thode <code>onCreate</code> .  Lors du d√©marrage de l'application, nous devons initialiser le moteur <code>TextToSpeech</code> pour une utilisation future. </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// (Portions of this method omitted) // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Set up the Text To Speech engine. TextToSpeech.OnInitListener listener = new TextToSpeech.OnInitListener() { @Override public void onInit(final int status) { if (status == TextToSpeech.SUCCESS) { Log.d("TTS", "Text to speech engine started successfully."); tts.setLanguage(Locale.US); } else { Log.d("TTS", "Error starting the text to speech engine."); } } }; tts = new TextToSpeech(this.getApplicationContext(), listener); }</span></span></code> </pre> <br><p>  Malgr√© le fait que nous ayons correctement initialis√© <code>TextToSpeech</code> , en r√®gle g√©n√©rale, vous devez toujours g√©rer les erreurs g√©n√©rales, par exemple, lorsque le moteur n'est toujours pas pr√™t la premi√®re fois que vous cliquez sur le texte. </p><br><p>  <code>TextToSpeech</code> √©galement de la langue.  Vous pouvez changer la langue en fonction de la langue du texte reconnu.  La reconnaissance de la langue n'est pas int√©gr√©e √† l' <code>Mobile Vision Text API</code> , mais elle est disponible via l' <code>Google Translate API</code> .  En tant que langue pour la reconnaissance de texte, vous pouvez utiliser la langue de la machine utilisateur. </p><br><p>  <code>onTap</code> bien, il ne reste plus qu'√† ajouter le code de lecture de texte dans la m√©thode <code>onTap</code> . </p><br><p>  <em>OcrCaptureActivity.java</em> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Speak the text when the user taps on screen. OcrGraphic graphic = graphicOverlay.getGraphicAtLocation(rawX, rawY); TextBlock text = null; if (graphic != null) { text = graphic.getTextBlock(); if (text != null &amp;&amp; text.getValue() != null) { Log.d(TAG, "text data is being spoken! " + text.getValue()); // Speak the string. tts.speak(text.getValue(), TextToSpeech.QUEUE_ADD, null, "DEFAULT"); } else { Log.d(TAG, "text data is null"); } } else { Log.d(TAG,"no text detected"); } return text != null; }</span></span></code> </pre> <br><p>  Maintenant, lorsque vous d√©marrez l'application et cliquez sur le texte d√©tect√©, votre appareil le lira.  Essayez-le! </p><br><h2>  Ach√®vement </h2><br><p>  Maintenant, vous avez une application qui peut reconna√Ætre le texte de la cam√©ra et le parler √† haute voix! </p><br><p>  Vous pouvez appliquer les connaissances acquises de la reconnaissance de texte dans vos autres applications.  Par exemple, lisez les adresses et les num√©ros de t√©l√©phone des cartes de visite, recherchez le texte des photographies de divers documents.  En bref, utilisez l' <code>OCR</code> partout o√π vous pouvez avoir besoin de reconna√Ætre du texte dans une image. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412679/">https://habr.com/ru/post/fr412679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412667/index.html">Cybergroup Turla utilise Metasploit dans la campagne Mosquito</a></li>
<li><a href="../fr412669/index.html">La gestion du temps ne fait pas peur: comment faire plus</a></li>
<li><a href="../fr412671/index.html">Console BLE: une toute nouvelle fa√ßon d'interagir avec les appareils BLE</a></li>
<li><a href="../fr412675/index.html">Contrats et adresses multisig dans Bitcoin et Ethereum</a></li>
<li><a href="../fr412677/index.html">Matrice de tra√ßabilit√©</a></li>
<li><a href="../fr412681/index.html">Calculs binaires pour l'arithm√©tique d√©cimale</a></li>
<li><a href="../fr412683/index.html">O√π et comment apprendre le machine learning?</a></li>
<li><a href="../fr412685/index.html">Suivi de chemin GPU Unity - Partie 2</a></li>
<li><a href="../fr412687/index.html">Impl√©mentez IdM. Proc√©dures et moyens techniques - du basique √† l'IdM</a></li>
<li><a href="../fr412689/index.html">L'analyse informatique pr√©dictive rationalise la surveillance des applications distribu√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>