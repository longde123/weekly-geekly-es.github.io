<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° ü§µ üôèüèø Cinco preguntas sobre el dise√±o de lenguajes de programaci√≥n ü§πüèæ üé∫ üë®üèº‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Filosof√≠a orientadora 

 1. Lenguajes de programaci√≥n para personas 
 Los lenguajes de programaci√≥n son c√≥mo las personas hablan con las computadoras....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cinco preguntas sobre el dise√±o de lenguajes de programaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477366/"><img src="https://habrastorage.org/webt/4b/el/ov/4belovlzntlpqyfg1tqnamrivd8.jpeg"><br><br><h2>  Filosof√≠a orientadora </h2><br><br><h3>  1. Lenguajes de programaci√≥n para personas </h3><br>  Los lenguajes de programaci√≥n son c√≥mo las personas hablan con las computadoras.  La computadora estar√° encantada de hablar cualquier idioma que no sea ambiguo.  La raz√≥n por la que tenemos lenguajes de alto nivel es porque las personas no pueden manejar el lenguaje de m√°quina.  La esencia de los lenguajes de programaci√≥n es evitar que nuestro pobre y fr√°gil cerebro humano se sobrecargue con una gran cantidad de detalles. <br><a name="habracut"></a><br>  Los arquitectos saben que algunos problemas de dise√±o son m√°s mundanos que otros.  Uno de los problemas de dise√±o m√°s claros y abstractos es el dise√±o de puentes.  En este caso, su trabajo es cubrir la distancia requerida con la menor cantidad de material posible.  En el otro extremo del espectro est√° el dise√±o de sillas.  Los dise√±adores de sillas deben pasar su tiempo pensando en los culos humanos. <br><br>  El desarrollo de software tiene una diferencia similar.  El dise√±o de algoritmos para enrutar datos a trav√©s de una red es un buen problema abstracto, como el dise√±o de puentes.  Mientras que dise√±ar lenguajes de programaci√≥n es como dise√±ar sillas: necesita hacer frente a las debilidades humanas. <br><br>  A la mayor√≠a de nosotros nos cuesta mucho darnos cuenta de esto.  Dise√±ar sistemas matem√°ticos elegantes suena mucho m√°s atractivo para la mayor√≠a de nosotros que caer en las debilidades humanas.  El papel de la elegancia matem√°tica es que cierto grado de elegancia hace que los programas sean m√°s f√°ciles de entender.  Pero todo no se limita a la elegancia. <br><br>  Y cuando digo que los idiomas deben estar dise√±ados para tener en cuenta las debilidades humanas, no quiero decir que los idiomas deben estar dise√±ados para programadores malos.  De hecho, debe dise√±ar software para los mejores programadores, pero incluso los mejores programadores tienen sus l√≠mites.  No creo que al menos a alguien le guste programar en un lenguaje donde todas las variables se denoten con la letra "x" con √≠ndices enteros. <br><br><h3>  2. Dise√±a para ti y para tus amigos </h3><br>  Si observa la historia de los lenguajes de programaci√≥n, la mayor√≠a de los mejores lenguajes han sido dise√±ados para ser utilizados por sus propios autores, y la mayor√≠a de los peores han sido dise√±ados para otras personas. <br><br>  Cuando los idiomas est√°n dise√±ados para otras personas, siempre es un grupo espec√≠fico de personas: las personas no son tan inteligentes como los creadores del idioma.  Entonces obtienes un idioma que te habla condescendientemente.  Cobol es el ejemplo m√°s claro, pero la mayor√≠a de los idiomas est√°n imbuidos de este esp√≠ritu. <br><br>  Esto no tiene nada que ver con qu√© tan alto es el idioma.  C es de nivel bastante bajo, pero fue creado para ser utilizado por sus autores, por lo que a los piratas inform√°ticos les encanta. <br><br>  El argumento para dise√±ar lenguajes para programadores malos es que hay m√°s programadores malos que buenos.  Quiz√°s esto sea as√≠.  Pero este peque√±o n√∫mero de buenos programadores escribe desproporcionadamente m√°s software. <br><br>  Me interesa la cuesti√≥n de c√≥mo crear un lenguaje que guste a los mejores hackers.  Creo que esta pregunta es id√©ntica a la pregunta de c√≥mo crear un buen lenguaje de programaci√≥n, pero incluso si no lo es, al menos es una pregunta interesante. <br><br><h3>  3. Dele al programador el mayor control posible </h3><br>  Muchos idiomas (especialmente los creados para otras personas) se comportan como ni√±eras: intentan advertirte de cosas que, en su opini√≥n, no te ser√°n √∫tiles.  Tengo la opini√≥n opuesta: dale al programador tanto control como puedas. <br><br>  Cuando estudi√© por primera vez a Lisp, lo que m√°s me gust√≥ fue que hablamos en igualdad de condiciones.  En otros idiomas que hab√≠a estudiado en ese momento, hab√≠a un idioma, y ‚Äã‚Äãestaba mi programa en ese idioma, y ‚Äã‚Äãexist√≠an por separado.  Pero en Lisp, las funciones y macros que escrib√≠ fueron las mismas en las que se escribi√≥ el lenguaje.  Podr√≠a reescribir el lenguaje en s√≠ mismo si quisiera.  Ten√≠a el mismo atractivo que el software de c√≥digo abierto. <br><br><h3>  4. Brevedad: la hermana del talento </h3><br>  La brevedad se subestima e incluso se desprecia.  Pero si observa los corazones de los hackers, ver√° que les encanta la brevedad.  ¬øCu√°ntas veces has escuchado a los hackers decir amorosamente que, digamos, en la APL, pueden hacer cosas incre√≠bles con solo un par de l√≠neas de c√≥digo?  Creo que a las personas realmente inteligentes les gusta prestar atenci√≥n a esto. <br><br>  Creo que casi todo lo que acorta los programas es bueno.  Deber√≠a haber muchas funciones de biblioteca, todo lo que puede ser impl√≠cito, debe ser as√≠;  la sintaxis deber√≠a ser m√°s concisa;  incluso los nombres de las entidades deben ser cortos. <br><br>  Y no solo los programas deben ser cortos.  Los manuales tambi√©n deben ser cortos.  Una buena parte de los manuales est√° llena de explicaciones, renuncias, advertencias y casos especiales.  Si necesita acortar el manual, la mejor opci√≥n es arreglar un idioma que requiere tantas explicaciones. <br><br><h3>  5. Reconoce lo que es hackear. </h3><br>  A muchas personas les gustar√≠a que la pirater√≠a sea matem√°tica, o al menos algo similar a las ciencias naturales.  Creo que piratear es m√°s como arquitectura.  La arquitectura est√° conectada con la f√≠sica, en el sentido de que el arquitecto necesita dise√±ar un edificio que no se caiga, pero el objetivo real del arquitecto es crear un gran edificio y no hacer descubrimientos en el campo de la est√°tica. <br><br>  Lo que les encanta a los hackers es crear excelentes programas.  Y creo que, al menos en nuestros propios pensamientos, debemos recordar que escribir programas maravillosos es maravilloso, incluso cuando este trabajo no se traduce f√°cilmente en la moneda intelectual ordinaria de los trabajos cient√≠ficos.  Desde un punto de vista intelectual, es igualmente importante c√≥mo desarrollar un lenguaje que los programadores adoren, y crear un lenguaje terrible que incorpore la idea sobre la cual puedes publicar un art√≠culo. <br><br><h2>  Problemas abiertos </h2><br><h3>  1. ¬øC√≥mo organizar grandes bibliotecas? </h3><br>  Las bibliotecas se est√°n convirtiendo en una parte importante de los lenguajes de programaci√≥n.  Se vuelven tan grandes que puede ser peligroso.  Si lleva m√°s tiempo encontrar una funci√≥n en la biblioteca que haga lo que necesita, que escribir esta funci√≥n usted mismo, entonces todo el c√≥digo no hace m√°s que engrosar su manual.  (Los manuales simb√≥licos fueron un ejemplo). Entonces tenemos que resolver el problema de organizar bibliotecas.  Lo ideal es dise√±arlos de manera que el programador pueda adivinar qu√© funci√≥n de biblioteca es adecuada. <br><br><h3>  2. ¬øLa gente realmente teme por la sintaxis del prefijo? </h3><br>  Este es un problema abierto en el sentido de que lo he estado pensando durante varios a√±os y todav√≠a no s√© la respuesta.  La sintaxis del prefijo me parece completamente natural, posiblemente adem√°s de usarla en matem√°ticas.  Pero puede ser que la mayor parte de la impopularidad de Lisp se deba simplemente a una sintaxis desconocida ... ¬øHay algo que ver con esto? Si es cierto, esta es otra pregunta. <br><br><h3>  3. ¬øQu√© necesitas para el software del servidor? </h3><br>  Creo que la mayor√≠a de las aplicaciones que se escribir√°n en los pr√≥ximos veinte a√±os ser√°n aplicaciones web, en el sentido de que los programas se ubicar√°n en el servidor y se comunicar√°n con usted a trav√©s de un navegador web.  Y para escribir tales aplicaciones necesitamos cosas nuevas. <br><br>  Una de estas cosas es admitir una nueva forma de liberar aplicaciones de servidor.  En lugar de una o dos versiones principales por a√±o, como el software de escritorio, el software del servidor se lanzar√° en una serie de peque√±os cambios.  Puede tener cinco o diez lanzamientos por d√≠a.  Y todos siempre tendr√°n la √∫ltima versi√≥n. <br><br>  ¬øSabes c√≥mo dise√±ar programas para ser compatibles?  El software del servidor debe estar dise√±ado para ser adaptable.  Deber√≠a poder cambiarlo f√°cilmente, o al menos saber qu√© significa un cambio menor y qu√© es importante. <br><br>  Otra cosa que puede ser √∫til en el software del servidor es, de repente, la continuidad de la entrega.  En una aplicaci√≥n web, puede usar algo como <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a> para obtener el efecto de las rutinas en el mundo sin estado de las sesiones web.  Puede que la continuidad de la entrega valga la pena si esta oportunidad no es demasiado cara. <br><br><h3>  4. ¬øQu√© nuevas abstracciones quedan por abrir? </h3><br>  No estoy seguro de cu√°n razonable es esta esperanza, pero personalmente me gustar√≠a descubrir una nueva abstracci√≥n, algo que podr√≠a ser tan importante como las funciones de primera clase o la recursi√≥n, o al menos los par√°metros predeterminados.  Tal vez este es un sue√±o imposible.  Tales cosas a menudo no se abren.  Pero no pierdo la esperanza. <br><br><h2>  Secretos poco conocidos </h2><br><h3>  1. Puedes usar el idioma que quieras </h3><br>  Anteriormente, la creaci√≥n de aplicaciones significaba la creaci√≥n de software de escritorio.  Y en el software de escritorio hay un gran sesgo hacia la escritura de aplicaciones en el mismo idioma que el sistema operativo.  Entonces, hace diez a√±os, escribir software en su conjunto significaba escribir software en C. Al final, la tradici√≥n ha evolucionado: las aplicaciones no deben escribirse en lenguajes inusuales.  Y esta tradici√≥n se ha desarrollado durante tanto tiempo que personas no t√©cnicas, como gerentes y capitalistas de riesgo, tambi√©n han aprendido esto. <br><br>  El software del servidor destruye este modelo por completo.  Con el software del servidor, puede tomar el idioma que desee.  Casi nadie m√°s entiende esto (especialmente los gerentes y capitalistas de riesgo).  Pero algunos hackers entienden esto, por lo que hemos escuchado sobre lenguajes independientes como Perl y Python.  No escuchamos sobre Perl y Python porque la gente los usa para escribir aplicaciones de Windows. <br><br>  ¬øQu√© significa esto para nosotros, personas interesadas en dise√±ar lenguajes de programaci√≥n, que hay una audiencia potencial para nuestro trabajo? <br><br><h3>  2. La velocidad proviene de los perfiladores </h3><br>  Los desarrolladores de lenguaje, o al menos sus implementadores, adoran escribir compiladores que generen c√≥digo r√°pido.  Pero creo que esto no es lo que hace que los idiomas sean r√°pidos para los usuarios.  Knut ha notado durante mucho tiempo que la velocidad depende de unos pocos cuellos de botella.  Y cualquiera que haya intentado acelerar el programa sabe que no puede adivinar d√≥nde est√° el cuello de botella.  El perfilador es la respuesta. <br><br>  Los desarrolladores de idiomas est√°n resolviendo el problema incorrecto.  Los usuarios no necesitan puntos de referencia para trabajar r√°pidamente.  Necesitan un lenguaje que pueda mostrar qu√© partes de su programa deben reescribirse.  En este punto, se necesita velocidad en la pr√°ctica.  Por lo tanto, podr√≠a ser mejor si los implementadores del lenguaje pasan la mitad del tiempo que dedican a optimizar el compilador y lo pasan escribiendo un buen perfilador. <br><br><h3>  3. Necesitas una aplicaci√≥n que desarrolle tu lenguaje </h3><br>  Tal vez esta no sea la verdad definitiva, pero parece que los mejores lenguajes se han desarrollado junto con las aplicaciones en las que se utilizaron.  C fue escrito por personas que necesitaban programaci√≥n del sistema.  Lisp fue dise√±ado en parte para la diferenciaci√≥n simb√≥lica; McCarthy estaba tan ansioso por comenzar que comenz√≥ a escribir programas de diferenciaci√≥n incluso en el primer documento de Lisp en 1960. <br><br>  Esto es especialmente bueno si su aplicaci√≥n resuelve algunos problemas nuevos.  Esto alienta a su idioma a tener nuevas funciones que los programadores necesitan.  Personalmente, estoy interesado en escribir un lenguaje que sea bueno para las aplicaciones de servidor. <br><br>  [Durante la discusi√≥n, Guy Steele tambi√©n expres√≥ esta idea, y agreg√≥ que la aplicaci√≥n no debe consistir en escribir un compilador para su idioma, a menos que su idioma est√© destinado a escribir compiladores.] <br><br>  <b>4. El lenguaje debe ser adecuado para escribir programas √∫nicos.</b> <br><br>  Usted sabe lo que significa un programa √∫nico: esto es cuando necesita resolver r√°pidamente un problema limitado.  Creo que si miras a tu alrededor, encontrar√°s muchos programas serios que comenzaron como programas √∫nicos.  No me sorprender√≠a si la mayor√≠a de los programas comenzaran como √∫nicos.  Por lo tanto, si desea crear un lenguaje que sea adecuado para escribir software en general, entonces deber√≠a ser adecuado para escribir programas √∫nicos, porque esta es la etapa inicial de muchos programas. <br><br><h3>  5. Sintaxis relacionada con la sem√°ntica </h3><br>  Tradicionalmente se cree que la sintaxis y la sem√°ntica son cosas muy diferentes.  Puede sonar impactante, pero no lo es.  Creo que lo que quieres obtener en tu programa est√° relacionado con c√≥mo lo expresas. <br><br>  Recientemente habl√© con Robert Morris, y se dio cuenta de que la sobrecarga del operador es una gran ventaja en los idiomas ganadores con sintaxis infija.  En idiomas con sintaxis de prefijo, cualquier funci√≥n que defina es en realidad un operador.  Si desea sumar el nuevo tipo de n√∫mero que cre√≥, simplemente puede definir una nueva funci√≥n para agregarlo.  Si hace esto en un idioma con sintaxis infija, ver√° que hay una gran diferencia entre usar un operador sobrecargado y llamar a una funci√≥n. <br><br><h2>  Ideas que vuelven con el tiempo </h2><br><h3>  1. Nuevos lenguajes de programaci√≥n </h3><br>  Mirando hacia atr√°s en la d√©cada de 1970, estaba de moda desarrollar nuevos lenguajes de programaci√≥n.  Ahora esto no es as√≠.  Pero creo que el software del servidor volver√° a la moda para crear nuevos idiomas.  Con el software de servidor, puede usar el idioma que desee, por lo que si alguien crea un idioma que parece mejor que el resto, habr√° personas que decidan usarlo. <br><br><h3>  2. Tiempo compartido </h3><br>  Richard Kelsey propuso esta idea, ha llegado el momento de que vuelva, y la apoyo plenamente.  Mi suposici√≥n (y Microsoft tambi√©n) es que muchos c√°lculos se mover√°n desde el escritorio a los servidores remotos.  En otras palabras, la divisi√≥n del tiempo ha regresado.  Creo que necesitar√°s apoyo a nivel de idioma.  Por ejemplo, Richard y Jonathan Reeves hicieron mucho trabajo para implementar la planificaci√≥n de procesos en el Esquema 48. <br><br><h3>  3. Eficiencia </h3><br>  Recientemente parec√≠a que las computadoras ya eran bastante r√°pidas.  Cada vez m√°s o√≠mos sobre bytecode, lo que al menos para m√≠ significa que tenemos el poder en stock.  Pero creo que con el software del servidor, no lo tenemos.  Alguien tendr√° que pagar por los servidores que ejecutan el software, y el n√∫mero de usuarios que el servidor puede soportar por m√°quina ser√° un divisor de sus costos de capital. <br><br>  Creo que la eficiencia importar√°, al menos en los cuellos de botella de la inform√°tica.  Esto ser√° especialmente importante para las operaciones de E / S, ya que las aplicaciones del servidor realizan muchas de esas operaciones. <br><br>  Al final, podr√≠a resultar que el c√≥digo de bytes no sea una opci√≥n.  Sun y Microsoft actualmente parecen estar luchando cara a cara en el campo de c√≥digo de bytes.  Pero lo hacen porque el bytecode es un lugar conveniente para integrarse en el proceso, y no porque el bytecode solo sea una buena idea.  Puede resultar que toda esta batalla pase desapercibida.  Ser√≠a gracioso <br><br><h2>  Trampas y trampas </h2><br><h3>  1. Clientes </h3><br>  Esto es solo una suposici√≥n, pero es que solo aquellas aplicaciones que estar√°n completamente del lado del servidor se beneficiar√°n.  Dise√±ar un software que funcione asumiendo que todos tendr√°n a su cliente es como crear una sociedad basada en el supuesto de que todos ser√°n honestos.  Definitivamente ser√≠a conveniente, pero debes asumir que nunca suceder√°. <br><br>  Creo que habr√° un r√°pido aumento en los dispositivos con acceso a la web, y podemos suponer que admitir√°n formularios y html b√°sicos.  ¬øTienes un navegador en tu tel√©fono?  ¬øHabr√° un tel√©fono en su PalmPilot?  ¬øTu blackberry tendr√° una pantalla m√°s grande?  ¬øTendr√°s la oportunidad de conectarte en l√≠nea desde tu gameboy?  De tu reloj?  No lo se  Y no tengo que averiguar si apuesto a que todo estar√° en el servidor.  Simplemente es mucho m√°s confiable tener todos los cerebros en el servidor.  . <br><br><h3>  2. Programaci√≥n orientada a objetos </h3><br>  Entiendo que esta es una declaraci√≥n controvertida, pero no creo que OOP sea algo importante.  Creo que este es un paradigma adecuado para aplicaciones espec√≠ficas que necesitan estructuras de datos espec√≠ficas, como sistemas de ventanas, simulaciones, sistemas CAD.  Pero no entiendo por qu√© deber√≠a ser adecuado para todos los programas. <br><br>  Creo que la gente en las grandes empresas adora la POO, en parte porque proporciona mucho de lo que parece trabajo.  Lo que, por supuesto, se puede representar como, digamos, una lista de enteros, ahora se puede representar como una clase con todo tipo de andamios, con ruido y bullicio. <br><br>  Otra caracter√≠stica atractiva de OOP es que los m√©todos le dan un cierto efecto de las funciones de primera clase.  Pero esto no es noticia para los programadores de Lisp.  Cuando tiene funciones reales de la primera clase, simplemente puede usarlas de cualquier manera que corresponda a la tarea, en lugar de insertar todo en una plantilla de clases y m√©todos. <br><br>  Creo que esto significa para el dise√±o del lenguaje que no debes incrustar OOP demasiado profundamente en √©l.  Quiz√°s la respuesta sea ofrecer cosas m√°s generales y fundamentales, y permitir a las personas dise√±ar cualquier sistema de objetos en forma de bibliotecas. <br><br><h3>  3. Dise√±o por comit√© </h3><br>  Si su idioma est√° siendo redactado por un comit√©, entonces est√° atrapado, y no solo por razones que todos conocen.  Todos saben que los comit√©s tienden a crear un dise√±o de lenguaje desigual e inconsistente.  Pero creo que el gran peligro es que no corren riesgos.  Cuando una persona est√° a la cabeza, toma riesgos que el comit√© nunca aceptar√° asumir. <br><br>  ¬øDebo arriesgarme para crear un buen lenguaje?  Muchas personas pueden sospechar que el dise√±o de un lenguaje es donde debes mantenerte bastante cerca de la sabidur√≠a tradicional.  Apuesto a que no lo es.  En todo lo dem√°s que hace la gente, la recompensa es proporcional al riesgo.  Entonces, ¬øpor qu√© el dise√±o del lenguaje debe ser diferente? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477366/">https://habr.com/ru/post/477366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477356/index.html">Detecci√≥n de ataque de fuerza bruta a trav√©s de NTLM con Varonis</a></li>
<li><a href="../477358/index.html">Te invitamos a DINS DevOps TARDE el 5 de diciembre: estamos hablando de un sistema de procesamiento de eventos, compartiendo experiencias con Influx</a></li>
<li><a href="../477360/index.html">Novedades de SOLIDWORKS Simulation 2020</a></li>
<li><a href="../477362/index.html">M√°s que antispam: c√≥mo aprovechar al m√°ximo su Security Email Gateway</a></li>
<li><a href="../477364/index.html">¬øC√≥mo convertirse en un desarrollador de Java? ¬øO tal vez elegir Python?</a></li>
<li><a href="../477370/index.html">PHP sin servidor</a></li>
<li><a href="../477372/index.html">Amazon pierde la guerra contra las falsificaciones</a></li>
<li><a href="../477374/index.html">Fuzzing Z-machines</a></li>
<li><a href="../477378/index.html">√Ågil mixto: enfoque de cascada al implementar aplicaciones comerciales (tambi√©n conocido como Agile-like)</a></li>
<li><a href="../477382/index.html">Esports: obtener ganancias: Mercedes, meg√°fono, apuestas y branding para esports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>