<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèΩ üëû üßïüèº Engineering-Ansatz f√ºr die Softwareentwicklung. Von der Theorie zur Praxis üöã üì∑ üë©üèæ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie kann man Ideen, Architekturen und Algorithmen testen, ohne Code zu schreiben? Wie formuliere und verifiziere ich ihre Eigenschaften? Was sind Mode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Engineering-Ansatz f√ºr die Softwareentwicklung. Von der Theorie zur Praxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/471012/"><p> Wie kann man Ideen, Architekturen und Algorithmen testen, ohne Code zu schreiben?  Wie formuliere und verifiziere ich ihre Eigenschaften?  Was sind Modellpr√ºfer und Modellfinder?  Was tun, wenn die F√§higkeiten der Tests nicht ausreichen? </p><br><p>  Hallo.  Mein Name ist Vasil Dyadov, jetzt arbeite ich als Programmierer in Yandex.Mail. Bevor ich bei Intel arbeitete, hatte ich zuvor RTL-Code (Register Transfer Level) auf Verilog / VHDL f√ºr ASIC / FPGA entwickelt.  Ich habe mich lange mit dem Thema Software- und Hardware-Zuverl√§ssigkeit, Mathematik, Tools und Methoden besch√§ftigt, die zur Entwicklung von Software und Logik mit garantierten, vordefinierten Eigenschaften verwendet werden. </p><br><p>  Dies ist der zweite Artikel in einer Reihe (der erste Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), der Entwickler und Manager auf den technischen Ansatz f√ºr die Softwareentwicklung aufmerksam machen soll.  In letzter Zeit wurde er trotz revolution√§rer √Ñnderungen in seinem Ansatz und seinen Unterst√ºtzungsinstrumenten zu Unrecht ignoriert. </p><a name="habracut"></a><br><p>  Der erste Artikel erschien einigen Lesern zu abstrakt.  Viele m√∂chten ein Beispiel f√ºr die Verwendung eines technischen Ansatzes und formaler Spezifikationen unter realit√§tsnahen Bedingungen sehen. </p><br><p>  In diesem Artikel sehen wir uns ein Beispiel f√ºr die tats√§chliche Anwendung von TLA + zur L√∂sung eines praktischen Problems an. </p><br><p>  Ich bin immer offen f√ºr Fragen im Zusammenhang mit der Softwareentwicklung und freue mich, mit den Lesern zu chatten (die Koordinaten f√ºr die Kommunikation finden Sie in meinem Profil). </p><br><h1 id="chto-takoe-tla">  Was ist TLA +? </h1><br><p>  Zun√§chst m√∂chte ich ein paar Worte zu TLA + und TLC sagen. </p><br><p>  TLA + (Temporal Logic of Actions + Data) ist ein Formalismus, der auf einer Art zeitlicher Logik basiert.  Entworfen von Leslie Lamport. </p><br><p>  Im Rahmen dieses Formalismus kann man den Raum der Systemverhaltensvarianten und die Eigenschaften dieser Verhaltensweisen beschreiben. </p><br><p>  Der Einfachheit halber k√∂nnen wir annehmen, dass das Verhalten des Systems durch eine Folge seiner Zust√§nde dargestellt wird (wie unendliche Perlen, Kugeln auf einer Schnur), und die TLA + -Formel definiert eine Klasse von Ketten, die alle m√∂glichen Varianten des Systemverhaltens beschreiben (eine gro√üe Anzahl von Perlen). </p><br><p>  TLA + ist gut geeignet, um interagierende nicht deterministische Finite-State-Maschinen (zum Beispiel die Interaktion von Diensten in einem System) zu beschreiben, obwohl seine Ausdruckskraft ausreicht, um viele andere Dinge zu beschreiben (die in Logik erster Ordnung ausgedr√ºckt werden k√∂nnen). </p><br><p>  Und TLC ist ein Modellpr√ºfer f√ºr explizite Zust√§nde: ein Programm, das gem√§√ü einer gegebenen TLA + -Systembeschreibung und Eigenschaftsformeln die Systemzust√§nde durchl√§uft und bestimmt, ob das System die angegebenen Eigenschaften erf√ºllt. </p><br><p>  In der Regel wird die Arbeit mit TLA + / TLC folgenderma√üen aufgebaut: Wir beschreiben das System in TLA +, formalisieren interessante Eigenschaften in TLA + und f√ºhren TLC zur √úberpr√ºfung aus. </p><br><p>  Da es nicht einfach ist, ein mehr oder weniger komplexes System in TLA + direkt zu beschreiben, wurde eine √ºbergeordnete Sprache erfunden - PlusCal, das in TLA + √ºbersetzt wird.  PlusCal gibt es auf zwei Arten: mit Pascal- und C-√§hnlicher Syntax.  In dem Artikel, in dem ich Pascal-√§hnliche Syntax verwendet habe, scheint es mir besser zu lesen.  PlusCal in Bezug auf TLA + ist ungef√§hr dasselbe wie C in Bezug auf Assembler. </p><br><p>  Hier werden wir nicht tief in die Theorie gehen.  Literatur zum Eintauchen in TLA + / PlusCal / TLC finden Sie am Ende des Artikels. </p><br><p>  Meine Hauptaufgabe ist es, die Anwendung von TLA + / TLC in einem einfachen und verst√§ndlichen Beispiel aus der Praxis zu zeigen. </p><br><p>  In einigen Kommentaren zum vorherigen Artikel wurde mir vorgeworfen, dass ich nicht die theoretischen Grundlagen von Werkzeugen gemalt habe, aber der Zweck dieser Artikelserie war es, die praktische Anwendung von Werkzeugen f√ºr den technischen Ansatz in der Softwareentwicklung zu zeigen. </p><br><p>  Ich denke, ein tiefes Eintauchen in die Theorie ist f√ºr niemanden von Interesse, aber wenn Sie interessiert sind, k√∂nnen Sie sich jederzeit an die PM wenden, um Links und Erkl√§rungen zu erhalten. Soweit ich √ºber ausreichende Kenntnisse verf√ºge (schlie√ülich bin ich kein theoretischer Mathematiker, sondern ein Softwareentwickler), werde ich versuchen, zu antworten . </p><br><h1 id="postanovka-zadachi">  Erkl√§rung des Problems </h1><br><p>  Zun√§chst werde ich ein wenig √ºber die Aufgabe sprechen, f√ºr die TLA + verwendet wurde. </p><br><p>  Die Aufgabe bezieht sich auf die Verarbeitung des Ereignisflusses.  N√§mlich zum Erstellen einer Warteschlange zum Speichern von Ereignissen und zum Senden von Benachrichtigungen √ºber diese Ereignisse. </p><br><p>  Das Data Warehouse ist physisch auf Basis des PostgreSQL-DBMS organisiert. </p><br><p>  Die Hauptsache, die Sie wissen m√ºssen: </p><br><ol><li>  Es gibt Quellen f√ºr Ereignisse.  F√ºr unsere Zwecke k√∂nnen wir uns darauf beschr√§nken, dass jedes Ereignis durch die Zeit gekennzeichnet ist, in der seine Verarbeitung geplant ist.  Diese Quellen schreiben Ereignisse in die Datenbank.  Normalerweise h√§ngen der Zeitpunkt des Schreibens in die Datenbank und der Zeitpunkt der geplanten Verarbeitung in keiner Weise zusammen. </li><li>  Es gibt koordinierende Prozesse, die Ereignisse aus der Datenbank lesen und Benachrichtigungen √ºber bevorstehende Ereignisse an die Komponenten des Systems senden, die auf diese Benachrichtigungen reagieren m√ºssen. </li><li>  Grundvoraussetzung: Wir d√ºrfen keine Ereignisse verlieren.  Die Benachrichtigung √ºber das Ereignis kann in extremen F√§llen wiederholt werden, dh es muss <em>mindestens einmal</em> eine Garantie gegeben <em>werden</em> .  In verteilten Systemen ist es √§u√üerst schwierig, eine Garantie <em>nur einmal</em> (es kann sogar unm√∂glich sein, aber es muss bewiesen werden) ohne Konsensmechanismen zu implementieren, und sie haben (zumindest alles, was ich wei√ü) einen sehr starken Einfluss auf das System in Bezug auf Verz√∂gerung und Durchsatz. </li></ol><br><p>  Nun ein paar Details: </p><br><ol><li>  Es gibt viele Quellprozesse, sie k√∂nnen Millionen (im schlimmsten Fall) von Ereignissen erzeugen, die in ein enges Zeitintervall fallen. </li><li>  Ereignisse k√∂nnen sowohl f√ºr die Zukunft als auch f√ºr die Vergangenheit generiert werden (z. B. wenn der Quellprozess verlangsamt wurde und ein Ereignis f√ºr einen bereits verstrichenen Moment aufgezeichnet hat). </li><li>  Die Priorit√§t der Ereignisverarbeitung liegt in der Zeit, d. H. Wir m√ºssen zuerst die fr√ºhesten Ereignisse verarbeiten. </li><li>  F√ºr jedes Ereignis generiert der Quellprozess eine Zufallszahl <em>worker_id</em> , aufgrund derer Ereignisse unter den Koordinatoren verteilt werden. </li><li>  Es gibt verschiedene Koordinierungsprozesse (skaliert je nach Bedarf basierend auf der Systemlast). </li><li>  Jeder Koordinatorprozess verarbeitet Ereignisse f√ºr seine eigene Menge <em>worker_id</em> , d. H. Aufgrund von <em>worker_id</em> vermeiden wir den Wettbewerb zwischen Koordinatoren und die Notwendigkeit von Sperren. </li></ol><br><p>  Wie aus der Beschreibung hervorgeht, k√∂nnen wir nur einen Koordinierungsprozess ber√ºcksichtigen und nicht die <em>worker_id</em> in unserer Aufgabe ber√ºcksichtigen. </p><br><p>  Das hei√üt, der Einfachheit halber nehmen wir an, dass: </p><br><ol><li>  Es gibt viele Quellprozesse. </li><li>  Der Koordinierungsprozess ist einer. </li></ol><br><p>  Ich werde die Entwicklung der Idee, dieses Problem schrittweise zu l√∂sen, beschreiben, damit verst√§ndlicher wird, wie sich der Gedanke von einer einfachen Implementierung zu einer optimierten entwickelte. </p><br><h1 id="reshenie-v-lob">  Stirnentscheidung </h1><br><p>  Wir erstellen eine Platte f√ºr Ereignisse, in der wir Ereignisse nur in Form eines <em>Zeitstempels</em> speichern (wir sind an anderen Parametern in dieser Aufgabe nicht interessiert).  Erstellen wir einen Index f√ºr das <em>Zeitstempelfeld</em> . </p><br><p>  Es scheint eine ganz normale L√∂sung zu sein. </p><br><p>  Nur gibt es ein Problem mit der Skalierbarkeit: Je mehr Ereignisse, desto langsamer die Datenbankoperationen. </p><br><p>  Ereignisse k√∂nnen in der Vergangenheit auftreten, daher muss der Koordinator die gesamte Zeitachse st√§ndig √ºberpr√ºfen. </p><br><p>  Das Problem kann umfassend gel√∂st werden, indem die Datenbank nach Zeit usw. in Shards aufgeteilt wird. Dies ist jedoch ein ressourcenintensiver Weg. </p><br><p>  Infolgedessen wird die Arbeit der Koordinatoren verlangsamt, da Sie Daten aus mehreren Datenbanken lesen und kombinieren m√ºssen. </p><br><p>  Es ist schwierig, das Zwischenspeichern von Ereignissen im Koordinator zu implementieren, um nicht zu den Basen zu gehen, um jedes Ereignis zu verarbeiten. </p><br><p>  Mehr Datenbanken - mehr Fehlertoleranzprobleme. </p><br><p>  Usw. </p><br><p>  Wir werden nicht im Detail auf diese frontale L√∂sung eingehen, da sie trivial und uninteressant ist. </p><br><h1 id="pervaya-optimizaciya">  Erste Optimierung </h1><br><p>  Mal sehen, wie man die Frontall√∂sung verbessert. </p><br><p>  Um den Zugriff auf die Datenbank zu optimieren, k√∂nnen Sie den Index etwas komplizieren und Ereignissen, die beim Festschreiben einer Transaktion in der Datenbank generiert werden, eine monoton ansteigende Kennung hinzuf√ºgen.  Das hei√üt, das Ereignis ist jetzt durch das Paar <em>{Zeit, ID} gekennzeichnet</em> , wobei <em>Zeit</em> die Zeit ist, zu der das Ereignis geplant ist, <em>ID</em> ein monoton ansteigender Z√§hler ist.  Es gibt eine Garantie f√ºr die Eindeutigkeit der <em>ID</em> f√ºr jedes Ereignis, aber es gibt keine Garantie daf√ºr, dass <em>ID-</em> Werte ohne L√∂cher auskommen (dh es kann eine solche Reihenfolge geben: <em>1</em> , <em>2</em> , <em>7</em> , <em>15</em> ). </p><br><p>  Es scheint, dass wir jetzt den Bezeichner des zuletzt gelesenen Ereignisses im Koordinatorprozess speichern und beim Abrufen Ereignisse mit Bezeichnern ausw√§hlen k√∂nnen, die gr√∂√üer als das zuletzt verarbeitete Ereignis sind. </p><br><p>  Aber hier taucht das Problem sofort auf: Quellprozesse k√∂nnen ein Ereignis mit einem Zeitstempel weit in der Zukunft aufzeichnen.  Dann m√ºssen wir im Koordinierungsprozess st√§ndig die Ereignisse mit kleinen Kennungen ber√ºcksichtigen, deren Verarbeitungszeit noch nicht gekommen ist. </p><br><p>  Sie k√∂nnen feststellen, dass Ereignisse relativ zur aktuellen Zeit in zwei Klassen unterteilt sind: </p><br><ol><li>  Ereignisse mit einem Zeitstempel in der Vergangenheit, aber mit einer gro√üen Kennung.  Sie wurden k√ºrzlich in die Datenbank geschrieben, nachdem wir dieses Zeitintervall verarbeitet hatten.  Dies sind Ereignisse mit hoher Priorit√§t, und sie m√ºssen zuerst verarbeitet werden, damit die Benachrichtigung - die bereits zu sp√§t ist - nicht einmal zu sp√§t ist. </li><li>  Es wurden einmal Ereignisse mit Zeitstempeln aufgezeichnet, die nahe am aktuellen Moment liegen.  Solche Ereignisse haben einen niedrigen Bezeichnerwert. </li></ol><br><p>  Dementsprechend ist der aktuelle Zustand des Koordinatorprozesses durch das Paar {state.time, state.id} gekennzeichnet. </p><br><p>  Es stellt sich heraus, dass sich Ereignisse mit hoher Priorit√§t links und √ºber diesem Punkt befinden (rosa Bereich) und normale Ereignisse rechts (hellblau): </p><br><p><img src="https://habrastorage.org/webt/n3/x3/q-/n3x3q-kjbxuerrkffffqqnh6hh8.png"></p><br><h2 id="blok-shema">  Flussdiagramm </h2><br><p>  Der Koordinator-Arbeitsalgorithmus lautet wie folgt: </p><br><p><img src="https://habrastorage.org/webt/j6/4d/ge/j64dgeq_jubcbyn4e3zu9ekfasy.png"></p><br><p><img src="https://habrastorage.org/webt/8y/ux/si/8yuxsi4nubi7q5yvclqizezo6xq.png"></p><br><p>  Beim Studium des Algorithmus k√∂nnen Fragen auftauchen: </p><br><ol><li>  Was ist, wenn die Verarbeitung normaler Ereignisse beginnt und in diesem Moment neue Ereignisse in der Vergangenheit (im rosa Bereich) eintreffen, werden sie nicht verloren gehen?  Antwort: Sie werden im n√§chsten Zyklus der Verarbeitung von Ereignissen mit hoher Priorit√§t verarbeitet.  Sie k√∂nnen nicht verloren gehen, da ihre <em>ID</em> garantiert h√∂her als state.id ist. </li><li>  Was ist, wenn nach der Verarbeitung aller normalen Ereignisse - zum Zeitpunkt des Wechsels zur Verarbeitung von Ereignissen mit hoher Priorit√§t - neue Ereignisse mit Zeitstempeln aus dem Intervall [state.time, state.time + Delta] eintreffen, verlieren wir sie?  Antwort: Sie fallen in den rosa Bereich, da sie die <em>Zeit</em> &lt;state.time and <em>id</em> &gt; haben. State.id: Sie sind vor kurzem angekommen und die <em>ID nimmt</em> monoton zu. </li></ol><br><h2 id="primer-raboty-algoritma">  Beispiel f√ºr eine Algorithmusoperation </h2><br><p>  Schauen wir uns einige Schritte des Algorithmus an: </p><br><p><img src="https://habrastorage.org/webt/jl/lf/5v/jllf5vhoz843at6gfrtmjmasppw.png"></p><br><p><img src="https://habrastorage.org/webt/z-/ri/zx/z-rizxhocuxtepr7_wnflvgqm14.png"></p><br><p><img src="https://habrastorage.org/webt/oc/dr/pv/ocdrpv4ozmf-pq_itridvcjookc.png"></p><br><p><img src="https://habrastorage.org/webt/uv/xt/aw/uvxtawqbs5ftd8uzebcwqosdrvw.png"></p><br><p><img src="https://habrastorage.org/webt/uo/_s/cg/uo_scglk7ucb_yze8he8b___wro.png"></p><br><p><img src="https://habrastorage.org/webt/ko/8q/24/ko8q24qizzqz5ddew4jbodavvts.png"></p><br><p><img src="https://habrastorage.org/webt/iw/-f/el/iw-felnslp1mdme-thbu_nicbly.png"></p><br><p><img src="https://habrastorage.org/webt/vf/vs/tz/vfvstz05jy9aowpndr-okgajxpk.png"></p><br><h2 id="model">  Modell </h2><br><p>  Wir werden sicherstellen, dass der Algorithmus keine Ereignisse verpasst und alle Benachrichtigungen gesendet werden: Wir werden ein einfaches Modell erstellen und es √ºberpr√ºfen. </p><br><p>  F√ºr das Modell verwenden wir TLA +, genauer gesagt PlusCal, was sich in TLA + √ºbersetzt. </p><br><pre><code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*      \*   (by Daniel Jackson) \* small-scope hypothesis,   \*  ,  ÃÅ   \*     \*   \*  : \* Events -   - ,   \*    [time, id], \*     \*      \*   \* Event_Id -    \*   id \* MAX_TIME -  ,   \*   \* TIME_DELTA -   Delta, \*     \*  variables Events = {}, Event_Id = 0, MAX_TIME = 5, TIME_DELTA \in 1..3 define \*   \*   ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x \*  fold_left/fold_right    RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) (*     (  ) *) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) (* :    *) ToSet(S) == {S[i] : i \in DOMAIN(S)} (*  map    *) MapSet(Op(_), S) == {Op(x) : x \in S} (*   *) \*   id  GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) \*   time  GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) (*   SQL  *) \*     \*   ORDER BY EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \*   time, id \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt;= max_id \* ORDER BY time, id SELECT_HIGH_PRIO(state) == LET \*      \* time &lt;= curr_time \* AND id &gt;= maxt_id selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } IN selected \* SELECT * FROM events \* WHERE time &gt; current_time AND time - Time &lt;= delta_time \* ORDER BY time, id SELECT_NORMAL(state, delta_time) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } IN selected \* Safety predicate \*       ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; \*  -   fair process inserter = "Sources" variable n, t; begin forever: while TRUE do \*      get_time: \*     \* ,     , \*    with evt_time \in 0..MAX_TIME do t := evt_time; end with; \*     ; \*   : \* 1.   . \* 2.  ,    \* Event_Id -   , \*     commit: \* either -     either Events := Events \cup {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process coordinator = "Coordinator" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do \*    high_prio: events := SELECT_HIGH_PRIO(state); \*   process_high_prio: \*          , \*    Events, \*       state.id := MAX({state.id} \union GetIds(events)) || \*      , \*      Events := Events \ events || \*  events  , \*      events := {}; \*  -   normal: events := SELECT_NORMAL(state, TIME_DELTA); process_normal: state.time := MAX({state.time} \union GetTimes(events)) || Events := Events \ events || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ================================</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, ist die Beschreibung relativ klein, trotz des ziemlich umfangreichen Abschnitts von Definitionen (define), der in einem separaten Modul herausgenommen und dann wiederverwendet werden k√∂nnte. </p><br><p>  In den Kommentaren habe ich versucht zu erkl√§ren, was im Modell passiert.  Hoffe das <br>  Ich habe es geschafft und es besteht keine Notwendigkeit, das Modell detaillierter zu bemalen. </p><br><p>  Ich m√∂chte nur einen Punkt in Bezug auf die Atomizit√§t von √úberg√§ngen zwischen Zust√§nden und Modellierungsmerkmalen klarstellen. </p><br><p>  Die Modellierung erfolgt durch atomare Prozessschritte.  In einem √úbergang wird ein atomarer Schritt eines Prozesses ausgef√ºhrt, in dem dieser Schritt ausgef√ºhrt werden kann.  Die Wahl von Schritt und Prozess ist nicht deterministisch: W√§hrend der Modellierung werden alle m√∂glichen Ketten atomarer Schritte aller Prozesse sortiert. </p><br><p>  Es kann sich die Frage stellen: Was ist mit der Modellierung echter Parallelit√§t, wenn wir gleichzeitig mehrere atomare Schritte in verschiedenen Prozessen ausf√ºhren? </p><br><p>  Diese Frage wurde Leslie Lamport seit langem im Buch Specifying Systems und anderen Werken beantwortet. </p><br><p>  Ich werde die Antwort nicht vollst√§ndig zitieren, kurz gesagt lautet das Wesentliche: Wenn es keine genaue Zeitskala gibt, in der jedes Ereignis an einen bestimmten Moment gebunden ist, gibt es keinen Unterschied bei der Modellierung paralleler Ereignisse als nicht deterministisch auftretende sequentielle Ereignisse, da wir immer davon ausgehen k√∂nnen, dass ein Ereignis fr√ºher als ein anderes aufgetreten ist Infinitesimalwert. </p><br><p>  Was aber wirklich wichtig ist, ist die kompetente Zuordnung der atomaren Schritte.  Wenn es zu viele von ihnen gibt, kommt es zu einer kombinatorischen Explosion des Zustandsraums.  Wenn Sie weniger Schritte als n√∂tig ausf√ºhren oder diese falsch ausw√§hlen, dh die Wahrscheinlichkeit, dass ein ung√ºltiger Zustand / √úbergang ung√ºltig wird (d. H. Wir werden die Fehler im Modell √ºbersehen). </p><br><p>  Um Prozesse korrekt in atomare Schritte zu unterteilen, m√ºssen Sie eine gute Vorstellung davon haben, wie das System in Bezug auf die Abh√§ngigkeit von Prozessen von Daten und Synchronisationsmechanismen funktioniert. </p><br><p>  Die Aufteilung von Prozessen in atomare Schritte verursacht in der Regel keine gro√üen Probleme.  Wenn dies der Fall ist, deutet dies eher auf ein Unverst√§ndnis des Problems hin und nicht auf Probleme beim Kompilieren des Modells und Schreiben der TLA + -Spezifikation.  Dies ist ein weiteres sehr n√ºtzliches Merkmal formaler Spezifikationen: Sie erfordern eine gr√ºndliche Untersuchung und Analyse. <br>  ein Problem.  Wenn die Aufgabe sinnvoll und gut verstanden ist, gibt es in der Regel keine Probleme mit ihrer Formalisierung. </p><br><h2 id="proverka-modeli">  Modellpr√ºfung </h2><br><p>  F√ºr die Modellierung werde ich TLA-Toolbox verwenden.  Sie k√∂nnen nat√ºrlich alles √ºber die Befehlszeile ausf√ºhren, aber die <em>IDE</em> ist immer noch praktischer, insbesondere um sich mit dem Modellieren mit TLA + vertraut zu machen. </p><br><p>  Die Erstellung des Projekts ist in Handb√ºchern, Artikeln und B√ºchern gut beschrieben, auf die ich am Ende des Artikels verwiesen habe, sodass ich mich nicht wiederholen werde.  Das einzige, worauf ich Sie aufmerksam machen werde, sind die Simulationseinstellungen. </p><br><p>  TLC ist eine <em>Modellpr√ºfung</em> mit expliziter Zustandspr√ºfung.  Es ist klar, dass der Zustandsraum durch angemessene Grenzen begrenzt werden muss.  Einerseits sollte es gro√ü genug sein, um die f√ºr uns interessanten Eigenschaften √ºberpr√ºfen zu k√∂nnen, und andererseits klein genug, um die Simulation in angemessener Zeit mit akzeptablen Ressourcen abzuschlie√üen. </p><br><p>  Dies ist ein ziemlich heikler Punkt. Hier m√ºssen Sie die Eigenschaften des Systems und des Modells verstehen.  Aber es kommt schnell mit Erfahrung.  F√ºr den Anfang k√∂nnen Sie einfach die maximal m√∂glichen Grenzwerte festlegen, die hinsichtlich der Simulationszeit und des Ressourcenverbrauchs noch akzeptabel sind. </p><br><p>  Es gibt auch eine M√∂glichkeit, nicht den gesamten Zustandsraum, sondern selektive Ketten bis zu einer bestimmten Tiefe zu √ºberpr√ºfen.  Es ist auch manchmal m√∂glich und notwendig zu verwenden. </p><br><p>  Wir kehren zu den Simulationseinstellungen zur√ºck. </p><br><p>  Zun√§chst definieren wir die Einschr√§nkungen f√ºr den Zustandsraum des Systems.  Einschr√§nkungen werden im Abschnitt <em>Erweiterte Optionen /</em> Simulationseinstellungen f√ºr Statusbeschr√§nkungen festgelegt. </p><br><p>  Dort habe ich einen TLA + Ausdruck angegeben: <code>Cardinality(Events) &lt;= 5 /\ Event_Id &lt;= 5</code> , <br>  Dabei ist Event_Id die Obergrenze f√ºr den Wert der Ereigniskennung. <code>Cardinality(Events)</code> ist die Gr√∂√üe des Satzes von Ereignisdatens√§tzen (begrenzt das Basismodell) <br>  Daten von f√ºnf Datens√§tzen in einer Platte). </p><br><p>  In der Simulation betrachtet die DC nur die Zust√§nde, in denen diese Formel wahr ist. </p><br><p>  Sie k√∂nnen weiterhin g√ºltige <em>Status√ºberg√§nge</em> zulassen ( <em>Erweiterte Optionen / Aktionsbeschr√§nkung</em> ). <br>  aber wir brauchen es nicht </p><br><p>  Als n√§chstes geben wir die TLA + -Formel an, die unser System beschreibt: <em>Modell√ºbersicht / Zeitformel</em> = <code>Spec</code> , wobei <em>Spezifikation</em> der Name der von PlusCal automatisch generierten TLA + -Formel ist (im obigen Modellcode hei√üt es nicht: Um Platz zu sparen, habe ich das Ergebnis der √úbersetzung von PlusCal in TLA + nicht zitiert). . </p><br><p>  Die n√§chste Einstellung, auf die Sie achten sollten, ist die Deadlock-Pr√ºfung. <br>  (H√§kchen in <em>Modell√ºbersicht / Deadlock</em> ).  Wenn dieses Flag aktiviert ist, √ºberpr√ºft der TLC das Modell auf "h√§ngende" Zust√§nde, dh solche, bei denen keine ausgehenden √úberg√§nge vorhanden sind.  Wenn sich solche Zust√§nde im Zustandsraum befinden, bedeutet dies einen eindeutigen Fehler im Modell.  Oder in TLC, das wie jedes andere nicht triviale Programm nicht vor Fehlern gefeit ist :) In meiner (nicht so gro√üen) Praxis bin ich noch nicht auf Deadlocks gesto√üen. </p><br><p>  Und schlie√ülich, f√ºr die all diese Tests gestartet wurden, die Sicherheitsformel in <em>Modell√ºbersicht / Invarianten</em> = <code>ALL_EVENTS_PROCESSED(state)</code> . </p><br><p>  TLC √ºberpr√ºft die G√ºltigkeit der Formel in jedem Zustand. Wenn sie falsch wird, <br>  zeigt eine Fehlermeldung an und zeigt die Reihenfolge der Zust√§nde an, die zu dem Fehler gef√ºhrt haben. </p><br><p>  Nach dem Starten von TLC, nachdem etwa 8 Minuten gearbeitet wurde, wurde "Keine Fehler" gemeldet.  Dies bedeutet, dass das Modell getestet wird und die angegebenen Eigenschaften erf√ºllt. </p><br><p>  TLC zeigt auch viele interessante Statistiken an.  Zum Beispiel wurden f√ºr dieses Modell 7 677 824 eindeutige Zust√§nde erhalten, insgesamt untersuchte die DC 27 109 029 Zust√§nde, der Durchmesser des Zustandsraums betr√§gt 47 (dies ist die maximale L√§nge der Zustandskette vor der Wiederholung). <br>  maximale Zyklusl√§nge aus sich nicht wiederholenden Zust√§nden im Zustands- und √úbergangsgraphen). </p><br><p>  Wenn wir 27 Millionen Staaten in 8 Minuten aufteilen, erhalten wir ungef√§hr 56.000 Staaten pro Sekunde, was m√∂glicherweise nicht sehr schnell erscheint.  Beachten Sie jedoch, dass ich die Simulation auf einem Laptop ausgef√ºhrt habe, der im Energiesparmodus arbeitete (ich habe die Kernfrequenz auf 800 MHz erzwungen, weil ich zu diesem Zeitpunkt in einem elektrischen Zug unterwegs war) und das Modell √ºberhaupt nicht f√ºr die Simulationsgeschwindigkeit optimiert habe. </p><br><p>  Es gibt viele M√∂glichkeiten, die Simulation zu beschleunigen: von der Portierung eines Teils des TLA + -Modellcodes auf Java und der schnellen Verbindung zu TLC (es ist n√ºtzlich, alle Arten von Hilfsfunktionen zu beschleunigen) bis zur Ausf√ºhrung von TLC in den Clouds und Clustern (die Cloud-Unterst√ºtzung von Amazon und Azure ist direkt in TLC selbst integriert). </p><br><h1 id="vtoraya-optimizaciya">  Zweite Optimierung </h1><br><p>  Im vorherigen Algorithmus ist bis auf einige Probleme alles in Ordnung: </p><br><ol><li>  <code>[state.time, state.time + Delta]</code> wir nicht alle Ereignisse aus der blauen Zone im Intervall <code>[state.time, state.time + Delta]</code> , k√∂nnen wir nicht zu Ereignissen mit hoher Priorit√§t <code>[state.time, state.time + Delta]</code> .  Das hei√üt, sp√§te Ereignisse werden noch mehr sp√§t sein.  Und normalerweise ist die Verz√∂gerung nicht vorhersehbar.  Aus diesem Grund kann state.time weit hinter der aktuellen Zeit zur√ºckbleiben, und dies ist die Ursache f√ºr das n√§chste Problem. </li><li>  Ereignisse, die im Bereich normaler Ereignisse eintreffen, k√∂nnen versp√§tet sein ( <em>id</em> &gt; state.id).  Sie haben bereits hohe Priorit√§t und sollten als Ereignisse aus der rosa Region betrachtet werden. Wir betrachten sie weiterhin als normal und behandeln sie als normal. </li><li>  Es ist schwierig, das Zwischenspeichern von Ereignissen und das Auff√ºllen von Caches (Lesen aus der Datenbank) zu organisieren. </li></ol><br><p>  Wenn die ersten beiden Punkte offensichtlich sind, wird der dritte wahrscheinlich die meisten Fragen aufwerfen.  Lassen Sie uns n√§her darauf eingehen. </p><br><p>  Angenommen, wir m√∂chten zuerst eine feste Anzahl von Ereignissen in den Speicher lesen und dann verarbeiten. </p><br><p>  Nach der Verarbeitung m√∂chten wir Ereignisse in der Datenbank mit Blockabfragen als verarbeitet markieren. Wenn Sie nicht mit Bl√∂cken, sondern mit einzelnen Ereignissen arbeiten, wird das Zwischenspeichern keinen gro√üen Gewinn bringen. </p><br><p>  Angenommen, wir haben einen Teil der Bl√∂cke verarbeitet und m√∂chten den Cache erg√§nzen.  Wenn dann sp√§te Ereignisse mit hoher Priorit√§t w√§hrend der Verarbeitung eintreffen, k√∂nnen wir sie fr√ºhzeitig verarbeiten. </p><br><p>  Das hei√üt, es ist sehr w√ºnschenswert, Ereignisse in kleinen Bl√∂cken lesen zu k√∂nnen, um sp√§te Ereignisse so schnell wie m√∂glich zu verarbeiten, aber das Verarbeitungsattribut in der Datenbank mit gro√üen Bl√∂cken gleichzeitig zu aktualisieren - aus Effizienzgr√ºnden. </p><br><p>  Was ist in diesem Fall zu tun? </p><br><p>  Versuchen Sie, mit der Datenbank in kleinen Bl√∂cken mit einem blauen und rosa Bereich zu arbeiten, und verschieben Sie den Statuspunkt in kleinen Schritten. </p><br><p>  Somit wurde der Cache eingef√ºhrt und aus den Datenbankdaten in ihn eingelesen. Nach jedem Lesen wurde der Statuspunkt verschoben, um bereits gelesene Ereignisse nicht erneut zu lesen. </p><br><p>  Jetzt ist der Algorithmus etwas komplizierter geworden, wir haben begonnen, in begrenzten Abschnitten zu lesen. </p><br><h2 id="blok-shema-1">  Flussdiagramm </h2><br><p><img src="https://habrastorage.org/webt/as/8n/qk/as8nqk0dmos8bsiwiigzphb7gns.png"></p><br><p><img src="https://habrastorage.org/webt/wn/9x/yx/wn9xyxfi4j2021hibcqxe3abhn8.png"></p><br><p>  In diesem Algorithmus ist ersichtlich, dass aufgrund der Beschr√§nkung auf Bl√∂cke lesbarer Ereignisse die maximale Verz√∂gerung beim √úbergang von der Verarbeitung mit niedriger Priorit√§t zur Verarbeitung mit hoher Priorit√§t gleich der maximalen Verarbeitungszeit des Blocks ist. </p><br><p>  Das hei√üt, jetzt k√∂nnen wir beide Ereignisse in kleinen Bl√∂cken in den Cache einlesen und die maximale Verz√∂gerung beim √úbergang zur Verarbeitung von Ereignissen mit hoher Priorit√§t durch Steuern der maximalen Blockgr√∂√üe zum Lesen steuern. </p><br><h2 id="primer-raboty-algoritma-1">  Beispiel f√ºr eine Algorithmusoperation </h2><br><p>  Schauen wir uns den Algorithmus in Arbeit in Schritten an.  Nehmen Sie der <code>LIMIT = 2</code> . </p><br><p><img src="https://habrastorage.org/webt/-i/u8/qz/-iu8qzxfabbn9gcig_ekb1xhabu.png"></p><br><p><img src="https://habrastorage.org/webt/3x/if/ju/3xifju7ktzac6eyyutbhfanpufs.png"></p><br><p><img src="https://habrastorage.org/webt/ab/dg/o7/abdgo7ieinh8ddx6tnthfcsrwre.png"></p><br><p><img src="https://habrastorage.org/webt/ei/qg/al/eiqgal0lfwfiwtdltnb-e1bjyc0.png"></p><br><p><img src="https://habrastorage.org/webt/hp/2i/kd/hp2ikd4mgcqsswoiwwexz_kmp-e.png"></p><br><p><img src="https://habrastorage.org/webt/tq/ct/fv/tqctfvtnrqo939zqut2-8lwjale.png"></p><br><p><img src="https://habrastorage.org/webt/yk/3j/jk/yk3jjkf9htxfmdvwsa1dyrogqqo.png"></p><br><p><img src="https://habrastorage.org/webt/ym/9d/vt/ym9dvt1_ykho82n4xhxwtlbkeow.png"></p><br><p>  Es stellt sich heraus, dass das Problem gel√∂st ist?  Aber nein.  (Es ist klar, dass, wenn das Problem zu diesem Zeitpunkt vollst√§ndig gel√∂st war, dann <br>  Dieser Artikel w√§re nicht gewesen :)) </p><br><h2 id="oshibka">  Der Fehler? </h2><br><p>  In dieser Form hat der Algorithmus ziemlich lange funktioniert.  Tests gingen alle gut.  Auch in der Produktion gab es keine Probleme. </p><br><p>  Aber der Entwickler des Algorithmus und seiner Implementierung (mein Kollege Peter Reznikov) ist sehr erfahren und er hatte intuitiv das Gef√ºhl, dass hier etwas nicht stimmt.  Daher wurde neben dem Hauptcode eine √úberpr√ºfung durchgef√ºhrt, bei der gelegentlich ein Timer √ºberpr√ºft wurde, um festzustellen, ob Ereignisse verpasst wurden, und <br>  wenn √ºberhaupt, habe ich sie verarbeitet. </p><br><p>  In dieser Form hat das System erfolgreich funktioniert.  Es stimmt, niemand hat Statistiken √ºber die Anzahl der vom Pr√ºfer ausgew√§hlten Ereignisse gef√ºhrt.  Daher wissen wir leider nicht, wie viele Fehler mit einer vorzeitigen Ereignisverarbeitung verbunden waren. </p><br><p>  Ich habe eine √§hnliche Warteschlange zeitgebundener Objekte implementiert.  Wir haben mit Peter Reznikov √ºber die Implementierung und Optimierung von Algorithmen gesprochen und √ºber diesen Algorithmus f√ºr die Arbeit mit Ereignissen gesprochen.  Sie bezweifelten, dass der Algorithmus korrekt ist.  Wir haben uns f√ºr ein kleines Modell entschieden, um Zweifel zu best√§tigen oder zu zerstreuen.  Infolgedessen haben wir einen Fehler gefunden. </p><br><h2 id="model-1">  Modell </h2><br><p>  Bevor ich den Trace mit einem Fehler zerlege, gebe ich den Quellcode des Modells an, auf dem der Fehler erkannt wurde. </p><br><p>  Die Unterschiede zum Vorg√§ngermodell sind sehr gering, die Gr√∂√üe der Lesebl√∂cke ist nur begrenzt: Der Operator Limit wird hinzugef√ºgt und dementsprechend werden die Operatoren zur Ereignisauswahl ge√§ndert. </p><br><p>  Um Platz zu sparen, habe ich nur Kommentare zu den ge√§nderten Teilen des Modells hinterlassen. </p><br><pre> <code class="plaintext hljs">---------------- MODULE events ---------------- EXTENDS Naturals, FiniteSets, Sequences, TLC (* --algorithm Events \*    LIMIT, \*     \*     \*   variables Events = {}, Event_Id = 0, MAX_TIME = 5, LIMIT \in 1..3, TIME_DELTA \in 1..2 define ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) Limit(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result \* SELECT * FROM events \* WHERE time &lt;= curr_time AND id &gt; max_id \* ORDER BY id \* LIMIT limit SELECT_HIGH_PRIO(state, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time /\ e.id &gt;= state.id } \*   Id sorted == SortSeq(ToSeq(selected), EventsOrderById) \*    limited == Limit(sorted, limit) IN ToSet(limited) \* SELECT * FROM events \* WHERE time &gt; current_time \* AND time - Time &lt;= delta_time \* ORDER BY time, id \* LIMIT limit SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events: /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } \*   sorted == SortSeq(ToSeq(selected), EventsOrder) \*   limited == Limit(sorted, limit) IN ToSet(limited) ALL_EVENTS_PROCESSED(state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt;= state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable state = ZERO_EVT, events = {}; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, LIMIT) new_limit == LIMIT - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, TIME_DELTA, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events))] || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Ein aufmerksamer Leser kann feststellen, dass neben der Einf√ºhrung von Limit auch die Bezeichnungen in event_processor ge√§ndert wurden.  Das Ziel ist etwas besser, echten Code zu simulieren, den zwei Auswahlen in einer Transaktion ausf√ºhren, <em>dh</em> die Auswahl von Ereignissen kann als atomar ausgef√ºhrt bezeichnet werden. </p><br><p>  Nun, und wenn wir einen Fehler in einem Modell mit gr√∂√üeren atomaren Operationen finden, garantiert dies praktisch, dass der gleiche Fehler im gleichen Modell auftritt, aber mit kleineren atomaren Schritten (eine ziemlich starke Aussage, aber ich denke, es ist intuitiv; obwohl es sollte gut sein, wenn es nicht bewiesen ist, und dann an einer gro√üen Auswahl von Modellen √ºberpr√ºft werden). </p><br><h2 id="proverka-modeli-1">  Modellpr√ºfung </h2><br><p>  Wir starten die Simulation mit den gleichen Parametern wie in der ersten Ausf√ºhrungsform. </p><br><p>  Bei der Suche in der Breite wird im 19. Schritt der Simulation eine Verletzung der Eigenschaft ALL_EVENTS_PROCESSED angezeigt. </p><br><p>  F√ºr gegebene Anfangsdaten (dies ist ein sehr kleiner Zustandsraum) zeigt der Fehler im 19. Schritt an, dass der Fehler sehr selten und schwer zu erkennen ist, da zuvor alle Zustandsketten mit einer L√§nge von weniger als 19 untersucht wurden. </p><br><p>  Daher ist dieser Fehler in Tests schwer zu erkennen.  Nur wenn Sie wissen, wo Sie suchen m√ºssen, und speziell Tests und tempor√§re H√ºtten ausw√§hlen. </p><br><p>  Ich werde nicht die gesamte Route mitbringen, um Platz und Zeit zu sparen.  Hier ist ein Segment aus mehreren Staaten zusammen mit einem Fehler: </p><br><p><img src="https://habrastorage.org/webt/1g/xq/en/1gxqen3cvdftawczsxb5apskzlc.png"></p><br><p><img src="https://habrastorage.org/webt/5r/b6/ml/5rb6mlga8u0rfalc1_3klnb6-ky.png"></p><br><p><img src="https://habrastorage.org/webt/5_/cz/n4/5_czn4pqrkbkhy6uocf3zllz39w.png"></p><br><p><img src="https://habrastorage.org/webt/_v/s8/d6/_vs8d6feegcimnw9bla8ylm-878.png"></p><br><p><img src="https://habrastorage.org/webt/wo/0j/qu/wo0jquth7jszanamlk7l3dpkspc.png"></p><br><h2 id="analiz-i-ispravlenie">  Analyse und Korrektur </h2><br><p>  Was ist passiert? </p><br><p>  Wie Sie sehen, manifestierte sich der Fehler darin, dass wir das Ereignis {2, 3} verpasst haben, weil das Limit beim Ereignis {2, 1} endete, und danach den Status des Koordinators ge√§ndert haben.  Dies kann nur geschehen, wenn zu einem bestimmten Zeitpunkt mehrere Ereignisse vorliegen. </p><br><p>  Deshalb war der Fehler in Tests schwer zu fassen.  F√ºr seine Manifestation ist es notwendig, dass ziemlich seltene Dinge zusammenfallen: </p><br><ol><li>  Mehrere Ereignisse treffen denselben Zeitpunkt. </li><li>  Die Begrenzung der Auswahl von Ereignissen endete vor dem Lesen all dieser Ereignisse. </li></ol><br><p>  Der Fehler kann relativ einfach korrigiert werden, wenn der Status des Koordinators etwas erweitert wird: F√ºgen Sie die Zeit und die Kennung des zuletzt gelesenen Ereignisses aus dem normalen Ereignisbereich mit der maximalen ID hinzu, wenn die Zeit dieses Ereignisses dem n√§chsten Status entspricht. </p><br><p>  Wenn es kein solches Ereignis gibt, setzen wir den zus√§tzlichen Status (extra_state) auf einen ung√ºltigen Status (UNDEF_EVT) und ber√ºcksichtigen ihn bei der Arbeit nicht. </p><br><p>  Ereignisse aus der normalen Region, die im vorherigen Schritt des Koordinators nicht verarbeitet wurden, werden als hohe Priorit√§t angesehen, und wir werden die Auswahl des Pr√§dikats mit hoher Priorit√§t und Sicherheit entsprechend korrigieren. </p><br><p>  Es w√§re m√∂glich, einen weiteren Bereich zwischen hoher Priorit√§t und Normal einzuf√ºhren und den Algorithmus zu √§ndern.  Zuerst werden die mit hoher Priorit√§t, dann die Zwischenprodukte verarbeitet und dann mit der anschlie√üenden Zustands√§nderung zu den normalen √ºbergegangen. </p><br><p>  Solche √Ñnderungen w√ºrden jedoch zu einem gr√∂√üeren Refactoring-Volumen mit nicht offensichtlichen Vorteilen f√ºhren (der Algorithmus wird etwas klarer sein; andere Vorteile sind nicht sofort sichtbar). </p><br><p>  Aus diesem Grund haben wir uns entschlossen, den aktuellen Status und die Auswahl der Ereignisse aus der Datenbank nur geringf√ºgig anzupassen. </p><br><h2 id="skorrektirovannaya-model">  Angepasstes Modell </h2><br><p>  Hier ist das korrigierte Modell. </p><br><pre> <code class="plaintext hljs">------------------- MODULE events ------------------- EXTENDS Naturals, FiniteSets, Sequences, TLC \*        CONSTANTS MAX_TIME, LIMIT, TIME_DELTA (* --algorithm Events variables Events = {}, Limit \in LIMIT, Delta \in TIME_DELTA, Event_Id = 0 define \*    \*  ,   extra_state UNDEF_EVT == [time |-&gt; MAX_TIME + 1, id |-&gt; 0] ZERO_EVT == [time |-&gt; 0, id |-&gt; 0] MAX(S) == CHOOSE x \in S: \A y \in S: y &lt;= x MIN(S) == CHOOSE x \in S: \A y \in S: y &gt;= x RECURSIVE SetReduce(_, _, _) SetReduce(Op(_, _), S, value) == IF S = {} THEN value ELSE LET s == CHOOSE s \in S : TRUE IN SetReduce(Op, S \ {s}, Op(s, value)) ToSeq(S) == LET op(e, val) == Append(val, e) IN SetReduce(op, S, &lt;&lt; &gt;&gt;) ToSet(S) == {S[i] : i \in DOMAIN(S)} MapSet(Op(_), S) == {Op(x) : x \in S} GetIds(Evts) == MapSet(LAMBDA x: x.id, Evts) GetTimes(Evts) == MapSet(LAMBDA x: x.time, Evts) EventsOrderByTime(e1, e2) == e1.time &lt; e2.time EventsOrderById(e1, e2) == e1.id &lt; e2.id EventsOrder(e1, e2) == \/ EventsOrderByTime(e1, e2) \/ /\ e1.time = e2.time /\ EventsOrderById(e1, e2) TakeN(S, limit) == LET amount == MIN({limit, Len(S)}) result == IF amount &gt; 0 THEN SubSeq(S, 1, amount) ELSE &lt;&lt; &gt;&gt; IN result (* SELECT * FROM events WHERE time &lt;= curr_time AND id &gt; max_id ORDER BY id Limit limit *) SELECT_HIGH_PRIO(state, limit, extra_state) == LET \*      \* time &lt;= curr_time \* AND id &gt; maxt_id selected == {e \in Events : \/ /\ e.time &lt;= state.time /\ e.id &gt;= state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id} sorted == \*  SortSeq(ToSeq(selected), EventsOrderById) limited == TakeN(sorted, limit) IN ToSet(limited) SELECT_NORMAL(state, delta_time, limit) == LET selected == {e \in Events : /\ e.time &lt;= state.time + delta_time /\ e.time &gt; state.time } sorted == SortSeq(ToSeq(selected), EventsOrder) limited == TakeN(sorted, limit) IN ToSet(limited) \*    extra_state UpdateExtraState(events, state, extra_state) == LET exact == {evt \in events : evt.time = state.time} IN IF exact # {} THEN CHOOSE evt \in exact : \A e \in exact: e.id &lt;= evt.id ELSE UNDEF_EVT \*    extra_state ALL_EVENTS_PROCESSED(state, extra_state) == \A e \in Events: \/ e.time &gt;= state.time \/ e.id &gt; state.id \/ /\ e.time = extra_state.time /\ e.id &gt; extra_state.id end define; fair process inserter = "Sources" variable t; begin forever: while TRUE do get_time: with evt_time \in 0..MAX_TIME do t := evt_time; end with; commit: either Events := Events \union {[time |-&gt; t, id |-&gt; Event_Id]} || Event_Id := Event_Id + 1; or Event_Id := Event_Id + 1; end either; end while; end process fair process event_processor = "Event_processor" variable events = {}, state = ZERO_EVT, extra_state = UNDEF_EVT; begin forever: while TRUE do select: events := LET evts_high_prio == SELECT_HIGH_PRIO(state, Limit, extra_state) new_limit == Limit - Cardinality(evts_high_prio) evts_normal == SELECT_NORMAL(state, Delta, new_limit) IN evts_high_prio \union evts_normal; proc_evts: Events := Events \ events || state := [ time |-&gt; MAX({state.time} \union GetTimes(events)), id |-&gt; MAX({state.id} \union GetIds(events)) ]; extra_state := UpdateExtraState(events, state, extra_state) || events := {}; end while; end process end algorithm; *) \* BEGIN TRANSLATION \*  TLA+,     PlusCal  \* END TRANSLATION ===================================================</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, sind die √Ñnderungen sehr gering: </p><br><ol><li>  Zus√§tzliche Daten zum Status "extra_state" hinzugef√ºgt. </li><li>  Die Auswahl der Ereignisse mit hoher Priorit√§t wurde ge√§ndert. </li><li>   UpdateExtraState   extra_state. </li><li>  <em>safety</em> -    . </li></ol><br><h2 id="modelirovanie">  </h2><br><p>    ,   . ,      (,  ,    ,     ). <br>       ,       ,  TLA+/TLC .  :) :) </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>     , ,     ( , ,  ,    ). </p><br><p>  ,            ,        TLA+/TLC,     . ,    . </p><br><p>         TLA+/TLC  ,   ,           ( ,     )  . </p><br><p>  ,     ,     ,  TLA+/TLC                . </p><br><h1 id="bibliografiya">  Bibliographie </h1><br><h2 id="knigi">  B√ºcher </h2><br><h3 id="dlya-pogruzheniya-v-oblast">     </h3><br><p>   ,    ,   ,    .      . </p><br><ol><li><p> Michael Jackson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem Frames: Analysing &amp; Structuring Software Development Problems</a> </p><br><p>      (  !),     .   ,   .      ,        . </p><br></li><li><p> Hillel Wayne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Practical TLA+: Planning Driven Development</a> </p><br><p>     TLA+/PlusCal     .  ,    .      .         :    . </p><br></li><li><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MODEL CHECKING.      </a> </p><br><p>     .  ,    ,  .      ,            . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers</a> </p><br><p>    TLA+.   ,   .      :     ,   .  ,     TLA+  ,    . </p><br></li></ol><br><h3 id="primery-iz-promyshlennosti">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formal Development of a Network-Centric RTOS</a> </p><br><p>    TLA+          ( <em>RTOS</em> )       TLC. </p><br><p>      ,      .   ,   TLA+      ,             ,    <em>RTOS</em>   ‚Äî Virtuoso.       ,       . </p><br><p>          ,           (, ,  ,  ,    ). </p><br></li><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">w Amazon Web Services Uses Formal Methods</a> </p><br><p>   TLA+      AWS.        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://lamport.azurewebsites.net/tla/amazon-excerpt.html</a> </p><br></li></ol><br><h2 id="internet">  Das Internet </h2><br><h3 id="blogi">  Blogs </h3><br><ol><li><p> Hillel Wayne (  "Practical TLA+") <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </p><br><p>     .  ,  .   ,  -   . </p><br></li><li><p> Ron Pressler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </p><br><p>   .        .  ,      TLA+.       TLA+,    <em>computer</em> <em>science</em>    . </p><br></li><li><p> Leslie Lamport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </p><br><p>      TLA+  <em>computer</em> <em>science</em> .  <em>TLA+</em>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br></li></ol><br><h3 id="prezentacii-i-videokursy">    </h3><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">. . , . . , . . .      </a> </p><br><p>  ,   ,       . </p><br></li><li><p>   TLA+,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> </p><br><p>   ,     TLA+. ,       TLA+. </p><br></li><li><p> Hillel Wayne </p><br><p>      Hillel Wayne  .      . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Two Hardest Problems in CS (June 5, 2018)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Everything about distributed systems is terrible | Code Mesh LDN 18</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Designing Distributed Systems with TLA+ | √òredev 2018</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tackling Concurrency Bugs with TLA+</a> </li></ul><br></li><li><p> Ron Pressler </p><br><p>  ,   Hillel Wayne,     .  ,    . Ron Pressler      . ÃÅ       ,    ,     . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Practice and Theory of TLA+</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Why Writing Correct Software Is Hard and Why Math (Alone) Won't Help Us</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">On the Nature of Abstraction</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Finite of sense &amp; infinite of thought | Code Mesh LDN 18</a> </li></ul><br></li></ol><br><h3 id="modelirovanie-1">  </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLA toolbox</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLAPS</a> :        TLA+  <br>           .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alloy Analyzer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471012/">https://habr.com/ru/post/de471012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471000/index.html">Holzspielzeug, letzter Teil - 1997</a></li>
<li><a href="../de471004/index.html">Holzspielzeug - ein Epilog, der an die Decke genagelt bleibt</a></li>
<li><a href="../de471006/index.html">500 USD pro Monat: Wof√ºr geben Empf√§nger von bedingungslosem Grundeinkommen ihr Geld aus?</a></li>
<li><a href="../de471008/index.html">Lassen Sie uns √ºber die √úberwachung sprechen: Live-Aufzeichnung des Devops Deflope-Podcasts mit New Relic beim Treffen am 23. Oktober</a></li>
<li><a href="../de471010/index.html">Grover-Algorithmus und Datensuche</a></li>
<li><a href="../de471014/index.html">Wir bauen eine autonome Wasserdrohne oder wie ich davon getr√§umt habe, dem Baikal zu helfen, aber ich bin kein Gazprom. Teil 1</a></li>
<li><a href="../de471016/index.html">Datenbankdesign. Best Practices</a></li>
<li><a href="../de471018/index.html">Vergleich der Leistung von PC und Smartphone, einschlie√ülich iPhone 11</a></li>
<li><a href="../de471020/index.html">So finden Sie einen Fehler in einem Mikroprozessor, der vor 35 Jahren ver√∂ffentlicht wurde</a></li>
<li><a href="../de471022/index.html">Enth√ºllung eines 140 Jahre alten Geheimnisses in der Physik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>