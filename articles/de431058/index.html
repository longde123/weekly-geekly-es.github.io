<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéè ‚õπüèæ üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© Erste Schritte mit Unicorn Engine üç∂ üÜé üò∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Suche nach "Unicorn Engine" auf Habr war ich √ºberrascht, dass dieses Tool noch nie in Artikeln vorgestellt wurde. Ich werde versuchen, diese L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erste Schritte mit Unicorn Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Bei der Suche nach "Unicorn Engine" auf Habr war ich √ºberrascht, dass dieses Tool noch nie in Artikeln vorgestellt wurde.  Ich werde versuchen, diese L√ºcke zu f√ºllen.  Beginnen wir mit den Grundlagen und sehen uns ein Beispiel f√ºr die Verwendung des Emulators im wirklichen Leben an.  Um das Rad nicht neu zu erfinden, habe ich beschlossen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Handbuch einfach zu √ºbersetzen.  <em>Bevor ich anfange, werde ich sagen, dass alle meine Kommentare oder Kommentare so aussehen werden</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  Was ist ein Einhornmotor? </h1><br><p>  <em>Die Entwickler selbst schreiben dar√ºber</em> <del>  <em>Einhornmotor</em> </del>  <em>Einhorn-Motor wie folgt:</em> </p><br><blockquote>  Unicorn ist ein leichter Prozessoremulator mit mehreren Plattformen und mehreren Architekturen. </blockquote><p>  Dies ist kein Standardemulator.  Es emuliert nicht den Betrieb des gesamten Programms oder des gesamten Betriebssystems.  Es werden keine Systembefehle unterst√ºtzt (z. B. √ñffnen einer Datei, Ausgabe eines Zeichens an die Konsole usw.).  Sie m√ºssen das Markup des Speichers durchf√ºhren und die Daten selbst in den Speicher laden. Anschlie√üend starten Sie einfach die Ausf√ºhrung von einer bestimmten Adresse aus. </p><br><p>  Wie ist es also n√ºtzlich? </p><br><ul><li>  Bei der Analyse von Viren k√∂nnen Sie einzelne Funktionen aufrufen, ohne einen sch√§dlichen Prozess zu erstellen. </li><li>  CTF l√∂sen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum Fuzzing</a> . </li><li>  <a href="">Ein Plugin f√ºr gdb</a> zur Vorhersage des zuk√ºnftigen Zustands, z. B. zuk√ºnftige Spr√ºnge oder Registerwerte. </li><li>  Emulation eines funktionsreichen Codes. </li></ul><br><p>  Was brauchst du </p><br><ul><li>  Installierte Unicorn Engine mit Python-Bindung. </li><li>  Disassembler </li></ul><br><h1 id="primer">  Beispiel </h1><br><p>  Nehmen Sie als Beispiel eine Aufgabe mit hxp CTF 2017 unter dem Namen <strong><em>Fibonacci</em></strong> .  Die Bin√§rdatei kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </p><br><p>  Wenn Sie das Programm starten, wird unsere Flagge in der Konsole angezeigt, jedoch sehr langsam.  Jedes nachfolgende Flag-Byte wird als langsamer und langsamer angesehen. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Dies bedeutet, dass wir den Betrieb dieser Anwendung optimieren m√ºssen, um das Flag in angemessener Zeit zu erhalten. </p><br><p>  Mit IDA Pro ( <em>ich pers√∂nlich habe radare2 + Cutter verwendet</em> ) haben wir den Code in einen C-√§hnlichen Pseudocode dekompiliert.  Trotz der Tatsache, dass der Code nicht richtig dekompiliert wurde, k√∂nnen wir immer noch Informationen dar√ºber erhalten, was im Inneren passiert. </p><br><div class="spoiler">  <b class="spoiler_title">Dekompilierter Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Hier ist der Assembler-Code der <em>Haupt-</em> und <em>Fibonacci-</em> Funktionen: </p><br><div class="spoiler">  <b class="spoiler_title">Haupt</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  In dieser Phase haben wir viele M√∂glichkeiten, dieses Problem zu l√∂sen.  Zum Beispiel k√∂nnen wir den Code mit einer der Programmiersprachen wiederherstellen und dort die Optimierung anwenden, aber der Prozess der Wiederherstellung des Codes ist eine sehr schwierige Aufgabe, bei der wir Fehler machen k√∂nnen.  Nun, dann ist es im Allgemeinen wertlos, den Code zu vergleichen, um den Fehler zu finden.  Wenn wir jedoch die Unicorn Engine verwenden, k√∂nnen wir die Phase der Code-Rekonstruktion √ºberspringen und das oben beschriebene Problem vermeiden.  Nat√ºrlich k√∂nnen wir diese Probleme vermeiden, indem wir frida verwenden oder Skripte f√ºr gdb schreiben, aber darum geht es nicht. </p><br><p>  Bevor wir mit der Optimierung beginnen, f√ºhren wir die Emulation in der Unicorn Engine aus, ohne das Programm zu √§ndern.  Und erst nach einem erfolgreichen Start k√∂nnen wir mit der Optimierung fortfahren. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  Schritt 1: Lassen Sie die Virtualisierung kommen </h2><br><p>  Lassen Sie uns die Datei fibonacci.py erstellen und neben der Bin√§rdatei speichern. </p><br><p>  Beginnen wir mit dem Importieren der erforderlichen Bibliotheken: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  In der ersten Zeile werden die wichtigsten bin√§ren und grundlegenden Einhornkonstanten geladen.  In der zweiten Zeile werden die Konstanten f√ºr die beiden x86- und x86_64-Architekturen geladen. </p><br><p>  F√ºgen Sie als N√§chstes einige notwendige Funktionen hinzu: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Hier haben wir die Funktionen angek√ºndigt, die wir sp√§ter ben√∂tigen werden: </p><br><ul><li>  <strong>read gibt</strong> einfach den Inhalt der Datei zur√ºck, </li><li>  <strong>u32 verwendet</strong> eine 4-Byte-Zeichenfolge in LE-Codierung und konvertiert in int, </li><li>  <strong>p32</strong> macht das Gegenteil - es nimmt eine Zahl und wandelt sie in eine 4-Byte-Zeichenfolge in LE-Codierung um. </li></ul><br><p>  Hinweis: Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pwntools</a> installiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben</a> , m√ºssen Sie diese Funktionen nicht erstellen, sondern nur importieren: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  Beginnen wir also mit der Initialisierung unserer Unicorn Engine-Klasse f√ºr die x86_64-Architektur: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Hier rufen wir die <strong>Uc-</strong> Funktionen mit folgenden Parametern auf: </p><br><ul><li>  Der erste Parameter ist die Hauptarchitektur.  Konstanten beginnen mit <strong>UC_ARCH_</strong> ; </li><li>  Der zweite Parameter ist die Spezifikation der Architektur.  Konstanten beginnen mit <strong>UC_MODE_</strong> . </li></ul><br><p>  Sie finden alle Konstanten im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheatsheet</a> . </p><br><p>  Wie ich oben geschrieben habe, m√ºssen wir den virtuellen Speicher manuell initialisieren, um die Unicorn Engine verwenden zu k√∂nnen.  In diesem Beispiel m√ºssen wir den Code und den Stapel irgendwo im Speicher ablegen. </p><br><p>  Die Basisadresse (Basisadresse) der Bin√§rdatei beginnt bei 0x400000.  Setzen wir unseren Stack auf 0x0 und weisen ihm 1024 * 1024 Speicher zu.  H√∂chstwahrscheinlich brauchen wir nicht so viel Platz, aber es tut immer noch nicht weh. </p><br><p>  Wir k√∂nnen den Speicher markieren, indem <strong>wir die</strong> Methode <strong>mem_map</strong> aufrufen. </p><br><p>  F√ºgen Sie diese Zeilen hinzu: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Jetzt m√ºssen wir die Bin√§rdatei auf dieselbe Weise wie der Bootloader in ihre Hauptadresse laden.  Danach m√ºssen wir <strong>RSP</strong> auf das Ende des Stapels setzen. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Jetzt k√∂nnen wir die Emulation starten und den Code ausf√ºhren, aber wir m√ºssen herausfinden, mit welcher Adresse die Arbeit beginnen soll und wann der Emulator anhalten soll. </p><br><p>  Nehmen Sie die Adresse des ersten Befehls von <strong>main ()</strong> , wir k√∂nnen die Emulation von 0x004004e0 starten.  Das Ende wird als Aufruf von <strong>putc ("\ n") betrachtet</strong> , das sich bei 0x00400575 befindet, nachdem das gesamte Flag angezeigt wurde. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Wir k√∂nnen anfangen zu emulieren: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  F√ºhren Sie nun das Skript aus: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Ups, etwas ist schief gelaufen, aber wir wissen nicht einmal was.  Kurz bevor wir <strong>mu.emu_start</strong> aufrufen <strong>, k√∂nnen</strong> wir hinzuf√ºgen: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Dieser Code f√ºgt einen Hook hinzu.  Wir deklarieren unsere eigene <strong>hook_code-</strong> Funktion, die vom Emulator vor jedem Befehl aufgerufen wird.  Es werden folgende Parameter ben√∂tigt: </p><br><ul><li>  unsere Kopie von <strong>Uc</strong> , </li><li>  Anweisungsadresse </li><li>  Gr√∂√üenanweisungen </li><li>  Benutzerdaten (wir k√∂nnen diesen Wert mit einem optionalen Argument an <strong>hook_add () √ºbergeben</strong> ). <br>  Wenn wir nun das Skript ausf√ºhren, sollten wir die folgende Ausgabe sehen: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  An der Adresse, an der der Fehler aufgetreten ist, k√∂nnen wir verstehen, dass unser Skript diesen Befehl nicht verarbeiten kann: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Diese Anweisung liest Daten von der Adresse 0x601038 (Sie k√∂nnen sie in IDA Pro sehen).  Dies ist der Abschnitt <strong>.bss</strong> , den wir nicht markiert haben.  Meine L√∂sung w√§re, einfach alle problematischen Anweisungen zu √ºberspringen, wenn dies die Programmlogik nicht beeinflusst. <br>  Unten ist eine weitere problematische Anweisung: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  Wir k√∂nnen mit glibc keine Funktionen aufrufen, da glibc nicht im Speicher geladen ist.  In jedem Fall ben√∂tigen wir diesen Befehl nicht, sodass wir ihn auch √ºberspringen k√∂nnen. <br>  Hier ist die vollst√§ndige Liste der zu √ºberspringenden Befehle: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Um Befehle zu √ºberspringen, m√ºssen wir <strong>RIP</strong> mit der folgenden Anweisung neu schreiben: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Jetzt sollte <strong>hook_code ungef√§hr</strong> so aussehen: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Wir m√ºssen auch etwas mit Anweisungen tun, die das Flag in der Byte-f√ºr-Byte-Konsole anzeigen. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">__IO_putc verwendet</a> als <strong>erstes Argument</strong> Bytes f√ºr die Ausgabe (dies ist das <strong>RDI-</strong> Register). </p><br><p>  Wir k√∂nnen Daten direkt aus dem Register lesen, Daten an die Konsole ausgeben und diese Anweisungen √ºberspringen.  Der aktualisierte <strong>hook_code</strong> wird unten dargestellt: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Wir k√∂nnen rennen und alles wird funktionieren, aber immer noch langsam. </p><br><h1 id="shag-2-uvelichim-skorost">  Schritt 2: Geschwindigkeit erh√∂hen! </h1><br><p>  Lassen Sie uns dar√ºber nachdenken, die Arbeitsgeschwindigkeit zu erh√∂hen.  Warum ist dieses Programm so langsam? </p><br><p>  Wenn wir uns den dekompilierten Code ansehen, werden wir sehen, dass <strong>main ()</strong> mehrmals <strong>fibonacci ()</strong> aufruft und <strong>fibonacci ()</strong> eine rekursive Funktion ist.  Schauen wir uns diese Funktion genauer an: Sie ben√∂tigt zwei Argumente und gibt sie zur√ºck.  Der erste R√ºckgabewert wird √ºber das <strong>RAX-</strong> Register √ºbergeben, der zweite √ºber die Verkn√ºpfung, die √ºber das zweite Argument an die Funktion √ºbergeben wurde.  Wenn wir uns die Beziehung zwischen <strong>main ()</strong> und <strong>fibonacci ()</strong> genauer ansehen, werden wir <strong>feststellen</strong> , dass das zweite Argument nur zwei m√∂gliche Werte annimmt: 0 oder 1. Wenn Sie dies immer noch nicht sehen, f√ºhren Sie <strong>gdb aus</strong> und setzen Sie einen Haltepunkt am Anfang der Funktion <strong>Fibonacci ()</strong> . </p><br><p>  Um die Funktionsweise des Algorithmus zu optimieren, k√∂nnen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dynamische Programmierung verwenden,</a> um den R√ºckgabewert f√ºr eingehende Parameter zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichern</a> .  Denken Sie selbst, das zweite Argument kann nur zwei m√∂gliche Werte annehmen. Wir m√ºssen uns also nur daran erinnern <math> </math> $ inline $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ inline $   Dampf </p><br><div class="spoiler">  <b class="spoiler_title">F√ºr diejenigen, die nicht verstehen</b> <div class="spoiler_text"><p>  <strong>Fibonacci</strong> ist eine rekursive Funktion, die den n√§chsten Wert als Summe der beiden vorherigen berechnet.  Bei jedem Schritt geht sie tiefer.  Jedes Mal, wenn sie von vorne anf√§ngt, geht sie den gleichen Weg wie zuvor, plus eine neue Bedeutung. </p><br><p>  Ein Beispiel: <br>  Angenommen, Tiefe = 6, dann: <strong>1 1 2 3 5 8</strong> . <br>  Und jetzt Tiefe = 8, dann: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Wir konnten uns nur daran erinnern, dass die ersten 6 Mitglieder <strong>1 1 2 3 5 8 sind</strong> , und wenn sie uns bitten, mehr zu z√§hlen, als wir uns erinnern, nehmen wir das, woran wir uns erinnern, und z√§hlen nur das, was fehlt. </p></div></div><br><p>  Sobald <strong>RIP</strong> am Anfang von <strong>fibonacci () steht</strong> , k√∂nnen wir die Funktionsargumente erhalten.  Wir wissen, dass eine Funktion ein Ergebnis zur√ºckgibt, wenn sie eine Funktion beendet.  Da wir nicht mit zwei Parametern gleichzeitig arbeiten k√∂nnen, ben√∂tigen wir einen Stapel, um die Parameter zur√ºckzugeben.  Wenn wir <strong>fibonacci ()</strong> eingeben <strong>, m√ºssen</strong> wir die Argumente auf den Stapel legen und sie beim Beenden aufnehmen.  Um die gez√§hlten Paare zu speichern, k√∂nnen wir ein W√∂rterbuch verwenden. </p><br><p>  Wie verarbeite ich ein Wertepaar? </p><br><ul><li>  Ganz am Anfang der Funktion k√∂nnen wir √ºberpr√ºfen, ob dieses Paar in den bereits bekannten Ergebnissen enthalten ist: <br><ul><li>  Wenn ja, k√∂nnen wir dieses Paar zur√ºckgeben.  Wir m√ºssen nur die R√ºckgabewerte in <strong>RAX</strong> und an die Adresse des Links schreiben, die sich im zweiten Argument befindet.  Wir weisen auch eine <strong>RIP-</strong> Adresse zu, um die Funktion zu verlassen.  Wir k√∂nnen <strong>RET</strong> in <strong>fibonacci ()</strong> nicht verwenden, da diese Aufrufe verkn√ºpft sind. Daher werden wir <strong>RET</strong> von <strong>main () √ºbernehmen</strong> . </li><li>  Wenn dies nicht der Fall ist, f√ºgen wir sie einfach dem Stapel hinzu. </li></ul></li><li>  Vor dem Beenden der Funktion k√∂nnen wir das zur√ºckgegebene Paar speichern.  Wir kennen die Eingabeargumente, da wir sie von unserem Stapel lesen k√∂nnen. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Dieser Code wird hier vorgestellt.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Hier ist das ganze Skript</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hurra, wir konnten die Anwendung endlich mit der Unicorn Engine optimieren.  Gut gemacht! </p><br><h1 id="zametka">  Eine Notiz </h1><br><p>  Jetzt habe ich beschlossen, dir ein paar Hausaufgaben zu machen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier finden Sie</a> drei weitere Aufgaben, von denen jede einen Hinweis und eine vollst√§ndige L√∂sung enth√§lt.  Sie k√∂nnen beim L√∂sen von Problemen einen Blick auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheatsheet werfen</a> . </p><br><p>  Eines der nervigsten Probleme besteht darin, sich den Namen der gew√ºnschten Konstante zu merken.  Dies ist einfach zu handhaben, wenn Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPython</a> Tab-Add-Ons verwenden.  Wenn Sie IPython installiert haben, k√∂nnen Sie <strong>vom Einhornimport UC_ARCH_</strong> schreiben. Dr√ºcken Sie die Tabulatortaste, und es werden alle Konstanten <strong>angezeigt</strong> , die auf die gleiche Weise beginnen. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431058/">https://habr.com/ru/post/de431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431046/index.html">Wie Z-Index tats√§chlich funktioniert</a></li>
<li><a href="../de431048/index.html">Eventmaschine sch√ºtzt den Lebenszyklus</a></li>
<li><a href="../de431050/index.html">Die Illusion von Reinheit: Beeinflusst die Mineralisierung von Wasser seine Qualit√§t und wie hilft uns das TDS-Messger√§t?</a></li>
<li><a href="../de431052/index.html">Frontend DevDay: Karten, Teams, zwei Abfragen</a></li>
<li><a href="../de431056/index.html">USPACE: Drohnenzeit</a></li>
<li><a href="../de431060/index.html">Deutsches ID-Spoofing mit Online-Authentifizierung und Fl√ºchtlingsfinanzierung in Deutschland</a></li>
<li><a href="../de431064/index.html">Rigid Programmer Manifesto</a></li>
<li><a href="../de431066/index.html">DEFCON 16. Wie kann ich dich erreichen? Lassen Sie mich die Wege auflisten. Teil 2</a></li>
<li><a href="../de431068/index.html">Die Kunst der Bildung: die Ideologie der Spielautomaten</a></li>
<li><a href="../de431070/index.html">Hara essen? Wir sprechen √ºber die Essgewohnheiten eines modernen IT-Spezialisten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>