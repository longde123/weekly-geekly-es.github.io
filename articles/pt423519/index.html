<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÅÔ∏è üöï ‚õ™Ô∏è Monstro Errante: como se livrar de problemas no mapa üçë üêâ üêØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° no processo de cria√ß√£o de The Witness se tornou um dos meus jogos favoritos. Comecei a toc√°-lo a partir do momento em que Jonathan Blow come√ßou a d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monstro Errante: como se livrar de problemas no mapa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423519/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png" alt="imagem"></div><br>  J√° no processo de cria√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> se tornou um dos meus jogos favoritos.  Comecei a toc√°-lo a partir do momento em que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jonathan Blow</a> come√ßou a desenvolv√™-lo, e mal podia esperar pelo seu lan√ßamento. <br><br>  Ao contr√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> jogo anterior de John <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Braid</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> escala de recursos e programa√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> estava muito mais pr√≥xima dos projetos AAA do que dos jogos independentes.  Todo mundo que trabalha nesses projetos sabe que a quantidade de trabalho na escolha desse caminho aumenta significativamente.  Havia muito mais pessoas trabalhando no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness do</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Braid</a> , mas, como em qualquer projeto desse n√≠vel, h√° muitos aspectos que requerem mais aten√ß√£o do que o gerenciamento de projetos pode proporcionar. <br><br>  Portanto, eu sempre quis encontrar tempo livre para ajudar a criar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> no lan√ßamento do jogo.  Ent√£o, um dia, dia de a√ß√£o de gra√ßas, John e eu nos sentamos e examinamos a lista de coisas na base de c√≥digo que se beneficiariam de esfor√ßos adicionais de outro programador.  Tendo decidido a import√¢ncia relativa dos itens da lista, decidimos que a jogabilidade ser√° mais beneficiada se fizermos melhorias no c√≥digo de movimento do jogador. <br><a name="habracut"></a><br><h2>  Walkmonster na parede </h2><br>  No contexto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> , o objetivo do c√≥digo de movimento de um jogador √© ser o mais discreto poss√≠vel.  O jogador deve mergulhar completamente em uma realidade alternativa, e nesta experi√™ncia de jogo todos os detalhes s√£o importantes.  A √∫ltima coisa que quer√≠amos era que o jogador notasse que ele estava sentado no computador e movendo a c√¢mera virtual. <br><br>  Portanto, o c√≥digo de movimento do jogador deve ser absolutamente confi√°vel.  Se um jogador se agarra a cantos, fica preso em paredes, cai no ch√£o, desce de uma colina sem a capacidade de voltar etc., isso destr√≥i instantaneamente a ilus√£o de imers√£o e lembra ao jogador que ele est√° dentro de um processo artificial de jogo que √© interferido por um sistema n√£o confi√°vel deslocamentos.  Em algumas circunst√¢ncias, isso pode levar a conseq√º√™ncias desastrosas para o jogador, se ele n√£o tiver a oportunidade de resolver o problema reiniciando o jogo ou recarregando a (provavelmente muito antiga) ‚Äúdefesa‚Äù.  Se voc√™ costuma jogar, deve ter encontrado problemas desse tipo e sabe o que quero dizer. <br><br>  Ap√≥s nossa discuss√£o, comecei a trabalhar nessa tarefa.  Antes de tudo, decidi escrever ferramentas integradas para trabalhar com o c√≥digo de movimento do jogador, para que possamos analis√°-lo e observar seu comportamento atual.  Depois de abrir o projeto, me deparei com um problema s√©rio j√° conhecido por mim: como devo nomear o primeiro arquivo de c√≥digo-fonte?  Essa √© sempre a parte mais importante de qualquer projeto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como Bob Pollard disse uma vez sobre os nomes de grupos musicais e √°lbuns</a> ).  Se voc√™ der um nome adequado ao arquivo de origem, os trabalhos futuros ser√£o claros e suaves.  Escolha o errado - voc√™ pode destruir todo o projeto. <br><br>  Mas qual √© o nome do sistema para garantir a qualidade do c√≥digo de movimento do jogador?  Eu nunca tive que escrever um c√≥digo como esse antes.  Quando pensei nisso, percebi que pessoalmente vi um exemplo desse c√≥digo apenas uma vez: ao jogar a vers√£o beta inicial do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quake</a> .  Ele continha bugs com a localiza√ß√£o dos monstros, e na janela do console voc√™ podia ver mensagens de erro informando que os monstros, em vez de criar na superf√≠cie da Terra, s√£o criados, parcialmente se cruzando com a geometria dos n√≠veis.  Cada mensagem de depura√ß√£o come√ßou com a frase "walkmonster in wall at ..." <br><br>  Bingo!  √â dif√≠cil encontrar um nome melhor para o arquivo de c√≥digo do que "walk_monster.cpp".  E eu tinha quase certeza de que a partir de agora o c√≥digo seria criado sem problemas. <br><br><h2>  Movimento ao ponto </h2><br>  Quando voc√™ deseja testar o sistema, o mais importante √© <i>realmente test√°-lo</i> .  Embora essa regra pare√ßa simples, as pessoas que escrevem testes geralmente n√£o cumprem. <br><br>  No nosso caso particular, √© muito f√°cil <i>imaginar</i> que estamos testando o c√≥digo de movimento de um jogador sem realmente test√°-lo.  Aqui est√° um exemplo: voc√™ pode analisar o volume de colis√µes e superf√≠cies nas quais pode se mover no jogo, procurar pequenas superf√≠cies, lacunas, etc.  Tendo eliminado todos esses problemas, podemos dizer que agora o jogador pode se mover e caminhar com seguran√ßa pelo mundo. <br><br>  Mas, na verdade, testamos os dados, n√£o o c√≥digo.  √â muito prov√°vel que haja erros no c√≥digo de movimento que levem a um comportamento ruim, mesmo com dados de alta qualidade. <br><br>  Para evitar essa armadilha, eu queria que o sistema de testes estivesse o mais pr√≥ximo poss√≠vel do comportamento da pessoa que realmente controla o movimento do personagem no jogo.  Comecei escrevendo dois procedimentos que se tornariam os alicerces de tais testes. <br><br>  O primeiro procedimento √© o mais pr√≥ximo das a√ß√µes humanas reais.  Esta √© uma chamada de atualiza√ß√£o que se conecta ao sistema de processamento de entrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do The Witness</a> e transmite os eventos de teclado e mouse sintetizados para ele.  √â capaz de coisas simples que uma pessoa pode fazer: olhar em volta, ir em dire√ß√£o a um ponto, olhar para um ponto e assim por diante.  O procedimento executa essas a√ß√µes simplesmente simulando a intera√ß√£o do usu√°rio com o teclado e o mouse, ent√£o eu tinha certeza de que, ao processar a entrada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness,</a> tudo ser√° feito exatamente como foi durante o teste.  Nos artigos a seguir, falarei mais sobre esse sistema e seu uso. <br><br>  O segundo procedimento √© uma etapa que n√£o √© usada neste n√≠vel.  Essa √© uma fun√ß√£o chamada <i>DriveTowardPoint</i> , que recebe dois pontos no mundo e, causando um sistema de colis√£o existente de um jogador, tenta se mover perfeitamente de um ponto para outro.  Realizando o retorno, ela transmite informa√ß√µes sobre a tentativa: quais obst√°culos encontrou no caminho e se conseguiu chegar ao ponto final. <br><br>  Essa fun√ß√£o n√£o √© t√£o confi√°vel quanto um m√©todo de teste com entrada sintetizada, porque elimina parte do sistema de movimento do jogador dos testes.  Por exemplo, qualquer estado incorreto associado √† localiza√ß√£o do jogador em caso de problemas com o sistema de colis√£o n√£o afetar√° o teste usando esta fun√ß√£o.  No entanto, considerei esse n√≠vel de teste valioso, porque ele pode testar vastas √°reas muito mais rapidamente, porque n√£o requer a execu√ß√£o de todo o ciclo do jogo, ou seja, pode ser usado com muito mais frequ√™ncia em todo o mundo, e n√£o apenas em testes separados . <br><br>  Tamb√©m √© importante notar que esta fun√ß√£o n√£o transmite dados de entrada f√≠sicos;  por exemplo, as velocidades n√£o s√£o indicadas para o ponto de partida.  Isso ocorre porque <i>The Witness</i> n√£o √© um jogo de a√ß√£o, portanto o jogador tem poucas propriedades f√≠sicas significativas.  Os jogadores n√£o podem pular, correr nas paredes, ativar o tempo da bala.  Voc√™ pode suportar esses comportamentos usando sistemas que descreverei mais adiante, mas eles adicionam n√≠veis de complexidade que n√£o eram necess√°rios em nosso projeto. <br><br>  Seja como for, depois de implementar o <i>DriveTowardPoint,</i> eu poderia come√ßar a resolver a primeira tarefa do sistema: determinar para onde o jogador pode se mudar para <i>The Witness</i> Island. <br><br><h2>  Explora√ß√£o r√°pida de √°rvores aleat√≥rias </h2><br>  Para onde os jogadores podem ir?  Parece uma pergunta simples, mas voc√™ ficar√° surpreso ao descobrir quantos jogos foram lan√ßados quando a equipe de desenvolvimento n√£o sabia a resposta real.  Se isso for poss√≠vel, eu queria que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> fosse um daqueles poucos jogos em que os desenvolvedores antes do lan√ßamento sabiam exatamente onde o jogador poderia ou n√£o conseguir - sem surpresas. <br><br>  Isso torna a declara√ß√£o do problema (mas provavelmente n√£o a solu√ß√£o) muito simples: se houver uma fun√ß√£o <i>DriveTowardPoint</i> que determine com seguran√ßa se o jogador pode se mover em uma linha reta entre dois pontos, crie um mapa de cobertura mostrando onde o jogador pode estar. <br><br>  Por alguma raz√£o, sem escrever uma √∫nica linha de c√≥digo, por alguma raz√£o, pensei que seria melhor usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√Årvore aleat√≥ria de explora√ß√£o r√°pida</a> .  Para aqueles que n√£o est√£o familiarizados com esse algoritmo, explicarei: esse √© um processo muito simples no qual registramos todos os pontos que visitamos com refer√™ncia ao ponto de onde viemos.  Para adicionar um ponto √† √°rvore, pegamos um ponto de destino aleat√≥rio em qualquer lugar do mundo, selecionamos o ponto mais pr√≥ximo, j√° na √°rvore, e tentamos ir desse ponto ao alvo.  O local onde acabamos se torna o pr√≥ximo ponto de amostragem. <br><br>  Normalmente, esse algoritmo √© usado para procurar caminhos: alternadamente, para pontos aleat√≥rios, sempre selecionamos o mesmo ponto que o alvo.  Isso inclina a explora√ß√£o do espa√ßo em dire√ß√£o ao ponto alvo, e √© isso que √© necess√°rio quando nossa √∫nica tarefa √© atingir a meta.  Mas, neste caso, eu queria criar um mapa completo dos lugares em que o jogador pudesse se encaixar, ent√£o eu uso apenas amostras aleat√≥rias. <br><br>  Depois de implementar esse algoritmo (felizmente, √© muito simples e n√£o exigiu muito tempo), vi que ele executou um bom trabalho explorando o espa√ßo (os caminhos mostrados s√£o mostrados por caminhos brancos e as linhas vermelhas verticais indicam os locais onde o algoritmo colidiu com um obst√°culo) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed2/ca3/fe3/ed2ca3fe3dbfe02cb7c9779af50f9ca6.png"></div><br>  No entanto, depois de observar seu comportamento, percebi que, na verdade, n√£o precisava desse algoritmo.  Por exemplo, mesmo ap√≥s muitas itera√ß√µes, ele mal consegue explorar as salas semelhantes √†s mostradas abaixo, apesar da densa cobertura das √°reas externas.  Isso ocorre porque ele simplesmente n√£o √© capaz de selecionar pontos aleat√≥rios o suficiente dentro das salas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/2d4/5a5/9832d45a5c14dc13df9a03cf5216697f.png" width="1280" height="720"></div><br>  Se eu pensasse nisso antes de come√ßar o trabalho, entenderia que a vantagem de algoritmos como o Rapidly Exploring Random Tree √© que eles exploram efetivamente espa√ßos de alta dimens√£o.  De fato, essa √© geralmente a principal raz√£o de seu uso.  Mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a testemunha</a> n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tem</a> espa√ßos de alta dimens√£o.  Temos um espa√ßo bidimensional (sim, distribu√≠do por uma variedade complexa, mas ainda √© um espa√ßo bidimensional). <br><br>  Neste espa√ßo de baixa dimens√£o, as vantagens da Rapidly Exploring Random Tree s√£o fracas e sua desvantagem √© criticamente importante para a minha tarefa: o algoritmo √© projetado para a pesquisa mais eficiente de caminhos para pares de pontos conectados no espa√ßo, e n√£o para a pesquisa eficiente de todos os pontos alcan√ß√°veis ‚Äã‚Äãdesse espa√ßo.  Se voc√™ tiver essa tarefa, na verdade, a √Årvore aleat√≥ria de explora√ß√£o r√°pida levar√° uma quantidade enorme de tempo para resolv√™-la. <br><br>  Ent√£o, rapidamente percebi que precisava procurar um algoritmo que cobrisse efetivamente completamente os espa√ßos de baixa dimens√£o. <br><br><h2>  Enchimento 3D </h2><br>  Quando realmente pensei em escolher um algoritmo, ficou √≥bvio que, de fato, eu precisava de algo como o bom e velho preenchimento bidimensional, usado para preencher √°reas do bitmap.  Para qualquer ponto de partida, eu apenas tive que preencher todo o espa√ßo, verificando exaustivamente todas as formas poss√≠veis.  Infelizmente, por muitas raz√µes, a solu√ß√£o para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> ser√° muito mais complicada do que para um bitmap bidimensional. <br><br>  Primeiro, n√£o temos um conceito claro da conex√£o finita de um ponto.  Todo o espa√ßo √© cont√≠nuo.  Isto √© para um pixel, podemos listar facilmente 4 locais poss√≠veis que podem ser alcan√ßados a partir de um determinado ponto e verificar cada um deles por vez. <br><br>  Em segundo lugar, n√£o h√° tamanho fixo de posi√ß√£o no espa√ßo, como um pixel em um bitmap.  As superf√≠cies nas quais o jogador est√° se movendo e os obst√°culos podem estar em qualquer lugar, eles n√£o t√™m um tamanho topol√≥gico m√°ximo ou m√≠nimo, al√©m de n√£o serem vinculados a nenhuma grade externa. <br><br>  Em terceiro lugar, embora o movimento atrav√©s do espa√ßo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Witness</a> possa ser considerado localmente como se movendo ao longo de um avi√£o, o pr√≥prio espa√ßo √© na verdade um coletor profundamente interconectado e mut√°vel, no qual as √°reas pass√≠veis de caminhar do jogador est√£o diretamente acima de outras √°reas (√†s vezes pode haver v√°rios n√≠veis localizados um acima do outro) .  Al√©m disso, existem conex√µes que variam de acordo com as condi√ß√µes do mundo (portas abertas / fechadas, elevadores que sobem / descem, etc.). <br><br>  Dadas as dificuldades descritas, √© muito simples criar sua pr√≥pria op√ß√£o de implementa√ß√£o para preenchimento, que, como resultado, ser√° preenchida com √°reas que se cruzam, falta de rotas importantes, informa√ß√µes erradas sobre conex√µes em locais complexos da variedade.  No final, o algoritmo ser√° muito complicado de usar, porque, para levar em conta as mudan√ßas no estado do mundo, ele deve ser executado novamente. <br><br>  Como n√£o achei uma boa solu√ß√£o imediatamente, decidi come√ßar com experimentos simples.  Usando o c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rapidly Exploring Random Tree</a> que escrevi, mudei a sele√ß√£o dos pontos de destino de aleat√≥rio para muito controlado.  Cada vez que um novo ponto foi adicionado √† √°rvore, eu indiquei que os pontos est√£o a uma dist√¢ncia unit√°ria ao longo das dire√ß√µes principais a partir do ponto que ser√° considerado o futuro alvo, como acontece em um simples preenchimento bidimensional. <br><br>  Mas √© claro que, se n√£o for cuidadoso, isso criar√° um ciclo de amostragem in√∫til.  O ponto se ramificar√° nos 8 pontos vizinhos ao redor, mas esses 8 pontos tentar√£o novamente retornar ao ponto de partida, e isso continuar√° para sempre.  Portanto, al√©m da sele√ß√£o controlada de pontos-alvo, preciso de uma restri√ß√£o simples: qualquer ponto-alvo que n√£o esteja a uma certa dist√¢ncia √∫til m√≠nima de um ponto-alvo existente n√£o ser√° levado em considera√ß√£o.  Para minha surpresa, essas duas regras simples criam um preenchimento bem-sucedido: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/591/cf6/446/591cf6446fdcc8281f7ebd9449c48703.png"></div><br>  Nada mal para um experimento bastante simples.  Mas o algoritmo sofre do que chamo de "eco de fronteira".  Esse efeito pode ser visto na seguinte captura de tela feita durante o estudo do mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/fd0/25f/58efd025f80d2b96274ed849d3e4c568.png"></div><br>  Em √°reas sem obst√°culos, o algoritmo funciona bem por amostragem a dist√¢ncias relativamente iguais.  Mas quando a interse√ß√£o atinge a borda, eles criam pontos "fora da grade", ou seja, n√£o s√£o alinhados de acordo com o padr√£o de amostras, segundo o qual o algoritmo preenche a √°rea aberta vizinha.  A raz√£o pela qual os pontos "na grade" n√£o criam mosaico excessivamente denso √© porque cada novo ponto que tenta retornar a um dos anteriores encontra o ponto anterior e se recusa a recont√°-lo novamente.  Mas, ao criar novos pontos na borda, eles ficam completamente desalinhados, de modo que nada pode impedi-los de retornar ao espa√ßo j√° explorado.  Isso leva √† cria√ß√£o de uma onda de amostras tendenciosas, que continua at√© atingir uma linha aleat√≥ria de pontos em algum outro lugar pr√≥ximo o suficiente para que o algoritmo possa encontr√°-lo coincidindo com a frente m√≥vel dos pontos. <br><br>  Embora isso n√£o pare√ßa ser um problema s√©rio, √© realmente cr√≠tico.  O objetivo de tais algoritmos √© concentrar as amostras nas √°reas em que √© mais prov√°vel que produzam resultados produtivos.  Quanto mais tempo gastamos amostrando e realizando a amostragem de vastas √°reas abertas, menos tempo gastamos marcando as pr√≥prias faces dessa √°rea, que s√£o as informa√ß√µes de que precisamos.  Como estamos lidando com espa√ßo cont√≠nuo e apenas um n√∫mero infinito de amostras pode descrever sua forma real, a propor√ß√£o de amostras significativas para amostras insignificantes √© literalmente uma medida da efic√°cia do algoritmo na cria√ß√£o de uma superf√≠cie aceit√°vel para um jogador. <br><br>  No entanto, existe uma solu√ß√£o simples para esse problema em particular: voc√™ precisa expandir a dist√¢ncia na qual os dois pontos s√£o considerados "bastante pr√≥ximos".  Ao fazer isso, reduziremos a densidade de amostragem em locais que <i>n√£o</i> s√£o <i>importantes para</i> n√≥s, mas tamb√©m perderemos a densidade de amostragem em locais que s√£o <i>importantes para</i> n√≥s, por exemplo, as √°reas ao redor das fronteiras que queremos verificar cuidadosamente quanto √† presen√ßa de "buracos". <br><br><h2>  Amostragem direcional localizada </h2><br>  Provavelmente porque comecei com a √Årvore Aleat√≥ria Rapidamente Exploradora, meu c√©rebro suplantou todas as outras id√©ias, exceto a de proximidade.  Todos os algoritmos anteriores usavam proximidade para sua tarefa, por exemplo, para determinar um novo ponto que precisa ser considerado a seguir ou para selecionar um ponto a partir do qual come√ßar a chegar a um novo ponto de destino. <br><br>  Mas, depois de pensar sobre a tarefa por algum tempo, cheguei √† conclus√£o de que tudo est√° se tornando mais l√≥gico, se pensarmos n√£o apenas na proximidade, mas tamb√©m na <i>dire√ß√£o</i> .  Ent√£o fica √≥bvio, mas se voc√™ trabalhou em tarefas semelhantes, sabe que √© f√°cil cair na armadilha do pensamento tacanho e n√£o ver o quadro geral, mesmo que isso seja mais simples.  Foi exatamente o que aconteceu comigo. <br><br>  Quando mudei minha vis√£o das coisas, a abordagem correta da amostragem parecia √≥bvia.  Cada vez que eu queria expandir minha explora√ß√£o do espa√ßo a partir de um ponto, solicitava a exist√™ncia de pontos pr√≥ximos no ambiente local.  No entanto, em vez de usar a dist√¢ncia desses pontos para a pesquisa, os classificarei de acordo com suas instru√ß√µes (antes disso, usei apenas oito dire√ß√µes principais, mas queria experimentar outros kernels). <br><br>  Em qualquer dire√ß√£o em que n√£o "vejo" o ponto, percorro a dist√¢ncia especificada e adiciono um ponto em qualquer lugar em que parei (independentemente de ter encontrado algo ou n√£o).  Se eu vir um ponto em uma das dire√ß√µes, estou indo para l√° e verificando se consigo chegar l√°.  Se eu puder, basta adicionar uma aresta vis√≠vel para que o usu√°rio possa ver facilmente que os pontos est√£o conectados.  Se n√£o puder, adiciono um novo ponto no ponto de colis√£o, definindo o limite do obst√°culo. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse m√©todo de amostragem funcionou bem. </font><font style="vertical-align: inherit;">Ele nos permite controlar com muita precis√£o a amostragem usando par√¢metros personaliz√°veis ‚Äã‚Äãconvenientes, salvar todos os pontos necess√°rios e evitar mosaicos desnecess√°rios, o que leva a um preenchimento muito r√°pido do espa√ßo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/e45/60e/699e4560ef50242ff48ba0682554248a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como o algoritmo realiza uma pesquisa ao longo das dire√ß√µes, e n√£o apenas usa a proximidade, ele √© protegido contra ecos de limites e limita a amostragem excessiva apenas aos limites de que precisamos: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/673/618/6f3673618d182bb1810e2577c18ab1ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o algoritmo n√£o √© afetado por transi√ß√µes de estado ou problemas com variedades complexas. Ele lida apenas com pontos, e esses pontos podem estar em qualquer lugar, e novos podem ser adicionados a qualquer momento. Se voc√™ j√° desenhou um mapa da √°rea com a porta fechada, depois de abrir a porta, basta colocar o √∫nico ponto de pesquisa do outro lado da porta e ordenar que o algoritmo continue expandindo esse mapa, ap√≥s o qual ele se conectar√° corretamente e examinar√° corretamente toda a √°rea fora da porta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, a qualquer momento, voc√™ pode alterar os par√¢metros b√°sicos e o sistema continuar√° funcionando. </font><font style="vertical-align: inherit;">Deseja que a amostragem de √°rea seja feita com maior densidade? </font><font style="vertical-align: inherit;">Apenas abaixe a dist√¢ncia padr√£o. </font><font style="vertical-align: inherit;">Isso j√° pode ser feito no processo de constru√ß√£o do mapa, e o algoritmo come√ßar√° a amostrar com uma densidade mais alta sem a necessidade de redefinir os resultados anteriores (o que pode levar algum tempo).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifica√ß√£o rudimentar de arestas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo padr√£o j√° faz amostras de bordas com muito cuidado, porque as interse√ß√µes criam pontos adicionais que n√£o est√£o inclu√≠dos no padr√£o de amostragem, mas n√£o necessariamente os verifica com os cuidados necess√°rios, porque n√£o executa nenhuma a√ß√£o especial ao encontrar obst√°culos. Percebi que, como sabia quais pontos foram criados durante as colis√µes, os dois pontos de colis√£o detectados s√£o conectados por uma aresta e podemos solicitar amostragem adicional para tentar encontrar mais pontos de fronteira na vizinhan√ßa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o pesquisei ativamente essa abordagem, mas criei um m√©todo rudimentar para testar essa teoria, que me pareceu promissora. </font><font style="vertical-align: inherit;">Tendo tomado dois pontos de colis√£o conectados por uma aresta, mudo para o ponto m√©dio da aresta e tento desenhar a perpendicular externa √† aresta. </font><font style="vertical-align: inherit;">Se ele n√£o cruzar a borda a uma dist√¢ncia muito curta, suponho que a borda seja mais complexa e adicione um novo ponto de destino para continuar a pesquisa nessa √°rea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo esse esquema simples cria uma amostragem densa e de alta qualidade ao longo da fronteira sem amostrar desnecessariamente √°reas abertas vizinhas. </font><font style="vertical-align: inherit;">Aqui est√° uma √°rea com v√°rias bordas, mas sem verificar as bordas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/c9f/f6d/6dcc9ff6d78ddb981413ed4b795dcd5b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E aqui est√° a mesma √°rea com arestas de verifica√ß√£o: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por mais que eu estivesse satisfeito com esse resultado, fiquei surpreso com a falta de algoritmos significativamente melhores para amostragem de borda e tentarei escolher mais alguns m√©todos no futuro. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vit√≥rias r√°pidas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo tendo investido apenas um pouco de tempo no desenvolvimento e criando um c√≥digo bastante simples, certifiquei-me de que o Walk Monster j√° esteja criando uma sa√≠da bastante adequada que possa detectar problemas reais no jogo. </font><font style="vertical-align: inherit;">Aqui est√£o exemplos de problemas que eu encontrei durante o desenvolvimento do algoritmo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6f6/823/4ed6f6823ba2de2886a0fd83f702aa97.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As encostas nas laterais desta plataforma n√£o devem ser transit√°veis, mas o jogador pode andar sobre elas. </font><font style="vertical-align: inherit;">Isso aconteceu porque no c√≥digo de movimento do jogador h√° uma maneira patol√≥gica de processar geometria obl√≠qua. </font><font style="vertical-align: inherit;">Agora eu sei que ele est√° l√°, e eu o corrigirei quando se trata de garantir sua confiabilidade.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c38/b83/530c38b83fd5762238c3210d45e72d86.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Testemunha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deveria ser um jogo contemplativo, mas se perguntando por que parece que existe uma pedra, embora n√£o seja, n√£o era um dos seus koans. </font><font style="vertical-align: inherit;">Como voc√™ pode imaginar, esse problema surgiu porque algu√©m deixou a quantidade de colis√£o no jogo ap√≥s remover a geometria que o designava. </font><font style="vertical-align: inherit;">Isso pode acontecer facilmente, e √© muito bom que tenhamos uma ferramenta que possa reconhecer rapidamente esses erros, para que as pessoas n√£o precisem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/233/c86/122233c86cd7f7cf4f08e69cbb76404a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/616/377/012616377b5515b2ee23d71da78bdeeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses objetos deveriam ser rochas intransit√°veis, mas o Walk Monster descobriu que isso n√£o aconteceu. </font><font style="vertical-align: inherit;">Pior, o Walk Monster descobriu que, por algum motivo, o caminho √© apenas de um caminho (da captura de tela da esquerda para a direita), mas n√£o deve ser assim. </font><font style="vertical-align: inherit;">Eu me certifiquei de que o jogador realmente pudesse fazer isso (eu consegui). </font><font style="vertical-align: inherit;">√â muito interessante observar a ocorr√™ncia de tais erros!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perguntas abertas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando voc√™ v√™ bons resultados que podem ser desenvolvidos, isso √© inspirador. </font><font style="vertical-align: inherit;">Como eu disse, se voc√™ escolher um nome adequado para os arquivos de origem, tudo ser√° como um rel√≥gio! </font><font style="vertical-align: inherit;">Mas todo esse trabalho foi conclu√≠do em apenas alguns dias, por isso est√° longe de ser exaustivo e muito foi feito completamente improvisado. </font><font style="vertical-align: inherit;">Se eu tiver tempo suficiente para o desenvolvimento posterior desses sistemas, vale a pena responder a v√°rias perguntas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, que p√≥s-processamento precisa ser feito com os dados para facilitar a visualiza√ß√£o? </font><font style="vertical-align: inherit;">Ser√° dif√≠cil para as pessoas descobrir uma rede n√£o processada de pontos e arestas, mas se voc√™ melhorar a descri√ß√£o dos dados, isso provavelmente dificultar√° a avalia√ß√£o de √°reas transit√°veis ‚Äã‚Äãdif√≠ceis √† primeira vista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo, como os padr√µes de amostragem em torno das bordas podem ser aprimorados para garantir que o n√∫mero m√°ximo de ‚Äúfuros‚Äù seja encontrado? Existem boas maneiras de caracterizar a redu√ß√£o de n√∫meros em uma treli√ßa e existem esquemas de mosaico de alta qualidade que maximizam a probabilidade de cruzar e passar por esses n√∫meros? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terceiro, quais padr√µes de amostragem s√£o melhores para preencher espa√ßos - regulares ou aleat√≥rios? Posso alterar facilmente os crit√©rios para escolher pontos de destino para criar mais padr√µes aleat√≥rios, mas n√£o est√° muito claro se vale a pena fazer e, nesse caso, que tipos de padr√µes aleat√≥rios ser√£o melhores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quarto, que outras informa√ß√µes queremos obter dos mapas de √°reas transit√°veis ‚Äã‚Äãse j√° aprendemos a constru√≠-las? Por exemplo, √© muito simples expandir um sistema existente com fun√ß√µes como procurar caminhos ou mapas de dist√¢ncia, para que o usu√°rio possa selecionar um ponto e solicitar o caminho mais curto entre ele e algum outro ponto, ou visualizar um mapa de calor da dist√¢ncia entre um ponto e outros pontos do mapa. Essas consultas ser√£o √∫teis? Que outras consultas posso usar?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, as visualiza√ß√µes de √°reas transit√°veis ‚Äã‚Äãdo Monster Walk s√£o mais que suficientes para mostrar que o c√≥digo de movimento do jogador √© muito ruim. </font><font style="vertical-align: inherit;">Planejei passar √† cria√ß√£o de um sistema para cart√µes de teste noturnos usando o m√©todo de simula√ß√£o de entrada do usu√°rio, mas √© √≥bvio que j√° temos problemas suficientes para resolver sem essa etapa. </font><font style="vertical-align: inherit;">Portanto, o pr√≥ximo passo ser√° aumentar a confiabilidade do c√≥digo de movimento do jogador. </font><font style="vertical-align: inherit;">E enquanto estou trabalhando nisso, gostaria de verificar se √© poss√≠vel aumentar a velocidade de execu√ß√£o em uma ou duas ordens de magnitude, porque enquanto o trabalho do Walk Monster √© muito mais lento pelo sistema de freios de colis√µes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423519/">https://habr.com/ru/post/pt423519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423505/index.html">Zuckerberg vende a√ß√µes do Facebook por US $ 13 bilh√µes, para que ‚Äúnossos filhos nunca precisem ficar doentes‚Äù</a></li>
<li><a href="../pt423507/index.html">Como economizar mem√≥ria nas guias do navegador, mas n√£o perder o conte√∫do. A experi√™ncia da equipe Yandex.Browser</a></li>
<li><a href="../pt423511/index.html">Interceptando a instala√ß√£o do Firefox e Chrome no Windows 10</a></li>
<li><a href="../pt423513/index.html">Economizamos em um controlador RAID ou como alimentar Varia com Iops</a></li>
<li><a href="../pt423515/index.html">SECO √© bom ou pode quebrar O do SOLID</a></li>
<li><a href="../pt423521/index.html">Sete regras pr√°ticas para experimentar sites</a></li>
<li><a href="../pt423523/index.html">Sensor combinado, com prefer√™ncia e poetas</a></li>
<li><a href="../pt423527/index.html">Os aplicativos infantis coletam massivamente dados pessoais e os transmitem a terceiros</a></li>
<li><a href="../pt423529/index.html">O que toda a equipe precisa para trabalhar? Como arrastar todos para o sistema de gerenciamento de projetos?</a></li>
<li><a href="../pt423531/index.html">Evolu√ß√£o da arquitetura m√≥vel do Reddit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>