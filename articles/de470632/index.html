<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈯️ 👨🏻‍🚒 ⌨️ Arend - HoTT-basierte abhängige Typensprache (Teil 2) ✂️ 🌎 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil des Artikels über die Arend-Sprache haben wir die einfachsten induktiven Typen, rekursiven Funktionen, Klassen und Mengen untersucht. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - HoTT-basierte abhängige Typensprache (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil des Artikels</a> über die Arend-Sprache haben wir die einfachsten induktiven Typen, rekursiven Funktionen, Klassen und Mengen untersucht. <br><br><h2>  2. Sortieren von Listen in Arend </h2><br><h3>  2.1 Bestellte Listen in Arend </h3><br>  Wir definieren den Typ der geordneten Listen als ein Paar, das aus einer Liste und einem Nachweis ihrer Reihenfolge besteht.  Wie bereits erwähnt, werden in Arend abhängige Paare mit dem Schlüsselwort <code>\Sigma</code> definiert.  Wir geben die Definition des <code>Sorted</code> Typs durch Vergleich mit der Stichprobe an, inspiriert von der Definition aus dem bereits erwähnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über geordnete Listen.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Hinweis: Arend konnte automatisch schließen, dass der <code>Sorted</code> Typ im <code>\Prop</code> Universum enthalten ist.  Dies geschah, weil sich alle drei Muster in der <code>Sorted</code> Definition gegenseitig ausschließen und der <code>consSorted</code> Konstruktor zwei Parameter hat, die beide zu <code>\Prop</code> . <br>  Lassen Sie uns eine offensichtliche Eigenschaft des <code>Sorted</code> Prädikats beweisen, sagen wir, dass das Ende einer geordneten Liste selbst eine geordnete Liste ist (diese Eigenschaft wird uns in Zukunft nützlich sein). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  In der nach <code>tail-sorted</code> wir gleichzeitig den Mustervergleich für die <code>xs</code> Liste und das <code>Sorted</code> Prädikat verwendet. Außerdem haben wir das <i>Überspringzeichen</i> "_" <i>verwendet</i> , das nicht verwendete Variablen ersetzen kann. <br><br>  Man kann sich fragen, ob es in Arend möglich ist, die Eigenschaft geordneter Listen zu beweisen, die in Abschnitt 1.3 als Beispiel für eine Tatsache erwähnt werden, die in Agda ohne Anmerkungen zur Immaterialität nicht bewiesen werden kann.  Denken Sie daran, dass diese Eigenschaft behauptet, dass es ausreicht, die Gleichheit der ersten Komponenten der Paare zu überprüfen, um die Gleichheit der durch abhängige Paare definierten geordneten Listen zu beweisen. <br><br>  Es wird argumentiert, dass in Arend diese Eigenschaft als Folge der <code>inProp</code> erwähnten <code>inProp</code> Konstruktion und der Extensionalitätseigenschaft für abhängige <code>SigmaExt</code> Paare leicht erhalten werden kann. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  Die <code>SigmaPropExt</code> Eigenschaft <code>SigmaPropExt</code> im <a href="">Paths-</a> Modul der Standardbibliothek bewiesen. Dort werden auch viele andere Fakten aus dem zweiten Kapitel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des HoTT-Buches</a> , einschließlich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaft der funktionalen Erweiterbarkeit</a> , bewiesen. <br><br>  Der Operator <code>.n</code> in Arend verwendet, um auf den Sigma-Projektor mit der Nummer n zuzugreifen (in unserem Fall ist der Sigma-Typ <code>SortedList A</code> , und der Ausdruck <code>l1.1</code> bedeutet, dass die erste Komponente dieses Typs ein Ausdruck vom Typ <code>List A</code> ). <br><br><h3>  2.2 Implementierung der Eigenschaft "be permutation" </h3><br>  Versuchen wir nun, die Listensortierfunktion in Arend zu implementieren.  Natürlich wollen wir keine einfache Implementierung des Sortieralgorithmus, sondern eine Implementierung zusammen mit einem Nachweis einiger Eigenschaften. <br><br>  Dieser Algorithmus muss mindestens zwei Eigenschaften haben: <br>  1. Das Ergebnis des Algorithmus sollte eine geordnete Liste sein. <br>  2. Die resultierende Liste sollte eine Permutation der ursprünglichen Liste sein. <br><br>  Versuchen wir zunächst, die Eigenschaft "be permutation" von Listen in Arend zu implementieren.  Dazu passen wir die Definition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> für Arend an. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  Das von uns eingeführte <code>InsertSpec</code> Prädikat hat die folgende intuitive Bedeutung: <code>InsertSpec xs a ys</code> bedeutet genau, dass die Liste <code>ys</code> das Ergebnis des Einfügens des Elements a in die Liste <code>xs</code> (an einer beliebigen Position) ist.  Somit kann <code>InsertSpec</code> als Spezifikation der <code>InsertSpec</code> verwendet werden. <br><br>  Es ist klar, dass der Datentyp <code>Perm</code> tatsächlich die Beziehung "be permutation" definiert: Der Konstruktor <code>permInsert</code> genau an, dass <code>xs</code> und <code>ys</code> für beide Seiten durchlässig sind, wenn <code>xs</code> und <code>ys</code> erhalten werden, indem dasselbe Element a in einige Listen <code>xs'</code> und <code>ys'</code> kürzere Längen, die bereits Permutationen voneinander sind. <br><br>  Für unsere Definition der Eigenschaft "be permutation" ist es einfach, die Symmetrieeigenschaft zu überprüfen. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  Die Transitivitätseigenschaft ist auch für <code>Perm</code> erfüllt, aber ihre Überprüfung ist viel komplizierter.  Da diese Eigenschaft bei der Implementierung unseres Sortieralgorithmus keine Rolle spielt, überlassen wir sie dem Leser als Übung. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 Änderung der Homotopie im Vergleich zur Probe </h3><br>  Versuchen wir nun, eine Funktion zu implementieren, die ein Element in eine geordnete Liste einfügt, damit die resultierende Liste geordnet bleibt.  Beginnen wir mit der folgenden naiven Implementierung. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  Das <code>\case</code> Konstrukt ermöglicht den Abgleich mit einer Stichprobe eines beliebigen Ausdrucks ( <code>\elim</code> kann nur auf der höchsten Ebene einer Funktionsdefinition und nur für deren Parameter verwendet werden).  Wenn Sie Arend bitten, den Einfügetyp zu überprüfen, wird die folgende Fehlermeldung angezeigt. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  Das Problem ist, dass in der <code>LinearOrder.Dec</code> Klasse <code>LinearOrder.Dec</code> Definition der <code>trichotomy</code> mit dem Operator <code>||</code> wird  , die wiederum unter Verwendung von Satzkürzungen bestimmt wird.  Wie bereits erwähnt, ist für Typen, die zum <code>\Prop</code> Universum gehören, die Übereinstimmung mit einem Muster in Arend nur zulässig, wenn der Typ des resultierenden Ausdrucks selbst eine Behauptung ist (für die obige Funktion ist das Ergebnis vom Typ <code>List OE</code> , und dieser Typ ist eine Menge). <br><br>  Gibt es einen Weg um dieses Problem herum?  Der einfachste Weg, dies zu lösen, besteht darin, die Definition der Eigenschaft der Trichotomie zu ändern.  Betrachten Sie die folgende Definition der Trichotomie unter Verwendung des nicht abgeschnittenen Typs <code>Or</code> anstelle des abgeschnittenen <code>||</code>  :: <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  <code>trichotomy</code> diese Definition in irgendetwas von der ursprünglichen <code>trichotomy</code> Definition durch <code>||</code>  ?  Warum haben wir überhaupt einen propositionell abgeschnittenen Typ verwendet, wenn dies unser Leben nur kompliziert und uns daran hindert, Mustervergleiche zu verwenden? <br><br>  Versuchen wir zunächst, die erste Frage zu beantworten: Bei strengen <code>StrictPoset</code> Ordnungen <code>StrictPoset</code> Unterschied zwischen <code>trichotomy</code> und <code>set-trichotomy</code> eigentlich gar nicht.  Beachten Sie, dass der <code>set-trichotomy</code> Typ eine Aussage ist.  Diese Tatsache folgt aus der Tatsache, dass sich alle drei Alternativen in der Definition der Trichotomie aufgrund von Ordnungsaxiomen gegenseitig ausschließen und jeder der drei Typen <code>x = y, x &lt; y, y &lt; x</code> selbst eine Aussage ist ( <code>x = y</code> ist also eine Aussage Wie in der Definition der <code>BaseSet</code> Klasse <code>BaseSet</code> wir gefordert, dass das Medium <code>E</code> eine Menge ist!). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  <code>absurd</code> ist in der obigen Auflistung die Bezeichnung für das Ex-Falso-Quodlibet-Prinzip, das im Logikmodul definiert ist.  Da der <code>Empty</code> Typ keine Konstruktoren in der Definition enthält (siehe Abschnitt 1.2), ist es nicht erforderlich, Fälle in der Definition von <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Da wir jetzt wissen, dass die <code>set-trichotomy</code> eine Aussage ist, können wir die <code>set-trichotomy</code> Eigenschaft aus der üblichen <code>trichotomy</code> Eigenschaft entscheidbarer Ordnungen ableiten.  Dazu können wir die Konstruktion <code>\return \level</code> verwenden, die dem Arend-Timer mitteilt, dass zu diesem Zeitpunkt der Mustervergleich eine zulässige Operation ist (in diesem Fall müssen wir beweisen, dass das Ergebnis der Funktion <code>set-trichotomy-property</code> eine Anweisung ist). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Versuchen wir nun, die zweite Frage zu beantworten, nämlich warum es bei der Formulierung der Eigenschaften mathematischer Objekte vorzuziehen ist, nicht gewöhnliche, sondern propositionell verkürzte Konstruktionen zu verwenden.  Betrachten Sie dazu ein Fragment der Definition nichtlinearer linearer Ordnungen (vollständige Definitionen von <code>Lattice</code> und <code>TotalOrder</code> finden Sie im <a href="">LinearOrder-</a> Modul): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Versuchen wir uns jetzt vorzustellen, wie sich die Bedeutung der <code>TotalOrder</code> Klasse ändern würde, wenn wir die Definition des Totalitätsfelds durch die nicht abgeschnittene <code>Or</code> Konstruktion <code>TotalOrder</code> würden. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  In diesem Fall ist der Typ <code>(x &lt;= y) `Or` (y &lt;= x)</code> keine Aussage mehr, weil  Bei gleichen Werten von <code>x</code> und <code>y</code> beide Alternativen bei der Definition von <code>badTotality</code> implementiert werden, und die Wahl des linken oder rechten Zweigs beim Nachweis von <code>badTotality</code> absolut willkürlich und liegt im Ermessen des Benutzers - es gibt keinen Grund, einen <code>Or</code> Konstruktor einem anderen vorzuziehen. <br><br>  Jetzt ist klar, was der Unterschied zwischen <code>TotalOrder</code> und <code>BadTotalOrder</code> .  Zwei geordnete Mengen <code>O1 O2</code> : <code>TotalOrder</code> sind immer gleich, wenn es möglich ist, die Gleichheit der Mengen <code>O1.E, O2.E</code> und der Ordnungen <code>O1.&lt;, O2.&lt;</code> Zu beweisen (dies ist die gewünschte Eigenschaft).  Andererseits ist es für <code>O1 O2</code> : <code>BadTotalOrder</code> nur <code>BadTotalOrder</code> , die Gleichheit von <code>O1</code> und <code>O2</code> zu beweisen, wenn zusätzlich zu allen Elementen <code>x</code> aus <code>E</code> Gleichheit <code>O1.badTotality xx</code> und <code>O2.badTotality xx</code> . <br><br>  Es stellt sich also heraus, dass die Klasse <code>BadTotalOrder</code> intuitiv nicht als "linear geordnete Menge" betrachtet werden muss, sondern als "linear geordnete Menge zusammen mit der Auswahl für jedes Element <code>x</code> Feldes <code>E</code> linken oder rechten Zweigs <code>Or</code> bei der Implementierung von <code>badTotality xx</code> ". <br><br><h3>  2.4 Sortieralgorithmus </h3><br>  Wir fahren nun mit der Implementierung des Sortieralgorithmus fort.  Versuchen wir, die naive Implementierung der <code>insert</code> Funktion aus dem vorherigen Abschnitt mithilfe der bewährten <code>set-trichotomy-property</code> (in diesem Fall haben wir aufgrund der erfolgreicheren Anordnung von Klammern bei der Definition der <code>set-trichotomy</code> die Anzahl der berücksichtigten Fälle reduziert). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Versuchen wir nun, ein Analogon dieser Definition für geordnete Listen zu implementieren.  Wir werden das spezielle Konstrukt <code>\let … \in</code> verwenden, mit dem wir dem Kontext neue lokale Variablen hinzufügen können. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Wir haben im Beweis ein unvollständiges Fragment hinterlassen (angezeigt durch den Ausdruck <code>{?}</code> ). An der Stelle, an der Sie zeigen möchten, dass das <code>x :-: result</code> der Liste <code>x :-: result</code> geordnet ist.  Obwohl es im Kontext Hinweise auf die Reihenfolge der <code>result</code> , müssen wir überprüfen, ob <code>x</code> den Wert des ersten Elements der <code>result</code> nicht überschreitet, was von den Prämissen im Kontext nicht so einfach zu verfolgen ist (um alle Prämissen im aktuellen Ziel zu sehen - das nennen wir Derzeitiger Berechnungszweig - Sie müssen die Typprüfung bei der <code>insert</code> anfordern. <br><br>  Es stellt sich heraus, dass das <code>insert</code> viel einfacher zu implementieren ist, wenn wir die Reihenfolge der resultierenden Liste parallel zum Nachweis der <code>insert</code> .  Ändern Sie die Unterschrift der <code>insert</code> und schreiben Sie in den einfachsten Fällen den Nachweis dieser Spezifikation: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  Für ein einzelnes Fragment ohne Beweis gibt Arend den folgenden Kontextwert aus: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Um den Beweis zu vervollständigen, müssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die volle Leistung des</a> Operators <code>\case</code> : Wir werden den Mustervergleich mit 5 verschiedenen Variablen verwenden, und da die Typen einiger Variablen von den Werten anderer Variablen abhängen können, werden wir den abhängigen Mustervergleich verwenden. <br><br>  Die Doppelpunktkonstruktion gibt explizit an, wie der Typ einiger verglichener Variablen von den Werten anderer Variablen abhängt (also in der Art der Variablen <code>xs-sorted, result-spec</code> und <code>result-sorted</code> in jedem von <code>\case</code> anstelle von <code>xs'</code> und <code>result</code> stimmt mit den entsprechenden Stichproben überein). <br><br>  Das Konstrukt <code>\return</code> ordnet die Variablen, die zum Abgleichen des Musters verwendet werden, dem Typ des erwarteten Ergebnisses zu.  Mit anderen Worten, im aktuellen Ziel wird in jeder der <code>\case</code> Klauseln die entsprechende Stichprobe durch die entsprechende Stichprobe ersetzt.  Ohne diese Konstruktion würde eine solche Ersetzung nicht durchgeführt, und das Ziel aller <code>\case</code> Klauseln würde mit dem Ziel anstelle des <code>\case</code> Ausdrucks selbst übereinstimmen. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  Im obigen Codeblock verdienen die komplexen ersten Argumente des <code>consSorted</code> Konstruktors in den letzten beiden Absätzen des Mustervergleichs einen zusätzlichen Kommentar.  Um zu verstehen, was diese beiden Ausdrücke bedeuten, ersetzen wir sie durch den Ausdruck <code>{?}</code> Und bitten den Arend-Timer, Ziele an beiden Positionen zu bestimmen. <br><br>  Sie können sehen, dass sowohl dort als auch dort das aktuelle Ziel der Typ <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  Darüber hinaus gibt es im Rahmen des ersten Ziels Prämissen <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  und im Kontext der zweiten Prämisse <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Intuitiv klar: Um das erste Ziel zu beweisen, reicht es aus, die Variable <code>r</code> durch die richtige Aussage <code>Or (x = y) (O.&lt; xy)</code> zu ersetzen und dann zum propositionell abgeschnittenen Typ <code>||</code> wechseln  Verwenden der in Abschnitt 1.3 definierten <code>Or-to-||</code> -Funktion  .  Um das zweite Ziel zu beweisen, setzen Sie einfach <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> anstelle der Variablen <code>x'</code> Variable <code>r</code> . <br><br>  Zur Formalisierung der beschriebenen Ausdruckssubstitutionsoperation existiert in der Standard-Arend-Bibliothek eine spezielle <code>transport</code> .  Betrachten Sie ihre Unterschrift: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  In unserem Fall müssen wir anstelle der Variablen <code>A</code> den Typ <code>OE</code> ersetzen (er kann explizit weggelassen werden, wenn die anderen <code>transport</code> angegeben werden) und anstelle von <code>B</code> den Ausdruck <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  Die Implementierung des Einfügungssortierungsalgorithmus zusammen mit der Spezifikation verursacht keine besonderen Schwierigkeiten mehr: Um die Liste <code>x :-: xs'</code> zu sortieren, sortieren wir zuerst den Schwanz der Liste <code>xs'</code> mit einem rekursiven Aufruf von <code>insertSort</code> und fügen dann das Element <code>x</code> in diese Liste ein, wobei die Reihenfolge für <code>insertSort</code> wird Hilfe beim Zugriff auf die bereits implementierte <code>insert</code> . <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Wir haben das ursprüngliche Ziel erreicht und die Sortierung der Listen auf Arend implementiert.  Der gesamte in diesem Absatz angegebene Arend-Code kann <a href="">von hier aus</a> in einer Datei heruntergeladen <a href="">werden</a> . <br><br>  Man könnte sich fragen, wie man die Implementierung der <code>LinearOrder.Dec</code> ändern müsste, wenn wir anstelle der strengen <code>LinearOrder.Dec</code> Befehle die nicht strengen <code>TotalOrder</code> Befehle verwenden würden.  Wie wir uns erinnern, wird bei der Definition der Totalitätsfunktion die Verwendung der abgeschnittenen Operation <code>||</code>  war ziemlich bedeutsam, das heißt, diese Definition entspricht nicht einer Definition, in der anstelle von <code>||</code>  verwendet von <code>Or</code> . <br><br>  Die Antwort auf diese Frage lautet wie folgt: Es ist immer noch möglich, ein <code>insert</code> Analogon für <code>TotalOrder</code> zu <code>TotalOrder</code> . Dazu müssten wir jedoch beweisen, dass der Typ der <code>insert</code> Funktion eine Anweisung ist (dies würde es uns bei der Definition von <code>insert</code> , mit der Stichprobe gemäß der <code>totality xy</code> Anweisung <code>totality xy</code> ). <br><br>  Mit anderen Worten, wir müssten beweisen, dass es nur eine geordnete Liste bis zur Gleichheit gibt, was das Ergebnis des Einfügens des Elements <code>y</code> in die geordnete Liste <code>xs</code> .  Es ist leicht zu erkennen, dass dies eine wahre Tatsache ist, aber der formale Beweis ist nicht mehr so ​​trivial.  Wir überlassen die Überprüfung dieser Tatsache dem interessierten Leser als Übung. <br><br><h2>  3. Schlussbemerkungen </h2><br>  In dieser Einführung haben wir die Hauptkonstrukte der Arend-Sprache kennengelernt und auch gelernt, wie man den Klassenmechanismus verwendet.  Es ist uns gelungen, den einfachsten Algorithmus zusammen mit dem Nachweis seiner Spezifikation zu implementieren.  So haben wir gezeigt, dass Arend gut zur Lösung "alltäglicher" Probleme geeignet ist, wie zum Beispiel zur Programmüberprüfung. <br><br>  Wir haben weit entfernt von allen Funktionen und Merkmalen von Arend erwähnt.  Zum Beispiel haben wir fast nichts über <i>Typen mit Bedingungen</i> gesagt, die es Ihnen ermöglichen, verschiedene Typkonstruktoren mit einigen speziellen Parameterwerten für diese Konstruktoren zu „kleben“.  Beispielsweise wird eine Implementierung des Integer-Typs in Arend unter Verwendung von Typen mit folgenden Bedingungen angegeben: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Diese Definition besagt, dass ganze Zahlen aus zwei Kopien des Typs natürlicher Zahlen bestehen, in denen "positive" und "negative" Nullen identifiziert werden.  Eine solche Definition ist viel praktischer als die Definition aus der Standard-Coq-Bibliothek, bei der die „negative Kopie“ natürlicher Zahlen „um eins verschoben“ werden muss, damit sich diese Kopien nicht überschneiden (es ist viel bequemer, wenn die Notation <code>neg 1</code> die Zahl -1, nicht -2 bedeutet). . <br><br>  Wir haben nichts über den Algorithmus zum Ableiten von Prädikativ- und Homotopieebenen in Klassen und deren Instanzen gesagt.  Wir haben auch die Art des Intervalls <code>I</code> kaum erwähnt, obwohl es eine Schlüsselrolle in der Theorie der Typen mit Intervallen spielt, die die logische Grundlage von Arend sind.  Um zu verstehen, wie wichtig dieser Typ ist, muss erwähnt werden, dass in Arend die Typgleichheit durch das Konzept eines Intervalls definiert wird.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470632/">https://habr.com/ru/post/de470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470616/index.html">Eine neue Lösung für das Fermi-Paradoxon (warum wir allein im Universum sind)</a></li>
<li><a href="../de470618/index.html">Thematische Modellierung von Nachrichten mittels Faktoranalyse</a></li>
<li><a href="../de470620/index.html">Infrastruktur als Code: So überwinden Sie Probleme mit XP</a></li>
<li><a href="../de470622/index.html">Übersicht über Methoden zur Merkmalsauswahl</a></li>
<li><a href="../de470628/index.html">Raumschiff Simulator Schiffbau</a></li>
<li><a href="../de470634/index.html">Identifizieren Sie Community-übergreifend auf Instagram, um Benutzerinteressen zu identifizieren</a></li>
<li><a href="../de470638/index.html">Quasi-Newtonsche Methoden oder wenn es zu viele zweite Ableitungen für Athos gibt</a></li>
<li><a href="../de470640/index.html">Dimensionierung Elasticsearch</a></li>
<li><a href="../de470642/index.html">Treffen Sie Yandex.Station Mini. Große Geschichte eines kleinen Geräts</a></li>
<li><a href="../de470646/index.html">Mathematik für Data Science. Neuer Kurs von OTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>