<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàØÔ∏è üë®üèª‚Äçüöí ‚å®Ô∏è Arend - HoTT-basierte abh√§ngige Typensprache (Teil 2) ‚úÇÔ∏è üåé üë®‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil des Artikels √ºber die Arend-Sprache haben wir die einfachsten induktiven Typen, rekursiven Funktionen, Klassen und Mengen untersucht. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - HoTT-basierte abh√§ngige Typensprache (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/470632/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil des Artikels</a> √ºber die Arend-Sprache haben wir die einfachsten induktiven Typen, rekursiven Funktionen, Klassen und Mengen untersucht. <br><br><h2>  2. Sortieren von Listen in Arend </h2><br><h3>  2.1 Bestellte Listen in Arend </h3><br>  Wir definieren den Typ der geordneten Listen als ein Paar, das aus einer Liste und einem Nachweis ihrer Reihenfolge besteht.  Wie bereits erw√§hnt, werden in Arend abh√§ngige Paare mit dem Schl√ºsselwort <code>\Sigma</code> definiert.  Wir geben die Definition des <code>Sorted</code> Typs durch Vergleich mit der Stichprobe an, inspiriert von der Definition aus dem bereits erw√§hnten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber geordnete Listen.</a> <br><br><pre> <code class="plaintext hljs">\func SortedList (O : LinearOrder.Dec) =&gt; \Sigma (l : List O) (Sorted l) \data Sorted {A : LinearOrder.Dec} (xs : List A) \elim xs | nil =&gt; nilSorted | :-: x nil =&gt; singletonSorted | :-: x1 (:-: x2 xs) =&gt; consSorted ((x1 = x2) || (x1 &lt; x2)) (Sorted (x2 :-: xs))</code> </pre> <br>  Hinweis: Arend konnte automatisch schlie√üen, dass der <code>Sorted</code> Typ im <code>\Prop</code> Universum enthalten ist.  Dies geschah, weil sich alle drei Muster in der <code>Sorted</code> Definition gegenseitig ausschlie√üen und der <code>consSorted</code> Konstruktor zwei Parameter hat, die beide zu <code>\Prop</code> . <br>  Lassen Sie uns eine offensichtliche Eigenschaft des <code>Sorted</code> Pr√§dikats beweisen, sagen wir, dass das Ende einer geordneten Liste selbst eine geordnete Liste ist (diese Eigenschaft wird uns in Zukunft n√ºtzlich sein). <br><a name="habracut"></a><br><pre> <code class="plaintext hljs">\func tail-sorted {O : LinearOrder.Dec} (x : O) (xs : List O) (A : Sorted (x :-: xs)) : Sorted xs \elim xs, A | nil, _ =&gt; nilSorted | :-: _ _, consSorted _ xs-sorted =&gt; xs-sorted</code> </pre> <br>  In der nach <code>tail-sorted</code> wir gleichzeitig den Mustervergleich f√ºr die <code>xs</code> Liste und das <code>Sorted</code> Pr√§dikat verwendet. Au√üerdem haben wir das <i>√úberspringzeichen</i> "_" <i>verwendet</i> , das nicht verwendete Variablen ersetzen kann. <br><br>  Man kann sich fragen, ob es in Arend m√∂glich ist, die Eigenschaft geordneter Listen zu beweisen, die in Abschnitt 1.3 als Beispiel f√ºr eine Tatsache erw√§hnt werden, die in Agda ohne Anmerkungen zur Immaterialit√§t nicht bewiesen werden kann.  Denken Sie daran, dass diese Eigenschaft behauptet, dass es ausreicht, die Gleichheit der ersten Komponenten der Paare zu √ºberpr√ºfen, um die Gleichheit der durch abh√§ngige Paare definierten geordneten Listen zu beweisen. <br><br>  Es wird argumentiert, dass in Arend diese Eigenschaft als Folge der <code>inProp</code> erw√§hnten <code>inProp</code> Konstruktion und der Extensionalit√§tseigenschaft f√ºr abh√§ngige <code>SigmaExt</code> Paare leicht erhalten werden kann. <br><br><pre> <code class="plaintext hljs">\func sorted-equality {A : LinearOrder.Dec} (l1 l2 : SortedList A) (P : l1.1 = l2.1) : l1 = l2 =&gt; SigmaPropExt Sorted l1 l2 P</code> </pre> <br>  Die <code>SigmaPropExt</code> Eigenschaft <code>SigmaPropExt</code> im <a href="">Paths-</a> Modul der Standardbibliothek bewiesen. Dort werden auch viele andere Fakten aus dem zweiten Kapitel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des HoTT-Buches</a> , einschlie√ülich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaft der funktionalen Erweiterbarkeit</a> , bewiesen. <br><br>  Der Operator <code>.n</code> in Arend verwendet, um auf den Sigma-Projektor mit der Nummer n zuzugreifen (in unserem Fall ist der Sigma-Typ <code>SortedList A</code> , und der Ausdruck <code>l1.1</code> bedeutet, dass die erste Komponente dieses Typs ein Ausdruck vom Typ <code>List A</code> ). <br><br><h3>  2.2 Implementierung der Eigenschaft "be permutation" </h3><br>  Versuchen wir nun, die Listensortierfunktion in Arend zu implementieren.  Nat√ºrlich wollen wir keine einfache Implementierung des Sortieralgorithmus, sondern eine Implementierung zusammen mit einem Nachweis einiger Eigenschaften. <br><br>  Dieser Algorithmus muss mindestens zwei Eigenschaften haben: <br>  1. Das Ergebnis des Algorithmus sollte eine geordnete Liste sein. <br>  2. Die resultierende Liste sollte eine Permutation der urspr√ºnglichen Liste sein. <br><br>  Versuchen wir zun√§chst, die Eigenschaft "be permutation" von Listen in Arend zu implementieren.  Dazu passen wir die Definition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> f√ºr Arend an. <br><br><pre> <code class="plaintext hljs">\truncated \data InsertSpec {A : \Set} (xs : List A) (a : A) (ys : List A) : \Prop \elim xs, ys | xs, :-: y ys =&gt; insertedHere (a = y) (xs = ys) | :-: x xs, :-: y ys =&gt; insertedThere (x = y) (InsertSpec xs a ys) \truncated \data Perm {A : \Set} (xs ys : List A) : \Prop | permInsert (xs' ys' : List A) (a : A) (Perm xs' ys') (InsertSpec xs' a xs) (InsertSpec ys' a ys) | permTrivial (xs = ys)</code> </pre> <br>  Das von uns eingef√ºhrte <code>InsertSpec</code> Pr√§dikat hat die folgende intuitive Bedeutung: <code>InsertSpec xs a ys</code> bedeutet genau, dass die Liste <code>ys</code> das Ergebnis des Einf√ºgens des Elements a in die Liste <code>xs</code> (an einer beliebigen Position) ist.  Somit kann <code>InsertSpec</code> als Spezifikation der <code>InsertSpec</code> verwendet werden. <br><br>  Es ist klar, dass der Datentyp <code>Perm</code> tats√§chlich die Beziehung "be permutation" definiert: Der Konstruktor <code>permInsert</code> genau an, dass <code>xs</code> und <code>ys</code> f√ºr beide Seiten durchl√§ssig sind, wenn <code>xs</code> und <code>ys</code> erhalten werden, indem dasselbe Element a in einige Listen <code>xs'</code> und <code>ys'</code> k√ºrzere L√§ngen, die bereits Permutationen voneinander sind. <br><br>  F√ºr unsere Definition der Eigenschaft "be permutation" ist es einfach, die Symmetrieeigenschaft zu √ºberpr√ºfen. <br><br><pre> <code class="plaintext hljs">\func Perm-symmetric {A : \Set} {xs ys : List A} (P : Perm xs ys) : Perm ys xs \elim P | permTrivial xs=ys =&gt; permTrivial (inv xs=ys) | permInsert perm-xs'-ys' xs-spec ys-spec =&gt; permInsert (Perm-symmetric perm-xs'-ys') ys-spec xs-spec</code> </pre> <br>  Die Transitivit√§tseigenschaft ist auch f√ºr <code>Perm</code> erf√ºllt, aber ihre √úberpr√ºfung ist viel komplizierter.  Da diese Eigenschaft bei der Implementierung unseres Sortieralgorithmus keine Rolle spielt, √ºberlassen wir sie dem Leser als √úbung. <br><br><pre> <code class="plaintext hljs">\func Perm-transitive {A : \Set} (xs ys zs : List A) (P1 : Perm xs ys) (P2 : Perm ys zs) : Perm xs zs =&gt; {?}</code> </pre> <br><h3>  2.3 √Ñnderung der Homotopie im Vergleich zur Probe </h3><br>  Versuchen wir nun, eine Funktion zu implementieren, die ein Element in eine geordnete Liste einf√ºgt, damit die resultierende Liste geordnet bleibt.  Beginnen wir mit der folgenden naiven Implementierung. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case LinearOrder.trichotomy xy \with {  | byLeft x=y =&gt; x :-: insert xs' y  | byRight (byLeft x&lt;y) =&gt; x :-: insert xs' y  | byRight (byRight y&lt;x) =&gt; y :-: x :-: xs' }</code> </pre> <br>  Das <code>\case</code> Konstrukt erm√∂glicht den Abgleich mit einer Stichprobe eines beliebigen Ausdrucks ( <code>\elim</code> kann nur auf der h√∂chsten Ebene einer Funktionsdefinition und nur f√ºr deren Parameter verwendet werden).  Wenn Sie Arend bitten, den Einf√ºgetyp zu √ºberpr√ºfen, wird die folgende Fehlermeldung angezeigt. <br><br><pre> <code class="plaintext hljs">[ERROR] Data type '||' is truncated to the universe \Prop  which does not fit in the universe of the eliminator type: List OE In: | byLeft x-leq-y =&gt; x :-: insert xs' y While processing: insert</code> </pre> <br>  Das Problem ist, dass in der <code>LinearOrder.Dec</code> Klasse <code>LinearOrder.Dec</code> Definition der <code>trichotomy</code> mit dem Operator <code>||</code> wird  , die wiederum unter Verwendung von Satzk√ºrzungen bestimmt wird.  Wie bereits erw√§hnt, ist f√ºr Typen, die zum <code>\Prop</code> Universum geh√∂ren, die √úbereinstimmung mit einem Muster in Arend nur zul√§ssig, wenn der Typ des resultierenden Ausdrucks selbst eine Behauptung ist (f√ºr die obige Funktion ist das Ergebnis vom Typ <code>List OE</code> , und dieser Typ ist eine Menge). <br><br>  Gibt es einen Weg um dieses Problem herum?  Der einfachste Weg, dies zu l√∂sen, besteht darin, die Definition der Eigenschaft der Trichotomie zu √§ndern.  Betrachten Sie die folgende Definition der Trichotomie unter Verwendung des nicht abgeschnittenen Typs <code>Or</code> anstelle des abgeschnittenen <code>||</code>  :: <br><br><pre> <code class="plaintext hljs">\func set-trichotomy {A : StrictPoset} (xy : A) =&gt; ((x = y) `Or` (x &lt; y)) `Or` (y &lt; x)</code> </pre> <br>  <code>trichotomy</code> diese Definition in irgendetwas von der urspr√ºnglichen <code>trichotomy</code> Definition durch <code>||</code>  ?  Warum haben wir √ºberhaupt einen propositionell abgeschnittenen Typ verwendet, wenn dies unser Leben nur kompliziert und uns daran hindert, Mustervergleiche zu verwenden? <br><br>  Versuchen wir zun√§chst, die erste Frage zu beantworten: Bei strengen <code>StrictPoset</code> Ordnungen <code>StrictPoset</code> Unterschied zwischen <code>trichotomy</code> und <code>set-trichotomy</code> eigentlich gar nicht.  Beachten Sie, dass der <code>set-trichotomy</code> Typ eine Aussage ist.  Diese Tatsache folgt aus der Tatsache, dass sich alle drei Alternativen in der Definition der Trichotomie aufgrund von Ordnungsaxiomen gegenseitig ausschlie√üen und jeder der drei Typen <code>x = y, x &lt; y, y &lt; x</code> selbst eine Aussage ist ( <code>x = y</code> ist also eine Aussage Wie in der Definition der <code>BaseSet</code> Klasse <code>BaseSet</code> wir gefordert, dass das Medium <code>E</code> eine Menge ist!). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-isProp {A : StrictPoset} (xy : A) (l1 l2 : set-trichotomy xy): l1 = l2 \elim l1, l2 | inl (inl l1), inl (inl l2) =&gt; pmap (\lam z =&gt; inl (inl z)) (Path.inProp l1 l2) | inl (inr l1), inl (inr l2) =&gt; pmap (\lam z =&gt; inl (inr z)) (Path.inProp l1 l2) | inr l1, inr l2 =&gt; pmap inr (Path.inProp l1 l2) | inl (inl l1), inl (inr l2) =&gt; absurd (lt-eq-false l1 l2) | inl (inr l1), inl (inl l2) =&gt; absurd (lt-eq-false l2 l1) | inl (inl l1), inr l2 =&gt; absurd (lt-eq-false (inv l1) l2) | inr l1, inl (inl l2) =&gt; absurd (lt-eq-false (inv l2) l1) | inl (inr l1), inr l2 =&gt; absurd (lt-lt-false l1 l2) | inr l1, inl (inr l2) =&gt; absurd (lt-lt-false l2 l1) \where {  \func lt-eq-false {A : StrictPoset} {xy : A} (l1 : x = y) (l2 : x &lt; y) : Empty =&gt;    A.&lt;-irreflexive x (transport (x &lt;) (inv l1) l2)  \func lt-lt-false {A : StrictPoset} {xy : A} (l1 : x &lt; y) (l2 : y &lt; x) : Empty =&gt;   A.&lt;-irreflexive x (A.&lt;-transitive _ _ _ l1 l2) }</code> </pre> <br>  <code>absurd</code> ist in der obigen Auflistung die Bezeichnung f√ºr das Ex-Falso-Quodlibet-Prinzip, das im Logikmodul definiert ist.  Da der <code>Empty</code> Typ keine Konstruktoren in der Definition enth√§lt (siehe Abschnitt 1.2), ist es nicht erforderlich, F√§lle in der Definition von <code>absurd</code> : <br><br><pre> <code class="plaintext hljs">\func absurd {A : \Type} (x : Empty) : A</code> </pre> <br>  Da wir jetzt wissen, dass die <code>set-trichotomy</code> eine Aussage ist, k√∂nnen wir die <code>set-trichotomy</code> Eigenschaft aus der √ºblichen <code>trichotomy</code> Eigenschaft entscheidbarer Ordnungen ableiten.  Dazu k√∂nnen wir die Konstruktion <code>\return \level</code> verwenden, die dem Arend-Timer mitteilt, dass zu diesem Zeitpunkt der Mustervergleich eine zul√§ssige Operation ist (in diesem Fall m√ºssen wir beweisen, dass das Ergebnis der Funktion <code>set-trichotomy-property</code> eine Anweisung ist). <br><br><pre> <code class="plaintext hljs">\func set-trichotomy-property {A : LinearOrder.Dec} (xy : A) : set-trichotomy xy =&gt; \case A.trichotomy xy \return \level (set-trichotomy xy) (set-trichotomy-isProp xy) \with {  | byLeft x=y =&gt; inl (inl x=y)  | byRight (byLeft x&lt;y) =&gt; inl (inr x&lt;y)  | byRight (byRight y&lt;x) =&gt; inr (y&lt;x) }</code> </pre> <br>  Versuchen wir nun, die zweite Frage zu beantworten, n√§mlich warum es bei der Formulierung der Eigenschaften mathematischer Objekte vorzuziehen ist, nicht gew√∂hnliche, sondern propositionell verk√ºrzte Konstruktionen zu verwenden.  Betrachten Sie dazu ein Fragment der Definition nichtlinearer linearer Ordnungen (vollst√§ndige Definitionen von <code>Lattice</code> und <code>TotalOrder</code> finden Sie im <a href="">LinearOrder-</a> Modul): <br><br><pre> <code class="plaintext hljs">\class TotalOrder \extends Lattice { | totality (xy : E) : x &lt;= y || y &lt;= x }</code> </pre> <br>  Versuchen wir uns jetzt vorzustellen, wie sich die Bedeutung der <code>TotalOrder</code> Klasse √§ndern w√ºrde, wenn wir die Definition des Totalit√§tsfelds durch die nicht abgeschnittene <code>Or</code> Konstruktion <code>TotalOrder</code> w√ºrden. <br><br><pre> <code class="plaintext hljs">\class BadTotalOrder \extends Lattice { | badTotality (xy : E) : (x &lt;= y) `Or` (y &lt;= x) }</code> </pre> <br>  In diesem Fall ist der Typ <code>(x &lt;= y) `Or` (y &lt;= x)</code> keine Aussage mehr, weil  Bei gleichen Werten von <code>x</code> und <code>y</code> beide Alternativen bei der Definition von <code>badTotality</code> implementiert werden, und die Wahl des linken oder rechten Zweigs beim Nachweis von <code>badTotality</code> absolut willk√ºrlich und liegt im Ermessen des Benutzers - es gibt keinen Grund, einen <code>Or</code> Konstruktor einem anderen vorzuziehen. <br><br>  Jetzt ist klar, was der Unterschied zwischen <code>TotalOrder</code> und <code>BadTotalOrder</code> .  Zwei geordnete Mengen <code>O1 O2</code> : <code>TotalOrder</code> sind immer gleich, wenn es m√∂glich ist, die Gleichheit der Mengen <code>O1.E, O2.E</code> und der Ordnungen <code>O1.&lt;, O2.&lt;</code> Zu beweisen (dies ist die gew√ºnschte Eigenschaft).  Andererseits ist es f√ºr <code>O1 O2</code> : <code>BadTotalOrder</code> nur <code>BadTotalOrder</code> , die Gleichheit von <code>O1</code> und <code>O2</code> zu beweisen, wenn zus√§tzlich zu allen Elementen <code>x</code> aus <code>E</code> Gleichheit <code>O1.badTotality xx</code> und <code>O2.badTotality xx</code> . <br><br>  Es stellt sich also heraus, dass die Klasse <code>BadTotalOrder</code> intuitiv nicht als "linear geordnete Menge" betrachtet werden muss, sondern als "linear geordnete Menge zusammen mit der Auswahl f√ºr jedes Element <code>x</code> Feldes <code>E</code> linken oder rechten Zweigs <code>Or</code> bei der Implementierung von <code>badTotality xx</code> ". <br><br><h3>  2.4 Sortieralgorithmus </h3><br>  Wir fahren nun mit der Implementierung des Sortieralgorithmus fort.  Versuchen wir, die naive Implementierung der <code>insert</code> Funktion aus dem vorherigen Abschnitt mithilfe der bew√§hrten <code>set-trichotomy-property</code> (in diesem Fall haben wir aufgrund der erfolgreicheren Anordnung von Klammern bei der Definition der <code>set-trichotomy</code> die Anzahl der ber√ºcksichtigten F√§lle reduziert). <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : List O) (y : O) : List O \elim xs | nil =&gt; y :-: nil | :-: x xs' =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; y :-: x :-: xs'  | inl x&lt;=y =&gt; x :-: insert xs' y }</code> </pre> <br>  Versuchen wir nun, ein Analogon dieser Definition f√ºr geordnete Listen zu implementieren.  Wir werden das spezielle Konstrukt <code>\let ‚Ä¶ \in</code> verwenden, mit dem wir dem Kontext neue lokale Variablen hinzuf√ºgen k√∂nnen. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : SortedList O \elim xs | (nil, _) =&gt; (y :-: nil, singletonSorted) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; (y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted)  | inl x&lt;=y =&gt; \let (result, result-sorted) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y         \in (x :-: result, {?})</code> </pre> <br>  Wir haben im Beweis ein unvollst√§ndiges Fragment hinterlassen (angezeigt durch den Ausdruck <code>{?}</code> ). An der Stelle, an der Sie zeigen m√∂chten, dass das <code>x :-: result</code> der Liste <code>x :-: result</code> geordnet ist.  Obwohl es im Kontext Hinweise auf die Reihenfolge der <code>result</code> , m√ºssen wir √ºberpr√ºfen, ob <code>x</code> den Wert des ersten Elements der <code>result</code> nicht √ºberschreitet, was von den Pr√§missen im Kontext nicht so einfach zu verfolgen ist (um alle Pr√§missen im aktuellen Ziel zu sehen - das nennen wir Derzeitiger Berechnungszweig - Sie m√ºssen die Typpr√ºfung bei der <code>insert</code> anfordern. <br><br>  Es stellt sich heraus, dass das <code>insert</code> viel einfacher zu implementieren ist, wenn wir die Reihenfolge der resultierenden Liste parallel zum Nachweis der <code>insert</code> .  √Ñndern Sie die Unterschrift der <code>insert</code> und schreiben Sie in den einfachsten F√§llen den Nachweis dieser Spezifikation: <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp) | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {  | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)  | inl x&lt;=y =&gt;   \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y   \in ((x :-: result, {?}), insertedThere idp result-spec)</code> </pre> <br>  F√ºr ein einzelnes Fragment ohne Beweis gibt Arend den folgenden Kontextwert aus: <br><br><pre> <code class="plaintext hljs">Expected type: Sorted (x :-: (insert (\this, tail-sorted x \this \this) \this).1.1) Context:  result-sorted : Sorted (insert (\this, tail-sorted \this \this \this) \this).1.1  xs-sorted : Sorted (x :-: xs')  x : O  x&lt;=y : Or (x = y) (O.&lt; xy)  O : Dec  result : List O  y : O  xs' : List O  result-spec : InsertSpec xs' y (insert (xs', tail-sorted \this xs' \this) y).1.1</code> </pre> <br>  Um den Beweis zu vervollst√§ndigen, m√ºssen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die volle Leistung des</a> Operators <code>\case</code> : Wir werden den Mustervergleich mit 5 verschiedenen Variablen verwenden, und da die Typen einiger Variablen von den Werten anderer Variablen abh√§ngen k√∂nnen, werden wir den abh√§ngigen Mustervergleich verwenden. <br><br>  Die Doppelpunktkonstruktion gibt explizit an, wie der Typ einiger verglichener Variablen von den Werten anderer Variablen abh√§ngt (also in der Art der Variablen <code>xs-sorted, result-spec</code> und <code>result-sorted</code> in jedem von <code>\case</code> anstelle von <code>xs'</code> und <code>result</code> stimmt mit den entsprechenden Stichproben √ºberein). <br><br>  Das Konstrukt <code>\return</code> ordnet die Variablen, die zum Abgleichen des Musters verwendet werden, dem Typ des erwarteten Ergebnisses zu.  Mit anderen Worten, im aktuellen Ziel wird in jeder der <code>\case</code> Klauseln die entsprechende Stichprobe durch die entsprechende Stichprobe ersetzt.  Ohne diese Konstruktion w√ºrde eine solche Ersetzung nicht durchgef√ºhrt, und das Ziel aller <code>\case</code> Klauseln w√ºrde mit dem Ziel anstelle des <code>\case</code> Ausdrucks selbst √ºbereinstimmen. <br><br><pre> <code class="plaintext hljs">\func insert {O : LinearOrder.Dec} (xs : SortedList O) (y : O) : \Sigma (ys : SortedList O) (InsertSpec xs.1 y ys.1) \elim xs  | (nil, _) =&gt; ((y :-: nil, singletonSorted), insertedHere idp idp)  | (:-: x xs', xs-sorted) =&gt; \case set-trichotomy-property xy \with {   | inr y&lt;x =&gt; ((y :-: x :-: xs', consSorted (byRight y&lt;x) xs-sorted), insertedHere idp idp)   | inl x&lt;=y =&gt;     \let ((result, result-sorted), result-spec) =&gt; insert (xs', tail-sorted x xs' xs-sorted) y     \in ((x :-: result,       \case result \as result, xs' \as xs', xs-sorted : Sorted (x :-: xs'), result-spec : InsertSpec xs' y result, result-sorted : Sorted result       \return Sorted (x :-: result) \with {        | nil, _, _, _, _ =&gt; singletonSorted        | :-: r rs, _, _, insertedHere y=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) y=r (Or-to-|| x&lt;=y)) result-sorted        | :-: r rs, :-: x' _, consSorted x&lt;=x' _, insertedThere x2=r _, result-sorted =&gt; consSorted (transport (\lam z =&gt; (x = z) || (x &lt; z)) x2=r x&lt;=x') result-sorted }), insertedThere idp result-spec)</code> </pre> <br>  Im obigen Codeblock verdienen die komplexen ersten Argumente des <code>consSorted</code> Konstruktors in den letzten beiden Abs√§tzen des Mustervergleichs einen zus√§tzlichen Kommentar.  Um zu verstehen, was diese beiden Ausdr√ºcke bedeuten, ersetzen wir sie durch den Ausdruck <code>{?}</code> Und bitten den Arend-Timer, Ziele an beiden Positionen zu bestimmen. <br><br>  Sie k√∂nnen sehen, dass sowohl dort als auch dort das aktuelle Ziel der Typ <code>(x = r) || O.&lt; xr</code>  <code>(x = r) || O.&lt; xr</code> .  Dar√ºber hinaus gibt es im Rahmen des ersten Ziels Pr√§missen <br><br><pre> <code class="plaintext hljs">x&lt;=y : Or (x = y) (O.&lt; xy) y=r : y = r</code> </pre> <br>  und im Kontext der zweiten Pr√§misse <br><br><pre> <code class="plaintext hljs">x&lt;=x' : (x = x') || O.&lt; xx' x2=r : x' = r.</code> </pre> <br>  Intuitiv klar: Um das erste Ziel zu beweisen, reicht es aus, die Variable <code>r</code> durch die richtige Aussage <code>Or (x = y) (O.&lt; xy)</code> zu ersetzen und dann zum propositionell abgeschnittenen Typ <code>||</code> wechseln  Verwenden der in Abschnitt 1.3 definierten <code>Or-to-||</code> -Funktion  .  Um das zweite Ziel zu beweisen, setzen Sie einfach <code>(x = x') || O.&lt; x x'</code>  <code>(x = x') || O.&lt; x x'</code> anstelle der Variablen <code>x'</code> Variable <code>r</code> . <br><br>  Zur Formalisierung der beschriebenen Ausdruckssubstitutionsoperation existiert in der Standard-Arend-Bibliothek eine spezielle <code>transport</code> .  Betrachten Sie ihre Unterschrift: <br><br><pre> <code class="plaintext hljs">\func transport {A : \Type} (B : A -&gt; \Type) {aa' : A} (p : a = a') (b : B a) : B a'</code> </pre> <br>  In unserem Fall m√ºssen wir anstelle der Variablen <code>A</code> den Typ <code>OE</code> ersetzen (er kann explizit weggelassen werden, wenn die anderen <code>transport</code> angegeben werden) und anstelle von <code>B</code> den Ausdruck <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code>  <code>\lam (z : O) =&gt; (x = z) || (x &lt; z)</code> . <br><br>  Die Implementierung des Einf√ºgungssortierungsalgorithmus zusammen mit der Spezifikation verursacht keine besonderen Schwierigkeiten mehr: Um die Liste <code>x :-: xs'</code> zu sortieren, sortieren wir zuerst den Schwanz der Liste <code>xs'</code> mit einem rekursiven Aufruf von <code>insertSort</code> und f√ºgen dann das Element <code>x</code> in diese Liste ein, wobei die Reihenfolge f√ºr <code>insertSort</code> wird Hilfe beim Zugriff auf die bereits implementierte <code>insert</code> . <br><br><pre> <code class="plaintext hljs">\func insertSort {O : LinearOrder.Dec} (xs : List O) : \Sigma (result : SortedList O) (Perm xs result.1) \elim xs | nil =&gt; ((nil, nilSorted), permTrivial idp) | :-: x xs' =&gt; \let | (ys, perm-xs'-ys) =&gt; insertSort xs'                      | (zs, zs-spec) =&gt; insert ys x                  \in (zs, permInsert perm-xs'-ys (insertedHere idp idp) zs-spec)</code> </pre> <br>  Wir haben das urspr√ºngliche Ziel erreicht und die Sortierung der Listen auf Arend implementiert.  Der gesamte in diesem Absatz angegebene Arend-Code kann <a href="">von hier aus</a> in einer Datei heruntergeladen <a href="">werden</a> . <br><br>  Man k√∂nnte sich fragen, wie man die Implementierung der <code>LinearOrder.Dec</code> √§ndern m√ºsste, wenn wir anstelle der strengen <code>LinearOrder.Dec</code> Befehle die nicht strengen <code>TotalOrder</code> Befehle verwenden w√ºrden.  Wie wir uns erinnern, wird bei der Definition der Totalit√§tsfunktion die Verwendung der abgeschnittenen Operation <code>||</code>  war ziemlich bedeutsam, das hei√üt, diese Definition entspricht nicht einer Definition, in der anstelle von <code>||</code>  verwendet von <code>Or</code> . <br><br>  Die Antwort auf diese Frage lautet wie folgt: Es ist immer noch m√∂glich, ein <code>insert</code> Analogon f√ºr <code>TotalOrder</code> zu <code>TotalOrder</code> . Dazu m√ºssten wir jedoch beweisen, dass der Typ der <code>insert</code> Funktion eine Anweisung ist (dies w√ºrde es uns bei der Definition von <code>insert</code> , mit der Stichprobe gem√§√ü der <code>totality xy</code> Anweisung <code>totality xy</code> ). <br><br>  Mit anderen Worten, wir m√ºssten beweisen, dass es nur eine geordnete Liste bis zur Gleichheit gibt, was das Ergebnis des Einf√ºgens des Elements <code>y</code> in die geordnete Liste <code>xs</code> .  Es ist leicht zu erkennen, dass dies eine wahre Tatsache ist, aber der formale Beweis ist nicht mehr so ‚Äã‚Äãtrivial.  Wir √ºberlassen die √úberpr√ºfung dieser Tatsache dem interessierten Leser als √úbung. <br><br><h2>  3. Schlussbemerkungen </h2><br>  In dieser Einf√ºhrung haben wir die Hauptkonstrukte der Arend-Sprache kennengelernt und auch gelernt, wie man den Klassenmechanismus verwendet.  Es ist uns gelungen, den einfachsten Algorithmus zusammen mit dem Nachweis seiner Spezifikation zu implementieren.  So haben wir gezeigt, dass Arend gut zur L√∂sung "allt√§glicher" Probleme geeignet ist, wie zum Beispiel zur Programm√ºberpr√ºfung. <br><br>  Wir haben weit entfernt von allen Funktionen und Merkmalen von Arend erw√§hnt.  Zum Beispiel haben wir fast nichts √ºber <i>Typen mit Bedingungen</i> gesagt, die es Ihnen erm√∂glichen, verschiedene Typkonstruktoren mit einigen speziellen Parameterwerten f√ºr diese Konstruktoren zu ‚Äûkleben‚Äú.  Beispielsweise wird eine Implementierung des Integer-Typs in Arend unter Verwendung von Typen mit folgenden Bedingungen angegeben: <br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero }</code> </pre> <br>  Diese Definition besagt, dass ganze Zahlen aus zwei Kopien des Typs nat√ºrlicher Zahlen bestehen, in denen "positive" und "negative" Nullen identifiziert werden.  Eine solche Definition ist viel praktischer als die Definition aus der Standard-Coq-Bibliothek, bei der die ‚Äûnegative Kopie‚Äú nat√ºrlicher Zahlen ‚Äûum eins verschoben‚Äú werden muss, damit sich diese Kopien nicht √ºberschneiden (es ist viel bequemer, wenn die Notation <code>neg 1</code> die Zahl -1, nicht -2 bedeutet). . <br><br>  Wir haben nichts √ºber den Algorithmus zum Ableiten von Pr√§dikativ- und Homotopieebenen in Klassen und deren Instanzen gesagt.  Wir haben auch die Art des Intervalls <code>I</code> kaum erw√§hnt, obwohl es eine Schl√ºsselrolle in der Theorie der Typen mit Intervallen spielt, die die logische Grundlage von Arend sind.  Um zu verstehen, wie wichtig dieser Typ ist, muss erw√§hnt werden, dass in Arend die Typgleichheit durch das Konzept eines Intervalls definiert wird.     ,   ,     ,           (..    ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470632/">https://habr.com/ru/post/de470632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470616/index.html">Eine neue L√∂sung f√ºr das Fermi-Paradoxon (warum wir allein im Universum sind)</a></li>
<li><a href="../de470618/index.html">Thematische Modellierung von Nachrichten mittels Faktoranalyse</a></li>
<li><a href="../de470620/index.html">Infrastruktur als Code: So √ºberwinden Sie Probleme mit XP</a></li>
<li><a href="../de470622/index.html">√úbersicht √ºber Methoden zur Merkmalsauswahl</a></li>
<li><a href="../de470628/index.html">Raumschiff Simulator Schiffbau</a></li>
<li><a href="../de470634/index.html">Identifizieren Sie Community-√ºbergreifend auf Instagram, um Benutzerinteressen zu identifizieren</a></li>
<li><a href="../de470638/index.html">Quasi-Newtonsche Methoden oder wenn es zu viele zweite Ableitungen f√ºr Athos gibt</a></li>
<li><a href="../de470640/index.html">Dimensionierung Elasticsearch</a></li>
<li><a href="../de470642/index.html">Treffen Sie Yandex.Station Mini. Gro√üe Geschichte eines kleinen Ger√§ts</a></li>
<li><a href="../de470646/index.html">Mathematik f√ºr Data Science. Neuer Kurs von OTUS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>