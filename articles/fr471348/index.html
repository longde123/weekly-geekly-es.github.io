<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 🌵 🥪 Applications TypeScript à pile complète ⏸️ 🖖🏻 🥊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article "Full Type Stack TypeScript Apps - Part 1: Developing Backend APIs with Nest.js" par Ana Ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Applications TypeScript à pile complète</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471348/"><p>  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Full Type Stack TypeScript Apps - Part 1: Developing Backend APIs with Nest.js"</a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ana Ribeiro</a> . </p><br><h2 id="chast-1-razrabotka-servernogo-api-s-pomoschyu-nestjs">  Partie 1: Développement de l'API serveur à l'aide de Nest.JS </h2><br><p>  TL; DR: il s'agit d'une série d'articles sur la création d'une application Web TypeScript à l'aide d'Angular et de Nest.JS.  Dans la première partie, nous écrirons une simple API serveur utilisant Nest.JS.  La deuxième partie de cette série est consacrée à l'application frontale utilisant Angular.  Vous pouvez trouver le code final développé dans cet article dans ce <a href="">référentiel GitHub.</a> </p><br><h3 id="chto-takoe-nestjs-i-pochemu-imenno-angular">  Qu'est-ce que Nest.Js et pourquoi Angular? </h3><br><p>  Nest.js est un cadre pour la création d'applications de serveur Web Node.js. </p><br><p>  Une particularité est qu'il résout un problème qu'aucun autre framework ne résout: la structure du projet node.js. <a name="habracut"></a>  Si vous avez déjà développé sous node.js, vous savez que vous pouvez faire beaucoup avec un seul module (par exemple, le middleware Express peut tout faire, de l'authentification à la validation), ce qui peut finalement conduire à un "gâchis" non pris en charge .  Comme vous le verrez ci-dessous, nest.js nous aidera à cela en fournissant des classes spécialisées dans divers problèmes. </p><br><p>  Nest.js est fortement inspiré par Angular.  Par exemple <cut></cut>  les deux plates-formes utilisent des gardes pour autoriser ou empêcher l'accès à certaines parties de vos applications, et les deux plates-formes fournissent une interface CanActivate pour implémenter ces gardes.  Cependant, il est important de noter que, malgré certains concepts similaires, les deux structures sont indépendantes l'une de l'autre.  Autrement dit, dans cet article, nous allons créer une API indépendante pour notre front-end, qui peut être utilisée avec n'importe quel autre framework (React, Vue.JS et ainsi de suite). </p><br><h3 id="veb-prilozhenie-dlya-on-layn-zakazov">  Application Web pour les commandes en ligne </h3><br><p>  Dans ce guide, nous allons créer une application simple dans laquelle les utilisateurs peuvent passer des commandes dans un restaurant.  Il implémentera cette logique: </p><br><ul><li>  tout utilisateur peut afficher le menu; </li><li>  seul un utilisateur autorisé peut ajouter des marchandises au panier (passer une commande) </li><li>  seul l'administrateur peut ajouter de nouveaux éléments de menu. </li></ul><br><p>  Par souci de simplicité, nous n'interagirons pas avec une base de données externe et n'implémenterons pas la fonctionnalité de notre panier. </p><cut></cut><br><h3 id="sozdanie-faylovoy-struktury-proekta-nestjs">  Création de la structure de fichiers du projet Nest.js </h3><br><p>  Pour installer Nest.js, nous devons installer Node.js (v.8.9.x ou supérieur) et NPM.  Téléchargez et installez Node.js pour votre système d'exploitation à partir du site Web officiel (NPM est inclus).  Une fois tout installé, vérifiez les versions: </p><br><pre><code class="bash hljs">node -v <span class="hljs-comment"><span class="hljs-comment"># v12.11.1 npm -v # 6.11.3</span></span></code> </pre> <br><p>  Il existe différentes façons de créer un projet avec Nest.js;  ils se trouvent dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> .  Nous utiliserons <code>nest-cli</code> .  Installez-le: </p><br><p> <code>npm i -g @nestjs/cli</code> </p> <br><p>  Ensuite, créez notre projet avec une simple commande: </p><br><p> <code>nest new nest-restaurant-api</code> </p> <br><p>  dans le processus, nest nous demandera de choisir un gestionnaire de paquets: <code>npm</code> ou <code>yarn</code> </p><br><p>  Si tout s'est bien passé, <code>nest</code> créera la structure de fichiers suivante: </p><br><pre> <code class="plaintext hljs">nest-restaurant-api ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── .gitignore ├── .prettierrc ├── nest-cli.json ├── package.json ├── package-lock.json ├── README.md ├── tsconfig.build.json ├── tsconfig.json └── tslint.json</code> </pre> <br><p>  allez dans le répertoire créé et démarrez le serveur de développement: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    cd nest-restaurant-api #   npm run start:dev</span></span></code> </pre> <br><p>  Ouvrez un navigateur et entrez <code>http://localhost:3000</code> .  Sur l'écran, nous verrons: <br><img src="https://habrastorage.org/webt/xl/pk/tl/xlpktlb_nkwfh6-akeba7wtnmjc.png"></p><br><p>  Dans le cadre de ce didacticiel, nous ne testerons pas notre API (bien que vous deviez écrire des tests pour toute application prête à l'emploi).  De cette façon, vous pouvez effacer le répertoire de <code>test</code> et supprimer le <code>src/app.controller.spec.ts</code> (qui est celui de test).  Par conséquent, notre dossier source contient les fichiers suivants: </p><br><ul><li>  <code>src/app.controller.ts</code> et <code>src/app.module.ts</code> : ces fichiers sont responsables de la création <code>Hello world</code> message <code>Hello world</code> long de la route <code>/</code> .  Parce que  ce point d'entrée n'est pas important pour cette application nous les supprimons.  Bientôt, vous apprendrez plus en détail ce que sont les <strong>contrôleurs</strong> et les <strong>services</strong> . </li><li>  <code>src/app.module.ts</code> : contient une description d'une classe de type <strong>module</strong> , qui est chargée de déclarer l'importation, l'exportation des contrôleurs et des fournisseurs vers l'application nest.js.  Chaque application a au moins un module, mais vous pouvez créer plus d'un module pour des applications plus complexes (plus dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . Notre application ne contiendra qu'un seul module </li><li>  <code>src/main.ts</code> : c'est le fichier responsable du démarrage du serveur. </li></ul><br><blockquote><cut text=""></cut>  Remarque: après avoir supprimé <code>src/app.controller.ts</code> et <code>src/app.module.ts</code> vous ne pourrez pas démarrer notre application.  Ne vous inquiétez pas, nous allons le réparer bientôt </blockquote><br><h3 id="sozdanie-tochek-vhoda-endpoints">  Créer des points d'entrée (points d'extrémité) </h3><br><br><p>  Notre API sera disponible sur la route <code>/items</code> .  Ce point d'entrée permet aux utilisateurs de recevoir des données et aux administrateurs de gérer le menu.  Créons-le. </p><br><p>  Pour ce faire, créez un répertoire appelé <code>items</code> dans <code>src</code> .  Tous les fichiers associés à la route <code>/items</code> seront stockés dans ce nouveau répertoire. </p><br><h4 id="sozdanie-kontrollerov">  Création de contrôleurs </h4><br><p>  dans <code>nest.js</code> , comme dans de nombreux autres frameworks, les contrôleurs sont responsables du mappage des routes avec des fonctionnalités.  Pour créer un contrôleur dans <code>nest.js</code> utilisez le décorateur <code>nest.js</code> comme suit: <code>@Controller(${ENDPOINT})</code> .  De plus, afin de mapper diverses méthodes <code>HTTP</code> , telles que <code>GET</code> et <code>POST</code> , des décorateurs <code>@Get</code> , <code>@Post</code> , <code>@Delete</code> , etc. sont utilisés. </p><br><p>  Dans notre cas, nous devons créer un contrôleur qui retourne les plats disponibles dans le restaurant et que les administrateurs utiliseront pour gérer le contenu du menu.  Créons un fichier appelé <code>items.controller.tc</code> dans le répertoire <code>src/items</code> avec le contenu suivant: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController { @Get() async findAll(): Promise&lt;string[]&gt; { return ['Pizza', 'Coke']; } @Post() async create() { return 'Not yet implemented'; } }</code> </pre> <br><p>  afin de rendre notre nouveau contrôleur disponible dans notre application, enregistrez-le dans le module: </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; @Module({ imports: [], controllers: [ItemsController], providers: [], }) export class AppModule {}</code> </pre> <br><p>  Lancez notre application: <code>npm run start:dev</code> et ouvrez dans le navigateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 3000 / items</a> , si vous avez tout fait correctement, alors nous devrions voir la réponse à notre demande get: <code>['Pizza', 'Coke']</code> . </p><br><p>  <em>Note du traducteur: pour créer de nouveaux contrôleurs, ainsi que d'autres éléments de <code>nest.js</code> : services, fournisseurs, etc., il est plus pratique d'utiliser la commande <code>nest generate</code> du <code>nest-cli</code> .</em>  <em>Par exemple, pour créer le contrôleur décrit ci-dessus, vous pouvez utiliser la commande <code>nest generate controller items</code> , à la suite de quoi nest créera les <code>src/items/items.controller.tc</code> <code>src/items/items.controller.spec.tc</code> et <code>src/items/items.controller.tc</code> contenu suivant:</em> </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Controller } from '@nestjs/common'; @Controller('items') export class ItemsController {}</code> </pre> <br><p>  <em>et enregistrez-le dans <code>app.molule.tc</code></em> </p><br><h4 id="dobavlenie-servisa-service">  Ajout d'un service </h4><br><p>  Maintenant, lors de l'accès à <code>/items</code> notre application renvoie le même tableau pour chaque demande, que nous ne pouvons pas changer.  Le traitement et la sauvegarde des données ne sont pas l'affaire du contrôleur; à cet effet, les services sont destinés à nest.js <br>  Les services dans nest sont des <code>@Injectable</code> <br>  Le nom du décorateur parle de lui-même, l'ajout de ce décorateur à la classe le rend injectable dans d'autres composants, tels que les contrôleurs. <br>  Créons notre service.  Créez le fichier <code>items.service.ts</code> dans le dossier <code>items.service.ts</code> avec le contenu suivant: </p><br><pre> <code class="plaintext hljs"> import { Injectable } from '@nestjs/common'; @Injectable() export class ItemsService { private readonly items: string[] = ['Pizza', 'Coke']; findAll(): string[] { return this.items; } create(item: string) { this.items.push(item); } }</code> </pre> <br><p>  et changez le contrôleur <code>ItemsController</code> (déclaré dans <code>items.controller.ts</code> ) pour utiliser notre service: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;string[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: string) { this.itemsService.create(item); } }</code> </pre> <br><p>  Dans la nouvelle version du contrôleur, nous avons appliqué le décorateur <code>@Body</code> à l'argument de méthode <code>create</code> .  Cet argument est utilisé pour faire correspondre automatiquement les données transmises via <code>req.body ['item']</code> à l'argument lui-même (dans ce cas, <code>item</code> ). <br>  Notre contrôleur reçoit également une instance de la classe <code>ItemsService</code> , injectée via le constructeur.  Déclarer <code>ItemsService</code> comme <code>private readonly</code> rend une instance immuable et visible uniquement à l'intérieur de la classe. <br>  Et n'oubliez pas d'enregistrer notre service dans <code>app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Après toutes les modifications, envoyons une demande HTTP POST au menu: </p><br><pre> <code class="bash hljs"> curl -X POST -H <span class="hljs-string"><span class="hljs-string">'content-type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{"item": "Salad"}'</span></span> localhost:3000/items</code> </pre> <br><p>  Ensuite, nous vérifierons si de nouveaux plats sont apparus dans notre menu en faisant une demande GET (ou en ouvrant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 3000 / items</a> dans un navigateur) </p><br><pre> <code class="bash hljs"> curl localhost:3000/items</code> </pre> <br><h4 id="sozdanie-marshruta-dlya-korziny-pokupok">  Création d'un itinéraire de panier d'achat </h4><br><p>  Maintenant que nous avons la première version du point d'entrée <code>/items</code> notre API, implémentons la fonctionnalité de panier.  Le processus de création de cette fonctionnalité n'est pas très différent de l'API déjà créée.  Par conséquent, afin de ne pas encombrer le manuel, nous allons créer un composant qui répond avec un statut OK lors de l'accès. </p><br><p>  Tout d'abord, dans le dossier <code>./src/shopping-cart/</code> créez le <code>shoping-cart.controller.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Post, Controller } from '@nestjs/common'; @Controller('shopping-cart') export class ShoppingCartController { @Post() async addItem() { return 'This is a fake service :D'; } }</code> </pre> <br><p>  Enregistrez ce contrôleur dans notre module ( <code>app.module.ts</code> ): </p><br><pre> <code class="plaintext hljs"> import { Module } from '@nestjs/common'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule {}</code> </pre> <br><p>  Pour vérifier ce point d'entrée, exécutez la commande suivante, après vous être assuré que l'application est en cours d'exécution: </p><br><pre> <code class="bash hljs"> curl -X POST localhost:3000/shopping-cart</code> </pre> <br><h4 id="dobavlenie-opisaniya--interface-typescript-dlya-items">  Ajout d'un script d'interface pour les éléments </h4><br><p>  Retour à notre service d' <code>items</code> .  Maintenant, nous enregistrons uniquement le nom du plat, mais ce n'est clairement pas suffisant, et, bien sûr, nous voudrons avoir plus d'informations (par exemple, le coût du plat).  Je pense que vous conviendrez que le stockage de ces données sous forme de tableau de chaînes n'est pas une bonne idée? <br>  Pour résoudre ce problème, nous pouvons créer un tableau d'objets.  Mais comment sauvegarder la structure des objets?  Ici, l'interface TypeScript nous aidera, dans laquelle nous définirons la structure de l'objet <code>items</code> .  Créez un nouveau fichier nommé <code>item.interface.ts</code> dans le dossier <code>src/items</code> : </p><br><pre> <code class="plaintext hljs"> export interface Items { readonly name: string; readonly price: number; }</code> </pre> <br><p>  <code>items.service.ts</code> ensuite <code>items.service.ts</code> fichier <code>items.service.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Injectable } from '@nestjs/common'; import { Item } from './item.interface'; @Injectable() export class ItemsService { private readonly items: Item[] = []; findAll(): Item[] { return this.items; } create(item: Item) { this.items.push(item); } }</code> </pre> <br><p>  Et aussi dans <code>items.controller.ts</code> : </p><br><pre> <code class="plaintext hljs">import { Get, Post, Body, Controller } from '@nestjs/common'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() async create(@Body() item: Item) { this.itemsService.create(item); } }</code> </pre> <br><h4 id="validaciya-vhodnyh-dannyh-v-nestjs">  Validation de l'entrée dans Nest.js </h4><br><p>  Malgré le fait que nous ayons déterminé la structure de l'objet <code>item</code> , notre application ne retournera pas d'erreur si nous envoyons une requête POST invalide (tout type de données non défini dans l'interface).  Par exemple, pour une telle demande: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": 3, "price": "any" }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  le serveur doit répondre avec un état de 400 (mauvaise demande), mais à la place, notre application répondra avec un état de 200 (OK). </p><br><p>  Pour résoudre ce problème, créez un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DTO (Data Transfer Object)</a> et un composant Pipe (canal). </p><br><p>  DTO est un objet qui définit comment les données doivent être transférées entre les processus.  Nous décrivons le DTO dans le <code>src/items/create-item.dto.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { IsString, IsInt } from 'class-validator'; export class CreateItemDto { @IsString() readonly name: string; @IsInt() readonly price: number; }</code> </pre> <br><p>  Les tuyaux dans <code>Nest.js</code> sont les composants utilisés pour la validation.  Pour notre API, créez un canal dans lequel il vérifie si les données envoyées à la méthode correspondent au DTO.  Un canal peut être utilisé par différents contrôleurs, alors créez le répertoire <code>src/common/</code> avec le fichier <code>validation.pipe.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value, metadata: ArgumentMetadata) { const { metatype } = metadata; if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype): boolean { const types = [String, Boolean, Number, Array, Object]; return !types.find(type =&gt; metatype === type); } }</code> </pre> <br><blockquote>  Remarque: Nous devons installer deux modules: <code>class-validator</code> <code>class-transformer</code> .  Pour ce faire, exécutez <code>npm install class-validator class-transformer</code> dans la console et redémarrez le serveur. </blockquote><p>  Adaptation de <code>items.controller.ts</code> pour une utilisation avec notre nouveau tube et DTO: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Vérifions à nouveau notre code, maintenant l'entrée <code>/items</code> n'accepte les données que si elles sont définies dans le DTO.  Par exemple: </p><br><pre> <code class="bash hljs"> curl -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json'</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "name": "Salad", "price": 3 }'</span></span> http://localhost:3000/items</code> </pre> <br><p>  Collez des données non valides (données qui ne peuvent pas être vérifiées dans <code>ValidationPipe</code> ), par conséquent, nous obtenons la réponse: </p><br><pre> <code class="plaintext hljs"> {"statusCode":400,"error":"Bad Request","message":"Validation failed"}</code> </pre> <br><h5 id="sozdanie-middleware">  Création de middleware </h5><br><p>  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page du guide de démarrage rapide Auth0</a> , la méthode recommandée pour vérifier le jeton JWT émis par Auth0 consiste à utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">middleware Express</a> fourni par <code>express-jwt</code> .  Ce middleware automatise une grande partie du travail. </p><br><p>  Créons un fichier <code>authentication.middleware.ts</code> dans le répertoire <code>src / common</code> avec le code suivant: </p><br><pre> <code class="plaintext hljs"> import { NestMiddleware } from '@nestjs/common'; import * as jwt from 'express-jwt'; import { expressJwtSecret } from 'jwks-rsa'; export class AuthenticationMiddleware implements NestMiddleware { use(req, res, next) { jwt({ secret: expressJwtSecret({ cache: true, rateLimit: true, jwksRequestsPerMinute: 5, jwksUri: 'https://${DOMAIN}/.well-known/jwks.json', }), audience: 'http://localhost:3000', issuer: 'https://${DOMAIN}/', algorithm: 'RS256', })(req, res, err =&gt; { if (err) { const status = err.status || 500; const message = err.message || 'Sorry, we were unable to process your request.'; return res.status(status).send({ message, }); } next(); }); }; }</code> </pre> <br><p>  Remplacez <code>${DOMAIN}</code> par la valeur de <em>domaine</em> des paramètres de l'application Auth0 </p><br><blockquote>  Note du traducteur: dans une application réelle, supprimez <code>DOMAIN</code> en une constante et définissez sa valeur via <code>env</code> (environnement virtuel) </blockquote><p>  Installez les <code>jwks-rsa</code> <code>express-jwt</code> et <code>jwks-rsa</code> : </p><br><pre> <code class="bash hljs"> npm install express-jwt jwks-rsa</code> </pre> <br><p>  Il est nécessaire de connecter le middleware créé (gestionnaire) à notre application.  Pour ce faire, dans le fichier <code>./src/app.module.ts</code> : </p><br><pre> <code class="plaintext hljs"> import { Module, MiddlewareConsumer, RequestMethod } from '@nestjs/common'; import { AuthenticationMiddleware } from './common/authentication.middleware'; import { ItemsController } from './items/items.controller'; import { ShoppingCartController } from './shopping-cart/shopping-cart.controller'; import { ItemsService } from './items/items.service'; @Module({ imports: [], controllers: [ItemsController, ShoppingCartController], providers: [ItemsService], }) export class AppModule { public configure(consumer: MiddlewareConsumer) { consumer .apply(AuthenticationMiddleware) .forRoutes( { path: '/items', method: RequestMethod.POST }, { path: '/shopping-cart', method: RequestMethod.POST }, ); } }</code> </pre> <br><p>  Le code ci-dessus indique que les requêtes POST vers les itinéraires <code>/items</code> et <code>/shopping-cart</code> sont protégées par le <em>middleware Express</em> , qui vérifie le jeton d'accès dans la requête. </p><br><p>  Redémarrez le serveur de développement ( <code>npm run start:dev</code> ) et appelez l'API Nest.js: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#     curl -X POST http://localhost:3000/shopping-cart #      TOKEN="eyJ0eXAiO...Mh0dpeNpg" # and issue a POST request with it curl -X POST -H 'authorization: Bearer '$TOKEN http://localhost:3000/shopping-cart</span></span></code> </pre> <br><h5 id="upravlenie-rolyami-s-auth0">  Gestion des rôles avec Auth0 </h5><br><p>  Pour le moment, tout utilisateur disposant d'un jeton vérifié peut publier un élément dans notre API.  Cependant, nous aimerions que seuls les utilisateurs disposant de droits d'administrateur puissent le faire.  Pour implémenter cette fonction, nous utilisons les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règles (règles) Auth0</a> . </p><br><p>  Alors, allez dans le panneau de configuration Auth0, dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la section <em>Règles</em></a> .  Là, cliquez sur le bouton <code>+ CREATE RULE</code> et sélectionnez "Définir les rôles pour un utilisateur" comme modèle de règle. </p><br><p><img src="https://habrastorage.org/webt/qa/bz/6m/qabz6mavaqzu_qfeh9vxn8xkn4w.png"></p><br><p>  Cela fait, nous obtenons un fichier JavaScript avec un modèle de règle qui ajoute le rôle d'administrateur à tout utilisateur qui a un e-mail appartenant à un certain domaine.  Modifions quelques détails dans ce modèle pour obtenir un exemple fonctionnel.  Pour notre application, nous ne donnerons à l'administrateur qu'un accès à notre propre adresse e-mail.  Nous devrons également modifier l'emplacement de stockage des informations sur le statut d'administrateur. </p><br><p>  À l'heure actuelle, ces informations sont stockées dans un jeton d'identification (utilisé pour fournir des informations sur l'utilisateur), mais un jeton d'accès doit être utilisé pour accéder aux ressources de l'API.  Le code après les modifications devrait ressembler à ceci: </p><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, context, callback</span></span></span><span class="hljs-function">) </span></span>{ user.app_metadata = user.app_metadata || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.email &amp;&amp; user.email === <span class="hljs-string"><span class="hljs-string">'${YOUR_EMAIL}'</span></span>) { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'admin'</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { user.app_metadata.roles = [<span class="hljs-string"><span class="hljs-string">'user'</span></span>]; } auth0.users .updateAppMetadata(user.user_id, user.app_metadata) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.accessToken[<span class="hljs-string"><span class="hljs-string">'http://localhost:3000/roles'</span></span>] = user.app_metadata.roles; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, user, context); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ callback(err); }); }</code> </pre> <br><blockquote>  Remarque: remplacez <code>${YOUR_EMAIL}</code> par votre adresse e-mail.  Il est important de noter qu'en règle générale, lorsque vous traitez des e-mails dans les règles Auth0, il est idéal de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">forcer la vérification des e-mails</a> .  Dans ce cas, cela n'est pas obligatoire car nous utilisons notre propre adresse e-mail. <br><br>  Note du traducteur: le fragment de code ci-dessus est entré dans le navigateur sur la page de configuration de la règle Auth0 </blockquote><p>  Pour vérifier si le jeton transmis à notre API est le jeton administrateur, nous devons créer un <em>gardien</em> Nest.js.  Dans le dossier <code>src/common</code> , créez le fichier <code>admin.guard.ts</code> </p><br><pre> <code class="plaintext hljs"> import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; @Injectable() export class AdminGuard implements CanActivate { canActivate(context: ExecutionContext): boolean { const user = context.getArgs()[0].user['http://localhost:3000/roles'] || ''; return user.indexOf('admin') &gt; -1; } }</code> </pre> <br><p>  Maintenant, si nous répétons le processus de connexion décrit ci-dessus et utilisons l'adresse e-mail définie dans la règle, nous obtiendrons un nouveau <code>access_token</code> .  Pour vérifier le contenu de ce <code>access_token</code> , copiez et collez le jeton dans le champ <code>Encoded</code> du site <code>https://jwt.io/</code> .  Nous verrons que la section de charge utile de ce jeton contient le tableau suivant: </p><br><pre> <code class="plaintext hljs"> "http://localhost:3000/roles": [ "admin" ]</code> </pre> <br><p>  Si notre jeton inclut vraiment ces informations, nous continuons l'intégration avec Auth0.  Alors, ouvrez <code>items.controller.ts</code> et ajoutez notre nouvelle garde là-bas: </p><br><pre> <code class="plaintext hljs"> import { Get, Post, Body, Controller, UsePipes, UseGuards, } from '@nestjs/common'; import { CreateItemDto } from './create-item.dto'; import { ItemsService } from './items.service'; import { Item } from './item.interface'; import { ValidationPipe } from '../common/validation.pipe'; import { AdminGuard } from '../common/admin.guard'; @Controller('items') export class ItemsController { constructor(private readonly itemsService: ItemsService) {} @Get() async findAll(): Promise&lt;Item[]&gt; { return this.itemsService.findAll(); } @Post() @UseGuards(new AdminGuard()) @UsePipes(new ValidationPipe()) async create(@Body() createItemDto: CreateItemDto) { this.itemsService.create(createItemDto); } }</code> </pre> <br><p>  Maintenant, avec notre nouveau jeton, nous pouvons ajouter de nouveaux éléments via notre API: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#    npm run start:dev #  POST       curl -X POST -H 'Content-Type: application/json' \ -H 'authorization: Bearer '$TOKEN -d '{ "name": "Salad", "price": 3 }' http://localhost:3000/items</span></span></code> </pre> <br><blockquote>  Note du traducteur: pour vérification, vous pouvez voir ce que nous avons dans les articles: <br><pre> <code class="plaintext hljs">curl -X GET http://localhost:3000/items</code> </pre> <br></blockquote><br><h4 id="itogi">  Résumé </h4><br><p>  Félicitations!  Nous venons de terminer la construction de notre API Nest.JS et nous pouvons maintenant nous concentrer sur le développement de la partie frontale de notre application!  N'oubliez pas de consulter la deuxième partie de cette série: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Applications TypeScript à pile complète - Partie 2: Développement d'applications angulaires frontales.</a> </p><br><blockquote>  Note du traducteur: La traduction de la deuxième partie est en cours. </blockquote><p>  Pour résumer, dans cet article, nous avons utilisé diverses fonctionnalités de Nest.js et TypeScript: modules, contrôleurs, services, interfaces, canaux, middleware et guard pour créer API  J'espère que vous avez une bonne expérience et êtes prêt à continuer à développer notre application.  Si quelque chose ne vous est pas clair, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle nest.js</a> est une bonne source de réponses </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471348/">https://habr.com/ru/post/fr471348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471336/index.html">Holivar. Histoire de Runet. Partie 6. Serrures: Lurk, Tape, 282nd et Chinese path</a></li>
<li><a href="../fr471340/index.html">Drimsim vs Mate 20 Pro Round! Mais pour qui?</a></li>
<li><a href="../fr471342/index.html">Avalonia élégant</a></li>
<li><a href="../fr471344/index.html">Encore une fois à propos d'ImmutableList en Java</a></li>
<li><a href="../fr471346/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 384 (7-13 octobre 2019)</a></li>
<li><a href="../fr471350/index.html">Ingénierie inverse des amplificateurs opérationnels à faible bruit à partir d'un ordinateur analogique en 1969</a></li>
<li><a href="../fr471352/index.html">Rédaction de présentations dans LaTeX</a></li>
<li><a href="../fr471358/index.html">Comment écrire un contrat intelligent avec Python sur l'ontologie? Partie 4: API native</a></li>
<li><a href="../fr471360/index.html">Méthode de duplication. 11 exemples tirés de la conception d'ICE</a></li>
<li><a href="../fr471364/index.html">Gestion automatisée des tests avec Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>