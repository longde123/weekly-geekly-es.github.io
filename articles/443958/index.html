<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèº üëï üë©üèº‚Äçüîß Patr√≥n desechable (Principio de dise√±o desechable) pt.1 üßëüèø‚Äçü§ù‚Äçüßëüèª üè¶ ü§¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Patr√≥n desechable (Principio de dise√±o desechable) 


 Creo que casi cualquier programador que use .NET ahora dir√° que este patr√≥n es pan comido. Es e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Patr√≥n desechable (Principio de dise√±o desechable) pt.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443958/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h1 id="disposable-pattern-disposable-design-principle">  Patr√≥n desechable (Principio de dise√±o desechable) </h1><br><p>  Creo que casi cualquier programador que use .NET ahora dir√° que este patr√≥n es pan comido.  Es el patr√≥n m√°s conocido utilizado en la plataforma.  Sin embargo, incluso el dominio del problema m√°s simple y conocido tendr√° √°reas secretas que nunca ha visto.  Entonces, describamos todo desde el principio para los principiantes y todo lo dem√°s (para que cada uno pueda recordar lo b√°sico).  No te saltes estos p√°rrafos, ¬°te estoy mirando! </p><br><p>  Si pregunto qu√© es IDisposable, seguramente dir√°n que es </p><br><pre><code class="plaintext hljs">public interface IDisposable { void Dispose(); }</code> </pre> <br><p>  ¬øCu√°l es el prop√≥sito de la interfaz?  Quiero decir, ¬øpor qu√© necesitamos aclarar la memoria si tenemos un recolector de basura inteligente que borra la memoria en lugar de nosotros, para que ni siquiera tengamos que pensarlo?  Sin embargo, hay algunos peque√±os detalles. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Existe la idea err√≥nea de que <code>IDisposable</code> sirve para liberar recursos no administrados.  Esto es solo parcialmente cierto y para entenderlo, solo necesita recordar los ejemplos de recursos no administrados.  ¬øEs la clase <code>File</code> un recurso no administrado?  No  ¬øQuiz√°s <code>DbContext</code> es un recurso no administrado?  No otra vez  Un recurso no administrado es algo que no pertenece al sistema de tipo .NET.  Algo que la plataforma no cre√≥, algo que existe fuera de su alcance.  Un ejemplo simple es un identificador de archivo abierto en un sistema operativo.  Un identificador es un n√∫mero que identifica de forma exclusiva un archivo abierto, no, no por usted, por un sistema operativo.  Es decir, todas las estructuras de control (por ejemplo, la posici√≥n de un archivo en un sistema de archivos, fragmentos de archivos en caso de fragmentaci√≥n y otra informaci√≥n de servicio, los n√∫meros de un cilindro, una cabeza o un sector de un HDD) est√°n dentro de un sistema operativo pero no Plataforma .NET.  El √∫nico recurso no administrado que se pasa a la plataforma .NET es el n√∫mero IntPtr.  Este n√∫mero est√° envuelto por FileSafeHandle, que a su vez est√° envuelto por la clase File.  Significa que la clase File no es un recurso no administrado por s√≠ solo, sino que usa una capa adicional en forma de IntPtr para incluir un recurso no administrado: el identificador de un archivo abierto.  ¬øC√≥mo lees ese archivo?  Usando un conjunto de m√©todos en WinAPI o Linux OS. </p><br><p>  Las primitivas de sincronizaci√≥n en programas multiproceso o multiprocesador son el segundo ejemplo de recursos no administrados.  Aqu√≠ pertenecen las matrices de datos que se pasan a trav√©s de P / Invoke y tambi√©n mutexes o sem√°foros. </p><br><blockquote>  Tenga en cuenta que el sistema operativo no simplemente pasa el identificador de un recurso no administrado a una aplicaci√≥n.  Tambi√©n guarda ese identificador en la tabla de identificadores abiertos por el proceso.  Por lo tanto, el sistema operativo puede cerrar correctamente los recursos despu√©s de la finalizaci√≥n de la aplicaci√≥n.  Esto garantiza que los recursos se cerrar√°n de todos modos despu√©s de salir de la aplicaci√≥n.  Sin embargo, el tiempo de ejecuci√≥n de una aplicaci√≥n puede ser diferente, lo que puede causar un bloqueo prolongado de los recursos. </blockquote><p>  Ok  Ahora cubrimos recursos no administrados.  ¬øPor qu√© necesitamos usar IDisposable en estos casos?  Porque .NET Framework no tiene idea de lo que sucede fuera de su territorio.  Si abre un archivo utilizando la API del sistema operativo, .NET no sabr√° nada al respecto.  Si asigna un rango de memoria para sus propias necesidades (por ejemplo, usando VirtualAlloc), .NET tampoco sabr√° nada.  Si no lo sabe, no liberar√° la memoria ocupada por una llamada VirtualAlloc.  O no cerrar√° un archivo abierto directamente a trav√©s de una llamada a la API del sistema operativo.  Estos pueden causar consecuencias diferentes e inesperadas.  Puede obtener OutOfMemory si asigna demasiada memoria sin liberarla (por ejemplo, simplemente configurando un puntero como nulo).  O, si abre un archivo en un recurso compartido de archivos a trav√©s del sistema operativo sin cerrarlo, bloquear√° el archivo en ese recurso compartido durante mucho tiempo.  El ejemplo de compartir archivos es especialmente bueno ya que el bloqueo permanecer√° en el lado de IIS incluso despu√©s de cerrar una conexi√≥n con un servidor.  No tiene derechos para liberar el bloqueo y deber√° solicitar a los administradores que <code>iisreset</code> o que cierren los recursos manualmente mediante un software especial. <br>  Este problema en un servidor remoto puede convertirse en una tarea compleja de resolver. </p><br><p>  Todos estos casos necesitan un <em>protocolo</em> universal y familiar <em>para la interacci√≥n</em> entre un sistema de tipos y un programador.  Debe identificar claramente los tipos que requieren cierre forzado.  La interfaz IDisposable sirve exactamente para este prop√≥sito.  Funciona de la siguiente manera: si un tipo contiene la implementaci√≥n de la interfaz IDisposable, debe llamar a Dispose () despu√©s de terminar el trabajo con una instancia de ese tipo. </p><br><p>  Entonces, hay dos formas est√°ndar de llamarlo.  Por lo general, crea una instancia de entidad para usarla r√°pidamente dentro de un m√©todo o durante la vida √∫til de la instancia de entidad. </p><br><p>  La primera forma es envolver una instancia para <code>using(...){ ... }</code> .  Significa que debe destruir un objeto una vez que finaliza el bloque relacionado con el uso, es decir, llamar a Dispose ().  La segunda forma es destruir el objeto, cuando termina su vida √∫til, con una referencia al objeto que queremos liberar.  Pero .NET no tiene m√°s que un m√©todo de finalizaci√≥n que implica la destrucci√≥n autom√°tica de un objeto, ¬øverdad?  Sin embargo, la finalizaci√≥n no es adecuada ya que no sabemos cu√°ndo se llamar√°.  Mientras tanto, necesitamos liberar un objeto en un momento determinado, por ejemplo, justo despu√©s de que terminemos de trabajar con un archivo abierto.  Es por eso que tambi√©n necesitamos implementar IDisposable y llamar a Dispose para liberar todos los recursos que poseemos.  Por lo tanto, seguimos el <em>protocolo</em> , y es muy importante.  Porque si alguien lo sigue, todos los participantes deber√≠an hacer lo mismo para evitar problemas. </p><br><h2 id="different-ways-to-implement-idisposable">  Diferentes formas de implementar IDisposable </h2><br><p>  Veamos las implementaciones de IDisposable de simple a complicado.  El primero y el m√°s simple es usar IDisposable como es: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { DisposableResource _anotherResource = new DisposableResource(); public void Dispose() { _anotherResource.Dispose(); } }</code> </pre> <br><p>  Aqu√≠, creamos una instancia de un recurso que Dispose () lanza a√∫n m√°s.  Lo √∫nico que hace que esta implementaci√≥n sea inconsistente es que a√∫n puede trabajar con la instancia despu√©s de su destrucci√≥n por <code>Dispose()</code> : </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { private DisposableResource _anotherResource = new DisposableResource(); private bool _disposed; public void Dispose() { if(_disposed) return; _anotherResource.Dispose(); _disposed = true; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } }</code> </pre> <br><p>  CheckDisposed () debe llamarse como una primera expresi√≥n en todos los m√©todos p√∫blicos de una clase.  La estructura de clase de <code>ResourceHolder</code> obtenida se ve bien para destruir un recurso no administrado, que es <code>DisposableResource</code> .  Sin embargo, esta estructura no es adecuada para un recurso no administrado incluido.  Veamos el ejemplo con un recurso no administrado. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { CloseHandle(_handle); } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern IntPtr CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError=true)] private static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  ¬øCu√°l es la diferencia en el comportamiento de los dos √∫ltimos ejemplos?  El primero describe la interacci√≥n de dos recursos gestionados.  Esto significa que si un programa funciona correctamente, el recurso se liberar√° de todos modos.  Dado que <code>DisposableResource</code> se administra, .NET CLR lo sabe y liberar√° la memoria si su comportamiento es incorrecto.  Tenga en cuenta que conscientemente no asumo lo que encapsula el tipo <code>DisposableResource</code> .  Puede haber cualquier tipo de l√≥gica y estructura.  Puede contener recursos administrados y no administrados.  <em>Esto no deber√≠a preocuparnos en absoluto</em> .  Nadie nos pide que descompilemos las bibliotecas de terceros cada vez y veamos si usan recursos administrados o no administrados.  Y si <em>nuestro tipo</em> utiliza un recurso no administrado, no podemos ignorarlo.  Hacemos esto en la clase <code>FileWrapper</code> .  Entonces, ¬øqu√© pasa en este caso?  Si usamos recursos no administrados, tenemos dos escenarios.  El primero es cuando todo est√° bien y se llama Dispose.  La segunda es cuando algo sale mal y Dispose falla. </p><br><p>  Digamos de inmediato por qu√© esto puede salir mal: </p><br><ul><li>  Si usamos el uso <code>using(obj) { ... }</code> , puede aparecer una excepci√≥n en un bloque de c√≥digo interno.  Esta excepci√≥n es atrapada por el bloque <code>finally</code> , que no podemos ver (este es el az√∫car sint√°ctico de C #).  Este bloque llama a Dispose impl√≠citamente.  Sin embargo, hay casos en que esto no sucede.  Por ejemplo, ni <code>catch</code> ni <code>finally</code> capture <code>StackOverflowException</code> .  Siempre debes recordar esto.  Porque si alg√∫n hilo se vuelve recursivo y se produce <code>StackOverflowException</code> en alg√∫n momento, .NET se olvidar√° de los recursos que us√≥ pero que no se lanzaron.  No sabe c√≥mo liberar recursos no administrados.  Permanecer√°n en la memoria hasta que el sistema operativo los libere, es decir, cuando salga de un programa, o incluso alg√∫n tiempo despu√©s de la finalizaci√≥n de una aplicaci√≥n. </li><li>  Si llamamos a Dispose () desde otro Dispose ().  Una vez m√°s, es posible que no lo logremos.  Este no es el caso de un desarrollador de aplicaciones distra√≠do, que olvid√≥ llamar a Dispose ().  Es la cuesti√≥n de las excepciones.  Sin embargo, estas no son solo las excepciones que bloquean un subproceso de una aplicaci√≥n.  Aqu√≠ hablamos de todas las excepciones que evitar√°n que un algoritmo llame a un Dispose externo () que llamar√° a nuestro Dispose (). </li></ul><br><p>  Todos estos casos crear√°n recursos no administrados suspendidos.  Esto se debe a que Garbage Collector no sabe que deber√≠a recolectarlos.  Todo lo que puede hacer en la pr√≥xima comprobaci√≥n es descubrir que se pierde la √∫ltima referencia a un gr√°fico de objeto con nuestro tipo <code>FileWrapper</code> .  En este caso, la memoria se reasignar√° para objetos con referencias.  ¬øC√≥mo podemos prevenirlo? </p><br><p>  Debemos implementar el finalizador de un objeto.  El 'finalizador' se llama as√≠ a prop√≥sito.  No es un destructor como puede parecer debido a formas similares de llamar a finalizadores en C # y destructores en C ++.  La diferencia es que se llamar√° a un finalizador de <em>todos modos</em> , a diferencia de un destructor (as√≠ como <code>Dispose()</code> ).  Se llama a un finalizador cuando se inicia la recolecci√≥n de basura (ahora es suficiente saber esto, pero las cosas son un poco m√°s complicadas).  Se utiliza para una liberaci√≥n garantizada de recursos si <em>algo sale mal</em> .  Debemos implementar un finalizador para liberar recursos no administrados.  Nuevamente, debido a que se llama a un finalizador cuando se inicia GC, no sabemos cu√°ndo sucede esto en general. </p><br><p>  Expandamos nuestro c√≥digo: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { InternalDispose(); GC.SuppressFinalize(this); } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Mejoramos el ejemplo con el conocimiento sobre el proceso de finalizaci√≥n y aseguramos la aplicaci√≥n contra la p√©rdida de informaci√≥n de recursos si no se llama a Dispose ().  Tambi√©n llamamos GC SuppressFinalize para deshabilitar la finalizaci√≥n de la instancia del tipo si Dispose () se llama con √©xito.  No hay necesidad de liberar el mismo recurso dos veces, ¬øverdad?  Por lo tanto, tambi√©n reducimos la cola de finalizaci√≥n al dejar ir una regi√≥n aleatoria de c√≥digo que probablemente se ejecutar√° con la finalizaci√≥n en paralelo, alg√∫n tiempo despu√©s.  Ahora, mejoremos el ejemplo a√∫n m√°s. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Ahora nuestro ejemplo de un tipo que encapsula un recurso no administrado parece completo.  Desafortunadamente, el segundo <code>Dispose()</code> es de hecho un est√°ndar de la plataforma y permitimos llamarlo.  Tenga en cuenta que las personas a menudo permiten la segunda llamada de <code>Dispose()</code> para evitar problemas con un c√≥digo de llamada y esto es incorrecto.  Sin embargo, un usuario de su biblioteca que mira la documentaci√≥n de MS puede no pensarlo y permitir√° m√∫ltiples llamadas de Dispose ().  Llamar a otros m√©todos p√∫blicos destruir√° la integridad de un objeto de todos modos.  Si destruimos el objeto, ya no podemos trabajar con √©l.  Esto significa que debemos llamar a <code>CheckDisposed</code> al comienzo de cada m√©todo p√∫blico. </p><br><p>  Sin embargo, este c√≥digo contiene un problema grave que impide que funcione como pretend√≠amos.  Si recordamos c√≥mo funciona la recolecci√≥n de basura, notaremos una caracter√≠stica.  Al recolectar basura, GC finaliza <em>principalmente</em> todo lo heredado directamente de <em>Object</em> .  Luego trata con objetos que implementan <em>CriticalFinalizerObject</em> .  Esto se convierte en un problema ya que ambas clases que dise√±amos heredan Object.  No sabemos en qu√© orden llegar√°n a la "√∫ltima milla".  Sin embargo, un objeto de nivel superior puede usar su finalizador para finalizar un objeto con un recurso no administrado.  Aunque, esto no suena como una gran idea.  El orden de finalizaci√≥n ser√≠a muy √∫til aqu√≠.  Para configurarlo, el tipo de nivel inferior con un recurso encapsulado no administrado debe heredarse de <code>CriticalFinalizerObject</code> . </p><br><p>  La segunda raz√≥n es m√°s profunda.  Imagine que se atrevi√≥ a escribir una aplicaci√≥n que no cuida mucho la memoria.  Asigna memoria en grandes cantidades, sin cobrar y otras sutilezas.  Un d√≠a, esta aplicaci√≥n se bloquear√° con OutOfMemoryException.  Cuando ocurre, el c√≥digo se ejecuta espec√≠ficamente.  No puede asignar nada, ya que dar√° lugar a una excepci√≥n repetida, incluso si se detecta la primera.  Esto no significa que no debamos crear nuevas instancias de objetos.  Incluso una llamada de m√©todo simple puede arrojar esta excepci√≥n, por ejemplo, la de finalizaci√≥n.  Le recuerdo que los m√©todos se compilan cuando los llama por primera vez.  Este es un comportamiento habitual.  ¬øC√≥mo podemos prevenir este problema?  Muy facilmente.  Si su objeto se hereda de <em>CriticalFinalizerObject</em> , <em>todos los</em> m√©todos de este tipo se compilar√°n inmediatamente despu√©s de cargarlo en la memoria.  Adem√°s, si marca m√©todos con el atributo <em>[PrePrepareMethod]</em> , tambi√©n se precompilar√°n y ser√° seguro llamarlos en una situaci√≥n de pocos recursos. </p><br><p>  ¬øPor qu√© es eso importante?  ¬øPor qu√© gastar tanto esfuerzo en los que fallecen?  Porque los recursos no administrados pueden suspenderse en un sistema por mucho tiempo.  Incluso despu√©s de reiniciar una computadora.  Si un usuario abre un archivo desde un recurso compartido de archivos en su aplicaci√≥n, el primero ser√° bloqueado por un host remoto y liberado en el tiempo de espera o cuando libera un recurso al cerrar el archivo.  Si su aplicaci√≥n se bloquea cuando se abre el archivo, no se lanzar√° incluso despu√©s de reiniciar.  Tendr√° que esperar mucho hasta que el host remoto lo libere.  Adem√°s, no debe permitir excepciones en finalizadores.  Esto conduce a un bloqueo acelerado del CLR y de una aplicaci√≥n, ya que no puede ajustar la llamada de un finalizador en <em>try ... catch</em> .  Quiero decir, cuando intentas liberar un recurso, debes estar seguro de que se puede liberar.  El √∫ltimo hecho, pero no menos importante: si el CLR descarga un dominio de forma anormal, tambi√©n se llamar√°n los finalizadores de tipos, derivados de <em>CriticalFinalizerObject</em> , a diferencia de los heredados directamente de <em>Object</em> . </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este traductor traducido del ruso como del idioma del autor por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos a crear una versi√≥n traducida de este texto a cualquier otro idioma, incluido el chino o el alem√°n, utilizando las versiones de texto en ruso e ingl√©s como fuente. <br><br>  Adem√°s, si quiere decir "gracias", la mejor manera de elegir es d√°ndonos una estrella en github o bifurcando repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443958/">https://habr.com/ru/post/443958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443948/index.html">Concurso "Soy un Intel Studio Expert" con super premios para desarrolladores</a></li>
<li><a href="../443950/index.html">Conf√≠e, aconseje, sugiera: busque revisiones de software reales</a></li>
<li><a href="../443952/index.html">Internet soberano - por nuestro dinero</a></li>
<li><a href="../443954/index.html">Singularidad tecnol√≥gica: el mito moderno del fin del mundo bajo el pretexto de la hip√≥tesis del progreso</a></li>
<li><a href="../443956/index.html">Red social en 2019: Yandex lanz√≥ Aura</a></li>
<li><a href="../443960/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.2</a></li>
<li><a href="../443962/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.3</a></li>
<li><a href="../443964/index.html">Kolesa Conf es la mayor conferencia de TI en Kazajst√°n. Anuncio de informes</a></li>
<li><a href="../443966/index.html">Google Docs: un chat favorito entre los estudiantes</a></li>
<li><a href="../443968/index.html">C√≥mo compramos una casa con paneles solares, y qu√© sali√≥ de ella</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>