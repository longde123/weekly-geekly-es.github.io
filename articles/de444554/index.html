<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏼 ♓️ 👨🏽‍🤝‍👨🏻 Die einfachste JSON RESTful API unter Elixir 👩🏿‍🔧 ♨️ 👨‍👨‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie implementiere ich einen JSON-API-Endpunkt auf Elixir ohne Frameworks? 


 Vom Übersetzer: 
 Der Artikel enthält ein Beispiel für eine sehr einfach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die einfachste JSON RESTful API unter Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>Wie implementiere ich einen JSON-API-Endpunkt auf Elixir ohne Frameworks?</strong> </p><br><p>  <em>Vom Übersetzer:</em> <em><br></em>  <em>Der Artikel enthält ein Beispiel für eine sehr einfache Webanwendung, die als Hello, World!</em>  <em>beim Erstellen der einfachsten API auf Elixir.</em> <em><br></em>  <em>Der Beispielcode wurde geringfügig geändert, um den aktuellen Versionen der Bibliotheken zu entsprechen.</em> <em><br></em>  <em>Der vollständige Beispielcode mit den Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/vheathen/elixir-">ist auf GitHub</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/vheathen/elixir-">sehen</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Neue sprachliche Herausforderungen </h2><br><p>  Viele Entwickler kommen aus der <strong>Welt von Ruby</strong> zu Elixir <strong>.</strong>  <strong>Dies ist eine sehr ausgereifte Umgebung</strong> in Bezug auf die Anzahl der verfügbaren Bibliotheken und Frameworks.  Und eine solche Reife reicht mir in Elixir manchmal nicht aus.  Wenn ich einen Dienst eines Drittanbieters benötige, kann das Ergebnis einer geeigneten Suche wie folgt aussehen: </p><a name="habracut"></a><br><ul><li>  es gibt eine offizielle, gut unterstützte Bibliothek (sehr selten); </li><li>  Es gibt eine offizielle, aber veraltete oder fehlerhafte Bibliothek (manchmal passiert es). </li><li>  Es gibt eine gut unterstützte Bibliothek, die von jemandem aus der Community entwickelt wurde (manchmal von Zeit zu Zeit). </li><li>  Es gibt eine Bibliothek, die von jemandem aus der Community entwickelt, aber nicht mehr unterstützt wird (ein sehr häufiger Fall). </li><li>  Es gibt mehrere Bibliotheken, von denen jede von jemandem für seine eigenen Bedürfnisse geschrieben wurde, und es fehlen die erforderlichen Funktionen (die beliebteste Option). </li><li>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine eigene</a> Bibliothek, die das Beste aus den oben genannten kombiniert ... (zu oft gefunden). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  Einfache JSON-API unter Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Sie werden vielleicht überrascht sein, aber <strong>Ruby ist nicht immer <em>auf den</em> Schienen</strong> ( <em>Ruby on Rails, erinnerst du dich? - Anmerkung des Übersetzers</em> ).  Die Kommunikation mit dem Internet ist ebenfalls nicht immer erforderlich.  Lassen Sie uns in diesem speziellen Fall über das Web sprechen. </p><br><p>  Bei der Implementierung eines einzelnen RESTful-Endpunkts gibt es normalerweise viele Optionen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rack-App</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Traube</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rails :: API</a> </li></ul><br><p>  Dies sind Beispiele für Tools, die ich persönlich verwendet habe.  Meine Kollegen sind zufriedene Sinatra-Benutzer.  Sie haben es geschafft, Hanami zu versuchen.  Ich kann jede Option wählen, die zu mir passt, auch abhängig von meiner aktuellen Stimmung. </p><br><p>  Aber als ich zu Elixir wechselte, stellte sich heraus, dass die Auswahl begrenzt war.  Obwohl es mehrere alternative „Frameworks“ gibt (deren Namen ich aus offensichtlichen Gründen hier nicht erwähnen werde), ist es fast unmöglich, sie zu verwenden! </p><br><p>  Ich habe den ganzen Tag damit verbracht, jede Bibliothek zu sortieren, die jemals im Internet erwähnt wurde.  Als Slack-Bot habe ich versucht, <strong>einen einfachen HTTP2-Server für Heroku bereitzustellen</strong> , habe mich aber am Ende des Tages ergeben.  Im wahrsten Sinne des Wortes war keine der Optionen, die ich gefunden habe, in der Lage, die grundlegenden Anforderungen umzusetzen. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  Nicht immer eine Lösung - Phoenix </h2><br><p>  <strong>Phoenix ist mein Lieblingswebframework, nur dass es manchmal überflüssig ist.</strong>  Ich wollte es nicht verwenden und das gesamte Framework nur für einen Endpunkt in das Projekt einbeziehen.  und es spielt keine Rolle, dass es sehr einfach ist. </p><br><p>  Ich konnte auch keine vorgefertigten Bibliotheken verwenden, da, wie ich bereits sagte, alle gefundenen Bibliotheken entweder nicht für meine Anforderungen geeignet waren (grundlegendes Routing und JSON-Unterstützung waren erforderlich) oder für eine einfache und schnelle Bereitstellung in Heroku nicht bequem genug waren.  Mach einen Schritt zurück, dachte ich. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Aber tatsächlich ist Phoenix selbst auf der Basis <em>von etwas gebaut</em> , nicht wahr? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Plug &amp; Cowboy kommen zur Rettung </h2><br><p> Wenn Sie auf Ruby einen wirklich minimalistischen Server erstellen müssen, können Sie einfach <code>rack</code> - eine modulare Schnittstelle für Ruby-Webserver. </p><br><p>  Glücklicherweise ist etwas Ähnliches in Elixir verfügbar.  In diesem Fall verwenden wir die folgenden Elemente: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cowboy</a> ist ein kleiner und schneller HTTP-Server für Erlang / OTP, der den vollständigen HTTP-Stack und das Routing implementiert und so optimiert ist, dass Latenz und Speichernutzung minimiert werden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plug</a> - eine Reihe von Adaptern für verschiedene Webserver, die in Erlang VM ausgeführt werden;  Jeder Adapter bietet eine direkte Schnittstelle zum dahinter liegenden Webserver. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gift</a> ist eine Bibliothek zur Verarbeitung von JSON auf Elixir. </li></ul><br><h1 id="realizaciya">  Implementierung </h1><br><p>  Ich möchte Komponenten wie Endpoint (Endpoint), Router (Router) und JSON Parser (JSON-Handler) implementieren.  Dann möchte ich das Ergebnis auf Heroku bereitstellen und eingehende Anfragen verarbeiten können.  Mal sehen, wie dies erreicht werden kann. </p><br><h2 id="prilozhenie">  App </h2><br><p>  Stellen Sie sicher, dass Ihr Elixir-Projekt einen Supervisor enthält.  Erstellen Sie dazu ein Projekt wie folgt: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Stellen Sie sicher, dass mix.exs Folgendes enthält: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  und erstellen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Bibliotheken </h2><br><p>  Die folgenden Bibliotheken müssen in <code>mix.exs</code> angegeben <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Laden Sie dann die Abhängigkeiten herunter und kompilieren Sie sie: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Endpunkt </h2><br><p>  Jetzt ist alles bereit, um einen Einstiegspunkt für den Server zu erstellen.  Erstellen wir eine <code>lib/minimal_server/endpoint.ex</code> Datei mit folgendem Inhalt: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  Das <code>Plug</code> Modul enthält <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Plug.Router</code></a> zum Umleiten eingehender Anforderungen in Abhängigkeit vom verwendeten Pfad und der HTTP-Methode.  Nach Erhalt der Anforderung ruft der Router das Modul <code>:match</code> , dargestellt durch die Funktion <code>match/2</code> , die für das Auffinden der entsprechenden Route verantwortlich ist, und leitet es dann an das Modul <code>:dispatch</code> , das den entsprechenden Code ausführt. </p><br><p>  Da unsere API JSON-kompatibel sein soll, müssen wir <code>Plug.Parsers</code> implementieren.  Da es <code>application/json</code> Anforderungen mit dem angegebenen <code>:json_decoder</code> verarbeitet <code>:json_decoder</code> , werden wir es verwenden, um den Anforderungshauptteil zu analysieren. </p><br><p>  Als Ergebnis haben wir eine temporäre Route "jede Anforderung" erstellt, die allen Anforderungen entspricht und mit nicht gefundenem HTTP-Code (404) antwortet. </p><br><h2 id="marshrutizator">  Router </h2><br><p>  Die Implementierung eines Routers ist der letzte Schritt bei der Erstellung unserer Anwendung.  Dies ist das letzte Element der gesamten Pipeline, die wir erstellt haben: Beginnen Sie mit dem Empfang einer Anfrage von einem Webbrowser und enden Sie mit der Bildung einer Antwort. </p><br><p>  Der Router verarbeitet die eingehende Anforderung vom Client und sendet eine Nachricht im gewünschten Format zurück ( <em>fügen Sie den obigen Code zur Datei <code>lib/minimal_server/router.ex</code> - Anmerkung des Übersetzers hinzu</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  Im obigen <code>Router</code> Modul wird die Anforderung nur verarbeitet, wenn sie von der <code>GET</code> Methode gesendet und entlang der <code>/</code> route gesendet wird.  Das Router-Modul antwortet mit einem <code>Content-Type</code> Header, der <code>application/json</code> und body enthält: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Alles zusammenfügen </h2><br><p>  Jetzt ist es an der Zeit, das <code>Endpoint</code> Modul zu ändern, um Anforderungen an den Router weiterzuleiten und die <code>Application</code> zu ändern, dass das <code>Endpoint</code> Modul selbst gestartet wird. </p><br><p>  Das erste kann durch Hinzufügen zu <code>MinimalServer.Endpoint</code> [ <em>vor der <code>match _ do ... end</code> rule - ca.</em>  <em>Übersetzer</em> ] Zeichenfolge </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Dadurch wird sichergestellt, dass alle Anforderungen an <code>/bot</code> an das <code>Router</code> Modul weitergeleitet und von diesem verarbeitet werden. </p><br><p>  Die zweite kann implementiert werden, indem die Funktionen <code>child_spec/1</code> und <code>start_link/1</code> Datei <code>child_spec/1</code> <code>start_link/1</code> werden: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Jetzt können Sie <code>application.ex</code> ändern, indem Sie <code>MinimalServer.Endpoint</code> zu der von der Funktion <code>children/0</code> Liste hinzufügen. </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Um den Server zu starten, gehen Sie einfach wie folgt vor: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Schließlich können Sie die Adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 4000 / bot</a> besuchen und unsere Nachricht sehen :) </p><br><h1 id="razvertyvanie">  Bereitstellung </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Konfig </h2><br><p>  In einer lokalen Umgebung und für den Betrieb ist der Server meistens anders konfiguriert.  Daher müssen wir für jeden dieser Modi separate Einstellungen vornehmen.  <code>config.exs</code> unsere <code>config.exs</code> indem Sie <code>config.exs</code> hinzufügen: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  In diesem Fall erhält die Anwendung beim Start im <code>test</code> , <code>prod</code> und <code>dev</code> Modus Port 4000, wenn diese Einstellungen nicht geändert werden. </p><br><div class="spoiler">  <b class="spoiler_title">Vom Übersetzer</b> <div class="spoiler_text"><p>  Zu diesem Zeitpunkt hat der Autor des Originaltextes vergessen zu erwähnen, wie config.exs so geändert werden kann, dass Sie verschiedene Optionen für verschiedene Modi verwenden können.  <code>import_config "#{Mix.env()}.exs"</code> Sie dazu <code>import_config "#{Mix.env()}.exs"</code> ; in der letzten Zeile in <code>config/config.exs</code> ;  Das Ergebnis ist so etwas wie: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Erstellen Sie anschließend die Dateien <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> im <code>config</code> indem Sie sie in jede Zeile <code>dev.exs</code> : </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  In der Produktion möchten wir die Portnummer normalerweise nicht fest einstellen, sondern uns auf eine Systemumgebungsvariable stützen, zum Beispiel: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>Fügen Sie den obigen Text am Ende von <code>config/prod.exs</code> - ca.</em>  <em>Übersetzer</em> </p><br><p>  Danach wird lokal ein fester Wert und im betrieblichen Betrieb eine Konfiguration von Umgebungsvariablen verwendet. </p><br><p>  Implementieren wir dieses Schema in <em>endpoint.ex</em> ( <em>ersetzen der Funktion start_link / 1 - Übersetzerkommentar</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku bietet die einfachste Ein-Klick-Bereitstellung ohne komplizierte Einrichtung.  Um unser Projekt <strong>bereitzustellen, müssen Sie einige einfache Dateien vorbereiten und eine Remote-Anwendung erstellen</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installation von Heroku CLI können</a> Sie eine neue Anwendung wie folgt erstellen: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating ⬢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  Fügen Sie nun das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elixir Build Kit</a> zu Ihrer Anwendung hinzu: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  Zum Zeitpunkt dieser Übersetzung sind die aktuellen Versionen von Elixir und Erlang (plus oder minus): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Um das Build Kit selbst zu konfigurieren, fügen Sie die obigen Zeilen zur Datei <code>elixir_buildpack.config</code> . </p><br><p>  Der letzte Schritt besteht darin, ein Procfile zu erstellen. Auch dies ist sehr einfach: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Anmerkung des Übersetzers: Um einen Fehler beim Erstellen von Heroku zu vermeiden, müssen Sie den Wert der Umgebungsvariablen festlegen, die in der Anwendung verwendet werden:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting ⬢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  Sobald Sie neue Dateien <em>festschreiben</em> [ <em>mit git - ca.</em>  <em>Übersetzer</em> ], können Sie sie auf Heroku hochladen: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  Und das ist alles!  Die Anwendung ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://minimal-server-habr.herokuapp.com</a> verfügbar. </p><br><h1 id="rezyume">  Zusammenfassung </h1><br><p>  Zu diesem Zeitpunkt haben Sie bereits verstanden, wie Sie <strong>die einfachste JSON RESTful-API und den einfachsten HTTP-Server in Elixir implementieren,</strong> ohne Frameworks zu verwenden, und nur 3 ( <em>ca. 4 - ca. Übersetzer</em> ) Bibliotheken verwenden. </p><br><p>  Wenn Sie Zugriff auf einfache Endpunkte gewähren müssen, müssen Sie Phoenix nicht jedes Mal verwenden, egal wie cool es ist, genau wie jedes andere Framework. </p><br><p>  Neugierig, warum es zwischen <code>plug</code> + <code>cowboy</code> und Phoenix keine zuverlässigen, gut getesteten und unterstützten Frameworks gibt?  Vielleicht besteht keine wirkliche Notwendigkeit, einfache Dinge zu implementieren?  Vielleicht nutzt jedes Unternehmen seine eigene Bibliothek?  Oder verwendet jeder entweder Phoenix oder den vorgestellten Ansatz? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/KamilLelonek/elixir-">Das Repository</a> ist wie immer auf meinem GitHub verfügbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444554/">https://habr.com/ru/post/de444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444544/index.html">Etwas über verteilte Rechenzentren für Unternehmen</a></li>
<li><a href="../de444546/index.html">Wie und warum langsamer arbeiten? Die Methode von Sergey Korolev</a></li>
<li><a href="../de444548/index.html">Persönliche Erfahrung: Wie wir uns in Lateinamerika für die Förderung hispanischer Startups engagiert haben</a></li>
<li><a href="../de444550/index.html">Zur Frage der Teilung</a></li>
<li><a href="../de444552/index.html">TDMS Fairway. Arbeiten Sie mit Fachwissen</a></li>
<li><a href="../de444556/index.html">Die Farbe des Mondes und der Sonne aus dem Weltraum in den Werten von RGB und Farbtemperatur</a></li>
<li><a href="../de444558/index.html">Was ist neu in CUBA 7?</a></li>
<li><a href="../de444560/index.html">Wir laden Sie zur Konferenz „Clouds. Modetrends ”26. März 2019</a></li>
<li><a href="../de444562/index.html">Modernisierung von GHIDRA. Lader für Rum Sega Mega Drive</a></li>
<li><a href="../de444564/index.html">Digitale Produktentwicklung mit mentalen Modellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>