<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèº ‚ôìÔ∏è üë®üèΩ‚Äçü§ù‚Äçüë®üèª Die einfachste JSON RESTful API unter Elixir üë©üèø‚Äçüîß ‚ô®Ô∏è üë®‚Äçüë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie implementiere ich einen JSON-API-Endpunkt auf Elixir ohne Frameworks? 


 Vom √úbersetzer: 
 Der Artikel enth√§lt ein Beispiel f√ºr eine sehr einfach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die einfachste JSON RESTful API unter Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>Wie implementiere ich einen JSON-API-Endpunkt auf Elixir ohne Frameworks?</strong> </p><br><p>  <em>Vom √úbersetzer:</em> <em><br></em>  <em>Der Artikel enth√§lt ein Beispiel f√ºr eine sehr einfache Webanwendung, die als Hello, World!</em>  <em>beim Erstellen der einfachsten API auf Elixir.</em> <em><br></em>  <em>Der Beispielcode wurde geringf√ºgig ge√§ndert, um den aktuellen Versionen der Bibliotheken zu entsprechen.</em> <em><br></em>  <em>Der vollst√§ndige Beispielcode mit den √Ñnderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/vheathen/elixir-">ist auf GitHub</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/vheathen/elixir-">sehen</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Neue sprachliche Herausforderungen </h2><br><p>  Viele Entwickler kommen aus der <strong>Welt von Ruby</strong> zu Elixir <strong>.</strong>  <strong>Dies ist eine sehr ausgereifte Umgebung</strong> in Bezug auf die Anzahl der verf√ºgbaren Bibliotheken und Frameworks.  Und eine solche Reife reicht mir in Elixir manchmal nicht aus.  Wenn ich einen Dienst eines Drittanbieters ben√∂tige, kann das Ergebnis einer geeigneten Suche wie folgt aussehen: </p><a name="habracut"></a><br><ul><li>  es gibt eine offizielle, gut unterst√ºtzte Bibliothek (sehr selten); </li><li>  Es gibt eine offizielle, aber veraltete oder fehlerhafte Bibliothek (manchmal passiert es). </li><li>  Es gibt eine gut unterst√ºtzte Bibliothek, die von jemandem aus der Community entwickelt wurde (manchmal von Zeit zu Zeit). </li><li>  Es gibt eine Bibliothek, die von jemandem aus der Community entwickelt, aber nicht mehr unterst√ºtzt wird (ein sehr h√§ufiger Fall). </li><li>  Es gibt mehrere Bibliotheken, von denen jede von jemandem f√ºr seine eigenen Bed√ºrfnisse geschrieben wurde, und es fehlen die erforderlichen Funktionen (die beliebteste Option). </li><li>  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine eigene</a> Bibliothek, die das Beste aus den oben genannten kombiniert ... (zu oft gefunden). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  Einfache JSON-API unter Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Sie werden vielleicht √ºberrascht sein, aber <strong>Ruby ist nicht immer <em>auf den</em> Schienen</strong> ( <em>Ruby on Rails, erinnerst du dich? - Anmerkung des √úbersetzers</em> ).  Die Kommunikation mit dem Internet ist ebenfalls nicht immer erforderlich.  Lassen Sie uns in diesem speziellen Fall √ºber das Web sprechen. </p><br><p>  Bei der Implementierung eines einzelnen RESTful-Endpunkts gibt es normalerweise viele Optionen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rack-App</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Traube</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rails :: API</a> </li></ul><br><p>  Dies sind Beispiele f√ºr Tools, die ich pers√∂nlich verwendet habe.  Meine Kollegen sind zufriedene Sinatra-Benutzer.  Sie haben es geschafft, Hanami zu versuchen.  Ich kann jede Option w√§hlen, die zu mir passt, auch abh√§ngig von meiner aktuellen Stimmung. </p><br><p>  Aber als ich zu Elixir wechselte, stellte sich heraus, dass die Auswahl begrenzt war.  Obwohl es mehrere alternative ‚ÄûFrameworks‚Äú gibt (deren Namen ich aus offensichtlichen Gr√ºnden hier nicht erw√§hnen werde), ist es fast unm√∂glich, sie zu verwenden! </p><br><p>  Ich habe den ganzen Tag damit verbracht, jede Bibliothek zu sortieren, die jemals im Internet erw√§hnt wurde.  Als Slack-Bot habe ich versucht, <strong>einen einfachen HTTP2-Server f√ºr Heroku bereitzustellen</strong> , habe mich aber am Ende des Tages ergeben.  Im wahrsten Sinne des Wortes war keine der Optionen, die ich gefunden habe, in der Lage, die grundlegenden Anforderungen umzusetzen. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  Nicht immer eine L√∂sung - Phoenix </h2><br><p>  <strong>Phoenix ist mein Lieblingswebframework, nur dass es manchmal √ºberfl√ºssig ist.</strong>  Ich wollte es nicht verwenden und das gesamte Framework nur f√ºr einen Endpunkt in das Projekt einbeziehen.  und es spielt keine Rolle, dass es sehr einfach ist. </p><br><p>  Ich konnte auch keine vorgefertigten Bibliotheken verwenden, da, wie ich bereits sagte, alle gefundenen Bibliotheken entweder nicht f√ºr meine Anforderungen geeignet waren (grundlegendes Routing und JSON-Unterst√ºtzung waren erforderlich) oder f√ºr eine einfache und schnelle Bereitstellung in Heroku nicht bequem genug waren.  Mach einen Schritt zur√ºck, dachte ich. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Aber tats√§chlich ist Phoenix selbst auf der Basis <em>von etwas gebaut</em> , nicht wahr? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Plug &amp; Cowboy kommen zur Rettung </h2><br><p> Wenn Sie auf Ruby einen wirklich minimalistischen Server erstellen m√ºssen, k√∂nnen Sie einfach <code>rack</code> - eine modulare Schnittstelle f√ºr Ruby-Webserver. </p><br><p>  Gl√ºcklicherweise ist etwas √Ñhnliches in Elixir verf√ºgbar.  In diesem Fall verwenden wir die folgenden Elemente: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cowboy</a> ist ein kleiner und schneller HTTP-Server f√ºr Erlang / OTP, der den vollst√§ndigen HTTP-Stack und das Routing implementiert und so optimiert ist, dass Latenz und Speichernutzung minimiert werden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plug</a> - eine Reihe von Adaptern f√ºr verschiedene Webserver, die in Erlang VM ausgef√ºhrt werden;  Jeder Adapter bietet eine direkte Schnittstelle zum dahinter liegenden Webserver. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gift</a> ist eine Bibliothek zur Verarbeitung von JSON auf Elixir. </li></ul><br><h1 id="realizaciya">  Implementierung </h1><br><p>  Ich m√∂chte Komponenten wie Endpoint (Endpoint), Router (Router) und JSON Parser (JSON-Handler) implementieren.  Dann m√∂chte ich das Ergebnis auf Heroku bereitstellen und eingehende Anfragen verarbeiten k√∂nnen.  Mal sehen, wie dies erreicht werden kann. </p><br><h2 id="prilozhenie">  App </h2><br><p>  Stellen Sie sicher, dass Ihr Elixir-Projekt einen Supervisor enth√§lt.  Erstellen Sie dazu ein Projekt wie folgt: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Stellen Sie sicher, dass mix.exs Folgendes enth√§lt: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  und erstellen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Bibliotheken </h2><br><p>  Die folgenden Bibliotheken m√ºssen in <code>mix.exs</code> angegeben <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Laden Sie dann die Abh√§ngigkeiten herunter und kompilieren Sie sie: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Endpunkt </h2><br><p>  Jetzt ist alles bereit, um einen Einstiegspunkt f√ºr den Server zu erstellen.  Erstellen wir eine <code>lib/minimal_server/endpoint.ex</code> Datei mit folgendem Inhalt: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  Das <code>Plug</code> Modul enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Plug.Router</code></a> zum Umleiten eingehender Anforderungen in Abh√§ngigkeit vom verwendeten Pfad und der HTTP-Methode.  Nach Erhalt der Anforderung ruft der Router das Modul <code>:match</code> , dargestellt durch die Funktion <code>match/2</code> , die f√ºr das Auffinden der entsprechenden Route verantwortlich ist, und leitet es dann an das Modul <code>:dispatch</code> , das den entsprechenden Code ausf√ºhrt. </p><br><p>  Da unsere API JSON-kompatibel sein soll, m√ºssen wir <code>Plug.Parsers</code> implementieren.  Da es <code>application/json</code> Anforderungen mit dem angegebenen <code>:json_decoder</code> verarbeitet <code>:json_decoder</code> , werden wir es verwenden, um den Anforderungshauptteil zu analysieren. </p><br><p>  Als Ergebnis haben wir eine tempor√§re Route "jede Anforderung" erstellt, die allen Anforderungen entspricht und mit nicht gefundenem HTTP-Code (404) antwortet. </p><br><h2 id="marshrutizator">  Router </h2><br><p>  Die Implementierung eines Routers ist der letzte Schritt bei der Erstellung unserer Anwendung.  Dies ist das letzte Element der gesamten Pipeline, die wir erstellt haben: Beginnen Sie mit dem Empfang einer Anfrage von einem Webbrowser und enden Sie mit der Bildung einer Antwort. </p><br><p>  Der Router verarbeitet die eingehende Anforderung vom Client und sendet eine Nachricht im gew√ºnschten Format zur√ºck ( <em>f√ºgen Sie den obigen Code zur Datei <code>lib/minimal_server/router.ex</code> - Anmerkung des √úbersetzers hinzu</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  Im obigen <code>Router</code> Modul wird die Anforderung nur verarbeitet, wenn sie von der <code>GET</code> Methode gesendet und entlang der <code>/</code> route gesendet wird.  Das Router-Modul antwortet mit einem <code>Content-Type</code> Header, der <code>application/json</code> und body enth√§lt: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Alles zusammenf√ºgen </h2><br><p>  Jetzt ist es an der Zeit, das <code>Endpoint</code> Modul zu √§ndern, um Anforderungen an den Router weiterzuleiten und die <code>Application</code> zu √§ndern, dass das <code>Endpoint</code> Modul selbst gestartet wird. </p><br><p>  Das erste kann durch Hinzuf√ºgen zu <code>MinimalServer.Endpoint</code> [ <em>vor der <code>match _ do ... end</code> rule - ca.</em>  <em>√úbersetzer</em> ] Zeichenfolge </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Dadurch wird sichergestellt, dass alle Anforderungen an <code>/bot</code> an das <code>Router</code> Modul weitergeleitet und von diesem verarbeitet werden. </p><br><p>  Die zweite kann implementiert werden, indem die Funktionen <code>child_spec/1</code> und <code>start_link/1</code> Datei <code>child_spec/1</code> <code>start_link/1</code> werden: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Jetzt k√∂nnen Sie <code>application.ex</code> √§ndern, indem Sie <code>MinimalServer.Endpoint</code> zu der von der Funktion <code>children/0</code> Liste hinzuf√ºgen. </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Um den Server zu starten, gehen Sie einfach wie folgt vor: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Schlie√ülich k√∂nnen Sie die Adresse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http: // localhost: 4000 / bot</a> besuchen und unsere Nachricht sehen :) </p><br><h1 id="razvertyvanie">  Bereitstellung </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Konfig </h2><br><p>  In einer lokalen Umgebung und f√ºr den Betrieb ist der Server meistens anders konfiguriert.  Daher m√ºssen wir f√ºr jeden dieser Modi separate Einstellungen vornehmen.  <code>config.exs</code> unsere <code>config.exs</code> indem Sie <code>config.exs</code> hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  In diesem Fall erh√§lt die Anwendung beim Start im <code>test</code> , <code>prod</code> und <code>dev</code> Modus Port 4000, wenn diese Einstellungen nicht ge√§ndert werden. </p><br><div class="spoiler">  <b class="spoiler_title">Vom √úbersetzer</b> <div class="spoiler_text"><p>  Zu diesem Zeitpunkt hat der Autor des Originaltextes vergessen zu erw√§hnen, wie config.exs so ge√§ndert werden kann, dass Sie verschiedene Optionen f√ºr verschiedene Modi verwenden k√∂nnen.  <code>import_config "#{Mix.env()}.exs"</code> Sie dazu <code>import_config "#{Mix.env()}.exs"</code> ; in der letzten Zeile in <code>config/config.exs</code> ;  Das Ergebnis ist so etwas wie: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Erstellen Sie anschlie√üend die Dateien <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> im <code>config</code> indem Sie sie in jede Zeile <code>dev.exs</code> : </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  In der Produktion m√∂chten wir die Portnummer normalerweise nicht fest einstellen, sondern uns auf eine Systemumgebungsvariable st√ºtzen, zum Beispiel: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>F√ºgen Sie den obigen Text am Ende von <code>config/prod.exs</code> - ca.</em>  <em>√úbersetzer</em> </p><br><p>  Danach wird lokal ein fester Wert und im betrieblichen Betrieb eine Konfiguration von Umgebungsvariablen verwendet. </p><br><p>  Implementieren wir dieses Schema in <em>endpoint.ex</em> ( <em>ersetzen der Funktion start_link / 1 - √úbersetzerkommentar</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku bietet die einfachste Ein-Klick-Bereitstellung ohne komplizierte Einrichtung.  Um unser Projekt <strong>bereitzustellen, m√ºssen Sie einige einfache Dateien vorbereiten und eine Remote-Anwendung erstellen</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installation von Heroku CLI k√∂nnen</a> Sie eine neue Anwendung wie folgt erstellen: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating ‚¨¢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  F√ºgen Sie nun das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elixir Build Kit</a> zu Ihrer Anwendung hinzu: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  Zum Zeitpunkt dieser √úbersetzung sind die aktuellen Versionen von Elixir und Erlang (plus oder minus): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Um das Build Kit selbst zu konfigurieren, f√ºgen Sie die obigen Zeilen zur Datei <code>elixir_buildpack.config</code> . </p><br><p>  Der letzte Schritt besteht darin, ein Procfile zu erstellen. Auch dies ist sehr einfach: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Anmerkung des √úbersetzers: Um einen Fehler beim Erstellen von Heroku zu vermeiden, m√ºssen Sie den Wert der Umgebungsvariablen festlegen, die in der Anwendung verwendet werden:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting ‚¨¢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  Sobald Sie neue Dateien <em>festschreiben</em> [ <em>mit git - ca.</em>  <em>√úbersetzer</em> ], k√∂nnen Sie sie auf Heroku hochladen: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  Und das ist alles!  Die Anwendung ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://minimal-server-habr.herokuapp.com</a> verf√ºgbar. </p><br><h1 id="rezyume">  Zusammenfassung </h1><br><p>  Zu diesem Zeitpunkt haben Sie bereits verstanden, wie Sie <strong>die einfachste JSON RESTful-API und den einfachsten HTTP-Server in Elixir implementieren,</strong> ohne Frameworks zu verwenden, und nur 3 ( <em>ca. 4 - ca. √úbersetzer</em> ) Bibliotheken verwenden. </p><br><p>  Wenn Sie Zugriff auf einfache Endpunkte gew√§hren m√ºssen, m√ºssen Sie Phoenix nicht jedes Mal verwenden, egal wie cool es ist, genau wie jedes andere Framework. </p><br><p>  Neugierig, warum es zwischen <code>plug</code> + <code>cowboy</code> und Phoenix keine zuverl√§ssigen, gut getesteten und unterst√ºtzten Frameworks gibt?  Vielleicht besteht keine wirkliche Notwendigkeit, einfache Dinge zu implementieren?  Vielleicht nutzt jedes Unternehmen seine eigene Bibliothek?  Oder verwendet jeder entweder Phoenix oder den vorgestellten Ansatz? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/KamilLelonek/elixir-">Das Repository</a> ist wie immer auf meinem GitHub verf√ºgbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444554/">https://habr.com/ru/post/de444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444544/index.html">Etwas √ºber verteilte Rechenzentren f√ºr Unternehmen</a></li>
<li><a href="../de444546/index.html">Wie und warum langsamer arbeiten? Die Methode von Sergey Korolev</a></li>
<li><a href="../de444548/index.html">Pers√∂nliche Erfahrung: Wie wir uns in Lateinamerika f√ºr die F√∂rderung hispanischer Startups engagiert haben</a></li>
<li><a href="../de444550/index.html">Zur Frage der Teilung</a></li>
<li><a href="../de444552/index.html">TDMS Fairway. Arbeiten Sie mit Fachwissen</a></li>
<li><a href="../de444556/index.html">Die Farbe des Mondes und der Sonne aus dem Weltraum in den Werten von RGB und Farbtemperatur</a></li>
<li><a href="../de444558/index.html">Was ist neu in CUBA 7?</a></li>
<li><a href="../de444560/index.html">Wir laden Sie zur Konferenz ‚ÄûClouds. Modetrends ‚Äù26. M√§rz 2019</a></li>
<li><a href="../de444562/index.html">Modernisierung von GHIDRA. Lader f√ºr Rum Sega Mega Drive</a></li>
<li><a href="../de444564/index.html">Digitale Produktentwicklung mit mentalen Modellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>