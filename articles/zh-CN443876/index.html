<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😷 😏 🤜🏽 我们正在开发一种Telegram机器人，用于在NodeJS和TypeScript上跟踪电影 📡 ☂️ 🚣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="碰巧，您是在电影开始之前来电影院看预告片的，而其中一些人却非常执着地坚持着，如果没有在电影院看电影，那么您将向自己保证要看这部电影，至少在以后，当电影可供下载时， ？ 我敢建议是的。 但通常最终会导致您成功忘记它，并且在最佳情况下，通过滚动浏览已经发行的电影列表来偶然找到这部电影。 

 我经常遇到...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们正在开发一种Telegram机器人，用于在NodeJS和TypeScript上跟踪电影</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443876/"><img src="https://habrastorage.org/webt/k8/du/50/k8du50aoufwmy7qczw9n6opy2mq.png"><br><br> 碰巧，您是在电影开始之前来电影院看预告片的，而其中一些人却非常执着地坚持着，如果没有在电影院看电影，那么您将向自己保证要看这部电影，至少在以后，当电影可供下载时， ？ 我敢建议是的。 但通常最终会导致您成功忘记它，并且在最佳情况下，通过滚动浏览已经发行的电影列表来偶然找到这部电影。 <br><br> 我经常遇到这样的问题，因此决定用Eve-Telegram-bot创建它，这有助于我避免忘记自己喜欢的电影的发行。 它是什么，它是如何工作的以及它是如何开发的，您可以直接阅读！ <br><a name="habracut"></a><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前言</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">怎么了</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">技术选择</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Telegraf.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目结构</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始化和启动</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理用户输入</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本地化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><a name="foreword"></a><h3> 前言 </h3><br> 本文不是有关创建Telegram机器人的详细指南。 尽管在本文中我经常提到我的项目，但是该材料的目的是关于总体发展的故事，即我所遇到的技术选择，关键点和陷阱。 <br><a name="why"></a><br><h3> 怎么了 </h3><br> 因此，正如我在上面所写，我经常忘记看那些我喜欢预告片的电影。 我一直在考虑解决此问题的时间很长。 我想到的第一件事是为智能手机创建了本机应用程序，但是 我以前从未做过，这将花费很多时间，而最终结果却无法满足我的需求以及潜在用户的需求。 <br><br> 下一个想法是创建PWA。 为了熟悉该技术，这是一个非常有趣的选择，但我决定将其留给未来。 同时，我已经使用Telegram很长时间了，在这段时间里，我积累了足够数量的机器人，这些机器人会定期使我的生活更轻松一些。 最终，在权衡了所有利弊之后，我决定该平台非常适合该想法。 <br><a name="technologies"></a><br><h3> 技术选择 </h3><br> 如果您浏览了Github for Telegram机器人，您会发现其中大多数都是用Python编写的。  Python确实是一种很棒的语言，并且非常适合这个想法，但是我想专门在NodeJS + TypeScript上实现这个项目。 应用适当的过滤器，我遇到了两个非常流行的工具： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">node-telegram-bot-api</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Telegraf.js</a> 。 <br><br> 在我没有开发机器人的经验之前，因此从这两种机器人中进行选择时，尚不清楚应该考虑哪些参数。 结果，在查看了文档并研究了每个库的问题之后，我选择了Telegraf.js。 决定性因素是中间件的可用性，该中间件的设计方式与流行的Express.js框架相同。  Telegraf.js还具有更频繁的更新历史记录和结构良好的文档，这表明开发人员正在投入足够的精力来改进该工具。 此外，它还包含TypeScript的小费，这对于所选堆栈肯定是一个加号。 <br><a name="telegraf"></a><br><h3>  Telegraf.js </h3><br>  Telegraf.js是编写项目的主要库。 它使用了几种有趣的方法，使您可以创建复杂的机器人，同时保持代码的简单性。 以下是最有趣的机制： <br><br><ul><li>  <b>中间件</b> -是的，这些是Express.js中可用的相同中间件。 当用户向机器人发送东西时，该消息首先通过所有已注册的中间件，然后到达控制器。 中间件可以修改上下文，以及中止请求的执行，例如，如果普通用户试图进入管理员区域。  Telegraf.js提供了一些非常有用的中间件，但您也可以自己使用它们。 即中间件被认为是Telegraf.js的杀手级功能 </li><li>  <b>会话</b> -可以存储未绑定到控制器的信息的会话。 您可以类比全局变量，该变量可以从bot的任何位置访问。 一个非常方便的东西，例如用于本地化。 可以以不同的模式存储会话-DB，Redis，本地文件等。 </li><li>  <b>Webooks-</b>机器人可以在两种模式下工作- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">长轮询</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Webhooks</a> 。 而且，尽管它们的工作速度相当快，但最好在生产环境中使用第二种选择。 因此，僵尸程序无需敲击Telegram服务器，而是自己接收所有更新。 <br><br>  <b>重要提示：</b> Webhooks <b>的</b>前提条件是必须支持SSL / TLS服务器。 还要确保运行Webhook的端口是开放的，并且可以从外部访问。 </li><li>  <b>标记</b> -通过该课程，您可以教机器人在标记/标记降级标记中做出响应。 例如，在制作HTML游戏时，这一点很重要。 但是，在我的项目中，我仅将其用于粗体/斜体文本。 </li><li>  <b>阶段</b>是一个非常有趣的模块，它帮助我保持了紧张和一些小时的发展。 在这里，我将详细介绍。 <br> 僵尸程序可以侦听来自用户的消息，并根据消息的类型或内容将其重定向到一个或另一个控制器，该控制器将执行其功能并将响应发送给用户。 看起来像这样： <br><br><pre><code class="javascript hljs">bot.hears(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ctx =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ctx.reply(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); });</code> </pre> <br> 它的工作原理很简单：如果您向机器人打招呼，它只会回答Hello！ 了解了这方面的工作之后，让我们尝试想象一下该机器人如何工作以搜索电影： <br><br><ol><li> 用户写道，他想去寻找电影。 </li><li> 用户驱动电影的名称； </li><li> 机器人会返回电影列表，并提示用户将所选电影保存到他的资料库中； </li><li>  ... </li></ol><br> 注意，有问题！ 当用户写信给他他想开始看电影时，以及当他写要搜索的电影名时，机器人如何区分？ <br><br>  <i>是的，您可以将任何发送的文本作为电影的名称，但是我们希望使带有<s>二十一点和妓女</s>的机器人<s>成为一个</s>很好的界面。</i> <br><br> 在这里，场景（舞台）开始发挥作用！ 通过上面的示例将最容易分辨。 当用户说他想去寻找电影时，我们启动了场景。 在此场景中，有单独的文本处理程序-bot.hears（...）。 因此，所有后续消息将直接与电影搜索有关，直到用户编写一条消息退出并离开场景为止。 之后，将停用该场景内的处理程序，直到用户再次返回该场景为止。 接下来，我将描述如何使用场景使事件处理尽可能简单。 <br></li></ul><br><a name="structure"></a><br><h3> 项目结构 </h3><br> 有人怀疑这篇文章篇幅太长，因此，为了不进一步延伸，我将省略一些要点。 例如，要使机器人开始工作，您需要首先获取Telegram Bot API令牌。 您可以在正式的Telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>或Telegraf.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>阅读有关如何执行此操作的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 <br><br> 该项目的文件结构如下： <br><br><div class="spoiler">  <b class="spoiler_title">项目结构</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/44/ps/n8/44psn8gqdploz320kpoh0yzmwxg.png"><br></div></div><br> 其工作方式如下： <br><br><ul><li>  <b>src / controllers-</b>这些是上面编写该脚本的场景。 在该项目中，每个场景都是一个单独的控制器，用于处理相应的请求。 </li><li>  <b>src / locales-</b>不同语言的翻译。  Telegraf.js使使用中间件向机器人添加本地化变得相对容易。 </li><li>  <b>src / models</b> -MongoDB的模型。 </li><li>  <b>src / types</b> -TypeScript的小费。 不幸的是，并非项目中使用的所有库都具有默认时间。 </li><li>  <b>src / util-</b>在项目的不同部分中使用的各种帮助程序功能。 在这里，您可以看到电影的下载，会话管理，创建键盘，错误处理程序以及更多功能的可用性。 </li><li>  <b>src / bot.ts-</b>完成bot的所有准备和启动的主文件。 </li><li>  <b>src / telegram.ts-</b>在这种情况下，我们从Telegraf.js库创建Telegram类的对象。 使用此对象，我们可以首先使用用户的ID向用户发送消息，而不必等到他们写东西。 例如，在这个项目中，我们向用户发送一条消息，指出他所关注的电影已经可以下载。 当然，该对象提供了更多功能。 </li><li>  <b>其他所有内容</b>都是项目不同部分的配置，本文将不再讨论。 </li></ul><br><a name="start"></a><h3> 初始化和启动 </h3><br> 当我们弄清项目的结构时，让我们看看机器人是如何启动的。 同样，为了缩短本文的篇幅，我不会在此处插入整个代码，而在我看来，仅会讨论主要的时刻。 您可以在存储库中看到完整的代码，本文结尾处提供了指向该链接的链接。 <br><br> 这一切都始于连接到数据库，该数据库存储有关用户及其跟踪的电影的信息。 成功建立连接后，我们将注册项目中使用的所有场景，设置用于本地化的参数，并添加多个中间件-处理会话，本地化，设置场景以及我们自己的几个。 例如，其中之一根据其ID接收有关用户的所有信息，并将其添加到控制器中使用的上下文中。 最后，在完成所有基本准备工作之后，我们以开发（长期轮询）或生产（Webhooks）模式启动该机器人。 <br><br>  <b>重要提示：</b>如果您使用不同的方法来接收更新（长时间轮询和Webhooks），则在长时间轮询模式下启动bot时，请首先使用api.telegram.org/botYOUR_TOKEN/deleteWebhook上的GET请求删除监听的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Webhook</a> 。 否则，机器人可能无法正常工作。 <br><a name="userinput"></a><br><h3> 处理用户输入 </h3><br> 万岁！ 该机器人可以工作，已连接到数据库，并已准备好接收来自用户的消息。 但是怎么做对呢？ <br><br> 首先，使用内置的电报键盘将为用户带来方便。 实际上，当您单击此键盘上的按钮时，将发送包含这些按钮内容的消息。 接下来，我们仅为此文本添加处理程序并执行某些操作。 <br><br>  <a href="">bot.ts</a>文件<a href="">包含</a>此类处理程序。 由于漫游器支持两种语言，因此按钮也可能包含不同的文本-俄语和英语。  Telegraf-i18n具有匹配功能，可以处理不同语言的相同按钮的单击。 <br><br>  bot.ts中的大多数处理程序执行单个功能-它们将用户启动到相应的场景中。 因此，我们有几个部分-搜索电影，我的收藏，设置和联系人。 每个部分都有自己的场景和按钮，单击时，用户将移至相应的场景。 <br><br>  <b>重要提示：请</b>确保添加一个处理程序，该处理程序会将用户从场景中释放出来，否则他们可能会永远呆在那里！ 发出一个通用命令（机器人中使用/ saveme）也将很有用，该命令将被添加到每个场景和主文件中。 此命令将用作任何场景的退出，以及重置用户设置。 <br><br> 现在，用户想去寻找电影。 通过单击适当的按钮，我们将其移至搜索场景。 为了方便起见，每个场景都有自己的文件夹，其中包含文件，每个文件执行特定功能。 <br><br> 在场景内部，您可以使用Middlewares.ts文件中的中间件。 例如，在搜索场景中使用中间件，我们可以简单地将有关电影的所有信息转发到适当的方法中，而不是每次在它们内部执行相同的功能。 <br><br>  Telegram还具有嵌入式键盘。 也许您遇到了带有投票的消息，在该消息的下面有几个半透明的按钮，当您单击其中一个时，投票数会发生变化。 这些按钮是嵌入式键盘 <br><br><div class="spoiler">  <b class="spoiler_title">夏娃就是这样</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gz/sn/-n/gzsn-nvolazzilaylnhy-ugacny.png"><br></div></div><br> 每个按钮都包含信息，当您单击该按钮时，它将被传输到相应的处理程序。  <b>传输信息的大小不应超过64个字节！</b> 要教机器人监听按钮点击，我们需要使用bot.action（/触发器/，回调）进行注册。 第一个参数包含绑定到按钮的所有数据。 我决定使用Redux之类的Actions，将{a：actionName，p：payload}形式的对象附加到每个按钮。 注册侦听器时，我们可以使用简单的RegExp，例如：bot.action（/ actionName /，callBack）。 嵌入式键盘的所有处理程序都在actions.ts文件中。 <br><br> 另外，在某些场景中有helpers.ts文件，其中包含一些为了卸载其余文件而带出的小功能。 在大多数情况下，都有用于用户进行各种操作的键盘生成器。 <br><a name="localization"></a><br><h3> 本地化 </h3><br> 既然这是一个重要的话题，我认为值得一提。 如我之前所说，Telegraf.js包含大量中间件，其中之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">telegraf-i18n</a> 。 该存储库包含详细说明，我对此没有任何特殊问题，但是尽管如此，我还是会在此项目中添加一些说明。 <br><br> 有一个用于本地化文件的locales文件夹，它是{{key“：” translation“}形式的JSON对象。 此外，无论何时需要使用不同的语言，我们都会使用该库中的方法，在此方法中，通过密钥传输所需的翻译，然后在输出中获得相应的翻译。 会话可用于存储有关用户选择的语言的信息。 同样值得一提的是按钮。 同一库中有一个match函数，因此，如果按钮上的文本根据语言而变化，此函数将帮助您挂起正确的侦听器。 <br><br>  <b>重要提示：</b>如果要使用本地化并用TypeScript编写漫游器，请不要忘记将翻译文件夹添加到tsconfig.json中，否则代码将无法编译。 例如： <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"include"</span></span>: [<span class="hljs-string"><span class="hljs-string">"src/locales/*.json"</span></span>]</code> </pre> <br><a name="conclusion"></a><h3> 结论 </h3><br> 感谢您阅读到底！ 在本文中，我试图尽可能详细地描述创建Telegram bot的过程，而没有对我的项目有强烈的依附。 我希望阅读本文并研究Eve的源代码后，您可以轻松创建一个可以为您提供帮助的机器人。 <br><br> 按照承诺，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>查看源代码，并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>尝试Eve的实际应用。 如有任何批评和建议，我将不胜感激。 <br><br> 我还要特别注意Telegraf.js文档中的这一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分</a> ，其中包含有趣的开源项目，您可以查看这些项目并从中汲取架构和解决方案的启发。 反过来，我想提及其中之一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-The Guard Bot</a> 。 一个真正的大型且制作精良的机器人，我从那里借用了一些开发解决方案。 <br><br> 此刻，我告诉了我所有想要的信息，我将很乐意回答您的问题，建议和意见！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443876/">https://habr.com/ru/post/zh-CN443876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443862/index.html">检察官的车锁。 Bestchange再次锁定</a></li>
<li><a href="../zh-CN443868/index.html">作为程序员，我去了体育馆，这带来了什么</a></li>
<li><a href="../zh-CN443870/index.html">Unity：程序网格编辑</a></li>
<li><a href="../zh-CN443872/index.html">nanoCAD SPDS Steelwork 1.2版的新功能概述</a></li>
<li><a href="../zh-CN443874/index.html">深度学习框架的比较：TensorFlow，PyTorch，Keras，MXNet，Microsoft Cognitive Toolkit，Caffe等</a></li>
<li><a href="../zh-CN443878/index.html">DEV Labs2019。用于解决非平凡任务的Python。 在线Mitap</a></li>
<li><a href="../zh-CN443882/index.html">MOSDROID＃15磷：表演视频</a></li>
<li><a href="../zh-CN443884/index.html">成功的产品经理的3个关键素质：Anton Danilov</a></li>
<li><a href="../zh-CN443886/index.html">通过JavaScript在Google访谈中解决任务：4种不同方式</a></li>
<li><a href="../zh-CN443894/index.html">Max Tegmark多宇宙的第四层</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>