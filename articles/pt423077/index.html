<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆕 👐🏾 👨🏾‍🤝‍👨🏽 Guia do montador X86 para iniciantes 🎹 🔫 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Atualmente, raramente é necessário escrever em assembler puro, mas eu definitivamente recomendo isso para qualquer pessoa interessada em programação. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do montador X86 para iniciantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423077/"> Atualmente, raramente é necessário escrever em assembler puro, mas eu definitivamente recomendo isso para qualquer pessoa interessada em programação.  Você verá as coisas de um ângulo diferente, e as habilidades serão úteis ao depurar o código em outros idiomas. <br><br>  Neste artigo, escreveremos do zero uma calculadora de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">notação polonesa reversa (RPN)</a> no assembler x86 puro.  Quando terminamos, podemos usá-lo assim: <br><br><pre><code class="bash hljs">$ ./calc <span class="hljs-string"><span class="hljs-string">"32+6*"</span></span> <span class="hljs-comment"><span class="hljs-comment"># "(3+2)*6"    30</span></span></code> </pre> <br>  Todo o código do artigo está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  É bastante comentado e pode servir como material educacional para quem já conhece montador. <br><br>  Vamos começar escrevendo o programa básico <i>Hello world!</i>  para verificar as configurações do ambiente.  Em seguida, passemos às chamadas do sistema, pilha de chamadas, quadros de pilha e a convenção de chamadas x86.  Então, para praticar, escreveremos algumas funções básicas no assembler x86 - e começaremos a escrever uma calculadora RPN. <br><a name="habracut"></a><br>  Supõe-se que o leitor tenha alguma experiência em programação em C e conhecimentos básicos de arquitetura de computadores (por exemplo, o que é um registro de processador).  Como usaremos o Linux, você também deve poder usar a linha de comando do Linux. <br><br><h1>  Configuração do ambiente </h1><br>  Como já mencionado, usamos o Linux (64 bits ou 32 bits).  O código acima não funciona no Windows ou no Mac OS X. <br><br>  Para instalação, você só precisa do vinculador GNU <code>ld</code> do <code>binutils</code> , que é pré-instalado na maioria das distribuições, e do montador NASM.  No Ubuntu e Debian, você pode instalar os dois com um comando: <br><br><pre> <code class="bash hljs">$ sudo apt-get install binutils nasm</code> </pre> <br>  Eu também recomendaria manter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma tabela ASCII à</a> mão. <br><br><h1>  Olá mundo! </h1><br>  Para verificar o ambiente, salve o seguinte código no arquivo <code>calc.asm</code> : <br><br><pre> <code class="hljs 1c">;   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> _start     ; . global _start ;   .rodata  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ) ;   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,       section .rodata ;     hello_world.   NASM ;   ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  , ;  . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    hello_world: db <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 ;   .text,     section .text _start: mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>   eax (<span class="hljs-number"><span class="hljs-number">0</span></span>x04 = write()) mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span>x1 ;   (<span class="hljs-number"><span class="hljs-number">1</span></span> =  , <span class="hljs-number"><span class="hljs-number">2</span></span> =  ) mov ecx, hello_world ;     mov edx, <span class="hljs-number"><span class="hljs-number">14</span></span> ;   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 ;  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>x80,   ;     mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x01 ; <span class="hljs-number"><span class="hljs-number">0</span></span>x01 = exit() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   int <span class="hljs-number"><span class="hljs-number">0</span></span>x80</code> </pre> <br>  Comentários explicam a estrutura geral.  Para obter uma lista de registros e instruções gerais, consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Montador x86</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Universidade da Virgínia</a> .  Com uma discussão mais aprofundada das chamadas do sistema, isso será ainda mais necessário. <br><br>  Os seguintes comandos coletam o arquivo assembler em um arquivo de objeto e, em seguida, compilam o arquivo executável: <br><br><pre> <code class="bash hljs">$ nasm -f elf_i386 calc.asm -o calc $ ld -m elf_i386 calc.o -o calc</code> </pre> <br>  Depois de iniciar, você deverá ver: <br><br><pre> <code class="bash hljs">$ ./calc Hello world!</code> </pre> <br><h3>  Makefile </h3><br>  Esta é uma parte opcional, mas você pode criar um <code>Makefile</code> para simplificar a construção e o layout no futuro.  Salve-o no mesmo diretório que <code>calc.asm</code> : <br><br><pre> <code class="hljs powershell">CFLAGS= <span class="hljs-operator"><span class="hljs-operator">-f</span></span> elf32 LFLAGS= <span class="hljs-literal"><span class="hljs-literal">-m</span></span> elf_i386 all: calc calc: calc.o ld <span class="hljs-variable"><span class="hljs-variable">$</span></span>(LFLAGS) calc.o <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc calc.o: calc.asm nasm <span class="hljs-variable"><span class="hljs-variable">$</span></span>(CFLAGS) calc.asm <span class="hljs-literal"><span class="hljs-literal">-o</span></span> calc.o clean: rm <span class="hljs-operator"><span class="hljs-operator">-f</span></span> calc.o calc .INTERMEDIATE: calc.o</code> </pre> <br>  Então, em vez das instruções acima, apenas execute make. <br><br><h1>  Chamadas do sistema </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As chamadas do sistema Linux</a> dizem ao sistema operacional para fazer algo por nós.  Neste artigo, usamos apenas duas chamadas do sistema: <code>write()</code> para escrever uma linha em um arquivo ou fluxo (no nosso caso, este é um dispositivo de saída padrão e um erro padrão) e <code>exit()</code> para sair do programa: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code) error_code -  <span class="hljs-number"><span class="hljs-number">0</span></span>         (  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-number"><span class="hljs-number">0x04</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, char *string, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>) fd —  <span class="hljs-number"><span class="hljs-number">1</span></span>   , <span class="hljs-number"><span class="hljs-number">2</span></span>      string —      <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> —    </code> </pre> <br>  As chamadas do sistema são configuradas armazenando o número de chamada do sistema no registro <code>eax</code> e, em seguida, seus argumentos em <code>ebx</code> , <code>ecx</code> , <code>edx</code> nessa ordem.  Você pode notar que <code>exit()</code> apenas um argumento - nesse caso, ecx e edx não importam. <br><br><table><tbody><tr><th>  eax </th><th>  ebx </th><th>  ecx </th><th>  edx </th></tr><tr><td align="center">  Número de chamada do sistema </td><td align="center">  arg1 </td><td align="center">  arg2 </td><td align="center">  arg3 </td></tr></tbody></table><br><br><h1>  Pilha de chamadas </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/574/ea2/2b0574ea20054a1e428d6f0518a80388.png"><br><br>  Uma pilha de chamadas é uma estrutura de dados que armazena informações sobre cada chamada em uma função.  Cada chamada tem sua própria seção na pilha - o "quadro".  Ele armazena algumas informações sobre a chamada atual: as variáveis ​​locais desta função e o endereço de retorno (para onde o programa deve ir após a execução da função). <br><br>  Noto imediatamente uma coisa não óbvia: a pilha <i>diminui a</i> memória.  Quando você adiciona algo ao topo da pilha, ele é inserido em um endereço de memória menor que o item anterior.  Em outras palavras, conforme a pilha cresce, o endereço de memória na parte superior da pilha diminui.  Para evitar confusão, sempre lembrarei deste fato. <br><br>  A instrução <code>push</code> algo no topo da pilha e exibe os dados a partir daí.  Por exemplo, <code>push </code> aloca um lugar no topo da pilha e coloca o valor do registro <code>eax</code> ali, e o <code>pop </code> transfere todos os dados do topo da pilha para o <code>eax</code> e libera essa área de memória. <br><br>  O objetivo do registro <code>esp</code> é apontar para o topo da pilha.  Qualquer dado acima de <code>esp</code> considerado como não atingindo a pilha, são dados de lixo.  A execução de uma instrução <code>push</code> (ou <code>pop</code> ) move <code>esp</code> .  Você pode manipular <code>esp</code> diretamente, se der um relatório às suas ações. <br><br>  O registro <code>ebp</code> é semelhante ao <code>esp</code> , mas sempre aponta aproximadamente para o meio do quadro de pilha atual, imediatamente antes das variáveis ​​locais da função atual (falaremos sobre isso mais adiante).  No entanto, chamar outra função não move o <code>ebp</code> automaticamente; isso deve ser feito manualmente a cada vez. <br><br><h1>  Convenção de Chamada de Arquitetura X86 </h1><br>  No x86, não existe um conceito interno de função como nas linguagens de alto nível.  A <code>goto</code> <code>call</code> <code>goto</code> basicamente apenas <code>jmp</code> ( <code>goto</code> ) para outro endereço de memória.  Para usar rotinas como funções em outros idiomas (que podem receber argumentos e retornar dados), você precisa seguir a convenção de chamada (existem muitas convenções, mas usamos o CDECL, a convenção mais popular para x86 entre compiladores C e programadores de assembler).  Ele também garante que os registros de rotina não sejam confundidos ao chamar outra função. <br><br><h3>  Regras do chamador </h3><br>  Antes de chamar a função, o chamador deve: <br><br><ol><li>  Salve os registros que o chamador precisa salvar na pilha.  A função chamada pode alterar alguns registros: para não perder dados, o chamador deve salvá-lo na memória até ser empurrado para a pilha.  Estes são os <code>edx</code> <code>eax</code> , <code>ecx</code> e <code>edx</code> .  Se você não usar nenhum deles, não poderá salvá-los. </li><li>  Escreva argumentos de função na pilha na ordem inversa (primeiro último argumento, primeiro primeiro argumento no final).  Essa ordem garante que a função chamada receba seus argumentos da pilha na ordem correta. </li><li>  Ligue para a sub-rotina. </li></ol><br>  Se possível, a função salvará o resultado em <code>eax</code> .  Imediatamente após a <code>call</code> chamador deve: <br><br><ol><li>  Remova os argumentos da função da pilha.  Isso geralmente é feito simplesmente adicionando o número de bytes ao <code>esp</code> .  Não esqueça que a pilha cresce, portanto, para remover da pilha, você deve adicionar bytes. </li><li>  Restaure os registros salvos, colocando-os na pilha na ordem inversa.  A função chamada não mudará nenhum outro registrador. </li></ol><br>  O exemplo a seguir demonstra como essas regras se aplicam.  Suponha que a função <code>_subtract</code> dois argumentos inteiros (4 bytes) e retorne o primeiro argumento menos o segundo.  Na sub-rotina <code>_mysubroutine</code> chame <code>_subtract</code> com os argumentos <code>10</code> e <code>2</code> : <br><br><pre> <code class="hljs perl">_mysubroutine: ; ... ;  -  ; ... <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;   (    eax) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ;  ,      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> call _subtract ; eax   <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">8</span></span> add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> ;  <span class="hljs-number"><span class="hljs-number">8</span></span>    (   <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; ... ;  - ,        eax ; ...</code> </pre> <br><h3>  Regras da rotina chamada </h3><br>  Antes de ligar, a sub-rotina deve: <br><br><ol><li>  Salve o ponteiro do registro base <code>ebp</code> do quadro anterior, escrevendo-o na pilha. </li><li>  Ajuste o <code>ebp</code> do quadro anterior para o atual (valor atual do <code>esp</code> ). </li><li>  Aloque mais espaço na pilha para variáveis ​​locais, se necessário, mova o ponteiro <code>esp</code> .  À medida que a pilha cresce, você precisa subtrair a memória ausente de <code>esp</code> . </li><li>  Salve os registros da rotina chamada na pilha.  Estes são <code>ebx</code> , <code>edi</code> e <code>esi</code> .  Não é necessário salvar registros que não estão planejados para serem alterados. </li></ol><br>  Pilha de chamadas após a etapa 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d15/55e/4c4/d1555e4c4d0851f1f8ddec2b527e4877.png"><br><br>  A pilha de chamadas após a etapa 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/e1a/9bc/2bae1a9bc4aff273c6badbd5ec94d2c8.png"><br><br>  Pilha de chamadas após a etapa 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c4/4bf/a7b/8c44bfa7bfb67546110925a9606e27cd.png"><br><br>  Nesses diagramas, um endereço de retorno é indicado em cada quadro de pilha.  Ele é automaticamente colocado na pilha por uma declaração de <code>call</code> .  A <code>ret</code> recupera o endereço da parte superior da pilha e pula para ele.  Não precisamos dessa instrução, apenas mostrei por que as variáveis ​​locais da função estão 4 bytes acima do <code>ebp</code> , mas os argumentos da função estão 8 bytes abaixo do <code>ebp</code> . <br><br>  No último diagrama, você também pode observar que as variáveis ​​locais da função sempre iniciam 4 bytes acima de <code>ebp</code> do endereço <code>ebp-4</code> (subtração aqui, porque estamos subindo a pilha), e os argumentos da função sempre começam 8 bytes abaixo de <code>ebp</code> do endereço <code>ebp+8</code> (além disso, porque estamos movendo a pilha para baixo).  Se você seguir as regras desta convenção, será assim com as variáveis ​​e argumentos de qualquer função. <br><br>  Quando a função estiver concluída e você desejar retornar, primeiro defina <code>eax</code> como o valor de retorno da função, se necessário.  Além disso, você precisa de: <br><br><ol><li>  Restaure os registros salvos, colocando-os na pilha na ordem inversa. </li><li>  Libere espaço na pilha alocada pela variável local na etapa 3, se necessário: simplesmente instalando <code>esp</code> no ebp </li><li>  Restaure o ponteiro base <code>ebp</code> do quadro anterior, retirando-o da pilha. </li><li>  Retornar com <code>ret</code> </li></ol><br>  Agora implementamos a função <code>_subtract</code> do nosso exemplo: <br><br><pre> <code class="hljs perl">_subtract: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp ;      mov ebp, esp ;  ebp ;          ,      ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>   ;  ;   , eax     ;     ,     ;       ,       <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ;      ret</code> </pre> <br><h3>  Entrada e saída </h3><br>  No exemplo acima, você pode notar que a função sempre executa da mesma maneira: <code>push ebp</code> , <code>mov ebp</code> , <code>esp</code> e alocação de memória para variáveis ​​locais.  O conjunto x86 possui uma instrução conveniente que faz tudo isso: <code>enter ab</code> , onde <code>a</code> é o número de bytes que você deseja alocar para variáveis ​​locais, <code>b</code> é o "nível de aninhamento", que sempre definiremos como <code>0</code> .  Além disso, a função sempre termina com as instruções <code>pop ebp</code> e <code>mov esp</code> , <code>ebp</code> (embora sejam necessárias apenas ao alocar memória para variáveis ​​locais, mas, de qualquer forma, não causem danos).  Isso também pode ser substituído por uma única instrução: <code>leave</code> .  Fazemos alterações: <br><br><pre> <code class="hljs perl">_subtract: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,     ;   ;    mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;      eax.  ;       ebp+<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+12] </span></span>;      ebp+<span class="hljs-number"><span class="hljs-number">12</span></span>  ;   ;   , eax     ;     ,     leave ;      ret</code> </pre> <br><h1>  Escrevendo algumas funções básicas </h1><br>  Depois de dominar a convenção de chamada, você pode começar a escrever algumas rotinas.  Por que não generalizar o código que exibe "Olá, mundo!" Para <code>_print_msg</code> qualquer linha: a função <code>_print_msg</code> . <br><br>  Aqui precisamos de outra função <code>_strlen</code> para contar o comprimento da string.  Em C, pode ficar assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*s != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   length++; s++; } //   return length; }</span></span></code> </pre> <br>  Em outras palavras, desde o início da linha, adicionamos 1 ao valor de retorno para cada caractere, exceto zero.  Assim que o caractere nulo é percebido, retornamos o valor acumulado no loop.  No assembler, isso também é bastante simples: você pode usar a função <code>_subtract</code> escrita anteriormente como base: <br><br><pre> <code class="hljs 1c">_strlen: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;        ebp ;       ,    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;   ;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, 0 ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebp</span></span></span><span class="hljs-function">+8] ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">   ;  </span></span></span></span>)   ecx (   ; ,      ) _strlen_loop_start: ;  ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> cmp byte [ecx], <span class="hljs-number"><span class="hljs-number">0</span></span> ;       . <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>  (<span class="hljs-number"><span class="hljs-number">4</span></span> ). ;    .    ;     ( <span class="hljs-built_in"><span class="hljs-built_in"></span></span>) je _strlen_loop_end ;  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>     inc eax ;    ,  <span class="hljs-number"><span class="hljs-number">1</span></span>    add ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;       jmp _strlen_loop_start ;      _strlen_loop_end: ;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> ; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br>  Já não é ruim, né?  Escrever o código C primeiro pode ajudar, porque a maioria é convertida diretamente em assembler.  Agora você pode usar esta função em <code>_print_msg</code> , onde aplicamos todo o conhecimento adquirido: <br><br><pre> <code class="hljs perl">_print_msg: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov eax, <span class="hljs-number"><span class="hljs-number">0x04</span></span> ; <span class="hljs-number"><span class="hljs-number">0x04</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0x1</span></span> ; <span class="hljs-number"><span class="hljs-number">0x1</span></span> =   mov ecx, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;       , ;   edx   .    _strlen <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;     (    edx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> dword [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   _strlen  _print_msg.  NASM ; ,    ,  , . ;      dword (<span class="hljs-number"><span class="hljs-number">4</span></span> , <span class="hljs-number"><span class="hljs-number">32</span></span> ) call _strlen ; eax     mov edx, eax ;     edx,     add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ;  <span class="hljs-number"><span class="hljs-number">4</span></span>    ( <span class="hljs-number"><span class="hljs-number">4</span></span>-  char*) <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;     <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;      _strlen,     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> leave ret</code> </pre> <br>  E veja os frutos do nosso trabalho duro, usando esta função no programa completo "Olá, mundo!". <br><br><pre> <code class="hljs pgsql">_start: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     (    ) push hello_world ;    _print_msg <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Acredite ou não, abordamos todos os principais tópicos necessários para escrever programas básicos do assembler x86!  Agora, temos todo o material e teoria introdutórios; portanto, vamos nos concentrar completamente no código e aplicar o conhecimento adquirido para escrever nossa calculadora RPN.  As funções serão muito mais longas e até usarão algumas variáveis ​​locais.  Se você deseja ver imediatamente o programa finalizado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está ele</a> . <br><br>  Para aqueles que não estão familiarizados com a notação polonesa reversa (às vezes chamada de notação polonesa reversa ou notação postfix), aqui as expressões são avaliadas usando a pilha.  Portanto, você precisa criar uma pilha, bem como as <code>_push</code> e <code>_push</code> para manipular essa pilha.  Você também <code>_print_answer</code> função <code>_print_answer</code> , que exibirá uma representação em sequência do resultado numérico no final do cálculo. <br><br><h1>  Criação de pilha </h1><br>  Primeiro, definimos o espaço na memória da nossa pilha, bem como a variável global <code>stack_size</code> .  É aconselhável alterar essas variáveis ​​para que não caiam na seção <code>.rodata</code> , mas em <code>.data</code> . <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">section</span></span> .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> stack_size: dd 0 ;   dword (4 )   0 stack: times 256 dd 0 ;   </span></span></code> </pre> <br>  Agora você pode implementar as <code>_pop</code> e <code>_pop</code> : <br><br><pre> <code class="hljs powershell">_push: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    push eax push edx mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov edx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>], edx ;    .   ;       dword inc dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;  <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size ;     pop edx pop eax leave ret _pop: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     dec dword [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  stack_size mov eax, [<span class="hljs-type"><span class="hljs-type">stack_size</span></span>] mov eax, [<span class="hljs-type"><span class="hljs-type">stack</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-type"><span class="hljs-type">eax</span></span>] ;       eax ;     ,     leave ret</code> </pre> <br><h1>  Saída de número </h1><br>  <code>_print_answer</code> muito mais complicado: você precisa converter números em strings e usar várias outras funções.  Você <code>_putc</code> função <code>_putc</code> , que gera um caractere, a função <code>mod</code> para calcular o restante da divisão (módulo) dos dois argumentos e <code>_pow_10</code> para aumentar a potência de 10. Mais tarde, você entenderá por que eles são necessários.  Isso é bem simples, aqui está o código: <br><br><pre> <code class="hljs powershell">_pow_10: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  ecx (  )  ;  mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">10</span></span> (<span class="hljs-number"><span class="hljs-number">10</span></span>**<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) _pow_10_loop_start: ;  eax  <span class="hljs-number"><span class="hljs-number">10</span></span>,  ecx   <span class="hljs-number"><span class="hljs-number">0</span></span> cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _pow_10_loop_end imul eax, <span class="hljs-number"><span class="hljs-number">10</span></span> sub ecx, <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _pow_10_loop_start _pow_10_loop_end: leave ret _mod: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> push ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov eax, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] mov ebx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">12</span></span>] idiv ebx ;  <span class="hljs-number"><span class="hljs-number">64</span></span>-  [<span class="hljs-type"><span class="hljs-type">edx</span></span>:<span class="hljs-type"><span class="hljs-type">eax</span></span>]  ebx.    ;  <span class="hljs-number"><span class="hljs-number">32</span></span>-  eax,    edx  ; . ;    eax,   edx.  ,  ;       , ;    . mov eax, edx ;     () pop ebx leave ret _putc: enter <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span>x04 ; write() mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   lea ecx, [<span class="hljs-type"><span class="hljs-type">ebp</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   mov edx, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-number"><span class="hljs-number">1</span></span>  int <span class="hljs-number"><span class="hljs-number">0</span></span>x80 leave ret</code> </pre> <br>  Então, como derivamos números individuais em um número?  Primeiro, observe que o último dígito do número é o restante da divisão por 10 (por exemplo, <code>123 % 10 = 3</code> ) e o próximo dígito é o restante da divisão por 100, dividido por 10 (por exemplo, <code>(123 % 100)/10 = 2</code> ).  Em geral, você pode encontrar um dígito específico de um número (da direita para a esquerda) localizando <code>( % 10**n) / 10**(n-1)</code> , onde o número de unidades será <code>n = 1</code> , o número de dezenas é <code>n = 2</code> e assim por diante. <br><br>  Usando esse conhecimento, você pode encontrar todos os dígitos de um número de <code>n = 1</code> a <code>n = 10</code> (esse é o número máximo de bits em um número inteiro de 4 bytes assinado).  Mas é muito mais fácil ir da esquerda para a direita - para que possamos imprimir cada caractere assim que o encontrarmos e nos livrarmos dos zeros no lado esquerdo.  Portanto, classificamos os números de <code>n = 10</code> <code>n = 1</code> . <br><br>  Em C, o programa será mais ou menos assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_DIGITS 10 void print_answer(int a) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (a </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 0) { //    putc('-'); //   «» a = -a; //     } int started = 0; for (int i = MAX_DIGITS; i &gt; 0; i--) { int digit = (a % pow_10(i)) / pow_10(i-1); if (digit == 0 &amp;&amp; started == 0) continue; //     started = 1; putc(digit + '0'); } }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora você entende por que precisamos dessas três funções. </font><font style="vertical-align: inherit;">Vamos implementar isso no assembler:</font></font><br><br><pre> <code class="hljs perl">%define MAX_DIGITS <span class="hljs-number"><span class="hljs-number">10</span></span> _print_answer: enter <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-string"><span class="hljs-string">"started"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov eax, [ebp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> cmp eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    ,    ;  jge _print_answer_negate_end ; call putc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x2d</span></span> ;  <span class="hljs-string"><span class="hljs-string">'-'</span></span> call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax neg eax ;     _print_answer_negate_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ; started = <span class="hljs-number"><span class="hljs-number">0</span></span> mov ecx, MAX_DIGITS ;  i _print_answer_loop_start: cmp ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> je _print_answer_loop_end ;  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>  ecx.   ebx   <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C. ;    edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx dec ecx ; i-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx ;    _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call _pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> mov edx, eax ; edx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ;   i  ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ; end pow_1<span class="hljs-number"><span class="hljs-number">0</span></span> call mov ebx, edx ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) imul ebx, <span class="hljs-number"><span class="hljs-number">10</span></span> ; digit = ebx = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) ;  _mod  (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)),   (eax mod ebx) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx ; arg2, ebx = digit = pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ; arg1, eax = a call _mod mov ebx, eax ; digit = ebx = a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>), almost there add esp, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   mod ;  ebx ( <span class="hljs-string"><span class="hljs-string">"digit"</span></span> )  pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i) (edx).    ; ,   idiv     edx, eax.  ; edx   ,    - ;   <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi mov esi, edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, ebx mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv esi ; eax   () mov ebx, eax ; ebx = (a % pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i)) / pow_1<span class="hljs-number"><span class="hljs-number">0</span></span>(i-<span class="hljs-number"><span class="hljs-number">1</span></span>),  <span class="hljs-string"><span class="hljs-string">"digit"</span></span>   C <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi ; end division cmp ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;  digit == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end cmp byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> ;  started == <span class="hljs-number"><span class="hljs-number">0</span></span> jne _print_answer_trailing_zeroes_check_end jmp _print_answer_loop_continue ; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> _print_answer_trailing_zeroes_check_end: mov byte [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> ; started = <span class="hljs-number"><span class="hljs-number">1</span></span> add ebx, <span class="hljs-number"><span class="hljs-number">0x30</span></span> ; digit + <span class="hljs-string"><span class="hljs-string">'0'</span></span> ;  putc <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _putc add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;   putc _print_answer_loop_continue: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ecx</span></span></span><span class="hljs-function">, 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_start</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_answer_loop_end</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ebx</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi um teste difícil! </font><font style="vertical-align: inherit;">Espero que os comentários ajudem a resolver o problema. </font><font style="vertical-align: inherit;">Se você pensa agora: "Por que você não pode escrever </font></font><code>printf("%d")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?", Então você vai gostar do final do artigo, onde substituímos a função por isso! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos todas as funções necessárias, resta implementar a lógica básica </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- e é tudo!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cálculo de notação reversa em polonês </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como já dissemos, a notação polonesa reversa é calculada usando a pilha. </font><font style="vertical-align: inherit;">Ao ler, o número é empurrado para a pilha e, ao ler, o operador é aplicado a dois objetos na parte superior da pilha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, se quisermos calcular </font></font><code>84/3+6*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(esta expressão também pode ser escrita no formulário </font></font><code>6384/+*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), o processo é o seguinte:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etapa </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Símbolo </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Empilhar antes </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Empilhar depois </font></font></th></tr><tr><td align="center">  1 </td><td align="center"> <code>8</code> </td> <td align="center"> <code>[]</code> </td> <td align="center"> <code>[8]</code> </td> </tr><tr><td align="center">  2 </td><td align="center"> <code>4</code> </td> <td align="center"> <code>[8]</code> </td> <td align="center"> <code>[8, 4]</code> </td> </tr><tr><td align="center">  3 </td><td align="center"> <code>/</code> </td> <td align="center"> <code>[8, 4]</code> </td> <td align="center"> <code>[2]</code> </td> </tr><tr><td align="center">  4 </td><td align="center"> <code>3</code> </td> <td align="center"> <code>[2]</code> </td> <td align="center"> <code>[2, 3]</code> </td> </tr><tr><td align="center">  5 </td><td align="center"> <code>+</code> </td> <td align="center"> <code>[2, 3]</code> </td> <td align="center"> <code>[5]</code> </td> </tr><tr><td align="center">  6 </td><td align="center"> <code>6</code> </td> <td align="center"> <code>[5]</code> </td> <td align="center"> <code>[5, 6]</code> </td> </tr><tr><td align="center">  7 </td><td align="center"> <code>*</code> </td> <td align="center"> <code>[5, 6]</code> </td> <td align="center"> <code>[30]</code> </td> </tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a entrada for uma expressão postfix válida, no final dos cálculos restará apenas um elemento na pilha - esta é a resposta, o resultado dos cálculos. </font><font style="vertical-align: inherit;">No nosso caso, o número é 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No assembler, você precisa implementar algo como este código em C:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// , 256      int stack_size = 0; int main(int argc, char *argv[]) { char *input = argv[0]; size_t input_length = strlen(input); for (int i = 0; i &lt; input_length; i++) { char c = input[i]; if (c &gt;= '0' &amp;&amp; c &lt;= '9') { //   —   push(c - '0'); //          } else { int b = pop(); int a = pop(); if (c == '+') { push(a+b); } else if (c == '-') { push(ab); } else if (c == '*') { push(a*b); } else if (c == '/') { push(a/b); } else { error("Invalid input\n"); exit(1); } } } if (stack_size != 1) { error("Invalid input\n"); exit(1); } print_answer(stack[0]); exit(0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora temos todas as funções necessárias para implementar isso, vamos começar. </font></font><br><br><pre> <code class="hljs perl">_start: ;  _start   ,    . ;   esp    argc ( ),  ; esp+<span class="hljs-number"><span class="hljs-number">4</span></span>   argv. , esp+<span class="hljs-number"><span class="hljs-number">4</span></span>    ; , esp+<span class="hljs-number"><span class="hljs-number">8</span></span> -       mov esi, [esp+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; esi = <span class="hljs-string"><span class="hljs-string">"input"</span></span> = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;  _strlen      <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi call _strlen mov ebx, eax ; ebx = input_length add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> ; end _strlen call mov ecx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; ecx = <span class="hljs-string"><span class="hljs-string">"i"</span></span> _main_loop_start: cmp ecx, ebx ;  (i &gt;= input_length) jge _main_loop_end mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> mov dl, [esi + ecx] ;          ; edx.   edx . ; edx =  c = input[i] cmp edx, <span class="hljs-string"><span class="hljs-string">'0'</span></span> jl _check_operator cmp edx, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jg _print_error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function">, '0' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edx</span></span></span><span class="hljs-function"> </span></span>; eax =  c - <span class="hljs-string"><span class="hljs-string">'0'</span></span> (,  ) jmp _push_eax_and_continue _check_operator: ;   _pop    b  edi, a  b -  eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx call _pop mov edi, eax ; edi = b call _pop ; eax = a <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx ; end call _pop cmp edx, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jne _subtract add eax, edi ; eax = a+b jmp _push_eax_and_continue _subtract: cmp edx, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jne _multiply <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function"> </span></span>; eax = ab jmp _push_eax_and_continue _multiply: cmp edx, <span class="hljs-string"><span class="hljs-string">'*'</span></span> jne _divide imul eax, edi ; eax = a*b jmp _push_eax_and_continue _divide: cmp edx, <span class="hljs-string"><span class="hljs-string">'/'</span></span> jne _print_error <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx ;  edx,      idiv mov edx, <span class="hljs-number"><span class="hljs-number">0</span></span> idiv edi ; eax = a/b <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx ;   eax     _push_eax_and_continue: ;  _push <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax ;   call _push add esp, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax ;  call _push inc ecx jmp _main_loop_start _main_loop_end: cmp byte [stack_size], <span class="hljs-number"><span class="hljs-number">1</span></span> ;  (stack_size != <span class="hljs-number"><span class="hljs-number">1</span></span>),   jne _print_error mov eax, [stack] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax call _print_answer ; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> a final newline <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0xA</span></span> call _putc ; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> successfully mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> ; <span class="hljs-number"><span class="hljs-number">0x01</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>() mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> =   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ;    _print_error: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> error_msg call _print_msg mov eax, <span class="hljs-number"><span class="hljs-number">0x01</span></span> mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também precisará adicionar uma linha </font></font><code>error_msg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à seção </font></font><code>.rodata</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs 1c">section .rodata ;     error_msg.  db  NASM ;    ,   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ; . <span class="hljs-number"><span class="hljs-number">0</span></span>xA =  <span class="hljs-built_in"><span class="hljs-built_in"></span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>x0 =    error_msg: db <span class="hljs-string"><span class="hljs-string">"Invalid input"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>xA, <span class="hljs-number"><span class="hljs-number">0</span></span>x0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E nós terminamos! </font><font style="vertical-align: inherit;">Surpreenda todos os seus amigos se você os tiver. </font><font style="vertical-align: inherit;">Espero que agora você reaja mais calorosamente às linguagens de alto nível, especialmente se você se lembrar de que muitos programas antigos foram escritos completa ou quase completamente em assembler, por exemplo, o RollerCoaster Tycoon original! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo o código está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Obrigado pela leitura! </font><font style="vertical-align: inherit;">Eu posso continuar se você estiver interessado.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ações adicionais </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Você pode praticar implementando várias funções adicionais: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retorne uma mensagem de erro em vez de segfault se o programa não receber um argumento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione suporte para espaços extras entre operandos e operadores na entrada. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione suporte para operandos de vários bits. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permitir números negativos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Substitua </font></font><code>_strlen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por uma função da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca C padrão</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><code>_print_answer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substitua por uma chamada </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ol><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiais adicionais </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Guia do Montador x86 da Universidade da Virgínia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um relato mais detalhado de muitos dos tópicos abordados, incluindo informações adicionais sobre todas as instruções x86 populares.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«   Intel»</a> .    x86 —   ,      .        ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NASM: Intel x86 Instruction Reference</a> —       x86. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423077/">https://habr.com/ru/post/pt423077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423067/index.html">Ferramentas de desenvolvedor Python da Microsoft. Introdução</a></li>
<li><a href="../pt423069/index.html">Evento especial da Apple, setembro de 2018 [arquivo de tradução de texto]</a></li>
<li><a href="../pt423071/index.html">Eu não tenho medo do seu NDA</a></li>
<li><a href="../pt423073/index.html">Sistema de arquivos interplanetário - hash (identidade) trivial, bloco DAG e buffers de protocolo</a></li>
<li><a href="../pt423075/index.html">Por que os CFOs estão tão ansiosos para converter os gastos de capital em TI em operações</a></li>
<li><a href="../pt423079/index.html">Pontos-chave de uma entrevista com Elon Musk em Joe Rogan</a></li>
<li><a href="../pt423083/index.html">Como me tornei desenvolvedor na ABBYY</a></li>
<li><a href="../pt423085/index.html">Ajustar o balanceamento de carga</a></li>
<li><a href="../pt423087/index.html">Não me empurre nos olhos</a></li>
<li><a href="../pt423089/index.html">Programadores na MBLT DEV 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>