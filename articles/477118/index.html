<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚ÄçüöÄ ü¶ñ üíü MIRO es una plataforma abierta de robot de interior. Parte 5 - Componente de software: ARDUINO (AVR), subimos "bajo el cap√≥" üïö üë®üèæ‚Äç‚úàÔ∏è üòÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta vez, veamos un poco m√°s a fondo la implementaci√≥n de algunos m√©todos de biblioteca clave para ARDUINO (AVR), que son responsables de mover el rob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIRO es una plataforma abierta de robot de interior. Parte 5 - Componente de software: ARDUINO (AVR), subimos "bajo el cap√≥"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="imagen"><br><br>  Esta vez, veamos un poco m√°s a fondo la implementaci√≥n de algunos m√©todos de biblioteca clave para ARDUINO (AVR), que son responsables de mover el robot MIRO.  Esta parte ser√° interesante para todos los que se preguntaron c√≥mo controlar la velocidad lineal y angular del robot en el ARDUINO, equipado con motores con los codificadores m√°s simples. <br><a name="habracut"></a><br>  Tabla de contenido: <a href="https://habr.com/ru/post/472380/">Parte 1</a> , <a href="https://habr.com/ru/post/472802/">Parte 2</a> , <a href="https://habr.com/ru/post/473368/">Parte 3</a> , <a href="https://habr.com/ru/post/475512/">Parte 4</a> , <a href="https://habr.com/ru/post/477118/">Parte 5</a> . <br><br>  Los m√©todos responsables de conducir con odometr√≠a siguen siendo dif√≠ciles de explicar c√≥mo, qu√© y por qu√©.  Lo primero que debe saber sobre el control del movimiento del robot es el hecho simple y obvio de que los motores colectores del robot nunca giran a la misma velocidad sin un ajuste adicional.  Embrague diferente, caracter√≠sticas de salida diferentes de los canales del conductor, motores el√©ctricos ligeramente diferentes y lubricaci√≥n en la caja de cambios. <br><br>  El segundo hecho que debe comprender y conocer es la presencia de inercia en el motor, incluso con una relaci√≥n de transmisi√≥n suficientemente grande.  Es decir  Al eliminar el voltaje de los terminales del motor, la rueda, incluso sin carga, se mueve unos pocos grados m√°s.  La magnitud de esta rotaci√≥n adicional depende de la fuerza de carga sobre la rueda, de la velocidad de rotaci√≥n antes de aliviar el estr√©s y de los mismos factores invisibles como el tipo y la cantidad de lubricante en la caja de engranajes. <br><br>  Estos hechos determinan la implementaci√≥n de un grupo de m√©todos relacionados con el movimiento de un chasis equipado con sensores de od√≥metro (en el caso de MIRO, codificadores digitales de cada rueda). <br><br>  Como descubrimos en la cuarta parte, en el modelo de software existe la clase <b>Chassis</b> , que implementa el control de rotaci√≥n de motores de chasis individuales.  Quiero enfatizar, no el control del movimiento del chasis, el trole, sino el control de los motores del trole.  El control directo del carro se implementa en las clases <b>Robot</b> y <b>Miro</b> . <br><br>  Comencemos desde arriba.  A continuaci√≥n se muestra un m√©todo de la clase <b>Miro</b> que implementa el movimiento de un robot a cierta distancia ( <b>dist</b> , metros) con una <b>velocidad</b> lineal ( <b>lin_speed</b> , m / s) y angular ( <b>ang_speed</b> , deg / s).  <b>Todav√≠a</b> no estamos prestando atenci√≥n al par√°metro <b>en_break</b> . <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  En este m√©todo, primero se calculan las velocidades angulares REQUERIDAS para los motores izquierdo y derecho.  Seg√∫n f√≥rmulas bastante obvias, lo que no es un problema para deducir.  Solo es necesario tener en cuenta que la velocidad lineal en el m√©todo se especifica en metros por segundo, y la velocidad angular en grados por segundo (no en radianes).  Por lo tanto, calculamos previamente la constante <b>MIRO_PI2ANG = 57.29 = 180 / pi.</b>  <b>ROBOT_DIAMETER</b> : distancia entre las ruedas izquierda y derecha del robot (en metros), <b>WHEEL_RADIUS</b> : radio de la rueda (tambi√©n en metros).  Todas las constantes num√©ricas para tales casos est√°n contenidas en el archivo defs.h, y los par√°metros personalizados del robot y el chasis est√°n en el archivo config.h. <br><br>  Despu√©s de eso, se calcula el √°ngulo mediante el cual se debe girar cada rueda para que el robot recorra la distancia <b>dist</b> (tambi√©n en metros). <br><br>  Por lo tanto, en esta etapa obtenemos a qu√© velocidad y en qu√© √°ngulo necesita girar cada rueda del chasis del robot.  Y luego se <b>llama al</b> m√©todo <b>wheelRotateAng ()</b> del objeto del <b>chasis</b> . <br><br>  El m√©todo <b>wheelRotateAng (float * speed, float * ang, bool en_break)</b> se usa para rotar las ruedas del robot con las velocidades angulares especificadas por la matriz <b>speed []</b> (en m / s) seg√∫n los √°ngulos especificados por la matriz <b>ang []</b> (en grados).  El √∫ltimo par√°metro <b>en_break</b> (que ya <b>cumplimos</b> anteriormente) establece el requisito de una parada <b>brusca</b> de las ruedas despu√©s de hacer un giro al aplicarles voltaje inverso a corto plazo.  Esto es necesario para suprimir la inercia del robot, evitando que se mueva m√°s all√° de la distancia requerida despu√©s de eliminar el voltaje de control de los motores.  Para una satisfacci√≥n completa, por supuesto, existe el m√©todo <b>wheelRotateAngRad ()</b> , similar a <b>wheelRotateAng ()</b> con la diferencia de que toma los valores de los √°ngulos de rotaci√≥n y las velocidades angulares en radianes y radianes por segundo como par√°metros. <br><br>  El algoritmo del m√©todo <b>wheelRotateAng ()</b> es el siguiente. <br><br>  1. Primero, se verifica la correspondencia de los valores de <b>velocidad []</b> y <b>ang [] con</b> algunas condiciones de contorno.  Obviamente, el chasis tiene limitaciones f√≠sicas tanto en la velocidad angular m√°xima de rotaci√≥n de las ruedas como en la m√≠nima (velocidad m√≠nima de alejamiento).  Adem√°s, los √°ngulos en <b>ang []</b> no pueden ser inferiores al √°ngulo de rotaci√≥n fijo m√≠nimo, determinado por la precisi√≥n de los codificadores. <br><br>  2. A continuaci√≥n, se calcula la direcci√≥n de rotaci√≥n de cada rueda.  Obviamente a trav√©s del signo del producto <b>ang [i] * velocidad [i]</b> ; <br><br>  3. Se calcula la "distancia de rotaci√≥n" <b>Dw [i]</b> para cada rueda: el n√∫mero de muestras de codificador que se deben hacer para rotar en el <b>√°ngulo</b> dado <b>[i]</b> . <br>  Este valor est√° determinado por la f√≥rmula: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> , <br>  donde <b>WHEEL_SEGMENTS</b> es el n√∫mero de segmentos de la rueda del codificador (revoluci√≥n completa). <br><br>  4. Se registra el valor de voltaje en el controlador del motor. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre voltaje en motores</b> <div class="spoiler_text">  * <i>PWM se utiliza para controlar la rotaci√≥n de los motores, por lo tanto, para conocer el voltaje suministrado a cada motor, es necesario conocer el voltaje de suministro del controlador del motor.</i>  <i>En el robot MIRO, el controlador est√° conectado directamente al circuito de alimentaci√≥n de la bater√≠a.</i>  <i>Funci√≥n float getVoltage ();</i>  <i>devuelve el voltaje de un divisor de voltaje con un factor de VOLTAGE_DIVIDER.</i>  <i>Voltaje de referencia ADC: 5V.</i>  <i>En este momento, el valor de VOLTAGE_DIVIDER en el robot es 2, y el voltaje de un banco (1S) de la bater√≠a se suministra a la entrada ADC (PIN_VBAT).</i>  <i>Esto no es del todo correcto debido al hecho de que los bancos de bater√≠as pueden descargarse de diferentes maneras y perder el equilibrio, pero, como la pr√°ctica ha demostrado, con una carga constante de una bater√≠a con equilibrio, la soluci√≥n funciona bastante.</i>  <i>En el futuro planeamos hacer un divisor normal con dos latas de bater√≠a.</i> <br></div></div><br>  5. De acuerdo con la tabla de calibraci√≥n para cada rueda, se determina el valor inicial de la se√±al PWM, lo que garantiza la rotaci√≥n de la rueda con la velocidad de <b>velocidad</b> requerida <b>[i]</b> .  ¬øQu√© tipo de tabla de calibraci√≥n y de d√≥nde vino? Analizaremos m√°s a fondo. <br><br>  6. La rotaci√≥n de los motores se inicia de acuerdo con los valores calculados de velocidad y direcci√≥n de rotaci√≥n.  En el texto de la implementaci√≥n de la clase, el m√©todo privado <b>_wheel_rotate_sync ()</b> es responsable de esto. <br><br>  Vamos a√∫n m√°s profundo.  El m√©todo <b>_wheel_rotate_sync ()</b> funciona de acuerdo con el siguiente algoritmo: <br><br>  1. En un bucle infinito, se realiza una comprobaci√≥n para lograr el contador de las respuestas del codificador de la distancia de giro <b>Dw [i]</b> para cada rueda.  Si se alcanza CUALQUIERA de los contadores <b>Dw [i]</b> , todas las ruedas se detienen y salen del ciclo y luego salen de la funci√≥n (paso 5).  Esto se hace por las siguientes razones.  Debido a la discreci√≥n de medir el √°ngulo de rotaci√≥n, es una situaci√≥n muy com√∫n cuando la distancia calculada <b>Dw [i] de</b> una rueda se obtiene al redondear un valor no entero a un lado m√°s peque√±o y <b>Dw [j] de la</b> segunda rueda a una m√°s grande.  Esto lleva al hecho de que despu√©s de detener una de las ruedas, la segunda rueda contin√∫a girando.  Para un chasis con un accionamiento diferencial (y para muchos otros), esto lleva a un "giro" no planificado del robot al final de la tarea.  Por lo tanto, en el caso de organizar el movimiento espacial de todo el chasis, es necesario detener todos los motores a la vez. <br><br>  2. Si no se alcanza <b>Dw [i]</b> , entonces en el bucle se verifica el hecho de la siguiente operaci√≥n del codificador (la variable <b>_syncloop [w]</b> , actualizada desde la interrupci√≥n del codificador y restablecida en este bucle infinito).  Cuando se produce la pr√≥xima intersecci√≥n, el programa calcula el m√≥dulo de la velocidad angular actual de cada rueda (grados / s), de acuerdo con la f√≥rmula obvia: <br><br>  <b>W [i] = (360 * tau [i]) / WHEEL_SEGMENTS</b> , <br>  donde: <br>  <b>tau [i]</b> : el valor promedio del tiempo entre las dos √∫ltimas respuestas de los codificadores.  La "profundidad" del filtro de promedio est√° determinada por <b>MEAN_DEPTH</b> y su valor predeterminado es 8. <br><br>  3. En funci√≥n de las velocidades calculadas de las ruedas, los errores absolutos se calculan como las diferencias entre las velocidades angulares establecidas y reales. <br><br>  4. En funci√≥n de los errores calculados, la acci√≥n de control (valor de se√±al PWM) se corrige para cada motor. <br><br>  5. Despu√©s de alcanzar <b>Dw [i]</b> , en el caso de un <b>en_break</b> activo, se aplica voltaje inverso a corto plazo a los motores.  La duraci√≥n de este efecto se determina a partir de la tabla de calibraci√≥n (ver m√°s abajo) y generalmente var√≠a de 15 a 40 ms. <br><br>  6. Hay una liberaci√≥n completa de tensi√≥n de los motores y sale de <b>_wheel_rotate_sync ()</b> . <br><br>  Ya he mencionado una cierta tabla de calibraci√≥n dos veces.  Entonces, en la biblioteca hay una tabla especial de valores almacenados en la EEPROM de la memoria del robot y que contiene registros de tres valores relacionados: <br><br>  1. Voltaje en los terminales del motor.  Se calcula traduciendo el valor de la se√±al PWM en el voltaje real.  Para esto, en el paso 4 del m√©todo <b>wheelRotateAng ()</b> , se registra el voltaje real en el controlador del motor. <br><br>  2. La velocidad angular de rotaci√≥n de la rueda (sin carga) correspondiente a un voltaje dado. <br><br>  3. La duraci√≥n de la se√±al de parada dura correspondiente a esta velocidad angular. <br>  Por defecto, el tama√±o de la tabla de calibraci√≥n es de 10 registros (determinado por la constante <b>WHEEL_TABLE_SIZE</b> en el archivo <b>config.h</b> ) - 10 triples de los valores "voltaje - velocidad angular - duraci√≥n de la se√±al de parada". <br><br>  Para determinar los valores de 2 y 3 entradas en esta tabla, se utiliza un m√©todo especial: <b>wheelCalibrate (rueda de bytes)</b> . <br><br>  Echemos un vistazo a esto.  Este m√©todo implementa una secuencia de acciones para determinar los valores faltantes en la tabla de calibraci√≥n del motor / rueda, as√≠ como para determinar la velocidad angular m√≠nima de arranque y la velocidad angular m√°xima de la rueda. <br><br>  Para realizar la calibraci√≥n, el robot se monta en un soporte; toda la rotaci√≥n de las ruedas durante la calibraci√≥n se realiza sin carga. <br><br>  1. Primero debe determinar la velocidad m√≠nima de arranque.  Esto se hace de manera muy simple.  En un ciclo, el PWM de control se alimenta al motor, comenzando desde 0, con un incremento de 1. En cada paso, el programa espera un tiempo, determinado por la constante <b>WHEEL_TIME_MAX</b> ( <b>retraso</b> normal <b>()</b> ).  Una vez transcurrido el tiempo de espera, verifica si se ha completado el inicio (cambiando el valor del contador del codificador).  Si se completa la polea, entonces se calcula la velocidad angular de rotaci√≥n de la rueda.  Para mayor certeza, el valor de 10 se agrega al valor de PWM correspondiente a esta velocidad de arranque, lo que da el primer par de valores "voltaje en el motor" - "velocidad angular". <br><br>  2. Despu√©s de encontrar la velocidad de inicio, se calcula el paso PWM para llenar uniformemente la tabla de calibraci√≥n. <br><br>  3. En el ciclo, para cada nuevo valor de PWM, la rueda gira 2 vueltas completas y la velocidad angular se mide de acuerdo con un algoritmo similar al m√©todo <b>_wheel_rotate_sync ()</b> .  En el mismo ciclo, tambi√©n por aproximaci√≥n sucesiva, se mide el valor √≥ptimo de la duraci√≥n de la se√±al de parada dura.  Inicialmente, se toma un valor obviamente grande.  Y luego se prueba en el modo "giro-parada".  Como el √≥ptimo, se selecciona el valor m√°ximo de la duraci√≥n de la se√±al de parada, en el que no se supera la "distancia de giro" establecida.  En otras palabras, dicho valor de la duraci√≥n de la se√±al, una vez que se suministra al motor, por un lado, se suprime la inercia y, por otro lado, no hay movimiento inverso a corto plazo (que se fija con el mismo codificador). <br><br>  4. Una vez completada la calibraci√≥n, el voltaje de control al motor calibrado deja de aplicarse y la tabla de calibraci√≥n de esta rueda se registra en la EEPROM. <br><br>  Omit√≠ todo tipo de trivialidades de implementaci√≥n y trat√© de expresar la esencia.  Puede observar que los <b>m√©todos wheelRotateAng ()</b> y <b>wheelRotateAngRad ()</b> son funciones de bloqueo.  Este es el precio por la precisi√≥n del movimiento y una integraci√≥n bastante simple en los bocetos de los usuarios.  Ser√≠a posible hacer un peque√±o administrador de tareas con un tiempo fijo, pero esto requerir√≠a que el usuario integrara su funcionalidad estrictamente en la cuota de tiempo asignada. <br><br>  Y para una aplicaci√≥n sin bloqueo, la API tiene una funci√≥n <b>wheelRotate (flotante * velocidad)</b> .  Como se puede ver en la lista de par√°metros, simplemente realiza la rotaci√≥n de las ruedas con las velocidades establecidas.  Y la velocidad de rotaci√≥n se ajusta en el m√©todo <b>Sync ()</b> del chasis del robot, que se llama en el m√©todo <b>Sync ()</b> del objeto de clase Miro del mismo nombre.  Y de acuerdo con los requisitos para la estructura del boceto del usuario, este m√©todo deber√≠a llamarse cada iteraci√≥n del <b>bucle</b> principal <b>() del</b> boceto ARDUINO. <br><br>  En el paso 4, en la descripci√≥n del m√©todo <b>_wheel_rotate_sync ()</b> , mencion√© la "correcci√≥n de control" del motor.  ¬øC√≥mo lo adivinaste?  Este es el controlador PID).  Bueno, m√°s precisamente el controlador PD.  Como saben (de hecho, no siempre), la mejor manera de determinar los coeficientes del regulador es la selecci√≥n).  Hay una definici√≥n en el archivo de configuraci√≥n config.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  Si lo descomenta, cuando llame al m√©todo <b>moveDist ()</b> de la clase Miro, el siguiente gr√°fico invertido del error relativo en el control de la velocidad angular de una de las ruedas del robot (izquierda) se mostrar√° en la consola del robot. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  ¬øNo se parece a nada)?  Abajo est√° el tiempo (cada barra es un paso del ciclo de control), y el valor del error se guarda a la derecha (con el signo preservado).  Aqu√≠ hay dos pares de gr√°ficos en la misma escala con diferentes coeficientes del controlador PD.  Los "jorobados" son solo las "olas" de sobreimpulso.  Los n√∫meros en las barras horizontales son un error relativo (con la preservaci√≥n del signo).  Visualizaci√≥n simple del regulador, ayudando a ajustar manualmente los coeficientes.  Con el tiempo, espero hacer una configuraci√≥n autom√°tica, pero por ahora. <br><br>  Aqu√≠ hay un adok :-) <br><br>  Bueno, por √∫ltimo, veamos un ejemplo.  Directamente desde la biblioteca API_Miro_moveDist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  Del texto del programa todo debe quedar claro.  C√≥mo funciona: en el video. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Baldosas de 600 x 600 mm y espacios de baldosas de 5 mm.  En teor√≠a, el robot debe rodear un cuadrado con un lado de 1 metro.  Por supuesto, la trayectoria "flota".  Pero para ser justos, vale la pena decir que en la versi√≥n del robot que me queda para las pruebas, hay motores bastante giratorios que son dif√≠ciles de manejar lentamente.  Pero a alta velocidad y deslizamiento hay un lugar para estar, y la inercia no es f√°cil de manejar.  Los motores con una relaci√≥n de transmisi√≥n m√°s alta (como incluso en nuestros robots MIRO, que no estaban disponibles durante la prueba) deber√≠an comportarse algo mejor. <br><br>  Si hay momentos incomprensibles, me complace aclarar, debatir y mejorar.  La retroalimentaci√≥n es generalmente interesante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477118/">https://habr.com/ru/post/477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477098/index.html">Nos ocupamos de la transmisi√≥n de video en resoluci√≥n 4K a 60 Hz a trav√©s de un concentrador USB-C</a></li>
<li><a href="../477100/index.html">Marat√≥n t√©cnico de Microsoft Dynamics 365</a></li>
<li><a href="../477104/index.html">IntelliSense asistido por IA para la base de c√≥digo de su equipo</a></li>
<li><a href="../477110/index.html">Planificaci√≥n entretenida</a></li>
<li><a href="../477114/index.html">Implementaci√≥n del int√©rprete MSH</a></li>
<li><a href="../477120/index.html">Software de monitorizaci√≥n continua de glucosa en sangre para Windows</a></li>
<li><a href="../477122/index.html">El cerebro de la empresa. Parte 3</a></li>
<li><a href="../477124/index.html">Bitcoin en una jaula?</a></li>
<li><a href="../477126/index.html">Administrador en 5 minutos. Frontend - react-admin, backend - Flask-RESTful</a></li>
<li><a href="../477128/index.html">Habra detective en el fin de semana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>