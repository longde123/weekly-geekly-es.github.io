<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêù üö± üïå Angular sin zone.js: m√°ximo rendimiento üñïüèº üëãüèæ üç∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los desarrolladores angulares le deben mucho a zone.js. Ella, por ejemplo, ayuda a lograr una facilidad casi m√°gica al trabajar con Angular. De hecho,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular sin zone.js: m√°ximo rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Los desarrolladores angulares le deben mucho a zone.js.  Ella, por ejemplo, ayuda a lograr una facilidad casi m√°gica al trabajar con Angular.  De hecho, casi siempre, cuando solo necesita cambiar alguna propiedad, y la cambiamos sin pensar en nada, Angular vuelve a representar los componentes correspondientes.  Como resultado, lo que ve el usuario siempre contiene la informaci√≥n m√°s reciente.  Esto es simplemente genial. <br><br>  Aqu√≠ me gustar√≠a explorar algunos aspectos de c√≥mo el uso del nuevo compilador Ivy (que apareci√≥ en Angular 9) puede facilitar en gran medida el rechazo del uso de zone.js. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  Al abandonar esta biblioteca, pude aumentar significativamente el rendimiento de la aplicaci√≥n Angular que se ejecuta bajo una gran carga.  Al mismo tiempo, logr√© implementar los mecanismos que necesitaba usando decoradores TypeScript, lo que condujo a muy pocos recursos adicionales del sistema. <br><br>  Tenga en cuenta que el enfoque para optimizar las aplicaciones angulares, presentado en este art√≠culo, es posible solo porque Angular Ivy y AOT est√°n habilitados de forma predeterminada.  Este art√≠culo est√° escrito con fines educativos, no tiene como objetivo promover el enfoque presentado para el desarrollo de proyectos angulares. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øPor qu√© podr√≠a necesitar usar Angular sin zone.js?</font> </h2><br>  Antes de continuar, hagamos una pregunta importante: "¬øVale la pena deshacerse de zone.js, dado que esta biblioteca nos ayuda a volver a renderizar plantillas con poco esfuerzo?"  Por supuesto, esta biblioteca es muy √∫til.  Pero, como siempre, tienes que pagar por todo. <br><br>  Si su aplicaci√≥n tiene requisitos de rendimiento espec√≠ficos, deshabilitar zone.js puede ayudar a cumplir esos requisitos.  Un ejemplo de una aplicaci√≥n en la que el rendimiento es crucial es un proyecto cuya interfaz se actualiza con mucha frecuencia.  En mi caso, dicho proyecto result√≥ ser una aplicaci√≥n comercial en tiempo real.  Su parte del cliente recibe constantemente mensajes a trav√©s del protocolo WebSocket.  Los datos de estos mensajes deben mostrarse lo m√°s r√°pido posible. <br><br><h2>  <font color="#3AC1EF">Eliminar zone.js de Angular</font> </h2><br>  Angular se puede hacer que funcione muy f√°cilmente sin zone.js.  Para hacer esto, primero debe comentar o eliminar el comando de importaci√≥n correspondiente, que se encuentra en el archivo <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Coment√≥ el comando de importaci√≥n zone.js</font></i> <br><br>  A continuaci√≥n, debe equipar el m√≥dulo ra√≠z con las siguientes opciones: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Hiedra angular: cambios de autodetecci√≥n con …µdetectChanges y …µmarkDirty</font> </h2><br>  Antes de que podamos comenzar a crear un decorador TypeScript, debemos aprender c√≥mo Ivy le permite invocar el proceso de detectar cambios en los componentes, ensuciarlos y omitir zone.js y DI. <br><br>  Ahora tenemos disponibles dos funciones adicionales, exportadas desde <code>@angular/core</code> .  Estos son <code>…µdetectChanges</code> y <code>…µmarkDirty</code> .  Estas dos funciones todav√≠a est√°n destinadas al uso interno y son inestables: el s√≠mbolo <code>…µ</code> se encuentra al comienzo de sus nombres. <br><br>  Veamos c√≥mo usar estas funciones. <br><br><h3>  <font color="#3AC1EF">‚ñç …µmarkFunci√≥n sucia</font> </h3><br>  Esta funci√≥n le permite marcar un componente, haci√©ndolo "sucio", es decir, necesita volver a renderizarse.  Ella, si el componente no estaba marcado como "sucio" antes de ser llamado, planea comenzar el proceso de detecci√≥n de cambios. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç …µdetectChanges Funci√≥n</font> </h3><br>  La documentaci√≥n interna angular dice que, por razones de rendimiento, no debe usar <code>…µdetectChanges</code> .  En cambio, se recomienda usar la funci√≥n <code>…µmarkDirty</code> .  La funci√≥n <code>…µdetectChanges</code> invoca sincr√≥nicamente el proceso de detecci√≥n de cambios en un componente y sus subcomponentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">Detectar cambios autom√°ticamente usando el decorador TypeScript</font> </h2><br>  Aunque las funciones proporcionadas por Angular aumentan la usabilidad del desarrollo al permitir que el DI funcione, el programador a√∫n puede sentirse frustrado por el hecho de que necesita importar y llamar a estas funciones por s√≠ solo para comenzar el proceso de detecci√≥n de cambios. <br><br>  Para simplificar el inicio autom√°tico de la detecci√≥n de cambios, puede escribir un decorador TypeScript, que resolver√° este problema de forma independiente.  Por supuesto, hay algunas limitaciones aqu√≠, que discutiremos a continuaci√≥n, pero en mi caso este enfoque result√≥ ser exactamente lo que necesitaba. <br><br><h3>  <font color="#3AC1EF">‚ñçIntroducci√≥n del decorador @observado</font> </h3><br>  Para detectar cambios, haciendo el menor esfuerzo posible, crearemos un decorador que se pueda aplicar de tres maneras.  A saber, es aplicable a las siguientes entidades: <br><br><ul><li>  A los m√©todos sincr√≥nicos. </li><li>  Objetos observables </li><li>  A los objetos ordinarios. </li></ul><br>  Considere un par de peque√±os ejemplos.  En el siguiente fragmento de c√≥digo, aplicamos el decorador <code>@observed</code> al objeto de <code>state</code> y al m√©todo <code>changeTitle</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Para verificar los cambios en el objeto de <code>state</code> , utilizamos un objeto proxy que intercepta los cambios en el objeto y llama al procedimiento para detectar cambios. </li><li>  <code>changeTitle</code> m√©todo <code>changeTitle</code> aplicando una funci√≥n que primero llama a este m√©todo y luego inicia el proceso de detecci√≥n de cambios. </li></ul><br>  Y aqu√≠ hay un ejemplo con <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  En el caso de los objetos Observables, usar un decorador parece un poco m√°s complicado.  Es decir, debe suscribirse al objeto observado y marcar el componente como "sucio" en la suscripci√≥n, pero tambi√©n debe borrar la suscripci√≥n.  Para hacer esto, reasignamos <code>ngOnInit</code> y <code>ngOnDestroy</code> para suscribirse y limpiarlo m√°s tarde. <br><br><h3>  <font color="#3AC1EF">‚ñçCreando un decorador</font> </h3><br>  Aqu√≠ est√° la firma decoradora <code>observed</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Como puede ver, el <code>descriptor</code> es un par√°metro opcional.  Esto se debe a que necesitamos que el decorador se aplique tanto a los m√©todos como a las propiedades.  Si el par√°metro existe, esto significa que el decorador se aplica al m√©todo.  En este caso, hacemos esto: <br><br><ul><li>  Guarde la propiedad del <code>descriptor.</code>  <code>value</code> </li><li>  Redefinimos el m√©todo de la siguiente manera: llame a la funci√≥n original y luego llame a <code>markDirty(this)</code> para comenzar el proceso de detecci√≥n de cambios.  As√≠ es como se ve: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  A continuaci√≥n, debe verificar qu√© tipo de propiedad estamos tratando.  Puede ser un objeto Observable o un objeto ordinario.  Aqu√≠ usaremos otra API angular interna.  Creo que no est√° destinado para su uso en aplicaciones normales (¬°lo siento!). <br><br>  Estamos hablando de la propiedad <code>…µcmp</code> , que da acceso a las propiedades procesadas por Angular despu√©s de que se definen.  Podemos usarlos para anular los m√©todos de los <code>onDestroy</code> <code>onInit</code> y <code>onDestroy</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).…µcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Para marcar una propiedad como una para ser monitoreada, usamos <code>ReflectMetadata</code> y establecemos su valor en <code>true</code> .  Como resultado, sabremos que necesitamos observar la propiedad cuando se inicializa el componente: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Ahora es el momento de anular el <code>onInit</code> y verificar las propiedades al crear la instancia del componente: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Definimos la funci√≥n <code>checkComponentProperties</code> , que <code>checkComponentProperties</code> las propiedades del componente, filtr√°ndolas de acuerdo con el valor establecido previamente usando <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  La funci√≥n <code>checkProperty</code> ser√° responsable de decorar propiedades individuales.  Primero, verificamos si la propiedad es un Observable o un objeto regular.  Si este es un objeto Observable, nos suscribimos a √©l y agregamos la suscripci√≥n a la lista de suscripciones almacenadas en el componente para sus necesidades internas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Si la propiedad es un objeto ordinario, la convertiremos en un objeto Proxy y llamaremos a <code>markDirty</code> en su funci√≥n de <code>handler</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    …µmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Finalmente, debe borrar la suscripci√≥n despu√©s de destruir el componente: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  Las posibilidades de este decorador no se pueden llamar integrales.  No cubren todos los usos posibles que pueden aparecer en una aplicaci√≥n grande.  Por ejemplo, estas son llamadas a funciones de plantilla que devuelven objetos Observables.  Pero estoy trabajando en eso. <br><br>  A pesar de esto, el decorador anterior es suficiente para mi peque√±o proyecto.  Encontrar√° su c√≥digo completo al final del material. <br><br><h2>  <font color="#3AC1EF">An√°lisis de resultados de aceleraci√≥n de aplicaciones.</font> </h2><br>  Ahora que hemos hablado un poco sobre los mecanismos internos de Ivy y sobre c√≥mo crear un decorador usando estos mecanismos, es hora de probar lo que tenemos en una aplicaci√≥n real. <br><br>  Yo, para descubrir el efecto de deshacerme de zone.js en el rendimiento de las aplicaciones angulares, utilic√© mi proyecto de afici√≥n <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio</a> . <br><br>  Apliqu√© el decorador a todos los enlaces necesarios utilizados en las plantillas y zone.js. deshabilitado  Por ejemplo, considere el siguiente componente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  La plantilla usa dos variables: <code>price</code> (el precio del activo estar√° aqu√≠) y <code>trend</code> (esta variable puede tomar valores <code>up</code> , <code>stale</code> y <code>down</code> , indicando la direcci√≥n del cambio de precio).  Los <code>@observed</code> con <code>@observed</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Tama√±o del paquete del proyecto</font> </h3><br>  Para comenzar, echemos un vistazo a cu√°nto ha disminuido el tama√±o del paquete del proyecto al deshacerse de zone.js.  A continuaci√≥n se muestra el resultado de construir el proyecto con zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">Resultado de construir un proyecto con zone.js</font></i> <br><br>  Y aqu√≠ est√° la asamblea sin zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">El resultado de construir un proyecto sin zone.js</font></i> <br><br>  Presta atenci√≥n al <code>polyfills-es2015.xxx.js</code> .  Si el proyecto usa zone.js, su tama√±o es de aproximadamente 35 Kb.  Pero sin zone.js, solo 130 bytes. <br><br><h3>  <font color="#3AC1EF">‚ñç Arranque</font> </h3><br>  Investigu√© dos opciones de aplicaci√≥n usando Lighthouse.  Los resultados de este estudio se dan a continuaci√≥n.  Cabe se√±alar que no los tomar√≠a demasiado en serio.  El hecho es que al tratar de encontrar los valores promedio, obtuve resultados significativamente diferentes al realizar varias mediciones para la misma versi√≥n de la aplicaci√≥n. <br><br>  Quiz√°s la diferencia en la evaluaci√≥n de las dos opciones de aplicaci√≥n depende solo del tama√±o de los paquetes. <br><br>  Entonces, aqu√≠ est√° el resultado obtenido para una aplicaci√≥n que utiliza zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">Resultados de an√°lisis para una aplicaci√≥n que usa zone.js</font></i> <br><br>  Y esto es lo que sucedi√≥ despu√©s de analizar la aplicaci√≥n en la que zone.js no se usa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">Resultados de an√°lisis para una aplicaci√≥n que no utiliza zone.js</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Rendimiento</font> </h3><br>  Y ahora llegamos a lo m√°s interesante.  Este es el rendimiento de una aplicaci√≥n que se ejecuta bajo carga.  Queremos saber c√≥mo se siente el procesador cuando la aplicaci√≥n muestra actualizaciones de precios de cientos de activos varias veces por segundo. <br><br>  Para cargar la aplicaci√≥n, cre√© 100 entidades que proporcionan datos condicionales a precios que cambian cada 250 ms.  Si el precio aumenta, se muestra en verde.  Si se reduce - rojo.  Todo esto podr√≠a cargar seriamente mi MacBook Pro. <br><br>  Cabe se√±alar que, mientras trabajaba en el sector financiero en varias aplicaciones dise√±adas para la transmisi√≥n de alta frecuencia de fragmentos de datos, me he encontrado con una situaci√≥n similar muchas veces. <br><br>  Para analizar c√≥mo las diferentes versiones de la aplicaci√≥n usan los recursos del procesador, utilic√© las herramientas de desarrollador de Chrome. <br><br>  As√≠ es como se ve la aplicaci√≥n que usa zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Carga del sistema creada por una aplicaci√≥n que usa zone.js</font></i> <br><br>  Y as√≠ es como funciona una aplicaci√≥n en la que zone.js no se usa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Carga del sistema creada por una aplicaci√≥n que no utiliza zone.js</font></i> <br><br>  Analizamos estos resultados, prestando atenci√≥n al gr√°fico de carga del procesador (amarillo): <br><br><ul><li>  Como puede ver, una aplicaci√≥n que utiliza zone.js carga constantemente el procesador en un 70-100%.  Si mantiene la pesta√±a del navegador abierta durante mucho tiempo, creando tal carga en el sistema, entonces la aplicaci√≥n que se ejecuta puede fallar. </li><li>  Y la versi√≥n de la aplicaci√≥n donde no se utiliza zone.js crea una carga estable en el procesador en el rango de 30 a 40%.  Genial </li></ul><br>  Tenga en cuenta que estos resultados se obtuvieron con la ventana de Chrome Developer Tools abierta, lo que tambi√©n ejerce presi√≥n sobre el sistema y ralentiza la aplicaci√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç aumento de carga</font> </h3><br>  Trat√© de asegurarme de que cada entidad responsable de actualizar el precio emitiera 4 actualizaciones m√°s por segundo, adem√°s de lo que ya produce. <br><br>  Esto es lo que logramos averiguar sobre la aplicaci√≥n en la que zone.js no se usa: <br><br><ul><li>  Esta aplicaci√≥n normalmente hizo frente a la carga, ahora utiliza aproximadamente el 50% de los recursos del procesador. </li><li>  Logr√≥ cargar el procesador tanto como la aplicaci√≥n con zone.js, solo cuando los precios se actualizaban cada 10 ms (los datos nuevos, como antes, proven√≠an de 100 entidades). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç An√°lisis de rendimiento con Benchpress angular</font> </h3><br>  El an√°lisis de rendimiento que realic√© anteriormente no se puede llamar particularmente cient√≠fico.  Para un estudio m√°s serio del rendimiento de varios marcos, recomendar√≠a usar <a href="https://krausest.github.io/js-framework-benchmark/current.html">este punto de referencia</a> .  Para la investigaci√≥n, Angular debe elegir la versi√≥n habitual de este marco y su versi√≥n sin zone.js. <br><br>  Yo, inspirado por algunas ideas de este punto de referencia, cre√© un <a href="https://github.com/Gbuomprisco/zoneless-angular">proyecto</a> que realiza c√°lculos pesados.  Prob√© su rendimiento con <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress</a> . <br><br>  Aqu√≠ est√° el c√≥digo del componente probado: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  Lanc√© un peque√±o conjunto de puntos de referencia utilizando Protractor y Benchpress.  Las operaciones se realizaron un n√∫mero espec√≠fico de veces. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Benchpress en acci√≥n</font></i> <br><br><h4>  Resultados </h4><br>  Aqu√≠ hay una muestra de los resultados obtenidos con Benchpress. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">Resultados de Benchpress</font></i> <br><br>  Aqu√≠ hay una explicaci√≥n de los indicadores presentados en esta tabla: <br><br><ul><li>  <code>gcAmount</code> : volumen de operaciones gc (recolecci√≥n de basura), Kb. </li><li>  <code>gcTime</code> : tiempo de operaci√≥n de gc, ms. </li><li>  <code>majorGcTime</code> : tiempo de las operaciones principales gc, ms. </li><li>  <code>pureScriptTime</code> : tiempo de ejecuci√≥n del script en ms, excluyendo las operaciones y la representaci√≥n de gc. </li><li>  <code>renderTime</code> : tiempo de representaci√≥n, ms. </li><li>  <code>scriptTime</code> : tiempo de ejecuci√≥n del script teniendo en cuenta las operaciones y la representaci√≥n de gc. </li></ul><br>  Ahora consideraremos el an√°lisis del rendimiento de algunas operaciones en diversas variantes de aplicaci√≥n.  El verde muestra los resultados de una aplicaci√≥n que usa zone.js, el naranja muestra los resultados de una aplicaci√≥n sin zone.js.  Tenga en cuenta que aqu√≠ solo se analiza el tiempo de representaci√≥n.  Si est√° interesado en todos los resultados de la prueba, marque <a href="https://github.com/Gbuomprisco/zoneless-angular">aqu√≠</a> . <br><br><h4>  Prueba: crear 1000 l√≠neas </h4><br>  En la primera prueba, se crean 1000 l√≠neas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">Resultados de la prueba</font></i> <br><br><h4>  Prueba: crear 10,000 filas </h4><br>  A medida que aumenta la carga en las aplicaciones, tambi√©n lo hace la diferencia en su rendimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">Resultados de la prueba</font></i> <br><br><h4>  Prueba: une 1000 l√≠neas </h4><br>  En esta prueba, se agregan 1000 l√≠neas a 10,000 l√≠neas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">Resultados de la prueba</font></i> <br><br><h4>  Prueba: eliminar 10,000 filas </h4><br>  Aqu√≠, se crean 10,000 l√≠neas, que luego se eliminan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">Resultados de la prueba</font></i> <br><br><h2>  <font color="#3AC1EF">C√≥digo fuente del decorador TypeScript</font> </h2><br>  A continuaci√≥n se muestra el c√≥digo fuente del decorador TypeScript discutido aqu√≠.  Este c√≥digo tambi√©n se puede encontrar <a href="">aqu√≠</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, …µComponentType as ComponentType, …µmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).…µcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property …µcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Aunque espero que te haya gustado mi historia sobre la optimizaci√≥n del rendimiento de los proyectos de Angular, tambi√©n espero no haberte incitado a apresurarte a eliminar zone.js de tu proyecto.  La estrategia descrita aqu√≠ deber√≠a ser el √∫ltimo recurso al que puede recurrir para aumentar el rendimiento de su aplicaci√≥n Angular. <br><br>  Primero debe probar enfoques como el uso de la estrategia de detecci√≥n de cambios de OnPush, la aplicaci√≥n de <code>trackBy</code> , la desactivaci√≥n de componentes, la ejecuci√≥n de c√≥digo fuera de zone.js, la lista negra de eventos zone.js (esta lista de m√©todos de optimizaci√≥n puede continuar).  El enfoque que se muestra aqu√≠ es bastante costoso, y no estoy seguro de que todos est√©n dispuestos a pagar un precio tan alto por el rendimiento. <br><br>  De hecho, el desarrollo sin zone.js puede no ser lo m√°s atractivo.  Quiz√°s esto no sea solo para la persona que est√° involucrada en el proyecto, que est√° bajo su control total.  Es decir, es el propietario de las dependencias y tiene la capacidad y el tiempo para llevar todo a su forma adecuada. <br><br>  Si result√≥ que probaste todo y crees que el cuello de botella de tu proyecto es precisamente zone.js, entonces quiz√°s deber√≠as intentar acelerar Angular detectando los cambios de forma independiente. <br><br>  Espero que este art√≠culo le haya permitido ver qu√© espera Angular en el futuro, de lo que Ivy es capaz y qu√© zone.js puede hacer para maximizar la velocidad de la aplicaci√≥n. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo optimizas tus proyectos angulares que necesitan el m√°ximo rendimiento? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476956/">https://habr.com/ru/post/476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476938/index.html">Lujo inaccesible de Intel: Core i9-9990XE con 14 n√∫cleos a una frecuencia de 5.0 GHz (2 partes)</a></li>
<li><a href="../476940/index.html">Sem√°foro en eventos C ++</a></li>
<li><a href="../476944/index.html">El cerebro de la empresa. Inicio</a></li>
<li><a href="../476948/index.html">Trayectorias cu√°nticas y con qu√© comen</a></li>
<li><a href="../476954/index.html">El trabajo no es un lobo, parte 3. Principiante: ¬øcrecer o sobrevivir?</a></li>
<li><a href="../476958/index.html">Omega Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../476970/index.html">EkbDotNet Meeting No. 1 - Ekaterimburgo se une a la comunidad DotNet.Ru</a></li>
<li><a href="../476972/index.html">Deno: Node.JS ¬øse est√° acabando el tiempo?</a></li>
<li><a href="../476974/index.html">Aprenda dise√±o web receptivo en 5 minutos</a></li>
<li><a href="../476976/index.html">6 errores de hablar en p√∫blico en conferencias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>