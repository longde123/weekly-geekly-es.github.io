<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úä ‚ÜòÔ∏è üëø Desarrollar un hex√°podo desde cero (parte 4) - trayectorias y secuencias matem√°ticas ü§± ü§±üèº üöì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! El desarrollo del hex√°podo ha ido un paso m√°s all√°. Esta vez, se implementan y prueban las trayectorias del movimiento de las extremidad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollar un hex√°podo desde cero (parte 4) - trayectorias y secuencias matem√°ticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444070/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/93/m5/ft93m5szh_bfaxkmnxialxpkoiu.png"></div><br>  Hola a todos!  El desarrollo del hex√°podo ha ido un paso m√°s all√°.  Esta vez, se implementan y prueban las trayectorias del movimiento de las extremidades, la siguiente parte de las matem√°ticas del movimiento.  En este art√≠culo hablar√© sobre estas trayectorias y secuencias b√°sicas para el movimiento.  Espero que sea interesante. <br><br>  <b>Etapas de desarrollo:</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1 - Dise√±o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2 - montaje</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3 - Cinem√°tica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>Parte 4 - trayectorias y secuencias matem√°ticas</b></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5 - Electr√≥nica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: transici√≥n a la impresi√≥n 3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7 - nuevo alojamiento, software de aplicaci√≥n y protocolos de comunicaci√≥n</a> <br><a name="habracut"></a><br><h2>  Trayectorias </h2><br>  La esencia de este mecanismo es que cuando establece dos puntos, puede elegir la trayectoria de la extremidad.  Al moverse de un punto a otro, las coordenadas cambiar√°n de acuerdo con ciertas ecuaciones param√©tricas.  El mecanismo result√≥ ser bastante poderoso y le permite obtener curvas interesantes para el movimiento.  Tambi√©n implementa el suavizado de movimientos al cambiar el paso del par√°metro t: cuanto m√°s peque√±o es el paso, m√°s puntos intermedios habr√°, menor ser√° la velocidad y mayor ser√° la suavidad del movimiento. <br><br>  El procedimiento para establecer los par√°metros de la trayectoria en algunos lugares es un poco incomprensible y puede confundirse en √©l.  La dificultad radica en el hecho de que al establecer las coordenadas de los puntos inicial y final, las coordenadas de los puntos reales en el espacio no siempre se establecen, es decir.  Algunas coordenadas establecen los par√°metros de la trayectoria.  Tuve que escribir un programa que muestra una ruta determinada y al mismo tiempo comprueba la accesibilidad de cada punto de la ruta. <br><br>  El controlador admite las siguientes rutas de movimiento: <br><br><ol><li>  <b>XYZ_LINAR</b> es la m√°s simple de todas las trayectorias.  La trayectoria se utiliza al avanzar, retroceder, subir y bajar.  Todas las coordenadas cambian linealmente y se calculan de la siguiente manera: <br><br><pre><code class="cpp hljs">x = t * (x1 - x0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + x0; y = t * (y1 - y0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + y0; z = t * (z1 - z0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + z0;</code> </pre> <br>  Aqu√≠ entendemos que no hay problemas.  Las coordenadas especifican los √°ngulos paralelep√≠pedos y coinciden con las coordenadas reales.  El movimiento ocurre a lo largo de la diagonal de la caja. <br><br><div class="spoiler">  <b class="spoiler_title">Visualizaci√≥n de trayectoria</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t5/55/uy/t555uy9zum9cfwqa6hw4gwotdni.png"><br><img src="https://habrastorage.org/webt/bn/2n/p-/bn2np-sm7n7onhmvariez7_0jy4.png"><br><img src="https://habrastorage.org/webt/5p/g6/yw/5pg6yw_fpcqdxnr4lotb-n0so4u.png"><br></div></div><br></li><li>  <b>YZ_ARC_Y_LINEAR</b> : esta trayectoria le permite implementar movimiento a lo largo de un arco.  La trayectoria se usa al girar, cuando necesitas mover una extremidad en el suelo.  Las coordenadas se calculan de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// Circle Y y = t * (y1 - y0) / 180.0f + y0; z = R * cos(t_mapped_rad); // Circle X</span></span></code> </pre><br>  Aqu√≠ es donde comienza la diversi√≥n.  Las coordenadas especifican la direcci√≥n de los rayos para limitar el arco y pueden no coincidir con las coordenadas reales.  Los rayos est√°n en el mismo plano, mientras que el radio del c√≠rculo es igual a la longitud del vector hasta el punto de partida. <br><br><div class="spoiler">  <b class="spoiler_title">Visualizaci√≥n de trayectoria</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ky/p0/dw/kyp0dwzfg-0t_qsrmwvstiwlweq.png"><br><br><img src="https://habrastorage.org/webt/ak/ng/ey/akngeyx2imiyht44jebbuydxyaw.png"><br></div></div><br></li><li>  <b>XZ_ARC_Y_SINUS</b> : esta trayectoria tambi√©n le permite implementar movimiento a lo largo de un arco, pero m√°s complejo que YZ_ARC_Y_LINEAR.  La trayectoria se usa al girar, cuando necesitas mover una extremidad por el aire.  Las coordenadas se calculan de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// circle Y y = (y1 - y0) * sin(DEG_TO_RAD(t)) + y0; z = R * cos(t_mapped_rad); // circle X</span></span></code> </pre><br>  La diversi√≥n contin√∫a.  Las coordenadas tambi√©n especifican la direcci√≥n de los rayos para limitar el arco, pero NO coinciden con las coordenadas reales.  La coordenada Y del punto objetivo establece la altura del seno. <br><br><div class="spoiler">  <b class="spoiler_title">Visualizaci√≥n de trayectoria</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t6/2g/tf/t62gtfnlk7nwgibcchhawz2ug4e.png"><br></div></div><br></li><li>  <b>XZ_ELLIPTICAL_Y_SINUS</b> : esta trayectoria le permite implementar movimiento a lo largo de una elipse.  La trayectoria se usa cuando se mueve hacia adelante y hacia atr√°s, cuando necesita mover una extremidad por el aire.  Esta trayectoria es una complicaci√≥n de XZ_ARC_Y_SINUS y se necesitaba solo debido a la marcha fea visual cuando se usa XZ_ARC_Y_SINUS (las piernas se extienden demasiado).  Las coordenadas se calculan de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = (z1 - z0) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = (x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = (y1 - y0); x = b * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(DEG_TO_RAD(<span class="hljs-number"><span class="hljs-number">180.0f</span></span> - t)) + x0; <span class="hljs-comment"><span class="hljs-comment">// circle Y y = c * sin(DEG_TO_RAD(t)) + y0; z = a * cos(DEG_TO_RAD(180.0f - t)) + z0 + a;</span></span></code> </pre><br>  Las coordenadas especifican los √°ngulos paralelep√≠pedos y NO coinciden con las coordenadas reales.  El movimiento se produce desde las esquinas inferiores de la caja, ubicadas en el mismo plano que tocando la parte superior de su parte.  Es mejor mirar la imagen en el spoiler, no s√© c√≥mo describirla brevemente en palabras. <br><br><div class="spoiler">  <b class="spoiler_title">Visualizaci√≥n de trayectoria</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pn/3x/4w/pn3x4wot6ajk1ofy4wl7rtjyp1y.png"><br></div></div></li></ol><br>  Esto completa las matem√°ticas b√°sicas del movimiento del hex√°podo.  En mi proyecto, este es un m√≠nimo necesario para la implementaci√≥n de casi cualquier movimiento. <br><br><h2>  Secuencias </h2><br><h3>  Poco de teor√≠a </h3><br>  Las secuencias son las acciones elementales que componen la marcha.  Se dividen en c√≠clicos y no c√≠clicos. <br><br><ul><li>  Las secuencias c√≠clicas se pueden realizar muchas veces y al final de cada ciclo deben devolver las extremidades a su posici√≥n original (movimiento y rotaci√≥n); </li><li>  Las secuencias no c√≠clicas se realizan solo una vez (ascenso y descenso); </li></ul><br>  Cada secuencia tiene tres bloques de iteraci√≥n: bloque de preparaci√≥n, bloque principal, bloque de finalizaci√≥n. <br><br><ul><li>  Bloque de entrenamiento: contiene iteraciones para mover las extremidades a la posici√≥n inicial de la secuencia.  En mi caso, avanzar requiere colocar las piernas en una determinada posici√≥n antes de comenzar a moverse.  Se ejecuta una vez tras la transici√≥n a la secuencia; </li><li>  Bloque principal: contiene la iteraci√≥n principal de la secuencia.  Se puede realizar c√≠clicamente; </li><li>  Finalizaci√≥n de bloque: contiene iteraciones para mover las extremidades a la posici√≥n base (la posici√≥n en la que se establecen las extremidades despu√©s de levantarlas); </li></ul><br>  La siguiente figura muestra la secuencia para avanzar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/yf/vw/ytyfvwd1slowqjmordig0qenioa.png"></div><br><ul><li>  Los puntos rojos indican la posici√≥n inicial de las extremidades antes de comenzar a moverse </li><li>  Las l√≠neas azules indican las trayectorias de la extremidad en el suelo. </li><li>  Las l√≠neas negras indican las trayectorias de la extremidad en el aire. </li><li>  Las flechas indican la secuencia. </li></ul><br>  Las coordenadas de los puntos se seleccionan en funci√≥n de la configuraci√≥n de la carcasa.  Eleg√≠ los puntos lo m√°s cerca posible del cuerpo para reducir la longitud de la palanca.  En un ciclo de la secuencia, el hex√°podo se mueve 18 cm (en 1 ciclo se toman 2 pasos - 1 paso en 3 extremidades).  Si aumenta la distancia, las extremidades comenzar√°n a adherirse entre s√≠.  Este par√°metro est√° limitado solo por la configuraci√≥n del caso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/hs/0b/67hs0bhvmyfefjvvxyb0qh0lojy.png"></div><br>  La secuencia est√° definida por dos puntos (1, 2) para cada miembro y se utilizan dos caminos: XYZ_LINEAR (l√≠neas azules) y XZ_ELLIPTICAL_Y_SINUS (l√≠neas negras).  El punto 1 es utilizado por la trayectoria XZ_ELLIPTICAL_Y_SINUS para establecer la altura del seno y, en consecuencia, la altura a la que se eleva el pie.  Los puntos 2 y 3 son puntos reales que alcanza una extremidad cuando se mueve. <br><br>  La ubicaci√≥n de los puntos depende solo de su imaginaci√≥n y de las capacidades del hex√°podo.  Quiz√°s todo result√≥ un poco complicado y hay una opci√≥n m√°s simple, pero aparentemente a√∫n no la he alcanzado. <br><br><h3>  Implementaci√≥n </h3><br>  Ahora echemos un vistazo a la implementaci√≥n de toda esta felicidad.  Las estructuras con par√°metros de secuencia son las siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">point_3d_t</span></span> point_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">path_type_t</span></span> path_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> smooth_point_count; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sequence_looped; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> main_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finalize_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> total_iteration_count; <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span> iteration_list[<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sequence_id_t</span></span> available_sequences[SUPPORT_SEQUENCE_COUNT]; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_info_t</span></span>;</code> </pre> <br>  <b>secuencia_iteraci√≥n_t</b> : contiene informaci√≥n sobre la iteraci√≥n de la secuencia: <br><br><ul><li>  lista_puntos: una matriz de puntos para cada miembro en formato XYZ; </li><li>  path_list: una serie de trayectorias para cada miembro; </li><li>  smooth_point_count: establece el n√∫mero de puntos de ruta (paso de par√°metro t); </li></ul><br>  <b>secuencia_info_t</b> - contiene informaci√≥n sobre la secuencia completa: <br><br><ul><li>  is_sequence_looped - establece el tipo de secuencia: c√≠clica o no; </li><li>  main_sequence_begin: establece el √≠ndice inicial del bloque principal en la matriz iteration_list; </li><li>  finalize_sequence_begin: establece el √≠ndice inicial del bloque de finalizaci√≥n en la matriz iteration_list; </li><li>  total_iteration_count: establece el n√∫mero de iteraciones en la secuencia; </li><li>  iteration_list: una matriz de iteraciones; </li><li>  available_sequences: establece la lista de secuencias disponibles para la transici√≥n de la actual (por ejemplo, no podemos comenzar a caminar sin antes levantarnos del piso); </li></ul><br>  <i>NOTA: El √≠ndice del bloque de preparaci√≥n no se indica intencionalmente; siempre se encuentra al comienzo de la matriz de iteraci√≥n.</i> <i><br></i> <br>  Desafortunadamente, no puedo proporcionar un c√≥digo para determinar la secuencia aqu√≠, porque  Es bastante amplio y se ve terrible despu√©s de las transferencias.  Acabo de dejar un enlace al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">archivo de definici√≥n</a> aqu√≠. <br><br><h3>  Esquema de procesamiento de movimiento </h3><br>  Vale la pena distinguir todos los c√≠rculos del infierno que atraviesa la secuencia en tiempo de ejecuci√≥n.  El esquema de procesamiento es el siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hz/bd/h-/hzbdh-sihkvi9t9lmxn73igosv8.png"></div><br><ol><li>  <b>MOTOR</b> DE <b>MOVIMIENTO</b> : organiza el procesamiento y el cambio entre secuencias.  No se realizan c√°lculos all√≠.  Si se simplifica, este m√≥dulo desliza el siguiente punto al m√≥dulo LIBMS DRIVER despu√©s de que se complete el procesamiento actual. <br>  <i>M√≥dulo de entrada: conjunto de coordenadas de puntos objetivo.</i> <i><br></i>  <i>Salida del m√≥dulo: punto objetivo para la iteraci√≥n actual de la secuencia.</i> </li><li>  <b>LIBMS DRIVER</b> es el m√°s complejo de todos los m√≥dulos.  Aqu√≠ reina toda la matem√°tica del movimiento: cinem√°tica inversa, c√°lculos de trayectoria y suavizado de movimientos.  Este m√≥dulo tiene una sincronizaci√≥n estricta con el m√≥dulo PWM.  Los c√°lculos se llevan a cabo con una frecuencia de 150Hz, respectivamente, el pulso de control a los variadores tambi√©n se suministra con una frecuencia de 150Hz. <br>  <i>Entrada de m√≥dulo: coordenadas del punto objetivo.</i> <i><br></i>  <i>Salida del m√≥dulo: √°ngulos de rotaci√≥n del servo.</i> </li><li>  <b>SERVO CONDUCTOR</b> .  No tiene nada de especial, excepto un mont√≥n de par√°metros para configurar y ajustar unidades. <br>  <i>Entrada del m√≥dulo: √°ngulos de rotaci√≥n del servo.</i> <i><br></i>  <i>Salida del m√≥dulo: control de ancho de pulso.</i> </li><li>  <b>PWM DRIVER</b> .  Software controlador PWM para el control del variador.  Aqu√≠ los pines se contraen en el momento adecuado.  La variable de sincronizaci√≥n sincronizada PWM se incrementa cada per√≠odo PWM. <br>  <i>Entrada de m√≥dulo: ancho de pulso de control.</i> <i><br></i>  <i>Salida del m√≥dulo: pulsos en los pines de control.</i> </li></ol><br>  Trat√© de hacer que los m√≥dulos fueran independientes entre s√≠ y lo logr√©.  Esto le permite insertar en este circuito cualquier m√≥dulo intermedio (por ejemplo, el m√≥dulo de adaptaci√≥n al paisaje) y nada se romper√° al mismo tiempo, mientras que la implementaci√≥n ocurrir√° con cambios m√≠nimos en el c√≥digo. <br><br><h2>  √öltimas noticias y cangrejos de proyecto encontrados </h2><br><div class="spoiler">  <b class="spoiler_title">√öltimas noticias</b> <div class="spoiler_text"><ol><li>  Sali√≥ una nueva versi√≥n de prueba del caso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">(archivo con dibujos)</a> y lo pint√© un poco.  El ensamblaje completo del hex√°podo con las boquillas de accionamiento en la posici√≥n central toma de 7 a 8 horas de ensamblaje continuo, y esto est√° considerando que ya he llevado a cabo este procedimiento m√°s de una vez. <br><br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/ux/k0/rjuxk0f6rfsfinjvlr9j8elgpna.jpeg"><br><br><img src="https://habrastorage.org/webt/53/nk/it/53nkit0njb3bc_tslbr8ql2utwe.jpeg"><br><br><img src="https://habrastorage.org/webt/1p/kj/cs/1pkjcsdujiutmq5ueqgtaeqjvxk.jpeg"><br><br><img src="https://habrastorage.org/webt/yw/ll/_0/ywll_0aat4jlvvx-ayq1byjbkz0.jpeg"><br></div></div></li><li>  Puse una pantalla OLED para mostrar alg√∫n tipo de informaci√≥n, result√≥ bastante bien. <br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gf/g8/q1/gfg8q1mn_1brvu8vlbl84uj2d4s.jpeg"><br><br><img src="https://habrastorage.org/webt/pb/6n/gl/pb6ngln4uduzi3ivvdea5bda4gs.jpeg"><br></div></div></li><li>  Se inici√≥ la comunicaci√≥n a trav√©s de WIFI.  Ahora se controla desde el tel√©fono (la herramienta ten√≠a que escribir la suya) </li><li>  Voltaje de fuente de alimentaci√≥n reducido de 12 V a 7 V debido a problemas de sobrecalentamiento de la placa de alimentaci√≥n. </li><li>  Con el lanzamiento de la parte 5 del desarrollo, publicar√© un enlace a las fuentes, finalmente adquirieron un estado en el que no se averg√ºenzan de mostrarle a la gente </li></ol><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Cangrejo de r√≠o encontrado</b> <div class="spoiler_text"><ol><li>  HC-SR04.  Sab√≠a que este sensor era malo, pero no lo creo.  En general, necesita un medidor de rango diferente </li><li>  MG996R no cumple con las especificaciones declaradas.  Prometieron 12 kg \ cm; de hecho, 5 kg \ cm en PWM con una frecuencia de 300Hz, a 50Hz era a√∫n peor y adem√°s resultaron ser anal√≥gicos (prometieron una cifra).  Apto solo para giros.  Tuve que cambiar a unidades digitales m√°s caras DS3218 a 20 kg / cm, de hecho 23 kg / cm </li><li>  Compil√© una tabla de √°ngulo-momento cada 10 grados y not√© que los anchos de pulso de control para el MG996R est√°n a diferentes distancias entre s√≠.  Tuve que hacer tablas de calibraci√≥n para cada unidad y calcular el impulso individualmente. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/9e/my/ez9emybwzomnlc0vxeslvl0l_im.png"></div><br>  Como puede ver, el tono del pulso para cada unidad es diferente, fue un descubrimiento inesperado para m√≠. </li><li>  Los valores m√≠nimos, m√°ximos y centrales del impulso difieren debido a las boquillas para las unidades (digamos lo que uno diga, todav√≠a no es uniforme).  La figura muestra las unidades a las que se aplica el pulso 1500us y se puede ver que una boquilla no est√° en el centro y, en consecuencia, es necesario ajustar el pulso para que todas las boquillas est√©n en la misma posici√≥n. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/md/bs/qvmdbsnasfavacafddclxdbug4o.jpeg"></div><br></li></ol><br>  Por cierto, hice la calibraci√≥n con este dispositivo: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/vx/de/pbvxdeg2clwcwtnh3ynnb9zg-d8.jpeg"></div><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444070/">https://habr.com/ru/post/444070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444058/index.html">Cuando los ni√±os entienden que toda su vida ya est√° en l√≠nea</a></li>
<li><a href="../444060/index.html">Migrar de Nagios a Icinga2 en Australia</a></li>
<li><a href="../444062/index.html">Iluminar! Transformaciones nocturnas del Centro Lakhta</a></li>
<li><a href="../444064/index.html">Nuevas ideas para un nuevo futuro.</a></li>
<li><a href="../444068/index.html">Quien esta mirando</a></li>
<li><a href="../444072/index.html">Compras en Android - Play Billing Library</a></li>
<li><a href="../444074/index.html">Internet de las cosas: cuatro historias tecnol√≥gicas</a></li>
<li><a href="../444076/index.html">C√≥mo intent√© derrotar a TP4056</a></li>
<li><a href="../444078/index.html">Kernel de Linux 5.1: lo que se sabe sobre los cambios</a></li>
<li><a href="../444082/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 290 (11 de marzo - 17 de marzo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>