<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 🖐🏿 🙅🏾 Affichage et optimisation de la sortie du terminal sur le Web ⏳ 🤶🏼 👩🏽‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a pas si longtemps, je suis tombé sur une tâche assez simple et en même temps intéressante: implémenter un terminal en lecture seule dans une a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Affichage et optimisation de la sortie du terminal sur le Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448030/"><p>  Il n'y a pas si longtemps, je suis tombé sur une tâche assez simple et en même temps intéressante: implémenter un terminal en lecture seule dans une application Web.  L'intérêt pour la tâche a été donné par trois aspects importants: </p><br><ul><li>  prise en charge des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">séquences d'échappement ANSI de</a> base </li><li>  prise en charge d'au moins 50 000 lignes de données </li><li>  afficher les données dès qu'elles deviennent disponibles. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ku/fa/rk/kufarkakkmxskpfqqokeixh_ste.png"></div><br><p>  Dans cet article, je parlerai de la façon dont il a été mis en œuvre et comment il a ensuite optimisé le tout. </p><a name="habracut"></a><br><p>  <em>Avertissement: Je ne suis pas un développeur Web expérimenté, donc certaines choses peuvent vous sembler évidentes et les conclusions ou décisions sont erronées.</em>  <em>Pour les corrections et clarifications, je vous en serai reconnaissant.</em> </p><br><h2 id="dlya-chego-eto-zatevalos">  Pourquoi était-ce </h2><br><p>  Toute la tâche est la suivante: un script s'exécute sur le serveur (bash, python, etc.) et écrit quelque chose sur stdout.  Et cette conclusion doit être affichée sur la page Web à mesure qu'elle arrive.  En même temps, il devrait ressembler au terminal (avec formatage, transferts de curseur, etc.) <br>  Je ne contrôle en aucune façon le script lui-même et sa sortie et je ne l'affiche pas sous une forme pure. </p><br><p>  Bien sûr, entre l'interface Web et le script, il devrait y avoir un intermédiaire - un serveur Web.  Et si ce n'est pas pour dissimuler - j'ai déjà une application web et un serveur, et je travaille en quelque sorte.  Le schéma ressemble à ceci: <br><img src="https://habrastorage.org/webt/ww/kb/ei/wwkbei13_tv9n6w6vcw_6c4e5dm.png"></p><br><p>  Mais auparavant, le serveur était responsable du traitement et du formatage.  Et je voulais l'améliorer pour un grand nombre de raisons: </p><br><ul><li>  double traitement des données - première analyse sur le serveur, puis transformation en composants html sur le client </li><li>  algorithme non optimal dû à la préparation des données pour le client </li><li>  forte charge sur le serveur - le traitement de la sortie d'un seul script peut charger complètement un seul thread sur le serveur </li><li>  prise en charge incomplète des séquences d'échappement ANSI </li><li>  bogues subtils </li><li>  le client a très mal réussi à afficher même des lignes au format 10k </li></ul><br><p>  Par conséquent, il a été décidé de transférer l'intégralité de la logique d'analyse à l'application Web et de ne laisser que le streaming des données brutes au serveur </p><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p>  Des parties du texte parviennent au client.  Le client doit les analyser en composants: texte brut, saut de ligne, retour chariot et commandes ANSI spéciales.  Il n'y a aucune garantie quant à l'intégrité des pièces - une commande ou un mot peut provenir de différents packages. </p><br><p>  Les commandes ANSI peuvent affecter le format du texte (couleur, arrière-plan, style), la position du curseur (d'où le texte suivant doit être affiché) ou pour effacer une partie de l'écran. <br>  Un exemple de ce à quoi il ressemble: <br><img src="https://habrastorage.org/webt/5u/3c/tt/5u3cttwmep44kv8c9gysh5bn9ig.png"></p><br><p>  De plus, il peut y avoir des URL dans le texte qui doivent également être reconnues et mises en évidence. </p><br><h2 id="beryom-gotovuyu-biblioteku-i-">  Nous prenons la bibliothèque terminée et ... </h2><br><p>  J'ai compris que le traitement correct et rapide de toutes les commandes n'est pas une tâche facile.  J'ai donc décidé de chercher une bibliothèque toute faite.  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voilà</a> , je suis immédiatement tombé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xterm.js</a> .  Un composant prêt à l'emploi du terminal, qui est déjà utilisé dans de nombreux endroits et, en plus, <em>"est vraiment rapide, il inclut même un moteur de rendu accéléré par GPU"</em> .  Ce dernier était le plus important pour moi, car  Je voulais enfin avoir un client très rapide. </p><br><p>  Malgré le fait que j'aime écrire mes propres vélos, j'étais extrêmement heureux de pouvoir non seulement gagner du temps, mais également obtenir un tas de fonctionnalités utiles gratuitement. </p><br><p>  Il m'a fallu 14 heures pour essayer de connecter le terminal et je n'ai <strong>pas pu y</strong> faire face.  Absolument. <br>  Différentes hauteurs de ligne, sélection tordue, taille adaptative du terminal, une API très étrange, manque de documentation saine ... </p><br><p>  Mais j'avais encore un peu d'inspiration et je pensais pouvoir faire face à ces problèmes. <br>  Jusqu'à ce que j'alimente mes 10 000 lignes de test au terminal ... Il est mort.  Et enterré avec moi les restes de mes espoirs. </p><br><h2 id="opisanie-itogovogo-algoritma">  Description de l'algorithme final </h2><br><p>  Tout d'abord, j'ai copié l'algorithme actuel implémenté en python et l'ai adapté pour javascript (en supprimant simplement les accolades et un autre pour la syntaxe). </p><br><p>  Je connaissais tous les principaux avantages et inconvénients de l'ancien algorithme, donc je n'avais qu'à améliorer les endroits inefficaces. </p><br><p>  Après délibération, essais et erreurs, j'ai opté pour l'option suivante: on divise l'algorithme en 2 composantes: </p><br><ul><li>  modèle pour analyser le texte et stocker l'état actuel du "terminal" </li><li>  mappage qui traduit le modèle en HTML </li></ul><br><h4 id="model-struktura-i-algoritm">  Modèle (structure et algorithme) </h4><br><ul><li>  Toutes les lignes sont stockées dans un tableau (numéro de ligne = index dans le tableau) </li><li>  Les styles de texte sont stockés dans un tableau séparé. </li><li>  La position actuelle du curseur est stockée et peut être modifiée par des commandes </li><li>  L'algorithme lui-même vérifie les données d'entrée caractère par caractère: <br><ul><li>  Si ce n'est que du texte, ajoutez à la ligne actuelle </li><li>  En cas de saut de ligne, augmentez l'index de ligne en cours </li><li>  S'il s'agit d'un des caractères de commande, nous le mettons dans le tampon de commande et attendons le caractère suivant </li><li>  Si le tampon de commande est correct, exécutez cette commande, sinon nous écrivons ce tampon sous forme de texte </li></ul></li><li>  Le modèle informe les auditeurs des lignes qui ont changé après le traitement du texte entrant </li></ul><br><p>  Dans mon implémentation, la complexité de l'algorithme est O ( <em>n</em> log <em>n</em> ), où log <em>n</em> est la préparation des lignes modifiées pour la notification (unicité et tri).  Au moment d'écrire ces lignes, j'ai réalisé que pour un cas particulier, vous pouvez vous débarrasser de log <em>n</em> , car les lignes sont le plus souvent ajoutées à la fin. </p><br><h4 id="otobrazhenie">  Affichage </h4><br><ul><li>  Affiche le texte sous forme d'éléments HTML </li><li>  Si la chaîne a changé, remplace complètement tous les éléments de la chaîne </li><li>  Coupe chaque ligne en fonction des styles: chaque segment stylisé a son propre élément </li></ul><br><p>  Avec une telle structure, le test est une tâche assez simple - nous transférons le texte vers le modèle (dans un seul package ou en parties) et vérifions simplement l'état actuel de toutes les lignes et styles qu'il contient.  Et pour n'afficher que quelques tests, car  il redessine toujours les lignes modifiées. </p><br><p>  Un avantage important est également une certaine paresse de l'affichage.  Si, dans un morceau de texte, nous remplaçons la même ligne (par exemple, la barre de progression), après que le modèle fonctionne, pour l'affichage, il ressemblera à une ligne modifiée. </p><br><h4 id="dom-vs-canvas">  DOM vs Canvas </h4><br><p>  Je voudrais insister un peu sur la raison pour laquelle j'ai choisi le DOM, bien que l'objectif soit la performance.  La réponse est simple - la paresse.  Pour moi, le rendu de tout dans Canvas par moi-même semble être une tâche assez intimidante.  Tout en conservant la convivialité: mise en évidence, copie, redimensionnement de l'écran, apparence soignée, etc.  L'exemple xterm.js m'a clairement montré que ce n'est pas facile du tout.  Leur rendu sur toile était loin d'être idéal. </p><br><p>  De plus, le débogage de l'arborescence DOM dans le navigateur et la possibilité de couvrir les tests unitaires est un avantage important. </p><br><p>  Au final, mon objectif était de 50k lignes, et je savais que le DOM devait y faire face, basé sur le travail de l'ancien algorithme. </p><br><h2 id="optimizacii">  Optimisations </h2><br><p>  L'algorithme était prêt, débogué et fonctionnait lentement mais sûrement.  Il était temps d'ouvrir le profileur et d'optimiser.  Pour l'avenir, je dirai que la plupart des optimisations ont été une surprise pour moi (comme cela arrive généralement). </p><br><p>  Le profilage a été effectué sur 10 000 lignes, chacune contenant des éléments stylisés.  Le nombre total d'éléments DOM est d'environ 100k. </p><br><p>  Aucune approche et aucun outil spécial n'ont été utilisés.  Seulement Chrome Dev Tools et quelques lancements pour chaque mesure.  En pratique, lors des lancements, seules les valeurs absolues des mesures (combien de secondes à compléter) différaient, mais pas le rapport en pourcentage entre les méthodes.  Par conséquent, je considère que cette technique est conditionnellement suffisante. </p><br><p>  Ci-dessous, je voudrais m'attarder plus en détail sur les améliorations les plus intéressantes.  Et pour commencer, un graphique de ce qui était: <br><img src="https://habrastorage.org/webt/me/xk/ot/mexkotdhezc4pwxhw4xczkzv9ie.png"></p><br><p>  <em>Tous les graphiques de profilage ont été créés après la mise en œuvre, en désoptimisant le code de la mémoire.</em> </p><br><h4 id="stringtrim">  string.trim </h4><br><p>  Tout d'abord, je suis tombé sur un string.trim incompréhensible qui consommait une quantité très importante de CPU (il me semble que c'était environ 10-20%) <br><img src="https://habrastorage.org/webt/ue/nq/6b/uenq6brmlm8fxzxxjklulp7ccly.png"></p><br><p>  trim () est la fonction de base du langage.  Pourquoi utilise-t-il une sorte de bibliothèque?  Et même s'il s'agit d'une sorte de polyfill, pourquoi a-t-il activé la dernière version de Chrome? </p><br><p> Un peu sur Google et la réponse se trouve: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://babeljs.io/docs/en/babel-preset-env</a> .  Par défaut, il active le polyfill pour un nombre assez important de navigateurs, et le fait au stade de la compilation.  La solution pour moi était de spécifier des <code>'targets': '&gt; 0.25%, not dead'</code> <br>  Mais à la fin, j'ai supprimé complètement l'appel de trim, car inutile. </p><br><h4 id="vuejs">  Vue.js </h4><br><p>  L'année dernière, j'ai transféré le composant terminal vers Vue.js.  Maintenant, je devais le transférer à vanilla, la raison est dans la capture d'écran ci-dessous (voir le nombre de lignes impliquant Vue.js): </p><br><p><img src="https://habrastorage.org/webt/ll/oq/i8/lloqi8k2igkme2q616eooswyogg.png"></p><br><p>  Je n'ai laissé que le wrapper, les styles et le traitement de la souris dans le composant Vue.  Tout ce qui concerne la création d'éléments DOM est entré dans JS pur, qui est connecté au composant Vue comme un champ normal (qui n'est pas surveillé par le framework). </p><br><pre> <code class="plaintext hljs">created() { this.terminalModel = new TerminalModel(); this.terminal = new Terminal(this.terminalModel); },</code> </pre> <br><p>  Je ne considère pas cela comme un inconvénient ou un défaut dans Vue.js.  C'est juste que les frameworks et les performances eux-mêmes ne se mélangent pas bien.  Eh bien, lorsque vous déposez des dizaines et des centaines de milliers d'objets dans un cadre réactif, il est très difficile de s'attendre à un traitement de celui-ci en quelques millisecondes.  Et pour être honnête, je suis même surpris que Vue.js se soit plutôt bien débrouillé. </p><br><h4 id="dobavlenie-novyh-elementov">  Ajout de nouveaux éléments </h4><br><p>  Tout est simple ici - si vous avez plusieurs milliers de nouveaux éléments et que vous souhaitez les ajouter au composant parent, faire appendChild n'est pas une bonne idée.  Le navigateur doit effectuer le traitement un peu plus souvent et consacrer plus de temps au rendu.  L'un des effets secondaires de mon cas a été un ralentissement du défilement automatique,  il force un recomptage de tous les composants ajoutés. </p><br><p><img src="https://habrastorage.org/webt/v_/5k/uj/v_5kujs_plen-j5zoxhq0ixv9um.png"></p><br><p>  Pour résoudre le problème, il existe un DocumentFragment.  Tout d'abord, nous y ajoutons tous les éléments, puis nous l'ajoutons au composant parent.  Le navigateur s'occupera de l'inline des composants entrants. </p><br><p>  Cette approche réduit le temps que le navigateur passe à rendre et à organiser les éléments. <br>  J'ai également essayé d'autres façons d'accélérer l'ajout d'éléments.  Aucun d'entre eux n'a pu ajouter quoi que ce soit au-dessus du DocumentFragment. </p><br><h4 id="span-vs-div">  span vs div </h4><br><p>  En fait, cela pourrait être appelé <code>display:inline</code> (span) vs <code>display:block</code> (div). </p><br><p>  Au départ, j'avais toutes les lignes de l'intervalle et je me suis terminé avec un caractère de saut de ligne.  Cependant, en termes de performances, ce n'est pas très efficace: le navigateur doit déterminer où l'élément commence et se termine.  Avec display: block, ces calculs sont beaucoup plus simples. </p><br><p>  Remplacer par un rendu accéléré par div de près de 2 fois. </p><br><p>  Malheureusement, dans le cas de l' <code>display:block</code> mise en surbrillance de plusieurs lignes de texte semble pire: </p><br><p><img src="https://habrastorage.org/webt/dm/kj/nq/dmkjnq9up61pc-ic0jalnfi3jw8.png"></p><br><p>  Pendant longtemps, je n'ai pas pu décider ce qui est le mieux - 2 secondes supplémentaires de rendu ou de sélection humaine.  En conséquence, l'aspect pratique a vaincu la beauté. </p><br><h4 id="master-css-10-go-urovnya">  Assistant CSS de niveau 10 </h4><br><p>  Un autre ~ 10% du temps de rendu a été coupé par l '"optimisation" CSS, que j'utilise pour formater le texte. </p><br><p>  L'inexpérience dans le développement Web et la compréhension des bases ont joué contre moi.  Je pensais que plus les sélecteurs étaient précis, mieux c'était, mais spécifiquement dans mon cas, ce n'était pas le cas. </p><br><p>  Pour formater le texte dans le terminal, j'ai utilisé les sélecteurs suivants: </p><br><pre> <code class="plaintext hljs">#script-panel-container .log-content &gt; div &gt; span.text_color_green,</code> </pre> <br><p>  Mais (en chrome), l'option suivante est un peu plus rapide: </p><br><pre> <code class="plaintext hljs">span.text_color_green</code> </pre> <br><p>  Je n'aime pas vraiment ce sélecteur, car  trop global, mais les performances sont plus chères. </p><br><h4 id="stringsplit">  string.split </h4><br><p>  Si vous avez un déjà-vu dû à l'un des points précédents, alors c'est faux.  Cette fois, il ne s'agit pas de polyfill, mais de l'implémentation standard dans Chrome: </p><br><p><img src="https://habrastorage.org/webt/i8/jk/lh/i8jklht2lc0hhc9h6p1la3zuk6o.png"></p><br><p>  <em>(J'ai enveloppé string.split dans defSplit pour que la fonction apparaisse dans le profileur)</em> </p><br><p>  1% sont des bagatelles.  Mais le cycliste idéaliste en moi était hanté.  Dans mon cas, le split se fait toujours un caractère à la fois et sans habitués.  Par conséquent, j'ai implémenté une option simple.  Voici le résultat: </p><br><p><img src="https://habrastorage.org/webt/hu/fd/_r/hufd_rbij0khcfqcudcnpfkjisa.png"></p><br><div class="spoiler">  <b class="spoiler_title">fastSplit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function fastSplit(str, separatorChar) { if (str === '') { return ['']; } let result = []; let lastIndex = 0; for (let i = 0; i &lt; str.length; i++) { const char = str[i]; if (char === separatorChar) { const chunk = str.substr(lastIndex, i - lastIndex); lastIndex = i + 1; result.push(chunk); } } if (lastIndex &lt; str.length) { const lastChunk = str.substr(lastIndex, str.length - lastIndex); result.push(lastChunk); } return result; }</code> </pre> </div></div><br><p>  Je pense qu'après cela, ils sont obligés de m'emmener dans l'équipe Google Chrome sans entretien. </p><br><h4 id="optimizaciya-posleslovie">  Optimisation, postface </h4><br><p>  L'optimisation est un processus sans fin et quelque chose peut être amélioré indéfiniment.  Surtout si l'on considère que les différents cas d'utilisation nécessitent des optimisations différentes (et conflictuelles). </p><br><p>  Pour mon cas, j'ai choisi le cas d'utilisation principal et optimisé son temps de fonctionnement de 15 secondes à 5 secondes.  Sur ce, j'ai décidé d'arrêter. <br><img src="https://habrastorage.org/webt/ol/ri/j3/olrij3u8nfgpdrbm5-0db4vkpra.png"></p><br><p>  Il y a encore quelques endroits que je prévois d'améliorer, mais c'est grâce à l'expérience acquise. </p><br><h2 id="bonus-mutacionnoe-testirovanie">  Bonus  Test de mutation. </h2><br><p>  Il est arrivé qu'au cours des derniers mois, je suis souvent tombé sur le terme «test mutationnel».  Et j'ai décidé que cette tâche était un excellent moyen d'essayer cette bête.  Surtout après que je n'ai pas eu de couverture de code dans Webstorm, pour des tests sur le karma. </p><br><p>  Comme la technique et la bibliothèque sont nouvelles pour moi, j'ai décidé de m'en sortir avec un peu de sang: pour tester un seul composant - le modèle.  Dans ce cas, vous pouvez clairement indiquer quel fichier nous testons et quelle suite de tests lui est destinée. </p><br><p>  Mais quoi qu'on en dise, j'ai dû beaucoup bricoler pour réussir l'intégration avec le karma et le webpack. </p><br><p>  Finalement, tout a commencé et après une demi-heure, j'ai vu de tristes résultats: environ la moitié des mutants ont survécu.  J'ai tué une partie immédiatement, une partie laissée pour l'avenir (lorsque j'ai implémenté les commandes ANSI manquantes). </p><br><p>  Après cela, la paresse a gagné, et pour le moment les résultats sont les suivants (pour 128 tests): </p><br><pre> <code class="plaintext hljs">Ran 79.04 tests per mutant on average. ------------------|---------|----------|-----------|------------|---------| File | % score | # killed | # timeout | # survived | # error | ------------------|---------|----------|-----------|------------|---------| terminal_model.js | 73.10 | 312 | 25 | 124 | 1 | ------------------|---------|----------|-----------|------------|---------| 23:01:08 (18212) INFO Stryker Done in 26 minutes 32 seconds.</code> </pre> <br><p>  En général, cette approche m'a semblé très utile (évidemment meilleure que la couverture du code) et drôle.  Le seul point négatif est un temps terriblement long - 30 minutes par classe, c'est trop. </p><br><p>  Et surtout, cette approche m'a fait repenser à 100% de couverture et à savoir s'il vaut la peine de tout couvrir avec des tests: maintenant mon avis est encore plus proche de «oui» en répondant à cette question. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  L'optimisation des performances, à mon avis, est un bon moyen d'apprendre plus profondément.  C'est aussi un bon entraînement pour le cerveau.  Et il est très regrettable que cela soit rarement vraiment nécessaire (au moins dans mes projets). </p><br><p>  Et comme toujours, l'approche «premier profilage, puis optimisation» fonctionne bien mieux que l'intuition. </p><br><h4 id="ssylki">  Les références </h4><br><p>  Ancienne implémentation: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">terminal_formatter.py</a> </li><li>  <a href="">log_panel.vue</a> </li></ul><br><p>  Nouvelle implémentation: </p><br><ul><li>  <a href="">terminal_model.js</a> </li><li>  <a href="">terminal_view.js</a> </li></ul><br><p>  Malheureusement, il n'y a pas de démonstration de composant Web, vous ne pourrez donc pas le faire.  Je m'excuse donc à l'avance </p><br><p>  Merci pour votre temps, je serai heureux de commentaires, suggestions et critiques raisonnables! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448030/">https://habr.com/ru/post/fr448030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448016/index.html">Analyse clinique de l'urine à domicile sur des bandelettes de test: avantages et inconvénients</a></li>
<li><a href="../fr448018/index.html">Événements numériques à Moscou du 15 avril au 21 avril</a></li>
<li><a href="../fr448022/index.html">Compilateur angulaire 200 lignes</a></li>
<li><a href="../fr448024/index.html">Les régulateurs européens s'opposent aux bannières de cookies</a></li>
<li><a href="../fr448026/index.html">Projet logiciel et OOP Evolution</a></li>
<li><a href="../fr448032/index.html">Plus de robots: Walmart présente des milliers de machines pour fonctionner dans ses magasins</a></li>
<li><a href="../fr448034/index.html">Recherche de tâches dans JIRA (langage simple). Partie 1: Recherche rapide et basique</a></li>
<li><a href="../fr448036/index.html">Importer vers J. Connect à partir du fichier de liste d'utilisateurs via l'API</a></li>
<li><a href="../fr448038/index.html">Nouvelles fonctionnalités pour les auteurs d'extensions dans Visual Studio 2019 v.16.1</a></li>
<li><a href="../fr448040/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 294 (du 8 au 14 avril)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>