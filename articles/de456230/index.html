<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 👩🏾‍💻 🐭 Iobroker-Suche nach Quests in Reality-Spielen 🥙 🛴 👌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, es gibt bereits mehrere Artikel über Habré über die Automatisierung von Spielen wie "Quests in Reality" ( eins , zwei , drei , vier ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Iobroker-Suche nach Quests in Reality-Spielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iobroker/blog/456230/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/c3/od/fgc3od3po8up_if_whhozn-7m6q.png"></div><br>  Hallo allerseits, es gibt bereits mehrere Artikel über Habré über die Automatisierung von Spielen wie "Quests in Reality" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fünf</a> ...). Ich möchte auch meine Erfahrungen mit der Teilnahme an einem solchen Projekt teilen.  Im Jahr 2015 beschlossen meine Freunde, eine Fluchtraum-Quest „Banküberfall“ in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserer</a> Stadt zu organisieren.  Sie wussten, dass ich schon lange verschiedene Automatisierungen mochte, darunter Systeme wie "Smart Home", die auf Open Source-Lösungen basieren, und baten um Hilfe bei der Organisation des Spiels.  Diese Idee schien mir interessant und ich stimmte zu - ich wollte meine Erfahrungen und Lösungen für etwas Interessanteres einsetzen, als eine Glühbirne in meiner Wohnung zu blinken. <br><br>  Ich habe versucht, am gesamten Zyklus des Projekts teilzunehmen - von Änderungen am Skript bis zu den nächsten Einlaufaufgaben, dem Erkennen und Beheben von Fehlern und nachfolgenden Verbesserungen.  Ich habe mehrere Spiele in unserer Stadt besucht (2015 konnten sie an den Fingern einer Hand gezählt werden), nicht für den Fan, sondern um Erfahrungen zu sammeln und Lösungen zurückzuentwickeln, und dies wurde durch die Reaktion der Organisatoren deutlich sichtbar.  Aber nachdem ich in Moskau am Spiel teilgenommen hatte, verstand ich das wahre Ausmaß der „Katastrophe“ und wollte meinen Job wirklich nicht schlechter machen als die technische Seite.  Bei der Suche nach „Rob the Bank“ in Tver nach Einzelheiten darüber, wie es im Laufe mehrerer Jahre geschaffen und entwickelt wurde, frage ich nach Katze. <br><a name="habracut"></a><br><h4>  Beschreibung der technischen Lösungen </h4><br>  Nachdem meine Kollegen mir an den Fingern erklärt hatten, was sie von mir wollen und wie alles funktionieren sollte, nahm in meinem Kopf buchstäblich in wenigen Minuten eine Architektur Gestalt an: ein zentraler Server mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ioBroker-</a> Plattform, lokale Controller auf Basis von Arduino-Boards und -Modulen, Datenaustausch mit Server und zwischen Controllern, die das MQTT-Protokoll verwenden.  Infolgedessen stellte sich heraus, dass die Architektur ungefähr wie folgt aussah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mo/mp/0a/momp0a7_im8_giwhie2b3hbmev8.png"></div><br>  Zusätzlich zur Interaktion des Task-Controllers mit dem zentralen Server musste eine Interaktion zwischen den Controllern verschiedener Quest-Aufgaben hergestellt werden.  Hierfür war meiner Meinung nach das MQTT-Protokoll mit einem Broker auf einem zentralen Server ideal geeignet.  Clients - Controller veröffentlichen ihre Status auf dem Server, abonnieren Befehle vom Server und die Status anderer Controller.  Um diese Lösung zu implementieren, wurde der <a href="">MQTT-</a> Adapter verwendet - er war auch ein MQTT-Broker und ermöglichte es Ihnen, eine Hierarchie von Themen im ioBroker-Objektbaum zu erstellen, um die Daten für die Visualisierung und Verwaltung zu verwenden (ein Screenshot unter der alten Version des „Admin-Panels“). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/k7/xe/ihk7xewvzvrpfeznzus4lnzciwc.png"></div><br>  In der Folge habe ich es nicht bereut, dass ich mich für eine solche Lösung entschieden habe: <br><br><ol><li>  MQTT ist ein leichtes Protokoll, die Bibliothek nahm wenig Platz ein und war selbst für die Arduino UNO mit dem ATmega328-Chip mehr als genug </li><li>  Beim ersten Neustart oder Einschalten der Steuerungen erhielten sie die Anfangsbedingungen für den Beginn der Arbeit mit MQTT - dies ist sehr praktisch </li><li>  Diese Lösung erwies sich als die zuverlässigste der getesteten und für Anfänger recht einfach zu implementieren und zu studieren </li></ol><br>  Nur wenige Optionen werden von Datenströmen erhalten, die einfachste davon - ein Ereignis tritt in Task-Controller Nr. 1 auf (eine Taste wird gedrückt), es veröffentlicht den Schaltflächenstatus in einem bestimmten Thema und sein Status wird angezeigt, indem die Farbe eines grafischen Elements in der visuellen Form des Bedieners geändert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vz/wq/6d/vzwq6ddn8r6k3oop3dwne8aceyc.png"></div><br>  Eine ebenso einfache und entgegengesetzte Option besteht darin, dass Sie das Relais manuell über Task-Controller Nr. 1 einschalten müssen. Ein Steuerereignis wird über den VIS-Adapter bereitgestellt, der den Status des Themas dieses Controllers ändert, und mit ask = false.  Der MQTT-Adapter empfängt eine Themenänderung mit ask = false, sodass dieses Thema nicht vom Controller eingetroffen ist. Die Änderung wird auf dem Controller veröffentlicht, der wiederum eine Bestätigung mit ask = true als Antwort veröffentlicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0h/je/cn/0hjecnoulb2wclpaqdc75feea8u.png"></div><br>  Der Intercontroller-Austausch erfolgt bei einem Ereignis auf einem der Controller.  Beispielsweise hat der erste Controller seine Aufgabe erfüllt und muss das Relais auf dem zweiten Controller einschalten - er veröffentlicht seinen Status im allgemeinen Thema, der Broker zeigt ihn in der Baumstruktur und auf der Visualisierungsseite an, da der zweite Controller dieses Thema abonniert hat, der Broker veröffentlicht ihn auf dem zweiten Controller und Letzterer veröffentlicht seinerseits eine Bestätigungsantwort. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cy/di/wn/cydiwndhin0xlgnbhd8v_fyeuqq.png"></div><br>  Das Projekt musste noch die Aufgabe der Interaktion mit einem Computer hinzufügen.  Die Oberfläche wurde in PHP geschrieben, die Seite drehte sich auf einem WEB-Server mit Autorun im Vollbild-Browsermodus.  Die Integration mit dem Hauptsystem erfolgte mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simple-API-</a> Treiber - bestimmte PHP-Anfragen an ioBroker zuckten einfach über PHP.  Die Systemeinheit selbst war im Darm des Schreibtischs versteckt, die Schnittstelle wurde mit der Maus gesteuert und der Quest-Dispatcher verfügte über eine drahtlose Tastatur. <br><br>  Die Visualisierung für den Bediener wurde im <a href="">VIS-</a> Treiber für eine Auflösung entwickelt - den Monitor des Bedieners. Anschließend konnten die Questmitarbeiter mobile Tablets mit derselben Benutzeroberfläche verwenden. Dies erwies sich als praktisch zum Zurücksetzen, um ein neues Spiel vorzubereiten und das System zu diagnostizieren.  Die Benutzeroberfläche erwies sich als spartanisch, ohne modische Dashboards und Ryushek-Schalter, aber verständlich, einfach und schnell.  Es waren keine spezielle Logik, Ebenen, Diagramme oder andere Elemente in der Benutzeroberfläche erforderlich, nur Symbole zur Anzeige des Gerätestatus, Schaltflächen zur Steuerung und mehrere Textfelder zur Anzeige des Betriebsmodus der Steuerungen und des Systembetriebsprotokolls. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/pt/wd/h1ptwd6tcgfwse0uufj2euz0q3k.png"></div><br>  Zum Zeitpunkt der Entwicklung des Projekts gab es keine anderen Optionen für das Visualisierungsdesign.  Später erschienen Visualisierungsadapter sowohl für mobile Geräte (ich verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> ) als auch für stationäre Tablets / Computer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habpanel</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lovelace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tileboard</a> und andere. <br>  Die Hauptlogik wurde im Code der Steuerungen festgelegt, aber die allgemeine Interaktion, Initialisierung der Parameter zum Starten, Servicefunktionen usw. wurde auf dem Hauptserver mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Javascript-</a> Adapters implementiert.  Der Code wurde in JS mit den integrierten ioBroker- <a href="">Funktionen geschrieben</a> , gefolgt von einem "Verschieben" zum <a href="">Blockieren</a> (diese Funktionalität erschien später als der Beginn der Arbeit am Projekt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zf/16/jf/zf16jfzepkmpevwz7crduo1eouc.png"></div><br>  Insgesamt waren mehrere Skripte beteiligt: <br><br><ol><li>  Skript für die anfängliche Systeminitialisierung (erste Aufnahme) </li><li>  Skript zum Zurücksetzen aller Controller vor dem nächsten Spiel </li><li>  Da einer der Controller nicht sofort zu MQTT "verschoben" wurde, wurde für einige Zeit ein Skript verwendet, um über HTTP-GET-Anforderungen mit dem Controller auszutauschen </li><li>  Skript zum Verwalten eines separaten Protokolls des Gameplays </li></ol><br>  Alle auf Arduino UNO-Karten basierenden Controller (später mussten mehrere Controller auf Arduino MEGA-Karten umgestellt werden - es gab nicht genügend Speicher) waren mit einer Ethernet-Erweiterungskarte auf Basis des W5100-Chips ausgestattet.  Datenaustausch zwischen Controllern und dem Server (wie oben beschrieben) unter Verwendung des MQTT-Protokolls.  Die Entwicklung von Algorithmen in der Arduino IDE wurde unter Verwendung von Standardbibliotheken durchgeführt.  Auf der Eisenseite gibt es nichts Übernatürliches - die maximale Verwendung von vorgefertigten Modulen und Erweiterungskarten mit einem Minimum an Löten und ohne die Herstellung von kundenspezifischen Platinen - alles auf Steckbrettern.  Lastmanagement durch Module mit konventionellen und Halbleiterrelais, Transistorschaltern für LED-Anzeigen und Lasten mit geringem Stromverbrauch.  Beim mechanischen Teil habe ich versucht, bewegliche Elemente so wenig wie möglich zu verwenden: Mikroschalter, Drücker, E / M-Schlösser und vorgefertigte LED-Fotodiodenmodule (offene Optokoppler), Halbleiterrelais, herkömmliche Magnetschlösser, Näherungskartenleser und Reedsensoren.  Ein paar Fotos unten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/ba/2u/emba2uqyqonrildjkuasukjcfzi.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f5/yi/g2/f5yig2rz9m0lhxzashj34kkw9xi.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/xe/fl/7txefleidqfbnndt1kab1mykooi.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/gf/ip/apgfipsup1kxphohjg4genozfcs.jpeg"></div><br>  Vor-Ort-Controller wurden über hausgemachte POE-Adapter mit Strom versorgt - Twisted-Pair-Kabel verwendeten Leerlaufkerne, um 12-V-Gleichstrom zu übertragen.  Konvertierung auf Controller-Karten durch vorgefertigte DC-DC-Karten bis zu 5 V - von denen Arduino + Ethernet-Karten selbst und Niedrigleistungslast mit 5 V-Logik gespeist wurden: Niedrigstrom-LEDs, Relais usw. Stärkere 12 V-Last: Magnetschlösser, leistungsstarke Relais oder Schütze, verschiedene Beleuchtungsgeräte - Separate Kabelleitungen wurden mit einer Kugelumlaufspindel oder einem PVA-Draht verwendet.  Zwei 220-V-Wechselstromeingänge wurden in den Hauptautomatisierungsschrank gebracht, und eine USV wurde über Schütze an den Schützen angeschlossen, die wiederum über einen Bypass angeschlossen wurden, um die Wartung zu vereinfachen.  Um die gesamte Automatisierung und Niederspannung mit Strom zu versorgen, wurden im Schrank leistungsstarke 2-Volt-Netzteile installiert, 2 x 12 V und 1 x 5 V.  Vom Automationsschrank aus starteten sie 220 V-Kabel für die Stromversorgung von Computern und verschiedenen Peripheriegeräten der Suche: von Puff-Puff bis Viu-Viu)) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pd/vt/tl/pdvttlnqsbxjljdpbpvwvwznyya.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cb/vj/gt/cbvjgtckvyjobgbe65vltwoprhy.jpeg"></div><br>  Die restlichen Lösungen sind für solche Projekte ziemlich Standard.  Videoüberwachungssystem für kabelgebundene IP-Kameras, immer mit IR-Beleuchtung und eingebauten Mikrofonen.  Der Videostream wird in einer der Questaufgaben verwendet und zusätzlich auf dem PC des Questmanagers verarbeitet. Open Source-Software (ZoneMinder) wird verwendet.  Das lokale Netzwerk der Arduino-Controller wurde vom Rest der Netzwerke getrennt, damit der Stream von den Kameras die bereits schwachen W5100-Chips von Ethernet-Boards nicht lädt. <br><br>  Freisprechen mit Spielteilnehmern mit einem herkömmlichen sowjetischen Verstärker und eingebauten Deckenlautsprechern. <br><br>  Am Ende wollte ich einen kleinen zentralen Server beschreiben.  Die ioBroker-Plattform wird auf der BananaPi ARM-Einzelplatine bereitgestellt, deren Leistung sich für alle Aufgaben als ausreichend herausstellte.  Die Umgebung ist das Armbian-Betriebssystem, ein paar Bash-Skripte für die Arbeit mit GPIO und für die Erstellung von Backups in der Cloud auf Yandex.Disk.  Mehrere GPIOs werden verwendet, um den Betriebsstatus einzelner Module und Adapter (LEDs) anzuzeigen, und eine Taste, um das System korrekt auszuschalten.  Auf dem Foto des 19-Zoll-Gehäuses oben ist zu sehen, dass sich die Platine in einem billigen Plexiglasgehäuse befindet, das später in einem 1U-Gehäuse mit normaler Stromversorgung und anderen Peripheriegeräten installiert wurde. <br><br><h4>  Bugs, Fallstricke, Schwierigkeiten </h4><br>  Meine Kollegen und ich haben die grundlegende Architektur ziemlich lange im Voraus durchdacht (ich habe das Projekt durchgeführt) und viele Knoten wurden „auf dem Tisch“ zusammengesetzt und getestet, sodass es keine grundlegenden Änderungen gab.  Kleinere „Rauheiten“ wurden an Ort und Stelle behoben.  Die Hauptprobleme, deren Lösung viel Zeit in Anspruch nahm: <br><br><ol><li>  Mangel an Arduino-Speicher auf 328-Chip, Umzug auf Arduino-MEGA-Karte.  Vorhersehbar ruhte auf einigen Controllern im Chipspeicher.  Die meiste Zeit wurde für die Überarbeitung der Erweiterungskarten aufgewendet. </li><li>  Probleme bei der Arbeit mit dem MQTT-Treiber wurden vom Autor des ioBroker-Projekts ziemlich schnell behoben. </li><li>  Der lange und schwierige Prozess der Auswahl eines Browsers für die normale Visualisierung im VIS-Treiber.  Es stellte sich als schwierig heraus, mit diesem Adapter zu arbeiten.  Infolgedessen wurde die Bearbeitung im Chrome-Browser durchgeführt, und der Laufzeitoperator startete eine bestimmte Version über den Dragon-Browser.  Da die Fehler behoben wurden, wurden sie vollständig auf den neuesten Chrome-Browser verschoben. </li><li>  Allmähliche Entwicklung von Anti-Vandalismus-Lösungen - aufgegebene Mikroschalter, mechanische Tasten und Drücker, Filmtastaturen usw. </li><li>  Die elektromechanischen Schlösser des Sheriffs erwiesen sich als von sehr geringer Qualität, sie mussten lokal durch gewöhnliche elektromagnetische Schlösser ersetzt werden. </li><li>  Der instabile Betrieb von Arduino-Controllern bei der Arbeit mit IP-Kameras führte dazu, dass die Netzwerke geteilt wurden und alles so funktionierte, wie es sollte. </li></ol><br><h4>  Fazit </h4><br>  Das gesamte Projekt, vom Studium und der Vereinbarung des Szenarios bis zum Start der ersten Testgruppen, dauerte ungefähr sechs Monate - viel, aber es war die erste Erfahrung, und außerdem habe ich fast mit den Hauptarbeiten zum Bau / zur Reparatur der Räumlichkeiten Schritt gehalten.  Außerdem gab es viel Arbeit "auf dem Tisch" - hauptsächlich bei Verwendung separater Arduino-Module, da diese nicht genau so funktionierten, wie ich es erwartet hatte.  Bei der Umsetzung des Projekts haben wir versucht, die folgenden Grundsätze so weit wie möglich einzuhalten: <br><br><ol><li>  Das Projekt beinhaltete Wartung und kleinere Reparaturen durch jeden Ingenieur, der mindestens einmal einen Lötkolben in den Händen hielt, weiß, was Arduino ist und in der Lage sein wird, die auf der Platine gelötete LED zu „blinken“. </li><li>  Entwicklung in Arduino IDE unter Verwendung von Standardbibliotheken für maximale Einfachheit. </li><li>  Maximieren Sie die Verwendung von handelsüblichen Standardmodulen in einem Projekt, um die Wartung und den Austausch zu vereinfachen </li><li>  Verwenden Sie Standardprotokolle und Datennetze </li><li>  Minimieren Sie die Anzahl der mechanischen Teile, um Haltbarkeit und Vandalismus zu gewährleisten. </li></ol><br>  Infolgedessen stellte sich heraus, dass in den ersten Wochen alle geringfügigen Mängel beseitigt wurden, und jetzt funktioniert das System seit fast 4 Jahren in fast der ursprünglichen Umgebung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456230/">https://habr.com/ru/post/de456230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456218/index.html">.NET Core 3.0 (Vorschau 6) veröffentlicht</a></li>
<li><a href="../de456220/index.html">Verallgemeinerung des Brokar-Problems</a></li>
<li><a href="../de456222/index.html">Die Gentechnik menschlicher Embryonen wird in zwei Jahren sicher und wirksam</a></li>
<li><a href="../de456224/index.html">Ankündigung der .NET Core 3.0-Vorschau 6</a></li>
<li><a href="../de456226/index.html">Vorhersage der Fußballergebnisse</a></li>
<li><a href="../de456232/index.html">Anleitung: Aktualisieren von Schnittstellen mit Standardmitgliedern in C # 8.0</a></li>
<li><a href="../de456234/index.html">Warum kauft Cisco Splunk nicht oder spricht nicht darüber, wie die Cisco-Plattform für die Bedrohungssuche funktioniert?</a></li>
<li><a href="../de456236/index.html">Peter - Insider Dev Tour: Insiderkonferenz für Entwickler von Microsoft</a></li>
<li><a href="../de456238/index.html">Tutorial: Aktualisieren Sie Schnittstellen mit Standardschnittstellenmitgliedern in C # 8.0</a></li>
<li><a href="../de456240/index.html">Chatbot-Entwicklung (Laravel + Botman)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>