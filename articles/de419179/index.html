<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸 🌓 🏘️ Reine pragmatische Architektur. Brainstorming 🏇 🥙 🎾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ist Ihnen die Idee gekommen, Ihre mutige Unternehmensanwendung von Grund auf neu zu schreiben? Wenn von Grund auf neu, dann ist es wow. Mindestens zwe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reine pragmatische Architektur. Brainstorming</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419179/">  Ist Ihnen die Idee gekommen, Ihre mutige Unternehmensanwendung von Grund auf neu zu schreiben?  Wenn von Grund auf neu, dann ist es wow.  Mindestens zweimal weniger Code, oder?  Aber ein paar Jahre werden vergehen und es wird auch wachsen, Vermächtnis werden ... es gibt nicht viel Zeit und Geld für das perfekte Umschreiben. <br><br>  Beruhige dich, die Behörden werden immer noch nicht erlauben, etwas umzuschreiben.  Es bleibt zu refactor.  Was ist der beste Weg, um Ihre kleinen Ressourcen auszugeben?  Wie kann ich umgestalten, wo gereinigt werden soll? <br><br>  Der Titel dieses Artikels enthält einen Verweis auf Onkel Bobs Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Clean Architecture"</a> und wurde auf der Grundlage eines wunderbaren Berichts von Victor Rentea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> ) über JPoint erstellt (unter der Katze wird er in der ersten Person sprechen, aber vorerst die einleitende lesen).  Dieser Artikel, der intelligente Bücher liest, ersetzt ihn nicht, ist aber für eine so kurze Beschreibung sehr gut dargelegt. <br><br>  Die Idee ist, dass beliebte Dinge wie „Saubere Architektur“ wirklich nützlich sind.  Überraschung  Wenn Sie ein ganz bestimmtes Problem lösen müssen, erfordert ein einfacher, eleganter Code keinen zusätzlichen Aufwand und keine Überentwicklung.  Die reine Architektur besagt, dass Sie Ihr Domänenmodell vor externen Effekten schützen müssen, und erklärt Ihnen genau, wie dies getan werden kann.  Ein evolutionärer Ansatz zur Erhöhung des Volumens von Mikrodiensten.  Tests, die das Refactoring weniger beängstigend machen.  Weißt du das alles schon?  Oder wissen Sie, aber Sie haben Angst, überhaupt darüber nachzudenken, denn es ist ein Horror, was Sie dann tun müssen? <br><br>  Wer möchte eine magische Anti-Aufschub-Pille, die hilft, das Zittern zu stoppen und mit dem Refactor zu beginnen - willkommen im Videobericht oder unter Katze. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mBxpOvlbAow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  Mein Name ist Victor, ich komme aus Rumänien.  Formal bin ich Berater, technischer Experte und leitender Architekt bei der rumänischen IBM.  Aber wenn ich gebeten wurde, meine Tätigkeit selbst zu definieren, dann bin ich ein Evangelist des reinen Codes.  Ich liebe es, schönen, sauberen und unterstützten Code zu erstellen - in der Regel spreche ich darüber in Berichten.  Darüber hinaus inspiriert mich die Lehre: Schulung von Entwicklern in den Bereichen Java EE, Spring, Dojo, Test Driven Development, Java Performance sowie im Bereich der erwähnten Evangelisation - den Prinzipien sauberer Codemuster und ihrer Entwicklung. <br><br>  Die Erfahrung, auf der meine Theorie basiert, ist hauptsächlich die Entwicklung von Unternehmensanwendungen für den größten IBM Kunden in Rumänien - den Bankensektor. <br><br>  Der Plan für diesen Artikel lautet wie folgt: <br><br><ul><li>  Datenmodellierung: Datenstrukturen sollten nicht zu unseren Feinden werden. <br></li><li>  Organisation der Logik: das Prinzip der "Zerlegung des Codes, die zu viel ist"; <br></li><li>  "Onion" ist die reinste Architektur der Transaction Script-Philosophie. <br></li><li>  Testen als Möglichkeit, mit Entwicklerängsten umzugehen. <br></li></ul><br><br>  Aber zuerst erinnern wir uns an die Hauptprinzipien, an die wir uns als Entwickler immer erinnern müssen. <br><br><h4>  Grundsatz der alleinigen Verantwortung </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/dd0/cd5/353dd0cd58012749b70e379e37231265.jpg"><br><br>  Mit anderen Worten: Quantität gegen Qualität.  Je mehr Funktionen Ihre Klasse enthält, desto schlechter wird sie in der Regel im qualitativen Sinne.  Bei der Entwicklung großer Klassen wird der Programmierer verwirrt, macht Fehler beim Erstellen von Abhängigkeiten, und großer Code ist unter anderem schwieriger zu debuggen.  Es ist besser, eine solche Klasse in mehrere kleinere zu unterteilen, von denen jede für eine Teilaufgabe verantwortlich ist.  Besser ein paar eng gekoppelte Module als eines - groß und langsam.  Die Modularität ermöglicht auch die Wiederverwendung von Logik. <br><br><h4>  Schwache Modulbindung </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/1c8/0f7/f721c80f7b3184be2218a01b66f7440a.jpg"><br><br>  Der Bindungsgrad ist ein Maß dafür, wie eng Ihre Module miteinander interagieren.  Es zeigt, wie weit sich die Auswirkungen der Änderungen, die Sie an einem bestimmten Punkt im System vornehmen, ausbreiten können.  Je höher die Bindung, desto schwieriger ist es, Änderungen vorzunehmen: Sie ändern etwas in einem Modul, und der Effekt erstreckt sich weit und nicht immer in der erwarteten Weise.  Daher sollte der Bindungsindikator so niedrig wie möglich sein - dies bietet mehr Kontrolle über das System, das geändert wird. <br><br><h4>  Nicht wiederholen </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/9de/5c0/2b99de5c00257d6123553c7bfaed0519.jpg"><br><br>  Ihre eigenen Implementierungen mögen heute gut sein, aber morgen nicht so gut.  Erlauben Sie sich nicht, Ihre eigenen Best Practices zu kopieren und sie daher in einer Codebasis zu verteilen.  Sie können aus StackOverflow oder aus Büchern kopieren - aus allen maßgeblichen Quellen, die (wie Sie sicher wissen) eine ideale (oder ähnliche) Implementierung bieten.  Die Verbesserung Ihrer eigenen Implementierung, die mehrmals vorkommt, aber in der gesamten Codebasis multipliziert wird, kann sehr anstrengend sein. <br><br><h4>  Einfachheit und Prägnanz </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/8d4/c85/7d48d4c85408c620ddcbe644c4acb6f9.jpg"><br><br>  Meiner Meinung nach ist dies das Hauptprinzip, das bei der Entwicklung und Softwareentwicklung beachtet werden muss.  "Vorzeitige Einkapselung ist die Wurzel des Bösen", sagte Adam Bien.  Mit anderen Worten, die Wurzel des Bösen liegt in der „Umgestaltung“.  Der Autor des Zitats, Adam Bien, war einmal damit beschäftigt, Legacy-Anwendungen anzunehmen, und erhielt beim vollständigen Umschreiben des Codes eine 2-3-mal kleinere Codebasis als die ursprüngliche.  Woher kommt so viel zusätzlicher Code?  Immerhin entsteht es aus einem Grund.  Seine Ängste lassen uns entstehen.  Es scheint uns, dass wir durch das Anhäufen einer großen Anzahl von Mustern, das Erzeugen von Indirektheit und Abstraktionen unseren Code schützen - Schutz vor den Unbekannten von morgen und den Anforderungen von morgen.  Tatsächlich brauchen wir heute nichts davon, wir erfinden dies alles nur um einiger „zukünftiger Bedürfnisse“ willen.  Und es ist möglich, dass diese Datenstrukturen später stören.  Um ehrlich zu sein, wenn einige meiner Entwickler auf mich zukommen und sagen, dass er etwas Interessantes gefunden hat, das dem Produktionscode hinzugefügt werden kann, antworte ich immer auf die gleiche Weise: "Junge, das wird für Sie nicht nützlich sein." <br><br>  Es sollte nicht viel Code geben, und der, der einfach ist, sollte einfach sein - die einzige Möglichkeit, normal damit zu arbeiten.  Dies ist ein Anliegen für Ihre Entwickler.  Sie müssen sich daran erinnern, dass dies die Kennzahlen für Ihr System sind.  Versuchen Sie, ihren Energieverbrauch zu senken, um die Risiken zu verringern, mit denen sie arbeiten müssen.  Dies bedeutet nicht, dass Sie Ihr eigenes Framework erstellen müssen. Außerdem würde ich Ihnen nicht raten, dies zu tun: Es wird immer Fehler in Ihrem Framework geben, jeder muss es studieren usw.  Es ist besser, vorhandene Vermögenswerte zu nutzen, von denen es heute eine Masse gibt.  Dies sollten einfache Lösungen sein.  Schreiben Sie globale Fehlerbehandlungsroutinen auf, wenden Sie Aspekttechnologie, Codegeneratoren, Spring- oder CDI-Erweiterungen an, konfigurieren Sie Anforderungs- / Thread-Bereiche, verwenden Sie die Bytecode-Manipulation und -Erstellung im laufenden Betrieb usw. All dies ist Ihr Beitrag zum wirklich Wichtigsten - dem Komfort Ihres Entwicklers. <br><br>  Insbesondere möchte ich Ihnen die Anwendung der Request / Thread-Bereiche demonstrieren.  Ich habe wiederholt beobachtet, wie dieses Ding Unternehmensanwendungen unglaublich vereinfacht.  Unter dem Strich haben Sie als angemeldeter Benutzer die Möglichkeit, RequestContext-Daten zu speichern.  Somit speichert RequestContext Benutzerdaten in kompakter Form. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/341/6c5/474/3416c54740aca3b8f514696bf9cf7f3d.jpg"><br><br>  Wie Sie sehen können, benötigt die Implementierung nur ein paar Codezeilen.  Nachdem Sie die Anforderung in der erforderlichen Anmerkung geschrieben haben (es ist nicht schwierig, dies zu tun, wenn Sie Spring oder CDI verwenden), müssen Sie die Benutzeranmeldung nicht mehr an die Methoden und was auch immer übergeben: Die im Kontext gespeicherten Anforderungsmetadaten navigieren transparent durch die Anwendung.  Mit dem Proxy mit Gültigkeitsbereich können Sie jederzeit auf die Metadaten der aktuellen Anforderung zugreifen. <br><br><h4>  Regressionstests </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c5/edf/d7a/5c5edfd7a14d760bc335d8e65f0d5666.jpg"><br><br>  Entwickler haben Angst vor aktualisierten Anforderungen, weil sie Angst vor Refactoring-Verfahren (Code-Änderungen) haben.  Der einfachste Weg, ihnen zu helfen, besteht darin, eine zuverlässige Testsuite für Regressionstests zu erstellen.  Damit hat der Entwickler jederzeit die Möglichkeit, seine Betriebszeit zu testen - um sicherzustellen, dass das System nicht beschädigt wird. <br><br>  Der Entwickler sollte keine Angst haben, etwas zu zerbrechen.  Sie müssen alles tun, damit Refactoring als etwas Gutes wahrgenommen wird. <br>  Refactoring ist ein kritischer Aspekt der Entwicklung.  Denken Sie daran, dass die Anwendung genau in dem Moment, in dem Ihre Entwickler Angst vor Refactoring haben, als Legacy angesehen werden kann. <br><br><h2>  Wo soll die Geschäftslogik implementiert werden? </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/8a2/08d/4fb8a208dc6d89279a663747de74369f.jpg"><br><br>  Wenn wir mit der Implementierung eines Systems (oder von Systemkomponenten) beginnen, stellen wir uns die Frage: Wo ist es besser, die Domänenlogik zu implementieren, dh die funktionalen Aspekte unserer Anwendung?  Es gibt zwei gegensätzliche Ansätze. <br>  Die erste basiert auf der <i>Transaktionsskript-</i> Philosophie.  Hier wird Logik in Prozeduren implementiert, die mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anämischen Entitäten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> mit Datenstrukturen) arbeiten.  Ein solcher Ansatz ist gut, da man sich bei seiner Umsetzung auf die formulierten Geschäftsaufgaben verlassen kann.  Bei der Arbeit an Anwendungen für den Bankensektor habe ich wiederholt die Übertragung von Geschäftsabläufen auf Software beobachtet.  Ich kann sagen, dass es wirklich sehr natürlich ist, Szenarien mit Software zu korrelieren. <br><br>  Ein alternativer Ansatz besteht darin, die Prinzipien des <i>domänengesteuerten Designs zu verwenden</i> .  Hier müssen Sie Spezifikationen und Anforderungen mit einer objektorientierten Methodik korrelieren.  Es ist wichtig, die Objekte sorgfältig zu prüfen und eine gute Geschäftsbeteiligung sicherzustellen.  Das Plus der auf diese Weise entworfenen Systeme ist, dass sie in Zukunft leicht gewartet werden können.  Nach meiner Erfahrung ist es jedoch ziemlich schwierig, diese Methode zu beherrschen: Sie werden sich frühestens nach sechs Monaten des Studiums mehr oder weniger mutig fühlen. <br><br>  Für meine Entwicklungen habe ich immer den ersten Ansatz gewählt.  Ich kann Ihnen versichern, dass es in meinem Fall perfekt funktioniert hat. <br><br><h2>  Datenmodellierung </h2><br><br><h4>  Entitäten </h4><br><br>  Wie modellieren wir die Daten?  Sobald die Anwendung mehr oder weniger anständige Größen annimmt, werden notwendigerweise <i>persistente Daten</i> angezeigt.  Dies ist die Art von Daten, die Sie länger als die anderen speichern müssen - es sind die <i>Domänenentitäten</i> Ihres Systems.  Wo sie gespeichert werden - ob in der Datenbank, in einer Datei oder direkt im Speicher - spielt keine Rolle.  Wichtig ist, <i>wie</i> Sie sie speichern - in welchen Datenstrukturen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a8/56b/127/0a856b127ec938a8c17eb345610b0ee8.jpg"><br><br>  Diese Wahl haben Sie als Entwickler und es hängt nur von Ihnen ab, ob diese Datenstrukturen für Sie oder gegen Sie funktionieren, wenn Sie in Zukunft funktionale Anforderungen implementieren.  Damit alles gut ist, müssen Sie Entitäten implementieren, indem Sie Körner <i>wiederverwendeter Domänenlogik</i> in sie legen.  Wie konkret?  Ich werde anhand eines Beispiels verschiedene Methoden demonstrieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/e56/7da/c73e567da2fb69ceb3d627fb408530cd.jpg"><br><br>  Mal sehen, was ich der Kundenentität zur Verfügung gestellt habe.  Zuerst habe ich einen <i>synthetischen</i> <code>getFullName()</code> <i>Getter</i> implementiert, der mir die Verkettung von Vorname und Nachname zurückgibt.  Ich habe auch die Methode <code>activate()</code> implementiert, um den Status meiner Entität zu überwachen und ihn so zu kapseln.  Bei dieser Methode habe ich erstens eine <i>Validierungsoperation</i> platziert und zweitens <i>den Feldern</i> status und <i>enabledBy Werte zugewiesen</i> , sodass keine Setter für sie erforderlich sind.  Ich habe der Kundenentität auch die <code>isActive()</code> und <code>canPlaceOrders()</code> , die die Lambda-Validierung in mir implementieren.  Dies wird als Prädikatenkapselung bezeichnet.  Solche Prädikate sind nützlich, wenn Sie Java 8-Filter verwenden: Sie können sie als Argumente an Filter übergeben.  Ich rate Ihnen, diese Helfer zu verwenden. <br><br>  Vielleicht verwenden Sie eine Art ORM wie Hibernate.  Angenommen, Sie haben zwei Entitäten mit bidirektionaler Kommunikation.  Die Initialisierung muss auf beiden Seiten durchgeführt werden, da Sie sonst, wie Sie verstehen, in Zukunft Probleme beim Zugriff auf diese Daten haben werden.  Entwickler vergessen jedoch häufig, ein Objekt von einer der Parteien zu initialisieren.  Bei der Entwicklung dieser Entitäten können Sie spezielle Methoden bereitstellen, die eine bidirektionale Initialisierung gewährleisten.  Schauen Sie sich <code>addAddress()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/7fe/273/c557fe273cc1f2658573f9e78a70ca1d.png"><br><br>  Wie Sie sehen können, ist dies eine sehr gewöhnliche Einheit.  Aber darin liegt die Domänenlogik.  Solche Entitäten sollten nicht dürftig und oberflächlich sein, sondern nicht mit Logik überfordert sein.  Ein Überlauf mit Logik tritt häufiger auf: Wenn Sie sich entscheiden, die gesamte Logik in der Domäne zu implementieren, ist es für jeden Anwendungsfall verlockend, eine bestimmte Methode zu implementieren.  In der Regel gibt es viele Anwendungsfälle.  Sie erhalten keine Entität, sondern einen großen Stapel aller Arten von Logik.  Versuchen Sie hier das Maß zu beachten: Nur <i>wiederverwendete Logik</i> wird in die Domäne gestellt und nur <i>in geringer Menge.</i> <i><br><br></i> <h4>  <i>Wertobjekte</i> </h4> <i><br><br></i>  Neben Entitäten benötigen Sie höchstwahrscheinlich auch Objektwerte.  Dies ist nichts anderes als eine Möglichkeit, Domänendaten zu gruppieren, damit Sie sie später gemeinsam im System verschieben können. <br><br>  Das Wertobjekt muss sein: <br><br><ul><li>  <b>Klein</b> .  Kein <code>float</code> für monetäre Variablen!  Seien Sie vorsichtig bei der Auswahl der Datentypen.  Je kompakter Ihr Objekt ist, desto einfacher ist es für einen neuen Entwickler, es herauszufinden.  Dies ist die Basis für ein angenehmes Leben. <br></li><li>  <b>Unveränderlich</b> .  Wenn das Objekt wirklich unveränderlich ist, kann der Entwickler ruhig sein, dass Ihr Objekt seinen Wert nicht ändert und nach der Erstellung nicht beschädigt wird.  Dies legt den Grundstein für eine ruhige und selbstbewusste Arbeit. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/765/284/a0e76528432de8c55dc146805a8b286d.jpg"><br><br>  Wenn Sie dem Konstruktor einen <code>validate()</code> -Methodenaufruf hinzufügen, kann sich der Entwickler auf die Gültigkeit der erstellten Entität beruhigen (wenn beispielsweise eine nicht vorhandene Währung oder ein negativer Geldbetrag übergeben wird, funktioniert der Konstruktor nicht). <br><br><h4>  Der Unterschied zwischen einer Entität und einem Wertobjekt </h4><br><br>  Wertobjekte unterscheiden sich von Entitäten darin, dass sie keine feste ID haben.  Entitäten haben immer Felder, die dem Fremdschlüssel einer Tabelle (oder eines anderen Speichers) zugeordnet sind.  Wertobjekte haben solche Felder nicht.  Es stellt sich die Frage: Sind die Verfahren zur Überprüfung der Gleichheit von zwei Wertobjekten und zwei Entitäten unterschiedlich?  Da Wertobjekte kein ID-Feld haben, müssen Sie die Werte aller ihrer Felder paarweise vergleichen (dh den gesamten Inhalt untersuchen), um zu dem Schluss zu kommen, dass zwei solche Objekte gleich sind.  Beim Vergleichen von Entitäten reicht es aus, einen einzigen Vergleich durchzuführen - nach Feld-ID.  Im Vergleichsverfahren liegt der Hauptunterschied zwischen Entitäten und Wertobjekten. <br><br><h4>  Datenübertragungsobjekte (DTOs) </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72a/d31/681/72ad31681509cdef20509d4514b02139.jpg"><br><br>  Wie ist die Interaktion mit der Benutzeroberfläche?  Sie müssen die <i>Daten zur Anzeige an ihn weitergeben</i> .  Benötigen Sie wirklich eine andere Struktur?  So ist es.  Und das alles, weil die Benutzeroberfläche überhaupt nicht dein Freund ist.  Er hat seine eigenen Anforderungen: Er muss die Daten so speichern, wie sie angezeigt werden sollen.  Das ist so wunderbar - dass es manchmal die Benutzeroberflächen und ihre Entwickler sind, die uns benötigen.  Dann müssen sie Daten für fünf Zeilen abrufen.  Dann denken sie daran, ein <code>isDeletable</code> Boolean-Feld für das Objekt zu erstellen (kann das Objekt im Prinzip ein solches Feld haben?), um zu wissen, ob die Schaltfläche Löschen aktiv ist oder nicht.  Aber es gibt nichts zu empören.  Benutzeroberflächen haben einfach unterschiedliche Anforderungen. <br><br>  Die Frage ist, können unsere Entitäten ihnen zur Verwendung anvertraut werden?  Höchstwahrscheinlich werden sie sie ändern, und zwar auf die für uns unerwünschteste Weise.  Deshalb werden wir ihnen noch etwas anderes zur Verfügung stellen - <i>Data Transfer Objects</i> (DTO).  Sie werden speziell an externe Anforderungen und an eine andere Logik als unsere angepasst.  Einige Beispiele für DTO-Strukturen sind: Formular / Anforderung (von der Benutzeroberfläche), Ansicht / Antwort (an die Benutzeroberfläche gesendet), SearchCriteria / SearchResult usw. Sie können dies gewissermaßen als API-Modell bezeichnen. <br><br>  Erstes wichtiges Prinzip: DTO sollte ein Minimum an Logik enthalten. <br>  Hier ist eine Beispielimplementierung von <code>CustomerDto</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/3bb/716/4ec3bb716c630f3b39ca82f8fe4c5e33.jpg"><br><br>  Inhalt: <i>private</i> Felder, <i>öffentliche</i> Getter und Setter für sie.  Alles scheint super zu sein.  OOP in seiner ganzen Pracht.  Eines ist jedoch schlecht: In Form von Gettern und Setzern habe ich zu viele Methoden implementiert.  In DTO sollte es so wenig Logik wie möglich geben.  Und was ist dann mein Ausweg?  Ich mache die Felder öffentlich!  Sie werden sagen, dass dies mit Methodenreferenzen aus Java 8 schlecht funktioniert, dass es Einschränkungen gibt usw. Aber ob Sie es glauben oder nicht, ich habe alle meine Projekte (10-11 Teile) mit solchen DTOs durchgeführt.  Bruder lebt.  Da meine Felder nun öffentlich sind, kann ich den Wert einfach auf <code>dto.fullName</code> indem <code>dto.fullName</code> einfach ein Gleichheitszeichen <code>dto.fullName</code> .  Was könnte schöner und einfacher sein? <br><br><h2>  Logikorganisation </h2><br><br><h4>  Zuordnung </h4><br><br>  Wir haben also eine Aufgabe: Wir müssen unsere Entitäten in DTO umwandeln.  Wir implementieren die Transformation wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/dfd/ca8/995dfdca8c1945fb92a64cee09851259.jpg"><br><br>  Wie Sie sehen können, fahren wir mit der Deklaration eines DTO mit Mapping-Operationen (Wertzuweisung) fort.  Muss ich ein leitender Entwickler sein, um regelmäßige Aufgaben in solchen Zahlen zu schreiben?  Für einige ist dies so ungewöhnlich, dass sie unterwegs beginnen, ihre Schuhe zu wechseln: Kopieren Sie beispielsweise Daten mithilfe eines Mapping-Frameworks mithilfe von Reflection.  Aber sie vermissen die Hauptsache - dass die Benutzeroberfläche früher oder später mit dem DTO interagiert, wodurch die Entität und das DTO in ihren Bedeutungen voneinander abweichen. <br><br>  Man könnte beispielsweise Mapping-Operationen in den Konstruktor einfügen.  Dies ist jedoch für keine Zuordnung möglich.  Insbesondere kann der Designer nicht auf die Datenbank zugreifen. <br><br>  Daher sind wir gezwungen, Mapping-Operationen in der Geschäftslogik zu belassen.  Und wenn sie ein kompaktes Erscheinungsbild haben, gibt es keinen Grund zur Sorge.  Wenn das Mapping nicht ein paar Zeilen, sondern mehr umfasst, ist es besser, es im sogenannten <i>Mapper zu platzieren</i> .  Ein Mapper ist eine Klasse, die speziell zum Kopieren von Daten entwickelt wurde.  Dies ist im Allgemeinen eine antidiluvianische Sache und eine Kesselplatte.  Aber hinter ihnen können Sie unsere vielen Aufgaben verstecken - um den Code sauberer und schlanker zu machen. <br><br>  Denken Sie daran: Ein <i>zu großer Code muss in eine separate Struktur verschoben werden</i> .  In unserem Fall waren die Mapping-Operationen wirklich ein bisschen viel, also haben wir sie in eine separate Klasse verschoben - den Mapper. <br><br>  Ermöglichen Mapper den Datenbankzugriff?  Sie können es standardmäßig aktivieren - dies geschieht häufig aus Gründen der Einfachheit und des Pragmatismus.  Aber es setzt Sie bestimmten Risiken aus. <br><br>  Ich werde mit einem Beispiel veranschaulichen.  Basierend auf dem vorhandenen DTO erstellen wir die <code>Customer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef3/9e8/b82/ef39e8b82a023a2fad6afe8e3c22b5ec.png"><br><br>  Für die Zuordnung benötigen wir einen Link zur Kundengruppe aus der Datenbank.  Also <code>getReference()</code> ich die Methode <code>getReference()</code> und sie gibt mir eine Entität zurück.  Die Anforderung wird höchstwahrscheinlich an die Datenbank gesendet (in einigen Fällen geschieht dies nicht und die Stub-Funktion funktioniert). <br><br>  Aber das Problem erwartet uns nicht hier, sondern in der Methode, die die inverse Operation ausführt - die Umwandlung der Entität in DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/e27/7ff/e6ae277ff6b22588b5bc5aaffabf9d0e.png"><br><br>  Mit einer Schleife gehen wir alle mit dem bestehenden Kunden verknüpften Adressen durch und übersetzen sie in DTO-Adressen.  Wenn Sie ORM verwenden, wird wahrscheinlich beim Aufrufen der Methode <code>getAddresses()</code> verzögertes Laden durchgeführt.  Wenn Sie ORM nicht verwenden, ist dies eine offene Anfrage an alle Kinder dieses Elternteils.  Und hier laufen Sie Gefahr, in das "N + 1-Problem" zu geraten.  Warum? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/001/2bb/e540012bbb4a242d84e55a2dffa5ca11.jpg"><br><br>  Sie haben eine Reihe von Eltern, von denen jeder Kinder hat.  Für all dies müssen Sie Ihre eigenen Analoga innerhalb des DTO erstellen.  Sie müssen eine <code>SELECT</code> Abfrage ausführen, um N übergeordnete Entitäten zu durchlaufen, und dann N <code>SELECT</code> Abfragen, um die <code>SELECT</code> Entitäten der einzelnen Entitäten zu <code>SELECT</code> .  Insgesamt N + 1 Anfrage.  Für 1000 übergeordnete <code>Customer</code> dauert ein solcher Vorgang 5 bis 10 Sekunden, was natürlich lange dauert. <br><br>  Angenommen, unsere <code>CustomerDto()</code> -Methode wird dennoch innerhalb der Schleife aufgerufen und konvertiert die Liste der Kundenobjekte in die CustomerDto-Liste. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58c/9c3/2b3/58c9c32b3e8a01a96d500920dfe5ef07.jpg"><br><br>  Das Problem mit N + 1-Abfragen hat einfache Standardlösungen: In <i>JPQL können</i> Sie <code>FETCH</code> by customer.addresses verwenden, um <code>FETCH</code> abzurufen und sie dann mit <code>JOIN</code> verbinden. In SQL können Sie die <code>IN</code> Umgehung und die <code>WHERE</code> . <br><br>  Aber ich würde es anders machen.  Sie können herausfinden, wie lang die Liste der Kinder maximal ist (dies kann beispielsweise anhand einer Suche mit Paginierung erfolgen).  Wenn die Liste nur 15 Entitäten enthält, benötigen wir nur 16 Abfragen.  Anstelle von 5 ms werden wir für alles ausgeben, zum Beispiel 15 ms - der Benutzer wird den Unterschied nicht bemerken. <br><br><h4>  Über Optimierung </h4><br><br>  Ich würde Ihnen nicht raten, in der Anfangsphase der Entwicklung auf die Systemleistung zurückzublicken.  Wie Donald Knud sagte: "Vorzeitige Optimierung ist die Wurzel des Bösen."  Sie können nicht von Anfang an optimieren.  Genau das muss für später übrig bleiben.  Und was besonders wichtig ist: <i>keine Annahmen - nur Messungen und Auswertung von Messungen!</i> <br><br>  Sind Sie sicher, dass Sie kompetent sind, ein echter Experte zu sein?  Sei demütig, wenn du dich selbst bewertest.  Denken Sie nicht, dass Sie die JVM verstehen, bis Sie mindestens ein paar Bücher über die JIT-Kompilierung gelesen haben.  Es kommt vor, dass die besten Programmierer aus unserem Team auf mich zukommen und sagen, dass <i>sie glauben</i> , eine effizientere Implementierung gefunden zu haben.  Es stellt sich heraus, dass sie wieder etwas erfunden haben, das den Code nur kompliziert.  Also antworte ich immer wieder: YAGNI.  Wir brauchen es nicht. <br><br>  Für Unternehmensanwendungen ist häufig überhaupt keine Optimierung der Algorithmen erforderlich.  Der Engpass für sie ist in der Regel nicht die Kompilierung und nicht für den Prozessor, sondern alle Arten von Eingabe-Ausgabe-Operationen.  Beispiel: Lesen einer Million Zeilen aus einer Datenbank, umfangreiches Schreiben in eine Datei und Interaktion mit Sockets. <br><br>  Mit der Zeit beginnen Sie zu verstehen, welche Engpässe das System enthält, und wenn Sie alles durch Messungen verstärken, werden Sie allmählich mit der Optimierung beginnen.  Halten Sie den Code vorerst so sauber wie möglich.  Sie werden feststellen, dass ein solcher Code viel einfacher weiter zu optimieren ist. <br><br><h4>  Ziehen Sie die Komposition der Vererbung vor </h4><br><br>  Zurück zu unserem DTO.  Angenommen, wir definieren ein DTO wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/39d/f91/18039df91fd1cc76a2413b7f373e7c0b.png"><br><br>  Möglicherweise benötigen wir es in vielen Workflows.  Diese Abläufe sind jedoch unterschiedlich, und höchstwahrscheinlich wird jeder Anwendungsfall einen anderen Grad der Feldfüllung annehmen.  Zum Beispiel müssen wir natürlich ein DTO früher erstellen, als wenn wir vollständige Benutzerinformationen haben.  Sie können die Felder vorübergehend leer lassen.  Je mehr Felder Sie ignorieren, desto mehr möchten Sie ein neues, strengeres DTO für diesen Anwendungsfall erstellen. <br><br>  Alternativ können Sie Kopien eines übermäßig großen DTO (in der Anzahl der verfügbaren Anwendungsfälle) erstellen und dann für jede Kopie zusätzliche Felder daraus entfernen.  Aber für viele Programmierer tut es aufgrund ihrer Intelligenz und Alphabetisierung wirklich weh, Strg + V zu drücken.  Das Axiom besagt, dass Copy-Paste schlecht ist. <br><br>  Sie können auf das in der OOP-Theorie bekannte <i>Vererbungsprinzip</i> zurückgreifen: Definieren Sie einfach ein grundlegendes DTO und erstellen Sie für jeden Anwendungsfall einen Erben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/069/77f/6f706977fec8625d720323b64fe87ad8.png"><br><br>  Ein bekanntes Prinzip lautet: „Bevorzugen Sie die Komposition gegenüber der Vererbung.“  Lesen Sie, was darin steht: <i>"erweitert"</i> .  Es scheint, dass wir die Quellklasse „erweitert“ haben sollten.  Aber wenn Sie darüber nachdenken, dann haben wir überhaupt keine „Erweiterung“ getan.  Dies ist die eigentliche „Wiederholung“ - dieselbe Seitenansicht zum Kopieren und Einfügen.  Daher werden wir keine Vererbung verwenden. <br><br>  Aber was sollen wir dann sein?  Wie gehe ich zur Komposition?  Gehen wir folgendermaßen vor: Schreiben Sie in CustomerView ein Feld, das auf das Objekt des zugrunde liegenden DTO verweist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/d49/831/1f2d49831b9b286b8bc069c824ac2871.jpg"><br><br>  Somit wird unsere Basisstruktur im Inneren verschachtelt.  So kommt die eigentliche Komposition heraus. <br><br>  Ob wir die Vererbung verwenden oder das Problem durch Komposition lösen - all dies sind Einzelheiten, Feinheiten, die im Verlauf unserer Implementierung tiefgreifend entstanden sind.  Sie sind sehr <i>zerbrechlich</i> .  Was bedeutet zerbrechlich?  Schauen Sie sich diesen Code genau an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/eb1/ef2/921eb1ef20effd43b129ad5d28b88253.png"><br><br>  Die meisten Entwickler, denen ich dies gezeigt habe, platzten sofort heraus, dass die Zahl "2" wiederholt wird, daher muss sie als Konstante herausgenommen werden.  Sie bemerkten nicht, dass die Zwei in allen drei Fällen eine völlig andere Bedeutung (oder einen „Geschäftswert“) hat und dass ihre Wiederholung nichts anderes als ein Zufall ist.  Eine Zwei in eine Konstante zu ziehen ist eine legitime Entscheidung, aber sehr fragil.  Versuchen Sie, keine fragile Logik in die Domäne zuzulassen.  Arbeiten Sie niemals mit externen Datenstrukturen, insbesondere mit DTO. <br><br>  Warum ist die Arbeit, die Vererbung zu beseitigen und die Komposition einzuführen, nutzlos?  Gerade weil wir DTO nicht für uns selbst, sondern für einen externen Kunden erstellen.  Und wie die Client-Anwendung das von Ihnen erhaltene DTO analysiert, können Sie nur erraten.  Dies hat jedoch offensichtlich wenig mit Ihrer Implementierung zu tun.  Entwickler hingegen unterscheiden möglicherweise nicht zwischen den grundlegenden und nicht grundlegenden DTOs, die Sie sorgfältig durchdacht haben.  Sie verwenden wahrscheinlich Vererbung und vielleicht dumm das Kopieren und Einfügen, das ist alles. <br><br><h4>  Fassaden </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/31c/9e4/be731c9e4cfe002cb3b59c11a708f623.jpg"><br><br>  Kehren wir zum Gesamtbild der Anwendung zurück.  Ich würde Ihnen raten, die Domänenlogik über das <i>Fassadenmuster</i> zu implementieren und die <i>Fassaden</i> nach Bedarf mit <i>Domänendiensten zu</i> erweitern.  Ein Domänendienst wird erstellt, wenn sich zu viel Logik in der Fassade ansammelt, und es ist bequemer, ihn einer separaten Klasse zuzuordnen. <br>  Ihre Domain-Services müssen unbedingt die Sprache Ihres Domain-Modells (seine Entitäten und Wertobjekte) sprechen.  In keinem Fall sollten sie mit DTO zusammenarbeiten, da DTO, wie Sie sich erinnern, Strukturen sind, die sich auf der Clientseite ständig ändern und für eine Domain zu zerbrechlich sind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/eb8/657/3adeb86570a92f804ba491836c99b9e8.jpg"><br><br>  Was ist der Zweck der Fassade? <br><br><ol><li>  Datenkonvertierung.  Wenn wir Entitäten von einem Ende und DTO vom anderen haben, ist es notwendig, Transformationen von einem zum anderen durchzuführen.  Und das ist das erste, wofür Fassaden sind.  Wenn das Konvertierungsverfahren an Volumen zugenommen hat, verwenden Sie die Mapper-Klassen. <br></li><li>  Die Implementierung von Logik.  In der Fassade beginnen Sie, die Hauptlogik der Anwendung zu schreiben.  Sobald es viel wird - nehmen Sie Teile zum Domain-Service. <br></li><li>  Datenvalidierung.  Denken Sie daran, dass alle vom Benutzer empfangenen Daten per Definition falsch sind (Fehler enthalten).  Die Fassade kann Daten validieren.  Diese Verfahren werden normalerweise zu den <i>Validatoren gebracht</i> , wenn das Volumen überschritten wird. <br></li><li>  Aspekte  Sie können weiter gehen und jeden Anwendungsfall durch seine Fassade führen.  Dann werden sich Dinge wie Transaktionen, Protokollierung und globale Ausnahmehandler zu Fassadenmethoden hinzufügen. Ich stelle fest, dass es sehr wichtig ist, globale Ausnahmehandler in jeder Anwendung zu haben, die alle Fehler abfangen, die nicht von anderen Handlern abgefangen wurden.  Sie werden Ihren Programmierern sehr helfen - sie geben ihnen Ruhe und Handlungsfreiheit. <br></li></ol><br><br><h4>  Zerlegung von viel Code </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/a9c/8e8/604a9c8e859ff1dc3fb38208d6bf836d.jpg"><br><br>  Noch ein paar Worte zu diesem Prinzip.  Wenn die Klasse eine für mich unangenehme Größe erreicht hat (z. B. 200 Zeilen), sollte ich versuchen, sie in Stücke zu zerbrechen.  Es ist jedoch nicht immer einfach, eine neue Klasse von einer vorhandenen zu isolieren.  Wir müssen einige universelle Wege finden.  Eine dieser Methoden ist die Suche nach Namen: Sie versuchen, einen Namen für eine Teilmenge der Methoden Ihrer Klasse zu finden.  Sobald Sie einen Namen gefunden haben, können Sie eine neue Klasse erstellen.  Das ist aber nicht so einfach.  Wie Sie wissen, gibt es beim Programmieren nur zwei komplexe Dinge: Dies macht den Cache ungültig und erfindet Namen.  In diesem Fall beinhaltet das Erfinden eines Namens das Identifizieren einer Unteraufgabe, die sich versteckt und daher zuvor von niemandem identifiziert wurde. <br><br>  Ein Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/fe3/82b/81ffe382b74f6bbd4a91626d83249a97.jpg"><br><br>  In der ursprünglichen Fassade von <code>CustomerFacade</code> beziehen sich einige der Methoden direkt auf den Kunden, andere auf die Kundenpräferenzen.  Auf dieser Grundlage kann ich die Klasse in zwei Teile aufteilen, wenn sie kritische Größen erreicht.  Ich bekomme zwei Fassaden: <code>CustomerFacade</code> und <code>CustomerPreferencesFacade</code> .  Das einzig schlechte ist, dass beide Fassaden zur gleichen Abstraktionsebene gehören.  Die Trennung nach Abstraktionsebenen impliziert etwas anderes. <br><br>  Ein weiteres Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ac/84e/788/2ac84e788af60fb038091aed273a390e.jpg"><br><br>  Angenommen, es gibt eine <code>OrderService</code> Klasse in unserem System, in der wir einen E-Mail-Benachrichtigungsmechanismus implementiert haben.  Jetzt erstellen wir einen <code>DeliveryService</code> und möchten hier denselben Benachrichtigungsmechanismus verwenden.  Kopieren-Einfügen ist ausgeschlossen.  Gehen wir folgendermaßen vor: Extrahieren Sie die Benachrichtigungsfunktionalität in die neue <code>AlertService</code> Klasse und schreiben Sie sie als Abhängigkeit für die <code>OrderService</code> <code>DeliveryService</code> und <code>OrderService</code> .  Hier erfolgte die Trennung im Gegensatz zum vorherigen Beispiel genau auf den Abstraktionsebenen. <code>DeliveryService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abstrakter als </font></font><code>AlertService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, weil es es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Teil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seines Workflows verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Trennung nach Abstraktionsebenen wird immer davon </font><i><font style="vertical-align: inherit;">ausgegangen,</font></i><font style="vertical-align: inherit;"> dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extrahierte Klasse zu einer Abhängigkeit wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extraktion wird zur Wiederverwendung durchgeführt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Extraktionsaufgabe ist nicht immer einfach. </font><font style="vertical-align: inherit;">Dies kann auch einige Schwierigkeiten mit sich bringen und eine Umgestaltung der Komponententests erfordern. </font><font style="vertical-align: inherit;">Nach meinen Beobachtungen ist es für Entwickler jedoch noch schwieriger, nach Funktionen in der riesigen monolithischen Codebasis der Anwendung zu suchen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paarprogrammierung </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/5b2/346/6255b23467294d6224107235443379f1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Berater werden über die Paarprogrammierung sprechen, über die Tatsache, dass dies eine universelle Lösung für alle Probleme der heutigen IT-Entwicklung ist. Währenddessen entwickeln Programmierer ihre technischen Fähigkeiten und funktionalen Kenntnisse. Darüber hinaus ist der Prozess selbst interessant, er bringt das Team zusammen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht als Berater, sondern menschlich gesehen ist das Wichtigste: Paarprogrammierung verbessert den „Busfaktor“. Das Wesentliche des „Busfaktors“ ist, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">möglichst viele Personen über die Systemstruktur informiert sein sollten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Leute zu verlieren bedeutet, die letzten Hinweise auf dieses Wissen zu verlieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Refactoring von Paarprogrammen ist eine Kunst, die Erfahrung und Schulung erfordert. Dies ist beispielsweise nützlich, um aggressives Refactoring durchzuführen, Hackathons, Schnitte durchzuführen, Dojos zu codieren usw. Die </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paarprogrammierung funktioniert gut, wenn Sie Probleme mit hoher Komplexität lösen müssen. Der Prozess der Zusammenarbeit ist nicht immer einfach. Es garantiert Ihnen jedoch, dass Sie ein "Reengineering" vermeiden - im Gegenteil, Sie erhalten eine Implementierung, die die festgelegten Anforderungen mit minimaler Komplexität erfüllt. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5a/5aa/666/a5a5aa666cb29c58dc9bb5b7d5bc6651.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Organisation eines praktischen Arbeitsformats ist eine Ihrer Hauptaufgaben gegenüber dem Team. Sie müssen sich ständig um die Arbeitsbedingungen des Entwicklers kümmern - ihm vollen Komfort und kreative Freiheit bieten, insbesondere wenn sie die Designarchitektur und ihre Komplexität erhöhen müssen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Ich bin Architekt. </font><font style="vertical-align: inherit;">Per Definition habe ich immer Recht. “</font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Dummheit wird regelmäßig öffentlich oder hinter den Kulissen zum Ausdruck gebracht. </font><font style="vertical-align: inherit;">In der heutigen Praxis finden sich Architekten als solche immer weniger. </font><font style="vertical-align: inherit;">Mit dem Aufkommen von Agile ging diese Rolle allmählich auf leitende Entwickler über, da normalerweise die gesamte Arbeit auf die eine oder andere Weise um sie herum aufgebaut wird. </font><font style="vertical-align: inherit;">Die Größe der Implementierung nimmt allmählich zu, und daher besteht Bedarf an Refactoring, und es werden neue Funktionen entwickelt.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwiebelarchitektur </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwiebel ist die reinste Transaktionsskript-Philosophie. Beim Aufbau orientieren wir uns am Ziel, den Code zu schützen, den wir für kritisch halten, und verschieben ihn dazu in das Domänenmodul. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a45/bb4/94a/a45bb494a51b04ecfe92606b744c0857.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserer Anwendung sind Domänendienste am wichtigsten: Sie implementieren die kritischsten Abläufe. Verschieben Sie sie in das Domänenmodul. Natürlich lohnt es sich auch, alle Ihre Domänenobjekte hierher zu verschieben - Entitäten und Wertobjekte. Alles andere, was wir heute zusammengestellt haben - DTO, Mapper, Validatoren usw. - wird sozusagen zur ersten Verteidigungslinie des Benutzers. Weil der Benutzer leider nicht unser Freund ist und es notwendig ist, das System vor ihm zu schützen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufmerksamkeit für diese Abhängigkeit:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/273/6bd/c7d2736bdc016b732c5c431299bf32ea.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anwendungsmodul hängt vom Domänenmodul ab - also nicht umgekehrt. Durch die Registrierung einer solchen Verbindung garantieren wir, dass das DTO niemals in das heilige Gebiet des Domänenmoduls eindringt: Sie sind vom Domänenmodul aus einfach nicht sichtbar und nicht zugänglich. Es stellt sich heraus, dass wir in gewisser Weise das Domain-Territorium eingezäunt haben - wir haben den Zugang von Fremden darauf beschränkt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möglicherweise muss die Domäne jedoch mit einem externen Dienst interagieren. Mit externen Mitteln unfreundlich, weil er mit seinem DTO ausgestattet ist. Welche Möglichkeiten haben wir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens: Überspringen Sie den Feind im Modul. </font></font><br><br><img src="https://habrastorage.org/webt/un/tn/hk/untnhkiksv5id_i-6c4qwdjxy1c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist natürlich eine schlechte Option: Es ist möglich, dass der externe Dienst morgen nicht auf Version 2.0 aktualisiert wird und wir unsere Domain neu zeichnen müssen. Lass den Feind nicht in die Domäne!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schlage einen anderen Ansatz vor: Wir werden einen speziellen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die Interaktion erstellen </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/8b1/09c/1238b109c54ac8f19524e6d41b32e85e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Adapter empfängt Daten von einem externen Dienst, extrahiert die Daten, die unsere Domäne benötigt, und konvertiert sie in die erforderlichen Arten von Strukturen. </font><font style="vertical-align: inherit;">In diesem Fall müssen wir während der Entwicklung lediglich die Aufrufe des externen Systems mit den Anforderungen der Domäne korrelieren. </font><font style="vertical-align: inherit;">Betrachten Sie es als einen riesigen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie diesen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich nenne diese Schicht "Korruptionsbekämpfung". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise müssen wir möglicherweise LDAP-Abfragen von einer Domäne ausführen. </font><font style="vertical-align: inherit;">Dazu implementieren wir das „Anti-Korruptions-Modul“ </font></font><code>LDAPUserServiceAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/520/fdc/84a/520fdc84a53641a26b957ac010a19c42.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Adapter können wir:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hässliche API-Aufrufe ausblenden (in unserem Fall die Methode ausblenden, die das Object-Array verwendet); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pack Ausnahmen in unsere eigenen Implementierungen; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konvertieren Sie die Datenstrukturen anderer Personen in ihre eigenen (in unsere Domänenobjekte). </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüfen Sie die Gültigkeit eingehender Daten. </font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist der Zweck des Adapters. </font><font style="vertical-align: inherit;">Gut, an der Schnittstelle zu jedem externen System, mit dem Sie interagieren müssen, muss Ihr Adapter installiert sein. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/663/9c5/b1a6639c58457537fb6a4d9c15e09eae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher leitet die Domäne den Anruf nicht an einen externen Dienst, sondern an den Adapter. </font><font style="vertical-align: inherit;">Dazu muss die entsprechende Abhängigkeit in der Domäne registriert sein (vom Adapter oder vom Infrastrukturmodul, in dem sie sich befindet). </font><font style="vertical-align: inherit;">Aber ist diese Sucht sicher? </font><font style="vertical-align: inherit;">Wenn Sie es so installieren, kann ein externer Service-DTO in unsere Domain gelangen. </font><font style="vertical-align: inherit;">Wir sollten das nicht zulassen. </font><font style="vertical-align: inherit;">Daher schlage ich Ihnen eine andere Möglichkeit vor, Abhängigkeiten zu modellieren.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prinzip der Abhängigkeitsinversion </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/4a1/f7c/0584a1f7c309505e4e5ea0c2b0b26c21.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir eine Schnittstelle, schreiben Sie die Signatur der erforderlichen Methoden hinein und platzieren Sie sie in unserer Domäne. Die Aufgabe des Adapters besteht darin, diese Schnittstelle zu implementieren. Es stellt sich heraus, dass sich die Schnittstelle innerhalb der Domäne und der Adapter außerhalb des Infrastrukturmoduls befindet, das die Schnittstelle importiert. Wir haben also die Richtung der Abhängigkeit in die entgegengesetzte Richtung gedreht. Zur Laufzeit ruft das Domänensystem jede Klasse über Schnittstellen auf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen, konnten wir durch die Einführung von Schnittstellen in die Architektur Abhängigkeiten bereitstellen und so unsere Domäne vor fremden Strukturen und APIs schützen, die in sie fallen. Dieser Ansatz wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängigkeitsinversion bezeichnet</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/cc2/cd0/c2ccc2cd0309a4c8f97b7521cfc63fb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen setzt die Abhängigkeitsinversion voraus, dass Sie die für Sie interessanten Methoden in der Schnittstelle innerhalb Ihres High-Level-Moduls (in der Domäne) platzieren und diese Schnittstelle von außen implementieren - in dem einen oder anderen hässlichen Low-Level-Modul (Infrastruktur). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die im Domänenmodul implementierte Schnittstelle muss die Domänensprache sprechen, dh sie verarbeitet ihre Entitäten, ihre Parameter und Rückgabetypen. Zur Laufzeit ruft die Domäne eine beliebige Klasse über einen polymorphen Aufruf der Schnittstelle auf. Abhängigkeitsinjektions-Frameworks (wie Spring und CDI) bieten uns eine konkrete Instanz der Klasse direkt zur Laufzeit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hauptsache ist jedoch, dass das Domänenmodul während der Kompilierung den Inhalt des externen Moduls nicht sieht. </font><font style="vertical-align: inherit;">Das brauchen wir. </font><font style="vertical-align: inherit;">Keine externe Entität sollte in die Domäne fallen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onkel Bob</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das Prinzip der Kontrollinversion (oder, wie er es nennt, „Plug-in-Architektur“) vielleicht das beste, das das OOP-Paradigma im Allgemeinen bietet. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a96/3cf/e13/a963cfe13d030fb1d7ec2bf0f780fe43.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Strategie kann zur Integration in beliebige Systeme, für synchrone und asynchrone Anrufe und Nachrichten, zum Senden von Dateien usw. verwendet werden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Glühbirnenübersicht </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/64d/cdb/dc364dcdb589b35a0597b6e478aace46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deshalb haben wir beschlossen, das Domänenmodul zu schützen. </font><font style="vertical-align: inherit;">Darin befinden sich ein Domänendienst, Entitäten, Wertobjekte und jetzt Schnittstellen für externe Dienste sowie Schnittstellen für das Repository (für die Interaktion mit der Datenbank). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur sieht folgendermaßen aus: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/983/0c7/07e9830c76d3b263743f8514b13bf42a.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Anwendungsmodul, das Infrastrukturmodul (durch Abhängigkeitsinversion), das Repository-Modul (wir betrachten die Datenbank auch als externes System), das Batch-Modul und möglicherweise einige andere Module werden als Abhängigkeiten für die Domäne deklariert. </font><font style="vertical-align: inherit;">Diese Architektur wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Zwiebel" genannt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">Es wird auch als "sauber", "sechseckig" und "Anschlüsse und Adapter" bezeichnet.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository-Modul </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde kurz auf das Repository-Modul eingehen. Ob es aus der Domain entfernt werden soll, ist eine Frage. Die Aufgabe des Repositorys ist es, die Logik sauberer zu machen und uns den Schrecken zu verbergen, mit persistenten Daten zu arbeiten. Die Option für Old-School-Leute besteht darin, JDBC für die Interaktion mit der Datenbank zu verwenden: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d70/44a/7edd7044a76373b2c513e246bf6eabaa.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können auch Spring und dessen JdbcTemplate verwenden: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d68/749/64bd68749f5b3de16591a23a8acda193.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder MyBatis DataMapper: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/31b/aa1/42331baa178ff3ad8f0ea8fb92704265.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es ist so kompliziert und hässlich, dass es jeden Wunsch entmutigt, etwas weiter zu tun. Daher empfehle ich die Verwendung von JPA / Hibernate oder Spring Data JPA. Sie geben uns die Möglichkeit, Abfragen zu senden, die nicht auf dem Datenbankschema basieren, sondern direkt auf dem Modell unserer Entitäten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung für JPA / Hibernate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/ebf/ef7/110ebfef7dad2a2bb278c50668eecda9.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fall von Spring Data JPA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/e2a/0ff/10be2a0ff082a8c1ac962c4754ec55a8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Data JPA kann zur Laufzeit automatisch Methoden generieren, z. B. getById (), getByName (). Außerdem können Sie bei Bedarf JPQL-Abfragen ausführen - und zwar nicht in der Datenbank, sondern in Ihrem eigenen Entitätsmodell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der JPA-Code für den Ruhezustand und Spring Data sieht wirklich ziemlich gut aus. Müssen wir es überhaupt aus der Domain extrahieren? Meiner Meinung nach ist dies nicht so und notwendig. Höchstwahrscheinlich wird der Code noch sauberer, wenn Sie dieses Fragment in der Domäne belassen. Handle also auf die Situation.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/f04/37c/055f0437cf059c9f7001db6b3d231e70.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie dennoch ein Repository-Modul erstellen, ist es für die Organisation von Abhängigkeiten besser, das Prinzip der Steuerungsinversion auf dieselbe Weise zu verwenden. </font><font style="vertical-align: inherit;">Platzieren Sie dazu die Schnittstelle in der Domäne und implementieren Sie sie im Repository-Modul. </font><font style="vertical-align: inherit;">Die Repository-Logik ist besser auf die Domäne zu übertragen. </font><font style="vertical-align: inherit;">Dies erleichtert das Testen, da Sie Mock-Objekte in der Domäne verwenden können. </font><font style="vertical-align: inherit;">Mit ihnen können Sie die Logik schnell und wiederholt testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionell wird nur eine Entität für ein Repository in einer Domäne erstellt. </font><font style="vertical-align: inherit;">Sie zerbrechen es nur, wenn es zu voluminös wird. </font><font style="vertical-align: inherit;">Denken Sie daran, dass Klassen kompakt sein müssen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c8/9e1/7e7/1c89e17e784e4db6fe8d7c713bcf1ab6.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können ein separates Modul erstellen, die aus der Fassade extrahierte Schnittstelle und die darauf basierenden DTOs platzieren, sie dann in eine JAR packen und in dieser Form an Ihre Java-Clients übertragen. </font><font style="vertical-align: inherit;">Mit dieser Datei können sie Anfragen an die Fassaden senden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pragmatische Glühbirne </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich zu denen unserer „Feinde“, denen wir Funktionen liefern, dh Kunden, haben wir auch Feinde und andererseits jene Module, von denen wir selbst abhängen. </font><font style="vertical-align: inherit;">Wir müssen uns auch vor diesen Modulen schützen. </font><font style="vertical-align: inherit;">Und dafür biete ich Ihnen eine leicht modifizierte „Zwiebel“ an - darin ist die gesamte Infrastruktur in einem Modul zusammengefasst. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/265/1f1/481/2651f1481062cfe6c18974df9a6dde9b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich nenne diese Architektur eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"pragmatische Glühbirne"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hier erfolgt die Trennung der Komponenten nach dem Prinzip „mein“ und „integrierbar“: getrennt, das bezieht sich auf meine Domäne, und getrennt, das bezieht sich auf die Integration mit externen Mitarbeitern. </font><font style="vertical-align: inherit;">Somit werden nur zwei Module erhalten: die Domäne und die Anwendung. </font><font style="vertical-align: inherit;">Eine solche Architektur ist sehr gut, aber nur, wenn das Anwendungsmodul klein ist. </font><font style="vertical-align: inherit;">Ansonsten kehren Sie besser zur traditionellen Zwiebel zurück.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tests </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie ich bereits sagte, wenn jeder Angst vor Ihrer Bewerbung hat, denken Sie daran, dass sie die Reihen von Legacy wieder aufgefüllt hat. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/12a/508/d1b/12a508d1b9595239f6d9b9a8a72c9474.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber die Tests sind gut. Sie geben uns ein Gefühl des Vertrauens, das es uns ermöglicht, das Refactoring fortzusetzen. Leider kann sich dieses Vertrauen leicht als ungerechtfertigt herausstellen. Ich werde erklären warum. TDD (Entwicklung durch Testen) setzt voraus, dass Sie sowohl der Autor des Codes als auch der Autor der Testfälle sind: Sie lesen die Spezifikationen, implementieren die Funktionalität und schreiben sofort eine Testsuite dafür. Tests werden beispielsweise erfolgreich sein. Aber was ist, wenn Sie die Anforderungen der Spezifikationen falsch verstanden haben? Dann prüfen die Tests nicht, was benötigt wird. Ihr Vertrauen ist also wertlos. Und das alles, weil Sie Code und Tests alleine geschrieben haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber versuchen Sie, unsere Augen dafür zu schließen. </font><font style="vertical-align: inherit;">Tests sind noch notwendig und geben uns auf jeden Fall Vertrauen. </font><font style="vertical-align: inherit;">Vor allem lieben wir natürlich Funktionstests: Sie implizieren keine Nebenwirkungen, keine Abhängigkeiten - nur Eingabe- und Ausgabedaten. </font><font style="vertical-align: inherit;">Um eine Domäne zu testen, müssen Sie Scheinobjekte verwenden: Mit ihnen können Sie Klassen isoliert testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Testen von Datenbankabfragen ist unangenehm. </font><font style="vertical-align: inherit;">Diese Tests sind fragil. Sie erfordern, dass Sie zuerst Testdaten zur Datenbank hinzufügen - und erst danach können Sie mit dem Testen der Funktionalität fortfahren. </font><font style="vertical-align: inherit;">Wie Sie verstehen, sind diese Tests jedoch auch erforderlich, selbst wenn Sie JPA verwenden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit-Tests </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/332/6ec/8bd3326ec6ca9886c78b4239491dc936.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich würde sagen, dass die Kraft von Unit-Tests nicht in der Möglichkeit liegt, sie auszuführen, sondern darin, was der Prozess des Schreibens umfasst. Während Sie einen Test schreiben, überdenken Sie den Code und arbeiten ihn durch - reduzieren Sie die Konnektivität, teilen Sie ihn in Klassen auf - führen Sie mit einem Wort das nächste Refactoring durch. Der zu testende Code ist reiner Code. es ist einfacher, die Verbundenheit ist darin reduziert; Im Allgemeinen wird es auch dokumentiert (ein gut geschriebener Komponententest beschreibt perfekt, wie die Klasse funktioniert). Es ist nicht überraschend, dass das Schreiben von Unit-Tests schwierig ist, insbesondere bei den ersten Stücken. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/be7/361/116be7361d4d6a2dc8cac91983808378.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Phase der ersten Unit-Tests haben viele Menschen große Angst vor den Aussichten, dass sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwas testen müssen. Warum werden sie so hart gegeben? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weil diese Tests die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Belastung für Ihre Klasse sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist der erste Schlag gegen das System, der vielleicht zeigt, dass es zerbrechlich und schwach ist. Sie müssen jedoch verstehen, dass diese wenigen Tests für Ihre Entwicklung am wichtigsten sind. Sie sind im Wesentlichen Ihre besten Freunde, weil sie alles sagen, was die Qualität Ihres Codes betrifft. Wenn Sie Angst vor dieser Phase haben, werden Sie nicht weit kommen. Sie müssen Tests für Ihr System ausführen. Danach nimmt die Komplexität ab, Tests werden schneller geschrieben. Wenn Sie sie einzeln hinzufügen, erstellen Sie eine zuverlässige </font><i><font style="vertical-align: inherit;">Regressionstestbasis</font></i><font style="vertical-align: inherit;"> für Ihr System</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und das ist unglaublich wichtig für die zukünftige Arbeit Ihrer Entwickler. </font><font style="vertical-align: inherit;">Es wird für sie einfacher sein, umzugestalten; </font><font style="vertical-align: inherit;">Sie werden verstehen, dass das System jederzeit auf Regression getestet werden kann, weshalb die Arbeit mit der Codebasis sicher ist. </font><font style="vertical-align: inherit;">Und ich versichere Ihnen, sie werden sich viel bereitwilliger mit der Umgestaltung befassen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/3d7/cbd/eb53d7cbdc3b190b2b597d6427088b1a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Rat an Sie: Wenn Sie heute das Gefühl haben, viel Kraft und Energie zu haben, widmen Sie sich dem Schreiben von Unit-Tests. </font><font style="vertical-align: inherit;">Und stellen Sie sicher, dass jeder sauber und schnell ist, sein eigenes Gewicht hat und die anderen nicht wiederholt.</font></font><br><br><h2>  Tipps </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend möchte ich Sie mit den folgenden Tipps ermahnen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halten Sie es </font><font style="vertical-align: inherit;">so lange wie möglich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einfach</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (und egal was es kostet) </font><font style="vertical-align: inherit;">: Vermeiden Sie „Reengineering“ und verspätete Optimierung, überlasten Sie die Anwendung nicht.</font></font><br></li><li> <i>   </i> ,        ,   ; <br></li><li>  «»           — <i>     </i> ; <br></li><li>   ,        — <i></i> :         ; <br></li><li>    «»,  ,     — <i>           </i> ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haben Sie keine Angst vor Tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Geben Sie ihnen die Möglichkeit, Ihr System herunterzufahren, alle Vorteile zu spüren - am Ende sind sie Ihre Freunde, weil sie ehrlich auf Probleme hinweisen können.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise helfen Sie sowohl Ihrem Team als auch sich selbst. </font><font style="vertical-align: inherit;">Und dann, wenn der Tag der Lieferung des Produkts kommt, sind Sie bereit dafür.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was zu lesen </font></font></h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/a4c/37d/852a4c37d17677fa3fb1e7e021f29e4a.jpg"><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 Tugenden eines guten Objekts</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL ist der schlimmste Fehler in der Informatik</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die saubere Architektur</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neuer Programmierjargon</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codequalität: WTFs / Minute</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum jedes einzelne Element von SOLID falsch ist!</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gute Software wird 3 mal geschrieben</font></font></a> <br></li></ul><br><br><blockquote>  .        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joker 2018</a> —    Java-.       .        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419179/">https://habr.com/ru/post/de419179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419165/index.html">Wir senden "anonyme" SMS von der Konsole an die gewünschte Nummer mit dem Bytehand- und C ++ - Dienst</a></li>
<li><a href="../de419169/index.html">"Welt des Wilden Westens" mit den Augen des Entwicklers</a></li>
<li><a href="../de419171/index.html">Deaktivieren der Laufzeitstatusprüfung in einer Android-Anwendung</a></li>
<li><a href="../de419173/index.html">Saubere Architektur im Kontext der plattformübergreifenden Entwicklung</a></li>
<li><a href="../de419177/index.html">Amazon Light Patterns</a></li>
<li><a href="../de419181/index.html">Mausprogrammierung: Wie wir uns von der CRM-Routine lösen</a></li>
<li><a href="../de419183/index.html">Demopati in Helsinki „Versammlung 2018“, Fotobericht, erster Tag</a></li>
<li><a href="../de419185/index.html">Überblick über aktuelle Protokolle zur Konsensbildung in einer dezentralen Umgebung</a></li>
<li><a href="../de419189/index.html">Warum Pauschalangebote bald die Grundlage des Einzelhandels bilden werden</a></li>
<li><a href="../de419193/index.html">Wir beschäftigen uns mit Objekten in JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>