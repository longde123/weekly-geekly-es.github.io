<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔌 🎁 🏑 UI-Framework in 5 Minuten 👨‍👨‍👧‍👦 🥃 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit habe ich mich gefragt, warum es so viele UI-Frameworks für das Web gibt. Ich bin schon lange in der IT tätig und kann mich nicht erin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UI-Framework in 5 Minuten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415857/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bt/su/qibtsu7-adonxh3cztr05mvwabi.png"></div><br><p>  Vor einiger Zeit habe ich mich gefragt, warum es so viele UI-Frameworks für das Web gibt.  Ich bin schon lange in der IT tätig und kann mich nicht erinnern, dass UI-Bibliotheken auf anderen Plattformen mit der gleichen Geschwindigkeit wie in WEB geboren wurden und starben.  Bibliotheken für Desktop-Betriebssysteme wie MFC, Qt, WPF usw.  - waren Monster, die sich im Laufe der Jahre entwickelten und nicht viele Alternativen hatten.  Im Web ist alles anders - Frameworks werden fast jede Woche veröffentlicht, Führungskräfte wechseln - warum passiert das? </p><br><p>  Ich denke, der Hauptgrund ist, dass die Komplexität beim Schreiben von UI-Bibliotheken stark abgenommen hat.  Ja, um eine Bibliothek zu schreiben, die viele verwenden werden - es erfordert immer noch viel Zeit und Fachwissen, aber um einen Prototyp zu schreiben - der, wenn er in eine praktische API eingebunden ist, einsatzbereit ist - dauert es sehr wenig Zeit.  Wenn Sie daran interessiert sind, wie dies getan werden kann, lesen Sie weiter. <a name="habracut"></a></p><br><h4 id="zachem-eta-statya">  Warum dieser Artikel? </h4><br><p>  Zu einer Zeit auf Habré gab es eine Reihe von Artikeln - um X für 30 Codezeilen auf js zu schreiben. </p><br><p>  Ich dachte - ist es möglich, eine Reaktion in 30 Zeilen zu schreiben?  Ja, für 30 Zeilen war ich nicht erfolgreich, aber das Endergebnis entspricht dieser Zahl. </p><br><p>  Im Allgemeinen ist der Zweck des Artikels rein pädagogisch.  Dies kann zu einem etwas tieferen Verständnis des Prinzips des UI-Frameworks beitragen, das auf dem virtuellen Haus basiert.  In diesem Artikel möchte ich zeigen, wie einfach es ist, ein anderes UI-Framework basierend auf einem virtuellen Zuhause zu erstellen. </p><br><p>  Am Anfang möchte ich sagen, was ich mit dem UI-Framework meine - weil viele unterschiedliche Meinungen dazu haben.  Einige glauben beispielsweise, dass Angular und Ember ein UI-Framework sind und React nur eine Bibliothek, die die Arbeit mit dem Ansichtsteil der Anwendung erleichtert. </p><br><p>  Wir definieren das UI-Framework wie folgt: Dies ist eine Bibliothek, die beim Erstellen / Aktualisieren / Löschen von Seiten oder einzelnen Seitenelementen in diesem Sinne hilft. Eine ziemlich große Anzahl von Wrappern über die DOM-API kann sich als UI-Framework herausstellen. Die einzige Frage sind die Abstraktionsoptionen (API), die diese Bibliothek zum Bearbeiten des DOM bereitstellt und in der Wirksamkeit dieser Manipulationen </p><br><p>  In der vorgeschlagenen Formulierung ist - React ein ziemliches UI-Framework. </p><br><p>  Nun, mal sehen, wie Sie Ihre Reaktion mit Blackjack und mehr schreiben.  React verwendet bekanntermaßen das Konzept eines virtuellen Hauses.  In vereinfachter Form besteht es darin, dass die Knoten des realen DOM in strikter Übereinstimmung mit den Knoten des zuvor erstellten virtuellen DOM-Baums erstellt werden.  Eine direkte Manipulation des realen DOM ist nicht erwünscht. Wenn Sie Änderungen am realen DOM vornehmen müssen, die Änderungen am virtuellen DOM vorgenommen werden, wird die neue Version des virtuellen DOM mit der alten Version verglichen, die Änderungen werden gesammelt, die auf das reale DOM angewendet werden müssen, und sie werden so angewendet, dass die Interaktion mit dem realen DOM minimiert wird DOM - das macht die Anwendung optimaler. </p><br><p>  Da der virtuelle Hausbaum ein gewöhnliches Java-Skriptobjekt ist - es ist ziemlich einfach zu manipulieren - seine Knoten zu ändern / zu vergleichen, verstehe ich hier, dass der Assembler-Code virtuell, aber recht einfach ist und teilweise von einem Präprozessor aus einer deklarativen Sprache einer höheren JSX-Ebene generiert werden kann. </p><br><h4 id="nachnem-s-jsx">  Beginnen wir mit JSX </h4><br><p>  Dies ist ein Beispiel für JSX-Code </p><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> console.log('yo')}&gt; Submit </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Component</code> </pre> <br><p>  Wir müssen ein solches virtuelles DOM erstellen, wenn wir die <code>Component</code> aufrufen </p><br><pre> <code class="hljs powershell">const vdom = { type: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, props: { className: <span class="hljs-string"><span class="hljs-string">'main'</span></span> }, children: [ { <span class="hljs-type"><span class="hljs-type">type</span></span>: <span class="hljs-string"><span class="hljs-string">'input'</span></span> }, { <span class="hljs-type"><span class="hljs-type">type</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-type"><span class="hljs-type">props</span></span>: { <span class="hljs-type"><span class="hljs-type">onClick</span></span>: () =&gt; <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-string"><span class="hljs-string">'yo'</span></span>) }, <span class="hljs-type"><span class="hljs-type">children</span></span>: [<span class="hljs-string"><span class="hljs-string">'Submit'</span></span>] } ] }</code> </pre> <br><p>  Natürlich werden wir diese Transformation nicht manuell schreiben, wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Plugin verwenden</a> , das Plugin ist veraltet, aber es ist einfach genug, um zu verstehen, wie alles funktioniert.  Es verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsx-transform</a> , das JSX wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">folgt</a> konvertiert: </p><br><pre> <code class="hljs ruby">jsx.fromString(<span class="hljs-string"><span class="hljs-string">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">factory:</span></span> <span class="hljs-string"><span class="hljs-string">'h'</span></span> }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'h("h1", null, ["Hello World"])'</span></span></code> </pre> <br><p>  Alles, was wir tun müssen, ist den vdom-Konstruktor der h-Knoten zu implementieren, eine Funktion, die rekursiv virtuelle DOM-Knoten erstellt. Im Falle einer Reaktion führt die React.createElement-Funktion dies aus.  Nachfolgend finden Sie eine primitive Implementierung einer solchen Funktion </p><br><pre> <code class="hljs actionscript">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type, props, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...stack</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> children = (stack || []).reduce(addChild, []) props = props || {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> type === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ? { type, props, children } : type(props, children) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(node)) { acc = node.reduce(addChild, acc) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == node || <span class="hljs-literal"><span class="hljs-literal">true</span></span> === node || <span class="hljs-literal"><span class="hljs-literal">false</span></span> === node) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { acc.push(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> node === <span class="hljs-string"><span class="hljs-string">"number"</span></span> ? node + <span class="hljs-string"><span class="hljs-string">""</span></span> : node) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc }</code> </pre> <br><p>  Natürlich verkompliziert die Rekursion den Code hier ein wenig, aber ich hoffe, es ist klar, jetzt können wir mit dieser Funktion vdom erstellen </p><br><pre> <code class="hljs scala"><span class="hljs-symbol"><span class="hljs-symbol">'h</span></span>(<span class="hljs-string"><span class="hljs-string">"h1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>])' =&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'h</span></span>1', props:<span class="hljs-literal"><span class="hljs-literal">null</span></span>, children:[<span class="hljs-symbol"><span class="hljs-symbol">'Hello</span></span> <span class="hljs-type"><span class="hljs-type">World</span></span>']}</code> </pre> <br><p>  und so für Knoten einer Verschachtelung </p><br><p>  Großartig, jetzt gibt unsere Komponentenfunktion den vdom-Knoten zurück. </p><br><p>  Jetzt wird der <code></code> Teil sein, wir müssen eine <code>patch</code> Funktion schreiben, die das Root-DOM-Element der Anwendung, das alte Vdom, das neue Vdom verwendet und die Knoten des realen DOM gemäß dem neuen Vdom aktualisiert. </p><br><p>  Vielleicht können Sie diesen Code einfacher schreiben, aber es stellte sich heraus, dass ich den Code aus dem Picodom-Paket als Grundlage genommen habe </p><br><pre> <code class="hljs powershell">export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent, oldNode, newNode)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> patchElement(parent, parent.children[<span class="hljs-number"><span class="hljs-number">0</span></span>], oldNode, newNode) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patchElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent, element, oldNode, node, isSVG, nextSibling)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldNode == null) { element = parent.insertBefore(createElement(node, isSVG), element) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.type != oldNode.type) { const oldElement = element element = parent.insertBefore(createElement(node, isSVG), oldElement) removeElement(parent, oldElement, oldNode) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { updateElement(element, oldNode.props, node.props) isSVG = isSVG || node.type === <span class="hljs-string"><span class="hljs-string">"svg"</span></span> let childNodes = [] ; (element.childNodes || []).forEach(element =&gt; childNodes.push(element)) let oldNodeIdex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.children &amp;&amp; node.children.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; node.children.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldNode.children &amp;&amp; oldNodeIdex &lt;= oldNode.children.length &amp;&amp; (node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type &amp;&amp; node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type === oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>].type || (!node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>].type &amp;&amp; node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>] === oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>])) ) { patchElement(element, childNodes[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>], oldNode.children[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>], node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG) oldNodeIdex++ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let newChild = element.insertBefore( createElement(node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG), childNodes[<span class="hljs-type"><span class="hljs-type">oldNodeIdex</span></span>] ) patchElement(element, newChild, {}, node.children[<span class="hljs-type"><span class="hljs-type">i</span></span>], isSVG) } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = oldNodeIdex; i &lt; childNodes.length; i++) { removeElement(element, childNodes[<span class="hljs-type"><span class="hljs-type">i</span></span>], oldNode.children ? oldNode.children[<span class="hljs-type"><span class="hljs-type">i</span></span>] || {} : {}) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element }</code> </pre> <br><p>  Diese naive Implementierung, die schrecklich nicht optimal ist, berücksichtigt nicht die Bezeichner der Elemente (Schlüssel, ID) - um die erforderlichen Elemente in den Listen korrekt zu aktualisieren, funktioniert sie jedoch in primitiven Fällen einwandfrei. </p><br><p>  Die Implementierung der <code>createElement updateElement removeElement</code> ich bringe sie nicht hierher, es ist bemerkenswert, jeder, der interessiert ist, kann die Quelle <a href="">hier sehen</a> . </p><br><p>  Es gibt die einzige Einschränkung: Wenn die Werteigenschaften für <code>input</code> aktualisiert werden, sollte der Vergleich nicht mit dem alten vnode, sondern mit dem <code>value</code> Attribut im realen Haus durchgeführt werden. Dadurch wird verhindert, dass das aktive Element diese Eigenschaft aktualisiert (da es dort bereits aktualisiert wurde), und es werden Probleme mit dem Cursor vermieden und Auswahl. </p><br><p>  Nun, das ist alles, jetzt müssen wir nur noch diese Teile zusammenfügen und das UI-Framework schreiben <br>  Wir halten uns innerhalb von <a href="">5 Zeilen</a> . </p><br><ol><li>  Wie in React benötigen wir zum Erstellen der Anwendung 3 Parameter <br> <code>export function app(selector, view, initProps) {</code> <br>  Selektor - Root-Dom-Selektor, in dem die Anwendung gemountet wird (standardmäßig 'body') <br>  view - eine Funktion, die den Root-VNode erstellt <br>  initProps - Eigenschaften der ersten Anwendung </li><li>  Nehmen Sie das Stammelement in das DOM <br> <code>const rootElement = document.querySelector(selector || 'body')</code> </li> <li>  Wir sammeln vdom mit anfänglichen Eigenschaften <br> <code>let node = view(initProps)</code> </li> <li>  Wir mounten das empfangene Vdom im DOM als das alte Vdom, das wir für null halten <br> <code>patch(rootElement, null, node)</code> </li> <li>  Wir geben die Anwendungsaktualisierungsfunktion mit neuen Eigenschaften zurück <br> <code>return props =&gt; patch(rootElement, node, (node = view(props)))</code> </li> </ol><br><p>  <strong>Framework ist fertig!</strong> </p><br><p>  'Hallo Welt' in diesem Framework sieht folgendermaßen aus: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { h, app } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../src/index"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{`Hello ${state}`}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{state}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">oninput</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> render(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ) } const render = app('body', view, 'world')</span></span></code> </pre> <br><p>  Diese Bibliothek unterstützt wie React das Zusammensetzen von Komponenten sowie das Hinzufügen und Entfernen von Komponenten zur Laufzeit, sodass sie als <code></code> UI-Framework betrachtet werden kann.  Einen etwas komplexeren Anwendungsfall finden Sie hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ToDo-Beispiel</a> . </p><br><p>  Natürlich gibt es in dieser Bibliothek viele Dinge: Lebenszyklusereignisse (obwohl es nicht schwierig ist, sie zu befestigen, verwalten wir selbst das Erstellen / Aktualisieren / Löschen von Knoten), separate Aktualisierungen von untergeordneten Knoten wie this.setState (dazu müssen Sie für jedes Element Links zu DOM-Elementen speichern vdom-Knoten - dies wird die Logik etwas komplizieren), PatchElement-Code ist schrecklich nicht optimal, funktioniert bei einer großen Anzahl von Elementen nicht gut, verfolgt keine Elemente mit einem Bezeichner usw. </p><br><p>  In jedem Fall wurde die Bibliothek für Bildungszwecke entwickelt - verwenden Sie sie nicht in der Produktion :) </p><br><p>  <em>PS:</em> Ich wurde von der großartigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperapp-</a> Bibliothek für diesen Artikel inspiriert, ein Teil des Codes wurde von dort übernommen. </p><br><p>  Gute Codierung! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415857/">https://habr.com/ru/post/de415857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415845/index.html">Fragen Sie Ethan: Woher kennen wir das Alter des Sonnensystems?</a></li>
<li><a href="../de415847/index.html">Audiogerät für besondere Zwecke: Diktograph - von der Werkstatt und der Oper bis zum ersten technischen Meisterwerk des Abhörens von 1907</a></li>
<li><a href="../de415851/index.html">Roter Omega PS2 Emulator</a></li>
<li><a href="../de415853/index.html">Hayabusa 2 Mission: Asteroiden enthüllen die Geschichte des Sonnensystems</a></li>
<li><a href="../de415855/index.html">Erstellen eines Controllers basierend auf Fuzzy-Logik mit Mehrkanal-Tuning</a></li>
<li><a href="../de415859/index.html">RuSSIR 2018: 12. Sommerschule für Informationsbeschaffung</a></li>
<li><a href="../de415863/index.html">„Starten Sie die Woche richtig“: Welche Geräte helfen, Umgebungsgeräusche zu reduzieren und die Konzentration zu „fangen“</a></li>
<li><a href="../de415865/index.html">Markdown-Wissensdatenbank (oder Blog oder Projektdokumentation)</a></li>
<li><a href="../de415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../de415871/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 321 (25. Juni - 1. Juli 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>