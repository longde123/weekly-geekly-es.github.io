<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è ‚õπüèø üèñÔ∏è MVCC-1. L'isolement üóÑÔ∏è ‚úÇÔ∏è üç©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Avec cet article, je commence une s√©rie de boucles (ou une boucle de s√©ries? En g√©n√©ral, une grande id√©e) sur la structure interne de P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. L'isolement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Bonjour, Habr!  Avec cet article, je commence une s√©rie de boucles (ou une boucle de s√©ries? En g√©n√©ral, une grande id√©e) sur la structure interne de PostgreSQL. <br><br>  Le mat√©riel sera bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des cours de formation en</a> administration que nous faisons avec Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">pluzanov</a> .  Tout le monde n'aime pas regarder une vid√©o (je n'aime vraiment pas √ßa), mais lire des diapositives, m√™me avec des commentaires, est compl√®tement ¬´faux¬ª. <br><br>  Bien s√ªr, les articles ne r√©p√©teront pas le contenu des cours un √† un.  Je ne parlerai que de la fa√ßon dont tout fonctionne, en omettant l'administration elle-m√™me, mais j'essaierai de le faire plus en d√©tail et en d√©tail.  Et je crois que ces connaissances sont utiles au d√©veloppeur d'applications tout autant qu'√† l'administrateur. <br><br>  Je vais me concentrer sur ceux qui ont d√©j√† une certaine exp√©rience de l‚Äôutilisation de PostgreSQL et au moins en termes g√©n√©raux imaginer ce qui se passe.  Pour les d√©butants, le texte sera un peu lourd.  Par exemple, je ne dirai pas un mot sur la fa√ßon d'installer PostgreSQL et d'ex√©cuter psql. <br><br>  Les choses qui seront discut√©es ne changent pas beaucoup d'une version √† l'autre, mais j'utiliserai le 11e PostgreSQL ¬´vanille¬ª actuel. <br><br>  Le premier cycle est consacr√© aux questions li√©es √† l'isolement et au multiversion, et son plan est le suivant: <br><br><ol><li>  Isolement, tel que compris par la norme et PostgreSQL (cet article); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calques, fichiers, pages</a> - ce qui se passe au niveau physique; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Versions de lignes, transactions virtuelles et imbriqu√©es</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instantan√©s de donn√©es et visibilit√© des versions des lignes, horizon des √©v√©nements</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nettoyage sur la page et mises √† jour √† chaud</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nettoyage normal</a> (aspirateur); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nettoyage automatique</a> (autovacuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©bordement et gel du compteur de transactions</a> . </li></ol><br>  Eh bien, allons-y. <br><a name="habracut"></a><br><h1>  Qu'est-ce que l'isolation et pourquoi est-elle importante? </h1><br>  Tout le monde conna√Æt probablement au moins l'existence de transactions, a rencontr√© l'acronyme ACID et a entendu parler des niveaux d'isolement.  Mais il faut encore r√©pondre √† l'opinion qu'il s'agit d'une th√©orie qui n'est pas n√©cessaire dans la pratique.  Je vais donc passer un peu de temps √† expliquer pourquoi c'est vraiment important. <br><br>  Il est peu probable que vous soyez ravi si l'application re√ßoit des donn√©es incorrectes de la base de donn√©es ou si l'application √©crit des donn√©es incorrectes dans la base de donn√©es. <br><br>  Mais que sont les donn√©es ¬´correctes¬ª?  Il est connu qu'au niveau de la base de donn√©es, vous pouvez cr√©er des contraintes d'int√©grit√© (telles que NOT NULL ou UNIQUE).  Si les donn√©es satisfont toujours aux contraintes d'int√©grit√© (et c'est parce que le SGBD le garantit), alors elles sont holistiques. <br><br>  <em>Est-ce correct</em> et <em>int√©gral</em> - la m√™me chose?  Pas vraiment.  Toutes les restrictions ne peuvent pas √™tre formul√©es au niveau de la base de donn√©es.  Une partie des restrictions est trop compliqu√©e, par exemple, elle couvre plusieurs tableaux √† la fois.  Et m√™me si la restriction, en principe, pouvait √™tre d√©finie dans la base de donn√©es, mais pour une raison inconnue, cela ne signifie pas qu'elle peut √™tre viol√©e. <br><br>  Donc, l' <em>exactitude est</em> plus stricte que l' <em>int√©grit√©</em> , mais nous ne savons pas exactement ce que c'est.  Il reste √† reconna√Ætre que la norme de la d√©cision correcte est une application qui, comme nous voulons le croire, est √©crite <em>correctement</em> et ne se trompe jamais.  Dans tous les cas, si l'application ne viole pas l'int√©grit√©, mais viole l'exactitude, le SGBD ne le saura pas et ne prendra pas la main. <br><br>  D√©sormais, nous appellerons exactitude le terme coh√©rence. <br><br>  Supposons cependant que l'application ex√©cute uniquement la s√©quence d'instructions correcte.  Quel est alors le r√¥le du SGBD, si l'application est correcte? <br><br>  Premi√®rement, il s'av√®re qu'une s√©quence correcte d'instructions peut perturber temporairement la coh√©rence des donn√©es, ce qui - curieusement - est normal.  Un exemple galvaud√© mais compr√©hensible est de transf√©rer des fonds d'un compte √† un autre.  La r√®gle de coh√©rence peut ressembler √† ceci: un <em>transfert ne modifie jamais le montant total d'argent dans les comptes</em> (une telle r√®gle est plut√¥t difficile √† √©crire en SQL comme contrainte d'int√©grit√©, elle existe donc au niveau de l'application et est invisible pour le SGBD).  Un transfert se compose de deux op√©rations: la premi√®re r√©duit les fonds dans un compte, la seconde - augmente dans un autre.  La premi√®re op√©ration viole la coh√©rence des donn√©es, la seconde - restaure. <br><br><blockquote>  Un bon exercice consiste √† appliquer la r√®gle d√©crite ci-dessus au niveau des contraintes d'int√©grit√©.  √ätes-vous faible?  ¬© <br></blockquote><br>  Que faire si la premi√®re op√©ration est termin√©e et la seconde ne l'est pas?  Apr√®s tout, c'est facile: lors de la deuxi√®me op√©ration, l'√©lectricit√© peut √™tre perdue, le serveur peut tomber, la division par z√©ro peut se produire - mais on ne sait jamais.  Il est clair que la coh√©rence est viol√©e et cela ne devrait pas √™tre autoris√©.  En principe, il est possible de r√©soudre de telles situations au niveau de l'application au prix d'efforts incroyables, mais, heureusement, ce n'est pas n√©cessaire: le SGBD s'en charge.  Mais pour cela, elle doit savoir que deux op√©rations constituent un tout indivisible.  C'est une <em>transaction</em> . <br><br>  Cela s'av√®re int√©ressant: sachant que les op√©rations constituent une transaction, le SGBD permet de maintenir la coh√©rence en garantissant l'atomicit√© des transactions, sans rien savoir des r√®gles de coh√©rence sp√©cifiques. <br><br>  Mais il y a un deuxi√®me point, plus subtil.  D√®s que plusieurs transactions simultan√©es apparaissent dans le syst√®me qui sont absolument correctes une par une, elles peuvent fonctionner ensemble de mani√®re incorrecte.  Cela est d√ª au fait que l'ordre des op√©rations est mixte: on ne peut pas supposer que toutes les op√©rations d'une transaction sont effectu√©es en premier, et ensuite seulement toutes les op√©rations d'une autre. <br><br>  Une note sur la simultan√©it√©.  En effet, en m√™me temps, les transactions peuvent fonctionner sur un syst√®me avec un processeur multic≈ìur, avec une matrice de disques, etc. Mais toutes les m√™mes consid√©rations sont vraies pour un serveur qui ex√©cute des commandes s√©quentiellement, en mode temps partag√©: tant de cycles, une transaction est ex√©cut√©e, tant de cycles sont diff√©rents .  Parfois, le terme ex√©cution <em>concurrentielle</em> est utilis√© pour r√©sumer. <br><br>  Les situations o√π les transactions correctes ne fonctionnent pas correctement ensemble sont appel√©es <em>anomalies d'</em> ex√©cution simultan√©e. <br><br>  Un exemple simple: si une application veut obtenir les donn√©es correctes de la base de donn√©es, au moins elle ne devrait pas voir de changements dans les autres transactions non valid√©es.  Sinon, vous pouvez non seulement obtenir des donn√©es incoh√©rentes, mais √©galement voir quelque chose qui n'a jamais √©t√© dans la base de donn√©es (si la transaction est annul√©e).  Cette anomalie est appel√©e <em>lecture sale</em> . <br><br>  S'il existe d'autres anomalies plus complexes, que nous traiterons un peu plus tard. <br><br>  Bien s√ªr, il est impossible de refuser l'ex√©cution simultan√©e: sinon, quel type de performance peut-on discuter?  Mais vous ne pouvez pas travailler avec des donn√©es incorrectes. <br><br>  Et encore une fois, le SGBD vient √† la rescousse.  Vous pouvez ex√©cuter les transactions <em>comme si elles √©taient</em> s√©quentielles, <em>comme si</em> elles se succ√©daient.  En d'autres termes, <em>isol√©ment les</em> uns des autres.  En r√©alit√©, le SGBD peut effectuer des op√©rations m√©lang√©es, mais en m√™me temps garantir que le r√©sultat de l'ex√©cution simultan√©e co√Øncidera avec le r√©sultat de l'une des ex√©cutions s√©quentielles possibles.  Et cela √©limine toutes les anomalies possibles. <br><br>  Donc, nous arrivons √† la d√©finition: <br><br><blockquote>  Une transaction est l'ensemble des op√©rations effectu√©es par une application qui transf√®re la base de donn√©es d'un √©tat correct √† un autre √©tat correct (coh√©rence), √† ‚Äã‚Äãcondition que la transaction soit compl√®te (atomicit√©) et sans interf√©rence d'autres transactions (isolement). <br></blockquote><br>  Cette d√©finition combine les trois premi√®res lettres de l'acronyme ACID.  Ils sont si √©troitement li√©s les uns aux autres qu'il est tout simplement insens√© de consid√©rer l'un sans l'autre.  En fait, il est difficile d'arracher la lettre D (durabilit√©).  Apr√®s tout, en cas de panne du syst√®me, les modifications apport√©es aux transactions non valid√©es y restent, avec lesquelles vous devez faire quelque chose pour restaurer la coh√©rence des donn√©es. <br><br>  Tout irait bien, mais la mise en ≈ìuvre d'une isolation compl√®te est une t√¢che techniquement difficile, coupl√©e √† une diminution du d√©bit du syst√®me.  Par cons√©quent, dans la pratique, une isolation tr√®s souvent (pas toujours, mais presque toujours) affaiblie est appliqu√©e, ce qui emp√™che certaines anomalies, mais pas toutes.  Et cela signifie qu'une partie du travail visant √† garantir l'exactitude des donn√©es incombe √† l'application.  C'est pourquoi il est tr√®s important de comprendre quel niveau d'isolement est utilis√© dans le syst√®me, quelles garanties il donne et lesquelles il ne donne pas, et comment √©crire le code correct dans de telles conditions. <br><br><h1>  Niveaux d'isolation SQL et anomalies </h1><br>  Le standard SQL d√©crit depuis longtemps quatre niveaux d'isolement.  Ces niveaux sont d√©termin√©s en r√©pertoriant les anomalies autoris√©es ou non lors de l'ex√©cution de transactions √† ce niveau.  Par cons√©quent, pour parler de ces niveaux, vous devez vous familiariser avec les anomalies. <br><br>  Je souligne que dans cette partie, nous parlons de la norme, c'est-√†-dire d'une certaine th√©orie sur laquelle la pratique s'appuie fortement, mais qui est en m√™me temps en contradiction avec.  Par cons√©quent, tous les exemples ici sont sp√©culatifs.  Ils utiliseront les m√™mes op√©rations sur les comptes clients: c'est assez √©vident, m√™me si, certes, cela n'a rien √† voir avec la fa√ßon dont les op√©rations bancaires sont r√©ellement organis√©es. <br><br><h2>  Mise √† jour perdue </h2><br>  Commen√ßons par la <em>mise √† jour perdue</em> .  Cette anomalie se produit lorsque deux transactions lisent la m√™me ligne dans le tableau, puis une transaction met √† jour cette ligne, puis la deuxi√®me transaction met √©galement √† jour la m√™me ligne, sans tenir compte des modifications apport√©es par la premi√®re transaction. <br><br>  Par exemple, deux transactions vont augmenter le montant sur le m√™me compte de 100 ‚ÇΩ.  La premi√®re transaction lit la valeur actuelle (1000 ‚ÇΩ), puis la deuxi√®me transaction lit la m√™me valeur.  La premi√®re transaction augmente le montant (il s'av√®re 1100 ‚ÇΩ) et √©crit cette valeur.  La deuxi√®me transaction fait de m√™me - obtient les m√™mes 1 100 ‚ÇΩ et les √©crit.  En cons√©quence, le client a perdu 100 ‚ÇΩ. <br><br>  Les mises √† jour perdues ne sont autoris√©es par la norme √† aucun niveau d'isolement. <br><br><h2>  Lecture sale et lecture sans engagement </h2><br>  Avec une <em>lecture sale,</em> nous nous sommes d√©j√† rencontr√©s ci-dessus.  Cette anomalie se produit lorsqu'une transaction lit les modifications en attente apport√©es par une autre transaction. <br><br>  Par exemple, la premi√®re transaction transf√®re tout l‚Äôargent du compte du client vers un autre compte, mais n‚Äôenregistre pas la modification.  Une autre transaction lit l'√©tat du compte, re√ßoit 0 ‚ÇΩ et refuse d'√©mettre de l'argent au client - malgr√© le fait que la premi√®re transaction est interrompue et annule ses modifications, de sorte que la valeur 0 n'a jamais exist√© dans la base de donn√©es. <br><br>  Une lecture sale est autoris√©e par la norme au niveau de lecture non valid√©e. <br><br><h2>  Lecture non r√©p√©t√©e et lecture valid√©e </h2><br>  L'anomalie de <em>lecture non r√©p√©t√©e</em> se produit lorsqu'une transaction lit deux fois la m√™me ligne et, dans l'intervalle entre les lectures, la deuxi√®me transaction modifie (ou supprime) cette ligne et valide les modifications.  Ensuite, la premi√®re transaction obtiendra des r√©sultats diff√©rents. <br><br>  Par exemple, laissez la r√®gle de coh√©rence <em>interdire les montants n√©gatifs dans les comptes clients</em> .  La premi√®re transaction va r√©duire le montant du compte de 100 ‚ÇΩ.  Elle v√©rifie la valeur actuelle, obtient 1000 ‚ÇΩ et d√©cide qu'une r√©duction est possible.  √Ä ce stade, la deuxi√®me transaction r√©duit √† z√©ro le montant du compte et enregistre les modifications.  Si maintenant la premi√®re transaction rev√©rifiait le montant, elle recevrait 0 ‚ÇΩ (mais elle avait d√©j√† d√©cid√© de diminuer la valeur, et le compte ¬´passe √† moins¬ª). <br><br>  La lecture sans r√©p√©tition est autoris√©e par la norme aux niveaux Lecture non valid√©e et Lecture valid√©e.  Mais une lecture sale Read Committed ne le permet pas. <br><br><h2>  Lecture fant√¥me et lecture r√©p√©table </h2><br>  <em>La lecture fant√¥me</em> se produit lorsqu'une transaction lit deux fois un ensemble de lignes dans la m√™me condition, et dans l'intervalle entre les lectures, la deuxi√®me transaction ajoute des lignes qui satisfont √† cette condition (et valide les modifications).  Ensuite, la premi√®re transaction recevra diff√©rents ensembles de lignes. <br><br>  Par exemple, supposons qu'une r√®gle de coh√©rence <em>interdit √† un client d'avoir plus de 3 comptes</em> .  La premi√®re transaction va ouvrir un nouveau compte, v√©rifie leur num√©ro actuel (disons, 2) et d√©cide que l'ouverture est possible.  √Ä ce stade, la deuxi√®me transaction ouvre √©galement un nouveau compte pour le client et enregistre les modifications.  Si maintenant la premi√®re transaction rev√©rifie la quantit√©, elle en recevra 3 (mais elle ouvre d√©j√† un autre compte et le client en a 4). <br><br>  La lecture fant√¥me est autoris√©e par la norme aux niveaux de lecture non valid√©e, de lecture valid√©e et de lecture r√©p√©table.  Mais au niveau de lecture r√©p√©table, la lecture non r√©p√©titive n'est pas autoris√©e. <br><br><h2>  Manque d'anomalies et s√©rialisables </h2><br>  La norme d√©finit un autre niveau - s√©rialisable - auquel aucune anomalie n'est autoris√©e.  Et ce n'est pas du tout la m√™me chose que l'interdiction d'une mise √† jour perdue et d'une lecture sale, non r√©p√©titive et fant√¥me. <br><br>  Le fait est qu'il y a beaucoup plus d'anomalies connues que celles list√©es dans la norme, et un nombre inconnu est toujours inconnu. <br><br>  La s√©rialisation devrait emp√™cher <em>toutes les</em> anomalies <em>en g√©n√©ral</em> .  Cela signifie qu'√† ce niveau, le d√©veloppeur de l'application n'a pas besoin de penser √† s'ex√©cuter simultan√©ment.  Si les transactions effectuent les s√©quences d'instructions correctes, en travaillant seules, les donn√©es seront coh√©rentes avec le fonctionnement simultan√© de ces transactions. <br><br><h2>  Plaque de r√©sum√© </h2><br>  Vous pouvez maintenant apporter une table connue √† tout le monde.  Mais ici, pour plus de clart√©, la derni√®re colonne y est ajout√©e, qui n'est pas dans la norme. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  changements perdus </th><th>  lecture sale </th><th>  lecture non r√©p√©t√©e </th><th>  lecture fant√¥me </th><th>  autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  oui </th><th>  oui </th><th>  oui </th><th>  oui </th></tr><tr><th>  Lire engag√© </th><th>  - </th><th>  - </th><th>  oui </th><th>  oui </th><th>  oui </th></tr><tr><th>  Lecture r√©p√©table </th><th>  - </th><th>  - </th><th>  - </th><th>  oui </th><th>  oui </th></tr><tr><th>  S√©rialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Pourquoi exactement ces anomalies? </h2><br>  Pourquoi seulement quelques-unes des nombreuses anomalies possibles dans la norme sont-elles r√©pertori√©es, et pourquoi sont-elles? <br><br>  Apparemment, personne ne semble le savoir avec certitude.  Mais la pratique ici a d√©finitivement d√©pass√© la th√©orie, il est donc possible que nous n'ayons pas pens√© √† d'autres anomalies (discours sur la norme SQL: 92). <br><br>  De plus, on a suppos√© que l'isolation devait √™tre construite sur des verrouillages.  L'id√©e du <em>protocole de blocage √† deux phases</em> largement utilis√© (2PL) est que pendant la transaction, la transaction bloque les lignes avec lesquelles elle travaille et, une fois termin√©e, elle lib√®re les verrous.  En simplifiant consid√©rablement, plus une transaction capture de verrous, mieux elle est isol√©e des autres transactions.  Mais les performances du syst√®me souffrent encore plus, car au lieu de travailler ensemble, les transactions commencent √† s'aligner pour les m√™mes lignes. <br><br>  Il me semble que la diff√©rence entre les niveaux d'isolement de la norme s'explique pr√©cis√©ment par le nombre de verrous n√©cessaires. <br><br>  Si une transaction emp√™che les lignes modifi√©es de changer, mais pas de lire, nous obtenons le niveau Lecture non valid√©e: les modifications perdues ne sont pas autoris√©es, mais les donn√©es non valid√©es peuvent √™tre lues. <br><br>  Si la transaction emp√™che les lignes mutables de lire et de changer, nous obtenons le niveau de lecture valid√©e: vous ne pouvez pas lire les donn√©es non valid√©es, mais lorsque vous acc√©dez √† nouveau √† la ligne, vous pouvez obtenir une valeur diff√©rente (lecture non r√©p√©t√©e). <br><br>  Si une transaction bloque √† la fois la lecture et la modification des lignes lisibles et mutables, nous obtenons le niveau de lecture r√©p√©table: la lecture r√©p√©t√©e de la ligne produira la m√™me valeur. <br><br>  Mais il y a un probl√®me avec Serializable: il n'est pas possible de verrouiller une ligne qui n'existe pas encore.  Pour cette raison, la possibilit√© de lecture fant√¥me reste: une autre transaction peut ajouter (mais pas supprimer) une ligne qui tombe dans les conditions d'une requ√™te pr√©c√©demment ex√©cut√©e, et cette ligne sera r√©cup√©r√©e. <br><br>  Par cons√©quent, pour impl√©menter le niveau de s√©rialisable, les verrous ordinaires ne suffisent pas - vous devez bloquer non pas les lignes, mais les conditions (pr√©dicats).  Ces verrous √©taient appel√©s <em>pr√©dicats</em> .  Ils ont √©t√© propos√©s en 1976, mais leur applicabilit√© pratique est limit√©e par des conditions assez simples, pour lesquelles il est clair comment combiner deux pr√©dicats diff√©rents.  Pour autant que je sache, il n'a pas √©t√© possible de mettre en ≈ìuvre de tels verrous dans aucun syst√®me. <br><br><h1>  Niveaux d'isolement PostgreSQL </h1><br>  Au fil du temps, Snapshot Isolation a remplac√© les <em>protocoles de</em> gestion des transactions bloquantes.  Son id√©e est que chaque transaction fonctionne avec un instantan√© coh√©rent des donn√©es √† un certain moment, dans lequel ne tombent que les modifications enregistr√©es avant la cr√©ation de l'instantan√©. <br><br>  Une telle isolation ne permet pas automatiquement une lecture sale.  Formellement, dans PostgreSQL, vous pouvez sp√©cifier le niveau de lecture non valid√©e, mais cela fonctionnera exactement comme Read Committed.  Par cons√©quent, nous ne parlerons plus du niveau de lecture non valid√©e. <br><br>  PostgreSQL impl√©mente une <em>multi-</em> version de ce protocole.  L'id√©e du multi-version est que plusieurs versions de la m√™me cha√Æne peuvent coexister dans un SGBD.  Cela vous permet de cr√©er un instantan√© des donn√©es en utilisant les versions disponibles et de vous en tirer avec un minimum de verrous.  En fait, seuls les changements r√©p√©t√©s sur la m√™me ligne sont bloqu√©s.  Toutes les autres op√©rations sont effectu√©es en m√™me temps: les transactions d'√©criture ne bloquent jamais les transactions de lecture et les transactions de lecture ne bloquent jamais personne. <br><br>  En utilisant des instantan√©s de donn√©es, l'isolation dans PostgreSQL est plus stricte que la norme l'exige: le niveau de lecture r√©p√©table ne permet pas seulement des lectures non r√©p√©titives, mais aussi fant√¥mes (bien qu'il ne fournisse pas une isolation compl√®te).  Et cela est r√©alis√© sans perte d'efficacit√©. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  changements perdus </th><th>  lecture sale </th><th>  lecture non r√©p√©t√©e </th><th>  lecture fant√¥me </th><th>  autres anomalies </th></tr><tr><th>  Lire sans engagement </th><th>  - </th><th>  - </th><th>  oui </th><th>  oui </th><th>  oui </th></tr><tr><th>  Lire engag√© </th><th>  - </th><th>  - </th><th>  oui </th><th>  oui </th><th>  oui </th></tr><tr><th>  Lecture r√©p√©table </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  oui </th></tr><tr><th>  S√©rialisable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Comment le multi-versioning est mis en ≈ìuvre ¬´sous le capot¬ª, nous parlerons dans les articles suivants, et maintenant nous examinerons en d√©tail chacun des trois niveaux √† travers les yeux de l'utilisateur (comme vous le savez, le plus int√©ressant se cache derri√®re ¬´d'autres anomalies¬ª).  Pour ce faire, cr√©ez un tableau des comptes.  Alice et Bob ont chacun 1 000 $, mais Bob a deux comptes ouverts: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lire engag√© </h2><br><h3>  Manque de lecture sale </h3><br>  Il est facile de v√©rifier que les donn√©es sales ne peuvent pas √™tre lues.  Commen√ßons la transaction.  Par d√©faut, il utilisera le niveau d'isolement Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Plus pr√©cis√©ment, le niveau par d√©faut est d√©fini par le param√®tre, il peut √™tre modifi√© si n√©cessaire: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Ainsi, dans une transaction ouverte, nous retirons des fonds du compte, mais n'enregistrons pas les changements.  La transaction voit ses propres changements: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Dans la deuxi√®me session, nous d√©marrons une autre transaction avec le m√™me niveau de lecture valid√©e.  Pour distinguer les diff√©rentes transactions, les commandes de la deuxi√®me transaction seront mises en retrait et barr√©es. <br><br>  Afin de r√©p√©ter les commandes ci-dessus (ce qui est utile), vous devez ouvrir deux terminaux et ex√©cuter psql dans chacun.  Dans le premier, vous pouvez entrer les commandes d'une transaction, et dans le second - les commandes d'une autre. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Comme pr√©vu, une autre transaction ne voit pas de modifications non valid√©es - une lecture incorrecte n'est pas autoris√©e. <br><br><h3>  Lecture non r√©p√©t√©e </h3><br>  Maintenant, laissez la premi√®re transaction valider les modifications et la seconde r√©ex√©cute la m√™me demande. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La demande re√ßoit d√©j√† de nouvelles donn√©es - c'est l'anomalie de la <em>lecture non r√©p√©t√©e</em> , qui est autoris√©e au niveau de lecture valid√©e. <br><br>  <em>Conclusion pratique</em> : dans une transaction, il est impossible de prendre des d√©cisions sur la base des donn√©es lues par l'instruction pr√©c√©dente - car tout peut changer entre le moment o√π les instructions sont ex√©cut√©es.  Voici un exemple dont les variations sont si courantes dans le code d'application qu'il s'agit d'un antipattern classique: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Pendant le temps qui s'√©coule entre la v√©rification et la mise √† jour, d'autres transactions peuvent changer l'√©tat du compte comme souhait√©, de sorte qu'un tel ¬´ch√®que¬ª ne sauve rien.  Il est commode d‚Äôimaginer qu‚Äôentre les op√©rateurs d‚Äôune transaction, tout autre op√©rateur d‚Äôautres transactions peut se ¬´coincer¬ª, par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Si, en r√©organisant les op√©rateurs, vous pouvez tout g√¢cher, le code est mal √©crit.  Et ne vous trompez pas qu'une telle combinaison de circonstances ne se produira pas - elle se produira. <br><br>  Comment √©crire correctement le code?  Les opportunit√©s se r√©sument g√©n√©ralement √† ce qui suit: <br><br><ul><li>  N'√©crivez pas de code. <br>  Ce n'est pas une blague.  Par exemple, dans ce cas, la v√©rification se transforme facilement en contrainte d'int√©grit√©: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  D√©sormais, aucune v√©rification n'est n√©cessaire: il suffit d'ex√©cuter simplement l'action et, si n√©cessaire, de g√©rer l'exception qui se produira en cas de tentative de violation de l'int√©grit√©. <br></li><li>  Utilisez une seule instruction SQL. <br>  Des probl√®mes de coh√©rence surviennent du fait que dans l'intervalle entre les op√©rateurs une autre transaction peut se terminer et les donn√©es visibles changeront.  Et s'il n'y a qu'un seul op√©rateur, il n'y a pas de lacunes. <br>  PostgreSQL dispose de suffisamment d'outils pour r√©soudre des probl√®mes complexes avec une seule instruction SQL.  Nous notons les expressions de table g√©n√©rales (CTE), dans lesquelles, entre autres, vous pouvez utiliser les instructions INSERT / UPDATE / DELETE, ainsi que l'instruction INSERT ON CONFLICT, qui impl√©mente la logique "ins√©rer, et s'il y a d√©j√† une ligne, mettre √† jour" dans une instruction. <br></li><li>  Verrous utilisateur. <br>  Le dernier recours consiste √† d√©finir manuellement un verrou exclusif soit sur toutes les lignes n√©cessaires (SELECT FOR UPDATE), soit sur toute la table (LOCK TABLE).  Cela fonctionne toujours, mais annule les avantages de la multi-version: au lieu de s'ex√©cuter simultan√©ment, une partie des op√©rations sera effectu√©e s√©quentiellement. <br></li></ul><br><h3>  Lecture incoh√©rente </h3><br>  Avant de se lancer dans le prochain niveau d'isolement, il faut admettre que tout n'est pas si simple.  L'impl√©mentation de PostgreSQL est telle qu'elle permet d'autres anomalies moins connues qui ne sont pas r√©glement√©es par la norme. <br><br>  Disons que la premi√®re transaction a commenc√© √† transf√©rer des fonds d'un compte Bob √† un autre: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  √Ä ce moment, une autre transaction calcule le solde de Bob, le calcul √©tant effectu√© dans un cycle sur tous les comptes de Bob.  En fait, la transaction commence √† partir du premier compte (et, √©videmment, voit l'√©tat pr√©c√©dent): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  √Ä ce stade, la premi√®re transaction se termine avec succ√®s: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et l'autre lit l'√©tat du deuxi√®me compte (et voit d√©j√† une nouvelle valeur): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ainsi, la deuxi√®me transaction a re√ßu un total de 1100 ‚ÇΩ, c'est-√†-dire des donn√©es incorrectes.  Il s'agit d'une anomalie de <em>lecture incoh√©rente</em> . <br><br>  Comment √©viter une telle anomalie en restant chez Read Committed?  Bien s√ªr, utilisez un seul op√©rateur.  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Jusqu'√† pr√©sent, j'ai soutenu que la visibilit√© des donn√©es ne peut changer qu'entre op√©rateurs, mais est-ce si √©vident?  Et si la demande est ex√©cut√©e pendant une longue p√©riode, peut-elle voir une partie des donn√©es dans un √©tat et une partie dans un autre? <br><br>  V√©rifiez-le.  Un moyen pratique de le faire consiste √† ins√©rer un retard artificiel dans l'op√©rateur en appelant la fonction pg_sleep.  Son param√®tre d√©finit le temps de retard en secondes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Pendant que cette construction est en cours, dans une autre transaction, nous reversons des fonds: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Le r√©sultat montre que l'op√©rateur voit les donn√©es dans l'√©tat dans lequel elles se trouvaient au moment de leur d√©marrage.  C'est certainement vrai. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Mais ici, ce n'est pas si simple.  PostgreSQL vous permet de d√©finir des fonctions, tandis que les fonctions ont le concept d'une <em>cat√©gorie de variabilit√©</em> .  Si une fonction <em>volatile</em> (avec la cat√©gorie VOLATILE) est appel√©e dans une demande et qu'une autre demande est ex√©cut√©e dans cette fonction, cette demande √† l'int√©rieur de la fonction verra des donn√©es qui ne sont pas coh√©rentes avec les donn√©es de la demande principale. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dans ce cas, nous obtenons des donn√©es incorrectes - 100 ‚ÇΩ sont perdus: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Je souligne qu'un tel effet n'est possible qu'au niveau d'isolement Read Committed, et uniquement avec la cat√©gorie de variabilit√© VOLATILE.  Le probl√®me est que ce niveau d'isolement et cette cat√©gorie de variabilit√© sont utilis√©s par d√©faut, donc je dois admettre - le r√¢teau est tr√®s bien.  Ne marchez pas! <br><br><h3>  Lecture incoh√©rente en √©change de modifications perdues </h3><br>  Une lecture incoh√©rente dans le cadre d'un op√©rateur peut - de mani√®re quelque peu inattendue - √™tre obtenue lors d'une mise √† jour. <br><br>  Voyons ce qui se passe lorsque vous essayez de modifier la m√™me ligne avec deux transactions.  Bob a maintenant 1000 ‚ÇΩ sur deux comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Nous commen√ßons une transaction qui r√©duit le solde de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Dans le m√™me temps, une autre transaction porte int√©r√™t sur tous les comptes clients avec un solde total √©gal ou sup√©rieur √† 1000 ‚ÇΩ: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  L'ex√©cution d'une instruction UPDATE se compose de deux parties.  Tout d'abord, un SELECT est r√©ellement ex√©cut√©, qui s√©lectionne les lignes correspondant √† la condition de mise √† jour.  Le changement de la premi√®re transaction n'√©tant pas fig√©, la deuxi√®me transaction ne peut pas le voir et n'affecte pas le choix des lignes de calcul des int√©r√™ts.  Ainsi, les comptes de Bob sont soumis √† la condition et une fois la mise √† jour termin√©e, son solde devrait augmenter de 10 ‚ÇΩ. <br><br>  La deuxi√®me √©tape de l'ex√©cution - les lignes s√©lectionn√©es sont mises √† jour l'une apr√®s l'autre.  Ici, la deuxi√®me transaction est forc√©e de ¬´geler¬ª, car la ligne id = 3 est d√©j√† verrouill√©e par la premi√®re transaction. <br><br>  Pendant ce temps, la premi√®re transaction valide les modifications: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel sera le r√©sultat? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Oui, d'une part, la commande UPDATE ne doit pas voir de changements dans la deuxi√®me transaction.  Mais d'un autre c√¥t√©, il ne devrait pas perdre les changements enregistr√©s lors de la deuxi√®me transaction. <br><br>  Une fois le verrou lib√©r√©, UPDATE relit la ligne qu'il tente de mettre √† jour (mais une seule!).  Le r√©sultat est que Bob a accumul√© 9 ‚ÇΩ, sur la base du montant de 900 ‚ÇΩ.  Mais si Bob en avait 900 ‚ÇΩ, ses comptes n'auraient pas du tout d√ª √™tre inclus dans l'√©chantillon. <br><br>  Ainsi, la transaction re√ßoit des donn√©es incorrectes: certaines des lignes sont visibles √† un moment donn√©, d'autres √† l'autre.  Au lieu d'une mise √† jour perdue, nous obtenons √† nouveau une anomalie dans la <em>lecture incoh√©rente</em> . <br><br><blockquote>  Les lecteurs attentifs notent qu'avec l'aide de l'application au niveau de lecture valid√©e, vous pouvez obtenir une mise √† jour perdue.  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  La base de donn√©es n'est pas √† bl√¢mer: elle re√ßoit deux instructions SQL et ne sait rien que la valeur de x + 100 est en quelque sorte li√©e √† accounts.amount.  N'√©crivez pas de code de cette fa√ßon. <br></blockquote><br><h2>  Lecture r√©p√©table </h2><br><h3>  Manque de lectures non r√©p√©titives et fant√¥mes </h3><br>  Le nom du niveau d'isolement lui-m√™me indique que la lecture est r√©p√©table.  Nous v√©rifierons cela, et en m√™me temps nous serons convaincus de l'absence de lectures fant√¥mes.  Pour ce faire, dans la premi√®re transaction, remettez les comptes de Bob √† leur √©tat pr√©c√©dent et cr√©ez un nouveau compte pour Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Dans la deuxi√®me session, nous d√©marrons la transaction avec le niveau de lecture r√©p√©table, en l'indiquant dans la commande BEGIN (le niveau de la premi√®re transaction n'est pas important). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  √Ä pr√©sent, la premi√®re transaction valide les modifications et la seconde r√©ex√©cute la m√™me demande. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  La deuxi√®me transaction continue de voir exactement les m√™mes donn√©es qu'au d√©but: ni les modifications des lignes existantes ni les nouvelles lignes ne sont visibles. <br><br>  √Ä ce niveau, vous n'avez pas √† vous soucier de quelque chose qui change entre les deux op√©rateurs. <br><br><h3>  Erreur de s√©rialisation en √©change de modifications perdues </h3><br>  Nous avons indiqu√© ci-dessus que lors de la mise √† jour de la m√™me ligne avec deux transactions au niveau de lecture valid√©e, une anomalie de lecture incoh√©rente peut se produire.  Cela est d√ª au fait que la transaction en attente relit la ligne verrouill√©e et ne la voit donc pas au m√™me moment que les autres lignes. <br><br>  Au niveau de lecture r√©p√©table, une telle anomalie n'est pas autoris√©e, mais si elle se produit toujours, rien ne peut √™tre fait - par cons√©quent, la transaction se termine avec une erreur de s√©rialisation.  Nous v√©rifions en r√©p√©tant le m√™me sc√©nario avec des pourcentages: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Les donn√©es sont rest√©es coh√©rentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  La m√™me erreur se produira dans le cas de tout autre changement de ligne concurrentiel, m√™me si les colonnes qui nous int√©ressent n'ont pas r√©ellement chang√©. <br><br>  <em>Conclusion pratique</em> : si l'application utilise le niveau d'isolement Lecture r√©p√©table pour l'√©criture de transactions, elle doit √™tre pr√™te √† r√©p√©ter les transactions qui se sont termin√©es par une erreur de s√©rialisation.  Pour les transactions en lecture seule, un tel r√©sultat n'est pas possible. <br><br><h3>  Entr√©e incoh√©rente </h3><br>  Ainsi, dans PostgreSQL, au niveau d'isolement de la lecture r√©p√©table, toutes les anomalies d√©crites dans la norme sont √©vit√©es.  Mais pas du tout.  Il s'av√®re qu'il y a <em>exactement deux</em> anomalies qui restent possibles.  (Cela est vrai non seulement pour PostgreSQL, mais aussi pour d'autres impl√©mentations d'isolement bas√©es sur des instantan√©s.) <br><br>  La premi√®re de ces anomalies est un <em>enregistrement incoh√©rent</em> . <br><br>  Laissez cette r√®gle de coh√©rence s'appliquer: <em>les montants n√©gatifs sont autoris√©s sur les comptes du client si le montant total sur tous les comptes de ce client reste non n√©gatif</em> . <br><br>  La premi√®re transaction re√ßoit le montant dans les comptes de Bob: 900 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  La deuxi√®me transaction re√ßoit le m√™me montant. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  La premi√®re transaction estime √† juste titre que le montant de l'un des comptes peut √™tre r√©duit de 600 ‚ÇΩ. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Et la deuxi√®me transaction arrive √† la m√™me conclusion.  Mais r√©duit un autre score: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Nous avons r√©ussi √† r√©duire le solde de Bob, bien que chacune des transactions fonctionne correctement individuellement. <br><br><h3>  Anomalie en lecture seule </h3><br>  Il s'agit de la deuxi√®me et derni√®re des anomalies possibles au niveau de la lecture r√©p√©table.  Pour le d√©montrer, vous aurez besoin de trois transactions, dont deux modifieront les donn√©es et la troisi√®me - en lecture seule. <br><br>  Mais d'abord, restaurez l'√©tat du compte de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  La premi√®re transaction facture √† Bob des int√©r√™ts sur le montant des fonds de tous les comptes.  Les int√©r√™ts sont cr√©dit√©s sur l'un de ses comptes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Puis une autre transaction retire de l'argent d'un autre compte de Bob et capture ses modifications: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Si √† ce moment la premi√®re transaction est valid√©e, il n'y aura pas d'anomalie: on pourrait supposer que la premi√®re transaction a √©t√© r√©alis√©e en premier, puis la seconde (mais pas l'inverse, car la premi√®re transaction a vu l'√©tat du compte id = 3 avant que ce compte ne soit modifi√© par la deuxi√®me transaction). <br><br>  Mais supposons qu'√† ce moment la troisi√®me transaction (en lecture seule) commence, qui lit le statut d'un compte qui n'est pas affect√© par les deux premi√®res transactions: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Et seulement apr√®s que la premi√®re transaction soit termin√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Quel √©tat la troisi√®me transaction devrait-elle voir maintenant? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Apr√®s avoir commenc√©, la troisi√®me transaction pourrait voir des changements dans la deuxi√®me transaction (qui √©tait d√©j√† valid√©e), mais pas la premi√®re (qui n'a pas encore √©t√© valid√©e).  En revanche, nous avons d√©j√† √©tabli ci-dessus que la deuxi√®me transaction doit √™tre consid√©r√©e comme ayant commenc√© apr√®s la premi√®re.  Quel que soit l'√©tat de la troisi√®me transaction, il sera incoh√©rent - c'est l'anomalie de la transaction de lecture uniquement.  Mais au niveau de lecture r√©p√©table, il est autoris√©: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  S√©rialisable </h2><br>  Au niveau s√©rialisable, toutes les anomalies possibles sont √©vit√©es.  En fait, Serializable est impl√©ment√© comme un compl√©ment d'isolement bas√© sur des instantan√©s de donn√©es.  Les anomalies qui ne se produisent pas pendant la lecture r√©p√©table (telles que la lecture sale, non r√©p√©table et fant√¥me) ne se produisent pas au niveau de s√©rialisable.  Et les anomalies qui surviennent (enregistrement incoh√©rent et anomalie de la transaction de lecture uniquement) sont d√©tect√©es et la transaction est abandonn√©e - l'erreur de s√©rialisation d√©j√† connue n'a pas pu s√©rialiser l'acc√®s. <br><br><h3>  Entr√©e incoh√©rente </h3><br>  Pour illustrer, nous r√©p√©tons le sc√©nario avec une anomalie d'enregistrement incoh√©rent: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  En plus du niveau de lecture r√©p√©table, une application utilisant le niveau d'isolement s√©rialisable doit r√©p√©ter les transactions qui se sont termin√©es par une erreur de s√©rialisation, qui nous est √©galement signal√©e par l'indication dans le message d'erreur. <br><br>  Nous obtenons la simplicit√© de la programmation, mais le prix √† payer est la rupture forc√©e d'une certaine proportion de transactions et la n√©cessit√© de les r√©p√©ter.  Toute la question, bien s√ªr, est de savoir quelle est cette part.  Si seulement ces transactions √©taient termin√©es qui se croisent vraiment de mani√®re incompatiable dans les donn√©es avec d'autres transactions, tout serait bien.  Mais une telle mise en ≈ìuvre se r√©v√©lerait in√©vitablement gourmande en ressources et inefficace, car elle devrait suivre les op√©rations avec chaque ligne. <br><br>  En fait, l'impl√©mentation de PostgreSQL est telle qu'elle autorise de faux d√©clencheurs n√©gatifs: certaines transactions tout √† fait normales qui ¬´n'ont simplement pas de chance¬ª seront interrompues.  Comme nous le verrons plus loin, cela d√©pend de nombreuses raisons, par exemple, la disponibilit√© d'index appropri√©s ou la quantit√© de RAM disponible.  De plus, il existe d'autres restrictions d'impl√©mentation (plut√¥t s√©rieuses), par exemple, les demandes au niveau s√©rialisable ne fonctionneront pas sur les r√©pliques, les plans d'ex√©cution parall√®les ne seront pas utilis√©s pour elles.  Et bien que le travail d'am√©lioration de la mise en ≈ìuvre ne s'arr√™te pas, mais les restrictions existantes r√©duisent l'attractivit√© de ce niveau d'isolement. <br><blockquote>  Des plans parall√®les appara√Ætront dans PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> ).  Et les requ√™tes sur les r√©pliques peuvent gagner dans PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre patch</a> ). <br></blockquote><br><h3>  Anomalie en lecture seule </h3><br>  Pour que seule une transaction de lecture ne puisse pas conduire √† une anomalie et n'en souffre pas, PostgreSQL propose un m√©canisme int√©ressant: une telle transaction peut √™tre bloqu√©e jusqu'√† ce que son ex√©cution soit s√ªre.  C'est le seul cas o√π une instruction SELECT peut √™tre bloqu√©e par des mises √† jour de lignes.  Voici √† quoi √ßa ressemble: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  La troisi√®me transaction n'est explicitement d√©clar√©e que par le lecteur (LIRE UNIQUEMENT) et diff√©r√©e (DEFERRABLE): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Lorsque vous essayez d'ex√©cuter une demande, la transaction est bloqu√©e, car sinon son ex√©cution entra√Ænera une anomalie. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et seulement apr√®s la validation de la premi√®re transaction, la troisi√®me continue √† s'ex√©cuter: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Autre remarque importante: si l'isolement s√©rialisable est utilis√©, toutes les transactions de l'application doivent utiliser ce niveau.  Vous ne pouvez pas m√©langer les transactions Read Committed (ou Repeatable Read) avec Serializable.  Autrement dit, vous pouvez m√©langer quelque chose, mais alors Serializable se comportera comme une lecture r√©p√©table sans avertissement.   ,   ,     . <br><br>      Serializble ‚Äî       ( , ,      ): <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>    ,   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    ¬´   ¬ª. <br></blockquote><br><h1>    ? </h1><br>   Read Committed   PostgreSQL   ,   ,        .   ,          ,     .  ,     . <br><br>        ,     .          ,     .         SQL-,      .   ,       ,     ,              . <br><br>   Repeatable Read    , , ,  .        ,     ,      . , , .          Read Committed   , ,   ,   SQL-. <br><br> ,  Serializable      ,     . ,     ‚Äî        .    ,   ,           .   ,   Serializable    ,  ,        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442804/">https://habr.com/ru/post/fr442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442790/index.html">L'inscription est ouverte pour Allure Server Meetup √† Saint-P√©tersbourg</a></li>
<li><a href="../fr442794/index.html">Nous vous invitons √† la conf√©rence ¬´Architecte (IT) dans les projets et organisations IT¬ª</a></li>
<li><a href="../fr442796/index.html">Enqu√™te: technologies cloud dans les services SIG et de g√©odonn√©es</a></li>
<li><a href="../fr442798/index.html">La surveillance des pings entre les h√¥tes Kubernetes est notre recette</a></li>
<li><a href="../fr442800/index.html">Bot Telegram simple en Python en 30 minutes</a></li>
<li><a href="../fr442806/index.html">Le programme pr√©liminaire DUMP-2019 est pr√™t. Intervenants de Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../fr442808/index.html">Nous vous invitons √† la Droid Party - une r√©union consacr√©e aux probl√®mes pratiques de d√©veloppement d'applications et d'appareils Android</a></li>
<li><a href="../fr442810/index.html">Mythes de la physique populaire, suite: gravit√©</a></li>
<li><a href="../fr442812/index.html">"Je ne vois aucune raison d'utiliser Python pour travailler avec Spark, √† part la paresse"</a></li>
<li><a href="../fr442814/index.html">10 ans se sont √©coul√©s, et personne n'a compris comment utiliser la blockchain. Et l√† encore?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>