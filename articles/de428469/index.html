<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº ü¶ë üë• Einzelner Windows-Kernel üî∞ üë¥üèº üõéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows ist eines der vielf√§ltigsten und flexibelsten Betriebssysteme, es funktioniert auf v√∂llig unterschiedlichen Architekturen und ist in verschied...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einzelner Windows-Kernel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428469/"> Windows ist eines der vielf√§ltigsten und flexibelsten Betriebssysteme, es funktioniert auf v√∂llig unterschiedlichen Architekturen und ist in verschiedenen Versionen verf√ºgbar.  Heute werden x86-, x64-, ARM- und ARM64-Architekturen unterst√ºtzt.  Windows unterst√ºtzte einst Itanium, PowerPC, DEC Alpha und MIPS.  Dar√ºber hinaus unterst√ºtzt Windows eine Vielzahl von SKUs, die unter verschiedenen Bedingungen ausgef√ºhrt werden.  Von Rechenzentren, Laptops, Xbox und Telefonen bis hin zu eingebetteten Versionen des Internet der Dinge, beispielsweise in Geldautomaten. <br><br>  Das Erstaunlichste ist, dass der Windows-Kernel in Abh√§ngigkeit von all diesen Architekturen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SKUs</a> praktisch unver√§ndert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bleibt</a> .  Der Kernel wird je nach Architektur und Prozessor, auf dem er arbeitet, dynamisch skaliert, um die Ger√§te optimal nutzen zu k√∂nnen.  Nat√ºrlich verf√ºgt der Kernel √ºber eine bestimmte Menge an Code, die einer bestimmten Architektur zugeordnet ist, aber es gibt nur eine minimale Menge davon, sodass Windows auf einer Vielzahl von Architekturen ausgef√ºhrt werden kann. <br><br>  In diesem Artikel werde ich √ºber die Entwicklung der wichtigsten Teile des Windows-Kernels sprechen, die es ihm erm√∂glichen, transparent vom verbrauchsarmen NVidia Tegra-Chip auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Surface RT</a> 2012 bis zu den riesigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monstern</a> in Azure-Rechenzentren zu skalieren. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55551i89F6A2C912C5C448/image-size/large?v=1.0&amp;px=999"></div><br>  Ein Windows-Task-Manager, der auf einem Windows DataCenter-Vorabversionscomputer ausgef√ºhrt wird. 896 Kerne unterst√ºtzen 1792 logische Prozessoren und 2 TB Speicher <br><br><h2>  Single Core Evolution </h2><br>  Bevor wir uns mit den Details des Windows-Kernels befassen, wollen wir uns ein wenig mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring befassen</a> .  Refactoring spielt eine Schl√ºsselrolle bei der Erh√∂hung der Wiederverwendung von Betriebssystemkomponenten auf verschiedenen SKUs und Plattformen (z. B. Client, Server und Telefon).  Die Grundidee des Refactorings besteht darin, dass Sie dieselbe DLL auf verschiedenen SKUs wiederverwenden k√∂nnen und dabei kleine √Ñnderungen unterst√ºtzen, die speziell f√ºr die gew√ºnschte SKU vorgenommen wurden, ohne die DLL umzubenennen und ohne die Arbeit von Anwendungen zu unterbrechen. <br><br>  Die Kerntechnologie des Windows-Refactorings ist eine wenig dokumentierte Technologie namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Sets</a> .  API-Suites sind ein Mechanismus, mit dem das Betriebssystem die DLL und ihren Verwendungsort trennen kann.  Mit dem API-Set k√∂nnen Anwendungen f√ºr win32 beispielsweise weiterhin kernel32.dll verwenden, obwohl die Implementierung aller APIs in einer anderen DLL geschrieben ist.  Diese Implementierungs-DLLs k√∂nnen sich auch zwischen SKUs unterscheiden.  Sie k√∂nnen die API-S√§tze in Aktion sehen, indem Sie die Abh√§ngigkeits√ºberquerung auf einer herk√∂mmlichen Windows-DLL ausf√ºhren, z. B. kernel32.dll. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55556i8BF228D9318A85CC/image-size/large?v=1.0&amp;px=999"></div><br>  Nachdem Sie diesen Exkurs √ºber die Struktur von Windows abgeschlossen haben, der es dem System erm√∂glicht, die Wiederverwendung und Freigabe von Code zu maximieren, gehen wir zu den technischen Tiefen des Startens des Kernels gem√§√ü dem Scheduler √ºber, der der Schl√ºssel zur Skalierung des Betriebssystems ist. <br><br><h2>  Kernel-Komponenten </h2><br>  Windows NT ist in der Tat ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikrokernel</a> in dem Sinne, dass es einen eigenen Kernel (KE) mit einem begrenzten Satz von Funktionen hat, der die ausf√ºhrbare Schicht (Executive Layer, Ex) verwendet, um alle Richtlinien auf hoher Ebene auszuf√ºhren.  EX ist immer noch im Kernel-Modus, es ist also nicht gerade ein Mikrokernel.  Der Kernel ist f√ºr das Planen von Threads, das Synchronisieren zwischen Prozessoren, das Behandeln von Ausnahmen auf Hardwareebene und das Implementieren von hardwareabh√§ngigen Funktionen auf niedriger Ebene verantwortlich.  Die EX-Schicht enth√§lt verschiedene Subsysteme, die eine Reihe von Funktionen bereitstellen, die normalerweise als Kern betrachtet werden - E / A, Objektmanager, Speichermanager, Prozesssubsystem usw. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55558i85CBB1B2E72B3E88/image-size/large?v=1.0&amp;px=999"></div><br>  Um die Gr√∂√üe der Komponenten besser zu verstehen, finden Sie hier eine ungef√§hre Aufschl√ºsselung der Anzahl der Codezeilen in mehreren Schl√ºsselverzeichnissen des Kernel-Quellbaums (einschlie√ülich Kommentaren).  Die Tabelle enth√§lt noch nicht alles, was mit dem Kernel zu tun hat. <br><br><table><tbody><tr><th>  Kernel-Subsysteme </th><th>  Codezeilen </th></tr><tr><td>  Speichermanager </td><td>  501.000 </td></tr><tr><td>  Registrierung </td><td>  211.000 </td></tr><tr><td>  Macht </td><td>  238.000 </td></tr><tr><td>  Exekutive </td><td>  157.000 </td></tr><tr><td>  Sicherheit </td><td>  135.000 </td></tr><tr><td>  Kernel </td><td>  339.000 </td></tr><tr><td>  Subsystem verarbeiten </td><td>  116.000 </td></tr></tbody></table><br>  Weitere Informationen zur Windows-Architektur finden Sie in der Buchreihe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Internals</a> . <br><br><h2>  Planer </h2><br>  Nachdem wir den Boden auf diese Weise vorbereitet haben, wollen wir ein wenig √ºber den Scheduler, seine Entwicklung und dar√ºber sprechen, wie der Windows-Kernel mit so vielen Prozessoren auf so viele verschiedene Architekturen skaliert werden kann. <br><br>  Ein Thread ist eine Grundeinheit, die Programmcode ausf√ºhrt, und genau seine Arbeit plant der Windows-Scheduler.  Bei der Entscheidung, welcher Thread gestartet werden soll, verwendet der Scheduler seine Priorit√§ten. Theoretisch sollte der Thread mit der h√∂chsten Priorit√§t auf dem System gestartet werden, auch wenn dies bedeutet, dass f√ºr Threads mit niedrigeren Priorit√§ten keine Zeit mehr bleibt. <br><br>  Nachdem der Thread die Quantenzeit (die Mindestzeit, die ein Thread arbeiten kann) gearbeitet hat, nimmt die dynamische Priorit√§t ab, so dass Threads mit hoher Priorit√§t nicht f√ºr immer funktionieren k√∂nnen, die Seele aller anderen.  Wenn ein anderer Thread zur Arbeit aufwacht, erh√§lt er eine Priorit√§t, die auf der Grundlage der Wichtigkeit des Ereignisses berechnet wird, das das Warten verursacht hat (z. B. wird die Priorit√§t f√ºr die Front-End-Benutzeroberfl√§che stark erh√∂ht und nicht viel - um E / A-Vorg√§nge abzuschlie√üen).  Daher arbeitet ein Thread mit hoher Priorit√§t, w√§hrend er interaktiv bleibt.  Wenn es vorwiegend mit Berechnungen verbunden wird (CPU-gebunden), sinkt seine Priorit√§t und sie kehren zu ihm zur√ºck, nachdem andere Threads mit hoher Priorit√§t ihre Prozessorzeit haben.  Dar√ºber hinaus erh√∂ht der Kernel willk√ºrlich die Priorit√§t von vorgefertigten Threads, die f√ºr einen bestimmten Zeitraum keine Prozessorzeit erhalten haben, um deren Rechenmangel zu verhindern und die Priorit√§tsinversion zu korrigieren. <br><br>  Der Windows Scheduler hatte anfangs eine Bereitschaftswarteschlange, aus der er den n√§chsten Thread mit der h√∂chsten Priorit√§t zum Ausf√ºhren ausw√§hlte.  Mit dem Beginn der Unterst√ºtzung f√ºr eine zunehmende Anzahl von Prozessoren wurde die einzige Warteschlange jedoch zu einem Engpass, und der Scheduler √§nderte die Arbeit im Windows Server 2003-Release-Bereich und organisierte eine Bereitschaftswarteschlange pro Prozessor.  Beim Wechsel zur Unterst√ºtzung mehrerer Anforderungen f√ºr einen Prozessor wurde keine einzige globale Sperre durchgef√ºhrt, um alle Warteschlangen zu sch√ºtzen, und der Scheduler konnte Entscheidungen auf der Grundlage lokaler Optima treffen.  Dies bedeutet, dass zu jedem Zeitpunkt im System ein Thread mit der h√∂chsten Priorit√§t vorhanden ist, dies bedeutet jedoch nicht unbedingt, dass N der Threads mit der h√∂chsten Priorit√§t in der Liste (wobei N die Anzahl der Prozessoren ist) im System arbeiten.  Dieser Ansatz hat sich ausgezahlt, bis Windows auf CPUs mit geringem Stromverbrauch wie Laptops und Tablets umstieg.  Wenn der Thread mit den h√∂chsten Priorit√§ten auf solchen Systemen nicht funktionierte (z. B. der Front-End-Thread der Benutzeroberfl√§che), f√ºhrte dies zu merklichen Schnittstellenfehlern.  Daher wurde in Windows 8.1 der Scheduler auf ein Hybridmodell √ºbertragen, mit Warteschlangen f√ºr jeden Prozessor f√ºr Threads, die diesem Prozessor zugeordnet sind, und einer gemeinsam genutzten Warteschlange mit vorgefertigten Prozessen f√ºr alle Prozessoren.  Dies wirkte sich nicht merklich auf die Leistung aus, da andere √Ñnderungen in der Scheduler-Architektur vorgenommen wurden, z. B. das Refactoring einer Dispatcher-Datenbanksperre. <br><br>  In Windows 7 wurde ein dynamischer Fair-Share-Scheduler (Dynamic Fair-Share-Scheduler, DFSS) eingef√ºhrt.  Dies betraf haupts√§chlich Terminalserver.  Diese Funktion hat versucht, das Problem zu l√∂sen, dass eine Terminalsitzung mit einer hohen CPU-Auslastung Threads in anderen Terminalsitzungen beeinflussen kann.  Da der Scheduler Sitzungen nicht ber√ºcksichtigte und lediglich die Priorit√§t zum Verteilen von Flows verwendete, konnten Benutzer in verschiedenen Sitzungen die Arbeit von Benutzern in anderen Sitzungen beeinflussen, indem sie ihre Flows erw√ºrgten.  Es gab auch Sitzungen (und Benutzern) mit einer gro√üen Anzahl von Threads einen unfairen Vorteil, da eine Sitzung mit einer gro√üen Anzahl von Threads mehr M√∂glichkeiten hatte, Prozessorzeit zu erhalten.  Es wurde versucht, dem Scheduler eine Regel hinzuzuf√ºgen, nach der jede Sitzung in Bezug auf die Prozessorzeit den anderen gleichgestellt wurde.  √Ñhnliche Funktionen gibt es unter Linux mit ihrem v√∂llig ehrlichen Scheduler ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Completely Fair Scheduler</a> ).  In Windows 8 wurde dieses Konzept als Scheduler-Gruppe verallgemeinert und dem Scheduler hinzugef√ºgt, wodurch jede Sitzung in eine unabh√§ngige Gruppe fiel.  Zus√§tzlich zu den Priorit√§ten f√ºr die Threads verwendet der Scheduler die Scheduler-Gruppen als Index der zweiten Ebene und entscheidet, welcher Thread als N√§chstes gestartet werden soll.  Auf dem Terminalserver haben alle Scheduler-Gruppen das gleiche Gewicht, sodass alle Sitzungen unabh√§ngig von der Anzahl oder Priorit√§t der Threads innerhalb der Scheduler-Gruppen die gleiche Prozessorzeit erhalten.  Dar√ºber hinaus werden solche Gruppen auch zur genaueren Steuerung von Prozessen verwendet.  In Windows 8 wurden Jobobjekte erweitert, um die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozessorzeitverwaltung</a> zu unterst√ºtzen.  Mithilfe einer speziellen API k√∂nnen Sie entscheiden, wie viel Prozessorzeit ein Prozess verwenden kann, falls es sich um ein weiches oder hartes Limit handelt, und Benachrichtigungen erhalten, wenn der Prozess diese Limits erreicht.  Dies √§hnelt der Ressourcenverwaltung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cgroups</a> unter Linux. <br><br>  Ab Windows 7 hat Windows Server die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr mehr als 64 logische Prozessoren</a> auf einem einzelnen Computer eingef√ºhrt.  Um so viele Prozessoren zu unterst√ºtzen, wurde im System eine neue Kategorie eingef√ºhrt, die ‚ÄûProzessorgruppe‚Äú.  Eine Gruppe ist eine unver√§nderliche Menge von logischen Prozessoren mit nicht mehr als 64 Teilen, die von einem Scheduler als Recheneinheit betrachtet werden.  Der Kernel beim Booten bestimmt, welcher Prozessor zu welcher Gruppe geh√∂rt, und bei Computern mit weniger als 64 Prozessorkernen ist dieser Ansatz kaum zu bemerken.  Ein Prozess kann in mehrere Gruppen unterteilt werden (z. B. eine Instanz von SQL Server). Es kann jeweils nur ein Thread innerhalb derselben Gruppe ausgef√ºhrt werden. <br><br>  Auf Computern mit einer Anzahl von mehr als 64 CPU-Kernen zeigte Windows jedoch neue Engp√§sse, die verhinderten, dass anspruchsvolle Anwendungen wie SQL Server mit zunehmender Anzahl von Prozessorkernen linear skaliert wurden.  Daher zeigten Geschwindigkeitsmessungen selbst mit dem Hinzuf√ºgen neuer Kerne und Speicher keinen signifikanten Anstieg.  Eines der Hauptprobleme war der Streit um die Blockierung der Dispatcher-Basis.  Durch das Sperren der Dispatcher-Datenbank wurde der Zugriff auf Objekte gesch√ºtzt, deren Arbeit geplant werden musste.  Zu diesen Objekten geh√∂ren Threads, Timer, Eingabe- / Ausgabeports und andere Kernelobjekte, die warten m√ºssen (Ereignisse, Semaphoren, Mutexe).  Unter dem Druck der Notwendigkeit, solche Probleme zu l√∂sen, wurde in Windows 7 daran gearbeitet, die Blockierung der Dispatcher-Datenbank zu beseitigen und durch genauere Anpassungen zu ersetzen, z. B. das blockweise Sperren von Objekten.  Auf diese Weise konnten Leistungsmessungen wie SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TPC-C</a> bei einigen Konfigurationen eine Geschwindigkeitssteigerung von 290% im Vergleich zum vorherigen Schema nachweisen.  Es war eine der gr√∂√üten Leistungssteigerungen in der Windows-Geschichte, die aufgrund einer √Ñnderung einer einzelnen Funktion aufgetreten ist. <br><br>  Windows 10 brachte eine weitere Innovation mit sich, indem es CPU-Sets einf√ºhrte.  Mit CPU-Sets kann ein Prozess ein System partitionieren, sodass ein Prozess auf mehrere Prozessorgruppen verteilt werden kann, sodass andere Prozesse diese nicht verwenden k√∂nnen.  Der Windows-Kernel erlaubt nicht einmal Ger√§te-Interrupts, die in Ihrem Set enthaltenen Prozessoren zu verwenden.  Dadurch wird sichergestellt, dass selbst Ger√§te ihren Code nicht auf Prozessoren ausf√ºhren k√∂nnen, die an die Gruppe Ihrer Anwendung ausgegeben wurden.  Es sieht aus wie eine virtuelle Low-Tech-Maschine.  Es ist klar, dass dies eine leistungsstarke Funktion ist, in die so viele Sicherheitsma√ünahmen integriert sind, dass der Anwendungsentwickler bei der Arbeit mit der API keine gro√üen Fehler macht.  Die Funktionalit√§t der CPU-Sets wird im Spielemodus verwendet. <br><br>  Schlie√ülich kommen wir zur Unterst√ºtzung von ARM64, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das in Windows 10 erschien</a> .  Die ARM-Architektur unterst√ºtzt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">big.LITTLE-</a> Architektur, die heterogener Natur ist - der "gro√üe" Kern ist schnell und verbraucht viel Energie, und der "kleine" Kern ist langsam und verbraucht weniger.  Die Idee ist, dass unbedeutende Aufgaben auf einem kleinen Kern ausgef√ºhrt werden k√∂nnen, wodurch Batterie gespart wird.  Um die big.LITTLE-Architektur zu unterst√ºtzen und die Akkulaufzeit unter Windows 10 unter ARM zu verl√§ngern, wurde dem Scheduler eine heterogene Layoutunterst√ºtzung hinzugef√ºgt, die die W√ºnsche einer Anwendung ber√ºcksichtigt, die mit der big.LITTLE-Architektur arbeitet. <br><br>  Mit W√ºnschen meine ich, dass Windows versucht, qualitativ hochwertige Dienste f√ºr Anwendungen bereitzustellen, Threads zu verfolgen, die im Vordergrund ausgef√ºhrt werden (oder denen die Prozessorzeit fehlt), und deren Ausf√ºhrung auf dem "gro√üen" Kern zu gew√§hrleisten.  Alle Hintergrundaufgaben, Dienste und anderen Hilfsthreads werden auf kleinen Kernen ausgef√ºhrt.  Auch im Programm k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie die</a> geringe Bedeutung des Threads <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwangsweise notieren</a> , damit er auf einem kleinen Kern funktioniert. <br><br>  Arbeiten f√ºr eine andere Person [Im Namen arbeiten]: In Windows wird viel Arbeit im Vordergrund von anderen Diensten ausgef√ºhrt, die im Hintergrund arbeiten.  Wenn Sie beispielsweise in Outlook suchen, wird die Suche selbst vom Indexer-Hintergrunddienst ausgef√ºhrt.  Wenn wir nur alle Dienste auf einem kleinen Kern ausf√ºhren, leiden die Qualit√§t und Geschwindigkeit der Anwendungen im Vordergrund.  Um zu verhindern, dass big.LITTLE-Architekturen in solchen Arbeitsszenarien langsamer werden, √ºberwacht Windows Anwendungsaufrufe, die an andere Prozesse gesendet werden, um die Arbeit in ihrem Namen auszuf√ºhren.  In diesem Fall geben wir dem Thread, der sich auf den Dienst bezieht, die Priorit√§t im Vordergrund und erzwingen, dass er auf dem gro√üen Kern ausgef√ºhrt wird. <br><br>  Lassen Sie mich diesen ersten Artikel √ºber den Windows-Kernel beenden, der einen √úberblick √ºber den Scheduler gibt.  Artikel mit √§hnlichen technischen Details zur internen Funktionsweise des Betriebssystems werden sp√§ter folgen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428469/">https://habr.com/ru/post/de428469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428453/index.html">Wie Programmierer ihre Heimat retteten</a></li>
<li><a href="../de428457/index.html">Labels umgehen: SoundCloud hat direkte Vertr√§ge mit Musikern abgeschlossen - Bedingungen kritisiert</a></li>
<li><a href="../de428461/index.html">Aufbau eines verteilten VPN-Netzwerks basierend auf Check Point. Mehrere g√§ngige Szenarien</a></li>
<li><a href="../de428465/index.html">Leitfaden zur Analyse der Gesch√§ftsauswirkungen</a></li>
<li><a href="../de428467/index.html">Alles ist unter Kontrolle. Warum brauchen wir √úberwachungssysteme f√ºr die technische Infrastruktur von Rechenzentren?</a></li>
<li><a href="../de428471/index.html">Das Urheberrecht ist in der Geschichte der Videospiele noch besser geworden</a></li>
<li><a href="../de428475/index.html">Wie Designer sich t√§uschen</a></li>
<li><a href="../de428477/index.html">F√ºr diejenigen, die eine Firewall w√§hlen</a></li>
<li><a href="../de428481/index.html">Digitale Vertr√§ge: Eine Kurzanleitung f√ºr NICHT Anw√§lte</a></li>
<li><a href="../de428485/index.html">Die meisten nervigen Menschen sind irrelevante Werbung und die Verwendung von Gadgets in der √ñffentlichkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>