<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃 💇🏿 💑 Curso MIT "Seguridad de sistemas informáticos". Lección 16: Ataques a través del canal lateral, Parte 2 👈🏻 😶 👩‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 16: Ataques a través del canal lateral, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/429392/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 3: “Desbordamientos del búfer: exploits y protección” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 4: “Separación de privilegios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 5: “¿De dónde vienen los sistemas de seguridad?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lección 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 7: “Sandbox de cliente nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 8: "Modelo de seguridad de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 9: "Seguridad de aplicaciones web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 10: “Ejecución simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 11: "Ur / Lenguaje de programación web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 12: Seguridad de red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 13: "Protocolos de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 14: "SSL y HTTPS" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 15: "Software médico" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 16: "Ataques de canal lateral" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Audiencia:</b> ¿cómo determinar x e y primero? <br><br>  <b>Profesor:</b> para esto debes mirar al expositor en representación binaria.  Supongamos que trato de calcular el valor de c <sup>1011010</sup> , el grado también puede consistir en un mayor número de bits.  Si queremos volver a cuadrar, entonces necesitamos mirar el bit más bajo, aquí está 0. <br><br><img src="https://habrastorage.org/webt/w_/6d/9i/w_6d9ilu4jpxs9k9sa-myz5wlog.jpeg"><br><br>  Por lo tanto, obtenemos la igualdad c <sup>1011010</sup> = (c <sup>101101</sup> ) <sup>2</sup> <br><br>  A continuación, necesitamos calcular c <sup>101101</sup> , aquí no podemos usar esta regla, porque no es 2x, será x más 1. Por lo tanto, escribimos esta igualdad: <br><br>  c <sup>101101</sup> = (c <sup>10110</sup> ) <sup>2</sup> c, porque este prefijo 101101 = 10110 + 1. <br><br>  Por lo tanto, multiplicamos el cuadrado por c, por lo que lo usamos para volver a cuadrado. <br><br>  Para las "ventanas deslizantes" necesitamos capturar más bits del extremo inferior.  Si quieres hacer un truco aquí con una "ventana deslizante" en lugar de extraer uno de aquí, entonces teniendo en cuenta esta enorme tabla, podemos tomar 3 bits a la vez, aferrándonos a c7.  Si tomamos los primeros 3 bits de un grado, obtenemos c <sup>101101</sup> = (c <sup>101</sup> ) <sup>8</sup> c <sup>101</sup> . <br><br>  En este caso, realmente tenemos la misma cantidad de cálculos para (c <sup>101</sup> ) <sup>8</sup> , pero puede ver el valor de c <sup>101</sup> en la tabla.  Y la parte en forma de (c <sup>101</sup> ) <sup>8</sup> dice que va a usar "ventanas deslizantes" para calcular su valor. <br><br><img src="https://habrastorage.org/webt/zw/ok/iz/zwokizdxzsucmo17lyvarjp0m1o.jpeg"><br><br>  Esto ahorra mucho tiempo, ya que permite utilizar valores multiplicados previamente.  Hace 10 años se creía que una tabla de valores de hasta 32 grados es el plan óptimo en términos de eficiencia computacional, porque hay algún tipo de compromiso aquí, ¿verdad?  Dedica tiempo a crear esta tabla, pero no debería ser demasiado grande si no va a utilizar algunos registros con frecuencia.  Suponga que si crea una tabla de valores de hasta c <sup>500</sup> grados, pero no va a utilizar exponentes con un valor superior a 128, simplemente pierda su tiempo. <br><br>  <b>Público:</b> ¿hay alguna razón para no crear una mesa tan gigante de antemano?  Es decir, calcular los valores de un número limitado de grados que se pueden eludir en los cálculos. <br><br>  <b>Profesor:</b> si no desea realizar cálculos volumétricos por adelantado ... bueno, hay dos cosas.  Una es que debe tener un código para verificar si el registro requerido en la tabla está lleno o no, y esto probablemente reducirá la precisión de la predicción de las ramas de los procesos de la CPU.  Al mismo tiempo, en el caso general, el procesador funcionará más lentamente, ya que tendrá que verificar si el registro requerido está en la tabla.  La segunda cosa, que es algo molesta, podría ser la pérdida de entradas de la tabla a través de varios canales laterales, es decir, a través de patrones de acceso a caché.  Entonces, si tiene algún otro proceso ejecutándose en el mismo procesador, puede ver qué direcciones de caché se eliminan del caché o se ralentizan porque alguien tiene acceso a grabar c <sup>3</sup> o grabar c <sup>31</sup> .  Y cuanto más grande sea esta tabla, más fácil será determinar qué bits de exponente se utilizan para crear la clave RSA. <br><br>  Esta tabla gigante puede decir qué dirección de caché se perdió para el procesador, es decir, indica que el proceso de cifrado debe tener acceso a esta entrada en la tabla.  A su vez, esto le indica que la secuencia de bits dada aparece en el exponente de su clave privada.  Por lo tanto, supongo que matemáticamente puede completar esta tabla tanto como sea necesario, pero en la práctica no desea que resulte de un tamaño gigantesco.  Además, no podrá utilizar eficazmente entradas de tabla enormes.  Es mucho más útil usar los registros de una tabla relativamente pequeña repetidamente, por ejemplo, para calcular c <sup>7,</sup> puede usar el valor c <sup>3</sup> dos veces y así sucesivamente. <br><br>  Por lo tanto, aquí está la optimización de RSA mediante el reencuadre y los métodos de "ventana deslizante".  No sé si todavía usan este tamaño de "ventanas deslizantes", pero en cualquier caso, acelera el proceso de cálculo, porque de lo contrario tendría que cuadrar cada bit del exponente y luego multiplicarlo por cada bit.  Por lo tanto, si tiene un exponente de 500 bits, entonces tendría que completar 500 cuadrados y aproximadamente 256 multiplicaciones por c.  Con las "ventanas deslizantes" todavía tiene que hacer 512 cuadrados, porque esto no se puede evitar, pero el número de multiplicaciones por c disminuirá de 256 a aproximadamente 32 debido al uso de entradas de la tabla. <br><br>  Este es el plan de optimización general, que acelera el proceso de cálculo aproximadamente una vez y media.  Esta es una optimización bastante simple.  Hay dos trucos inteligentes con números que hacen que el proceso de multiplicación sea más eficiente. <br><br>  La primera es la transformación de Montgomery, en un segundo veremos por qué esto es especialmente importante para nosotros.  Esta optimización está tratando de resolver un problema para nosotros, que es que cada vez que hacemos la multiplicación, obtenemos un número que continúa creciendo y creciendo en orden creciente.  En particular, tanto en las "ventanas deslizantes" como en el nuevo cuadratura, en realidad multiplicaste 2 números juntos cuando elevaste c a la potencia de y. <br><br>  El problema es que si los datos de entrada c <sup>x</sup> y c <sup>y</sup> para la multiplicación fueran, digamos, 512 bits cada uno, entonces el tamaño del resultado de la multiplicación sería 1000 bits.  Después de eso, toma este resultado de 1000 bits y lo multiplica nuevamente por algo así como 512 bits, se convierte en el tamaño de 1500, 2000, 2500 bits y todo crece y crece. <br><br>  Sin embargo, no desea esto, porque la multiplicación aumenta el orden de los números multiplicados.  Debido a esto, debemos mantener el tamaño de nuestro número lo más pequeño posible, básicamente igual a 512 bits, porque todos estos cálculos son mod p o mod q. <br><br>  Podemos reducir este número, por ejemplo, queremos calcular (((c <sup>x</sup> ) <sup>2</sup> ) <sup>2</sup> ) <sup>2</sup> .  Lo que podría hacer es, por ejemplo, calcular cx módulo p, luego volverlo al cuadrado nuevamente módulo p y nuevamente al cuadrado módulo p.  Este método es relativamente bueno, porque nos permite mantener el tamaño de nuestro número dentro de 512 bits, es decir, lo más pequeño que podamos obtener.  Esto es bueno en el sentido de reducir el tamaño de los números que necesitamos multiplicar, pero de hecho, la operación con este módulo p "aumenta significativamente el costo" del cálculo. <br><br><img src="https://habrastorage.org/webt/j2/8z/p2/j28zp2waavtrlhxb_agi5dedmh8.jpeg"><br><br>  Porque la forma de obtener mod p es en división.  Y la división es peor que la multiplicación.  No enumeraré los algoritmos para la división, pero es muy lento.  Por lo general, intenta evitar las operaciones de división siempre que sea posible, porque esta no es una programación fácil.  El hecho es que necesita usar algún tipo de algoritmos de aproximación, métodos de Newton y similares, y todo esto ralentizará el proceso de cálculo. <br><br>  La multiplicación es mucho más rentable, pero usar las operaciones mod p o mod q para reducir el tamaño de los números costará más que la multiplicación.  Le mostraré una forma de evitar esto y cómo hacer cálculos rápidos utilizando la transformación Montgomery. <br><br>  La idea básica es representar los enteros que vas a multiplicar en forma de transformación de Montgomery.  Esto es realmente muy fácil.  Para hacer esto, simplemente multiplicamos nuestro número a por un cierto valor mágico R. Después de un segundo te diré de qué se trata.  Pero primero descubramos qué sucede cuando seleccionamos un valor arbitrario de R. <br><br>  Entonces, tomamos 2 números, a y b, y los convertimos a la representación de Montgomery, multiplicando cada uno por R. Entonces el producto de a y b en la transformación de Montgomery se verá así: <br><br>  ab &lt;-&gt; (aR) (bR) / R = abR <br><br>  Es decir, multiplicas aR por bR y obtienes el producto de ab por R al cuadrado.  Ahora tenemos dos R, esto es un poco molesto, pero puede dividirlo por R. Como resultado, obtenemos el producto de ab por R. No está claro por qué necesitábamos multiplicar este número una vez más.  Primero descubramos si esto es correcto, y luego entenderemos por qué será más rápido. <br>  Esto es correcto en el sentido de que es muy fácil.  Si desea multiplicar algunos números, debe multiplicarlos por este valor de R y obtener la transformación Montgomery.  Cada vez que multiplicamos estos 2 números, debemos dividirlos entre R y luego observar la forma resultante de la transformación de la forma abR.  Luego, cuando terminemos de cuadrar, multiplicar y todas estas cosas, volveremos a la forma normal y ordinaria del resultado, simplemente dividiendo por R por última vez. <br><br><img src="https://habrastorage.org/webt/mi/jh/jo/mijhjogewp0y5aant8x9lk61gpg.jpeg"><br><br>  Ahora considere cómo elegir el número más adecuado para R para que la división por R sea una operación muy rápida.  Y lo mejor aquí es que si la división por R es muy rápida cuando es un número pequeño, y no tenemos que hacer este mod q con demasiada frecuencia.  En particular, aR, digamos, también tendrá un tamaño de aproximadamente 500 bits, porque todo esto es en realidad mod p o mod q.  Por lo tanto, aR es de 500 bits, bR también será de 500 bits, de modo que el producto (aR) (bR) será de 1000 bits.  R también será un número conveniente de 500 bits, el tamaño de p.  Y si podemos hacer que la operación de división sea lo suficientemente rápida, entonces el resultado de ab también será aproximadamente un número de 500 bits, de modo que podamos multiplicar sin la necesidad de una división adicional.  Dividir por R es mucho más rentable y nos da un pequeño resultado, lo que evita el uso de mod p en la mayoría de las situaciones. <br><br>  Entonces, ¿cuál es este extraño número R del que estoy hablando todo el tiempo?  Tiene un valor de 2 a 512 grados: <br><br>  R = 2 <sup>512</sup> <br><br>  Será 1 y un montón de ceros, por lo que es fácil multiplicar por ese número, porque es suficiente para agregar un montón de ceros al resultado.  La división también puede ser simple si los bits menos significativos del resultado son cero.  Entonces, si tiene un valor de un montón de bits acompañado de 512 ceros, dividir entre 2 y 512 grados será muy simple: simplemente coloca ceros en el lado derecho, y esta es una operación de división completamente correcta. <br><br>  El pequeño problema es que en realidad no tenemos ceros en el lado derecho cuando haces esta multiplicación.  Tenemos números reales de 512 bits con los 512 bits. <br><br>  El producto de (aR) por (bR) también es un número real del orden de 1000 bits, por lo que no podemos soltar los bits menos significativos.  Pero un enfoque razonable se basa en el hecho de que lo único que nos preocupa es el valor de mod p.  Por lo tanto, siempre puede agregar múltiples p a este valor sin cambiar su equivalente de mod p.  Como resultado, podemos agregar múltiplos de valores de p para que todos los bits menos significativos se conviertan en ceros.  Veamos algunos ejemplos simples.  No voy a escribir 512 bits en la pizarra, pero solo daré un breve ejemplo. <br><br>  Supongamos que en nuestra situación R = 2 <sup>4</sup> = 10000. Este es un tamaño mucho más pequeño de lo que realmente es.  Veamos cómo funciona esta transformación de Montgomery.  Intentamos calcular mod q, donde q = 7.  En forma binaria q = 7 es (111). <br><br>  Supongamos además que realizamos alguna multiplicación (aR) (bR), y en representación binaria el resultado es 11010, es decir, este será el valor del producto (aR) (bR).  ¿Cómo lo dividimos por R? <br><br>  Obviamente, no los cuatro bits menos significativos son ceros, por lo que no podemos separarlos, sino que podemos agregar cantidades que son múltiplos de q.  En particular, podemos agregar 2 veces en q, con 2q = 1110 en representación binaria.  Como resultado de la suma, obtenemos 101000, espero haber hecho todo bien. <br><br><img src="https://habrastorage.org/webt/yy/vp/8f/yyvp8ffoelgybgl_ntariqw3uvi.jpeg"><br><br>  Entonces obtuvimos la suma (aR) (bR) + 2q.  De hecho, no nos importa + 2q, porque lo único que nos importa es el valor de mod q.  Ahora estamos más cerca de la meta, porque tenemos tres ceros a la derecha.  Ahora podemos agregar más q.  Digamos que esta vez será 8q, que será 111000. Nuevamente, sume nuestras líneas y obtenga 1100000. Ahora tenemos el original (aR) (bR) + 2q + 8q = 1100000. Finalmente, podemos dividir esto fácilmente en R, solo bajando cuatro ceros bajos. <br><br><img src="https://habrastorage.org/webt/r_/vd/n-/r_vdn-ktqvqa5oojy35pnml5hsm.jpeg"><br><br>  <b>Audiencia: ¿el</b> producto (aR) (bR) siempre terminará con 1024 ceros? <br><br>  <b>Profesor:</b> no, y explicaré cuál podría ser la confusión.  Digamos que el número a es 512 bits, lo multiplicamos por R y obtuvimos un número de 1000 bits.  En este caso, tiene razón, aR es el número en el que los bits altos son a, y los bits bajos son todos ceros.  Pero luego ejecutamos mod q para hacerlo más pequeño.  Por lo tanto, el tamaño de 1024 bits es generalmente una coincidencia, ya que este número tiene estos ceros bajos solo durante la primera conversión, pero después de hacer algunas multiplicaciones, serán bits arbitrarios. <br><br>  Para no confundirlo, tuve que escribir mod q aquí después de aR y después de bR, aquí lo estoy agregando, y calcular este mod q tan pronto como realice la conversión para reducir el valor. <br><br><img src="https://habrastorage.org/webt/nc/en/7o/ncen7oailgwdxhdlosl-fmds1oo.jpeg"><br><br>  La conversión inicial es bastante laboriosa, o al menos tan costosa como la modulación convencional en la multiplicación.  Lo bueno es que pagas este precio una vez cuando haces la conversión de Montgomery, y luego, en lugar de volver a convertirlo en cada paso de los cálculos, simplemente lo mantienes en forma de vista de Montgomery. <br>  Recuerda que para elevar a una potencia que tiene 512 bits, tendrás que hacer más de 500 multiplicaciones, porque tenemos que hacer al menos 500 cuadrados y algunos más.  Entonces haces mod q dos veces y luego obtienes muchas operaciones de división simples si te quedas en esta forma de representar números.  Y al final, haces una división por R para volver a esta forma ab. <br><br>  Entonces, en lugar de hacer mod q 500 veces para cada paso de la multiplicación, haces mod q dos veces y luego continúas haciendo estas divisiones por R a un costo mínimo. <br>  Público: cuando agrega múltiplos de q y luego divide por R, ¿tenemos un resto? <br>  Profesor: en realidad mod q significa el resto cuando se divide por q.  En pocas palabras, x + yq mod q = x.  En este caso, hay otra propiedad útil: que todos los módulos son primos.  Esto es tan cierto como el hecho de que si tiene (x + yq / R) mod q, entonces es igual a x / R mod q. <br><br><img src="https://habrastorage.org/webt/pk/s_/mq/pks_mqcl8worhpd4rrek3pamwzy.jpeg"><br><br>  La razón para pensarlo es que no hay operaciones de división real en aritmética modular, es solo inversión.  De hecho, esto significa que si tenemos (x + yq) multiplicado por R invertido calculado por mod q, entonces es igual a la suma de dos productos: el producto x del R invertido por mod q y el producto de yq por el R invertido por mod q.  Además, el último término se reduce, porque es algo multiplicado por q. <br><br><img src="https://habrastorage.org/webt/vg/ky/iz/vgkyizet0a_ne58agxvlks8ommk.jpeg"><br><br>  Para cosas como sumar 2q, 8q, etc., existe una fórmula que acelera el proceso de cálculo.  Lo hice gradualmente, primero calculé 2q, luego 8q y así sucesivamente, pero los materiales de la conferencia tienen una fórmula completa que se puede usar, simplemente no quiero perder el tiempo escribiéndolo en la pizarra.  Le permite calcular qué valor de múltiplo de q debe agregar para que todos los bits menos significativos se conviertan en 0. Luego resulta que para hacer la división por R, solo necesita calcular este múltiplo mágico de q, agregarlo y luego descartar el valor bajo cero bits, y esto devolverá su número a 512 bits sin importar el tamaño del resultado que obtenga. <br><br>  Pero hay una sutileza.  La única razón por la que estamos hablando de esto es porque algo extraño está sucediendo aquí, lo que nos permite encontrar información sobre los tiempos.  En particular, aunque dividimos por R, todavía sabemos que el resultado será de aproximadamente 512 bits.  Pero aún puede ser más que q, porque q no es un número de 512 bits, puede ser ligeramente menor que R. <br><br>  Entonces puede ser que después de hacer esta división ventajosa por R, tengamos que restar q nuevamente, porque obtenemos algo pequeño, pero aún no lo suficientemente pequeño.  Entonces existe la posibilidad de que después de esta división tengamos que restar q nuevamente.  Y esta resta se puede usar como parte del ataque, porque la operación de resta agrega el tiempo de cálculo. <br><br><img src="https://habrastorage.org/webt/js/3b/bq/js3bbqk4o3wsvylxkgaatijeh_k.jpeg"><br><br>  Y alguien descubrió, no estos tipos, sino alguien en el trabajo anterior, que existe la posibilidad de hacer algo llamado reducción adicional o reducción adicional.      ,    . ,    xd mod q,     -        x mod q,   2R.        . <br><br><img src="https://habrastorage.org/webt/it/si/iw/itsiiweom0jn8nlm8tyidksk3ty.jpeg"><br><br>    ,    x mod q   ,         .       ,        cd. <br><br><img src="https://habrastorage.org/webt/ty/b3/ig/tyb3igh49ab4o2u8pgvydckrzh8.jpeg"><br><br>    ,  extra reduction   ,   X ,   , ,   q. <br><br><img src="https://habrastorage.org/webt/6k/bd/4s/6kbd4spmlvgepzklkfxrm4ebso0.jpeg"><br><br>  ,        c,   extra reduction   ,   c     — q.  ,     ,      q  .     ,    extra reduction, , ,  X mod q  ,  = q + έ,     .         ,      .    ,    , ,   ,    extra reduction   . <br><br> <b>:</b>  ,       ? <br><br> <b>:</b>  ,      extra reduction?    ,  , ,        .  ,             . ,               ,        extra reduction, , ,     .       ,    . ,     ,      mod q.       , , ,   .  ,      mod q  ,  ,      . <br><br>  ,    . ,    - ,   .  —         ,       . ,  -  ,   extra reduction  . <br><br> ,    .  ,   OpenSSL,      ,  .  ,          mod q    .    ,         ,       . <br><br> ,     ,     ,      , a  b.    — 512- .     ,      32-  ,      ,    64-  ?       ? <br><br><img src="https://habrastorage.org/webt/ir/qp/p3/irqpp3-qwmtd5ny6id59a12tw3w.jpeg"><br><br>  -    ?  ,     ,    a  b             . <br><br>     , ,    512  ,    64- ,      32- .    a     : a <sub>1</sub>  a <sub>0</sub> ,  a <sub>0</sub>    ,  a <sub>1</sub> —  .      b –     b <sub>1</sub>  b <sub>0</sub> . <br><br>     ab      3- :       a <sub>1</sub> b <sub>1</sub> ,        a <sub>0</sub> b <sub>0</sub> ,     a <sub>1</sub> b <sub>0</sub> + a <sub>0</sub> b <sub>1</sub> .         . <br><br><img src="https://habrastorage.org/webt/9d/sd/dz/9dsddzqrr7zvczt8rh0noqpyuh8.jpeg"><br><br> 55:00  <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Curso MIT "Seguridad de sistemas informáticos".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 16: «   »,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3v5Von-oNUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versión completa del curso está disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Gracias por quedarte con nosotros.  ¿Te gustan nuestros artículos?  ¿Quieres ver más materiales interesantes?  <b>Apóyenos</b> haciendo un pedido o recomendándolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un análogo único de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o cómo dividir el servidor?</a>  (las opciones están disponibles con RAID1 y RAID10, hasta 24 núcleos y hasta 40GB DDR4). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps hasta diciembre de forma gratuita</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al pagar por un período de seis meses, puede ordenar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Dell R730xd 2 veces más barato?</b>  Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Países Bajos y los EE. UU.</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429392/">https://habr.com/ru/post/es429392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429382/index.html">De Alibaba a Pyaterochka: quién y cómo usa el sistema de reconocimiento facial en los negocios</a></li>
<li><a href="../es429384/index.html">Componentes de bicicletas eléctricas: motor</a></li>
<li><a href="../es429386/index.html">El proveedor de AT&T se convierte en el mayor titular de derechos de autor y comenzará a desconectar a los usuarios acusados ​​de piratería</a></li>
<li><a href="../es429388/index.html">Cómo hacer un rediseño de un sitio web y no crear problemas: 4 pasos importantes</a></li>
<li><a href="../es429390/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 16: "Ataques de canal lateral", Parte 1</a></li>
<li><a href="../es429394/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 16: "Ataques de canal lateral", Parte 3</a></li>
<li><a href="../es429396/index.html">Cómo probar una aplicación cuando interactúa con la API usando SoapUI</a></li>
<li><a href="../es429400/index.html">Seals vs red neuronal 2. O ejecuta SqueezeNet v.1.1 en Raspberry Zero en tiempo real (casi)</a></li>
<li><a href="../es429402/index.html">ML.NET 0.7 (Machine Learning .NET)</a></li>
<li><a href="../es429404/index.html">8 segundos y medio para priorizar la funcionalidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>