<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☯️ 🎰 🌏 ECMAScript 2017（ES8）简介 🐙 🤗 🌭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目录 
 前言 
 ES7概述 
 1.对象条目 
 2.对象值 
 3. String.prototype.padEnd 
 4. String.prototype.padStart 
 5. Object.getOwnPropertyDescriptor 
 6.尾随逗号 
 7. Shared...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ECMAScript 2017（ES8）简介</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475074/"><h4> 目录 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ES7概述</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.对象条目</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.对象值</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3. String.prototype.padEnd</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4. String.prototype.padStart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5. Object.getOwnPropertyDescriptor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.尾随逗号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7. SharedArrayBuffer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8.原子学</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">9.异步功能</a> <br><br><a name="section000"></a><h2> 前言 </h2><br> 您好，过去我已经考虑过ES6的创新，现在是时候拆分ES8了，因为它带来了许多新功能。 我没有单独考虑ES7（2016），因为此版本仅带来了2项创新。 这是Array.prototype.includes（）和幂运算符。 但是，在启动ES8之前，让我们先看看ES7的创新。 <br><br><a name="section0000"></a><h2>  ES7概述 </h2><br>  <b>includes（）方法</b>确定数组是否包含特定元素，并根据此结果返回true或false。 <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.includes(searchElement[, fromIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>]) : <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span></code> </pre> <br>  searchElement-要搜索的项目。 <br><br>  fromIndex-数组中开始搜索searchElement元素的位置。 对于负值，将从索引array.length + fromIndex升序开始执行搜索。 默认值为0。 <a name="habracut"></a><br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].includes(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, NaN].includes(NaN); // true</span></span></code> </pre> <br>  include（）可以应用于其他类型的对象（例如，类似数组的对象）。 示例：在arguments对象上使用include（）方法。 <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([].includes.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log([].includes.call(arguments, 'd')); // false })('a','b','c');</span></span></code> </pre> <br>  <b>幂运算符</b> （**）返回以a为底且自然指数为b的幂。 提高a到b的力量。 <br><br><pre> <code class="javascript hljs">a ** b</code> </pre> <br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// 8 3 ** 2 // 9 3 ** 2.5 // 15.588457268119896 10 ** -1 // 0.1 NaN ** 2 // NaN 2 ** 3 ** 2 // 512 2 ** (3 ** 2) // 512 (2 ** 3) ** 2 // 64 -(2 ** 2) // -4 (-2) ** 2 // 4</span></span></code> </pre> <br><a name="section001"></a><h2>  1.对象条目 </h2><br>  Object.entries（）返回一个数组，其元素是与直接在对象中发现的[key，value]对的枚举属性相对应的数组。 属性的顺序与您手动循环浏览对象的属性时的顺序相同。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj-一个对象，其枚举属性将作为数组[key，value]返回。 <br><br>  Object.entries（）返回属性的顺序与for ... in循环中的顺序相同（不同之处是for-in还列出了原型链中的属性）。  Object.entries（）返回的数组中元素的顺序与声明对象的方式无关。 如果需要特定顺序，则必须在调用方法之前对数组进行排序。 <br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-comment"><span class="hljs-comment">// [ ['foo', 'bar'], ['baz', 42] ] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ] //    c random   var an_obj = { 100: 'a', 2: 'b', 7: 'c' }; console.log(Object.entries(an_obj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ] // getFoo  ,    var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } }); my_obj.foo = "bar"; console.log(Object.entries(my_obj)); // [ ['foo', 'bar'] ] // non-object     object console.log(Object.entries("foo")); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ] let obj = { one: 1, two: 2 }; for (let [k,v] of Object.entries(obj)) console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`) // "one": 1 // "two": 2</span></span></code> </pre> <br>  <b>将对象转换为地图</b> <br><br> 新的Map（）构造函数接受值的重复。 使用Object.entries，您可以轻松地将Object转换为Map。 这比使用2个元素数组组成的数组更为简洁，但是键只能是字符串。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map); <span class="hljs-comment"><span class="hljs-comment">// Map {"foo" =&gt; "bar", "baz" =&gt; 42}</span></span></code> </pre> <br> 为什么Object.entries（）的返回值是数组而不是迭代器？ <br> 在这种情况下，对应的用例是Object.keys（），而不是Map.prototype.entries（）。 <br><br> 为什么Object.entries（）仅返回带有字符串键的枚举本机属性？ <br><br> 再次，这样做是为了匹配Object.keys（）。 此方法还忽略键为字符的属性。 最后，可能会有一个Reflect.ownEntries（）方法返回其自身的所有属性。 <br><br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a>中的object.entries。 <br><br><a name="section002"></a><h2>  2.对象值 </h2><br>  Object.values（）返回一个数组，其元素是在对象中找到的枚举属性的值。 该顺序与您手动循环浏览对象的顺序相同。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj) : <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span></code> </pre> <br>  obj-将返回其枚举属性值的对象。 <br><br>  Object.values（）方法以与for ... in循环相同的顺序返回对象的枚举属性的值的数组。 循环和方法之间的区别在于，循环列出了原型链中的属性。 <br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(obj)); <span class="hljs-comment"><span class="hljs-comment">// ['bar', 42] //    var obj = { 0: 'a', 1: 'b', 2: 'c' }; console.log(Object.values(obj)); // ['a', 'b', 'c']</span></span></code> </pre><br>  Object.entries和Object.values（）之间的区别在于，第一个返回包含属性名称和值的数组的数组，而第二个仅返回具有属性值的数组。 <br><br>  <b>Object.values（）和Object.entries（）之间的示例差异</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">'somestring'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(object)); <span class="hljs-comment"><span class="hljs-comment">// ["somestring", 42, false] console.log(Object.entries(object)); // [ ["a", "somestring"], ["b", 42], ["c", false] ]</span></span></code> </pre> <br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>中的Object.values（）以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a> 。 <br><br><a name="section003"></a><h2>  3. String.prototype.padEnd </h2><br>  padEnd（）方法使用给定的字符串（最终重复）来完成当前行，以便结果字符串达到指定的长度。 加法应用于当前行的末尾（右侧）。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padEnd(maxLength [ , fillString ]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength-填充当前行后结果行的长度。 如果此参数小于当前行的长度，则将按原样返回当前行。 <br>  fillString-用于补充当前行的字符串。 如果此行太长，它将被截断并且将应用最左边的那一行。  “”（0x0020 SPACE）是此参数的默认值。 <br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "abc " 'abc'.padEnd(10, "foo"); // "abcfoofoof" 'abc'.padEnd(6,"123456"); // "abc123"</span></span></code> </pre> <br> 填充字符串的用例包括： <br><br><ul><li> 在文件名或URL中添加计数器或标识符：'file 001.txt' </li><li> 控制台输出对齐方式：“测试001：✓” </li><li> 打印带有固定位数的十六进制或二进制数字：'0x00FF' </li></ul><br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>中的String.prototype.padEnd以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a> 。 <br><br><a name="section004"></a><h2>  4. String.prototype.padStart </h2><br>  padStart（）方法用另一行填充当前行（如果需要，可以多次输入），以使结果行达到指定的长度。 填充在当前行的开头（左侧）执行。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.prototype.padStart(maxLength [, fillString]) : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  maxLength-当前行完成后摘要行的长度。 如果该值小于当前行的长度，则当前行将保持不变。 <br><br>  fillString-填充当前行的字符串。 如果此字符串对于给定的长度而言太长，它将被截断。 默认值为“”（0x0020空格）。 <br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// " abc" 'abc'.padStart(10, "foo"); // "foofoofabc" 'abc'.padStart(6,"123465"); // "123abc" 'abc'.padStart(8, "0"); // "00000abc" 'abc'.padStart(1); // "abc"</span></span></code> </pre> <br> 为什么未将填充方法称为padLeft和padRight？ <br><br> 对于双向或从右到左语言，术语“左”和“右”不起作用。 因此，padStart和padEnd的命名遵循现有的名称，以startsWith和endsWith开头。 <br><br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a>中的String.prototype.padStart。 <br><br><a name="section005"></a><h2>  5. Object.getOwnPropertyDescriptor </h2><br>  Object.getOwnPropertyDescriptor（）方法为传递的对象返回自己的属性（即直接位于对象中，而不是通过原型链接收到的属性）的属性描述符。 如果该属性不存在，则返回undefined。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, prop) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  obj-在其中搜索属性的对象。 <br><br>  prop-将返回其描述的属性名称。 <br><br> 此方法使您可以查看属性的确切描述。  JavaScript中的属性由字符串名称和属性描述符组成。 <br><br> 属性描述符是具有以下某些属性的记录： <br><br><ul><li>  value-与属性关联的值（仅在数据描述符中）。 </li><li> 可写-如果可以更改与属性关联的值，则为true；否则为false（仅在数据描述符中）。 </li><li>  get-返回属性值的函数，如果没有这样的函数，则为undefined（仅在访问描述符中）。 </li><li>  set-更改属性值的函数，如果没有这样的函数，则为undefined（仅在访问描述符中）。 </li><li> 可配置-如果可以更改此属性的句柄类型，并且可以从包含它的对象中删除该属性，则为true，否则为false。 </li><li> 枚举-如果列出包含它的对象的属性时此属性可用，则为true，否则为false。 </li></ul><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs">obj = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// {set: undefined, enumerable: true, configurable: true, get: ƒ} obj2 = { bar: 42 }; console.log(Object.getOwnPropertyDescriptor(obj2, 'bar')); // {value: 42, writable: true, enumerable: true, configurable: true}</span></span></code> </pre> <br><h4>  Object.getOwnPropertyDescriptor（）的用例 </h4><br>  <b>第一个</b>用例：将属性复制到对象 <br> 从ES6开始，JavaScript已经具有用于复制属性的工具方法：Object.assign（）。 但是，此方法使用简单的get和set操作复制键为键的属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = source[key]; <span class="hljs-comment"><span class="hljs-comment">// get target[key] = value; // set</span></span></code> </pre> 这意味着它无法正确复制具有默认指定属性以外的属性的属性（获取，设置，写入等方法）。 以下示例说明了此限制。 该对象的源有一个安装程序，其密钥为foo： <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> source = { set foo(value) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(source, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br> 使用Object.assign（）将foo属性复制到目标对象失败： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target1 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(target1, source); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target1, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { value: undefined, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> 幸运的是，结合使用Object.getOwnPropertyDescriptors（）和Object.defineProperties（）可以： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target2 = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(target2, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(source)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(target2, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></span></code> </pre> <br>  <b>第二个</b>用例：克隆对象 <br> 浅克隆类似于复制属性，因此Object.getOwnPropertyDescriptors（）在这里也是一个不错的选择。 <br><br> 这次我们使用Object.create（），它具有两个参数： <br> 第一个参数指定返回对象的原型。 <br><br> 第二个可选参数是属性描述符的集合，类似于Object.getOwnPropertyDescriptors（）返回的那些描述符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clone = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(obj), <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj));</code> </pre> <br>  <b>第三种</b>用例：具有任意原型的跨平台对象文字。 <br><br> 使用对象文字来创建具有任意原型的对象的最佳语法方法是使用特殊的__proto__属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: prot, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, };</code> </pre> <br>  las，保证仅在浏览器中提供此功能。 常规解决方法是Object.create（）和赋值： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot); obj.foo = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre> <br> 但是您也可以使用Object.getOwnPropertyDescriptors（）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create( prot, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors({ <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, }) );</code> </pre> <br> 另一种选择是Object.assign（）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign( <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prot), { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, } );</code> </pre> <br> 陷阱：使用超级复制方法。 <br><br> 超级使用的方法紧密地绑定到其原始对象（存储该对象的对象）。 当前无法将这种方法复制或移动到另一个对象。 <br><br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a>中的Object.getOwnPropertyDescriptor。 <br><br><a name="section006"></a><h2>  6.尾随逗号 </h2><br> 挂逗号（尾随逗号）-在向JavaScript代码添加新元素，参数或属性时很有用。 如果要添加新属性，则只需添加新行而不更改前一行（如果已在其中使用了逗号）。 这使得版本控制更简洁，代码更改的麻烦也更少。 <br><br><h4> 文字中的逗号 </h4><br>  <b>数组</b> <br><br>  JavaScript会忽略数组中的逗号分隔： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [0, 1, 2] console.log(arr.length); // 3 var arr2 = [0, 1, 2,,,]; console.log(arr2.length); // 5 arr2.forEach((e) =&gt; console.log(e)); // 0 1 2 console.log(arr.map((e) =&gt; e)); // 0 1 2</span></span></code> </pre> <br> 如果使用多个悬挂点，则会创建孔。 具有“孔”的阵列称为稀疏（密集阵列不具有“孔”）。 例如，使用Array.prototype.forEach（）或Array.prototype.map（）迭代数组时，将跳过孔。 <br><br>  <b>对象</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object); <span class="hljs-comment"><span class="hljs-comment">// {foo: "bar", baz: "qwerty", age: 42}</span></span></code> </pre> <br><h4> 在功能中使用逗号 </h4><br>  <b>参数定义</b> <br><br> 功能参数的以下定义是有效的，并且彼此等效。 悬挂的逗号不会影响函数或其参数对象的length属性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) </span></span>{} (p) =&gt; {}; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p,</span></span></span><span class="hljs-function">) =&gt;</span></span> {};</code> </pre> <br>  <b>方法定义</b> <br><br> 挂逗号也可用于定义类或对象的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ one(a,) {}, two(a, b,) {}, } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { one(a,) {}, two(a, b,) {}, };</code> </pre> <br>  <b>函数调用</b> <br><br> 以下函数调用是有效的，并且彼此等效。 <br><br><pre> <code class="javascript hljs">f(p); f(p,); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>,);</code> </pre> <br>  <b>无效的挂逗号</b> <br><br> 定义函数参数或调用仅包含逗号的函数将引发SyntaxError。 另外，使用其余参数时，不允许使用逗号分隔。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">,</span></span></span><span class="hljs-function">) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// SyntaxError: missing formal parameter (,) =&gt; {}; // SyntaxError: expected expression, got ',' f(,) // SyntaxError: expected expression, got ',' function f(...p,) {} // SyntaxError: parameter after rest parameter (...p,) =&gt; {} // SyntaxError: expected closing parenthesis, got ','</span></span></code> </pre> <br><h4> 吊销中的逗号 </h4><br> 使用破坏性分配时，也可以在左侧使用逗号分隔。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      [a, b,] = [1, 2]; //      var o = { p: 42, q: true, }; var {p, q,} = o;</span></span></code> </pre> <br> 再次使用其余参数，将引发SyntaxError。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [a, ...b,] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Rest element must be last element</span></span></code> </pre> <br><h4>  JSON悬挂逗号 </h4><br> 仅在ECMAScript 5中允许在对象中挂逗号。由于JSON基于早于ES5的JavaScript语法<b>，因此JSON中</b>不允许<b>挂逗号。</b> <br><br> 这两行都抛出SyntaxError <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'[1, 2, 3, 4, ]'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo" : 1, }'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ] in JSON // Uncaught SyntaxError: Unexpected token } in JSON</span></span></code> </pre> <br><h4> 为什么挂逗号有用？ </h4><br> 有两个好处。 <br><br> 首先，重新排列元素更容易，因为如果最后一个元素改变了位置，则无需添加或删除逗号。 <br><br> 其次，它可以帮助版本控制系统跟踪真正发生的变化。 例如，来自： <br><br><pre> <code class="plaintext hljs">[ 'Foo' ] : [ 'Foo', '' ]</code> </pre> <br> 导致带有“ foo”的行和带有“ bar”的行都被标记为已更改，尽管唯一的实际更改是添加最后一行。 <br><br> 请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档中的</a>尾随逗号。 <br><br><a name="section007"></a><h2>  7. SharedArrayBuffer </h2><br>  SharedArrayBuffer对象用于创建固定长度的拆分缓冲区，以存储原始二进制数据，类似于ArrayBuffer对象，但是相比之下，SharedArrayBuffer实例可用于在共享内存上创建视图。  SharedArrayBuffer无法断开连接。 <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(length) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre>  length-创建缓冲区数组的大小（以字节为单位）。 <br><br> 返回-指定长度的新SharedArrayBuffer对象。 初始化后其内容为0。 <br><br> 为了在群集中的一个代理与另一个代理（代理可以是网页的主程序或网络工作人员之一）之间使用SharedArrayBuffer对象共享内存，使用了postMessage和结构化克隆。 <br><br> 结构化克隆算法接受映射到SharedArrayBuffers的SharedArrayBuffers和TypedArrays。 在这两种情况下，SharedArrayBuffer对象都传递给接收者，后者在接收代理内部创建一个新的私有SharedArrayBuffer对象（与ArrayBuffer相同）。 但是，两个SharedArrayBuffer对象引用的共享数据块是同一数据块，并且其中一个代理中的该块中的第三方效果最终将在另一个代理中可见。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); worker.postMessage(sab);</code> </pre> <br> 共享内存可以在worker或主线程中同时创建和更改。 根据系统（CPU，OS，浏览器）的不同，更改可能需要一段时间才能传播到所有上下文。 为了同步，需要原子操作。 <br><br> 共享数组缓冲区是高级并行抽象的基本构建块。 它们使您可以在多个工作线程和主线程之间共享SharedArrayBuffer对象的字节（共享缓冲区以访问字节，将其包装在Typed Array中）。 这种交换具有两个优点： <br> 您可以更快地在工作人员之间交换数据。 <br><br> 工人之间的协调变得越来越容易和快捷（与postMessage（）相比）。 <br><br> 工人的实施如下。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js self.addEventListener ('message', function (event) { const {sharedBuffer} = event.data; const sharedArray = new Int32Array (sharedBuffer); // ··· });</span></span></code> </pre><br> 首先，我们提取发送给我们的共享数组的缓冲区，然后将其包装在类型数组中，以便我们可以在本地使用它。 <br><br>  <b>SharedArrayBuffer的属性和方法。</b> <br><br>  SharedArrayBuffer.length-值为1的SharedArrayBuffer构造函数的长度。 <br>  SharedArrayBuffer.prototype-允许所有SharedArrayBuffer对象使用其他属性。 <br><br>  <b>SharedArrayBuffer实例</b> <br>  <b>属性</b> <br><br>  SharedArrayBuffer.prototype.constructor-定义一个创建对象原型的函数。 初始值为标准的内置SharedArrayBuffer构造函数。 <br><br>  SharedArrayBuffer.prototype.byteLength（只读）-数组的大小，以字节为单位。 在创建数组时设置，无法更改。 <br><br>  <b>方法</b> <br><br>  SharedArrayBuffer.prototype.slice（）-返回一个新的SharedArrayBuffer，其内容是此SharedArrayBuffer从独占开始（包括结尾）的字节的副本。 如果开始或结束为负数，则这是指从数组末尾开始的索引，而不是从开头开始。 此方法与Array.prototype.slice（）具有相同的算法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  SharedArrayBuffer     const buffer = new SharedArrayBuffer(16); const int32View = new Int32Array(buffer); //  view // produces Int32Array [0, 0, 0, 0] int32View[1] = 42; const sliced = new Int32Array(buffer.slice(4,12)); console.log(sliced); // Int32Array [42, 0]</span></span></code> </pre> <br><pre> <code class="javascript hljs">sab.slice([begin, end]) : <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span></code> </pre> <br>  begin-提取开始的零索引。 您可以使用负索引来指示距序列结尾的偏移量。  slice（-2）提取序列中的最后两个元素。 如果未定义开始，则切片从索引0开始。 <br> 结束-应从零开始的索引，应完成提取。 <br><br> 例如，切片（1,4）检索第二个元素到第四个元素（索引为1、2和3的元素）。 您可以使用负索引来指示距序列结尾的偏移量。  slice（2，-1）通过序列中的倒数第二个元素检索第三个元素。 如果省略end，则片将读取序列的末尾（sab.byteLength）。 <br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); sab.slice(); <span class="hljs-comment"><span class="hljs-comment">// SharedArrayBuffer { byteLength: 1024 } sab.slice(2); // SharedArrayBuffer { byteLength: 1022 } sab.slice(-2); // SharedArrayBuffer { byteLength: 2 } sab.slice(0, 1); // SharedArrayBuffer { byteLength: 1 }</span></span></code> </pre> <br> 请参阅官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDN Web文档</a>中的SharedArrayBuffer。 <br><br><a name="section008"></a><h2>  8.原子学 </h2><br>  Atomics对象提供原子操作作为静态方法。 与SharedArrayBuffer对象一起使用。 <br><br> 原子操作安装在原子模块中。 与其他全局对象不同，Atomics不是构造函数。 它不能与new运算符一起使用，也不能将Atomics对象作为函数调用。 所有Atomics属性和方法都是静态的（例如，类似于Math对象）。 <br><br> 共享内存时，几个线程可以读取和写入相同的数据到内存。 原子操作保证将读取和读取期望值，并在下一个操作开始工作之前完成操作，并且不会中断这些期望值。 <br><br><h4> 属性 </h4><br>  Atomics [Symbol.toStringTag]-此属性的值为Atomics。 <br><br><h4> 方法 </h4><br>  <b>原子操作</b> <br><br><ul><li>  Atomics.add（）-将显示的值添加到数组中指定位置的当前值。 返回此位置的前一个值。 </li><li>  Atomics.and（）-在指定的数组位置计算按位与。 返回此位置的前一个值。 </li><li>  Atomics.compareExchange（）-如果显示的值等于显示的值，则将显示的值保存到数组的指定位置。 返回前一个值。 </li><li> Atomics.exchange() —       .   . </li><li> Atomics.load() —      . </li><li> Atomics.or() —   OR    .      . </li><li> Atomics.store() —       .  . </li><li> Atomics.sub() —          .      . </li><li> Atomics.xor() —   XOR    .      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.add（）静态方法将值添加到数组中指定位置的当前值，并在此位置返回前一个值。</font><font style="vertical-align: inherit;">此原子操作确保在回写修改后的值之前，不会发生其他写操作。</font></font><br><br><pre> <code class="javascript hljs">Atomics.add(typedArray, index, value) : mixed</code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray-整数的拆分数组。</font><font style="vertical-align: inherit;">Int8Array，Uint8Array，Int16Array，Uint16Array，Int32Array或Uint32Array。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> index-typedArray中要添加值的位置。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value-要添加的数字。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> return-指定位置的先前值（typedArray [index]）。 </font></font></li></ul><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果typedArray类型不是有效的整数类型之一，则引发TypeError。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果typedArray类型不是泛型类型，则引发TypeError。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果index在typedArray之外，则抛出RangeError。 </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sab = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedArrayBuffer(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(sab); Atomics.add(ta, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  0,   Atomics.load(ta, 0); // 12</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.add（）中的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反复MDN网络上的文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 等待并通知 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait（）和wake（）方法是基于futexes（“快速用户空间互斥体”）Linux建模的，并提供了等待直到某个状态变为真的方法，通常用作阻塞构造。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.wait（）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查仍表示</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">是否</font><font style="vertical-align: inherit;">包含在数组的指定位置中，并且处于睡眠挂起或超时状态。</font><font style="vertical-align: inherit;">返回确定，不等于或超时。</font><font style="vertical-align: inherit;">如果调用代理中不允许等待，则它将引发异常错误（大多数浏览器不允许在浏览器的主流中使用wait（））。</font></font><br><br><ul><li> Atomics.wait() — ,               -.  «ok», «not-equal»  «timed-out».       ,     (    wait()    ). </li><li> Atomics.wake() —   ,         .   ,   . </li><li> Atomics.isLockFree(size) —  ,            .  true,                 (  ).   . </li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 优化问题 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化使工作人员中的代码不可预测。</font><font style="vertical-align: inherit;">在单线程中，编译器可以执行破坏多线程代码的优化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下面的代码为例：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单线程中，sharedArray [0]的值在循环执行期间永不更改（如果sharedArray是数组或未以任何方式固定的类型化数组）。</font><font style="vertical-align: inherit;">因此，可以对代码进行如下优化：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tmp = sharedArray [<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tmp === <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在多线程模式下，此优化不允许我们使用此模板来等待另一个线程中所做的更改。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个示例是以下代码：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js sharedArray [1] = 11; sharedArray [2] = 22;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个线程中，您可以重新排列这些写操作，因为它们之间什么也没读。</font><font style="vertical-align: inherit;">当您期望以特定顺序执行记录时，多线程会遇到问题：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// worker.js while (sharedArray [2]! == 22); console.log (sharedArray [1]); // 0  11</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这些类型的优化使得几乎不可能将在同一缓冲区上工作的多个工作程序的操作与一个公共数组同步。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解决优化问题 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Atomics全局变量，其方法有三个主要用途。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个用例：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原子方法可用于与其他工作人员同步。</font><font style="vertical-align: inherit;">例如，以下两个操作允许您读取和写入数据，并且不会被编译器重新排序：</font></font><br><br><pre> <code class="javascript hljs">Atomics.load (TypedArray &lt;T&gt;, index) : T Atomics.store (TypedArray &lt;T&gt;, index, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想法是使用普通操作读取和写入大多数数据，而Atomics操作（加载，存储和其他操作）确保读取和写入是安全的。通常，您将使用基于Atomics的自己的同步机制，例如锁。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个非常简单的示例，由于使用了Atomics，它始终可以正常工作（我跳过了sharedArray的设置）：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// main.js console.log ('notified...'); Atomics.store (sharedArray, 0, 123); // worker.js while (Atomics.load (sharedArray, 0)! == 123); console.log ('notified');</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个用例：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待通知</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用while循环来等待通知不是很有效，因此Atomics具有帮助性的操作：Atomics.wait（Int32Array，索引，值，超时）和Atomics.wake（Int32Array，索引，计数）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三种用例：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原子运算</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某些原子运算可以算术且不能同时中断，这有助于同步。</font></font>例如： <br><br><pre> <code class="javascript hljs">Atomics.add (TypedArray &lt;T&gt;, index, value) : T</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粗略地说，该操作执行：index + = value; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值撕裂的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享内存的另一个问题是值撕裂（垃圾）：读取时，您会看到一个中间值-新值被写入内存之前既没有值，也没有新值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范的“无撕裂阅读”部分规定，当且仅当：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 读取和写入都通过类型化数组（而非DataView）进行。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这两个类型化的数组都与它们的共享数组缓冲区对齐：sharedArray.byteOffset％sharedArray.BYTES_PER_ELEMENT === 0 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 两种类型的数组每个元素的字节数相同。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 换句话说，当通过以下方式访问共享数组的相同缓冲区时，残缺值是一个问题： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一个或多个DateViews； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有一个或多个未对齐的类型化数组； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有不同大小的元素的类型化数组； </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为避免这些情况下的值出现差异，请使用Atomics或sync。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用中的共享数组缓冲区 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享数组缓冲区和JavaScript语义，用于执行未决函数。 JavaScript具有所谓的“完成前”执行语义：每个函数都可以期望它在完成之前不会被另一个线程中断。函数成为事务并可以执行完整的算法，而没有人看到处于中间状态的数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享数组缓冲区中断了完成周期（RTC）：函数执行过程中，另一个线程可以更改函数正在处理的数据。但是，该代码完全控制是否发生这种RTC违规：如果它不使用共享数组缓冲区，则是安全的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这大致类似于异步函数违反RTC的方式。在那里，您可以使用await关键字启用锁定操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享数组缓冲区允许emscripten在asm.js中编译pthread。引用emscripten文档页面：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[En] [允许共享阵列缓冲区] Emscripten应用程序可在Web Worker之间共享主内存堆。这与低级原子和futex支持的原语一起使Emscripten能够实现对Pthreads（POSIX线程）API的支持。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Ru] [共享阵列缓冲区允许] Emscripten应用程序在Web Worker之间共享一堆主内存。除了底层原子原语和futex支持之外，Emscripten还支持Pthreads API（POSIX线程）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，您可以在asm.js中编译多线程C和C ++代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于如何最好地在WebAssembly中使用多线程的讨论正在进行中。</font><font style="vertical-align: inherit;">鉴于Web工作人员相对较重，WebAssembly可能会引入轻量级线程。</font><font style="vertical-align: inherit;">您还可以看到主题正在走向WebAssembly的未来。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 交换除整数以外的数据 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前，只能使用整数数组（最长32位）。</font><font style="vertical-align: inherit;">这意味着共享其他类型数据的唯一方法是将它们编码为整数。</font><font style="vertical-align: inherit;">可能有用的工具包括：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TextEncoder和TextDecoder：前者将字符串转换为Uint8Array实例，后者则相反。 </font></font></li><li> stringview.js: ,      .   . </li><li> FlatJS:  JavaScript        (,   )    (ArrayBuffer  SharedArrayBuffer). JavaScript + FlatJS    JavaScript. JavaScript  (TypeScript  . .) . </li><li> TurboScript:  JavaScript-    .    asm.js  WebAssembly. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，可能会出现其他的更高级别的数据交换机制。实验将继续找出这些机制的外观。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用共享数组缓冲区的代码能以多快的速度工作？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lars T. Hansen编写了Mandelbrot算法的两种实现（如他的文章“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript的新并行基元的味道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”所述，它是使用多个Web工作者的顺序版本和并行版本。最多4个Web工作者，因此处理器核心，加速几乎呈线性增长，从每秒6.9帧（1个Web工作者）到每秒25.4帧（4个Web工作者）。更多的Web工作者带来了额外的生产率提高，但效率却有所提高。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hansen指出，加速是令人印象深刻的，但是并行工作是由于代码更加复杂。</font><font style="vertical-align: inherit;">有关共享阵列缓冲区和支持技术的</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他信息</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共享内存</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Lars T.Hansen </font><a href="" rel="nofollow"><font style="vertical-align: inherit;">的简短教程</font></a></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拉尔斯·汉森（Lars T.Hansen）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">品尝JavaScript的新并行原语</font></a></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBuffer和Atomics第2.95阶段到第3阶段</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（PDF），Guo-yu Guo和Lars T. Hansen的幻灯片（2016-11-30）[ES句子随附的幻灯片]</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络工作者的基本知识，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者：埃里克·比德尔曼（Eric Bidelman）[网络工作者简介]。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他JavaScript并发技术： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的路径，以并行的JavaScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”由赫尔曼[其中JavaScript是拒绝PJS的移动后的概述]的Dave</font></font></li><li> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Write massively-parallel GPU code for the browser with WebGL</a> ” by Steve Sanderson [ , ,   WebGL      GPU]. </li><li> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Concurrency is not parallelism</a> ” by Rob Pike [Rob Pike   «concurrency»  «parallelism»    ]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Using Web Workers</a> " from MDN [  MDN,      web workers]. </li><li> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Shared memory and atomics</a> " by Axel Rauschmayer [     js   Shared Array Buffers  Atomics] </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请参阅官方</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的</font><font style="vertical-align: inherit;">Atomics Object </font><font style="vertical-align: inherit;">。</font></font><br><br><a name="section009"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9.异步功能 </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用AsyncFunction构造函数创建Async函数 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncFunction构造函数创建一个新的异步函数对象。</font><font style="vertical-align: inherit;">在JavaScript中，任何异步函数实际上都是AsyncFunction对象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，AsyncFunction不是全局对象。</font><font style="vertical-align: inherit;">可以通过执行以下代码获得它。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">句法</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arg1，arg2，... argN-函数用作形式参数名称的名称。每个名称必须是与有效的JavaScript标识符匹配的字符串，或此类逗号分隔的字符串的列表；例如，“ x”，“ theValue”或“ a，b”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functionBody-一个字符串，其中包含JavaScript源代码中的函数定义。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用AsyncFunction构造函数创建的异步函数对象将在函数创建时进行解析。与使用异步函数表达式声明异步函数并在代码内部调用异步函数相比，这效率较低，因为此类函数会与其余代码一起解析。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递给函数的所有参数按照传递顺序被视为创建的函数中的参数标识符的名称。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将AsyncFunction构造函数作为函数调用（不使用new运算符）与将其作为构造函数调用具有相同的效果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用AsyncFunction构造函数创建的异步函数不会使创建它们的上下文短路。它们始终在全局范围内创建。当他们开始时，他们将只能访问其局部变量和全局变量，但无权访问调用AsyncFunction构造函数的作用域。这与将eval与异步函数的代码一起使用不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用AsyncFunction构造函数创建异步函数的示例</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AsyncFunction = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}).constructor <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncFunction(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'return await resolveAfter2Seconds(a) + await resolveAfter2Seconds(b);'</span></span>); a(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  30  4  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 异步函数声明 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步函数声明定义了一个异步函数，该函数返回一个AsyncFunction对象。</font><font style="vertical-align: inherit;">您还可以使用异步函数表达式定义异步函数。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">句法</font></font></b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[param[, param[, ... param]]]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// body }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name-函数的名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param-要传递给函数的参数名称。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句-包含函数主体的表达式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用之后，异步函数返回Promise。接收到结果后，Promise完成，返回接收到的值。当异步函数引发异常时，Promise将失败，并抛出一个值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步函数可以包含一个等待表达式，该表达式暂停异步函数的执行并等待来自所传递的Promise的响应，然后恢复异步函数并返回接收到的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await关键字仅在异步函数中有效。在另一种情况下，您将收到一个SyntaxError错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待功能的目的是同步简化promise的使用，并在Promises组上重现一些操作。</font><font style="vertical-align: inherit;">就像承诺就像结构化回调一样，异步/等待就像生成器和承诺的组合。</font></font><br><br>  <b>例子</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveAfter2Seconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(x); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> resolveAfter2Seconds(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + a + b; } add1(<span class="hljs-number"><span class="hljs-number">10</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(v); <span class="hljs-comment"><span class="hljs-comment">//  60  4  }); async function add2(x) { const a = resolveAfter2Seconds(20); const b = resolveAfter2Seconds(30); return x + await a + await b; } add2(10).then(v =&gt; { console.log(v); //  60  2  });</span></span></code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 异步的作用是什么？ </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在一个.js文件中编写JS程序，但是您的代码很可能会分成几部分。现在仅执行其中一部分，其余部分将在以后执行。函数是将程序分为多个部分的最常用的技术。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于大多数初次使用JS的开发人员来说，主要问题是对现在以后不会发生的事情缺乏了解。换句话说，根据定义，现在无法完成的任务将异步结束。而且，我们将不会拥有假定的程序的阻塞行为。 （You-Dont-Know-JS /异步与性能，Jake Archibald）。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ajax(..)  Ajax-,   var data = ajax( "http://some.url.1" ); console.log( data );// !  `data`     Ajax-</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是什么错误？</font><font style="vertical-align: inherit;">在我们从请求接收数据之前执行console.log（）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从现在开始到以后“等待”的明显决定是使用回调：</font></font><br><br><pre> <code class="javascript hljs">ajax( <span class="hljs-string"><span class="hljs-string">"http://some.url.1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myCallbackFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( data ); <span class="hljs-comment"><span class="hljs-comment">// ,   ! } );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑过早解决同步代码执行的各种方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有3个函数getUser，getPosts，getComments。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { getUser, getPosts, getComments } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./db'</span></span>); getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>, (error, user) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getPosts(user.id, (error, posts) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id, (error, comment) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); }); }); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此示例中，很难不注意到金字塔，金字塔随着增加的新功能而增加。这种编码风格通常称为“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调地狱”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一种特定模式，可让您控制竞争（异步）请求，从而确保执行顺序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决嵌套函数问题的部分方法是使用Promise（我在上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论了Promise </font><font style="vertical-align: inherit;">，它删除了它并使代码更整洁。它们还提供了更方便的错误处理方式。但是许多人不喜欢这种语法。</font></font><br><br><pre> <code class="javascript hljs">getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> getPosts(user,id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">posts</span></span></span><span class="hljs-function"> =&gt;</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">comments</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器成为Promise的替代方法（我也在上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行了</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">讨论</font></a><font style="vertical-align: inherit;">。生成器本身不适合编写异步代码，但是如果将它们与Promise一起使用，我们会得到一些独特的东西-看起来是同步的异步代码。同时，生成器提供了使用try ... catch构造函数的熟悉的错误处理机制只有生成器有一个很大的负号-为了与Promise一起使用，您将需要一个单独的函数来控制生成器的过程答：您可以自己编写此函数，也可以使用第三方库（例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在本示例中，我编写了此类函数的实现。</font></font><br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> posts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getPosts(user.id); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comments = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getComments(posts[<span class="hljs-number"><span class="hljs-number">0</span></span>].id); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(comments); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); } }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iterator = generator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prev</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { value, done } = iterator.next(prev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) resolve(value); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>) value.then(run, reject); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> run(value); } run(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用异步代码的每种方法都有其优点和缺点。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回调函数（回调函数）-易于使用，但是随着嵌套函数的增加，可读性开始受到损害。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises（Promises）-优雅而舒适，但对于初学者来说很难理解。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成器（Generators）-允许您同步编写异步代码，但是它们需要单独的功能，并且生成器的操作机制非常复杂。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步函数是在Promises和Generators的基础上创建的，以便使异步代码的工作变得简单易懂。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了了解什么是异步函数，请考虑以下示例：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，如果使函数异步（添加async关键字），则该函数将返回一个Promise，其中包含具有id属性的对象。 </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">// Promise { {id: 1} }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们可以说任何异步函数都返回Promis（或者将其应返回的值包装在Promis中）。</font><font style="vertical-align: inherit;">如果返回给异步函数的值已经是一个Promise，则将不会再次将其转回。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了从诺言中获得价值，我们可以使用then（）方法。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; } getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user)); <span class="hljs-comment"><span class="hljs-comment">// { id: 1 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，我们可以使用await关键字，稍后将对其进行讨论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们回到第一个示例（仅这次，我们将使用real函数发送HTTP请求。</font></font><br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是使用Promise异步代码的样子。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果使用异步函数，我们可以将异步代码编写为同步代码。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sendRequest(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); } main();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我唯一不喜欢的是异步运算符只能在异步函数中使用。</font><font style="vertical-align: inherit;">否则，我将不需要使用main（）函数。</font><font style="vertical-align: inherit;">当然，您也可以使用then（）方法，但随后的代码将不再是异步的。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response= <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } sendRequest() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的是，我们不使用回调函数从fetch（）获取数据。</font><font style="vertical-align: inherit;">相反，我们使用await关键字，它实际上告诉了运行时：等待fetch（）函数执行并将结果写入响应变量。</font><font style="vertical-align: inherit;">然后使用回调函数，我们说：等待fetch（）函数执行并调用回调函数来处理数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是使用Promise和异步功能之间的明显区别</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Promise function sendRequest() { return fetch(`https://jsonplaceholder.typicode.com/users/1`) .then(data =&gt; data.json()); } //  async function async function sendRequest() { let response = await fetch(`https://jsonplaceholder.typicode.com/users/1`); return response.json(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await运算符只能在异步函数的主体中使用，并且其操作可以在任何返回promise的函数中使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了处理异步函数中的异常，习惯上使用try ... catch构造。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Unexpected error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">// Error: Unexpected error at sendRequest } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后... </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    async; await; async; await; async; await; async; await; In the System(); The function.sleep()s tonight~</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请参阅官方</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规范</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的“ </font><font style="vertical-align: inherit;">异步函数定义” </font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475074/">https://habr.com/ru/post/zh-CN475074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475060/index.html">创建简单的呼叫跟踪服务，第2部分</a></li>
<li><a href="../zh-CN475062/index.html">介绍Apple登录-Apple授权系统</a></li>
<li><a href="../zh-CN475064/index.html">适用于Windows桌面的.NET Core 3</a></li>
<li><a href="../zh-CN475068/index.html">我们将所有局域网流量都封装在vpn中，而没有速度限制</a></li>
<li><a href="../zh-CN475072/index.html">通过公司的眼光实习生</a></li>
<li><a href="../zh-CN475076/index.html">苏联超级英雄，捷克鼻屎和澳大利亚克隆人</a></li>
<li><a href="../zh-CN475078/index.html">了解SwiftUI中的属性包装器</a></li>
<li><a href="../zh-CN475082/index.html">Habr每周＃26 /每周工作四天，GitLab参政，Yandex正在测试Rover送货机器人</a></li>
<li><a href="../zh-CN475086/index.html">面向前端开发人员的REST API类型</a></li>
<li><a href="../zh-CN475092/index.html">“我稍后再读”：脱机收集网页的艰难命运</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>