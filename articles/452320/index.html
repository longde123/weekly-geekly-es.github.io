<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¶ üë©üèª‚ÄçüöÄ ‚ô®Ô∏è MVCC-6. Limpieza üî∫ üë©üèº‚Äçüîß üñ•Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comenzamos con problemas relacionados con el aislamiento , hicimos una digresi√≥n sobre la organizaci√≥n de datos en un nivel bajo , luego hablamos en d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Limpieza</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Comenzamos con problemas relacionados con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aislamiento</a> , hicimos una digresi√≥n sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">organizaci√≥n de datos en un nivel bajo</a> , luego hablamos en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre las versiones de fila</a> y c√≥mo se obtienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instant√°neas</a> de las versiones. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez</a> hablamos sobre las actualizaciones CALIENTES y la limpieza en la p√°gina, y hoy repasaremos la conocida rutina de limpieza, <em>aspiradora vulgar</em> .  S√≠, ya se ha escrito tanto sobre ella que es poco probable que diga algo nuevo, pero la integridad de la imagen requiere sacrificio.  Se paciente. <br><br><h1>  Limpieza normal (aspiradora) </h1><br><h2>  ¬øQu√© hace la limpieza? </h2><br>  La limpieza dentro de la p√°gina es r√°pida, pero libera solo una fracci√≥n del espacio.  Funciona dentro de la misma p√°gina tabular y no afecta a los √≠ndices. <br><br>  La limpieza principal "normal" se realiza mediante el comando VACUUM y la llamaremos simplemente limpieza (y hablaremos sobre la limpieza autom√°tica por separado). <br><br>  Entonces, la limpieza procesa la tabla por completo.  Limpia no solo versiones innecesarias de cadenas, sino tambi√©n referencias a ellas de todos los √≠ndices. <br><br>  El procesamiento ocurre en paralelo con otras actividades en el sistema.  En este caso, la tabla y los √≠ndices se pueden usar de la manera habitual tanto para leer como para cambiar (sin embargo, la ejecuci√≥n simult√°nea de comandos como CREATE INDEX, ALTER TABLE y algunos otros ser√° imposible). <br><br>  Solo se ven en la tabla las p√°ginas en las que se produjo alguna actividad.  Para esto, se utiliza un mapa de visibilidad (le recuerdo que las p√°ginas que contienen solo versiones bastante antiguas de filas que est√°n garantizadas para ser visibles en todas las instant√°neas de datos est√°n marcadas en √©l).  Solo se procesan las p√°ginas que no est√°n marcadas en el mapa, mientras que el mapa en s√≠ se actualiza. <br><br>  En el proceso, el mapa de espacio libre se actualiza para reflejar el espacio libre que aparece en las p√°ginas. <br><a name="habracut"></a><br>  Como de costumbre, crea una tabla: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Usando el par√°metro <em>autovacuum_enabled,</em> desactivamos la limpieza autom√°tica.  Hablaremos de eso la pr√≥xima vez, pero por ahora, para los experimentos, es importante que gestionemos la limpieza manualmente. <br><br>  Hay tres versiones de la fila en la tabla ahora, y cada una est√° vinculada desde un √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Despu√©s de la limpieza, las versiones "muertas" desaparecen y solo hay una, relevante.  Y al √≠ndice tambi√©n le queda un enlace: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Tenga en cuenta que los dos primeros punteros recibieron el estado no utilizado, y no muerto, como lo ser√≠a con la limpieza dentro de la p√°gina. <br><br><h2>  Y nuevamente sobre el horizonte de transacciones </h2><br>  ¬øC√≥mo determina PostgreSQL qu√© versiones de fila pueden considerarse "muertas"?  Ya consideramos el concepto de un horizonte de transacciones cuando hablamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de las</a> instant√°neas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos</a> , pero este es un tema tan importante que no es pecado repetirlo. <br><br>  Comencemos la experiencia previa nuevamente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Pero antes de actualizar la l√≠nea nuevamente, deje que comience otra transacci√≥n (pero no termine).  En nuestro ejemplo, funcionar√° en el nivel de lectura confirmada, pero deber√≠a obtener un n√∫mero de transacci√≥n real (no virtual).  Por ejemplo, puede cambiar o incluso bloquear algunas filas en cualquier tabla, no necesariamente en vac: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Hay tres filas en la tabla y tres enlaces en el √≠ndice.  ¬øQu√© pasa despu√©s de la limpieza? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Quedan dos versiones de la fila en la tabla: la limpieza decidi√≥ que la versi√≥n (0.2) a√∫n no se pod√≠a eliminar.  La raz√≥n, por supuesto, est√° en el horizonte de transacciones de la base de datos, que en nuestro ejemplo est√° determinado por una transacci√≥n incompleta: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Puede solicitar limpieza para hablar sobre lo que sucede: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Por favor tenga en cuenta: <br><br><ul><li>  2 versiones de fila no extra√≠bles: se encontraron 2 versiones en la tabla que no se pueden eliminar, </li><li>  Todav√≠a no se pueden eliminar las versiones de 1 fila muerta, incluido 1 "muerto", </li><li>  xmin m√°s antiguo muestra el horizonte actual. </li></ul><br>  Repetimos la conclusi√≥n una vez m√°s: la presencia de transacciones de larga duraci√≥n en la base de datos (no completadas o de muy larga ejecuci√≥n) puede conducir a la expansi√≥n de tablas (abarrotadas), independientemente de la frecuencia con que se realice la limpieza.  Por lo tanto, en PostgreSQL, las cargas de trabajo OLTP y OLAP est√°n mal combinadas en una base de datos: los informes que se ejecutan durante horas no permitir√°n que las tablas actualizadas con frecuencia se borren a tiempo.  Una posible soluci√≥n ser√≠a crear una r√©plica de "informes" separada. <br><br>  Despu√©s de completar una transacci√≥n abierta, el horizonte cambia y la situaci√≥n se corrige: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Ahora la p√°gina solo tiene la √∫ltima versi√≥n actual de la l√≠nea: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Tambi√©n hay solo una entrada en el √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Que esta pasando adentro </h2><br>  La limpieza debe procesar tanto la tabla como los √≠ndices al mismo tiempo, y hacerlo de una manera que no bloquee la operaci√≥n de otros procesos.  ¬øC√≥mo lo hace ella? <br><br>  Todo comienza con <strong>un escaneo de tabla</strong> (teniendo en cuenta el mapa de visibilidad, como ya se se√±al√≥).  En las p√°ginas le√≠das, se determinan versiones innecesarias de cadenas y sus identificadores (tid) se escriben en una matriz especial.  La matriz se encuentra en la memoria local del proceso de limpieza;  se le asigna un fragmento de <em>mantenimiento_trabajo_mem</em> .  El valor predeterminado para este par√°metro es 64 MB.  Tenga en cuenta que esta memoria se asigna inmediatamente en su totalidad, y no seg√∫n sea necesario.  Es cierto que si la tabla es peque√±a, el fragmento se asigna menos. <br><br>  A continuaci√≥n, una de dos cosas: o llegaremos al final de la tabla, o la memoria asignada para la matriz finalizar√°.  En cualquiera de los dos casos, comienza la <strong>fase de limpieza del √≠ndice</strong> .  Para hacer esto, <em>cada uno</em> de los √≠ndices creados en la tabla se <em>escanea completamente</em> en busca de registros que hagan referencia a versiones almacenadas de filas.  Los registros encontrados se borran de las p√°ginas de √≠ndice. <br><br>  En este punto obtenemos la siguiente imagen: en los √≠ndices ya no hay enlaces a versiones innecesarias de filas, pero todav√≠a existen en la tabla.  Esto no contradice nada: al ejecutar una consulta, no llegamos a versiones muertas de filas (con acceso al √≠ndice), o las marcamos al verificar la visibilidad (al escanear una tabla). <br><br>  Despu√©s de eso, comienza la <strong>fase de limpieza de la mesa</strong> .  La tabla se escanea nuevamente para leer las p√°ginas necesarias, eliminar las versiones almacenadas de las l√≠neas de ellas y liberar los punteros.  Podemos hacer esto porque ya no hay enlaces de √≠ndices. <br><br>  Si la tabla no se ley√≥ completamente en la primera pasada, la matriz se borra y todo se repite desde el lugar donde lo dejamos. <br><br>  De esta manera: <br><br><ul><li>  la tabla siempre se escanea dos veces; </li><li>  Si durante la limpieza se eliminan tantas versiones de fila que no pueden caber en la memoria <em>maintenance_work_mem</em> , todos los √≠ndices se explorar√°n por completo tantas veces como sea necesario. </li></ul><br>  En tablas grandes, esto puede llevar una cantidad considerable de tiempo y crear una carga significativa en el sistema.  Por supuesto, las solicitudes no ser√°n bloqueadas, pero la E / S "extra" tambi√©n es desagradable. <br><br>  Para acelerar el proceso, tiene sentido pedir una limpieza m√°s a menudo (para que no se borre un n√∫mero muy grande de versiones de fila cada vez) o asignar m√°s memoria. <br><br>  Noto entre par√©ntesis que, a partir de la versi√≥n 11, PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede omitir los escaneos de √≠ndice</a> si esto no es absolutamente necesario.  Esto deber√≠a facilitar la vida de los propietarios de tablas grandes en las que solo se agregan filas (pero no se modifican). <br><br><h2>  Monitoreo </h2><br>  ¬øC√≥mo entender que la limpieza no hace frente al trabajo en una sola pasada? <br><br>  Ya hemos visto el primer m√©todo: puede llamar al comando VACUUM con VERBOSE.  Luego, la informaci√≥n sobre las fases del trabajo se mostrar√° en la consola. <br><br>  En segundo lugar, a partir de la versi√≥n 9.6, hay una vista pg_stat_progress_vacuum, que tambi√©n contiene toda la informaci√≥n necesaria. <br><br>  (Hay una tercera forma: mostrar informaci√≥n en el registro de mensajes, pero esto solo funciona para la limpieza autom√°tica, que se discutir√° la pr√≥xima vez). <br><br>  Insertaremos m√°s filas en la tabla para que la limpieza tarde un tiempo notable, y las actualizaremos para que haya algo que ver con la limpieza. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Reduzca el tama√±o de la memoria asignada para la matriz de identificadores: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Comenzamos a limpiar y, mientras funciona, pasaremos a la vista pg_stat_progress_vacuum varias veces: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Aqu√≠ vemos en particular: <br><br><ul><li>  nombre de la fase actual (fase): hablamos de tres fases principales, pero en general hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s de</a> ellas; </li><li>  n√∫mero total de p√°ginas de la tabla (heap_blks_total); </li><li>  el n√∫mero de p√°ginas rastreadas (heap_blks_scanned); </li><li>  el n√∫mero de p√°ginas ya borradas (heap_blks_vacuumed); </li><li>  El n√∫mero de pases por √≠ndice (index_vacuum_count). </li></ul><br>  El progreso general est√° determinado por la proporci√≥n de heap_blks_vacuumed a heap_blks_total, pero tenga en cuenta que este valor no cambia sin problemas, sino "bruscamente" debido a los escaneos de √≠ndice.  Sin embargo, se debe prestar especial atenci√≥n al n√∫mero de ciclos de limpieza: un valor mayor que 1 significa que la memoria asignada no fue suficiente para completar la limpieza de una sola vez. <br><br>  La salida del comando VACUUM VERBOSE, completada en este momento, mostrar√° el panorama general: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Aqu√≠ puede ver que en total hubo tres pases a trav√©s de los √≠ndices, cada uno de los cuales despej√≥ 174,480 punteros a versiones muertas de cadenas.  ¬øDe d√≥nde viene este n√∫mero?  Un enlace (tid) toma 6 bytes, y 1024 * 1024/6 = 174762 es el n√∫mero que vemos en pg_stat_progress_vacuum.max_dead_tuples.  En realidad, se puede usar un poco menos: se garantiza que, al leer la p√°gina siguiente, todos los punteros a las versiones "muertas" quepan exactamente en la memoria. <br><br><h2>  An√°lisis </h2><br>  El an√°lisis o, en otras palabras, la recopilaci√≥n de informaci√≥n estad√≠stica para el planificador de consultas, no est√° formalmente relacionado con la limpieza.  Sin embargo, podemos realizar el an√°lisis no solo con el equipo ANALYZE, sino tambi√©n combinar la limpieza con el an√°lisis: AN√ÅLISIS DE VAC√çO.  En este caso, primero se realiza la limpieza y luego el an√°lisis: no se producen ahorros. <br><br>  Pero, como veremos m√°s adelante, la limpieza autom√°tica y el an√°lisis autom√°tico se realizan en un solo proceso y se gestionan de manera similar. <br><br><h1>  Limpieza completa (aspiradora llena) </h1><br>  Como hemos visto, la limpieza convencional libera m√°s espacio que la limpieza entre p√°ginas, pero incluso esto no siempre resuelve el problema por completo. <br><br>  Si por alguna raz√≥n una tabla o √≠ndice ha crecido significativamente en tama√±o, la limpieza regular liberar√° espacio dentro de las p√°ginas existentes: tendr√°n agujeros que luego se usar√°n para insertar nuevas versiones de filas.  Pero el n√∫mero de p√°ginas no cambiar√° y, por lo tanto, desde el punto de vista del sistema operativo, los archivos ocupar√°n exactamente la misma cantidad de espacio que ocuparon antes de la limpieza.  Y esto es malo porque: <br><br><ul><li>  el escaneo completo de una tabla (o √≠ndice) se ralentiza; </li><li>  puede ser necesario un cach√© de b√∫fer m√°s grande (porque las p√°ginas est√°n almacenadas y la densidad de informaci√≥n √∫til disminuye); </li><li>  puede aparecer un nivel "extra" en el √°rbol de √≠ndice, lo que ralentizar√° el acceso al √≠ndice; </li><li>  los archivos ocupan espacio en disco adicional y copias de seguridad. </li></ul><br>  (La √∫nica excepci√≥n son las p√°ginas completamente limpiadas al final del archivo, tales p√°ginas "muerden" el archivo y regresan al sistema operativo). <br><br>  Si la parte de informaci√≥n √∫til en los archivos cae por debajo de un l√≠mite razonable, el administrador puede realizar una limpieza completa de la tabla.  Al mismo tiempo, la tabla y todos sus √≠ndices se reconstruyen completamente desde cero, y los datos se empaquetan de la forma m√°s compacta posible (por supuesto, teniendo en cuenta el par√°metro factor de relleno).  Al reconstruir, PostgreSQL reconstruye secuencialmente la tabla primero y luego cada uno de sus √≠ndices.  Se crean nuevos archivos para cada objeto y, al final de la reconstrucci√≥n, se eliminan los archivos antiguos.  Tenga en cuenta que en el proceso de trabajo en el disco requerir√° espacio adicional. <br><br>  Para ilustrar, inserte varias filas en la tabla nuevamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  ¬øC√≥mo evaluar la densidad de la informaci√≥n?  Para hacer esto, es conveniente usar la extensi√≥n especial: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  La funci√≥n lee toda la tabla y muestra estad√≠sticas sobre cu√°nto espacio ocupan los datos en los archivos.  La informaci√≥n principal que nos interesa ahora es el campo tuple_percent: el porcentaje ocupado por datos √∫tiles.  Es menos de 100 debido a la inevitable sobrecarga de informaci√≥n de servicio dentro de la p√°gina, pero no obstante es bastante alta. <br><br>  Para el √≠ndice, se muestra otra informaci√≥n, pero el campo avg_leaf_density tiene el mismo significado: el porcentaje de informaci√≥n √∫til (en p√°ginas de hoja). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Y aqu√≠ est√° el tama√±o de la tabla y el √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Ahora elimine el 90% de todas las l√≠neas.  Seleccionamos las filas para eliminar al azar, de modo que en cada p√°gina con una alta probabilidad permanezca al menos una fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  ¬øQu√© tama√±o tendr√°n los objetos despu√©s de la limpieza normal? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Vemos que el tama√±o no ha cambiado: la limpieza regular no puede reducir el tama√±o de los archivos de ninguna manera.  Aunque la densidad de informaci√≥n obviamente ha disminuido unas 10 veces: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Ahora verifique qu√© sucede despu√©s de una limpieza completa.  Aqu√≠ est√°n los archivos utilizados por la tabla y los √≠ndices ahora: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Ahora los archivos se reemplazan por otros nuevos.  El tama√±o de la tabla y el √≠ndice ha disminuido significativamente, y la densidad de informaci√≥n ha aumentado en consecuencia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Tenga en cuenta que la densidad de informaci√≥n en el √≠ndice incluso ha aumentado en comparaci√≥n con el original.  Volver a crear un √≠ndice (√°rbol B) a partir de los datos disponibles es m√°s rentable que insertar datos en un √≠ndice existente l√≠nea por l√≠nea. <br><br>  Las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de</a> extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgstattuple</a> que utilizamos leen toda la tabla.  Si la tabla es grande, esto es inconveniente y, por lo tanto, hay una funci√≥n pgstattuple_approx all√≠, que omite las p√°ginas marcadas en el mapa de visibilidad y muestra n√∫meros aproximados. <br><br>  Una forma a√∫n m√°s r√°pida, pero incluso menos precisa, es estimar la proporci√≥n del volumen de datos con respecto al tama√±o del archivo en el directorio del sistema.  Las opciones para tales consultas se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la wiki</a> . <br><br>  Una limpieza completa no requiere un uso regular, ya que bloquea completamente todo el trabajo con la tabla (incluida la consulta) durante toda la duraci√≥n de su trabajo.  Est√° claro que en un sistema utilizado activamente esto puede ser inaceptable.  Los bloqueos se considerar√°n por separado, pero por ahora nos limitaremos a mencionar la extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_repack</a> , que bloquea la tabla solo por un corto tiempo al final del trabajo. <br><br><h2>  Equipos similares </h2><br>  Hay varios comandos que tambi√©n reconstruyen completamente tablas e √≠ndices, y esto es similar a una limpieza completa.  Todos ellos bloquean completamente el trabajo con la tabla, todos eliminan los archivos de datos antiguos y crean nuevos. <br><br>  El comando CLUSTER es similar en todo a VACUUM FULL, pero adem√°s organiza f√≠sicamente la versi√≥n de las cadenas de acuerdo con uno de los √≠ndices disponibles.  Esto le da al planificador la capacidad de utilizar el acceso al √≠ndice de manera m√°s efectiva en algunos casos.  Sin embargo, debe entenderse que la agrupaci√≥n no es compatible: con los cambios posteriores en la tabla, se violar√° el orden f√≠sico de las versiones de fila. <br><br>  El comando REINDEX reconstruye un √≠ndice √∫nico en una tabla.  De hecho, VACUUM FULL y CLUSTER usan este comando para reconstruir √≠ndices. <br><br>  El comando TRUNCATE funciona l√≥gicamente igual que DELETE: elimina todas las filas de la tabla.  Pero DELETE, como ya se discuti√≥, solo marca la versi√≥n de las filas como eliminada, lo que requiere una limpieza adicional.  TRUNCATE solo crea un archivo nuevo y limpio.  Como regla, esto funciona m√°s r√°pido, pero tenga en cuenta que TRUNCATE bloquear√° completamente el trabajo con la tabla durante todo el tiempo hasta el final de la transacci√≥n. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452320/">https://habr.com/ru/post/452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452310/index.html">Configuraci√≥n de canales de venta de red para gadgets DO-RA</a></li>
<li><a href="../452312/index.html">Las telecomunicaciones brit√°nicas pagar√°n una compensaci√≥n a los suscriptores por desconexiones</a></li>
<li><a href="../452314/index.html">El dise√±o de niveles y jugabilidad roguelike en el ejemplo de Cogmind</a></li>
<li><a href="../452316/index.html">La misi√≥n Chang'e-4: los resultados del quinto d√≠a lunar: problemas con el rover Yutu-2 y un nuevo descubrimiento cient√≠fico</a></li>
<li><a href="../452318/index.html">Usar Firebase como almacenamiento de im√°genes para una aplicaci√≥n de Android</a></li>
<li><a href="../452322/index.html">Del epicentro de Google Cloud Next '19: notas de campo del CEO</a></li>
<li><a href="../452328/index.html">Matryoshka C Sistema de lenguaje de programa de capa</a></li>
<li><a href="../452330/index.html">¬øC√≥mo llevar a cabo una planificaci√≥n trimestral sin papel distribuido y no arruinarlo?</a></li>
<li><a href="../452332/index.html">Es dif√≠cil ser un mantenedor de proyectos de c√≥digo abierto</a></li>
<li><a href="../452334/index.html">C√≥mo disfrazarse en Internet: compare servidores y servidores proxy residentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>