<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìï ‚ò¶Ô∏è üíÆ C√≥mo portar un juego a PSVita mejor√≥ el rendimiento general ‚öñÔ∏è ü•ô üëãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el nivel puede haber miles de enemigos. 

 Defender's Quest: Valley of the Forgotten DX siempre ha tenido problemas con la velocidad desde hace muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo portar un juego a PSVita mejor√≥ el rendimiento general</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414135/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/148/2a1/9371482a13b17c628afe9e994e6df76f.jpg" alt="imagen"></div><br>  <i>En el nivel puede haber miles de enemigos.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Defender's Quest: Valley of the Forgotten DX</a> siempre ha tenido problemas con la velocidad desde hace mucho tiempo, y finalmente logr√© resolverlos.  El principal incentivo para un aumento masivo de la velocidad fue nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puerto en PlayStation Vita</a> .  El juego ya se lanz√≥ en la PC y funcion√≥ bien, si no perfectamente, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Xbox One</a> con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PS4</a> .  Pero sin una mejora importante en el juego, nunca podr√≠amos lanzarlo en Vita. <br><br>  Cuando un juego se ralentiza, los comentaristas en Internet suelen culpar a un lenguaje de programaci√≥n o motor.  Es cierto que lenguajes como C # y Java son m√°s caros que C y C ++, y herramientas como Unity tienen problemas irresolubles, como la recolecci√≥n de basura.  De hecho, a la gente se le ocurren tales explicaciones porque el lenguaje y el motor son las propiedades m√°s obvias del software.  Pero los verdaderos asesinos del rendimiento pueden ser peque√±os detalles est√∫pidos que no tienen nada que ver con la arquitectura. <br><a name="habracut"></a><br><h1>  0. Herramientas de perfilado </h1><br>  Solo hay una forma real de hacer que el juego sea m√°s r√°pido: realizar perfiles.  Averig√ºe en qu√© pasa demasiado tiempo la computadora y haga que pase menos tiempo en ella, o incluso mejor, que no pierda tiempo <em>en absoluto</em> . <br><br>  La herramienta de creaci√≥n de perfiles m√°s simple es el monitor de sistema est√°ndar de Windows (monitor de rendimiento): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/b29/a69/ea3b29a690d6fe0ce9c6014abb6a9a62.png"></div><br>  De hecho, esta es una herramienta bastante flexible y es muy f√°cil trabajar con ella.  Simplemente presione Ctrl + Alt + Supr, abra el "Administrador de tareas" y haga clic en la pesta√±a "Rendimiento".  Sin embargo, no ejecute muchos otros programas.  Si observa de cerca, puede detectar f√°cilmente picos en el uso de la CPU e incluso p√©rdidas de memoria.  Esta es una forma poco informativa, pero puede ser el primer paso para encontrar lugares lentos. <br><br>  Defender's Quest est√° escrito en el lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haxe de</a> alto nivel compilado en otros idiomas (mi objetivo principal era C ++).  Esto significa que cualquier herramienta capaz de perfilar C ++ tambi√©n puede perfilar mi c√≥digo C ++ generado por Haxe.  Entonces, cuando quer√≠a entender las causas de los problemas, lanc√© Performance Explorer desde Visual Studio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/a24/932/999a24932b41cd329e28bcb6c5076725.png"></div><br>  Adem√°s, las diferentes consolas tienen sus propias herramientas de creaci√≥n de perfiles, lo cual es muy conveniente, pero debido a la NDA no puedo decirle nada sobre ellas.  Pero si tienes acceso a ellos, ¬°pero aseg√∫rate de usarlos! <br><br>  En lugar de escribir un terrible tutorial sobre c√≥mo usar herramientas de creaci√≥n de perfiles como Performance Explorer, solo dejo un enlace a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n oficial</a> y paso al tema principal: cosas sorprendentes que llevaron a un gran aumento de la productividad y c√≥mo logr√© encontrarlas ! <br><br><h1>  1. Detecci√≥n de problemas </h1><br>  El rendimiento del juego no es solo la velocidad en s√≠ misma, sino tambi√©n su percepci√≥n.  Defender's Quest es un juego de g√©nero de defensa de torre que se renderiza a 60 FPS, pero con una velocidad de juego variable en el rango de 1 / 4x a 16x.  Independientemente de la velocidad del juego, la simulaci√≥n utiliza una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marca de tiempo fija</a> con 60 actualizaciones por segundo de 1x tiempo de simulaci√≥n.  Es decir, si ejecuta el juego a una velocidad de 16x, entonces la l√≥gica de actualizaci√≥n realmente funcionar√° con una frecuencia de <em>960 FPS</em> .  Honestamente, ¬°estas son solicitudes demasiado altas para el juego!  Pero fui yo quien cre√≥ este modo, y si resulta ser lento, los jugadores definitivamente lo notar√°n. <br><br>  Y en el juego hay <em>tal</em> nivel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/5e1/694/ed95e16941a18fe9a71b7333d537f1d9.png"></div><br>  Esta es la batalla de bonificaci√≥n final "Endless 2", tambi√©n es "mi pesadilla personal".  La captura de pantalla se tom√≥ en el modo New Game +, en el que los enemigos no solo son mucho m√°s fuertes, sino que tambi√©n tienen caracter√≠sticas como restaurar la salud.  La estrategia favorita del jugador aqu√≠ es bombear a los dragones al m√°ximo nivel de Rugido (ataque AOE que aturde a los enemigos), y detr√°s de ellos poner una cantidad de caballeros con Knockback bombeado al m√°ximo para empujar a todos los que pasen los dragones de regreso a su √°rea de acci√≥n.  El efecto acumulativo es que un gran grupo de monstruos permanece sin parar en un lugar, mucho m√°s tiempo del que tendr√≠an que sobrevivir los jugadores si realmente los mataran.  Dado que los jugadores deben <em>esperar</em> olas y no <em>matarlas</em> para recibir recompensas y logros, esta estrategia es absolutamente efectiva y brillante: este es exactamente el comportamiento de los jugadores que estimul√©. <br><br>  Desafortunadamente, esto tambi√©n resulta ser un caso <em>patol√≥gico</em> para el rendimiento, <em>especialmente</em> cuando los jugadores quieren jugar a velocidades de 16x u 8x.  Por supuesto, solo los jugadores m√°s hardcore tratar√°n de obtener el logro "Hundredth Wave" en New Game + en el nivel Endless 2, pero son solo los que hablan el juego m√°s fuerte, as√≠ que quer√≠a que fueran felices. <br><br>  Es solo un juego en 2D con un mont√≥n de sprites, ¬øqu√© podr√≠a estar mal? <br><br>  Y de hecho.  Vamos a hacerlo bien. <br><br><h1>  2. Resoluci√≥n de colisi√≥n </h1><br>  Echa un vistazo a esta captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/bd2/116/098bd2116180a0b3ea3c9a66339b7fa3.png"></div><br>  ¬øVes este bagel alrededor del guardabosques?  Esta es su √°rea de impacto: tenga en cuenta que tambi√©n hay una zona muerta en la que no <em>puede</em> alcanzar objetivos.  Cada clase tiene su propia √°rea de ataque, y cada defensor tiene un √°rea de diferente tama√±o, dependiendo del nivel de impulso y los par√°metros personales.  Y cada defensor en teor√≠a puede apuntar a cualquier enemigo en el campo de su alcance.  Lo mismo es cierto para ciertos tipos de enemigos.  Puede haber hasta 36 defensores en el mapa (sin incluir el personaje principal Azru), pero no hay un l√≠mite superior en el n√∫mero de enemigos.  Cada defensor y enemigo tiene una lista de posibles objetivos, creada sobre la base de llamadas para verificar el √°rea en cada paso de actualizaci√≥n (menos el corte l√≥gico de aquellos que no pueden atacar en este momento, y as√≠ sucesivamente). <br><br>  Hoy en d√≠a, los procesadores de video son muy r√°pidos: si no los aplica demasiado, pueden procesar casi cualquier n√∫mero de pol√≠gonos.  Pero incluso las CPU m√°s r√°pidas tienen f√°cilmente "cuellos de botella" en procedimientos simples, especialmente aquellos que crecen exponencialmente.  Es por eso que un juego 2D puede resultar m√°s lento que un juego 3D mucho m√°s hermoso, no porque el programador no pueda hacer frente (tal vez esto tambi√©n sea, al menos en mi caso), sino en principio porque la l√≥gica a veces puede ser m√°s costosa, que dibujar!  La pregunta no es cu√°ntos objetos hay en la pantalla, sino qu√© <em>hacen</em> . <br><br>  Exploremos y agilicemos el reconocimiento de colisiones.  A modo de comparaci√≥n, dir√© que antes de la optimizaci√≥n, el reconocimiento de colisi√≥n tom√≥ hasta ~ 50% del tiempo de CPU en el ciclo de batalla principal.  Despu√©s de la optimizaci√≥n, menos del 5%. <br><br><h2>  Se trata de √°rboles cuadrantes </h2><br>  La principal soluci√≥n al problema del reconocimiento de colisi√≥n lenta es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dividir el espacio</a> , y desde el principio utilizamos una implementaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de</a> alta calidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del √°rbol de cuadrante</a> .  Esencialmente, separa efectivamente el espacio para que se puedan omitir muchas comprobaciones de colisi√≥n opcionales. <br><br>  En cada cuadro, actualizamos todo el √°rbol de cuadrantes (QuadTree) para rastrear la posici√≥n de cada objeto, y cuando el enemigo o el defensor quiere apuntar a alguien, le pide a QuadTree una lista de objetos cercanos.  Pero el generador de perfiles nos dijo que ambas operaciones son mucho m√°s lentas de lo que deber√≠an ser. <br><br>  ¬øQu√© est√° mal aqu√≠? <br><br>  Al final result√≥ que, mucho. <br><br><h2>  Mecanograf√≠a </h2><br>  Como mantuve a los enemigos y defensores en un √°rbol de cuadrante, tuve que indicar lo que estaba buscando, y esto se hizo as√≠: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, "e"); //"e" -   "enemy"</code> <br> <br>  En la jerga de los programadores, esto se llama c√≥digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escritura de cadenas</a> y, entre otras razones, es malo porque las comparaciones de cadenas siempre son m√°s lentas que las enteras. <br><br>  R√°pidamente recog√≠ constantes enteras y reemplac√© el c√≥digo con esto: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, QuadTree.ENEMY);</code> <br> <br>  (S√≠, probablemente vali√≥ la pena usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enum Abstract</a> para la m√°xima seguridad de tipograf√≠a, pero ten√≠a prisa y primero necesitaba hacer el trabajo). <br><br>  Este cambio solo hizo una <em>gran</em> contribuci√≥n, porque esta funci√≥n se llama de forma <em>constante</em> y recursiva, cada vez que alguien necesita una nueva lista de objetivos. <br><br><h2>  Matriz vs Vector </h2><br>  Mira esto: <br><br> <code>var things:Array&lt;XY&gt;</code> <br> <br>  Las matrices Haxe son muy similares a las matrices ActionScript y JS en que son colecciones de objetos redimensionables, pero en Haxe est√°n fuertemente tipadas. <br><br>  Sin embargo, existe otra estructura de datos que es m√°s eficiente con lenguajes est√°ticos de destino como cpp, es decir, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">haxe.ds.Vector</a> .  Los vectores haxe son esencialmente lo mismo que las matrices, excepto que cuando se crean obtienen un tama√±o fijo. <br><br>  Como mis √°rboles de cuadrante ya ten√≠an un volumen fijo, reemplac√© las matrices con vectores para lograr un aumento notable de la velocidad. <br><br><h2>  Solicita solo lo que necesitas </h2><br>  Anteriormente, mi funci√≥n <code>queryRange</code> devolv√≠a una lista de objetos, instancias <code>XY</code> .  Conten√≠an las coordenadas x / y del objeto de juego referenciado y su identificador entero √∫nico (√≠ndice de b√∫squeda en la matriz principal).  El objeto del juego que ejecutaba la solicitud recibi√≥ estos XY, extrajo un identificador entero para obtener su objetivo y luego se olvid√≥ del resto. <br><br>  Entonces, ¬øpor qu√© deber√≠a pasar todas estas referencias a objetos XY para cada nodo QuadTree de forma <em>recursiva</em> , e incluso <em>960 veces por cuadro?</em>  Es suficiente para m√≠ devolver una lista de identificadores enteros. <br><br>  <strong><em>CONSEJO PROFESIONAL: ¬°los enteros son mucho m√°s r√°pidos de transmitir que casi todos los dem√°s tipos de datos!</em></strong> <br><br>  En comparaci√≥n con otras correcciones, esto era bastante simple, pero el crecimiento del rendimiento a√∫n era notable, porque este bucle interno se usaba de manera muy activa. <br><br><h2>  Optimizaci√≥n de recursi√≥n de cola </h2><br>  Hay una cosa elegante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada optimizaci√≥n de</a> llamadas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cola</a> .  Es dif√≠cil de explicar, as√≠ que mejor te mostrar√© un ejemplo. <br><br>  Fue: <br><br> <code>nw.queryRange(Range, -1, result); <br> ne.queryRange(Range, -1, result); <br> sw.queryRange(Range, -1, result); <br> se.queryRange(Range, -1, result); <br> return result;</code> <br> <br>  Se convirti√≥ en: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, sw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, ne.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, nw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, result))));</code> </pre> <br>  El c√≥digo devuelve los mismos resultados l√≥gicos, pero seg√∫n el generador de perfiles, la segunda opci√≥n es m√°s r√°pida, al menos cuando se traduce a cpp.  Ambos ejemplos realizan exactamente la misma l√≥gica: realizan cambios en la estructura de datos de "resultado" y la pasan a la siguiente funci√≥n antes de regresar.  Cuando hacemos esto de forma recursiva, podemos evitar que el compilador genere referencias temporales, ya que simplemente puede devolver el resultado de la funci√≥n anterior de inmediato, en lugar de seguirlo en un paso adicional.  O algo por el estilo.  No entiendo completamente c√≥mo funciona esto, as√≠ que lea la publicaci√≥n en el enlace de arriba. <br><br>  (A juzgar por lo que s√©, la versi√≥n actual del compilador Haxe no tiene una funci√≥n de optimizaci√≥n de recursi√≥n de cola, es decir, probablemente sea el trabajo del compilador C ++, as√≠ que no se sorprenda si este truco no funciona al traducir el c√≥digo Haxe no en cpp). <br><br><h2>  Agrupaci√≥n de objetos </h2><br>  Si necesito resultados precisos, debo destruir y reconstruir QuadTree nuevamente con cada llamada de actualizaci√≥n.  Crear nuevas instancias de QuadTree es una tarea bastante com√∫n, pero con un gran n√∫mero de nuevos objetos AABB y XY, los QuadTrees que dependen de ellos provocaron una sobrecarga de memoria severa.  Como se trata de objetos muy simples, ser√≠a l√≥gico asignar muchos de estos objetos por adelantado y reutilizarlos constantemente.  Esto se llama un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupo de objetos</a> . <br><br>  Sol√≠a ‚Äã‚Äãhacer algo como esto: <br><br> <code>nw = new QuadTree( new AABB( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( new AABB( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( new AABB( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( new AABB( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Pero luego reemplac√© el c√≥digo con esto: <br><br> <code>nw = new QuadTree( AABB.get( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( AABB.get( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( AABB.get( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( AABB.get( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Utilizamos el marco de c√≥digo abierto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HaxeFlixel</a> , por lo que lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementamos</a> usando la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FlxPool</a> HaxeFlixel.  En el caso de optimizaciones tan altamente especializadas, a menudo reemplazo algunos de los elementos b√°sicos de Flixel (por ejemplo, reconocimiento de colisi√≥n) con mi propia implementaci√≥n (como lo hice con QuadTrees), pero FlxPool es mejor que todo lo que escrib√≠ yo mismo y hace exactamente lo que necesita. <br><br><h2>  Especializaci√≥n si es necesario </h2><br>  Un objeto <code>XY</code> es una clase simple que tiene las propiedades <code>x</code> , <code>y</code> e <code>int_id</code> .  Como se us√≥ en un bucle interno particularmente activo, pude guardar muchos comandos y operaciones de asignaci√≥n de memoria moviendo todos estos datos a una estructura de datos especial que proporciona la misma funcionalidad que <code>Vector&lt;XY&gt;</code> .  Llam√© a esta nueva clase <code>XYVector</code> y el resultado se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Esta es una aplicaci√≥n muy especializada y no es flexible al mismo tiempo, pero nos ha proporcionado algunas mejoras de velocidad. <br><br><h2>  Funciones incorporadas </h2><br>  Ahora, despu√©s de haber completado la fase amplia del reconocimiento de colisi√≥n, necesitamos hacer muchas comprobaciones para descubrir qu√© objetos realmente colisionan.  Siempre que sea posible, trato de comparar puntos y figuras, no figuras y figuras, pero a veces tengo que hacer lo √∫ltimo.  En cualquier caso, todo esto requiere sus propios controles especiales: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  Todo esto se puede mejorar con una sola <code>inline</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  Cuando agregamos en l√≠nea a una funci√≥n, le decimos al compilador que copie y pegue este c√≥digo y pegue las variables cuando se usa, y que no realice una llamada externa a una funci√≥n separada, lo que genera costos innecesarios.  La incrustaci√≥n no siempre es aplicable (por ejemplo, infla la cantidad de c√≥digo), pero es ideal para situaciones en las que se invocan funciones peque√±as una y otra vez. <br><br><h2>  Traemos a la mente conflictos </h2><br>  La verdadera lecci√≥n aqu√≠ es que en el mundo real, las optimizaciones no siempre son del mismo tipo.  Tales soluciones son una mezcla de t√©cnicas avanzadas, trucos baratos, aplicaci√≥n de recomendaciones l√≥gicas y eliminaci√≥n de errores est√∫pidos.  Todo esto en general nos da un impulso de rendimiento. <br><br>  Pero a√∫n as√≠, ¬° <em>mide siete veces, corta una!</em> <br><br>  No vale la pena el esfuerzo de dos horas de optimizaci√≥n pedante de la funci√≥n, llamada una vez cada seis cuadros y que toma 0.001 ms, a pesar de la fealdad y la estupidez del c√≥digo. <br><br><h1>  3. Ordenar todo </h1><br>  De hecho, fue una de mis √∫ltimas mejoras, pero result√≥ ser tan ventajoso que merece su propio t√≠tulo.  Adem√°s, fue el m√°s simple y se demostr√≥ repetidamente.  El generador de perfiles me mostr√≥ un procedimiento que no pude mejorar en absoluto: el bucle principal draw (), que tom√≥ demasiado tiempo.  La raz√≥n fue la funci√≥n que orden√≥ todos los elementos de la pantalla antes de renderizar, es decir, ¬° <em>ordenar</em> todos los sprites tom√≥ mucho m√°s tiempo que dibujarlos! <br><br>  Si miras las capturas de pantalla del juego, ver√°s que todos los enemigos y defensores se ordenan primero por <code>y</code> , luego, por <code>x</code> , de modo que los elementos se superpongan entre s√≠ de atr√°s hacia adelante, de izquierda a derecha, cuando nos movemos desde la esquina superior izquierda a la esquina inferior derecha de la pantalla. <br><br>  Una forma de burlar la clasificaci√≥n es simplemente pasar la clasificaci√≥n de representaci√≥n a trav√©s del marco.  Este es un truco √∫til para algunas funciones costosas, pero de inmediato condujo a errores visuales muy notables, por lo que no nos conven√≠a. <br><br>  Finalmente, la decisi√≥n vino de uno de los mantenedores de HaxeFlixel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jens Fisher</a> .  √âl pregunt√≥: "¬øTe has asegurado de usar un algoritmo de clasificaci√≥n que sea r√°pido para las matrices casi ordenadas?" <br><br>  No!  Result√≥ que no.  Utilic√© la ordenaci√≥n de matrices de la biblioteca est√°ndar de Haxe (creo que fue una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">combinaci√≥n de fusi√≥n</a> , una buena opci√≥n para casos generales. Pero tuve un caso muy <em>especial</em> . Al ordenar en cada cuadro, la posici√≥n de clasificaci√≥n cambia solo un n√∫mero muy peque√±o de sprites, incluso si hay muchos de ellos. Por lo tanto, Reemplac√© la antigua llamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaci√≥n</a> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaci√≥n por insertos</a> , y <em>¬°boom!</em> - la velocidad aument√≥ instant√°neamente. <br><br><h1>  4. Otros problemas t√©cnicos </h1><br>  El reconocimiento y la clasificaci√≥n de colisiones fueron grandes victorias en la l√≥gica de <code>update()</code> y <code>draw()</code> , pero se ocultaron muchas m√°s trampas en los bucles internos utilizados activamente. <br><br><h2>  Std.is () y elenco </h2><br>  En diferentes bucles internos "calientes", ten√≠a un c√≥digo similar: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Std.<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { var typed:<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = cast(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>); }</code> </pre> <br><br>  En el lenguaje Haxe, <code>Std.is()</code> nos dice si un objeto pertenece a un tipo espec√≠fico (Tipo) o una clase (Clase), y <code>cast</code> intenta lanzarlo a un tipo espec√≠fico durante la ejecuci√≥n del programa. <br><br>  Hay versiones seguras y sin protecci√≥n de <code>cast</code> : los yesos seguros conducen a un rendimiento reducido, pero los yesos sin protecci√≥n no lo hacen. <br><br>  Seguro: <code>cast(something, Type);</code> <br><br>  Desprotegido: <code>var typed:Type = cast something;</code> <br><br>  Cuando falla un intento de lanzamiento inseguro, quedamos nulos, mientras que un lanzamiento seguro arroja una excepci√≥n.  Pero si no vamos a atrapar una excepci√≥n, ¬øcu√°l es el punto de hacer un reparto seguro?  Sin captura, la operaci√≥n a√∫n falla, pero funciona m√°s lentamente. <br><br>  Adem√°s, no tiene sentido preceder un lanzamiento seguro con la comprobaci√≥n <code>Std.is()</code> .  La √∫nica raz√≥n para usar un yeso seguro es una excepci√≥n garantizada, pero si verificamos el tipo antes del yeso, ¬°ya garantizamos que el yeso no fallar√°! <br><br>  Puedo acelerar un poco las <code>Std.is()</code> con un reparto <code>Std.is()</code> despu√©s de verificar <code>Std.is()</code> .  Pero, ¬øpor qu√© necesitamos reescribir lo mismo si no necesito verificar el tipo de clase en absoluto? <br><br>  Supongamos que tengo un <code>CreatureSprite</code> , que puede ser una instancia de una subclase de <code>DefenderSprite</code> o <code>EnemySprite</code> .  En lugar de llamar a <code>Std.is(this,DefenderSprite)</code> podemos crear un campo entero en <code>CreatureSprite</code> con valores como <code>CreatureType.DEFENDER</code> o <code>CreatureType.ENEMY</code> , que se verifican a√∫n m√°s r√°pido. <br><br>  Repito, vale la pena arreglarlo solo en aquellos lugares donde se registra claramente una desaceleraci√≥n significativa. <br><br>  Por cierto, puedes leer m√°s sobre el yeso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguro</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sin protecci√≥n</a> en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual de Haxe</a> . <br><br><h2>  Serializaci√≥n / Deserializaci√≥n del Universo </h2><br>  Fue molesto encontrar esos lugares en el c√≥digo: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:SomeClass </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SomeClass.fromXML(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toXML()); }</code> </pre> <br>  Si  Para copiar un objeto, lo <em>serializamos en XML</em> y luego <em>analizamos todo este XML</em> , despu√©s de lo cual descartamos instant√°neamente el XML y devolvemos un nuevo objeto.  Esta es probablemente la forma m√°s lenta de copiar un objeto, adem√°s, sobrecarga la memoria.  Inicialmente, escrib√≠ llamadas XML para guardar y cargar desde el disco, y creo que era demasiado vago para escribir los procedimientos de copia correctos. <br><br>  Probablemente, todo estar√≠a en orden si esta funci√≥n rara vez se usara, pero estas llamadas surgieron en lugares inapropiados en el medio del juego.  As√≠ que me sent√© y comenc√© a escribir y probar la funci√≥n de copia correcta. <br><br><h2>  Di no a nulo </h2><br>  La comprobaci√≥n de igualdad para nulo se usa con bastante frecuencia, pero cuando se traduce Haxe a cpp, un objeto que permite un valor indefinido genera costos innecesarios que no surgen si el compilador puede suponer que el objeto nunca ser√° nulo.  Esto es especialmente cierto para los tipos base como <code>Int</code> - Haxe implementa la validez de un valor indefinido para ellos en el sistema de destino est√°tico por su "empaque", lo que ocurre no solo para las variables que se declaran expl√≠citamente como nulas ( <code>var myVar:Null&lt;Int&gt;</code> ), sino tambi√©n para cosas como las opciones de ayuda ( <code>?myParam:Int</code> ).  Adem√°s, los cheques nulos en s√≠ mismos causan desperdicio innecesario. <br><br>  Pude solucionar algunos de estos problemas simplemente mirando el c√≥digo y pensando en alternativas: ¬øpuedo hacer una verificaci√≥n m√°s simple, que siempre ser√° cierta cuando el objeto sea nulo?  ¬øPuedo detectar nulos mucho antes en la cadena de llamadas a funciones y pasar un entero simple o un indicador booleano a las llamadas secundarias?  ¬øPuedo estructurar todo para que <em>nunca se</em> garantice que el valor sea nulo?  Y as√≠ sucesivamente.  No podemos eliminar por completo las verificaciones nulas y los valores anulables, pero sacarlos de las funciones me ayud√≥ mucho. <br><br><h1>  5. Tiempo de descarga </h1><br>  En PSVita, tuvimos problemas serios especiales con el tiempo de carga de algunas escenas.  Al generar perfiles, result√≥ que las razones se reducen principalmente a la rasterizaci√≥n de texto, la representaci√≥n innecesaria de software, la representaci√≥n costosa de botones y otras cosas. <br><br><h2>  Texto </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HaxeFlixel se</a> basa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenFL</a> , que tiene TextField impresionante y confiable.  Pero utilic√© objetos FlxText de manera imperfecta: los objetos FlxText tienen un campo de texto interno OpenFL que est√° rasterizado.  Sin embargo, result√≥ que no necesitaba la mayor√≠a de estas funciones de texto complejas, pero debido a la forma est√∫pida de configurar mi sistema de interfaz de usuario, los campos de texto ten√≠an que representarse antes de que se ubicaran todos los dem√°s objetos.  Esto condujo a saltos peque√±os pero notables, por ejemplo, al cargar una ventana emergente. <br><br>  Aqu√≠ hice tres correcciones: en primer lugar, reemplac√© la mayor cantidad de texto posible con fuentes r√°ster.  Flixel tiene soporte incorporado para varios formatos de fuente r√°ster, incluido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BMFont de AngelCode</a> , que facilita el trabajo con Unicode, estilo y kerning, pero la API de texto r√°ster es ligeramente diferente de la API de texto plano, por lo que tuve que escribir una peque√±a clase de contenedor para simplifica la transici√≥n.  (Le di el nombre adecuado <code>FlxUITextHack</code> ). <br><br>  Esto mejor√≥ ligeramente el trabajo: las fuentes de mapa de bits se procesan muy r√°pidamente, pero aument√≥ ligeramente la complejidad: tuve que preparar especialmente conjuntos de caracteres separados y agregar l√≥gica de cambio dependiendo de la configuraci√≥n regional, en lugar de simplemente configurar un cuadro de texto que hizo todo el trabajo. <br><br>  La segunda soluci√≥n fue crear un nuevo objeto de interfaz de usuario que fuera un simple <em>marcador</em> de <em>posici√≥n</em> para el texto pero que tuviera las mismas propiedades p√∫blicas que el texto.  Lo llam√© "√°rea de texto" y cre√© una nueva clase para √©l en mi biblioteca de interfaz de usuario para que mi sistema de interfaz de usuario pueda usar estas √°reas de texto de la misma manera que los campos de texto reales, pero no muestra nada hasta que calcula el tama√±o y la posici√≥n para todo lo dem√°s.  Luego, cuando mi escena estaba preparada, comenc√© el procedimiento de reemplazar estas √°reas de texto con campos de texto reales (o campos de texto de fuentes de mapa de bits). <br><br>  La tercera correcci√≥n se refer√≠a a la percepci√≥n.  Si hay pausas entre la entrada y la reacci√≥n, incluso en medio segundo, el jugador percibe esto como frenado.  Por lo tanto, trat√© de encontrar todas las escenas en las que hay un retraso en la entrada hasta la pr√≥xima transici√≥n, y agregu√© una capa transl√∫cida con la palabra "Cargando ..." o simplemente una capa sin texto.  Una correcci√≥n tan simple mejor√≥ en gran medida la <em>percepci√≥n de la</em> capacidad <em>de</em> respuesta del juego, ya que algo sucede inmediatamente despu√©s de que el jugador toca el control, incluso si lleva un tiempo mostrar el men√∫. <br><br><h2>  Renderizado de software </h2><br>  La mayor√≠a de los men√∫s utilizan una combinaci√≥n de escala de software y composici√≥n de 9 divisiones.  Esto sucedi√≥ porque en la versi√≥n para PC hab√≠a una interfaz de usuario independiente de la resoluci√≥n que pod√≠a funcionar con una relaci√≥n de aspecto de 4: 3 y 16: 9, escalada en consecuencia.  Pero en PSVita ya <em>conocemos la</em> resoluci√≥n, es decir, no necesitamos todos estos recursos extra de alta resoluci√≥n y algoritmos de escala en tiempo real.  Simplemente podemos pre-renderizar recursos a la resoluci√≥n exacta y colocarlos en la pantalla. <br><br>  Primero, ingres√© en el marcado de UI para las condiciones de Vita que cambiaron el juego al uso de un conjunto paralelo de recursos.  Entonces necesitaba crear estos recursos preparados para un permiso.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">depurador HaxeFlixel</a> result√≥ ser muy √∫til <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> : agregu√© mi script para que simplemente vac√≠e el cach√© de trama al disco.  Luego, cre√© una configuraci√≥n de compilaci√≥n especial para Windows que simula el permiso para Vita, abr√≠ todos los men√∫s del juego, cambi√© al depurador y lanc√© el comando de exportaci√≥n para las versiones escaladas de los recursos como PNG listos para usar.  Luego los renombr√© y los us√© como recursos para Vita. <br><br><h2>  Representaci√≥n de botones </h2><br>  Mi sistema de interfaz de usuario ten√≠a un problema real con los botones: cuando se crearon, los botones representaron el conjunto de recursos predeterminado y, un momento despu√©s, cambiaron el tama√±o (y volvieron a mostrar) el c√≥digo de inicio de la interfaz de usuario, y a veces incluso la <em>tercera</em> vez, antes de cargar toda la interfaz de usuario .  Resolv√≠ este problema agregando opciones que retrasaron la representaci√≥n de los botones a la √∫ltima etapa. <br><br><h2>  Escaneo de texto opcional </h2><br>  La revista se estaba cargando especialmente despacio.  Al principio pens√© que el problema estaba en los campos de texto, pero no.  El texto de la revista puede contener enlaces a otras p√°ginas, lo que se indica mediante caracteres especiales incrustados en el texto sin formato.  Estos caracteres se cortaron m√°s tarde y se usaron para calcular la ubicaci√≥n del enlace. <br><br>  Result√≥  que escane√© <em>todos los campos de texto</em> para encontrar y reemplazar estos caracteres con enlaces formateados correctamente, ¬°sin siquiera comprobar primero si hay alg√∫n car√°cter especial en este campo de texto!  Peor a√∫n, seg√∫n el dise√±o, los enlaces <em>solo se</em> usaron en la p√°gina de contenido, pero los verifiqu√© en cada cuadro de texto en cada p√°gina. <br><br>  Me las arregl√© para sortear todas estas comprobaciones utilizando la construcci√≥n if del formulario "¬øEste cuadro de texto utiliza enlaces en absoluto?".  La respuesta a esta pregunta generalmente era no.  Finalmente, la p√°gina que tard√≥ m√°s en cargar result√≥ ser la p√°gina de √≠ndice.  Como nunca cambia en el men√∫ del diario, ¬øpor qu√© no lo almacenamos en cach√©? <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Perfiles de memoria </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La velocidad no es solo la CPU. </font><font style="vertical-align: inherit;">La memoria tambi√©n puede ser un problema, especialmente en plataformas d√©biles como Vita. </font><font style="vertical-align: inherit;">Incluso cuando logr√≥ deshacerse de la √∫ltima p√©rdida de memoria, a√∫n podr√≠a tener problemas con el uso de la memoria de diente de sierra en un entorno de recolecci√≥n de basura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l es el uso de la memoria de diente de sierra? </font><font style="vertical-align: inherit;">El recolector de basura funciona de la siguiente manera: los datos y los objetos que no utiliza se acumulan con el tiempo y se borran peri√≥dicamente. </font><font style="vertical-align: inherit;">Pero no tiene un control claro sobre cu√°ndo sucede esto, por lo que el gr√°fico de uso de memoria parece una sierra:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/d66/464/7fcd664644c9d2b8bbfe3ac82d60ae2b.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sacar la basura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la limpieza no es instant√°nea, la cantidad total de RAM que usa generalmente es mayor de lo que realmente necesita. Pero si </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excede la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cantidad total de RAM del sistema, puede suceder una de dos cosas: en una PC, probablemente solo use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un archivo de p√°gina</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir, convierta temporalmente parte del espacio del disco duro en RAM virtual. Una alternativa en entornos de memoria limitada (como las consolas) es bloquear la aplicaci√≥n, incluso si no hubiera suficientes pares de bytes miserables. ¬°Y esto suceder√° incluso si no usa estos bytes y la recolecci√≥n de basura se realizar√° en ellos pronto!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo bueno de Haxe es que es completamente de c√≥digo abierto, es decir, no est√° encerrado en un cuadro negro que no puede arreglar, como es el caso de Unity. </font><font style="vertical-align: inherit;">¬°Y el backend hxcpp proporciona una amplia gesti√≥n de recolecci√≥n de basura directamente desde la API! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los usamos para borrar instant√°neamente la memoria despu√©s de un gran nivel para permanecer dentro de los l√≠mites dados: </font></font><br><br> <code>cpp.vm.Gc.run(false); //   (true/false - /  )</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no debe usarlo involuntariamente si no sabe lo que est√° haciendo, pero es conveniente que existan tales herramientas cuando sean necesarias.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Soluci√≥n a trav√©s del dise√±o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas estas mejoras de rendimiento fueron m√°s que suficientes para optimizar el juego para PC, pero tambi√©n tratamos de lanzar una versi√≥n para PSVita, y ten√≠amos planes a largo plazo para Nintendo Switch, por lo que tuvimos que exprimir todo, desde el c√≥digo hasta la ca√≠da. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero a menudo hay una "visi√≥n de t√∫nel" cuando te enfocas solo en ataques t√©cnicos y olvidas que un simple cambio de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dise√±o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede mejorar enormemente la situaci√≥n </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acelerar los efectos a alta velocidad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con 16x, muchos efectos ocurren tan r√°pido que el jugador ni siquiera los ve. Ya hemos usado un truco: el rayo de Azra se hizo m√°s f√°cil con la velocidad del juego, y la cantidad de part√≠culas para los ataques AOE es menor. Complementamos esta t√©cnica al deshabilitar los n√∫meros de da√±o de alta velocidad y otros trucos similares. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n nos dimos cuenta de que en alg√∫n momento, la velocidad de 16x puede ser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s lenta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que la de 8x cuando hay demasiados objetos en la pantalla, por lo que cuando el n√∫mero de enemigos aumenta hasta cierto l√≠mite, reducimos autom√°ticamente la velocidad del juego a 8x o 4x. En la pr√°ctica, es probable que el jugador vea esto solo en Endless Battle 2. Esto permite un rendimiento y renderizaci√≥n fluidos sin sobrecargar la CPU.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n utilizamos restricciones espec√≠ficamente para la plataforma. </font><font style="vertical-align: inherit;">En Vita, omitimos el efecto del rayo cuando Azra activa o acelera al personaje, y usamos otros trucos similares.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuerpo oculto </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øY qu√© hay del enorme mont√≥n de enemigos en la esquina inferior derecha de Endless Battle 2? Hay literalmente cientos o incluso </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">miles de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enemigos dibujando uno encima del otro. </font><font style="vertical-align: inherit;">¬øPor qu√© no nos saltamos la representaci√≥n de aquellos que ni siquiera podemos ver? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un truco de dise√±o astuto que requiere una programaci√≥n astuta, porque necesitamos un algoritmo inteligente que defina los objetos ocultos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de estos juegos se dibujan utilizando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el algoritmo del artista</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : los objetos anteriores en la lista de dibujo est√°n bloqueados por todo lo que viene despu√©s de ellos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al invertir el orden de representaci√≥n del algoritmo del artista, puede generar un "mapa de portada" y descubrir qu√© debe ocultarse. Cre√© un falso "lienzo" con 8 niveles de "oscuridad" (solo una matriz bidimensional de bytes) con una resoluci√≥n mucho menor que un campo de batalla real. Comenzando desde el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">final de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la lista de renderizado, tomamos el cuadro delimitador de cada objeto y lo "dibujamos" en el lienzo, aumentando la "oscuridad" del punto en 1 por cada "p√≠xel" cubierto por el cuadro delimitador de baja resoluci√≥n. Al mismo tiempo, leemos la "oscuridad" promedio del √°rea en la que vamos a dibujar. De hecho, predecimos cu√°ntos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redibujos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experimentar√° cada objeto con una llamada de dibujo real.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el n√∫mero previsto de redibujos es lo suficientemente alto, entonces marco al enemigo como "enterrado", con dos umbrales: completamente enterrado, es decir, completamente invisible o parcialmente enterrado, es decir, ser√° dibujado, pero sin mostrar una barra de salud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Por cierto, esta es la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funci√≥n de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verificar los redibujos). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que esto funcione correctamente, debe configurar correctamente la resoluci√≥n del mapa oculto. </font><font style="vertical-align: inherit;">Si es demasiado grande, tendremos que realizar un mont√≥n adicional de llamadas simplificadas, si es demasiado peque√±o, ocultaremos los objetos de manera demasiado agresiva y obtendremos errores visuales. </font><font style="vertical-align: inherit;">Si selecciona la tarjeta correctamente, el efecto apenas se nota, pero el aumento de la velocidad es muy notable: no hay forma de dibujar algo m√°s r√°pido que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hacerlo.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mejor precarga que frenos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En medio de las peleas, not√© frenadas frecuentes, que, estaba seguro, fueron causadas por una pausa en la recolecci√≥n de basura. </font><font style="vertical-align: inherit;">Sin embargo, la elaboraci√≥n de perfiles ha demostrado que esto no es as√≠. </font><font style="vertical-align: inherit;">Pruebas posteriores revelaron que esto ocurre al comienzo de la ola de generaci√≥n de enemigos, y m√°s tarde descubr√≠ que esto solo ocurre cuando se trata de una ola de enemigos que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no exist√≠a antes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obviamente, alg√∫n c√≥digo de configuraci√≥n enemigo caus√≥ el problema y, por supuesto, al perfilar, se encontr√≥ una funci√≥n "activa" en la configuraci√≥n de gr√°ficos. </font><font style="vertical-align: inherit;">Comenc√© a trabajar en una compleja configuraci√≥n de descarga de subprocesos m√∫ltiples, pero luego me di cuenta de que pod√≠a poner todos los procedimientos de carga de gr√°ficos enemigos en la precarga de la batalla. </font><font style="vertical-align: inherit;">Por separado, estas fueron descargas muy peque√±as, incluso en las plataformas m√°s lentas que agregaron menos de un segundo al tiempo total de carga de la batalla, pero evitaron un frenado muy notable durante el juego.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reservamos stock para m√°s tarde </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si trabaja en un entorno con memoria limitada, puede usar el antiguo truco de nuestra industria: asignar una gran cantidad de memoria as√≠, y luego olvidarlo hasta el final del proyecto. Al final del proyecto, despu√©s de haber desperdiciado todo el presupuesto de memoria disponible, puede salvarse gracias a este "huevo de ahorros". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos encontramos en una situaci√≥n as√≠: solo necesit√°bamos una docena de bytes para guardar el ensamblado para PSVita, pero demonios, ¬°nos olvidamos de este truco y, por lo tanto, nos atascamos! ¬°Las √∫nicas opciones restantes fueron semanas de cirug√≠a de c√≥digo desesperada y dolorosa! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero espera un momento! Una de mis optimizaciones (sin √©xito) fue cargar tantos recursos como sea posible y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpetuo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacenarlos en la memoria, porque supuse por error que la lectura de recursos durante la ejecuci√≥n del programa caus√≥ un gran tiempo de carga. </font><font style="vertical-align: inherit;">Result√≥ que esto no era as√≠, por lo que casi todas estas llamadas adicionales para precarga y almacenamiento eterno pod√≠an eliminarse por completo, ¬°y todav√≠a ten√≠a memoria libre!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deshacerse de cosas que no usamos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras trabaj√°bamos en la compilaci√≥n para PSVita, fuimos particularmente claros en que hay un mont√≥n de cosas que simplemente no necesitamos. Debido a la baja resoluci√≥n, el modo de gr√°ficos fuente y el modo de gr√°ficos HD eran indistinguibles, por lo que para todos los sprites utilizamos los gr√°ficos originales. Tambi√©n logramos mejorar la funci√≥n de reemplazar la paleta con la ayuda de un sombreador de p√≠xeles especial (anteriormente utilizamos la funci√≥n de representaci√≥n del programa). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro ejemplo fue el mapa de batalla en s√≠ mismo: en la PC y las consolas dom√©sticas, apilamos un mont√≥n de tarjetas de fichas una encima de la otra para crear un mapa de varias capas. Pero como el mapa nunca cambia, en Vita podr√≠amos hornear todo en una imagen terminada para que se llame en una llamada de sorteo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de los recursos adicionales, el juego ten√≠a muchas llamadas adicionales, por ejemplo, defensores y enemigos que enviaban una se√±al de regeneraci√≥n en cada cuadro, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluso cuando no ten√≠an la capacidad de regenerarse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si la IU estaba abierta para tal criatura, entonces se redibuj√≥ en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada cuadro</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay media docena de otros ejemplos de peque√±os algoritmos que calculan algo dentro de una funci√≥n "activa", pero nunca devuelven resultados en ning√∫n lado. </font><font style="vertical-align: inherit;">Por lo general, estos fueron los resultados de crear la estructura en las primeras etapas de desarrollo, por lo que simplemente los eliminamos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NaNopocalypse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este caso fue gracioso. </font><font style="vertical-align: inherit;">El generador de perfiles inform√≥ que lleva mucho tiempo calcular los √°ngulos. </font><font style="vertical-align: inherit;">Aqu√≠ est√° el c√≥digo Haxe C ++ generado en el generador de perfiles:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/387/7d5/4f43877d538fc9c44c34e5bfaa72bd45.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una de esas funciones que toman valores como </font></font><code>-90</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y los convierten </font></font><code>270</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A veces obtienes valores como </font></font><code>-724</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que en unos pocos ciclos se reducen a </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por alguna raz√≥n, se pas√≥ un valor a esta funci√≥n </font></font><code>-2147483648</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d8/6bc/9c8/7d86bc9c84d9e75a345b898ff44940a1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos los c√°lculos. Si en cada ciclo agregamos 360 a -2147483648, entonces tomar√° aproximadamente 5,965,233 iteraciones hasta que sea mayor que 0 y complete el ciclo. Por cierto, este ciclo se realiz√≥ con cada actualizaci√≥n (no en cada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuadro</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ¬°en cada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actualizaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !), Cada vez que el proyectil (u otra cosa) cambi√≥ su √°ngulo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, fue mi culpa, porque pas√© un valor </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un valor especial que significa "No es un n√∫mero" (no es un n√∫mero), que generalmente indica un error que ocurri√≥ anteriormente en el c√≥digo. Si lo lleva a un n√∫mero entero sin verificar primero, entonces suceden cosas tan extra√±as. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como soluci√≥n temporal, agregu√© un cheque</font></font><code>Math.isNan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que restablecen el √°ngulo cuando se produce un evento de este tipo (bastante raro, pero inevitable). </font><font style="vertical-align: inherit;">Al mismo tiempo, continu√© buscando la causa ra√≠z del error, lo encontr√© y el retraso desapareci√≥ de inmediato. </font><font style="vertical-align: inherit;">Resulta que si no realiza 6 millones de iteraciones sin sentido, ¬°entonces puede obtener un gran aumento de velocidad! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">insert√≥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una soluci√≥n para este error </font><font style="vertical-align: inherit;">en el propio HaxeFlixel).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No te burles de ti mismo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanto OpenFL como HaxeFlixel se basan en el almacenamiento en cach√© de recursos. </font><font style="vertical-align: inherit;">Esto significa que cuando cargamos un recurso, la pr√≥xima vez que se reciba este recurso, se tomar√° del cach√© y no se volver√° a cargar desde el disco. </font><font style="vertical-align: inherit;">Este comportamiento puede ser anulado y, a veces, tiene sentido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, me met√≠ en algunas cosas extra√±as extra√±as: descargu√© el recurso, le dije expl√≠citamente al sistema que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> almacenara </font><em><font style="vertical-align: inherit;">en</font></em><font style="vertical-align: inherit;"> cach√© los resultados, porque estaba completamente seguro de lo que estaba haciendo y no quer√≠a "desperdiciar memoria" en la memoria cach√©. </font><font style="vertical-align: inherit;">A√±os m√°s tarde, estas llamadas "inteligentes" me hicieron cargar el mismo recurso una y otra vez, ralentizando el juego y desperdiciando una memoria preciosa, que "guard√©" al abandonar el cach√©.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Adem√°s, puede que no valga la pena hacer niveles como Endless Battle 2 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√≠, es genial que hayamos implementado todos estos peque√±os trucos para aumentar la velocidad. Honestamente, no nos dimos cuenta de la mayor√≠a de ellos hasta que comenzamos a portar el juego a sistemas menos potentes, cuando en algunos niveles los problemas se volvieron completamente intolerables. Me alegro de que al final logramos aumentar la velocidad, pero creo que tambi√©n debe evitarse el dise√±o del nivel patol√≥gico. Endless Battle 2 puso demasiado estr√©s en el sistema, especialmente en comparaci√≥n con </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los dem√°s niveles del juego</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso despu√©s de todos estos cambios, la versi√≥n de PSVita todav√≠a no puede hacer frente al dise√±o original de Endless 2, y no quer√≠a arriesgar la velocidad en los modelos base XB1 y PS4, por lo que cambi√© el equilibrio para las versiones de consola de Endless 2. Reduje el n√∫mero de enemigos, pero aument√© sus caracter√≠sticas para que el nivel tenga aproximadamente la misma dificultad. Adem√°s, en PSVita limitamos el n√∫mero de ondas a cien para evitar el riesgo de falla de memoria, pero no agregamos restricciones en la PS4 y XB1. Gracias a esto, lograr el logro de resistencia sigue siendo igualmente dif√≠cil en todas las consolas. En la versi√≥n para PC, el dise√±o del nivel Endless Batlte 2 se mantuvo sin cambios.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo esto fue una lecci√≥n para nosotros, que tendremos en cuenta al crear Defender's Quest II: ¬°estaremos muy atentos a los niveles sin un l√≠mite superior en la cantidad de enemigos en la pantalla! </font><font style="vertical-align: inherit;">Por supuesto, las misiones "interminables" son muy atractivas para los fan√°ticos de Tower Defense, as√≠ que no las eliminar√© por completo, pero ¬øqu√© pasa con los niveles con puntos de control en los que el jugador DEBE destruir todo en la pantalla antes de pasar a las siguientes oleadas? </font><font style="vertical-align: inherit;">Esto no solo nos permitir√° limitar el n√∫mero de enemigos en la pantalla, sino que tambi√©n nos daremos cuenta de guardar en el medio del nivel sin preocuparnos por serializar el estado de la sopa loca de objetos en una batalla intensa: ser√° suficiente para nosotros simplemente guardar las coordenadas de los defensores, aumentar los niveles, etc.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Pensamientos en conclusi√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El rendimiento del juego es un tema complejo porque los jugadores a menudo no entienden lo que es, y no debemos esperar que lo comprendan. Pero espero que este art√≠culo te haya aclarado un poco c√≥mo se ve todo dentro, y hayas aprendido m√°s sobre c√≥mo el dise√±o, las compensaciones t√©cnicas y las decisiones simplemente est√∫pidas ralentizan los juegos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conclusi√≥n es que incluso en un juego con un buen dise√±o desarrollado por un equipo talentoso, estos peque√±os fragmentos de c√≥digo "oxidados" se pueden encontrar absolutamente en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todas partes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero en la pr√°ctica, solo una peque√±a fracci√≥n de ellos realmente afecta el rendimiento. La capacidad de detectarlos y eliminarlos es igualmente arte y ciencia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me alegro de que aprovecharemos todas estas ventajas en el desarrollo de Defender's Quest II. </font><font style="vertical-align: inherit;">Honestamente, si no hubi√©ramos hecho un puerto para PSVita, entonces probablemente ni siquiera habr√≠a probado la mitad de estas optimizaciones. </font><font style="vertical-align: inherit;">E incluso si no compras el juego para PSVita, puedes agradecer a esta peque√±a consola, que mejor√≥ significativamente la velocidad de Defender's Quest.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414135/">https://habr.com/ru/post/es414135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414125/index.html">C√≥mo probamos VMware vSAN ‚Ñ¢: por qu√© funciona en la pr√°ctica</a></li>
<li><a href="../es414127/index.html">Instale 3CX en un hosting por 2,99 euros / mes. en 10 minutos</a></li>
<li><a href="../es414129/index.html">M√°ster en Inform√°tica Te√≥rica en la Universidad Estatal de San Petersburgo</a></li>
<li><a href="../es414131/index.html">El efecto de la frecuencia de la se√±al en la energ√≠a de los enlaces de radio en el espacio libre</a></li>
<li><a href="../es414133/index.html">Dise√±o de juego de rompecabezas con el ejemplo de In The Shadows</a></li>
<li><a href="../es414137/index.html">Experiencia de desarrollo de SPA en VueJS + Nuxt</a></li>
<li><a href="../es414139/index.html">Lanzamiento del proxy MTProto no oficial en Python, caracter√≠sticas del protocolo</a></li>
<li><a href="../es414141/index.html">7 reglas para dise√±ar placas de circuito impreso</a></li>
<li><a href="../es414149/index.html">Las razones del mal sonido de la mayor√≠a de los tel√©fonos inteligentes Android</a></li>
<li><a href="../es414151/index.html">Fintech-digest: los bancos informar√°n da√±os por ataques de hackers, Western Union se niega a trabajar con criptomonedas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>