<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ ◀️ 👨🏿‍🤝‍👨🏾 Tests C sans SMS et inscription 🈷️ 🏖️ 👵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, zerocost a écrit un article intéressant, «Tests en C ++ sans macros et mémoire dynamique» , qui traite d'un cadre minimaliste pour tester l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests C sans SMS et inscription</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435028/"><p><img src="https://habrastorage.org/webt/lg/12/b3/lg12b3c-s5uuok0_nialgfngc9e.png" alt="Capture d'écran" align="right">  Récemment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">zerocost a</a> écrit un article intéressant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Tests en C ++ sans macros et mémoire dynamique»</a> , qui traite d'un cadre minimaliste pour tester le code C ++.  L'auteur a (presque) réussi à éviter l'utilisation de macros pour enregistrer les tests, mais à la place d'eux, des modèles «magiques» sont apparus dans le code, qui me semblent personnellement, désolé, inimaginablement laid.  Après avoir lu l'article, j'ai eu un vague sentiment d'insatisfaction, car je <em>savais</em> ce qui pouvait être mieux fait.  Je ne pouvais pas me souvenir immédiatement où, mais j'ai <em>certainement vu</em> le code de test, qui ne contient pas un seul caractère supplémentaire pour les enregistrer: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-string"><span class="hljs-string">"2 + 2 = ?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Enfin, je me suis souvenu que ce cadre s'appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Cutter</strong></a> et qu'il utilise une manière géniale pour identifier les fonctions de test à sa manière. </p><a name="habracut"></a><br><p>  (KDPV tiré du site Web de Cutter sous CC BY-SA.) </p><br><h2 id="v-chyom-zhe-tryuk">  Quel est le truc? </h2><br><p>  Le code de test est assemblé dans une bibliothèque partagée distincte.  Les fonctions de test sont extraites des symboles de bibliothèque exportés et identifiées par des noms.  Les tests sont effectués par un utilitaire externe spécial.  Sapienti était assis. </p><br><pre> <code class="cpp hljs">$ cat test_addition.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cutter.h&gt; void test_addition() { cut_assert_equal_int(2 + 2, 5); }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ cc -shared -o test_addition.so \ -I/usr/include/cutter -lcutter \ test_addition.c</code> </pre> <br><pre> <code class="plaintext hljs">$ cutter . F ========================================================================= Failure: test_addition &lt;2 + 2 == 5&gt; expected: &lt;4&gt; actual: &lt;5&gt; test_addition.c:5: void test_addition(): cut_assert_equal_int(2 + 2, 5, ) ========================================================================= Finished in 0.000943 seconds (total: 0.000615 seconds) 1 test(s), 0 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 omission(s), 0 notification(s) 0% passed</code> </pre> <br><p>  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple tiré de la documentation de Cutter</a> .  Vous pouvez parcourir en toute sécurité tout ce qui concerne les Autotools et ne regarder que le code.  Le cadre est un peu étrange, oui, comme tout le japonais. </p><br><p>  Je n'entrerai pas dans trop de détails sur les fonctionnalités d'implémentation.  Je n'ai pas non plus de code à part entière (et même au moins brouillon), car personnellement je n'en ai pas vraiment besoin (dans Rust, tout est sorti de la boîte).  Cependant, pour les personnes intéressées, cela peut être un bon exercice. </p><br><h2 id="detali-i-vozmozhnosti-realizacii">  Détails et options de mise en œuvre </h2><br><p>  Considérez certaines des tâches que vous devez résoudre lors de l'écriture d'un cadre de test à l'aide de l'approche Cutter. </p><br><h3 id="poluchenie-eksportiruemyh-funkciy">  Obtention des fonctions exportées </h3><br><p>  Tout d'abord, vous devez accéder aux fonctions de test d'une manière ou d'une autre.  Bien entendu, la norme C ++ ne décrit pas du tout les bibliothèques partagées.  Windows a récemment acquis un sous-système Linux, qui permet de réduire les trois principaux systèmes d'exploitation à POSIX.  Comme vous le savez, les systèmes POSIX fournissent les fonctions <code>dlopen()</code> , <code>dlsym()</code> , <code>dlclose()</code> , avec lesquelles vous pouvez obtenir l'adresse de la fonction, connaître le nom de son symbole, et ... c'est tout.  La liste des fonctions contenues dans la bibliothèque chargée n'est pas divulguée par POSIX. </p><br><p>  Malheureusement (quoique plutôt heureusement), il n'existe pas de moyen standard et portable pour découvrir toutes les fonctions exportées depuis la bibliothèque.  Peut-être, le fait que le concept de <em>bibliothèque</em> n'existe pas sur toutes les plateformes (lire: embarqué) est en quelque sorte impliqué ici.  Mais ce n'est pas l'essentiel.  L'essentiel est que vous devez utiliser des fonctionnalités spécifiques <em>à la</em> plate-forme. </p><br><p>  En première approximation, vous pouvez simplement appeler l'utilitaire <strong>nm</strong> : </p><br><pre> <code class="cpp hljs">$ cat test.<span class="hljs-function"><span class="hljs-function">cpp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><pre> <code class="plaintext hljs">$ clang -shared test.cpp</code> </pre> <br><pre> <code class="plaintext hljs">$ nm -gj ./a.out __Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  analyser sa sortie et utiliser <code>dlsym()</code> . </p><br><p>  Pour une introspection plus approfondie, des bibliothèques comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libelf</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libMachO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pe-parse sont</a> utiles, vous permettant d'analyser par programme des fichiers exécutables et des bibliothèques de plateformes qui vous intéressent.  En fait, <strong>nm</strong> et l'entreprise les utilisent. </p><br><h3 id="filtraciya-testovyh-funkciy">  Filtrage des fonctions de test </h3><br><p>  Comme vous l'avez peut-être remarqué, les bibliothèques contiennent des caractères étranges: </p><br><pre> <code class="plaintext hljs">__Z20test_object_additionv dyld_stub_binder</code> </pre> <br><p>  C'est ce qu'est <code>__Z20test_object_additionv</code> , lorsque nous avons appelé la fonction simplement <code>test_object_addition</code> ?  Et quel est ce <code>dyld_stub_binder</code> gauche? </p><br><p>  Les caractères " <code>__Z20...</code> " <code>__Z20...</code> sont la soi-disant <em>décoration de</em> nom (dénomination du nom).  Fonction de compilation C ++, rien ne peut être fait, vivre avec.  C'est ce que les fonctions sont appelées du point de vue du système (et <code>dlsym()</code> ).  Afin de les montrer à une personne dans leur forme normale, vous pouvez utiliser des bibliothèques comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libdemangle</a> .  Bien sûr, la bibliothèque dont vous avez besoin dépend du compilateur que vous utilisez, mais le format de décoration est généralement le même dans le cadre de la plateforme. </p><br><p>  Quant aux fonctions étranges comme <code>dyld_stub_binder</code> , ce sont aussi des fonctionnalités de plateforme qui devront être prises en compte.  Vous n'avez pas besoin d'appeler de fonctions lors du démarrage des tests, car il n'y a pas de poisson là-bas. </p><br><p>  Une suite logique de cette idée est de filtrer la fonction par nom.  Par exemple, vous ne pouvez exécuter que des fonctions avec <code>test</code> dans le nom.  Ou simplement des fonctions de l'espace de noms de <code>tests</code> .  Et utilisez également des espaces de noms imbriqués pour regrouper les tests.  Il n'y a pas de limite à votre imagination. </p><br><h3 id="peredacha-konteksta-ispolnyaemogo-testa">  Passer le contexte d'un test exécutable </h3><br><p>  Les fichiers objets avec des tests sont collectés dans une bibliothèque partagée, dont l'exécution du code est entièrement contrôlée par un utilitaire-driver externe - <code>cutter</code> pour Cutter.  Par conséquent, les fonctions de test internes peuvent l'utiliser. </p><br><p>  Par exemple, le contexte d'un test exécutable ( <code>IRuntime</code> dans l'article d'origine) peut être transmis en toute sécurité via une variable globale (thread-local).  Le conducteur est responsable de la gestion et du passage du contexte. </p><br><p>  Dans ce cas, les fonctions de test ne nécessitent pas d'arguments, mais conservent toutes les fonctionnalités avancées, telles que la dénomination arbitraire des cas testés: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_vector_add_element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testing::description(<span class="hljs-string"><span class="hljs-string">"vector size grows after push_back()"</span></span>); }</code> </pre> <br><p>  La fonction <code>description()</code> accède à l' <code>IRuntime</code> conditionnel via une variable globale et peut ainsi transmettre un commentaire au framework pour une personne.  La sécurité d'utilisation du contexte global est garantie par le framework et n'est pas de la responsabilité du rédacteur de test. </p><br><p>  Avec cette approche, il y aura moins de bruit dans le code avec le transfert de contexte aux déclarations de comparaison et aux fonctions de test internes qui peuvent devoir être appelées depuis la principale. </p><br><h3 id="konstruktory-i-destruktory">  Constructeurs et destructeurs </h3><br><p>  Étant donné que l'exécution des tests est entièrement contrôlée par le pilote, il peut exécuter du code supplémentaire <em>autour des</em> tests. </p><br><p>  La bibliothèque Cutter utilise pour cela les fonctions suivantes: </p><br><ul><li>  <code>cut_setup()</code> - avant chaque test individuel </li><li>  <code>cut_teardown()</code> - après chaque test individuel </li><li>  <code>cut_startup()</code> - avant d'exécuter tous les tests </li><li>  <code>cut_shutdown()</code> - après la fin de tous les tests </li></ul><br><p>  Ces fonctions sont appelées uniquement si elles sont définies dans le fichier de test.  Vous pouvez y mettre la préparation et le nettoyage de l'environnement de test (fixture): la création des fichiers temporaires nécessaires, la configuration difficile des objets testés, et d'autres antipatterns de test. </p><br><p>  Pour C ++, il est possible de proposer une interface plus idiomatique: </p><br><ul><li>  plus orienté objet et type sûr </li><li>  avec une meilleure prise en charge du concept RAII </li><li>  utilisation de lambdas pour une exécution différée </li><li>  impliquant un contexte d'exécution de test </li></ul><br><p>  Mais pour l'instant, j'y repense en détail maintenant. </p><br><h3 id="samodostatochnye-ispolnimye-fayly-s-testami">  Exécutables de test autonomes </h3><br><p>  Cutter utilise une approche de bibliothèque partagée pour plus de commodité.  Divers tests sont compilés dans un ensemble de bibliothèques qu'un utilitaire de test séparé trouve et exécute.  Naturellement, si vous le souhaitez, le code entier du pilote de test peut être intégré directement dans le fichier exécutable, en obtenant les fichiers séparés habituels.  Cependant, cela nécessitera une collaboration avec le système de construction pour organiser la mise en page de ces fichiers exécutables de la bonne manière: sans supprimer les fonctions «inutilisées», avec les bonnes dépendances, etc. </p><br><h3 id="prochee">  Autre </h3><br><p>  Cutter et d'autres frameworks ont également beaucoup d'autres choses utiles qui peuvent vous faciliter la vie lors de l'écriture de tests: </p><br><ul><li>  instructions de test flexibles et <em>extensibles</em> </li><li>  création et obtention de données de test à partir de fichiers </li><li>  études de trace de pile, gestion des exceptions et des drop </li><li>  «niveaux de ventilation» personnalisables des tests </li><li>  exécution de tests dans plusieurs processus </li></ul><br><p>  Il vaut la peine de revenir sur les cadres existants lors de l'écriture de votre vélo.  UX est un sujet beaucoup plus profond. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  L'approche utilisée par le framework Cutter permet d'identifier des fonctions de test avec une charge cognitive minimale sur le programmeur: il suffit d'écrire des fonctions de test et c'est tout.  Le code ne nécessite pas l'utilisation de modèles ou de macros spéciaux, ce qui augmente sa lisibilité. </p><br><p>  Les fonctionnalités d'assemblage et d'exécution de tests peuvent être cachées dans des modules réutilisables pour des systèmes d'assemblage tels que Makefile, CMake, etc. Des questions sur un assemblage séparé de tests devront toujours être posées d'une manière ou d'une autre. </p><br><p>  Les inconvénients de cette approche incluent la difficulté de placer des tests dans le même fichier (la même unité de traduction) que le code principal.  Malheureusement, dans ce cas, sans conseils supplémentaires, il n'est plus possible de déterminer quelles fonctions doivent être lancées et lesquelles ne le sont pas.  Heureusement, en C ++, il est généralement habituel de distribuer les tests et l'implémentation dans différents fichiers. </p><br><p>  Quant à l'élimination définitive des macros, il me semble qu'en <em>principe</em> elles ne doivent pas être abandonnées.  Les macros permettent, par exemple, d'écrire des instructions de comparaison plus courtes, en évitant la duplication de code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_object_addition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ensure_equals(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br><p>  mais en gardant en même temps le même contenu informationnel du problème en cas d'erreur: </p><br><pre> <code class="plaintext hljs">Failure: test_object_addition &lt;ensure_equals(2 + 2, 5)&gt; expected: &lt;5&gt; actual: &lt;4&gt; test.c:5: test_object_addition()</code> </pre> <br><p>  Le nom de la fonction testée, le nom du fichier et le numéro de ligne du début de la fonction peuvent en théorie être extraits des informations de débogage contenues dans la bibliothèque collectée.  La valeur attendue et réelle des expressions comparées est connue de la fonction <code>ensure_equals()</code> .  La macro vous permet de "restaurer" l'orthographe d'origine de l'instruction de test, à partir de laquelle il est plus clair pourquoi la valeur <code>4</code> est attendue. </p><br><p>  Cependant, ce n'est pas pour tout le monde.  L'avantage des macros pour le code de test s'arrête-t-il là?  Je n'ai pas encore vraiment pensé à ce moment, ce qui peut s'avérer être un bon terrain pour <del>  perversions </del>  recherche.  Une question beaucoup plus intéressante: est-il possible de faire en quelque sorte un <em>cadre simulé</em> pour C ++ sans macros? </p><br><p>  Le lecteur attentif a également noté qu'il n'y a vraiment pas de SMS et d'amiante dans la mise en œuvre, ce qui est incontestablement un plus pour l'écologie et l'économie de la Terre. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435028/">https://habr.com/ru/post/fr435028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435014/index.html">Dart vs Node.js: comparaison des performances sur les implémentations de serveur HTTP</a></li>
<li><a href="../fr435016/index.html">Ce que Larry Ellison apportera à Tesla</a></li>
<li><a href="../fr435018/index.html">En 2018, nous avons enfin commencé à prendre au sérieux le temps passé sur le smartphone</a></li>
<li><a href="../fr435020/index.html">Temple de la renommée de l'électronique grand public: les histoires des meilleurs gadgets des 50 dernières années, partie 2</a></li>
<li><a href="../fr435026/index.html">Nous fabriquons un messager * qui fonctionne même dans l'ascenseur</a></li>
<li><a href="../fr435032/index.html">Le vaisseau spatial Chang'e-4 a fait un atterrissage réussi de l'autre côté de la lune et a envoyé la première photo</a></li>
<li><a href="../fr435036/index.html">Réflexions sur le C ++ moderne et le développement de jeux</a></li>
<li><a href="../fr435038/index.html">L'énergie nucléaire mondiale en 2018</a></li>
<li><a href="../fr435040/index.html">Bitcoin il y a 10 ans</a></li>
<li><a href="../fr435044/index.html">Antiquités: le minidisque dans son habitat naturel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>