<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🍳 📥 ♾ Un peu sur l'analyse lexicale 🐴 🤧 🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il était une fois, quand le ciel était bleu, l'herbe était plus verte et les dinosaures parcouraient la Terre ... Non, oubliez les dinosaures. Eh bien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un peu sur l'analyse lexicale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Il était une fois, quand le ciel était bleu, l'herbe était plus verte et les dinosaures parcouraient la Terre ... Non, oubliez les dinosaures.  Eh bien, en général, il était une fois l'idée de distraire de la programmation Web standard et de faire quelque chose de plus fou.  Cela pourrait bien sûr être n'importe quoi, mais le choix s'est porté sur l'écriture de votre propre interprète.  Que puis-je dire ... <i>N'écrivez jamais vos propres langages de programmation</i> .  Mais j'ai pris de l'expérience de tout cela, alors j'ai décidé de la partager.  Commençons par le fondement même - le lexer. <br><a name="habracut"></a><br><h2>  Préface </h2><br>  Avant de commencer à comprendre de quel type de «lexer» l’animal, il vaut la peine de déterminer de quoi sont faits les YaP. <br><br>  Dans le monde moderne, chaque compilateur / interprète / transpilateur / quelque chose d'autre (comme je l'appellerai simplement «compilateur», sans distinction de types) est divisé en deux parties.  Dans la terminologie des oncles intelligents, ces éléments sont appelés «frontend» et «backend».  Non, ce n'est pas du tout ce que, quand on travaille avec le web, ce qu'on a l'habitude d'appeler et le front n'est pas écrit en JS avec HTML.  Bien que ... D'accord. <br><br>  La première tâche du frontend est de prendre le <b>texte</b> et de le transformer en <b>AST</b> (arbre de syntaxe abstraite), en vérifiant la syntaxe (et parfois la sémantique) en cours de route.  La tâche du second backend est de tout faire fonctionner.  Si le code est assemblé à l'intérieur de l'interpréteur, l'AST crée un ensemble d'instructions pour le processeur virtuel (machine virtuelle), si le compilateur, puis l'ensemble d'instructions pour le processeur réel.  Dans la vie, tout est beaucoup plus compliqué et peut ne pas être implémenté comme ça.  Par exemple, dans le cas du compilateur GCC, tout est mélangé, mais Clang est déjà plus canonique, LLVM est un représentant typique du «backend» pour les compilateurs. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Maintenant, apprenons à connaître un morceau appelé le frontend. <br><br><h2>  Analyse lexicale </h2><br>  La tâche du lexer et du stade de l'analyse lexicale est d'obtenir de très nombreuses lettres à l'entrée et de les regrouper en certaines catégories - les «jetons».  Par conséquent, l'analyse lexicale est également appelée «tokenisation».  Il s'agit de la toute première étape du traitement de texte produite par chaque compilateur existant. <br><br>  Quelque chose comme ça: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  Au fait, nous avons déjà écrit ici un tas d'outils pour vous faciliter la vie.  Les mêmes fonctions <i>preg</i> que nous avons utilisées pour analyser le texte sont tout à fait <i>capables de</i> cette tâche.  Cependant, il existe des outils plus pratiques à cet effet: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phlexy</a> , écrit par Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoa</a> est une boîte à outils composée de Lexer + Parser + Grammar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Port Yacc</a> , écrit par Anthony Ferrara, qui est également une boîte à outils complète, et sur lequel l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur PHP</a> Popov bien connu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> écrit, applicable dans les outils qui utilisent l'analyse de code. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Railt Lexer</a> mon implémentation pour PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parle</a> est une extension pour PHP qui autorise un ensemble limité d'expressions PCRE (pas d'anticipation et d'autres constructions de syntaxe). </li><li>  Et enfin, la fonction php standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">token_get_all</a> , qui est destinée directement à l'analyse lexicale de PHP. </li></ul><br>  Eh bien, il est clair qu'il y a beaucoup de gadgets qui peuvent diviser le texte en jetons, peut-être que j'ai même oublié quelque chose, comme le lexer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Doctrine</a> .  Mais quelle est la prochaine étape? <br><br><h2>  Types de Lexers </h2><br>  Et comme toujours, tout n'est pas aussi simple qu'il y paraissait.  Il existe au moins deux catégories différentes de lexers.  Il y a l'option habituelle, assez triviale, à laquelle vous glissez les règles, et elle divise déjà tout en jetons.  La configuration de celui-ci n'est pas très différente de l'exemple montré par moi ci-dessus.  Cependant, il existe une autre option appelée <b>multi-états</b> .  Ces lexers sont un peu plus difficiles à comprendre, donc je veux en parler un peu plus. <br><br>  La tâche d'un lexer multi-états est d'afficher différents jetons en fonction de l'état précédent.  Eh bien, par exemple, en PHP, de tels états "transitionnels" sont formés à l'aide des balises &lt;? Php +?&gt;, Des lignes internes, des commentaires et des constructions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NOWDOC</a> . <br><br>  Vous vous souvenez de l'exemple précédent avec 4 jetons ci-dessus?  Modifions-le un peu pour comprendre quels sont ces états: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  Dans ce cas, si nous avons le lexer le plus simple sans les capacités étendues de PCRE, alors nous obtenons l'ensemble de jetons suivant: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Comme vous pouvez le voir, nous avons obtenu un montant complètement banal sur les éléments 3 à 5: le commentaire a été pris de manière assez inattendue et a été divisé en jetons, bien qu'il aurait dû être considéré comme une pièce entière. <br><br>  Bien sûr, avec la fonctionnalité PCRE, un tel jeton pourrait être arraché à l'aide d'une simple régularité " <i>// [^ \ n] * \ n</i> ", mais si ce n'est pas le cas?  Ou voulons-nous l'entailler avec nos mains?  En bref, dans le cas d'un lexer multi-états - nous pouvons dire que tous les jetons doivent être dans le groupe n ° <b>1</b> , dès que le jeton " <i>//</i> " est trouvé, alors une transition vers le groupe n ° 2 doit se produire.  Et à l'intérieur du deuxième groupe, la transition inverse, si le jeton " <i>\ n</i> " est trouvé - la transition vers le premier groupe. <br><br>  Quelque chose comme ça: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Je pense que maintenant il devient plus clair comment certains HEREDOC sont analysés, car même avec toute la puissance de PCRE, écrire un régulier pour ce cas est extrêmement problématique, étant donné que cette syntaxe HEREDOC prend en charge l'interpolation variable.  Essayez simplement d'analyser quelque chose comme ça avec la fonction <i>intégrée token_get_all</i> (note&gt; 12 jetons): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Eh bien, il semble que nous soyons prêts à commencer à pratiquer. <br><br><h2>  Pratique </h2><br>  Rappelons-nous ce que nous avons en PHP pour de telles choses?  Eh bien, bien sûr, preg_match!  D'accord, descends.  L'algorithme basé sur preg_match est implémenté dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoa</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cette implémentation de Phelxy</a> .  Sa tâche est assez simple: <br><br><ol><li>  Nous avons en main le texte source et un tableau de réguliers. </li><li>  Nous correspondons jusqu'à ce que quelque chose de approprié soit trouvé. </li><li>  Dès que vous trouvez une pièce, coupez-la du texte et faites-la correspondre davantage. </li></ol><br>  Sous forme de code, cela ressemblera à ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Feuille de code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Utilisation d'une feuille de code</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Cette approche est assez banale et permet à quelques pressions sur le clavier de modifier le lexer dans la région de la méthode next (), en ajoutant une transition entre les états et en transformant cette division de la masturbation en un lexer primitif à plusieurs états.  Dans la zone <i>$ this-&gt; tokens,</i> ajoutez simplement quelque chose comme <i>$ this-&gt; tokens [$ this-&gt; state]</i> . <br><br>  Cependant, en plus du primitivisme lui-même, il y a un autre inconvénient, pas fatal comme cela pourrait se révéler, mais quand même ... Une telle implémentation est incroyablement lente.  Sur i7 7600k, le propriétaire dont je me trouvais par hasard - un algorithme similaire traite environ 400 jetons par seconde, et avec une augmentation de leurs variations (c'est-à-dire les définitions que nous avons transmises au constructeur) - il peut ralentir à la vitesse du changement de président en Russie ... ahem désolé.  Je voulais dire, bien sûr, que cela fonctionnera <b>très lentement</b> . <br><br>  D'accord, que pouvons-nous faire?  Pour commencer, vous pouvez comprendre ce qui ne va pas.  Le fait est que chaque fois que nous appelons <b>preg_match</b> à l'intérieur du <b>joker</b> du langage, un compilateur avec son JIT appelé PCRE se lève (Et avec PHP 7.3, PCRE2 l'est déjà).  Chaque fois, il analyse les habitués eux-mêmes et recueille un analyseur pour eux, avec lequel nous analysons le texte pour créer des jetons.  Cela semble un peu étrange et tautologique.  Mais en bref, chaque jeton nécessite une compilation de 1 à N réguliers, où N est le nombre de définitions de ces jetons.  Dans le même temps, il convient de noter que même l'indicateur " <i>S</i> " appliqué et l'optimisation utilisant " <i>\ G</i> " dans le constructeur, où des expressions régulières pour les jetons sont générées, n'aident pas. <br><br>  Il n'y a qu'un seul moyen de sortir de cette situation - vous devez analyser tout ce texte en un seul passage, c'est-à-dire  en exécutant une <b>seule</b> fonction <b>preg_match</b> .  Il reste à résoudre deux problèmes: <br><br><ol><li>  Comment indiquer que le résultat de l'expression régulière N1 correspond au jeton N2?  C'est-à-dire  comment indiquer que " <i>\ w +</i> ", par exemple, est <i>T_CONST</i> . </li><li>  Comment déterminer la séquence de jetons en conséquence.  Comme vous le savez, le résultat de <b>preg_match</b> ou <b>preg_match_all</b> contiendra tout mélangé.  Et même avec l'aide de drapeaux passés comme quatrième argument, la situation ne changera pas. </li></ol><br>  Ici, vous pouvez faire une pause et réfléchir un peu.  Eh bien ou pas. <br><br>  La solution au premier problème <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s'appelle les groupes PCRE</a> , également appelés «sous-masques».  En utilisant les règles: " <i>(?? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> ", vous pouvez obtenir tous les jetons en un seul passage en les comparant avec leurs noms.  À la suite de la correspondance, un tableau associatif sera formé, composé des paires " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> ". <br><br>  Le second est un peu plus compliqué.  Mais ici, vous pouvez appliquer une astuce tactique et utiliser la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preg_replace_callback</a> .  Sa particularité est que l'anonym passé comme deuxième argument sera appelé strictement séquentiellement pour chaque jeton, du premier au dernier. <br><br>  Afin de ne pas languir - la mise en œuvre est la suivante: <br><br><div class="spoiler">  <b class="spoiler_title">Un autre volet de code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  Et son utilisation n'est pas différente de la version précédente.  Dans le même temps, la vitesse de travail passe de <b>400</b> à <b>57 000</b> jetons par seconde.  C'est cet algorithme que j'ai appliqué <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans mon implémentation</a> , reprenant la réécriture du code source Hoa.  Soit dit en passant, si vous utilisez Parle, vous pouvez compresser jusqu'à <b>600 000</b> jetons par seconde.  Et l'image globale ressemble à ceci (avec XDebug activé en PHP 7.1, donc les chiffres sont inférieurs, mais le ratio peut être grossièrement représenté). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Le jaune est l'extension native de Parle. </li><li>  Bleu - implémentation via <i>preg_replace_callback</i> avec un pré-assemblé régulier. </li><li>  Rouge - tout de même, mais avec la <i>régularité</i> générée lors de l'appel à <i>preg_replace_callback</i> . </li><li>  Vert - implémentation via <i>preg_match</i> . </li></ul><br><h2>  Pourquoi? </h2><br>  Eh bien, tout cela, bien sûr, est merveilleux, mais les impatients sont impatients de poser la question: "Qui en a besoin?"  Dans le monde abstrait de PHP, où le principe de "fig-fig-and-site-ready" domine - de telles bibliothèques ne sont pas nécessaires, nous serons honnêtes.  Mais si nous parlons de l'écosystème dans son ensemble, nous pouvons rappeler les bibliothèques notoires comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">symfony / yaml</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Doctrine</a> .  Les annotations dans Symfony sont le même sous-langage dans PHP, nécessitant une analyse lexicale et syntaxique distincte.  De plus, il existe des transpilateurs CoffeeScript, Less et Scss / Sass encore moins connus, écrits en PHP.  Eh bien, ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yay</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prétraitez en</a> fonction de cela.  Je ne mentionnerai même pas les outils d'analyse de code comme phpmd ou phpcs.  Et les générateurs de documentation comme phpDocumentnor ou Sami sont assez triviaux.  Chacun de ces projets à un degré ou un autre utilise l'analyse lexicale à la première étape de l'analyse du texte / code. <br><br>  Ce n'est pas une liste complète de projets et j'espère peut-être que mon histoire vous aidera à découvrir quelque chose de nouveau et à le reconstituer. <br><br><h2>  Postface </h2><br>  À l'avenir, s'il y a quelqu'un qui s'intéresse au sujet des analyseurs et des compilateurs, alors il y a quelques rapports intéressants sur ce sujet, en particulier des gars de JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Vidéo</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Pourtant, bien sûr, la plupart des performances d'Andrei Breslav ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">abreslav</a> ), qui peuvent être trouvées sur l'immensité de YouTube - je vous conseille de regarder. <br><br>  Eh bien, pour les fans de fiction, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il existe une telle ressource</a> qui m'a personnellement été extrêmement utile. <br><br>  Post post scriptum.  Si vous êtes quelque part enfermé dans l'immensité de cette épopée, vous pouvez en informer l'auteur en toute sécurité sous n'importe quelle forme qui vous convient. <br><br>  En prime, je voudrais donner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple d'un simple lexeur PHP</a> , il semble que ce n'est pas si effrayant maintenant, et maintenant c'est même clair ce qu'il fait, non?  Bien que je trompe, les yeux saignent des habitués.  =) <br><br>  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435102/">https://habr.com/ru/post/fr435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435086/index.html">Que devrions-nous construire notre carte de montage PCI-E</a></li>
<li><a href="../fr435088/index.html">Le géant chinois du streaming Tencent Music entre en bourse - qu'est-ce que cela signifie et à quoi les concurrents devraient-ils s'attendre</a></li>
<li><a href="../fr435094/index.html">Manette de jeu de Sega Mega Drive et Raspberry Pi Partie 2 (six derniers boutons)</a></li>
<li><a href="../fr435096/index.html">L'effet de la radio à tube chaud</a></li>
<li><a href="../fr435098/index.html">ADB vs Spy Cam & Mic</a></li>
<li><a href="../fr435106/index.html">Encore une fois à propos de passport.js</a></li>
<li><a href="../fr435108/index.html">Utilisation de Prolog</a></li>
<li><a href="../fr435112/index.html">Entretien d'entreprise</a></li>
<li><a href="../fr435114/index.html">Spring data jpa</a></li>
<li><a href="../fr435118/index.html">Save File Me - un service de sauvegarde gratuit avec chiffrement côté client</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>