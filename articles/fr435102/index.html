<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüç≥ üì• ‚ôæ Un peu sur l'analyse lexicale üê¥ ü§ß üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il √©tait une fois, quand le ciel √©tait bleu, l'herbe √©tait plus verte et les dinosaures parcouraient la Terre ... Non, oubliez les dinosaures. Eh bien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un peu sur l'analyse lexicale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Il √©tait une fois, quand le ciel √©tait bleu, l'herbe √©tait plus verte et les dinosaures parcouraient la Terre ... Non, oubliez les dinosaures.  Eh bien, en g√©n√©ral, il √©tait une fois l'id√©e de distraire de la programmation Web standard et de faire quelque chose de plus fou.  Cela pourrait bien s√ªr √™tre n'importe quoi, mais le choix s'est port√© sur l'√©criture de votre propre interpr√®te.  Que puis-je dire ... <i>N'√©crivez jamais vos propres langages de programmation</i> .  Mais j'ai pris de l'exp√©rience de tout cela, alors j'ai d√©cid√© de la partager.  Commen√ßons par le fondement m√™me - le lexer. <br><a name="habracut"></a><br><h2>  Pr√©face </h2><br>  Avant de commencer √† comprendre de quel type de ¬´lexer¬ª l‚Äôanimal, il vaut la peine de d√©terminer de quoi sont faits les YaP. <br><br>  Dans le monde moderne, chaque compilateur / interpr√®te / transpilateur / quelque chose d'autre (comme je l'appellerai simplement ¬´compilateur¬ª, sans distinction de types) est divis√© en deux parties.  Dans la terminologie des oncles intelligents, ces √©l√©ments sont appel√©s ¬´frontend¬ª et ¬´backend¬ª.  Non, ce n'est pas du tout ce que, quand on travaille avec le web, ce qu'on a l'habitude d'appeler et le front n'est pas √©crit en JS avec HTML.  Bien que ... D'accord. <br><br>  La premi√®re t√¢che du frontend est de prendre le <b>texte</b> et de le transformer en <b>AST</b> (arbre de syntaxe abstraite), en v√©rifiant la syntaxe (et parfois la s√©mantique) en cours de route.  La t√¢che du second backend est de tout faire fonctionner.  Si le code est assembl√© √† l'int√©rieur de l'interpr√©teur, l'AST cr√©e un ensemble d'instructions pour le processeur virtuel (machine virtuelle), si le compilateur, puis l'ensemble d'instructions pour le processeur r√©el.  Dans la vie, tout est beaucoup plus compliqu√© et peut ne pas √™tre impl√©ment√© comme √ßa.  Par exemple, dans le cas du compilateur GCC, tout est m√©lang√©, mais Clang est d√©j√† plus canonique, LLVM est un repr√©sentant typique du ¬´backend¬ª pour les compilateurs. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Maintenant, apprenons √† conna√Ætre un morceau appel√© le frontend. <br><br><h2>  Analyse lexicale </h2><br>  La t√¢che du lexer et du stade de l'analyse lexicale est d'obtenir de tr√®s nombreuses lettres √† l'entr√©e et de les regrouper en certaines cat√©gories - les ¬´jetons¬ª.  Par cons√©quent, l'analyse lexicale est √©galement appel√©e ¬´tokenisation¬ª.  Il s'agit de la toute premi√®re √©tape du traitement de texte produite par chaque compilateur existant. <br><br>  Quelque chose comme √ßa: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  Au fait, nous avons d√©j√† √©crit ici un tas d'outils pour vous faciliter la vie.  Les m√™mes fonctions <i>preg</i> que nous avons utilis√©es pour analyser le texte sont tout √† fait <i>capables de</i> cette t√¢che.  Cependant, il existe des outils plus pratiques √† cet effet: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phlexy</a> , √©crit par Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoa</a> est une bo√Æte √† outils compos√©e de Lexer + Parser + Grammar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Port Yacc</a> , √©crit par Anthony Ferrara, qui est √©galement une bo√Æte √† outils compl√®te, et sur lequel l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur PHP</a> Popov bien connu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> √©crit, applicable dans les outils qui utilisent l'analyse de code. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Railt Lexer</a> mon impl√©mentation pour PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parle</a> est une extension pour PHP qui autorise un ensemble limit√© d'expressions PCRE (pas d'anticipation et d'autres constructions de syntaxe). </li><li>  Et enfin, la fonction php standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">token_get_all</a> , qui est destin√©e directement √† l'analyse lexicale de PHP. </li></ul><br>  Eh bien, il est clair qu'il y a beaucoup de gadgets qui peuvent diviser le texte en jetons, peut-√™tre que j'ai m√™me oubli√© quelque chose, comme le lexer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Doctrine</a> .  Mais quelle est la prochaine √©tape? <br><br><h2>  Types de Lexers </h2><br>  Et comme toujours, tout n'est pas aussi simple qu'il y paraissait.  Il existe au moins deux cat√©gories diff√©rentes de lexers.  Il y a l'option habituelle, assez triviale, √† laquelle vous glissez les r√®gles, et elle divise d√©j√† tout en jetons.  La configuration de celui-ci n'est pas tr√®s diff√©rente de l'exemple montr√© par moi ci-dessus.  Cependant, il existe une autre option appel√©e <b>multi-√©tats</b> .  Ces lexers sont un peu plus difficiles √† comprendre, donc je veux en parler un peu plus. <br><br>  La t√¢che d'un lexer multi-√©tats est d'afficher diff√©rents jetons en fonction de l'√©tat pr√©c√©dent.  Eh bien, par exemple, en PHP, de tels √©tats "transitionnels" sont form√©s √† l'aide des balises &lt;? Php +?&gt;, Des lignes internes, des commentaires et des constructions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NOWDOC</a> . <br><br>  Vous vous souvenez de l'exemple pr√©c√©dent avec 4 jetons ci-dessus?  Modifions-le un peu pour comprendre quels sont ces √©tats: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  Dans ce cas, si nous avons le lexer le plus simple sans les capacit√©s √©tendues de PCRE, alors nous obtenons l'ensemble de jetons suivant: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Comme vous pouvez le voir, nous avons obtenu un montant compl√®tement banal sur les √©l√©ments 3 √† 5: le commentaire a √©t√© pris de mani√®re assez inattendue et a √©t√© divis√© en jetons, bien qu'il aurait d√ª √™tre consid√©r√© comme une pi√®ce enti√®re. <br><br>  Bien s√ªr, avec la fonctionnalit√© PCRE, un tel jeton pourrait √™tre arrach√© √† l'aide d'une simple r√©gularit√© " <i>// [^ \ n] * \ n</i> ", mais si ce n'est pas le cas?  Ou voulons-nous l'entailler avec nos mains?  En bref, dans le cas d'un lexer multi-√©tats - nous pouvons dire que tous les jetons doivent √™tre dans le groupe n ¬∞ <b>1</b> , d√®s que le jeton " <i>//</i> " est trouv√©, alors une transition vers le groupe n ¬∞ 2 doit se produire.  Et √† l'int√©rieur du deuxi√®me groupe, la transition inverse, si le jeton " <i>\ n</i> " est trouv√© - la transition vers le premier groupe. <br><br>  Quelque chose comme √ßa: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Je pense que maintenant il devient plus clair comment certains HEREDOC sont analys√©s, car m√™me avec toute la puissance de PCRE, √©crire un r√©gulier pour ce cas est extr√™mement probl√©matique, √©tant donn√© que cette syntaxe HEREDOC prend en charge l'interpolation variable.  Essayez simplement d'analyser quelque chose comme √ßa avec la fonction <i>int√©gr√©e token_get_all</i> (note&gt; 12 jetons): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Eh bien, il semble que nous soyons pr√™ts √† commencer √† pratiquer. <br><br><h2>  Pratique </h2><br>  Rappelons-nous ce que nous avons en PHP pour de telles choses?  Eh bien, bien s√ªr, preg_match!  D'accord, descends.  L'algorithme bas√© sur preg_match est impl√©ment√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hoa</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cette impl√©mentation de Phelxy</a> .  Sa t√¢che est assez simple: <br><br><ol><li>  Nous avons en main le texte source et un tableau de r√©guliers. </li><li>  Nous correspondons jusqu'√† ce que quelque chose de appropri√© soit trouv√©. </li><li>  D√®s que vous trouvez une pi√®ce, coupez-la du texte et faites-la correspondre davantage. </li></ol><br>  Sous forme de code, cela ressemblera √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Feuille de code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Utilisation d'une feuille de code</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Cette approche est assez banale et permet √† quelques pressions sur le clavier de modifier le lexer dans la r√©gion de la m√©thode next (), en ajoutant une transition entre les √©tats et en transformant cette division de la masturbation en un lexer primitif √† plusieurs √©tats.  Dans la zone <i>$ this-&gt; tokens,</i> ajoutez simplement quelque chose comme <i>$ this-&gt; tokens [$ this-&gt; state]</i> . <br><br>  Cependant, en plus du primitivisme lui-m√™me, il y a un autre inconv√©nient, pas fatal comme cela pourrait se r√©v√©ler, mais quand m√™me ... Une telle impl√©mentation est incroyablement lente.  Sur i7 7600k, le propri√©taire dont je me trouvais par hasard - un algorithme similaire traite environ 400 jetons par seconde, et avec une augmentation de leurs variations (c'est-√†-dire les d√©finitions que nous avons transmises au constructeur) - il peut ralentir √† la vitesse du changement de pr√©sident en Russie ... ahem d√©sol√©.  Je voulais dire, bien s√ªr, que cela fonctionnera <b>tr√®s lentement</b> . <br><br>  D'accord, que pouvons-nous faire?  Pour commencer, vous pouvez comprendre ce qui ne va pas.  Le fait est que chaque fois que nous appelons <b>preg_match</b> √† l'int√©rieur du <b>joker</b> du langage, un compilateur avec son JIT appel√© PCRE se l√®ve (Et avec PHP 7.3, PCRE2 l'est d√©j√†).  Chaque fois, il analyse les habitu√©s eux-m√™mes et recueille un analyseur pour eux, avec lequel nous analysons le texte pour cr√©er des jetons.  Cela semble un peu √©trange et tautologique.  Mais en bref, chaque jeton n√©cessite une compilation de 1 √† N r√©guliers, o√π N est le nombre de d√©finitions de ces jetons.  Dans le m√™me temps, il convient de noter que m√™me l'indicateur " <i>S</i> " appliqu√© et l'optimisation utilisant " <i>\ G</i> " dans le constructeur, o√π des expressions r√©guli√®res pour les jetons sont g√©n√©r√©es, n'aident pas. <br><br>  Il n'y a qu'un seul moyen de sortir de cette situation - vous devez analyser tout ce texte en un seul passage, c'est-√†-dire  en ex√©cutant une <b>seule</b> fonction <b>preg_match</b> .  Il reste √† r√©soudre deux probl√®mes: <br><br><ol><li>  Comment indiquer que le r√©sultat de l'expression r√©guli√®re N1 correspond au jeton N2?  C'est-√†-dire  comment indiquer que " <i>\ w +</i> ", par exemple, est <i>T_CONST</i> . </li><li>  Comment d√©terminer la s√©quence de jetons en cons√©quence.  Comme vous le savez, le r√©sultat de <b>preg_match</b> ou <b>preg_match_all</b> contiendra tout m√©lang√©.  Et m√™me avec l'aide de drapeaux pass√©s comme quatri√®me argument, la situation ne changera pas. </li></ol><br>  Ici, vous pouvez faire une pause et r√©fl√©chir un peu.  Eh bien ou pas. <br><br>  La solution au premier probl√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s'appelle les groupes PCRE</a> , √©galement appel√©s ¬´sous-masques¬ª.  En utilisant les r√®gles: " <i>(?? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> ", vous pouvez obtenir tous les jetons en un seul passage en les comparant avec leurs noms.  √Ä la suite de la correspondance, un tableau associatif sera form√©, compos√© des paires " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> ". <br><br>  Le second est un peu plus compliqu√©.  Mais ici, vous pouvez appliquer une astuce tactique et utiliser la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">preg_replace_callback</a> .  Sa particularit√© est que l'anonym pass√© comme deuxi√®me argument sera appel√© strictement s√©quentiellement pour chaque jeton, du premier au dernier. <br><br>  Afin de ne pas languir - la mise en ≈ìuvre est la suivante: <br><br><div class="spoiler">  <b class="spoiler_title">Un autre volet de code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  Et son utilisation n'est pas diff√©rente de la version pr√©c√©dente.  Dans le m√™me temps, la vitesse de travail passe de <b>400</b> √† <b>57 000</b> jetons par seconde.  C'est cet algorithme que j'ai appliqu√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans mon impl√©mentation</a> , reprenant la r√©√©criture du code source Hoa.  Soit dit en passant, si vous utilisez Parle, vous pouvez compresser jusqu'√† <b>600 000</b> jetons par seconde.  Et l'image globale ressemble √† ceci (avec XDebug activ√© en PHP 7.1, donc les chiffres sont inf√©rieurs, mais le ratio peut √™tre grossi√®rement repr√©sent√©). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Le jaune est l'extension native de Parle. </li><li>  Bleu - impl√©mentation via <i>preg_replace_callback</i> avec un pr√©-assembl√© r√©gulier. </li><li>  Rouge - tout de m√™me, mais avec la <i>r√©gularit√©</i> g√©n√©r√©e lors de l'appel √† <i>preg_replace_callback</i> . </li><li>  Vert - impl√©mentation via <i>preg_match</i> . </li></ul><br><h2>  Pourquoi? </h2><br>  Eh bien, tout cela, bien s√ªr, est merveilleux, mais les impatients sont impatients de poser la question: "Qui en a besoin?"  Dans le monde abstrait de PHP, o√π le principe de "fig-fig-and-site-ready" domine - de telles biblioth√®ques ne sont pas n√©cessaires, nous serons honn√™tes.  Mais si nous parlons de l'√©cosyst√®me dans son ensemble, nous pouvons rappeler les biblioth√®ques notoires comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">symfony / yaml</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Doctrine</a> .  Les annotations dans Symfony sont le m√™me sous-langage dans PHP, n√©cessitant une analyse lexicale et syntaxique distincte.  De plus, il existe des transpilateurs CoffeeScript, Less et Scss / Sass encore moins connus, √©crits en PHP.  Eh bien, ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yay</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©traitez en</a> fonction de cela.  Je ne mentionnerai m√™me pas les outils d'analyse de code comme phpmd ou phpcs.  Et les g√©n√©rateurs de documentation comme phpDocumentnor ou Sami sont assez triviaux.  Chacun de ces projets √† un degr√© ou un autre utilise l'analyse lexicale √† la premi√®re √©tape de l'analyse du texte / code. <br><br>  Ce n'est pas une liste compl√®te de projets et j'esp√®re peut-√™tre que mon histoire vous aidera √† d√©couvrir quelque chose de nouveau et √† le reconstituer. <br><br><h2>  Postface </h2><br>  √Ä l'avenir, s'il y a quelqu'un qui s'int√©resse au sujet des analyseurs et des compilateurs, alors il y a quelques rapports int√©ressants sur ce sujet, en particulier des gars de JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Vid√©o</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Pourtant, bien s√ªr, la plupart des performances d'Andrei Breslav ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">abreslav</a> ), qui peuvent √™tre trouv√©es sur l'immensit√© de YouTube - je vous conseille de regarder. <br><br>  Eh bien, pour les fans de fiction, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il existe une telle ressource</a> qui m'a personnellement √©t√© extr√™mement utile. <br><br>  Post post scriptum.  Si vous √™tes quelque part enferm√© dans l'immensit√© de cette √©pop√©e, vous pouvez en informer l'auteur en toute s√©curit√© sous n'importe quelle forme qui vous convient. <br><br>  En prime, je voudrais donner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple d'un simple lexeur PHP</a> , il semble que ce n'est pas si effrayant maintenant, et maintenant c'est m√™me clair ce qu'il fait, non?  Bien que je trompe, les yeux saignent des habitu√©s.  =) <br><br>  Je vous remercie! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435102/">https://habr.com/ru/post/fr435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435086/index.html">Que devrions-nous construire notre carte de montage PCI-E</a></li>
<li><a href="../fr435088/index.html">Le g√©ant chinois du streaming Tencent Music entre en bourse - qu'est-ce que cela signifie et √† quoi les concurrents devraient-ils s'attendre</a></li>
<li><a href="../fr435094/index.html">Manette de jeu de Sega Mega Drive et Raspberry Pi Partie 2 (six derniers boutons)</a></li>
<li><a href="../fr435096/index.html">L'effet de la radio √† tube chaud</a></li>
<li><a href="../fr435098/index.html">ADB vs Spy Cam & Mic</a></li>
<li><a href="../fr435106/index.html">Encore une fois √† propos de passport.js</a></li>
<li><a href="../fr435108/index.html">Utilisation de Prolog</a></li>
<li><a href="../fr435112/index.html">Entretien d'entreprise</a></li>
<li><a href="../fr435114/index.html">Spring data jpa</a></li>
<li><a href="../fr435118/index.html">Save File Me - un service de sauvegarde gratuit avec chiffrement c√¥t√© client</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>