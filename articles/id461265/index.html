<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↩️ 🤰🏿 😥 Tentang penyalahgunaan penggunaan sistem operasi dalam proyek untuk mikrokontroler 👩🏽‍🤝‍👨🏻 👳🏿 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mikrokontroler modern memiliki kinerja yang cukup tinggi dan ini memberi banyak programmer kesempatan untuk berpikir kira-kira sebagai berikut: - “Tid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang penyalahgunaan penggunaan sistem operasi dalam proyek untuk mikrokontroler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461265/">  Mikrokontroler modern memiliki kinerja yang cukup tinggi dan ini memberi banyak programmer kesempatan untuk berpikir kira-kira sebagai berikut: - “Tidak apa-apa jika 1-5% kinerja digunakan untuk pemeliharaan sistem operasi.  Tetapi kode saya akan mudah didebug dan eksplisit! "  Pemikiran ini didukung oleh sejumlah besar memori (flash) non-volatile untuk menyimpan kode sistem operasi dan memori operasional (RAM / SRAM) untuk mengalokasikan tumpukannya sendiri untuk setiap tugas.  Namun, dalam banyak kasus ide ini keliru.  Dan dalam artikel ini saya akan memberi tahu Anda alasannya. <a name="habracut"></a><br><br><h2>  Tentang proyek tempat saya bekerja </h2><br>  Dalam praktik saya, saya sering harus bekerja dengan "desainer".  Saya menggambarkan pendekatan ini secara rinci dalam artikel saya sebelumnya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan C ++ di mikrokontroler</a> .  Maka saya tidak memberi tahu hal yang paling penting.  Sebagian besar "blok" dari "konstruktor" ini entah bagaimana terikat pada sistem operasi waktu-nyata.  Sebagian besar "blok" memiliki aliran sendiri (tugas, dalam hal sistem operasi real-time FreeRTOS yang digunakan).  Dan itu, rata-rata, proyek ini memiliki sekitar 10-15 tugas.  Terkadang nilai ini mencapai 35-40. <br><br>
<h2>  Di mana begitu banyak? </h2><br>  Berikut adalah daftar singkat tugas yang dihadapi <b>dalam setiap</b> proyek: <ul><li>  Pemeliharaan ADC (setiap modul dilayani oleh alirannya sendiri); </li><li>  pemeliharaan wdt (jika OS crash, tugas tidak akan mengatur ulang dan perangkat akan reboot); </li><li>  bekerja dengan halaman pengaturan (aliran terpisah mengontrol pekerjaan dengan memori flash); </li><li>  pemeliharaan protokol interaksi dengan dunia luar (hilir ke antarmuka. Misalnya, uart); </li></ul><br>  Kemudian sudah ada hal-hal spesifik untuk setiap perangkat, seperti aliran untuk servis termistor (menerima data dari aliran pengukuran ADC dan mengubah data ini ke suhu), polling periferal eksternal dan sebagainya. <br><br><h2>  Kesederhanaan yang tampak </h2><br>  Terlepas dari kenyataan bahwa ada banyak tugas dalam proyek, masing-masing dari mereka "tersembunyi" di dalam objek dari kelas yang sesuai (ingat bahwa konstruktor dalam C ++, tetapi ini juga dapat ditiru dalam C menggunakan "pemrograman dalam C dalam gaya berorientasi objek." Tapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih baik tidak perlu</a> ).  Karena objek "konstruktor" ini bersifat global dan FreeRTOS 9 digunakan dalam proyek-proyek, yang mendukung pembuatan entitas mereka sendiri dalam buffer yang dialokasikan oleh pengguna, penggunaan memori dapat dikontrol pada saat menghubungkan.  Jadi dari sudut pandang pemantauan kebocoran memori - semuanya lebih atau kurang normal.  Namun ada beberapa nuansa berikut: <br><ul><li>  perlu dipahami dengan jelas berapa banyak tumpukan yang dibutuhkan untuk setiap utas.  Dalam hal ini: <ul><li>  kasus kritis harus diperhitungkan (misalnya, bersarang dengan perilaku tertentu); </li><li>  jika fungsi dari perpustakaan standar digunakan, maka juga tahu bagaimana mereka diatur, atau setidaknya memiliki gagasan tentang seberapa banyak mereka akan mengkonsumsi tumpukan; </li></ul></li></ul><br>  Terlepas dari kenyataan ini, tampaknya menggunakan sistem operasi hanya akan meningkatkan logika kode dan membuatnya lebih jelas. <br><br><h2>  Penyalahgunaan fungsi sistem operasi </h2><br>  Masalah utama dimulai pada saat Anda mulai melupakan apa yang Anda tulis khusus untuk mikrokontroler.  OS membebankan biaya untuk bekerja dengan entitasnya sendiri (seperti semafor, mutex, antrian).  Berikut adalah contoh <a href="">kelas UART untuk mengimplementasikan fungsi terminal</a> .  Dalam interupsi, sebuah byte diterima, setelah itu, jika melewati rentang dengan karakter input yang valid, ia ditambahkan ke antrian dengan penggantian yang sesuai (misalnya, '\ n' berubah ke urutan "\ n \ r").  Ini dilakukan untuk mengamankan port untuk pengiriman (karena port dapat berfungsi tidak hanya sebagai terminal. Data log juga dapat dikirim melaluinya).  Di satu sisi, ini memastikan bahwa respons akan dikirim sesegera mungkin dan tidak akan mengganggu pengiriman data prioritas yang lebih tinggi (selain itu, sementara data prioritas yang lebih tinggi dikirim, ia terakumulasi dalam buffer, yang memungkinkan DMA digunakan untuk mengirim respons).  Namun, mulai dari saat ini Anda mendapatkan jalur yang licin.  Alih-alih menulis banyak melalui antrian, orang hanya bisa mengkonfigurasi dengan benar gangguan pada buffer non-kosong yang saat ini tidak berfungsi pada UART dan ketika DMA berakhir.  Pendekatan ini membutuhkan pemahaman yang jelas tentang cara kerja perangkat.  Namun, ini mengurangi biaya ke minimum absolut, membuat kebutuhan untuk solusi seperti itu nol. <br><br><h2>  Mengabaikan fungsionalitas perangkat keras mikrokontroler </h2><br>  Dalam praktik saya, saya bertemu proyek dengan 18 pengatur waktu perangkat lunak sistem operasi yang disetel ke frekuensi yang sama.  Pada saat yang sama, ada sekitar 10 timer dalam mikrokontroler, yang hanya digunakan systic.  Untuk mencatat penjadwal sistem operasi.  Keputusan ini dijelaskan oleh kurangnya keinginan untuk "mengacaukan perangkat keras" dari mikrokontroler.  Pada saat yang sama, sekitar 10 kb dialokasikan ke stack untuk fungsi yang disebut oleh pengatur waktu perangkat lunak.  Bahkan, sekitar 1 kb digunakan (pendek).  Ini disebabkan oleh "ambiguitas apa yang terjadi di dalam perpustakaan yang disebut." <br>  Dalam hal ini, dimungkinkan untuk memilih TIM6 dengan aman (dalam kasus menggunakan stm32f4), yang akan menghasilkan interupsi dengan frekuensi yang diberikan dan di dalamnya hanya akan memanggil fungsi yang diperlukan. <br><br><h2>  Menggunakan infinite loop sebagai ganti mesin negara </h2><br>  Sebagai kolom terpisah, saya akan memilih ketidakmampuan beberapa programmer untuk menulis mesin negara hingga, dan bukannya membuat aliran di mana ada loop tak terbatas yang memulai kerjanya dengan mendapatkan sesuatu dari antrian.  Menariknya, cara membuat mesin negara terbatas hingga melalui bahasa itu sendiri ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br><h2>  Mengabaikan "penjadwal perangkat keras" </h2><br>  Banyak mikrokontroler 32 bit memiliki pengontrol interupsi yang dipikirkan dengan baik dengan sistem prioritas yang dapat disesuaikan.  Dalam kasus stm32f4, ia memiliki nama NVIC, dan memiliki kemampuan untuk menetapkan prioritas interupsi dengan 16 level (tanpa mempertimbangkan sub-level). <br>  Sebagian besar aplikasi di bawah FreeRTOS yang harus saya tangani dapat ditulis sebagai mesin negara yang disebut interupsi dengan prioritas yang dikonfigurasi dengan benar.  Dan jika prosesor kembali ke "eksekusi normal" - pergi ke "tidur".  Dalam hal ini, tidak perlu memblokir akses ke sebagian besar sumber daya (variabel dan lainnya).  Aplikasi akan kehilangan tingkat abstraksi ekstra.  Dan dalam hal ini - jauh dari gratis.  Namun, pendekatan ini memerlukan perencanaan arsitektur yang bijaksana untuk setiap proyek.  Dalam proyek, "desainer" - semua interupsi memiliki satu prioritas dan, pada kenyataannya, diperlukan untuk "menyaring" data.  Kemudian masukkan sisa-sisa dalam antrian, dari mana aliran objek kelas yang sesuai akan mengambilnya. <br><br><h2>  Ringkasan </h2><br>  Dalam artikel ini saya berbicara tentang masalah dasar yang harus Anda hadapi ketika menggunakan sistem operasi dalam proyek-proyek untuk mikrokontroler, dan juga memeriksa kasus-kasus umum menggunakan sistem operasi ketika ini bisa dihindari tanpa kehilangan keterbacaan dan logika kode. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461265/">https://habr.com/ru/post/id461265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461253/index.html">Cara menembak diri Anda di kaki di C dan C ++. Haiku OS Cookbook</a></li>
<li><a href="../id461255/index.html">Cara menembak diri Anda di kaki di C dan C ++. Koleksi Resep OS Haiku</a></li>
<li><a href="../id461257/index.html">Bagaimana cara menghitung ROI dari otomatisasi uji dengan Selenium?</a></li>
<li><a href="../id461259/index.html">Pesta Penyimpanan, 8 Agustus, Moskow</a></li>
<li><a href="../id461261/index.html">Daftar periksa webinar RRC yang bermanfaat untuk produk RRC</a></li>
<li><a href="../id461267/index.html">Teknologi Intel Baru untuk Kemasan Chip</a></li>
<li><a href="../id461269/index.html">Solusi pekerjaan dengan pwnable.kr 08 adalah leg dan 10 adalah shellshock. Assembler ARM. Kerentanan Bash</a></li>
<li><a href="../id461271/index.html">Cara mempromosikan aplikasi seluler pada 2019: 4 cara praktis + alat yang bermanfaat</a></li>
<li><a href="../id461273/index.html">Pendekatan serakah dan mesin slot. Analisis tugas ML-track kejuaraan pemrograman</a></li>
<li><a href="../id461277/index.html">Ikhtisar alat SQLIndexManager gratis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>