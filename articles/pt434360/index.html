<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∫ üë®üèΩ‚Äçüè≠ üëÜüèº Palestra explicada sobre programa√ß√£o ass√≠ncrona em Javascript üî´ ü•Ä üõ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Como voc√™ deve se lembrar, em outubro est√°vamos traduzindo um artigo interessante sobre o uso de temporizadores em Javascript. Isso ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Palestra explicada sobre programa√ß√£o ass√≠ncrona em Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/434360/"> Ol√° pessoal! <br><br>  Como voc√™ deve se lembrar, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outubro</a> est√°vamos traduzindo um artigo interessante sobre o uso de temporizadores em Javascript.  Isso causou uma enorme discuss√£o, de acordo com os resultados dos quais desejamos retornar h√° muito tempo a este t√≥pico e oferecer uma an√°lise detalhada da programa√ß√£o ass√≠ncrona nessa linguagem.  Estamos felizes por termos conseguido encontrar material decente e public√°-lo antes do final do ano.  Boa leitura! <br><a name="habracut"></a><br>  A programa√ß√£o ass√≠ncrona em Javascript passou por uma evolu√ß√£o em v√°rios est√°gios: de retornos de chamada a promessas e mais a geradores e, em breve, a <code>async/await</code> .  Em cada est√°gio, a programa√ß√£o ass√≠ncrona em Javascript era um pouco simplificada para aqueles que j√° haviam batido de joelhos nessa linguagem, mas para iniciantes isso se tornava apenas mais assustador, pois era necess√°rio entender as nuances de cada paradigma, dominar a aplica√ß√£o de cada um e, n√£o menos importante, entender como tudo funciona. <br><br>  Neste artigo, decidimos relembrar brevemente como usar retornos de chamada e promessas, fazer uma breve introdu√ß√£o aos geradores e ajud√°-lo a entender intuitivamente exatamente como √© organizada a programa√ß√£o ass√≠ncrona "sob o cap√¥" com geradores e async / wait.  Esperamos que, dessa maneira, voc√™ possa aplicar com confian√ßa os v√°rios paradigmas exatamente onde forem apropriados. <br><br>  Sup√µe-se que o leitor j√° tenha usado retornos de chamada, promessas e geradores para programa√ß√£o ass√≠ncrona e tamb√©m esteja familiarizado com fechamentos e currying em Javascript. <br><br>  <b>Inferno de retorno de chamada</b> <br><br>  Inicialmente, havia retornos de chamada.  Javascript n√£o possui E / S s√≠ncrona (doravante denominada E / S) e o bloqueio n√£o √© suportado.  Portanto, para organizar qualquer E / S ou adiar qualquer a√ß√£o, foi escolhida uma estrat√©gia: o c√≥digo que era necess√°rio executar de forma ass√≠ncrona foi passado para a fun√ß√£o com execu√ß√£o adiada, que foi lan√ßada em algum lugar abaixo no loop de eventos.  Um retorno de chamada n√£o √© t√£o ruim, mas o c√≥digo aumenta e os retornos geralmente geram novos retornos.  O resultado √© algo como isto: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Al√©m dos arrepios ao ver um c√≥digo fractal, h√° mais um problema: agora delegamos o controle da nossa l√≥gica <code>do*Stuff</code> para outras fun√ß√µes ( <code>get*UserData()</code> ), √†s quais voc√™ pode n√£o ter c√≥digo-fonte e pode n√£o estar. verifique se eles est√£o realizando seu retorno de chamada  √ìtimo, n√£o √©? <br><br>  <b>Promessas</b> <br><br>  Promessas invertem a invers√£o de controle fornecida por retornos de chamada e ajudam a desvendar um emaranhado de retornos de chamada em uma cadeia suave. <br>  Agora o exemplo anterior pode ser convertido para algo como isto: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  J√° n√£o √© t√£o feio, n√©? <br><br>  Mas deixe-me !!!  Vejamos um exemplo de retorno de chamada mais vital (mas ainda em grande parte artificial): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     ‚Äì   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  Ent√£o, selecionamos o perfil do usu√°rio, depois os interesses dele e, com base nos interesses dele, selecionamos recomenda√ß√µes e, finalmente, tendo coletado todas as recomenda√ß√µes, exibimos a p√°gina.  Esse conjunto de retornos de chamada, dos quais, provavelmente, podemos nos orgulhar, mas, no entanto, √© de alguma forma desgrenhado.  Nada, aplique promessas aqui - e tudo vai dar certo.  Certo? <br><br>  Vamos mudar nosso m√©todo <code>fetchJson()</code> para que ele retorne uma promessa em vez de aceitar um retorno de chamada.  Uma promessa √© resolvida por um corpo de resposta analisado no formato JSON. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Legal n√©  O que h√° de errado com esse c√≥digo agora? <br><br>  ... Opa! .. <br>  N√£o temos acesso ao perfil ou interesses na √∫ltima fun√ß√£o desta cadeia?  Ent√£o, nada funciona!  O que fazer?  Vamos tentar as promessas aninhadas: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  Sim ... agora parece muito mais desajeitado do que esper√°vamos.  √â por causa de bonecas t√£o loucas que n√≥s, por √∫ltimo, mas n√£o menos importante, tentamos sair do inferno de retornos de chamada?  O que fazer agora? <br><br>  O c√≥digo pode ser penteado um pouco, apoiando-se nos fechamentos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  Sim, agora tudo est√° praticamente do jeito que quer√≠amos, mas com uma peculiaridade.  Observe como chamamos argumentos dentro de retornos de chamada nas <code>fetchedInterests</code> e <code>fetchedInterests</code> , em vez de <code>user</code> e <code>interests</code> ?  Se sim, ent√£o voc√™ √© muito observador! <br><br>  A falha dessa abordagem √© a seguinte: voc√™ precisa ter muito, muito cuidado para n√£o nomear nada nas fun√ß√µes internas, bem como as vari√°veis ‚Äã‚Äãdo cache que voc√™ usar√° em seu fechamento.  Mesmo se voc√™ tiver o dom de evitar sombras, a refer√™ncia a uma vari√°vel t√£o alta no fechamento ainda parece bastante perigosa, e isso definitivamente n√£o √© bom. <br><br>  <b>Geradores ass√≠ncronos</b> <br><br>  Geradores v√£o ajudar!  Se voc√™ usa geradores, toda a emo√ß√£o desaparece.  Apenas m√°gica.  A verdade √©  Veja apenas: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  Isso √© tudo.  Isso vai funcionar.  Voc√™ n√£o chora ao ver como s√£o bonitos os geradores, se arrepende de ter sido t√£o m√≠ope e ter come√ßado a aprender Javascript antes mesmo de os geradores aparecerem?  Eu admito que essa id√©ia j√° me visitou. <br>  Mas ... como tudo isso funciona?  Realmente m√°gico? <br><br>  Claro!  Nos voltamos para a exposi√ß√£o. <br><br>  <b>Geradores</b> <br><br>  No nosso exemplo, parece que os geradores s√£o f√°ceis de usar, mas na verdade h√° muita coisa acontecendo neles.  Para saber mais sobre geradores ass√≠ncronos, voc√™ precisa entender melhor como os geradores funcionam e como eles fornecem execu√ß√£o ass√≠ncrona, o que parece s√≠ncrono. <br><br>  Como o nome indica, o gerador cria os valores: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  √â bem simples, mas de qualquer maneira, vamos falar sobre o que est√° acontecendo aqui: <br><br><ol><li> <code>const counter = counts();</code>  - inicialize o gerador e salve-o no contador vari√°vel.  O gerador est√° no limbo; nenhum c√≥digo no corpo do gerador foi executado ainda. </li><li> <code>console.log(counter.next());</code>  - Interpreta√ß√£o da sa√≠da ( <code>yield</code> ) 1, ap√≥s a qual 1 √© retornado como <code>value</code> , e <code>done</code> resulta em <code>false</code> , pois a sa√≠da n√£o termina a√≠ </li><li> <code>console.log(counter.next());</code>  - Agora 2! </li><li> <code>console.log(counter.next());</code>  - Agora 3!  Terminado.  Est√° tudo certo?  N√£o.  A execu√ß√£o √© interrompida no passo <code>yield 3;</code>  Para concluir, voc√™ precisa chamar next () novamente. </li><li> <code>console.log(counter.next());</code>  - Agora 4, e ele retorna, mas n√£o √© emitido, ent√£o agora sa√≠mos da fun√ß√£o e tudo est√° pronto. </li><li> <code>console.log(counter.next());</code>  - O gerador terminou o trabalho!  Ele n√£o tem nada a relatar, exceto como "tudo est√° feito". </li></ol><br>  Ent√£o descobrimos como os geradores funcionam!  Mas espere, que verdade chocante: os geradores podem n√£o apenas transmitir valores, mas tamb√©m devor√°-los! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  Ufa, o que ?!  Um gerador consome valores, em vez de ger√°-los.  Como isso √© poss√≠vel? <br><br>  O segredo est√° na <code>next</code> fun√ß√£o.  Ele n√£o apenas retorna valores do gerador, mas tamb√©m pode devolv√™-los ao gerador.  Se voc√™ contar a <code>next()</code> argumento, a opera√ß√£o de <code>yield</code> , que o gerador est√° esperando no momento, na verdade resultar√° no argumento.  √â por isso que o primeiro <code>counter.next(1)</code> registrado como <code>undefined</code> .  Simplesmente n√£o existe extradi√ß√£o que possa ser resolvida. <br><br>  √â como se o gerador permitisse que o c√≥digo de chamada (procedimento) e o c√≥digo do gerador (procedimento) se associassem para que passassem valores uns para os outros √† medida que eram executados e esperassem um pelo outro.  A situa√ß√£o √© praticamente a mesma, como se tivesse sido pensada para os geradores Javascript a possibilidade de implementar procedimentos competitivos executados em coopera√ß√£o, eles tamb√©m s√£o "corotinas".  Na verdade, praticamente como <code>co()</code> , certo? <br><br>  Mas n√£o vamos nos apressar, sen√£o nos enganaremos.  Nesse caso, √© importante que o leitor compreenda intuitivamente a ess√™ncia dos geradores e da programa√ß√£o ass√≠ncrona, e a melhor maneira de fazer isso √© montar voc√™ mesmo o gerador.  N√£o escreva uma fun√ß√£o de gerador e n√£o use a terminada, mas recrie voc√™ mesmo o interior da fun√ß√£o de gerador. <br><br>  <b>O dispositivo interno do gerador - geramos geradores</b> <br><br>  Ok, eu realmente n√£o sei exatamente como s√£o os componentes internos do gerador em diferentes tempos de execu√ß√£o do JS.  Mas isso n√£o √© t√£o importante.  Geradores correspondem √† interface.  Um ‚Äúconstrutor‚Äù para instanciar um gerador, o <code>next(value? : any)</code> m√©todo <code>next(value? : any)</code> , com o qual ordenamos que o gerador continue trabalhando e atribui valores a ele, outro m√©todo <code>throw(error)</code> , caso um <code>throw(error)</code> gerado em vez de um valor e, finalmente, um m√©todo <code>return()</code> , que ainda est√° silencioso.  Se a conformidade com a interface for alcan√ßada, tudo estar√° bem. <br><br>  Ent√£o, vamos tentar criar o gerador <code>counts()</code> acima mencionado no ES5 puro, sem a <code>function*</code> palavra-chave <code>function*</code> .  Por enquanto, voc√™ pode ignorar <code>throw()</code> e passar o valor para <code>next()</code> , pois o m√©todo n√£o aceita nenhuma entrada.  Como fazer isso? <br><br>  Mas em Javascript, h√° outro mecanismo para pausar e retomar a execu√ß√£o do programa: fechamentos!  Parece familiar? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  Se voc√™ usou fechamentos antes, tenho certeza de que voc√™ j√° escreveu algo assim.  A fun√ß√£o retornada pelo makeCounter pode gerar uma sequ√™ncia infinita de n√∫meros, assim como um gerador. <br><br>  No entanto, essa fun√ß√£o n√£o corresponde √† interface do gerador e n√£o pode ser aplicada diretamente em nosso exemplo com <code>counts()</code> , que retorna 4 valores e sai.  O que √© necess√°rio para uma abordagem universal para escrever fun√ß√µes semelhantes a geradores? <br><br>  Fechamentos, m√°quinas estatais e trabalho duro! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  Ao executar este c√≥digo, voc√™ ver√° os mesmos resultados que na vers√£o com o gerador.  Legal n√© <br>  Ent√£o, separamos o lado gerador do gerador;  vamos analisar o consumo? <br>  De fato, n√£o h√° muitas diferen√ßas. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  Tudo o que √© necess√°rio √© adicionar <code>input</code> como argumento <code>go</code> e os valores s√£o canalizados.  Parece m√°gica de novo?  Quase como geradores? <br><br>  Viva!  Por isso, recriamos o gerador como fornecedor e consumidor.  Por que n√£o tentar combinar essas fun√ß√µes?  Aqui est√° outro exemplo bastante artificial de um gerador: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  Como somos todos especialistas em geradores, entendemos que esse gerador adiciona o valor fornecido em <code>next(value)</code> √† <code>sum</code> e depois retorna sum.  Funciona exatamente como esper√°vamos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Legal.  Agora vamos escrever essa interface como uma fun√ß√£o normal! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Uau, implementamos uma corrotina completa. <br><br>  Ainda h√° algo a discutir sobre a opera√ß√£o de geradores.  Como as exce√ß√µes funcionam?  Com as exce√ß√µes que ocorrem dentro dos geradores, tudo √© simples: <code>next()</code> far√° com que a exce√ß√£o chegue ao chamador e o gerador morrer√°.  A transmiss√£o de uma exce√ß√£o ao gerador √© feita no m√©todo <code>throw()</code> , que omitimos acima. <br><br>  Vamos enriquecer nosso terminador com um novo recurso interessante.  Se o chamador passar a exce√ß√£o para o gerador, ele retornar√° ao √∫ltimo valor da soma. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Problema de Programa√ß√£o - Penetra√ß√£o de Erro do Gerador</b> <br><br>  Camarada, como implementamos throw ()? <br><br>  F√°cil!  Erro √© apenas outro valor.  Podemos passar para <code>go()</code> como o pr√≥ximo argumento.  De fato, √© necess√°ria alguma cautela aqui.  Quando o <code>throw(e)</code> chamado, a <code>yield</code> funcionar√° como se tiv√©ssemos escrito o throw e.  Isso significa que devemos verificar se h√° erros em todos os estados de nossa m√°quina de estados e travar o programa se n√£o conseguirmos lidar com o erro. <br><br>  Vamos come√ßar com a implementa√ß√£o anterior do terminador, copiada <br><br>  <a href="">Padr√£o</a> <br><br>  <a href="">Solu√ß√£o</a> <br><br>  Boom!  Implementamos um conjunto de corotinas capazes de transmitir mensagens e exce√ß√µes entre si, como um gerador real. <br><br>  Mas a situa√ß√£o est√° piorando, n√£o √©?  A implementa√ß√£o da m√°quina de estado est√° se afastando cada vez mais da implementa√ß√£o do gerador.  Al√©m disso, devido ao tratamento de erros, o c√≥digo est√° cheio de lixo;  o c√≥digo √© ainda mais complicado devido ao longo <code>while</code> que temos aqui.  Para converter um <code>while</code> voc√™ precisa "desembara√ßar" em estados.  Portanto, nosso caso 1 inclui, na verdade, 2,5 itera√ß√µes do <code>while</code> , pois o <code>yield</code> interrompido no meio.  Por fim, √© necess√°rio adicionar c√≥digo extra para enviar exce√ß√µes do chamador e vice-versa, se n√£o houver <code>try/catch</code> no gerador para lidar com essa exce√ß√£o. <br><br>  Voc√™ conseguiu !!!  Conclu√≠mos uma an√°lise detalhada de poss√≠veis alternativas para a implementa√ß√£o de geradores e, espero, voc√™ j√° entendeu melhor como os geradores funcionam.  No res√≠duo seco: <br><br><ul><li>  Um gerador pode gerar valores, consumir valores ou ambos. </li><li>  O estado do gerador pode ser pausado (estado, m√°quina de estado, captura?) </li><li>  O chamador e o gerador permitem formar um conjunto de corutin, interagindo entre si </li><li>  Exce√ß√µes s√£o encaminhadas em qualquer dire√ß√£o. </li></ul><br>  Agora que somos mais versados ‚Äã‚Äãem geradores, proponho uma maneira potencialmente conveniente de raciocinar sobre eles: essas s√£o constru√ß√µes sint√°ticas com as quais voc√™ pode escrever procedimentos executados competitivamente que passam valores entre si atrav√©s de um canal que passa valores um de cada vez ( <code>yield</code> ).  Isso ser√° √∫til na pr√≥xima se√ß√£o, onde produziremos uma implementa√ß√£o de <code>co()</code> partir da rotina. <br><br>  <b>Invers√£o do controle de Corutin</b> <br><br>  Agora que somos h√°beis no trabalho com geradores, vamos pensar em como eles podem ser usados ‚Äã‚Äãna programa√ß√£o ass√≠ncrona.  Se pudermos escrever geradores como tal, isso n√£o significa que as promessas nos geradores ser√£o resolvidas automaticamente.  Mas espere, os geradores n√£o devem funcionar sozinhos.  Eles devem interagir com outro programa, o procedimento principal, o que chama <code>.next()</code> e <code>.throw()</code> . <br><br>  E se colocarmos nossa l√≥gica de neg√≥cios n√£o no procedimento principal, mas no gerador?  Sempre que um determinado valor ass√≠ncrono ocorrer, digamos, uma promessa, o gerador dir√°: "N√£o quero mexer com essa bobagem, acorde-me quando resolver", far√° uma pausa e emitir√° uma promessa ao procedimento de veicula√ß√£o.  Procedimento de manuten√ß√£o: "OK, ligo mais tarde."  Ap√≥s o qual ele registra um retorno de chamada com essa promessa, sai e aguarda at√© que seja poss√≠vel disparar um ciclo de eventos (ou seja, quando a promessa √© resolvida).  Quando isso acontecer, o procedimento anunciar√° ‚Äúei, √© sua vez‚Äù e enviar√° o valor via <code>.next()</code> gerador adormecido.  Ela aguardar√° o gerador fazer seu trabalho e, enquanto isso, far√° outras coisas ass√≠ncronas ... e assim por diante.  Voc√™ ouviu uma hist√≥ria triste sobre como o procedimento continua a servi√ßo de um gerador. <br><br>  Ent√£o, voltando ao t√≥pico principal.  Agora que sabemos como geradores e promessas funcionam, n√£o ser√° dif√≠cil criar esse "procedimento de servi√ßo".  O procedimento de servi√ßo em si ser√° executado competitivamente como uma promessa, instanciar√° e manter√° o gerador e, em seguida, retornar√° ao resultado final do nosso procedimento principal usando o retorno de chamada <code>.then()</code> . <br><br>  Em seguida, vamos retornar ao programa co () e discuti-lo em mais detalhes.  <code>co()</code> √© um procedimento de servi√ßo que exige trabalho escravo, de modo que o gerador possa trabalhar apenas com valores s√≠ncronos.  J√° parece muito mais l√≥gico, certo? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   ‚Äî co() </b> <br><br>  √ìtimo!     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br> <a href=""></a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   ‚Äì    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br> <a href=""></a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  ‚Äî !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br> <b></b> <br><br>       Javascript   , ,  ¬´ ¬ª     <code>co()</code> ,  ,    ,    <code>async/await</code> . ?  Certo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434360/">https://habr.com/ru/post/pt434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434346/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 22: ‚ÄúSeguran√ßa da Informa√ß√£o MIT‚Äù, parte 3</a></li>
<li><a href="../pt434348/index.html">Voc√™ se lembra da sua senha no Habr√©?</a></li>
<li><a href="../pt434354/index.html">Criando um modelo de reconhecimento de face usando aprendizado profundo em Python</a></li>
<li><a href="../pt434356/index.html">Still de Python com e-mail</a></li>
<li><a href="../pt434358/index.html">Substitui√ß√£o de importa√ß√£o de sistemas operacionais. Como vejo o SO dom√©stico</a></li>
<li><a href="../pt434362/index.html">N√ÉO previsto para 2019</a></li>
<li><a href="../pt434364/index.html">Suporte da fila do Hangfire</a></li>
<li><a href="../pt434368/index.html">Machine Learning para encontrar erros no c√≥digo: como eu estagiei na JetBrains Research</a></li>
<li><a href="../pt434370/index.html">Outro conquistador de sombras em Phaser, ou o uso de bicicletas</a></li>
<li><a href="../pt434374/index.html">Verificando o RBAC no Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>