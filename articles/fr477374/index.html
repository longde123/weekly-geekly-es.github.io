<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏼 👩🏾‍🚒 🎅🏼 Machines Z à fuzzing 🌲 🤞🏻 ⛹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Machines Z à fuzzing 
 Jouer à des jeux d'aventure texte est un pur plaisir, mais le plaisir est assez consommateur de cerveau. Mais aujourd'hui, nous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machines Z à fuzzing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477374/"><h1>  <a href="https://8bitworkshop.com/blog/misc/fuzzing-the-z-machine.md.html">Machines Z à fuzzing</a> </h1><br>  Jouer à des jeux d'aventure texte est un pur plaisir, mais le plaisir est assez consommateur de cerveau.  Mais aujourd'hui, nous avons toutes ces capacités de processeur inactives. <br><br>  Que se passe-t-il si nous faisons passer l'ordinateur par le jeu par nous-mêmes et que nous devons simplement nous pencher en arrière sur la chaise et regarder?  Nous n'avons même pas besoin de tous ces réseaux de neurones de nouvelle génération, plutôt d'une simple force brute. <br><br>  Nous déposons juste un tas de texte semi-aléatoire à l'entrée du jeu de texte et voyons ce qui se passe.  Dans le monde de la sécurité de l'information, on parle de fuzzing. <br><br>  L'objectif sera la Z-Machine, un interprète de machine virtuelle développé par Joel Berez et Mark Blanck en 1979, au cœur des Jeux Infocom.  C'est une cible idéale pour le fuzzing d'aventure, car il est bien documenté et dispose de nombreux outils et bibliothèques de support. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/883/408/615/883408615f5e4ed5964aef089ba74a5d.jpg" title="Lancement de Zork sur l'Atari 800XL (Sebastian Grunwald, CC 3.0)"><br><br>  <em>Lancement de Zork sur l'Atari 800XL (Sebastian Grunwald, CC 3.0)</em> <br><br><h1>  Mini Zork </h1><br>  Le jeu que nous allons <em>jouer</em> - <em>MINI-ZORK-1: The Great Underground Empire</em> .  Il s'agit d'une version de démonstration du premier Zorka d'Infokomovsky, conçue pour démarrer à partir d'une cassette et non à partir d'une disquette.  Il s’agissait essentiellement d’une publicité publiée dans le supplément des années 1990 au magazine britannique des utilisateurs de Commodore, <strong>Zzap! 64</strong> . <br><br>  Pour ceux qui n'ont pas joué à Zork, voici ce que vous voyez après avoir chargé le jeu: <br><a name="habracut"></a><br><pre><code class="plaintext hljs">MINI-ZORK I: The Great Underground Empire Copyright (c) 1988 Infocom, Inc. All rights reserved. ZORK is a registered trademark of Infocom, Inc. Release 34 / Serial number 871124 West of House You are standing in an open field west of a white house, with a boarded front door. You could circle the house to the north or south. There is a small mailbox here. &gt;</code> </pre> <br>  Astuce&gt; invite l'utilisateur à entrer des commandes comme OPEN MAILBOX ou GO NORTH pour avancer dans le jeu.  Le but est de «trouver les trésors du Grand Empire Souterrain et de les collecter dans votre boîte à butin» tout en résolvant des énigmes et en plongeant les ennemis. <br><br><h1>  Jouons à la chasse aux verbes (et aux noms) </h1><br>  Le guide de l'utilisateur complet avec Zork donne des exemples de commandes possibles, telles que OUVRIR LA PORTE EN BOIS et WARLOCK, PRENDRE LE SORTIE DÉFILER PUIS SUIVEZ-MOI.  Cependant, les utilisateurs devaient deviner indépendamment comment résoudre une énigme particulière. <br><br>  Les verbes tels que GET et DROP (GET / DROP) sont assez évidents, tout comme les huit points cardinaux standard et haut / bas (UP / DOWN), et en même temps in and out (IN / OUT).  Mais les utilisateurs devaient également utiliser ATTACK, POOL et PRAY, ainsi que prononcer des mots magiques qui n'étaient pas dans le manuel.  La situation où le jeu ne donnait pas suffisamment d'indices aux joueurs, ils appelaient moqueusement la «chasse aux verbes». <br><br>  Pour générer des commandes, fuzzer aura besoin d'une liste de mots acceptés par le jeu, son vocabulaire.  La Z-machine sélectionne cette liste comme dictionnaire de jeu (elle se trouve à un emplacement standard dans le fichier de chaque jeu). <br><br>  (C'est une sorte d'arnaque, oui! Mais il n'y a vraiment pas d'autre moyen d'expliquer à l'ordinateur quels mots utiliser, car certains verbes ne sont mentionnés nulle part dans le texte.) <br><br>  La façon la plus simple de générer des commandes est de prendre au hasard un ou plusieurs mots, dans notre cas, un ou deux.  Nous ne savons pas quels mots sont des verbes et quels noms, donc nous générons beaucoup de commandes étranges comme "SEE OOPS" et "DRIVER BELOW". <br><br>  Évidemment, cela est assez inefficace, car nous devons trier N * N combinaisons (où N est la taille du vocabulaire) pour trouver la commande même comme "KILL TROLL". <br><br>  Cependant, nous pouvons tricher un peu.  Nous scannerons tous les mots sur la sortie texte du jeu et choisirons ceux qui se trouvent dans notre dictionnaire.  Et choisissez un mot dans cette liste (au lieu d'un dictionnaire complet).  Par exemple, si nous voyons NORTH, WEST, HOUSE et MAILBOX dans le texte, nous sommes plus susceptibles d'utiliser ces mots. <br><br><h1>  Recherche de marqueurs d'histoire </h1><br>  En donnant simplement des commandes aléatoires, nous obtenons beaucoup de bêtises que l'analyseur jurera: <br><br><pre> <code class="plaintext hljs">&gt;about painti [    !] &gt;leathe guideb [   "leathe" ,    .]</code> </pre> <br>  (Les mots de vocabulaire ne dépassent pas six caractères dans la Z-Machine, nous générons donc des mots comme «leathe».) <br><br>  Cependant, un tel piétinement sur place prendra une éternité.  Comment déterminer quelles voies sont plus prometteuses que d'autres?  Nous chercherons des marqueurs pour promouvoir l'histoire. <br><br>  La Z-Machine possède une instruction PRINT qui imprime du texte sur la console.  Ce sont souvent des fragments de descriptions, comme «Ouest de la maison» et «bouteille brisée».  Nous enregistrerons chacun d'eux comme marqueur. <br><br>  Chaque fois que nous voyons un nouveau marqueur, nous enregistrons le passage actuel - une liste des équipes que nous avons exécutées dans le jeu en cours. <br><br>  Nous associons cette liste au marqueur actuel, afin que nous puissions (espérons-le) obtenir le même texte dans la sortie après avoir relu les mêmes commandes. <br><br>  Chaque lancement du jeu sélectionne un marqueur cible spécifique, et donc le passage qui lui est associé.  L'algorithme de recherche sélectionne les nouveaux marqueurs plus souvent que les anciens. <br><br>  Nous ne rejouerons pas les équipes textuellement dans chaque partie, mais nous ajouterons quelques équipes aléatoires et mélangerons l'ordre.  Lorsque nous verrons un nouveau marqueur, nous augmenterons le paramètre «succès», dont la croissance montrera qu'il est possible de changer moins souvent la liste des commandes.  Lorsque ce paramètre augmente suffisamment, nous marquons ce marqueur comme «stable», car nous avons un passage prévisible qui y mène. <br><br><h1>  Vous cherchez un court chemin </h1><br>  Les façons dont nous traversons le jeu sont souvent inefficaces.  Voici la liste des commandes qui ont été utilisées pour générer le marqueur «Wheeeeeeeeee !!!!!»: <br><br><pre> <code class="plaintext hljs">curse, art, body gate, incant count, the, the egg, repent, from the, the consum, what, leathe, trap- see, breath here, what intnum, about here, leathe guideb, about, about here, pot, here, see, here about, about, self, here about, mangle, see, rug, the, reply, elvish, say, stilet beetle, say toss, pray, gate about, what bolt, guideb, wooden, say knock, say sit, trail and, here, pray leathe, intnum, one, pray one, jump</code> </pre> <br>  Tout ce que nous devons vraiment faire est d'entrer la dernière commande: JUMP (ou DIVE).  Mais l'algorithme de recherche ne sait pas laquelle des commandes précédentes est nécessaire pour afficher "Wheeeeeeeeee !!!!!" <br><br>  Nous devons réduire le passage - pour les rendre aussi courts que possible.  Lorsque nous voyons un marqueur, nous remplaçons le passage associé par une liste de commandes plus courte, si possible.  Cela nous amène plus rapidement au marqueur cible, nous donnant plus de mouvements à expérimenter après avoir atteint l'objectif. <br><br>  De nombreux marqueurs, tels que "Wheeeeeeeeee !!!!!", ne sont pas intéressants, car nous pouvons les réaliser en un tour au tout début du jeu.  En réduisant leur liste de commandes, nous pourrons éventuellement confirmer que c'est le cas, et ainsi les supprimer de la liste des marqueurs cibles potentiels. <br><br><h1>  Plus que des mots </h1><br>  Puisque nous avons un accès direct à l'état interne de la machine Z, nous pouvons utiliser autre chose que la sortie de texte pour contrôler notre recherche.  Par exemple, nous pouvons corriger lorsqu'un objet s'est déplacé d'une pièce à l'autre, ou lorsque d'autres propriétés et indicateurs ont changé sur l'objet.  Appelez-le marqueurs VM (marqueurs de machine virtuelle) et corrigez-les en parallèle avec les marqueurs de texte: <br><br><pre> <code class="plaintext hljs">@mv_30_15  (#30)      #15 @f_176_10_1    "" (10)   ""(#176)</code> </pre> <br>  Nous en avons besoin parce que la sortie de texte ne nous raconte pas toute l'histoire.  Par exemple, en ramassant une épée ou une lampe, nous atteindrons le même marqueur «Pris». Et le marqueur VM indiquera à l'algorithme de recherche quand un nouvel état de la machine virtuelle est atteint, par exemple, lorsqu'un joueur se déplace dans une nouvelle salle, ou qu'un objet a été ramassé ou jeté. <br><br><h1>  Briser une machine virtuelle </h1><br>  L'enquête sur l'état du jeu est un processus assez lent.  L'une des premières tâches du jeu est de tuer le troll, ce qui ne vous permet pas d'aller plus loin.  Cependant, avant cela, le joueur doit trouver une épée dans la maison un peu plus haut. <br><br>  Afin d'accélérer le processus de recherche, nous allons casser la Z-machine et ramener l'état du jeu à ce que nous avons vu plus tôt.  Par exemple, nous avons accidentellement déplacé une épée dans la main d’un joueur, ce qui a permis d’exécuter avec succès la commande «STAB» (stab).  ("ATTACK TROLL" ne fonctionnera que si nous ajoutons "WITH SWORD", mais "STAB" (coup de couteau) implique déjà la présence d'un objet pointu et fonctionne donc.) <br><br>  Nous ne casserons que des marqueurs stables, donc si nous pouvons répéter le jeu de manière fiable et que les mains du joueur se révèlent être une épée, nous autoriserons le piratage de cet état: "l'épée est entre les mains du joueur".  Ensuite, nous pouvons combiner les équipes utilisées pour lever l'épée avec les équipes utilisées pour descendre le donjon, découvrant en cours de route que nous devons attaquer le troll. <br><br>  L'exemple du troll est particulièrement jésuite, car, en règle générale, il faut plusieurs coups pour le terminer, et chaque attaque donne un résultat aléatoire.  Étant donné que notre algorithme préfère les passes plus courtes, il est préférable d'adhérer à une prévision optimiste concernant nos capacités de combat. <br><br>  Après 530 000 soluces et 10 600 000 équipes (200 équipes par match), nous avons enfin compris comment attaquer le troll: <br><br><pre> <code class="plaintext hljs">north, east, open window, into, west, light, lift trap, small hi, get, west, light, tug large, lift trap, down, north, stab</code> </pre> <br>  Il y a encore quelques commandes inutiles, et nous ne comprenons toujours pas que nous devons le frapper plusieurs fois, mais nous pouvons le gérer. <br><br><h1>  Passe-temps fatal </h1><br>  L'algorithme de recherche ne connaît pas la différence entre collecter des objets, lancer des objets et déplacer un joueur d'une pièce à l'autre.  La seule façon dont il définit le progrès est de voir les marqueurs de l'histoire progresser. <br><br>  Cela développe rapidement dans l'algorithme de recherche un goût pour ... le meurtre!  Pour tuer un joueur, en particulier, parce qu'il est si facile et simple: entrez "ATTACK": <br><br><pre> <code class="plaintext hljs">&gt;attack [  ] ,  ! ****   **** , ,     .      ,       .          c-.  ,      .</code> </pre> <br>  Dans Mini Zorka, la première mort n'est pas la fin du jeu, le joueur se téléporte vers un autre endroit et vos affaires sont dispersées.  Pour un algorithme de recherche, la mort est simplement un objet se déplaçant d'une pièce à l'autre, créant des marqueurs pour déplacer l'histoire en cours de route.  Ce passe-temps entraîne l'exposition d'autres bugs amusants dans le jeu, tels que la capacité du joueur à jeter ses mains dans la rivière. <br><br>  Le jeu marque de 0 à 350 points, basé sur la résolution d'énigmes et la collecte de trésors.  Lorsqu'un joueur meurt, il est réduit de 10 points.  Nous pouvons utiliser le compte comme une heuristique, mais cela peut réduire excessivement les comportements à risque - l'amour d'errer dans des endroits sombres ou de combattre des trolls. <br><br>  L'algorithme de recherche s'intéresse également vivement à ce que le joueur ne voit pas, comme les PNJ se déplaçant entre les pièces.  Par exemple, le marqueur @ mv_112_37 indique le mouvement d'un voleur vers une pièce spécifique.  L'algorithme de recherche parvient à reproduire ce marqueur en exécutant à plusieurs reprises des commandes Z ou WAIT, s'attendant essentiellement à ce que le voleur atteigne la pièce cible. <br><br>  Il aime aussi ramasser et jeter des objets à différents endroits, car chaque mouvement de l'objet est un nouveau marqueur.  Qui sait  Peut-être que jeter cette feuille sur un chemin forestier mènera à la victoire dans le jeu!  (Narrateur: non, ce ne sera pas le cas.) <br><br>  Le fuzzing identifie invariablement les erreurs dans le programme, et ce jeu n'est pas différent, bien qu'il persiste.  Il a compris comment générer le mot «Clrthatrqdc» au tout début du jeu: <br><br><pre> <code class="plaintext hljs">&gt;tie up [  ] With a Clrthatrqdc!?!</code> </pre> <br>  Cela semble être une variable non initialisée indiquant des données non textuelles.  Le codage du texte compressé dans la machine Z est principalement alphabétique, car vous ne voyez pas autant de déchets aléatoires que lorsque vous essayez d'imprimer un fichier binaire en ASCII.  (Actuellement, ce mot <a href="https://www.google.com/search%3Fq%3DClrthatrqdc">n'est que deux fois sur Google</a> ( <em>déjà quatre fois, environ. Trad.</em> ).) <br><br><h1>  Procédure pas à pas </h1><br>  Pour gagner le jeu, nous devrons ramener nos biens pillés dans la boîte à butin et y fourrer chaque objet.  Notre algorithme de recherche simple mettra beaucoup de temps à tomber sur ce comportement, en particulier compte tenu de sa tendance à gaspiller de l'énergie et à déplacer des objets d'une pièce à l'autre. <br><br>  La complication d'un algorithme de recherche aléatoire prend du temps, nous devons donc être sélectifs lors de l'ajout de nouvelles fonctionnalités.  Nous voulons également éviter les connaissances a priori dans le jeu - en d'autres termes, nous voulons seulement tricher un peu. <br><br>  Si vous voulez expérimenter, <a href="">consultez le code source sur GitHub</a> , qui utilise <a href="https://github.com/DLehenbauer/jszm">JSZM</a> (l'interpréteur de Z-Machine Daniel Legenbauer). De nombreux <a href="http://www.ifarchive.org/indexes/if-archiveXgamesXzcode.html">jeux sont disponibles</a> (seules les versions jusqu'à 3 sont prises en charge.) <br><br>  Le document Graham Nelson <a href="https://www.inform-fiction.org/zmachine/standards/z1point1/index.html">Z-Machine Standards</a> , qui traite de la machine Z depuis deux décennies, est également disponible. <br><br>  Et dois-je ajouter le support Z-Machine sur <a href="https://8bitworkshop.com/">8bitworkshop</a> ?  Faites le moi savoir! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477374/">https://habr.com/ru/post/fr477374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477362/index.html">Plus qu'un anti-spam: comment tirer le meilleur parti de votre passerelle de messagerie électronique de sécurité</a></li>
<li><a href="../fr477364/index.html">Comment devenir développeur Java? Ou peut-être choisir Python?</a></li>
<li><a href="../fr477366/index.html">Cinq questions sur la conception de langages de programmation</a></li>
<li><a href="../fr477370/index.html">PHP sans serveur</a></li>
<li><a href="../fr477372/index.html">Amazon perd la guerre contre les contrefaçons</a></li>
<li><a href="../fr477378/index.html">Agile mixte - approche Waterfall lors de la mise en œuvre d'applications métier (aka Agile-like)</a></li>
<li><a href="../fr477382/index.html">Esports - faire du profit: Mercedes, mégaphone, paris et image de marque pour les esports</a></li>
<li><a href="../fr477384/index.html">Conférence «Sécurité de l'information. Menaces du présent et du futur »</a></li>
<li><a href="../fr477386/index.html">Semaine de sécurité 48: fuite de données gigantesque et vulnérabilité dans Whatsapp</a></li>
<li><a href="../fr477388/index.html">NILFS2 - système de fichiers pare-balles pour / home</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>