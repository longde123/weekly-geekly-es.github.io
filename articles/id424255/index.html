<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏽 👴 🥦 Cara menggunakan analisis statis dengan benar 🤚 ✒️ 🚮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang semakin banyak orang berbicara tentang analisis statis untuk mencari kerentanan sebagai tahap pengembangan yang diperlukan. Namun, banyak yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menggunakan analisis statis dengan benar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/424255/">  Sekarang semakin banyak orang berbicara tentang analisis statis untuk mencari kerentanan sebagai tahap pengembangan yang diperlukan.  Namun, banyak yang membicarakan masalah analisis statis.  Kami banyak berbicara tentang hal ini pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Positive Hack Days di</a> masa lalu, dan berdasarkan hasil diskusi ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami telah menulis tentang cara</a> kerja penganalisa statis.  Jika Anda mencoba alat yang serius, Anda mungkin takut dengan laporan panjang dengan rekomendasi yang membingungkan, kesulitan dalam menyiapkan alat dan positif palsu.  Jadi, apakah analisis statis masih diperlukan? <br><br>  Pengalaman kami menunjukkan apa yang dibutuhkan.  Dan banyak masalah yang muncul saat pertama kali melihat alat ini, sangat mungkin untuk dipecahkan.  Saya akan mencoba memberi tahu Anda apa yang dapat dilakukan pengguna dan seperti apa penganalisa itu sehingga penggunaannya bermanfaat, dan tidak memperkenalkan "alat lain yang tidak perlu yang dibutuhkan oleh petugas keamanan." <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/03/li/2s/03li2supuuuomzi_a_vcsm_wnye.jpeg"></div><a name="habracut"></a><br><h2>  Tentang analisis statis </h2><br>  Jadi, kita sudah bicara tentang keterbatasan teoritis analisis statis.  Sebagai contoh, analisis statis yang mendalam mencoba untuk memecahkan masalah yang eksponensial dalam kompleksitas.  Oleh karena itu, setiap alat mencari kompromi antara waktu yang dibutuhkan, sumber daya yang dikeluarkan, jumlah kerentanan yang ditemukan, dan jumlah positif palsu. <br><br>  Mengapa kita perlu analisis mendalam?  Setiap IDE sangat cepat menemukan kesalahan, kadang-kadang bahkan yang berhubungan dengan keamanan - apa masalah yang umumnya bersifat eksponensial?  Contoh klasik adalah injeksi SQL (dan injeksi lainnya, seperti XSS, RCE dan sejenisnya), yang melewati beberapa fungsi (yaitu, membaca data dari pengguna dan menjalankan kueri terjadi dalam fungsi yang berbeda).  Pencariannya memerlukan analisis antar-proses dari aliran data, dan ini adalah tugas kompleksitas eksponensial.  Setuju, tanpa mencari kerentanan semacam itu, analisis tidak dapat dianggap mendalam.  Untuk alasan yang sama, Anda perlu menganalisis kode secara keseluruhan, dan bukan di bagian - jika tidak, kerentanan antar-prosedur dapat terlewatkan. <br><br>  Dalam beberapa tahun terakhir, saya telah memperoleh banyak pengalaman dalam berkomunikasi dengan pelanggan (potensial) dari berbagai analisa statis.  Secara khusus, kami membahas klaim untuk alat berdasarkan hasil penggunaan pertama (pilot).  Sebagian besar klaim mengikuti satu atau lain cara dari keterbatasan teoritis teknologi.  Selain itu, alat mungkin tidak memiliki fungsionalitas yang dibutuhkan pengguna.  Namun, menurut pendapat saya, alat analisis dapat bergerak (dan bergerak) ke arah pengguna dalam hal memecahkan masalah yang ditunjukkan di bawah ini.  Tetapi Anda juga harus dapat menggunakan analisis, meratakan konsekuensi dari masalah yang sama - ternyata, ini tidak begitu sulit.  Mari kita mulai. <br><br>  Anda dapat membayangkan situasi model: Anda memutuskan untuk mencoba teknologi dalam aksi atau memilih penganalisa statis - membelanjakan seorang pilot.  Tentu saja, Anda tidak mempercayai kasus uji vendor dan ingin mencoba menganalisis kode Anda (pada saat yang sama Anda dapat menemukan kerentanan nyata dan memperbaikinya).  Anda diberi penginstal atau mesin virtual jadi dengan sistem untuk waktu yang singkat. <br><br><h2>  Jalankan analisis </h2><br>  Pertama, Anda perlu menjalankan analisis.  Anda pergi ke antarmuka, dan semuanya tampak jelas: unggah arsip dengan kode sumber ke dalam formulir dan klik "analisis".  Tapi tidak: Anda mendapatkan beberapa formulir dengan bidang berbeda yang perlu diisi, entah bagaimana.  Penting untuk menentukan bahasa pemrograman, beberapa pengaturan analisa, pilih paket kerentanan (bagaimana Anda tahu apa yang termasuk di dalamnya?) Dan seterusnya.  Anda lulus tes ini, dan analisis dimulai.  Ah, tidak - kesalahan pindai.  "Format tidak memenuhi persyaratan", "Perakitan kode diperlukan untuk bahasa ini", "File untuk pemindaian tidak ditemukan" ... Jika Anda tidak menulis kode ini sendiri, Anda masih harus pergi ke pengembang untuk meminta bantuan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/tq/s6/_2tqs69b0eezkhxbzkzmphokjya.png"></div><br>  <i>Pengembang menyerahkan kode sumber untuk pengujian</i> <br><br>  Perhatian khusus diberikan pada persyaratan untuk kode bangunan.  Sebagian besar analisis untuk sejumlah bahasa mengharuskan kode dikumpulkan selama analisis (bahasa JVM - Java, Scala, Kotlin dan sejenisnya, C / C ++, Objective-C, C #).  Anda memahami betapa menyakitkannya: untuk mereproduksi lingkungan proyek besar untuk perakitan pada mesin baru.  Di sisi lain, persyaratan ini dibenarkan, mereka mengikuti dari teknologi analisis dan spesifik bahasa ini. <br><br>  Bagaimana penganalisa menyelesaikan masalah ini?  Pertama, mereka membuat peluncuran analisis seotomatis mungkin.  Idealnya, cukup mengunduh file dalam format apa pun, dan penganalisa itu sendiri harus memahami bahasa apa yang ada di sana, cara mencoba membangun dan cara mengatur sisa pengaturan secara default sehingga hasilnya selengkap mungkin.  Jelas bahwa tidak mungkin untuk meramalkan segalanya - namun, Anda dapat mencoba menangani sebagian besar kasus. <br><br>  Persyaratan perakitan harus dibuat selembut mungkin.  Misalnya, untuk bahasa JVM, Anda tidak perlu meminta perakitan selama analisis - cukup minta memuat artefak, yaitu kode yang dirangkai bersama dengan sumbernya (yang jauh lebih sederhana).  Untuk Xcode, dalam kasus Objective-C, perakitan dapat diotomatisasi untuk sebagian besar kasus.  Jika tidak mungkin untuk mengumpulkan kode, analis dapat mencoba melakukan analisis parsial.  Hasilnya tidak akan begitu lengkap, tetapi lebih baik daripada tidak ada hasilnya sama sekali.  Juga nyaman jika modul analisis dapat diletakkan di mesin ke pengembang, di mana perakitan kode sudah dikonfigurasi, sementara arsitektur harus memungkinkan modul lain dan bagian antarmuka ditransfer ke mesin lain. <br><br>  Akhirnya, penganalisa harus mengajukan persyaratan format paling lunak dan menangani file input itu sendiri.  Arsip dengan kode sumber, arsip bersarang, arsip dari repositori, tautan ke repositori, arsip dari suatu produk, file yang dapat dieksekusi dari suatu produk - ada baiknya jika analisator mendukung semua ini. <br><br>  Namun, jangan lupa bahwa penganalisa tidak memiliki kecerdasan buatan dan tidak dapat melihat semuanya.  Karena itu, jika kesalahan terjadi, Anda harus membiasakan diri dengan manual - ada banyak hal berguna dalam mempersiapkan kode untuk analisis.  Nah, semua pekerjaan meluncurkan pemindaian selama implementasi analisa dilakukan hanya sekali untuk setiap basis kode.  Paling sering, penganalisis umumnya diintegrasikan ke dalam siklus CI, yaitu, tidak akan ada masalah dengan perakitan. <br><br><h2>  Proses analisis </h2><br>  Oke, pemindaian telah dimulai.  Satu jam berlalu - tidak ada hasil.  Bilah kemajuan tergantung di suatu tempat di tengah, tidak jelas dengan persentase dan perkiraan apa yang selesai.  Jam kedua berlalu - kemajuan telah bergerak 99 persen dan telah bertahan di sana selama setengah jam.  Jam ketiga berlalu dan penganalisa lumpuh, melaporkan kekurangan RAM.  Atau menggantung satu jam lagi dan berakhir.  Anda dapat mengharapkan analisis untuk lulus pada kecepatan yang sama dengan checkstyle Anda, dan di sini harapan akan sangat berbeda dari kenyataan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a5/0j/k9/a50jk9gc7psxqoedgvb5zolspvk.gif"></div><br>  Ya, penganalisa statis yang baik dapat menghabiskan banyak sumber daya, saya tunjukkan salah satu alasan di atas: menemukan kerentanan yang kompleks adalah tugas yang sulit secara eksponensial.  Jadi semakin banyak sumber daya dan semakin banyak waktu, hasil yang lebih baik akan (dengan mesin yang bagus, tentu saja).  Sangat sulit untuk memprediksi waktu analisis dan sumber daya yang diperlukan - waktu pengoperasian algoritma analisis statis sangat tergantung pada konstruksi bahasa, kompleksitas kode, pada kedalaman panggilan - karakteristik yang sulit untuk dihitung sebelumnya. <br><br>  Masalah dengan sumber daya adalah kejahatan yang perlu.  Anda harus berhati-hati dalam mengalokasikan sumber daya yang diperlukan, dengan sabar menunggu pemindaian selesai, dan juga memahami bahwa tidak ada yang dapat secara akurat memprediksi sumber daya yang diperlukan untuk penganalisa, bahkan dengan basis kode yang diberikan, dan Anda harus siap untuk mengubah parameter ini.  Selain itu, parameter yang diperlukan dapat berubah bahkan tanpa memperbarui basis kode - karena pembaruan analisa. <br><br>  Namun demikian, penganalisa dapat sedikit membantu dengan masalah ini.  Ia mampu memisahkan bagian sumber daya intensif (mesin) dan antarmuka menjadi mesin yang berbeda.  Ini akan memungkinkan Anda untuk tidak memuat mesin dengan program yang tidak perlu yang akan memperlambat pekerjaan mereka, sementara itu mungkin untuk menggunakan antarmuka sistem untuk setiap beban kerja pada pemindaian (misalnya, untuk melihat dan mengedit hasil).  Ini juga akan membuatnya mudah untuk skala tanpa menginstal ulang seluruh sistem (kami meningkatkan analisa pada mesin virtual baru, tentukan IP mesin utama - dan voila). <br><br>  Selain itu, penganalisa dapat memungkinkan Anda untuk memilih kedalaman analisis, menonaktifkan pemeriksaan berat, menggunakan analisis tambahan (di mana tidak semua kode diperiksa, tetapi hanya diubah).  Hal-hal ini harus digunakan dengan sangat hati-hati, karena dapat sangat mempengaruhi hasil pemindaian.  Jika Anda menggunakan fungsionalitas seperti itu, disarankan untuk melakukan analisis penuh pada beberapa interval. <br><br><h2>  Hasil analisis </h2><br>  Mari kita beralih ke hasil pemindaian (untuk waktu yang lama kita pergi ke mereka).  Anda menunggu sejumlah kerentanan di jendela penganalisa dengan gentar, dan Anda sangat terkejut melihatnya.  156 kritis, 1260 sedang, dan rendah 3210.  Anda pergi ke halaman hasil dan tenggelam dalam sejumlah masalah yang ditemukan.  Anda mengunduh laporan pdf dan Anda melihat beberapa ribu halaman teks.  Coba tebak apa yang akan dikatakan pengembang kode ketika dia melihat kanvas seperti itu? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4-/gs/y-/4-gsy-s94btn4jfejjkvcnkc-hg.jpeg"></div><br>  <i>Satpam membawa laporan kerentanan kepada pengembang</i> <br><br>  Tapi mari kita tetap mencoba melihat hasilnya, beri dia kesempatan.  Setelah memeriksa lusinan kejadian dengan cermat, Anda mulai memahami mengapa ada begitu banyak kerentanan.  Beberapa kerentanan benar-benar terlihat serius, Anda memahami bahwa mereka perlu diperbaiki.  Namun, segera Anda menemukan sekitar selusin palsu.  Dan juga - sejumlah besar kerentanan dalam kode perpustakaan.  Anda tidak akan memperbaiki perpustakaan!  Dan kemudian Anda mengerti berapa banyak waktu yang Anda habiskan untuk menganalisis hasil.  Dan prosedur ini harus diulang setiap hari, minggu, baik, atau setidaknya setiap rilis.  (Sebenarnya tidak). <br><br>  Untuk mulai dengan, positif palsu dapat dipahami dengan cara yang sangat berbeda.  Seseorang tidak akan menganggap hanya kerentanan kritis salah yang dapat dieksploitasi saat ini.  Seseorang akan menganggap hanya kesalahan eksplisit yang salah dari penganalisa.  Banyak tergantung pada apa yang Anda inginkan dari alat ini.  Kami menyarankan Anda mempertimbangkan hampir semua kejadian, karena bahkan kerentanan tingkat rendah yang tidak dapat dieksploitasi saat ini dapat berubah menjadi masalah serius besok, misalnya, karena perubahan kode dan kondisi eksternal. <br><br>  Ok, Anda perlu melihat semua entri, tetapi ini masih banyak pekerjaan.  Dan di sini analisanya dapat membantu dengan sangat baik.  Fungsi paling penting dari penganalisis adalah kemampuan untuk melacak kerentanan antara pemindaian satu proyek, sementara melacaknya tahan terhadap perubahan kecil yang standar untuk pengembangan kode.  Ini menghilangkan masalah yang perlu diulang analisis panjang: pertama kali Anda menghabiskan lebih banyak waktu, menghapus positif palsu dan mengubah kekritisan kejadian, tetapi kemudian Anda hanya perlu melihat kerentanan baru, yang akan beberapa kali lebih kecil. <br><br>  Bagus, tetapi apakah perlu untuk meninjau semua kerentanan untuk pertama kalinya?  Kami merekomendasikan melakukan ini, tetapi secara umum, ini tidak perlu.  Pertama, alat analisis memungkinkan Anda untuk menyaring hasil berdasarkan direktori dan file: misalnya, ketika Anda memulai pemindaian, Anda dapat langsung mengecualikan komponen, pustaka, kode uji apa pun dari analisis.  Ini akan mempengaruhi kecepatan analisis.  Kedua, penganalisa memungkinkan Anda untuk menyaring hasil berdasarkan kerentanan, yaitu, ketika Anda mulai memindai, Anda dapat membatasi sekumpulan kerentanan.  Akhirnya, selain kritikalitas, penganalisa dapat menghasilkan sesuatu seperti probabilitas kerentanan palsu (yaitu, kepercayaannya terhadap kerentanan ini).  Dengan menggunakan metrik ini, Anda dapat memfilter hasilnya. <br><br>  Secara terpisah, perlu dicatat teknologi Analisis Komposisi Perangkat Lunak (sekarang mulai didukung oleh semakin banyak instrumen di tingkat yang berbeda).  Teknologi ini memungkinkan Anda untuk mendeteksi penggunaan perpustakaan dalam kode Anda, menentukan nama dan versi, menunjukkan kerentanan yang diketahui, serta lisensi.  Teknologi ini dapat memisahkan kode perpustakaan dari milik Anda, yang juga dapat menyaring hasil. <br><br>  Ternyata Anda dapat menangani masalah hasil analisis yang melimpah, dan ini tidak terlalu sulit.  Dan meskipun melihat hasil pertama mungkin memang memakan waktu, maka ketika Anda memindai, itu akan menghabiskan lebih sedikit.  Namun, saya perhatikan lagi bahwa Anda harus berhati-hati tentang penyaringan hasil - Anda dapat melewati kerentanan.  Bahkan jika perpustakaan diketahui, itu tidak berarti bahwa tidak ada kerentanan di dalamnya.  Jika sekarang kerentanan ini terdeteksi dengan buruk (yaitu, alat ini menunjukkan banyak kesalahan positif untuk kerentanan ini), dan Anda menonaktifkannya, saat memperbarui penganalisa, Anda dapat melewati kerentanan sebenarnya. <br><br><h2>  Periksa alat analisa </h2><br>  Dipahami dengan laporan besar dan positif palsu.  Tetapi Anda ingin melangkah lebih jauh - untuk memastikan bahwa penganalisa menemukan kerentanan yang Anda tahu pasti (Anda dapat dengan sengaja meletakkannya, atau menemukan alat lain). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mz/iw/ri/mziwriqq4uvyofssmsi53qbgx3a.jpeg"></div><br>  Untuk memulainya, penting untuk memahami bahwa penganalisa tidak dapat menemukan kerentanan karena berbagai alasan.  Yang paling sederhana adalah pemindaian tidak terkonfigurasi dengan benar (Anda harus memperhatikan pesan kesalahan).  Namun dari sudut pandang teknologi analisis, alasannya bisa berbeda.  Analisis statis terdiri dari dua komponen penting: mesin (berisi semua kompleksitas algoritmik dan matematika) dan basis aturan pencarian kerentanan.  Satu situasi adalah ketika mesin memungkinkan Anda untuk menemukan kerentanan kelas ini, tetapi tidak ada kerentanan di basis aturan.  Dalam hal ini, menambahkan aturan biasanya tidak sulit.  Situasi yang sama sekali berbeda, jika mesin, pada prinsipnya, tidak mendukung kerentanan seperti itu - di sini revisi bisa sangat signifikan.  Saya memberi contoh di awal artikel: Injeksi SQL tidak akan pernah ditemukan tanpa algoritma analisis aliran data. <br><br>  Penganalisa statis harus menerapkan seperangkat algoritma dalam mesin yang mencakup kelas kerentanan yang tersedia untuk bahasa pemrograman tertentu (analisis aliran kontrol, aliran data, analisis interval, dll.).  Poin penting adalah kemampuan untuk menambahkan aturan pencarian kerentanan Anda sendiri ke alat - ini akan menghilangkan alasan pertama hilangnya kerentanan. <br><br>  Jadi, jika Anda tidak menemukan kerentanan yang ada dalam hasil pemindaian, pertama-tama Anda perlu mencari tahu alasan untuk melewatkan - biasanya vendor dapat membantu dengan ini.  Jika alasannya ada di basis aturan atau dalam konfigurasi pemindaian, maka situasinya dapat dengan mudah dihilangkan.  Yang paling penting adalah untuk mengevaluasi kedalaman analisis, yaitu, apa, pada prinsipnya, memungkinkan Anda untuk mencari mesin. <br><br><h2>  Kompetensi </h2><br>  Setelah membaca artikel di tempat ini, kita dapat mengasumsikan bahwa untuk bekerja dengan alat ini, diperlukan keahlian yang mendalam dari pengembang, karena Anda perlu memahami tanggapan mana yang salah dan mana yang benar.  Menurut saya, itu semua tergantung pada seberapa ramah instrumen itu berperilaku.  Jika ia menyediakan fungsionalitas yang nyaman dan mudah dimengerti, deskripsi kerentanan yang mudah dipahami dengan contoh, tautan, dan rekomendasi dalam berbagai bahasa, jika alat ini menunjukkan jejak kerentanan yang terkait dengan analisis aliran data, Anda tidak perlu memiliki keahlian yang mendalam dari pengembang dengan memahami semua seluk-beluk bahasa pemrograman dan kerangka kerja.  Namun, harus ada latar belakang minimal dalam pengembangan untuk membaca kode. <br><br><h2>  Integrasi dalam proses pengembangan </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/9t/p0/zw9tp0n81io8zllg6actd_zl_dc.jpeg"></div><br>  Di akhir artikel, kami secara singkat menyentuh salah satu masalah paling penting dalam menggunakan alat ini, dan kami akan mempertimbangkannya secara rinci dalam artikel berikut.  Misalkan Anda memutuskan untuk menggunakan analisa statis.  Namun, Anda memiliki proses pengembangan yang mapan, baik teknologi dan organisasi, dan Anda tidak ingin mengubahnya (tidak ada yang akan memberikannya). <br><br>  Alat tersebut harus memiliki antarmuka non-grafis penuh (misalnya, CLI atau REST API), yang dengannya Anda dapat mengintegrasikan alat analisis ke dalam proses apa pun.  Baik jika penganalisa memiliki integrasi siap pakai dengan berbagai komponen: plug-in untuk IDE atau sistem build, integrasi dengan sistem kontrol versi, plug-in untuk server CI / CD (Jenkins, TeamCity), integrasi dengan sistem manajemen proyek (JIRA), atau bekerja dengan pengguna ( Direktori Aktif). <br><br>  Integrasi analisis statis ke dalam proses pengembangan (yang disebut SDLC) adalah cara paling efektif untuk menggunakannya jika prosesnya sudah mapan dan semua peserta sepakat dan tahu mengapa ini perlu.  Analisis kode yang konstan setelah perubahan atau pembaruan ke penganalisis akan memungkinkan Anda untuk menemukan kerentanan sedini mungkin.  Pemisahan peran pengembang dan spesialis keamanan informasi, indikasi yang jelas tentang persyaratan keamanan informasi dan integrasi lunak ke dalam proses saat ini (misalnya, pada awalnya - sifat penasehat sistem) akan memungkinkan Anda untuk menggunakan alat tanpa rasa sakit dan bermanfaat.  Namun, belum ada yang membatalkan penggunaan alat secara manual, jika model pengembangan Anda tidak menyiratkan proses serupa. <br><br><h2>  Ringkasan </h2><br>  Artikel ini berisi rekomendasi dasar untuk mulai menggunakan analisa statis.  Penganalisa yang baik bekerja dengan urutan besarnya lebih baik daripada pemeriksa ringan, ia mencari masalah dengan kompleksitas yang berbeda secara fundamental.  Oleh karena itu, perlu diperhitungkan dengan fitur analisis statis sebagai teknologi, tetapi pada saat yang sama memilih alat tertentu sehingga fungsinya secara maksimal menghaluskan semua fitur tersebut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424255/">https://habr.com/ru/post/id424255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424243/index.html">5 cara mudah untuk meningkatkan komunikasi dengan pelanggan</a></li>
<li><a href="../id424245/index.html">Menulis klien Telegram itu mudah</a></li>
<li><a href="../id424247/index.html">KotlinConf 2018 Live - tonton siarannya 4-5 Oktober</a></li>
<li><a href="../id424249/index.html">Materi dari pertemuan #RuPostgres - video, presentasi, analisis kuis, dan laporan foto</a></li>
<li><a href="../id424251/index.html">Kami mempertimbangkan statistik percobaan di hh.ru</a></li>
<li><a href="../id424257/index.html">Hexagon Maps in Unity: Bagian 1-3</a></li>
<li><a href="../id424259/index.html">Minggu Keamanan 36: Telnet harus ditutup</a></li>
<li><a href="../id424261/index.html">Bagaimana mengatasi masalah pemrograman</a></li>
<li><a href="../id424263/index.html">Meningkatkan IDA Pro. Kami memperbaiki jambs modul prosesor</a></li>
<li><a href="../id424265/index.html">Review sepeda listrik Twitter Mantis E-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>