<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úñÔ∏è ü§úüèΩ üî≥ Gu√≠a de JavaScript Parte 4: Caracter√≠sticas „äóÔ∏è üì™ üôèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy publicamos la cuarta parte de la traducci√≥n del manual de JavaScript, dedicada a las funciones. 

 ‚Üí Parte 1: primer programa, caracter√≠sticas del...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de JavaScript Parte 4: Caracter√≠sticas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430382/">  Hoy publicamos la cuarta parte de la traducci√≥n del manual de JavaScript, dedicada a las funciones. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: primer programa, caracter√≠sticas del lenguaje, est√°ndares</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: estilo de c√≥digo y estructura del programa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: variables, tipos de datos, expresiones, objetos.</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: funciones</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: matrices y bucles</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: excepciones, punto y coma, literales comod√≠n</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7: modo estricto, esta palabra clave, eventos, m√≥dulos, c√°lculos matem√°ticos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">Funciones de JavaScript</font> </h2><br>  Hablemos sobre las funciones en JavaScript, hagamos una revisi√≥n general de ellas y consideremos los detalles sobre ellas, cuyo conocimiento le permitir√° usarlas de manera efectiva. <br><a name="habracut"></a><br>  Una funci√≥n es un bloque de c√≥digo independiente que, una vez declarado, se puede invocar tantas veces como sea necesario.  Una funci√≥n puede, aunque no es necesaria, aceptar par√°metros.  Las funciones devuelven un solo valor. <br><br>  Las funciones en JavaScript son objetos, o m√°s bien, son objetos de tipo <code>Function</code> .  Su diferencia clave con los objetos ordinarios, d√°ndoles las capacidades excepcionales que poseen, es que pueden llamarse funciones. <br><br>  Adem√°s, las funciones en JavaScript se denominan "funciones de primera clase", ya que pueden asignarse a variables, pueden pasarse a otras funciones como argumentos y pueden devolverse desde otras funciones. <br><br>  Primero, consideramos las caracter√≠sticas de trabajar con funciones y las construcciones sint√°cticas correspondientes que exist√≠an en el lenguaje antes del advenimiento del est√°ndar ES6 y que a√∫n son relevantes. <br><br>  As√≠ es como se ve una declaraci√≥n de funci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  En estos d√≠as, estas funciones se denominan "normales", distingui√©ndolas de las funciones de "flecha" que aparecieron en ES6. <br><br>  Puede asignar una funci√≥n a una variable o constante.  Tal construcci√≥n se llama expresi√≥n de funci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Puede notar que en el ejemplo anterior, la funci√≥n se asigna a una constante, pero en s√≠ misma no tiene un nombre.  Dichas funciones se llaman an√≥nimas.  Se pueden asignar nombres a funciones similares.  En este caso, estamos hablando de una expresi√≥n de funci√≥n con nombre (expresi√≥n de funci√≥n con nombre). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  El uso de tales expresiones aumenta la conveniencia de la depuraci√≥n (en los mensajes de error donde se realiza el seguimiento de la pila, el nombre de la funci√≥n es visible).  El nombre de la funci√≥n en una expresi√≥n funcional tambi√©n puede ser necesario para que la funci√≥n pueda llamarse a s√≠ misma, lo cual es indispensable para implementar algoritmos recursivos. <br><br>  En el est√°ndar ES6, han aparecido funciones de flecha, que son especialmente convenientes de usar en forma de las llamadas "funciones en l√≠nea", como argumentos pasados ‚Äã‚Äãa otras funciones (devoluciones de llamada). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Las funciones de flecha, adem√°s del hecho de que las estructuras utilizadas para declararlas, son m√°s compactas que el uso de funciones ordinarias, difieren de ellas en algunas caracter√≠sticas importantes, que discutiremos a continuaci√≥n. <br><br><h2>  <font color="#3AC1EF">Par√°metros de funciones</font> </h2><br>  Los par√°metros son variables que se establecen en la etapa de declarar una funci√≥n y contendr√°n los valores que se le pasan (estos valores se denominan argumentos).  Las funciones en JavaScript pueden no tener par√°metros o tener uno o m√°s par√°metros. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const doSomethingElse = foo =&gt; { // - } const doSomethingElseAgain = (foo, bar) =&gt; { // - }</span></span></code> </pre> <br>  Aqu√≠ hay algunos ejemplos de funciones de flecha. <br><br>  Comenzando con el est√°ndar ES6, las funciones pueden tener los llamados "par√°metros predeterminados". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - }</span></span></code> </pre> <br>  Representan valores est√°ndar establecidos por los par√°metros de las funciones si, cuando se llama, los valores de algunos par√°metros no est√°n establecidos.  Por ejemplo, la funci√≥n que se muestra arriba se puede llamar pasando ambos par√°metros que recibe y por otros m√©todos. <br><br><pre> <code class="javascript hljs">doSomething(<span class="hljs-number"><span class="hljs-number">3</span></span>) doSomething()</code> </pre> <br>  En ES8, ahora puede poner una coma despu√©s del √∫ltimo argumento de una funci√≥n (esto se llama coma final).  Esta caracter√≠stica le permite aumentar la conveniencia de editar c√≥digo cuando usa sistemas de control de versiones durante el desarrollo del programa.  Los detalles sobre esto se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Los argumentos pasados ‚Äã‚Äãa las funciones se pueden representar como matrices.  Para analizar estos argumentos, puede usar un operador que se parezca a tres puntos (este es el llamado "operador de extensi√≥n" u "operador de propagaci√≥n").  As√≠ es como se ve. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } const args = [2, 'ho!'] doSomething(...args)</span></span></code> </pre> <br>  Si las funciones necesitan tomar muchos par√°metros, recordar el orden de su secuencia puede ser dif√≠cil.  En tales casos, se utilizan objetos con par√°metros y oportunidades para la desestructuraci√≥n de objetos ES6. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - console.log(foo) // 2 console.log(bar) // 'ho!' } const args = { foo: 2, bar: 'ho!' } doSomething(args)</span></span></code> </pre> <br>  Esta t√©cnica permite, describiendo los par√°metros en forma de propiedades del objeto y pasando la funci√≥n al objeto, obtener el acceso de la funci√≥n a los par√°metros por sus nombres sin usar construcciones adicionales.  Lea m√°s sobre esta t√©cnica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  <font color="#3AC1EF">Valores devueltos de funciones</font> </h2><br>  Todas las funciones devuelven un cierto valor.  Si el comando return no se especifica expl√≠citamente, la funci√≥n volver√° <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bar = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'hey'</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - } console.log(doSomething())</span></span></code> </pre> <br>  La ejecuci√≥n de la funci√≥n finaliza despu√©s de que se ejecuta todo el c√≥digo que contiene o despu√©s de que se encuentra la palabra clave <code>return</code> en el c√≥digo.  Cuando se encuentra esta palabra clave en una funci√≥n, su operaci√≥n se completa y el control se transfiere al lugar desde donde se llam√≥ a la funci√≥n. <br><br>  Si despu√©s de la palabra clave <code>return</code> especifica un cierto valor, este valor vuelve al lugar de la llamada a la funci√≥n como resultado de la ejecuci√≥n de esta funci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = doSomething() <span class="hljs-comment"><span class="hljs-comment">// result === 'test'</span></span></code> </pre> <br>  Solo se puede devolver un valor de una funci√≥n.  Para poder devolver m√∫ltiples valores, puede devolverlos como un objeto usando un objeto literal o como una matriz, y cuando llame a una funci√≥n, use la construcci√≥n de asignaci√≥n destructiva.  Los nombres de los par√°metros se guardan.  Al mismo tiempo, si necesita trabajar con un objeto o una matriz devuelta por una funci√≥n, es decir, en forma de un objeto o una matriz, puede hacerlo sin una asignaci√≥n destructiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [ name, age ] = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br>  La construcci√≥n <code>const [ name, age ] = doSomething()</code> se puede leer de la siguiente manera: "declare las constantes de <code>name</code> y <code>age</code> y as√≠gneles los valores de los elementos de la matriz que devolver√° la funci√≥n". <br>  As√≠ es como se ve lo mismo usando un objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Roger'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, age } = doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, age) <span class="hljs-comment"><span class="hljs-comment">//Roger 6</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Funciones anidadas</font> </h2><br>  Las funciones se pueden declarar dentro de otras funciones. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingElse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {} doSomethingElse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } doSomething()</code> </pre> <br>  El alcance de una funci√≥n anidada est√° limitado por una funci√≥n externa; no se puede llamar desde afuera. <br><br><h2>  <font color="#3AC1EF">M√©todos de objeto</font> </h2><br>  Cuando las funciones se utilizan como propiedades de los objetos, dichas funciones se denominan m√©todos de objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started`</span></span>) } } car.start()</code> </pre> <br><h2>  <font color="#3AC1EF">Esta palabra clave</font> </h2><br>  Si comparamos la flecha y las funciones ordinarias utilizadas como m√©todos de objetos, podemos encontrar su diferencia importante, que consiste en el significado de la palabra clave <code>this</code> .  Considera un ejemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> car = { <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">'Ford'</span></span>, <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'Fiesta'</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Started </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Stopped </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.brand}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.model}</span></span></span><span class="hljs-string">`</span></span>) } } car.start() <span class="hljs-comment"><span class="hljs-comment">//Started Ford Fiesta car.stop() //Stopped undefined undefined</span></span></code> </pre> <br>  Como puede ver, llamar al m√©todo <code>start()</code> conduce al resultado esperado, pero el m√©todo <code>stop()</code> obviamente no funciona correctamente. <br><br>  Esto se debe al hecho de que la palabra clave this se comporta de manera diferente cuando se usa en flechas y funciones ordinarias.  A saber, la <code>this</code> en la funci√≥n de flecha contiene un enlace al contexto que incluye la funci√≥n.  En este caso, cuando se trata del navegador, este contexto es el objeto de la <code>window</code> . <br><br>  As√≠ es como se ve la ejecuci√≥n de dicho c√≥digo en la consola del navegador. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">arrFn</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } test.fn() test.arrFn()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b3/7c4/c29/4b37c4c299f7f21c40c77c372d34974f.png"></div><br>  <i><font color="#999999">Caracter√≠sticas de esta palabra clave en funciones convencionales y de flecha</font></i> <br><br>  Como puede ver, llamar a esto en una funci√≥n regular significa llamar al objeto, y <code>this</code> en la funci√≥n de flecha apunta a la <code>window</code> . <br><br>  Todo esto significa que las funciones de flecha no son adecuadas para la funci√≥n de objeto y m√©todos de constructor (si intenta utilizar la funci√≥n de flecha como constructor, se lanzar√° un <code>TypeError</code> ). <br><br><h2>  <font color="#3AC1EF">Expresiones funcionales llamadas inmediatamente</font> </h2><br>  La expresi√≥n de funci√≥n invocada inmediatamente (IIFE) es una funci√≥n que se llama autom√°ticamente inmediatamente despu√©s de que se declara. <br><br><pre> <code class="javascript hljs">;(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'executed'</span></span>) })()</code> </pre> <br>  El punto y coma antes de IIFE es opcional, pero su uso le permite asegurarse contra errores asociados con la colocaci√≥n autom√°tica de punto y coma. <br><br>  En el ejemplo anterior, la palabra <code>executed</code> ir√° a la consola, despu√©s de lo cual IIFE saldr√°.  IIFE, al igual que otras funciones, puede devolver los resultados de su trabajo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IIFE'</span></span> })() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(something)</code> </pre> <br>  Despu√©s de ejecutar este sencillo ejemplo, la consola obtendr√° la l√≠nea <code>IIFE</code> , que result√≥ ser <code>something</code> despu√©s de ejecutar la expresi√≥n de funci√≥n llamada inmediatamente.  Puede parecer que no hay un beneficio particular de tal dise√±o.  Sin embargo, si en IIFE se realizan algunos c√°lculos complejos que deben hacerse solo una vez, despu√©s de lo cual los mecanismos correspondientes son innecesarios, la utilidad de IIFE es obvia.  Es decir, con este enfoque, despu√©s de ejecutar IIFE, solo el resultado devuelto por la funci√≥n estar√° disponible en el programa.  Adem√°s, podemos recordar que las funciones pueden devolver otras funciones y objetos.  Estamos hablando de cierres, hablaremos de ellos a continuaci√≥n. <br><br><h2>  <font color="#3AC1EF">Actualizaci√≥n de funciones</font> </h2><br>  Antes de ejecutar el c√≥digo JavaScript, se reorganiza.  Ya hablamos sobre el mecanismo de elevaci√≥n para variables declaradas usando la palabra clave <code>var</code> .  Un mecanismo similar funciona con funciones.  Es decir, estamos hablando del hecho de que las declaraciones de funciones en el curso del procesamiento del c√≥digo antes de su ejecuci√≥n se mueven a la parte superior de su alcance.  Como resultado, por ejemplo, resulta que puede llamar a la funci√≥n antes de que se declare. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//did something function doSomething() { console.log('did something') }</span></span></code> </pre> <br>  Si mueve una llamada de funci√≥n para que vaya despu√©s de su declaraci√≥n, nada cambiar√°. <br><br>  Si, en una situaci√≥n similar, se usa una expresi√≥n funcional, entonces un c√≥digo similar arrojar√° un error. <br><br><pre> <code class="javascript hljs">doSomething() <span class="hljs-comment"><span class="hljs-comment">//TypeError var doSomething = function () { console.log('did something') }</span></span></code> </pre> <br>  En este caso, resulta que aunque la declaraci√≥n de la variable <code>doSomething</code> eleva a la parte superior del alcance, esto no se aplica a la operaci√≥n de asignaci√≥n. <br>  Si, en lugar de <code>var</code> , utiliza las palabras clave <code>let</code> o <code>const</code> en una situaci√≥n similar, este c√≥digo tampoco funcionar√°, sin embargo, el sistema mostrar√° un mensaje de error diferente ( <code>ReferenceError</code> lugar de <code>TypeError</code> ), porque al usar <code>let</code> y <code>const</code> , no se <code>const</code> declaraciones constantes y variables. <br><br><h2>  <font color="#3AC1EF">Funciones de flecha</font> </h2><br>  Ahora hablaremos m√°s sobre las funciones de flecha que ya hemos cumplido.  Pueden considerarse una de las innovaciones m√°s significativas del est√°ndar ES6, difieren de las funciones ordinarias no solo en apariencia, sino tambi√©n en su comportamiento.  En estos d√≠as se usan extremadamente ampliamente.  Quiz√°s no haya un solo proyecto moderno en el que no se utilicen en la gran mayor√≠a de los casos.  Podemos decir que su apariencia cambi√≥ para siempre la apariencia del c√≥digo JS y las caracter√≠sticas de su trabajo. <br><br>  Desde un punto de vista puramente externo, la sintaxis para declarar funciones de flecha es m√°s compacta que la sintaxis de funciones ordinarias.  Aqu√≠ est√° la declaraci√≥n de una funci√≥n regular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Aqu√≠ est√° el anuncio de la funci√≥n de flecha, que, en general, si no tiene en cuenta las caracter√≠sticas de las funciones de flecha, es similar a la anterior. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Si el cuerpo de una funci√≥n de flecha contiene solo un comando, cuyo resultado devuelve esta funci√≥n, puede escribirse sin llaves y sin la palabra clave <code>return</code> .  Por ejemplo, dicha funci√≥n devuelve la suma de los argumentos que se le pasan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//3</span></span></code> </pre> <br>  Como puede ver, los par√°metros de las funciones de flecha, como en el caso de las funciones ordinarias, se describen entre par√©ntesis.  Adem√°s, si dicha funci√≥n toma solo un par√°metro, puede especificarse sin par√©ntesis.  Por ejemplo, aqu√≠ hay una funci√≥n que devuelve el resultado de dividir el n√∫mero que le pas√≥ por 2. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">8</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//4</span></span></code> </pre> <br>  Como resultado, resulta que las funciones de flecha son muy convenientes de usar en situaciones donde se necesitan funciones peque√±as. <br><br><h3>  <font color="#3AC1EF">‚ñç Resultados impl√≠citos de retorno de funciones</font> </h3><br>  Ya hemos mencionado esta caracter√≠stica de las funciones de flecha, pero es tan importante que se debata con m√°s detalle.  Estamos hablando del hecho de que las funciones de flecha de una l√≠nea admiten el retorno impl√≠cito de los resultados de su trabajo.  Un ejemplo de devolver un valor primitivo de una funci√≥n de flecha de una sola l√≠nea que ya hemos visto.  ¬øQu√© pasa si tal funci√≥n deber√≠a devolver un objeto?  En este caso, las llaves del literal del objeto pueden confundir al sistema, por lo que se utilizan par√©ntesis en el cuerpo de la funci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = myFunction() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.value) <span class="hljs-comment"><span class="hljs-comment">//test</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Palabra clave esto y funciones de flecha</font> </h3><br>  Arriba, cuando miramos las caracter√≠sticas de <code>this</code> , comparamos las funciones regulares y de flecha.  Esta secci√≥n pretende llamar su atenci√≥n sobre la importancia de sus diferencias.  La <code>this</code> , en s√≠ misma, puede causar ciertas dificultades, ya que depende del contexto de la ejecuci√≥n del c√≥digo y de si el modo estricto est√° habilitado o no. <br><br>  Como hemos visto, cuando se usa la <code>this</code> en un m√©todo de un objeto representado por una funci√≥n regular, <code>this</code> apunta al objeto al que pertenece el m√©todo.  En este caso, hablamos de vincular la palabra clave <code>this</code> a un valor que represente el contexto de la funci√≥n.  En particular, si se llama a una funci√≥n como m√©todo de objeto, la palabra clave this est√° vinculada a este objeto. <br><br>  En el caso de las funciones de flecha, resulta que el enlace <code>this</code> no se realiza en ellas; usan la <code>this</code> desde su alcance.  Como resultado, no se recomienda su uso como m√©todos de objeto. <br><br>  El mismo problema ocurre cuando se usan funciones como controladores de eventos para elementos DOM.  Por ejemplo, el <code>button</code> elemento HTML <code>button</code> usa para describir botones.  El evento <code>click</code> se <code>click</code> cuando un usuario hace clic en un bot√≥n.  Para responder a este evento en el c√≥digo, primero debe obtener un enlace al elemento correspondiente y luego asignarle un controlador de eventos de <code>click</code> como una funci√≥n.  Como tal controlador, puede usar tanto la funci√≥n regular como la funci√≥n de flecha.  Pero, si en el controlador de eventos necesita acceder al elemento para el que se llama (es decir, a <code>this</code> ), la funci√≥n de flecha no funcionar√° aqu√≠, ya que <code>this</code> valor disponible apunta al objeto de <code>window</code> .  Para probar esto en la pr√°ctica, cree una p√°gina HTML, cuyo c√≥digo se muestra a continuaci√≥n, y haga clic en los botones. <br><br><pre> <code class="javascript hljs">&lt;!DOCTYPE html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Arrow function</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript">     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> f = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"fn"</span></span></span></span><span class="xml"><span class="javascript">)     f.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></span><span class="xml"><span class="javascript"><span class="hljs-function"> (</span></span></span><span class="hljs-params"></span><span class="xml"><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span></span><span class="xml"><span class="javascript">{         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === f)     })     </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">const</span></span></span></span><span class="xml"><span class="javascript"> af = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.getElementById(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">"arrowFn"</span></span></span></span><span class="xml"><span class="javascript">)     af.addEventListener(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'click'</span></span></span></span><span class="xml"><span class="javascript">, () =&gt; {         alert(</span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span><span class="xml"><span class="javascript"> === </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">window</span></span></span></span><span class="xml"><span class="javascript">)     })   </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  En este caso, cuando haga clic en estos botones, aparecer√°n ventanas que contienen <code>true</code> .  Sin embargo, en el controlador de eventos de <code>click</code> del bot√≥n con el identificador <code>fn</code> , se verifica la igualdad de <code>this</code> el bot√≥n, y en el bot√≥n con la <code>arrowFn</code> del identificador <code>arrowFn</code> la igualdad de <code>this</code> y el objeto de la <code>window</code> . <br><br>  Como resultado, si necesita llamar a <code>this</code> en el controlador de eventos del elemento HTML, la funci√≥n de flecha no funcionar√° para el dise√±o de dicho controlador. <br><br><h2>  <font color="#3AC1EF">Cortocircuitos</font> </h2><br>  Los cierres son un concepto importante en JavaScript.  De hecho, si escribiste funciones JS, entonces tambi√©n usaste cierres.  Los cierres se utilizan en algunos patrones de dise√±o, en el caso de que necesite organizar un control estricto del acceso a ciertos datos o funciones. <br><br>  Cuando se llama a una funci√≥n, tiene acceso a todo lo que est√° dentro del alcance de lo externo.  Pero no hay acceso a lo que se declara dentro de la funci√≥n.  Es decir, si una variable (u otra funci√≥n) se declar√≥ en una funci√≥n, no se puede acceder al c√≥digo externo durante la ejecuci√≥n de la funci√≥n o despu√©s de la finalizaci√≥n de su trabajo.  Sin embargo, si se devuelve otra funci√≥n de la funci√≥n, esta nueva funci√≥n tendr√° acceso a todo lo que se declar√≥ en la funci√≥n original.  En este caso, todo esto estar√° oculto del c√≥digo externo en el cierre. <br><br>  Considera un ejemplo.  Aqu√≠ hay una funci√≥n que toma el nombre del perro y luego lo muestra en la consola. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> ;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say))() } bark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  El valor devuelto por esta funci√≥n a√∫n no nos interesa, el texto se muestra en la consola usando IIFE, que en este caso no juega un papel especial, sin embargo, esto nos ayudar√° a ver la conexi√≥n entre esta funci√≥n y su variante, en la que, en lugar de llamar a una funci√≥n que muestra texto a la consola, devolveremos esta funci√≥n desde la funci√≥n reescrita <code>bark()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) bark() <span class="hljs-comment"><span class="hljs-comment">// Roger barked!</span></span></code> </pre> <br>  El resultado del c√≥digo en dos casos es el mismo.  Pero en el segundo caso, lo que se transfiri√≥ a la funci√≥n original cuando se llam√≥ (el nombre del perro, <code>Roger</code> ) se almacena en el cierre, despu√©s de lo cual es utilizado por otra funci√≥n devuelta desde el original. <br><br>  Realicemos otro experimento: cree, utilizando la funci√≥n original, dos nuevos para perros diferentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prepareBark = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dog</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> say = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> barked!`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(say) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rogerBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Roger`</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sydBark = prepareBark(<span class="hljs-string"><span class="hljs-string">`Syd`</span></span>) rogerBark() sydBark()</code> </pre> <br>  Este c√≥digo generar√° lo siguiente. <br><br><pre> <code class="javascript hljs">Roger barked! Syd barked!</code> </pre> <br>  Resulta que el valor de la constante <code>say</code> est√° vinculado a la funci√≥n que se devuelve desde la funci√≥n <code>prepareBark()</code> . <br><br>  Tenga en cuenta que, por <code>say</code> , cuando llama a <code>prepareBark()</code> nuevamente, obtiene un nuevo valor, mientras que el valor registrado en <code>say</code> primera vez que <code>prepareBark()</code> llama a <code>prepareBark()</code> no cambia.  El punto es que con cada llamada a esta funci√≥n, se crea un nuevo cierre. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre las funciones ordinarias y de flecha, sobre las caracter√≠sticas de su declaraci√≥n y uso, sobre c√≥mo se comporta <code>this</code> palabra clave en diferentes situaciones y sobre los cierres.  La pr√≥xima vez hablaremos de matrices y bucles. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo te sientes acerca de las funciones de flecha en JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430382/">https://habr.com/ru/post/es430382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430372/index.html">Coche de hidr√≥geno. ¬øEs hora de decir adi√≥s a la gasolina?</a></li>
<li><a href="../es430374/index.html">Ingenier√≠a de datos y m√°s: graba videos y diapositivas de la reuni√≥n</a></li>
<li><a href="../es430376/index.html">Gu√≠a de JavaScript Parte 6: Excepciones, punto y coma, plantillas literales</a></li>
<li><a href="../es430378/index.html">J2CL - Mejor tarde que nunca</a></li>
<li><a href="../es430380/index.html">Gu√≠a de JavaScript, parte 5: matrices y bucles</a></li>
<li><a href="../es430384/index.html">Crear mapas a partir de caracter√≠sticas de ruido</a></li>
<li><a href="../es430386/index.html">Planta de energ√≠a de almacenamiento de estado s√≥lido que se construir√° en India</a></li>
<li><a href="../es430388/index.html">Desconferencia de cumbre web</a></li>
<li><a href="../es430392/index.html">C√≥mo desarrollo y pruebo las API con mi "bicicleta" PieceofScript</a></li>
<li><a href="../es430394/index.html">Implementando b√∫squeda instant√°nea en Android usando RxJava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>