<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚒 👶 📱 启动Predator-预编译的数据存储库 😈 ❓ 🎉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，对象计算公司（OCI）的Micronaut团队推出了Predator ，这是一个新的开源项目，其目标是显着改善微服务和无服务器应用程序的数据访问的运行时间和性能（从内存）（从内存中）。与GORM和Spring Data之类的工具相比。 
 数据访问工具的历史记录 


我们可以跟踪自2004年...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>启动Predator-预编译的数据存储库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460839/"><p><img src="https://habrastorage.org/webt/zy/lo/n1/zylon1nrzso3rt7yshzjaia3krg.jpeg"></p><br><p> 今天，对象计算公司（OCI）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut</a>团队推出了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Predator</a> ，这是一个新的开源项目，其目标是显着改善微服务和无服务器应用程序的数据访问的运行时间和性能（从内存）（从内存中）。与GORM和Spring Data之类的工具相比。 </p><a name="habracut"></a><br><h2 id="istoriya-instrumentov-dostupa-k-dannym"> 数据访问工具的历史记录 </h2><br><p>我们可以跟踪自2004年Ruby on Rails推出ActiveRecord子系统以来的数据存储库模板的历史记录，该API彻底改变了我们对开发人员生产力的数据访问理解。 </p><br><p> 在2007年，Grails团队首先为JVM引入了类似于ActiveRecord的API-GORM（Grails的一部分）。  GORM依靠Groovy的动态特性在Hibernate之上实现搜索方法，并为JVM用户提供了相同的生产力优势。 </p><br><p>由于GORM依赖于Groovy语言，因此Spring Data项目创建于2011年，该项目允许Java开发人员在界面中定义搜索方法（例如<code>findByTitle</code> ，并在运行时自动实现查询逻辑。 </p><br><h2 id="kak-rabotayut-instrumenty-dostupa-k-dannym"> 数据访问工具如何工作 </h2><br><p> 所有提到的实现都使用相同的模板，该模板在运行时构建项目实体的元模型，以对实体类之间的关系进行建模。 在Spring Data中，它是一个MappingContext，在GORM中，它也称为MappingContext。 通过使用反射扫描类来构造它们。  （这里的命名相似并非偶然。2010年，我与Spring Data团队合作，尝试为一个项目重新创建Java的GORM，该项目最终变成了今天的Spring Data。） </p><br><p> 然后，使用正则表达式分析和框架逻辑的组合，使用此元模型在运行时将诸如<code>bookRepository.findByTitle("The Stand")</code>类的搜索表达式转换为抽象查询模型。 我们需要一个抽象查询模型，因为查询的目标方言对于每个数据库（SQL，JPA-QL，Cypher，Bson等）都是不同的 </p><br><h2 id="podderzhka-repozitoriev-v-micronaut">  Micronaut存储库支持 </h2><br><p> 自从一年多前推出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Micronaut</a>以来，我们被问到的主要缺失功能是“ GORM for Java”或Spring Data支持。 如此众多的开发人员爱上了这些工具所提供的生产力，以及对定义框架实现的接口的便捷性。 我想说，Grails和Spring Boot的大部分成功都可以分别归功于GORM和Spring Data。 </p><br><p> 对于使用Groovy的Micronaut用户，我们从一开始就获得了GORM支持，而Java和Kotlin用户则一无所有，因为他们需要自己实现存储库。 </p><br><p> 坦率地说，为Micronaut添加一个配置Spring Data的模块在技术上是可能的，并且坦率地说更容易。 但是，按照这条路径，我们将提供一个使用Micronaut试图避免的所有方法实现的子系统：代理的广泛使用，反射和高内存消耗。 </p><br><h2 id="predstavlyaem-predator"> 引入捕食者！ </h2><br><p>  Predator是Precomputed Data Repositories的缩写，它使用Micronaut API在执行之前进行编译（AoT，提前进行），以转移实体的元模型并将搜索表达式（例如<code>findByTitle</code> ）转换为适当的SQL或JPA-QL，供您的编译器使用。 结果，该查询执行了一个非常薄的程序运行时层而没有反射，并且仅保留它来运行查询并返回结果。 </p><br><p> 结果是压倒性的……冷启动大大减少了，我们获得了惊人的低内存消耗，并且性能得到了极大的提高。 </p><br><p> 今天，我们在Apache 2许可下开放了Predator的源代码，它将为JPA（基于Hibernate）和带有JDBC的SQL提供两个初始实现（计划在将来提供更多功能）。 </p><br><p>  JDBC实现令我最满意的是，因为它完全独立于反射，不为数据访问级别使用代理和动态类加载，从而提高了性能。 运行时层非常轻巧，即使手工编写的等效存储库代码也不会更快地执行。 </p><br><h2 id="proizvoditelnost-predator"> 表现掠食者 </h2><br><p> 由于Predator不需要在运行时执行任何查询转换，因此性能提升非常明显。 在云计算利用率的世界中，您需要为应用程序的运行时间或执行单个功能付出时间，而开发人员通常会忽略其数据访问机制的性能。 </p><br><p> 下表总结了与其他实现相比，简单搜索表达式（如<code>findByTitle</code>可以预期的性能差异。 所有测试都是在相同条件下使用8核Xeon iMac Pro的测试平台进行的，这些测试是开放的，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在存储库中</a>找到： </p><br><div class="scrollable-table"><table><thead><tr><th> 实作 </th><th> 每秒操作 </th></tr></thead><tbody><tr><td> 捕食者JDBC </td><td>  225K次/秒 </td></tr><tr><td> 捕食者JPA </td><td>  13万次/秒 </td></tr><tr><td> 春季数据JPA </td><td>  90K次/秒 </td></tr><tr><td>  GORM JPA </td><td>  5万次操作/秒 </td></tr><tr><td>  Spring Data JDBC </td><td> 查找器不受支持 </td></tr></tbody></table></div><br><p> 是的，您没看错。 使用Predator JDBC，您可以预期性能比GORM提高近4倍，而Spring Data则提高2.5倍。 </p><br><p> 即使使用Predator JPA，与GORM相比，您也可以指望将性能提高2倍以上，与Spring Data JPA相比，可以提高40％。 </p><br><p> 查看使用Predator时与替代方法相比执行堆栈大小的差异： </p><br><p>  <strong>捕食者：</strong> </p><br><p><img src="https://habrastorage.org/webt/6_/5l/ns/6_5lnsvtlyng0zisy5updpoii30.png"></p><br><p>  <strong>捕食者JPA：</strong> </p><br><p><img src="https://habrastorage.org/webt/dw/us/bc/dwusbcyeubxeu8l-glmhgq0r7me.png"></p><br><p>  <strong>春季数据：</strong> </p><br><p><img src="https://habrastorage.org/webt/di/m2/uv/dim2uvimrgxvs4ksszq0gsxujkq.png"></p><br><p>  <strong>GORM：</strong> </p><br><p><img src="https://habrastorage.org/webt/ad/7z/rs/ad7zrsyjfc1-fpr-cm3vqp9cmle.png"></p><br><p> 在执行请求之前，Predator JDBC仅使用15帧，而Predator JPA使用30（主要是由于Hibernate），相比之下，Spring Data或GORM中使用了50多个堆栈帧。 这要归功于不使用反射的Micronaut AOP机制。 </p><br><p> 较短的stackrace还可简化应用程序调试。 在编译期间执行大部分工作的优点之一是，可以在应用程序启动之前检测到错误，从而大大改善了开发人员的体验。 我们会立即得到编译错误，而不是最常见错误的运行时错误。 </p><br><h2 id="proverki-vremeni-kompilyacii"> 编译时间检查 </h2><br><p> 存储库模板的大多数实现仅依赖于在运行时执行所有操作。 这意味着，如果开发人员在定义存储库的接口时犯了一个错误，则在实际启动应用程序之前，错误是不可见的。 </p><br><p> 这使我们失去了Java用于类型检查的某些好处，并且我们的数据经验很差。 捕食者不是这种情况。 考虑以下示例： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JdbcRepository</span></span>(dialect = Dialect.H2) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Book </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span></span>; }</code> </pre> <br><p> 在这里， <code>BookRepository</code>我们声明了对名为<code>Book</code>的对象的请求，该对象具有<code>title</code>属性。 不幸的是，此声明中有一个错误：我们将<code>findByTile</code>方法命名为而不是<code>findByTitle</code> 。 除运行此代码外，Predator不允许您的代码编译时显示一条错误消息： </p><br><pre> <code class="plaintext hljs">Error:(9, 10) java: Unable to implement Repository method: BookRepository.findByTile(String title). Cannot use [Equals] criterion on non-existent property path: tile</code> </pre> <br><p> 可能时，会在编译时检查Predator的许多方面，以确保运行时错误不是由错误的存储库声明引起的。 </p><br><h2 id="predator-jdbc-i-graalvm-substrate"> 捕食者JDBC和GraalVM底物 </h2><br><p>  Predator满意的另一个原因是，它与本机GraalVM Substrate图像兼容，并且在构建过程中不需要复杂的字节码转换，这与在GraalVM上进行Hibernate操作不同。 </p><br><p> 通过完全消除数据访问层的反射和动态代理，Predator大大简化了与在GraalVM上运行的数据一起使用的应用程序的创建。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Predator JDBC示例应用程序</a>可以在Substrate上正常运行，并且由于运行时层更薄，因此您可以创建比Hibernate少得多的本机映像（少25 MB！）。 </p><br><p> 当我们为Micronaut 1.2实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bean验证规则编译</a>时，我们看到了相同的结果。 删除对Hibernate Validator的依赖关系后，本机映像大小将减少10 MB，而JAR大小将减少2 MB。 </p><br><p> 这里的优势是显而易见的：通过在编译期间进行更多工作并创建更紧凑的运行时，您可以获得更小的本机映像和JAR文件，从而在通过Docker进行部署时导致更小，更容易地部署微服务。  Java框架的未来是功能更强大的编译器和更小，更轻便的运行时。 </p><br><h2 id="predator-i-buduschee"> 捕食者与未来 </h2><br><p> 我们刚刚开始与Predator合作，并对其带来的机会感到非常满意。 </p><br><p> 最初，我们从对JPA和SQL的支持开始，但是在将来，您可以期望对MongoDB，Neo4J，Reactive SQL和其他数据库的支持。 幸运的是，这项工作要简单得多，因为大多数Predator实际上都是基于GORM源代码的，我们可以为Neo4J重用GORM逻辑，为MongoDB重用GORM，以比您期望的更快地发布这些实现。 </p><br><p>  Predator是将Micronaut Core中的各种构建块结合在一起的最终产物，从可以用于生成Swagger文档的AoT API到相对较新的Bean自省支持，它使您可以在运行时分析对象而无需进行反射，从而使其得以实现。 </p><br><p>  Micronaut提供了令人惊奇的事物的构建块。 捕食者就是这样的事情，我们才刚刚开始研究Micronaut 1.0的一些有前途的功能。 </p><br><p> 更新：令人震惊的公告后，Spring Data Killer被重命名为Micronaut Data： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ://micronaut-projects.github.io/micronaut-data/1.0.x/guide/ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460839/">https://habr.com/ru/post/zh-CN460839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460825/index.html">Screen Capture API简介-在浏览器中扫描QR码</a></li>
<li><a href="../zh-CN460827/index.html">PGP问题</a></li>
<li><a href="../zh-CN460831/index.html">设计师的危险</a></li>
<li><a href="../zh-CN460833/index.html">物理与经济学。 性别学差异及其在IT中的体现</a></li>
<li><a href="../zh-CN460837/index.html">初学者播客手册</a></li>
<li><a href="../zh-CN460841/index.html">TOP-23语言学习应用</a></li>
<li><a href="../zh-CN460843/index.html">引入新的3CX呼叫流程设计器和3CX CRM模板生成器</a></li>
<li><a href="../zh-CN460845/index.html">费尔南多·科尔巴托（Fernando Corbato），您的计算机之父（和密码），享年93岁。</a></li>
<li><a href="../zh-CN460847/index.html">1230万个并发WebSocket</a></li>
<li><a href="../zh-CN460849/index.html">第4部分。用于计算异步并行进程的逻辑函数的图形模型</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>