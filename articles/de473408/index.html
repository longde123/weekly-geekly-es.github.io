<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüîß ü§πüèº ü•Å Das Debuggen von versteckten Speicherlecks in Ruby üìï ‚úçÔ∏è ü§∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2015 schrieb ich √ºber die Tools, die Ruby zum Erkennen von verwalteten Speicherlecks bereitstellt. In dem Artikel ging es haupts√§chlich um leicht hand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Debuggen von versteckten Speicherlecks in Ruby</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473408/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/sf/qs/vxsfqsmdrslng_xf3oslr5os3ge.jpeg"></div><br>  2015 schrieb ich √ºber die Tools, die Ruby zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkennen von verwalteten Speicherlecks</a> bereitstellt.  In dem Artikel ging es haupts√§chlich um leicht handhabbare Lecks.  Dieses Mal werde ich √ºber Tools und Tricks sprechen, mit denen Sie Lecks beseitigen k√∂nnen, die in Ruby nicht so einfach zu analysieren sind.  Insbesondere werde ich √ºber mwrap, heaptrack, iseq_collector und chap sprechen. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cd/bda/07b/5cdbda07b31678a618b6f6205f5f9722.png"></div><br><h1>  Nicht verwaltete Speicherlecks </h1><br>  Dieses kleine Programm provoziert ein Leck mit einem direkten Aufruf an malloc.  Es beginnt mit einem Verbrauch von 16 MB RSS und endet mit 118 MB.  Der Code speichert 100.000 Bl√∂cke mit 1024 Bytes und l√∂scht 50.000 davon. <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'fiddle'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'objspace'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">`</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{Process.pid} -o rss -h`.strip.to_i * 1024 puts "RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}" end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374</span></span></span></span></code> </pre> <br>  Obwohl RSS 118 MB gro√ü ist, sind unserem Ruby-Objekt nur drei Megabyte bekannt.  In der Analyse sehen wir nur einen sehr kleinen Teil dieses sehr gro√üen Speicherverlusts. <br><br>  Ein echtes Beispiel f√ºr ein solches Leck ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oleg Dashevsky</a> . Ich empfehle, diesen wunderbaren Artikel zu lesen. <br><br><h1>  Wenden Sie Mwrap an </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mwrap</a> ist ein Speicherprofiler f√ºr Ruby, der alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenzuordnungen</a> im Speicher √ºberwacht, indem er Malloc und andere Funktionen dieser Familie abf√§ngt.  Es f√§ngt Aufrufe ab, die diesen Ort und den freien Speicher mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LD_PRELOAD freigeben</a> .  Es verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liburcu</a> zum Z√§hlen und kann Zuordnungs- und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂schz√§hler</a> f√ºr jeden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufrufpunkt</a> in C- und Ruby-Code verfolgen.  Mwrap ist klein, etwa doppelt so gro√ü wie RSS f√ºr ein Profilprogramm und etwa doppelt so langsam. <br><br>  Es unterscheidet sich von vielen anderen Bibliotheken durch seine sehr geringe Gr√∂√üe und Ruby-Unterst√ºtzung.  Es verfolgt Speicherorte in Ruby-Dateien und ist nicht auf Valgrind + Masif C-Level-Backtracks und √§hnliche Profiler beschr√§nkt.  Dies vereinfacht die Isolierung der Problemquellen erheblich. <br><br>  Um den Profiler zu verwenden, m√ºssen Sie die Anwendung √ºber die Mwrap-Shell ausf√ºhren. Sie implementiert die LD_PRELOAD-Umgebung und f√ºhrt die Ruby-Bin√§rdatei aus. <br><br>  F√ºgen wir Mwrap zu unserem Skript hinzu: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'mwrap'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_leaks</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mwrap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocations</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frees</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age_total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_lifespan</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;&lt;</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((total / allocations.to_f)</span></span></span></span> * (allocations - frees)), allocations, frees] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results.sort! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|(_, growth_a), (_, growth_b)|</span></span> growth_b &lt;=&gt; growth_a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">20</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|location, growth, allocations, frees|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> growth == <span class="hljs-number"><span class="hljs-number">0</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{location}</span></span></span><span class="hljs-string"> growth: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{growth.to_i}</span></span></span><span class="hljs-string"> allocs/frees (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{allocations}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{frees}</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear leak_memory GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  F√ºhren Sie nun das Skript mit dem Mwrap-Wrapper aus: <br><br><pre> <code class="ruby hljs">% gem install mwrap % mwrap ruby leak.rb leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">51200000</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">100000</span></span>/<span class="hljs-number"><span class="hljs-number">50000</span></span>) leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">4008</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Mwrap hat ein Leck im Skript korrekt erkannt (50.000 * 1024).  Und nicht nur bestimmt, sondern auch eine bestimmte Linie isoliert ( <code>i = Fiddle.malloc(1024)</code> ), die zu einem Leck f√ºhrte.  Der Profiler hat es korrekt an Aufrufe von <code>Fiddle.free</code> gebunden. <br><br>  Es ist wichtig zu beachten, dass es sich um eine Bewertung handelt.  Mwrap √ºberwacht den vom Dial Peer zugewiesenen gemeinsam genutzten Speicher und anschlie√üend die Speicherfreigabe.  Wenn Sie jedoch einen Aufrufpunkt haben, der Speicherbl√∂cke unterschiedlicher Gr√∂√üe zuweist, ist das Ergebnis ungenau.  Wir haben Zugriff auf die Bewertung: <code>((total / allocations) * (allocations - frees))</code> <br><br>  Um die Leckverfolgung zu vereinfachen, verfolgt Mwrap au√üerdem <code>age_total</code> , die Summe der Lebensdauer jedes freigegebenen Elements, und <code>max_lifespan</code> , die Lebensdauer des √§ltesten Elements am <code>max_lifespan</code> .  Wenn <code>age_total / frees</code> gro√ü ist, steigt der Speicherverbrauch trotz zahlreicher Speicherbereinigungen. <br><br>  Mwrap hat mehrere Helfer, um L√§rm zu reduzieren.  <code>Mwrap.clear</code> den gesamten internen Speicher.  <code>Mwrap.quiet {}</code> zwingt Mwrap, den Codeblock zu verfolgen. <br><br>  Ein weiteres Unterscheidungsmerkmal von Mwrap ist die Verfolgung der Gesamtzahl der zugewiesenen und freigegebenen Bytes.  Entfernen Sie <code>clear</code> aus dem Skript und f√ºhren Sie es aus: <br><br><pre> <code class="ruby hljs">usage puts <span class="hljs-string"><span class="hljs-string">"Tracked size: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691</span></span></code> </pre> <br>  Das Ergebnis ist sehr interessant, da Mwrap trotz der RSS-Gr√∂√üe von 130 MB nur 91 MB sieht.  Dies deutet darauf hin, dass wir unseren Prozess aufgeblasen haben.  Die Ausf√ºhrung ohne Mwrap zeigt, dass der Prozess in einer normalen Situation 118 MB dauert, und in diesem einfachen Fall betrug der Unterschied 12 MB.  Das Zuordnungs- / Freigabemuster f√ºhrte zu einer Fragmentierung.  Dieses Wissen kann sehr n√ºtzlich sein, in einigen F√§llen fragmentieren die nicht konfigurierten glibc malloc-Prozesse so stark, dass die sehr gro√üe Menge an Speicher, die in RSS verwendet wird, tats√§chlich frei ist. <br><br><h1>  Kann Mwrap ein altes Leck auf dem roten Teppich isolieren? </h1><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem Artikel beschreibt</a> Oleg einen sehr gr√ºndlichen Weg, um ein sehr d√ºnnes Leck im roten Teppich zu isolieren.  Es gibt viele Details.  Es ist sehr wichtig, Messungen durchzuf√ºhren.  Wenn Sie keine Zeitleiste f√ºr den RSS-Prozess erstellen, ist es unwahrscheinlich, dass Sie Lecks beseitigen k√∂nnen. <br><br>  Lassen Sie uns in eine Zeitmaschine einsteigen und zeigen, wie viel einfacher es ist, Mwrap f√ºr solche Lecks zu verwenden. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">red_carpet_leak</span></span></span><span class="hljs-function"> 100</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markdown</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redcarpet</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Markdown</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Redcarpet::Render::HTML, extensions = {})</span></span></span></span> markdown.render(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear red_carpet_leak GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Redcarpet 3.3.2: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000)</code> </pre> <br>  Redcarpet 3.5.0: <br><br><pre> <code class="plaintext hljs">redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000)</code> </pre> <br>  Wenn Sie es sich leisten k√∂nnen, den Prozess mit der halben Geschwindigkeit auszuf√ºhren, indem Sie ihn einfach im Mwrap-Produkt neu starten und das Ergebnis in einer Datei protokollieren, k√∂nnen Sie eine Vielzahl von Speicherlecks identifizieren. <br><br><h1>  Geheimnisvolles Leck </h1><br>  Vor kurzem wurde Rails auf Version 6 aktualisiert. Im Allgemeinen war die Erfahrung sehr positiv, die Leistung blieb ungef√§hr gleich.  Rails 6 hat einige sehr gute Funktionen, die wir verwenden werden (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitwerk</a> ).  Rails hat die Art und Weise ge√§ndert, in der die Vorlagen gerendert wurden. Aus Kompatibilit√§tsgr√ºnden waren einige √Ñnderungen erforderlich.  Einige Tage nach dem Update stellten wir einen Anstieg des RSS f√ºr Sidekiq-Task-Performer fest. <br><br>  Mwrap meldete einen starken Anstieg des Speicherverbrauchs aufgrund seiner Zuordnung ( <a href="">Link</a> ): <br><br><pre> <code class="ruby hljs"> source.encode! <span class="hljs-comment"><span class="hljs-comment"># Now, validate that the source we got back from the template # handler is valid in the default_internal. This is for handlers # that handle encoding but screw up unless source.valid_encoding? raise WrongEncodingError.new(source, Encoding.default_internal) end begin mod.module_eval(source, identifier, 0) rescue SyntaxError # Account for when code in the template is not syntactically valid; eg if we're using # ERB and the user writes &lt;%= foo( %&gt;, attempting to call a helper `foo` and interpolate # the result into the template, but missing an end parenthesis. raise SyntaxErrorInTemplate.new(self, original_source) end end def handle_render_error(view, e) if e.is_a?(Template::Error)</span></span></code> </pre> <br>  Zuerst waren wir sehr verwirrt.  Wir haben versucht zu verstehen, warum wir mit Mwrap unzufrieden sind.  Vielleicht ist er pleite?  Als der Speicherverbrauch zunahm, blieben die Haufen in Ruby unver√§ndert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/79b/b60/7d079bb600f7d072515d081bb584c500.png"><br><br>  Zwei Millionen Slots im Heap verbrauchten nur 78 MB (40 Bytes pro Slot).  Linien und Arrays k√∂nnen mehr Platz beanspruchen, aber es hat den beobachteten abnormalen Speicherverbrauch immer noch nicht erkl√§rt.  Dies wurde best√§tigt, als ich <code>rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all</code> . <br><br>  Wo ist die Erinnerung geblieben? <br><br><h1>  Heaptrack </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heaptrack</a> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heapspeicher-</a> Profiler f√ºr Linux. <br><br>  Milian Wolff <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erkl√§rte</a> perfekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> wie der Profiler funktioniert, und sprach in mehreren Reden dar√ºber ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> ).  Tats√§chlich handelt es sich um einen sehr effizienten nativen Heap-Profiler, der mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libunwind</a> Backtraces von profilierten Anwendungen sammelt.  Es arbeitet merklich schneller als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Valgrind / Massif</a> und hat die F√§higkeit, es f√ºr die tempor√§re Profilerstellung im Produkt viel bequemer zu machen.  Es kann an einen bereits laufenden Prozess angeh√§ngt werden! <br><br>  Wie bei den meisten Heap-Profilern muss Heaptrack z√§hlen, wenn jede Funktion in der Malloc-Familie aufgerufen wird.  Dieser Vorgang verlangsamt den Prozess definitiv ein wenig. <br><br>  Meiner Meinung nach ist die Architektur hier die bestm√∂gliche.  Das Abfangen erfolgt mit <code>LD_PRELOAD</code> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDB</a> , um den Profiler zu laden.  Mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speziellen FIFO-Datei</a> √ºbertr√§gt er Daten aus dem Profilierungsprozess so schnell wie m√∂glich.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heaptrack-</a> Wrapper ist ein einfaches Shell-Skript, das das Auffinden eines Problems erleichtert.  Der zweite Prozess liest Informationen aus dem FIFO und komprimiert die Tracking-Daten im laufenden Betrieb.  Da Heaptrack mit ‚ÄûChunks‚Äú arbeitet, k√∂nnen Sie das Profil innerhalb von Sekunden nach Beginn der Profilerstellung mitten in der Sitzung analysieren.  Kopieren Sie einfach die Profildatei an einen anderen Speicherort und starten Sie die Heaptrack-GUI. <br><br>  Dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab-Ticket</a> erz√§hlte mir von der M√∂glichkeit, Heaptrack zu starten.  Wenn sie es ausf√ºhren k√∂nnten, k√∂nnte ich es. <br><br>  Unsere Anwendung wird in einem Container ausgef√ºhrt, und ich muss sie mit <code>--cap-add=SYS_PTRACE</code> neu starten. <code>--cap-add=SYS_PTRACE</code> kann GDB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptrace verwenden</a> , das erforderlich ist, damit Heaptrack sich selbst injiziert.  Ich ben√∂tige auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleinen Hack</a> f√ºr die Shell-Datei, um <code>root</code> auf das Profil des Nicht- <code>root</code> Prozesses anzuwenden (wir haben unsere Discourse-Anwendung im Container unter einem begrenzten Konto gestartet). <br><br>  Nachdem alles erledigt ist, m√ºssen Sie nur noch die <code>heaptrack -p PID</code> ausf√ºhren und warten, bis die Ergebnisse <code>heaptrack -p PID</code> .  Heaptrack erwies sich als hervorragendes Tool. Es war sehr einfach, alles zu verfolgen, was mit Speicherlecks passiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/9ad/a55/72c9ada55ca01cb02e06d1b433fab705.png"><br><br>  In der Grafik sehen Sie zwei Spr√ºnge, einen aufgrund von <code>cppjieba</code> und einen aufgrund von <code>objspace_xmalloc0</code> in Ruby. <br><br>  Ich wusste von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cppjieba</a> .  Das Segmentieren der chinesischen Sprache ist teuer. Sie ben√∂tigen gro√üe W√∂rterb√ºcher, sodass dies kein Leck ist.  Aber was ist mit dem Zuweisen von Speicher in Ruby, was mir das immer noch nicht sagt? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/340/72a/c57/34072ac5776eea391854dabe54f18056.png"><br><br>  Die Hauptverst√§rkung h√§ngt mit <code>iseq_set_sequence</code> in <code>compile.c</code> .  Es stellt sich heraus, dass das Leck auf Anweisungen zur√ºckzuf√ºhren ist.  Dies beseitigte das von Mwrap entdeckte Leck.  Die Ursache war <code>mod.module_eval(source, identifier, 0)</code> , wodurch Folgen von Anweisungen erstellt wurden, die nicht aus dem Speicher gel√∂scht wurden. <br><br>  Wenn ich in einer retrospektiven Analyse sorgf√§ltig einen Heap-Dump von Ruby in Betracht gezogen h√§tte, h√§tte ich all diese IMEMOs bemerkt, da sie in diesem Dump enthalten sind.  Sie sind w√§hrend der In-Process-Diagnose einfach unsichtbar. <br><br>  Von diesem Zeitpunkt an war das Debuggen ziemlich einfach.  Ich habe alle Aufrufe des Eval-Moduls verfolgt und die ausgewerteten Daten gespeichert.  Ich fand heraus, dass wir einer gro√üen Klasse immer wieder Methoden hinzuf√ºgen.  Hier ist eine vereinfachte Ansicht des Fehlers, auf den wir gesto√üen sind: <br><br><pre> <code class="python hljs">require <span class="hljs-string"><span class="hljs-string">'securerandom'</span></span> module BigModule; end <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_methods</span></span></span><span class="hljs-function"> 10</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> = "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_</span></span></span><span class="hljs-function">#{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-function">}; #{"</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">;" * 100}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigModule</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSS</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">16164</span></span> ObjectSpace size <span class="hljs-number"><span class="hljs-number">2869</span></span> leak_methods usage <span class="hljs-comment"><span class="hljs-comment"># RSS: 123096 ObjectSpace size 5583</span></span></code> </pre> <br>  Ruby hat eine Klasse zum Speichern von <code>RubyVM::InstructionSequence</code> Befehlssequenzen: <code>RubyVM::InstructionSequence</code> .  Ruby ist jedoch zu faul, um diese Wrapper-Objekte zu erstellen, da das unn√∂tige Speichern ineffizient ist.  Koichi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sasada</a> hat die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iseq_collector-</a> Abh√§ngigkeit erstellt.  Wenn wir diesen Code hinzuf√ºgen, k√∂nnen wir unseren verborgenen Speicher finden: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iseq_collector'</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ObjectSpace.memsize_of_all_iseq / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 98747 ObjectSpace.memsize_of_all_iseq</span></span></code> </pre> <br>  materialisiert jede Folge von Anweisungen, was den Speicherverbrauch des Prozesses leicht erh√∂hen und dem Garbage Collector etwas mehr Arbeit geben kann. <br><br>  Wenn wir zum Beispiel die Anzahl der ISEQs vor und nach dem Starten des Kollektors berechnen, werden wir <code>ObjectSpace.memsize_of_all_iseq</code> unser Z√§hler der <code>RubyVM::InstructionSequence</code> Klasse nach dem Starten von <code>ObjectSpace.memsize_of_all_iseq</code> von 0 auf 11128 steigt (in diesem Beispiel): <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_iseqs</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectSpace</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RubyVM::InstructionSequence)</span></span></span></span>.count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Diese Wrapper bleiben w√§hrend der gesamten Lebensdauer der Methode erhalten. Sie m√ºssen mit einem vollst√§ndigen Lauf des Garbage Collectors besucht werden.  Unser Problem wurde gel√∂st, indem die Klasse, die f√ºr das Rendern von E-Mail-Vorlagen verantwortlich ist ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hotfix 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hotfix 2</a> ), wiederverwendet wurde. <br><br><h1>  Kap </h1><br>  W√§hrend des Debuggens habe ich ein sehr interessantes Tool verwendet.  Vor einigen Jahren hat Tim Boddy ein internes Tool herausgezogen, mit dem VMWare Speicherlecks analysiert, und den Code ge√∂ffnet.  Hier ist das einzige Video dazu, das ich gefunden habe: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=EZ2n3kGtVDk</a> .  Im Gegensatz zu den meisten √§hnlichen Tools hat dieses Tool keine Auswirkungen auf den ausf√ºhrbaren Prozess.  Es kann einfach auf die Dateien des Hauptdumps angewendet werden, w√§hrend glibc als Allokator verwendet wird (jemalloc / tcmalloc usw. werden nicht unterst√ºtzt usw.). <br><br>  Mit chap ist es sehr einfach, das Leck zu erkennen, das ich hatte.  Nur wenige Distributionen haben eine Chap-Bin√§rdatei, aber Sie k√∂nnen sie einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus dem Quellcode kompilieren</a> .  Er wird sehr aktiv unterst√ºtzt. <br><br><pre> <code class="plaintext hljs"># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes.</code> </pre> <br>  Chap kann Signaturen verwenden, um nach Speicherorten mit unterschiedlichem Speicher zu suchen, und GDB erg√§nzen.  Beim Debuggen in Ruby kann dies eine gro√üe Hilfe sein, um festzustellen, welchen Speicher der Prozess verwendet.  Es zeigt den insgesamt verwendeten Speicher, manchmal kann glibc malloc so stark fragmentieren, dass das verwendete Volume sehr stark vom tats√§chlichen RSS abweichen kann.  Sie k√∂nnen die Diskussion lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Feature # 14759: [PATCH] set M_ARENA_MAX f√ºr glibc malloc - Ruby Master - Ruby Issue Tracking System</a> .  Chap ist in der Lage, den gesamten verwendeten Speicher korrekt zu z√§hlen und eine eingehende Analyse seiner Zuordnung bereitzustellen. <br><br>  Dar√ºber hinaus kann chap in Workflows integriert werden, um Lecks automatisch zu erkennen und solche Baugruppen zu kennzeichnen. <br><br><h1>  Follow-up-Arbeit </h1><br>  Diese Debugging-Runde hat mich dazu gebracht, einige Fragen zu unseren Helfer-Toolkits zu stellen: <br><br><ul><li>  Ich h√§tte gerne Unterst√ºtzung f√ºr die Erfassung von Call-Stack-Frames von Ruby in Heaptrack.  Milian interessiert sich auch daf√ºr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">412929 - K√∂nnen wir uns einen Rahmen aus Ruby Land schnappen?</a> <br></li><li>  Ich m√∂chte, dass Ruby umfassendere Diagnosefunktionen unterst√ºtzt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.ruby-lang.org/issues/16245</a> <br></li><li>  Ich m√∂chte, dass Mwrap im Produkt etwas einfacher zu verwenden ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie hier</a> . </li></ul><br><h1>  Zusammenfassung </h1><br>  Unser heutiges Toolkit zum Debuggen sehr komplexer Speicherlecks ist viel besser als vor 4 Jahren!  Mwrap, Heaptrack und Chap sind sehr leistungsf√§hige Tools zur L√∂sung von Speicherproblemen, die w√§hrend der Entwicklung und des Betriebs auftreten. <br><br>  Wenn Sie nach einem einfachen Speicherverlust in Ruby suchen, empfehle ich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen Artikel von 2015 zu</a> lesen, der gr√∂√ütenteils relevant ist. <br><br>  Ich hoffe, Sie finden es einfacher, wenn Sie das n√§chste Mal mit dem Debuggen eines komplexen nativen Speicherverlusts beginnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473408/">https://habr.com/ru/post/de473408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473392/index.html">Wie starten wir eine neue Bank-Site? Teil 2</a></li>
<li><a href="../de473394/index.html">Ihr alle l√ºgt! √úber CRM-Werbung</a></li>
<li><a href="../de473396/index.html">Wir brauchen noch eine Bitrix</a></li>
<li><a href="../de473400/index.html">Hochwertige, leichte und anpassungsf√§hige Text-to-Speech-Technologie mit LPCNet</a></li>
<li><a href="../de473406/index.html">Freier Marathon "Data Science and AI: Bringen Sie der Maschine bei, das Skript f√ºr die Serie zu schreiben"</a></li>
<li><a href="../de473412/index.html">Erstellen eines Plugins f√ºr Clang Static Analyzer zur Suche nach Ganzzahl√ºberl√§ufen</a></li>
<li><a href="../de473416/index.html">ZeroNights 2019 Konferenzprogramm</a></li>
<li><a href="../de473418/index.html">OSCP - Offensive Sicherheit</a></li>
<li><a href="../de473420/index.html">Wir er√∂ffnen die Saison der PHP-Meetups am 2. November in Nischni Nowgorod</a></li>
<li><a href="../de473424/index.html">ARM k√ºndigte die Grafikl√∂sungen Mali-G57 Valhall und Mali-D37 sowie die Neuroprozessoren Ethos-N57 und N37 an</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>