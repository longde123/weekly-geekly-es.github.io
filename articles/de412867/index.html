<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏽 🎽 👩🏾‍🏫 Kompilieren der DOS-COM-Datei mit dem GCC-Compiler 🖖🏿 🛥️ 👃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel veröffentlicht am 9. Dezember 2014 
 Update für 2018: RenéRebe hat ein interessantes Video basierend auf diesem Artikel gemacht ( Teil 2 ) 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilieren der DOS-COM-Datei mit dem GCC-Compiler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412867/"> <font color="gray">Artikel veröffentlicht am 9. Dezember 2014</font> <br>  <i>Update für 2018: RenéRebe hat ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessantes Video</a> basierend auf diesem Artikel gemacht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> )</i> <br><br>  Letztes Wochenende habe ich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ludum Dare # 31</a> teilgenommen.  Aber noch bevor die Konferenz angekündigt wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> wollte ich wegen meines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jüngsten Hobbys</a> ein Spiel der alten Schule unter DOS machen.  Die Zielplattform ist DOSBox.  Dies ist die praktischste Methode zum Ausführen von DOS-Anwendungen, obwohl alle modernen x86-Prozessoren bis zum 16-Bit-8086 vollständig abwärtskompatibel mit alten sind. <br><br>  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOS Defender-</a> Spiel erfolgreich erstellt und auf der Konferenz gezeigt.  Das Programm arbeitet im Real-Modus des 32-Bit-80386. Alle Ressourcen sind in die ausführbare COM-Datei integriert, keine externen Abhängigkeiten, sodass das Spiel vollständig in eine 10-Kilobyte-Binärdatei gepackt ist. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/skeeto/dosdefender-ld31</a> </li><li>  <a href="">DOSDEF.COM</a> (10 KB, v1.1.0, funktioniert in DOSBox) </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/na/qs/aynaqsaenvt32x5oa8y7z4fmnfy.gif"></div><a name="habracut"></a><br>  Zum Spielen benötigen Sie einen Joystick oder ein Gamepad.  Ich habe die Mausunterstützung für die Präsentation in die Veröffentlichung für Ludum Dare aufgenommen, sie dann aber gelöscht, weil sie nicht sehr gut funktioniert hat. <br><br>  Der technisch interessanteste Teil ist, dass <b><i>keine</i> DOS-Entwicklungstools benötigt wurden, um das Spiel zu erstellen</b> !  Ich habe nur den regulären Linux C-Compiler (gcc) verwendet.  In Wirklichkeit können Sie nicht einmal einen DOS Defender für DOS erstellen.  Ich sehe DOS nur als eingebettete Plattform, die die einzige Form ist, in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOS heute noch existiert</a> .  Zusammen mit DOSBox und DOSEMU ist dies ein ziemlich praktischer Satz von Werkzeugen. <br><br>  Wenn Sie sich nur für den praktischen Teil der Entwicklung interessieren, gehen Sie zum Abschnitt „Cheat on GCC“, in dem wir das DOS-COM-Programm „Hello, World“ mit GCC Linux schreiben. <br><br><h1>  Die richtigen Werkzeuge finden </h1><br>  Als ich dieses Projekt startete, dachte ich nicht an GCC.  In Wirklichkeit ging ich diesen Weg, als ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bcc-</a> Paket (Bruce's C Compiler) für Debian entdeckte, das 16-Bit-Binärdateien für 8086 kompiliert. Es wird zum Kompilieren von x86-Bootloadern und anderen Dingen verwendet, aber bcc kann auch zum Kompilieren von DOS-COM-Dateien verwendet werden.  Es hat mich interessiert. <br><br>  Als Referenz: Der Intel 8086 16-Bit-Mikroprozessor wurde 1978 veröffentlicht.  Es hatte keine bizarren Eigenschaften moderner Prozessoren: keinen Speicherschutz, keine Gleitkommaanweisungen und nur 1 MB adressierbaren RAM.  Alle modernen x86-Desktops und -Laptops können sich noch vor vierzig Jahren als dieser 16-Bit-Prozessor 8086 ausgeben, mit der gleichen eingeschränkten Adressierung und all dem.  Dies ist eine ziemlich abwärtskompatibel.  Eine solche Funktion wird als <i>Real-Modus bezeichnet</i> .  Dies ist der Modus, in dem alle x86-Computer gestartet werden.  Moderne Betriebssysteme wechseln sofort in den <i>geschützten Modus</i> mit virtueller Adressierung und sicherem Multitasking.  DOS hat das nicht getan. <br><br>  Leider ist bcc kein ANSI C-Compiler. Es unterstützt eine Teilmenge von K &amp; R C sowie integrierten x86-Assembler-Code.  Im Gegensatz zu anderen 8086 C-Compilern gibt es kein Konzept für "ferne" oder "lange" Zeiger. Daher ist integrierter Assembler-Code erforderlich, um auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Speichersegmente</a> (VGA, Uhren usw.) zuzugreifen.  Hinweis: Die Überreste dieser "langen Zeiger" 8086 bleiben in der Win32-API erhalten: <code>LPSTR</code> , <code>LPWORD</code> , <code>LPDWORD</code> usw. Dieser integrierte Assembler ist nicht einmal eng mit dem integrierten Assembler GCC vergleichbar.  In Assembler müssen Sie Variablen manuell aus dem Stapel laden. Da bcc zwei verschiedene Aufrufkonventionen unterstützt, sollten die Variablen im Code gemäß der einen oder anderen Konvention fest codiert werden. <br><br>  Angesichts dieser Einschränkungen habe ich mich entschlossen, nach Alternativen zu suchen. <br><br><h1>  DJGPP </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DJGPP</a> - GCC-Port unter DOS.  Ein wirklich sehr beeindruckendes Projekt, das fast die gesamte POSIX unter DOS überträgt.  Viele DOS-portierte Programme werden auf DJGPP erstellt.  Er erstellt jedoch nur 32-Bit-Programme für den geschützten Modus.  Wenn Sie im geschützten Modus mit Hardware (z. B. VGA) arbeiten müssen, sendet das Programm Anforderungen an den Dienst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der DOS-Schnittstelle</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den geschützten Modus</a> (DPMI).  Wenn ich DJGPP genommen hätte, hätte ich mich nicht auf eine einzelne Standalone-Binärdatei beschränken können, da ich einen DPMI-Server haben müsste.  Die Leistung leidet auch unter Anfragen nach DPMI. <br><br>  Die notwendigen Tools für DJGPP zu bekommen ist, gelinde gesagt, schwierig.  Glücklicherweise habe ich ein nützliches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">build-djgpp-</a> Projekt gefunden, das alles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführt</a> , zumindest unter Linux. <br><br>  Entweder gab es einen schwerwiegenden Fehler oder die offiziellen DJGPP-Binärdateien wurden erneut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit dem Virus infiziert</a> , aber als ich meine Programme in DOSBox startete, wurde ständig der Fehler "Nicht COFF: Auf Viren prüfen" angezeigt.  Um weiter zu überprüfen, ob sich die Viren nicht auf meinem eigenen Computer befinden, habe ich die DJGPP-Umgebung auf meinem Raspberry Pi eingerichtet, der als Reinraum fungiert.  Dieses ARM-basierte Gerät kann nicht mit dem x86-Virus infiziert werden.  Und immer noch trat das gleiche Problem auf, und alle binären Hashes waren zwischen den Maschinen gleich, also ist es nicht meine Schuld. <br><br>  Angesichts dieses und des DPMI-Problems begann ich weiter zu suchen. <br><br><h1>  Narren gcc </h1><br>  Was ich schließlich beschlossen habe, war der knifflige Trick, GCC zu „betrügen“, um DOS-COM-Dateien im Real-Modus zu erstellen.  Der Trick funktioniert bis zu 80386 (was normalerweise erforderlich ist).  Der 80386-Prozessor wurde 1985 auf den Markt gebracht und war der erste 32-Bit-x86-Mikroprozessor.  GCC hält sich auch in x86-64-Umgebungen an diese Anweisungen.  Leider kann GCC in keiner Weise 16-Bit-Code produzieren, so dass ich das ursprüngliche Ziel, ein Spiel für 8086 zu entwickeln, aufgeben musste.  Dies spielt jedoch keine Rolle, da die Ziel-DOSBox-Plattform im Wesentlichen ein 80386-Emulator ist. <br><br>  Theoretisch sollte der Trick auch im MinGW-Compiler funktionieren, aber es gibt einen langjährigen Fehler, der verhindert, dass er korrekt funktioniert („PE-Operationen können nicht für Nicht-PE-Ausgabedateien ausgeführt werden“).  Es kann jedoch umgangen werden, und ich habe es selbst gemacht: Sie sollten die Anweisung <code>OUTPUT_FORMAT</code> entfernen und einen zusätzlichen <code>objcopy</code> Schritt hinzufügen ( <code>objcopy -O binary</code> ). <br><br><h3>  Hallo Welt unter DOS </h3><br>  Zur Demonstration erstellen wir das DOS COM-Programm „Hello, World“ mit GCC unter Linux. <br><br>  Diese Methode weist ein großes und bedeutendes Hindernis auf: <b>Es wird keine Standardbibliothek geben</b> .  Es ist, als würde man ein Betriebssystem von Grund auf neu schreiben, mit Ausnahme einiger Dienste, die DOS bereitstellt.  Das heißt kein <code>printf()</code> oder ähnliches.  Stattdessen bitten wir DOS, die Zeichenfolge auf der Konsole zu drucken.  Das Erstellen einer DOS-Anforderung erfordert einen Interrupt, dh Inline-Assembler-Code! <br><br>  DOS hat neun Interrupts: 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x2F.  Das Wichtigste, was uns interessiert, ist 0x21, die Funktion 0x09 (Zeile drucken).  Zwischen DOS und BIOS gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tausende von Funktionen, die nach diesem Muster benannt sind</a> .  Ich werde nicht versuchen, den x86-Assembler zu erklären, aber kurz gesagt, die Funktionsnummer bleibt im <code>ah</code> Register hängen - und der 0x21-Interrupt wird ausgelöst.  Die Funktion 0x09 nimmt auch ein Argument an - einen Zeiger auf eine Zeile zum Drucken, die in den Registern <code>dx</code> und <code>ds</code> wird. <br><br>  Hier ist die <code>print()</code> Funktion des GCC-Inline-Assemblers.  An diese Funktion übergebene Zeilen müssen mit dem Zeichen $ enden.  Warum?  Weil DOS. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br>  Der Code wird als <code>volatile</code> deklariert, da er einen Nebeneffekt hat (Zeilendruck).  Für GCC ist der Assembler-Code undurchsichtig, und der Optimierer stützt sich auf Einschränkungen bei Ausgabe / Eingabe / Clobber (letzte drei Zeilen).  Für solche DOS-Programme hat jeder eingebaute Assembler Nebenwirkungen.  Dies liegt daran, dass es nicht für die Optimierung geschrieben wurde, sondern für den Zugriff auf Hardwareressourcen und DOS - Dinge, auf die einfaches C nicht zugreifen kann. <br><br>  Sie müssen sich auch um die aufrufende Anweisung kümmern, da GCC nicht weiß, dass der Speicher, auf den die <code>string</code> zeigt, jemals gelesen wurde.  Es ist wahrscheinlich, dass ein Array, das die Zeichenfolge unterstützt, ebenfalls als <code>volatile</code> deklariert werden muss.  All dies deutet auf das Unvermeidliche hin: Alle Aktionen in einer solchen Umgebung werden zu einem endlosen Kampf mit dem Optimierer.  Nicht alle diese Schlachten können gewonnen werden. <br><br>  Nun zur Hauptfunktion.  Sein Name ist im Prinzip nicht wichtig, aber ich vermeide es, ihn <code>main()</code> , weil MinGW lustige Ideen hat, wie man solche Charaktere spezifisch verarbeitet, auch wenn sie ihn bitten, dies nicht zu tun. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  COM-Dateien sind auf 65279 Byte begrenzt.  Dies liegt daran, dass das x86-Speichersegment 64 KB groß ist und DOS die COM-Dateien einfach auf die 0x0100-Segmentadresse herunterlädt und ausführt.  Keine Überschriften, nur eine saubere Binärdatei.  Da das COM-Programm im Prinzip keine signifikante Größe haben kann, sollte kein reales Layout (freistehend) auftreten, wird das Ganze als eine einzige Übersetzungseinheit kompiliert.  Dies ist ein GCC-Aufruf mit einer Reihe von Parametern. <br><br><h3>  Compiler-Optionen </h3><br>  Hier sind die wichtigsten Compileroptionen. <br><br> <code>-std=gnu99 -Os -nostdlib -m32 -march=i386 -ffreestanding</code> <br> <br>  Da Standardbibliotheken nicht verwendet werden, besteht der einzige Unterschied zwischen gnu99 und c99 in den getrennten Trigraphen (wie es sein sollte), und der integrierte Assembler kann als <code>asm</code> anstelle von <code>__asm__</code> .  Dies ist nicht Newtons Mülleimer.  Das Projekt wird so eng mit GCC verbunden sein, dass ich mir immer noch keine Sorgen um die GCC-Erweiterungen mache. <br><br>  Die Option <code>-Os</code> reduziert das Kompilierungsergebnis so weit wie möglich.  Das Programm wird also schneller arbeiten.  Dies ist im Hinblick auf DOSBox wichtig, da der Standardemulator langsam wie eine 80er-Maschine läuft.  Ich möchte in diese Einschränkung passen.  Wenn der Optimierer Probleme verursacht, <code>-O0</code> vorübergehend <code>-O0</code> um festzustellen, ob Ihr Fehler oder der Optimierer hier ist. <br><br>  Wie Sie sehen können, versteht der Optimierer nicht, dass das Programm im Real-Modus mit den entsprechenden Adressierungsbeschränkungen arbeitet.  <b>Es führt alle Arten von ungültigen Optimierungen durch, die Ihre perfekt gültigen Programme beschädigen.</b>  Dies ist kein GCC-Fehler, da wir selbst hier verrückte Dinge tun.  Ich musste den Code mehrmals wiederholen, um zu verhindern, dass der Optimierer das Programm bricht.  Zum Beispiel mussten wir vermeiden, komplexe Strukturen von Funktionen zurückzugeben, da diese manchmal mit Müll gefüllt waren.  Die wirkliche Gefahr besteht darin, dass die zukünftige Version von GCC noch intelligenter wird und noch mehr Code bricht.  Hier ist dein Freund <code>volatile</code> . <br><br>  Der nächste Parameter ist <code>-nostdlib</code> , da wir auch statisch keine Verknüpfung zu gültigen Bibliotheken herstellen können. <br><br>  Die Parameter <code>-m32-march=i386</code> Compiler an, den Code 80386 auszugeben. Wenn ich den Bootloader für einen modernen Computer schreiben würde, wäre die Sicht auf 80686 ebenfalls normal, aber die DOSBox ist 80386. <br><br>  Das Argument <code>-ffreestanding</code> erfordert, dass GCC keinen Code <code>-ffreestanding</code> , der auf die <code>-ffreestanding</code> der integrierten Standardbibliothek zugreift.  Manchmal wird anstelle von tatsächlich arbeitendem Code ein Code zum Aufrufen einer integrierten Funktion erstellt, insbesondere bei mathematischen Operatoren.  Ich hatte eines der Hauptprobleme mit bcc, bei dem dieses Verhalten nicht deaktiviert werden kann.  Diese Option wird am häufigsten beim Schreiben von Bootloadern und Betriebssystemkernen verwendet.  Und jetzt die dos dos .com Dateien. <br><br><h3>  Linker-Optionen </h3><br>  Die <code>-Wl</code> verwendet, um Argumente an den Linker ( <code>ld</code> ) zu übergeben.  Wir brauchen das, weil wir alles in einem Anruf bei GCC erledigen. <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld</code> </pre> <br>  <code>--nmagic</code> deaktiviert die Seitenausrichtung von Abschnitten.  Erstens brauchen wir es nicht.  Zweitens verschwendet es wertvollen Platz.  In meinen Tests scheint dies keine notwendige Maßnahme zu sein, aber nur für den Fall, ich lasse diese Option. <br><br>  Der Parameter <code>--script</code> gibt an, dass wir ein spezielles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linker-Skript verwenden</a> möchten.  Auf diese Weise können Sie die Abschnitte ( <code>text</code> , <code>data</code> , <code>bss</code> , <code>rodata</code> ) unseres Programms genau platzieren.  Hier ist das <code>com.ld</code> Skript. <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">OUTPUT_FORMAT</span></span>(binary) <span class="hljs-type"><span class="hljs-type">SECTIONS</span></span> { . = <span class="hljs-number"><span class="hljs-number">0x0100</span></span>; .text : { *(.text); } .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bss</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">); } _heap = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class">(4); }</span></span></code> </pre> <br>  <code>OUTPUT_FORMAT(binary)</code> weist Sie an, dies nicht in eine ELF-Datei (oder PE usw.) zu legen.  Der Linker sollte nur den sauberen Code zurücksetzen.  Eine COM-Datei ist nur sauberer Code, das heißt, wir geben dem Linker den Befehl, eine COM-Datei zu erstellen! <br><br>  Ich sagte, dass COM-Dateien auf <code>0x0100</code> hochgeladen <code>0x0100</code> .  Die vierte Zeile verschiebt die Binärdatei dort.  Das erste Byte der COM-Datei ist immer noch das erste Byte des Codes, wird jedoch von diesem Speicheroffset aus gestartet. <br><br>  Dann folgen alle Abschnitte: <code>text</code> (Programm), <code>data</code> (statische Daten), <code>bss</code> (Daten ohne Initialisierung), <code>rodata</code> (Zeichenfolgen).  Schließlich markiere ich das Ende der Binärdatei mit dem Symbol <code>_heap</code> .  Dies wird später beim Schreiben von <code>sbrk()</code> wenn wir mit „Hallo Welt“ fertig sind.  Ich habe angegeben, <code>_heap</code> mit 4 Bytes auszurichten. <br><br>  Fast fertig. <br><br><h3>  Programmstart </h3><br>  Der Linker kennt normalerweise unseren Einstiegspunkt ( <code>main</code> ) und richtet ihn für uns ein.  Da wir jedoch ein „binäres“ Problem angefordert haben, müssen wir es selbst herausfinden.  Wenn die Funktion <code>print()</code> als erste ausgeführt wird, startet das Programm damit, was falsch ist.  Das Programm benötigt eine kleine Überschrift, um loszulegen. <br><br>  Für solche Dinge gibt es im Linker-Skript eine <code>STARTUP</code> Option, die der Einfachheit halber jedoch direkt im Programm implementiert wird.  Normalerweise heißen solche Dinge <code>crt0.o</code> oder <code>Boot.o</code> , falls Sie irgendwo darauf <code>Boot.o</code> .  Unser Code <i>muss</i> mit diesem eingebauten Assembler beginnen, bevor Einschlüsse und dergleichen vorgenommen werden.  DOS übernimmt den größten Teil der Installation für uns. Wir müssen nur zum Einstiegspunkt gehen. <br><br><pre> <code class="hljs perl">asm (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C, %ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>);</code> </pre> <br>  <code>.code16gcc</code> teilt dem Assembler mit, dass wir im Real-Modus arbeiten werden, damit die richtige Konfiguration vorgenommen wird.  Trotz des Namens wird <i>kein</i> 16-Bit-Code erzeugt!  Zunächst wird die <code>dosmain</code> Funktion, die wir zuvor geschrieben haben, aufgerufen.  Anschließend teilt er DOS mit der 0x4C-Funktion („Mit Rückkehrcode beenden“) mit, dass wir den Exit-Code an das 1-Byte-Register übergeben (bereits von <code>dosmain</code> ).  Dieser eingebaute Assembler ist automatisch <code>volatile</code> da er keine Ein- und Ausgänge hat. <br><br><h3>  Alle zusammen </h3><br>  Hier ist das ganze Programm in C. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C,%ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Ich werde <code>com.ld</code> nicht wiederholen <code>com.ld</code>  Hier ist die GCC-Herausforderung. <br><br><pre> <code class="hljs powershell">gcc <span class="hljs-literal"><span class="hljs-literal">-std</span></span>=gnu99 <span class="hljs-literal"><span class="hljs-literal">-Os</span></span> <span class="hljs-literal"><span class="hljs-literal">-nostdlib</span></span> <span class="hljs-literal"><span class="hljs-literal">-m32</span></span> <span class="hljs-literal"><span class="hljs-literal">-march</span></span>=i386 <span class="hljs-literal"><span class="hljs-literal">-ffreestanding</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-o</span></span> hello.com <span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld hello.c</code> </pre> <br>  Und seine Tests in DOSBox: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/478/358/4c5478358be0cdd9cc05eafd66bd44d2.png"><br><br>  Wenn Sie schöne Grafiken wünschen, müssen Sie nur den Interrupt aufrufen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den VGA-Speicher schreiben</a> .  Wenn Sie Ton wünschen, verwenden Sie den PC-Lautsprecher-Interrupt.  Ich habe nicht herausgefunden, wie ich Sound Blaster nennen soll.  Von diesem Moment an wuchs DOS Defender auf. <br><br><h1>  Speicherzuordnung </h1><br>  <code>_heap</code> daran, dass <code>_heap</code> um ein anderes Thema zu <code>_heap</code> ?  Wir können es verwenden, um <code>sbrk()</code> zu implementieren und Speicher im Hauptabschnitt des Programms dynamisch zuzuweisen.  Dies ist ein realer Modus und es gibt keinen virtuellen Speicher, sodass wir in jeden Speicher schreiben können, auf den wir jederzeit zugreifen können.  Einige Bereiche (z. B. unterer und oberer Speicher) sind für Geräte reserviert.  Es besteht also keine <i>wirkliche</i> Notwendigkeit, sbrk () zu verwenden, aber es ist interessant, es zu versuchen. <br><br>  Wie bei x86 üblich, befinden sich Ihr Programm und Ihre Partitionen im unteren Speicher (in diesem Fall 0x0100) und der Stapel im oberen Speicher (in unserem Fall im Bereich 0xffff).  Auf Unix-ähnlichen Systemen stammt der von <code>malloc()</code> zurückgegebene <code>malloc()</code> von zwei Stellen: <code>sbrk()</code> und <code>mmap()</code> .  Was <code>sbrk()</code> tut, ist, Speicher direkt über Programm- / Datensegmenten zuzuweisen und ihn in Richtung des Stapels „nach oben“ zu erhöhen.  Jeder Aufruf von <code>sbrk()</code> vergrößert diesen Platz (oder lässt ihn genau gleich).  Dieser Speicher wird von <code>malloc()</code> und dergleichen verwaltet. <br><br>  So implementieren Sie <code>sbrk()</code> in einem COM-Programm.  Bitte beachten Sie, dass Sie Ihre eigene <code>size_t</code> definieren müssen, da wir keine Standardbibliothek haben. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _heap; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *hbreak = &amp;_heap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sbrk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = hbreak; hbreak += size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre> <br>  Es setzt einfach den Zeiger auf <code>_heap</code> und erhöht ihn nach Bedarf.  Ein etwas schlaueres <code>sbrk()</code> wird auch bei der Ausrichtung vorsichtig sein. <br><br>  Bei der Erstellung von DOS Defender ist etwas Interessantes passiert.  Ich habe (fälschlicherweise) angenommen, dass der Speicher von meinem <code>sbrk()</code> zurückgesetzt wurde.  So war es nach dem ersten Spiel.  DOS setzt diesen Speicher zwischen den Programmen jedoch nicht zurück.  Als ich das Spiel erneut startete, wurde <i>es genau dort fortgesetzt, wo ich aufgehört hatte</i> , da dieselben Datenstrukturen mit demselben Inhalt geladen wurden.  Ziemlich cooler Zufall!  Dies ist ein Teil dessen, was diese eingebettete Plattform zum Spaß macht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412867/">https://habr.com/ru/post/de412867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412855/index.html">CSRF-Schwachstellen sind weiterhin relevant</a></li>
<li><a href="../de412859/index.html">Zwei-Faktor-Authentifizierung unter Windows und Datenverschlüsselung ohne Zertifizierungsstelle und Domäne</a></li>
<li><a href="../de412861/index.html">Erstellen einer Benutzerpfadzuordnung für Dummies</a></li>
<li><a href="../de412863/index.html">Dialogflower - Google Dialogflow für Yandex Alice</a></li>
<li><a href="../de412865/index.html">So schießen Sie eine Motion Eye-Kamera im Sony Xperia XZ2</a></li>
<li><a href="../de412869/index.html">Interview mit einem Experten für Tissue Engineering und regenerative Medizin, Professor Tal Tal Dvir</a></li>
<li><a href="../de412871/index.html">Eclair - Deklarative Java Spring-Protokollierungsbibliothek</a></li>
<li><a href="../de412873/index.html">Festplatten, die durch den Ton gewöhnlicher Laptop-Lautsprecher beeinträchtigt werden</a></li>
<li><a href="../de412877/index.html">Ruthenium (Ru) - das vierte Element mit ferromagnetischen Eigenschaften bei Raumtemperatur</a></li>
<li><a href="../de412879/index.html">Problem Nr. 24: IT-Schulung - aktuelle Probleme und Herausforderungen führender Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>