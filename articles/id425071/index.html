<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ ğŸ§“ğŸ½ ğŸ™ï¸ Bagaimana cara melindungi dari stack overflow (pada Cortex M)? ğŸ‘©ğŸ»â€ğŸ”§ ğŸ‘¶ğŸ¿ ğŸ¦–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda memprogram pada komputer "besar", maka Anda mungkin tidak memiliki pertanyaan seperti itu. Ada banyak tumpukan untuk melimpah, Anda harus me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara melindungi dari stack overflow (pada Cortex M)?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425071/">  Jika Anda memprogram pada komputer "besar", maka Anda mungkin tidak memiliki pertanyaan seperti itu.  Ada banyak tumpukan untuk melimpah, Anda harus mencoba.  Dalam kasus terburuk, Anda mengklik OK pada jendela seperti ini dan mencari tahu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/c2c/358/b12c2c358fa3a040589578b71521957b.png" alt="gambar"></div><br>  Tetapi jika Anda memprogram mikrokontroler, maka masalahnya terlihat sedikit berbeda.  Pertama, Anda perlu <i>memperhatikan</i> bahwa tumpukan sudah penuh. <br><br>  Pada artikel ini saya akan berbicara tentang penelitian saya sendiri tentang topik ini.  Karena saya memprogram terutama di bawah STM32 dan di bawah Milander 1986 - saya fokus pada mereka. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Mari kita bayangkan kasus paling sederhana - kita menulis kode single-threaded sederhana tanpa sistem operasi, mis.  kami hanya memiliki satu tumpukan.  Dan jika Anda, seperti saya, memprogram di uVision Keil, maka memori didistribusikan entah bagaimana seperti ini: <br><br><img src="https://habrastorage.org/webt/er/tb/to/ertbtohh-xf2meqxvzekrxlmwoe.png"><br><br>  Dan jika Anda, seperti saya, menganggap memori dinamis pada mikrokontroler sebagai jahat, maka seperti ini: <br><br><img src="https://habrastorage.org/webt/op/bu/el/opbuelnjpcvre-9jjpm_qnrlqcw.png"><br><br><div class="spoiler">  <b class="spoiler_title">Ngomong-ngomong</b> <div class="spoiler_text">  Jika Anda ingin melarang penggunaan heap, Anda dapat melakukannya seperti ini: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> import(__use_no_heap_region)</span></span></code> </pre> <br>  Detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> <br></div></div><br>  OK, apa masalahnya?  Masalahnya adalah bahwa Keil menempatkan tumpukan <b>tepat di</b> belakang area data statis.  Dan tumpukan di Cortex-M tumbuh ke arah penurunan alamat.  Dan ketika meluap, maka itu hanya merangkak keluar dari bagian memori yang dialokasikan.  Dan menimpa variabel statis atau global. <br><br>  Terutama hebat jika tumpukan meluap hanya saat memasuki interupsi.  Atau, bahkan lebih baik, dalam interupsi bersarang!  Dan diam-diam merusak beberapa variabel yang digunakan dalam bagian kode yang sama sekali berbeda.  Dan program crash pada pernyataan tersebut.  Jika anda beruntung  Tas heisen bola, orang bisa mencari seminggu penuh dengan senter. <br><br>  Segera buat reservasi bahwa jika Anda menggunakan heap, maka masalahnya tidak kemana-mana, hanya saja variabel global heap rampasan.  Tidak jauh lebih baik. <br><br>  Oke, masalahnya jelas.  Apa yang harus dilakukan <br><br><h2>  MPU </h2><br>  Yang paling sederhana dan paling jelas adalah menggunakan MPU (dengan kata lain, Memory Protection Unit).  Memungkinkan Anda untuk menetapkan atribut yang berbeda ke bagian memori yang berbeda;  khususnya, Anda dapat mengelilingi tumpukan dengan wilayah hanya-baca dan menangkap MemFault saat menulis di sana. <br><br>  Misalnya, dalam stm32f407 MPU adalah.  Sayangnya, di banyak stm "junior" lainnya tidak.  Dan dalam Milandrovsky 1986VE1 juga tidak ada. <br><br>  Yaitu  Solusinya bagus, tetapi tidak selalu terjangkau. <br><br><h2>  Kontrol manual </h2><br>  Saat kompilasi, Keil dapat membuat (dan melakukannya secara default) laporan html dengan grafik panggilan (opsi tautan "--info = stack").  Dan laporan ini juga memberikan informasi tentang tumpukan yang digunakan.  Gcc dapat melakukannya juga (opsi -fstack-use).  Karenanya, Anda terkadang dapat melihat laporan ini (atau menulis skrip yang melakukan ini untuk Anda, dan menyebutnya sebelum setiap pembuatan). <br><br>  Selain itu, di bagian paling awal laporan, sebuah jalur ditulis yang mengarah ke penggunaan maksimum tumpukan: <br><br><img src="https://habrastorage.org/webt/eb/mh/ao/ebmhaouyrjjvnmziubxybt3zyg0.png"><br><br>  Masalahnya adalah bahwa jika kode Anda memiliki panggilan fungsi oleh pointer atau metode virtual (dan saya memilikinya), maka laporan ini dapat sangat meremehkan kedalaman tumpukan maksimum.  Yah, interupsi, tentu saja, tidak diperhitungkan.  Bukan cara yang sangat andal. <br><br><h2>  Penempatan Tacky Stack </h2><br>  Saya belajar tentang metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> .  Artikel ini tentang karat, tetapi ide utamanya adalah ini: <br><br><img src="https://habrastorage.org/webt/i3/pz/yb/i3pzyb-ewbtxaei_oaz5mrhthda.png"><br><br>  Saat menggunakan gcc, ini bisa dilakukan menggunakan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ganda</a> ". <br><br>  Dan di Keil, lokasi area dapat diubah menggunakan skrip Anda sendiri untuk tautan (file sebar dalam terminologi Keil).  Untuk melakukan ini, buka opsi proyek dan hapus centang "Gunakan tata letak memori dari dialog target".  Maka file default akan muncul di bidang "Scatter file".  Itu terlihat seperti ini: <br><br><pre> <code class="cpp hljs">; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load region size_region ER_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 <span class="hljs-number"><span class="hljs-number">0x20000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00005000</span></span> { ; RW data .ANY (+RW +ZI) } }</code> </pre> <br>  Apa yang harus dilakukan selanjutnya?  Opsi yang memungkinkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> menyarankan mendefinisikan bagian dengan nama yang dipesan - ARM_LIB_HEAP dan ARM_LIB_STACK.  Tapi ini memerlukan konsekuensi yang tidak menyenangkan, setidaknya bagi saya - ukuran tumpukan dan tumpukan harus diatur dalam file pencar. <br><br>  Di semua proyek yang saya gunakan, ukuran tumpukan dan tumpukan diatur dalam file startup assembler (yang dihasilkan Keil saat membuat proyek).  Saya benar-benar tidak ingin mengubahnya.  Saya hanya ingin memasukkan file sebar baru dalam proyek, dan semuanya akan baik-baik saja.  Jadi saya pergi dengan cara yang sedikit berbeda: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#! armcc -E ; with that we can use C preprocessor <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_BEGIN 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_SIZE_BYTES (4*1024) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BEGIN 0x8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_SIZE_BYTES (32*1024) ; This scatter file places stack before .bss region, so on stack overflow ; we get HardFault exception immediately LR_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load region size_region ER_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } ; Stack region growing down REGION_STACK RAM_BEGIN { *(STACK) } ; We have to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> heap region, even </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we don</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'t actually use heap REGION_HEAP ImageLimit(REGION_STACK) { *(HEAP) } ; this will place .bss region above the stack and heap and allocate RAM that is left for it RW_IRAM1 ImageLimit(REGION_HEAP) (RAM_SIZE_BYTES - ImageLength(REGION_STACK) - ImageLength(REGION_HEAP)) { *(+RW +ZI) } }</span></span></span></span></code> </pre> <br></div></div><br>  Lalu saya mengatakan bahwa semua objek bernama STACK harus terletak di wilayah REGION_STACK, dan semua objek HEAP harus terletak di wilayah REGION_HEAP.  Dan yang lainnya ada di wilayah RW_IRAM1.  Dan dia mengatur daerah dalam urutan ini - awal operasi, tumpukan, tumpukan, segala sesuatu yang lain.  Perhitungannya adalah bahwa dalam file startup assembler tumpukan dan tumpukan diatur menggunakan kode ini (mis., Sebagai array dengan nama STACK dan HEAP): <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit PRESERVE8 THUMB</code> </pre> <br></div></div><br>  Oke, Anda mungkin bertanya, tapi apa artinya ini bagi kita?  Dan inilah yang terjadi.  Sekarang, ketika keluar dari tumpukan, prosesor mencoba untuk menulis (atau membaca) memori yang tidak ada.  Dan pada STM32, gangguan terjadi karena pengecualian - HardFault. <br><br>  Ini tidak semudah MemFault karena MPU, karena HardFault dapat terjadi karena berbagai alasan, tetapi setidaknya kesalahannya keras dan tidak sepi.  Yaitu  itu terjadi segera, dan bukan setelah periode waktu yang tidak diketahui, seperti sebelumnya. <br><br>  Yang terbaik dari semuanya, kami tidak membayar apa pun untuk itu, tidak ada runtime overhead!  Wow  Tapi ada satu masalah. <br><br>  <i>Ini tidak berfungsi pada Milander.</i> <br><br>  Ya  Tentu saja, pada Milandra (saya terutama tertarik pada 1986BE1 dan BE91), kartu memori terlihat berbeda.  Di STM32, sebelum dimulainya operasi, tidak ada apa-apa, dan di Milandra, sebelum operasi, terletak area bus eksternal. <br><br>  Tetapi bahkan jika Anda tidak menggunakan bus eksternal, Anda tidak akan menerima HardFault.  Atau mungkin mendapatkannya.  Atau mungkin mendapatkannya, tetapi tidak segera.  Saya tidak dapat menemukan informasi mengenai hal ini (yang tidak mengejutkan bagi Milander), dan percobaan tidak memberikan hasil yang masuk akal.  HardFault <i>kadang-kadang</i> terjadi jika ukuran tumpukan kelipatan 256. Kadang-kadang HardFault terjadi jika tumpukan terlalu jauh ke memori yang tidak ada. <br><br>  Tapi itu bahkan tidak masalah.  Jika HardFault tidak terjadi setiap waktu, maka cukup memindahkan tumpukan ke awal RAM tidak lagi menyelamatkan kita.  Dan sejujurnya, STM juga tidak berkewajiban untuk melemparkan pengecualian pada saat yang sama, spesifikasi inti Cortex-M tampaknya tidak mengatakan apa pun yang konkret tentang hal ini. <br><br>  Jadi, bahkan pada STM lebih seperti peretasan, tidak terlalu kotor. <br><br>  Jadi, Anda perlu mencari cara lain. <br><br><h2>  Akses breakpoint dalam catatan </h2><br>  Jika kita memindahkan tumpukan ke awal RAM, maka nilai batas tumpukan akan selalu sama - 0x20000000.  Dan kita bisa menempatkan breakpoint pada catatan di sel ini.  Ini dapat dilakukan dengan perintah dan bahkan terdaftar di autorun menggunakan file .ini: <br><br><pre> <code class="plaintext hljs">// breakpoint on stackoverflow BS Write 0x20000000, 1</code> </pre> <br>  Tapi ini bukan cara yang bisa diandalkan.  Breakpoint ini akan menyala setiap kali stack diinisialisasi.  Sangat mudah untuk mengalahkannya secara tidak sengaja dengan mengeklik "Bunuh semua breakpoint".  Dan dia akan melindungi Anda hanya di hadapan debugger.  Tidak bagus <br><br><h2>  Perlindungan overflow dinamis </h2><br>  Pencarian cepat pada subjek ini mengarahkan saya ke opsi Keil --protect_stack dan --protect_stack_all.  Opsi yang berguna, sayangnya, mereka melindungi tidak meluap seluruh tumpukan, tetapi dari muncul fungsi lain ke dalam bingkai tumpukan.  Misalnya, jika kode Anda melampaui batas array atau gagal dengan sejumlah parameter variabel.  Gcc, tentu saja, bisa melakukannya juga (-fstack-protector). <br><br>  Inti dari opsi ini adalah sebagai berikut: "variabel penjaga" ditambahkan ke setiap bingkai tumpukan, yaitu, nomor penjaga.  Jika nomor ini telah berubah setelah keluar dari fungsi, maka fungsi penangan kesalahan dipanggil.  Detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Suatu hal yang bermanfaat, tetapi tidak cukup apa yang saya butuhkan.  Saya perlu pemeriksaan yang lebih sederhana - sehingga ketika memasuki setiap fungsi, nilai register SP (Stack Pointer) diperiksa terhadap nilai minimum yang diketahui sebelumnya.  Tetapi jangan menulis tes ini dengan tangan Anda di pintu masuk ke setiap fungsi? <br><br><h2>  Kontrol SP dinamis </h2><br>  Untungnya, gcc memiliki opsi luar biasa "-finstrument-functions", yang memungkinkan Anda untuk memanggil fungsi yang ditentukan pengguna saat Anda memasuki setiap fungsi dan saat Anda keluar dari setiap fungsi.  Ini biasanya digunakan untuk menampilkan informasi debug, tetapi apa bedanya? <br><br>  Yang lebih untungnya, Keil sengaja menyalin fungsionalitas gcc, dan ada opsi yang sama tersedia dengan nama "--gnu_instrument" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail</a> ). <br><br>  Setelah itu, Anda hanya perlu menulis kode ini: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //   ,         scatter- extern unsigned int Image$$REGION_STACK$$RW$$Base; //    ,   static const uint32_t stack_lower_address = (uint32_t) &amp;( Image$$REGION_STACK$$RW$$Base ); //         extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_enter( void * current_func, void * callsite ) { (void)current_func; (void)callsite; ASSERT( __current_sp() &gt;= stack_lower_address ); } //   -   extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_exit( void * current_func, void * callsite ) { (void)current_func; (void)callsite; }</span></span></code> </pre> <br></div></div><br>  Dan voila!  Sekarang, setelah memasuki setiap fungsi (termasuk penangan interrupt), pemeriksaan akan dilakukan untuk stack overflow.  Dan jika tumpukan meluap, akan ada penegasan. <br><br><div class="spoiler">  <b class="spoiler_title">Sedikit penjelasan:</b> <div class="spoiler_text"><ul><li>  Ya, tentu saja, Anda perlu memeriksa luapan dengan margin, jika tidak ada risiko "melompat" di atas tumpukan. </li><li>  Image $$ REGION_STACK $$ RW $$ Base adalah keajaiban khusus untuk mendapatkan informasi tentang area memori menggunakan konstanta yang dihasilkan oleh linker.  Detail (meskipun tidak terlalu jelas di beberapa tempat) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br></div></div><br>  Apakah solusinya sempurna?  Tentu saja tidak. <br><br>  Pertama, pemeriksaan ini jauh dari gratis, kode dari itu membengkak sebesar 10 persen. Nah, kode itu akan bekerja lebih lambat (walaupun saya tidak mengukurnya).  Apakah itu penting atau tidak, itu terserah Anda;  Menurut pendapat saya, ini adalah harga yang wajar untuk keamanan. <br><br>  Kedua, ini kemungkinan besar tidak akan berfungsi ketika menggunakan perpustakaan yang sudah dikompilasi (tapi karena saya tidak menggunakannya sama sekali, saya tidak memeriksa). <br><br>  Tetapi solusi ini berpotensi cocok untuk program multi-utas, karena kami melakukan verifikasi sendiri.  Tapi saya belum benar-benar memikirkan ide ini, jadi saya akan menahannya untuk saat ini. <br><br><h2>  Untuk meringkas </h2><br>  Ternyata untuk menemukan solusi bekerja untuk FM32 dan untuk Milander, meskipun untuk yang terakhir saya harus membayar dengan beberapa overhead. <br><br>  Bagi saya, yang terpenting adalah perubahan kecil dalam paradigma berpikir.  Sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tersebut</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atas,</a> saya tidak berpikir sama sekali bahwa Anda dapat melindungi diri Anda dari tumpukan yang meluap.  Saya tidak menganggap ini sebagai masalah yang perlu diselesaikan, melainkan sebagai fenomena alam tertentu - kadang hujan, dan kadang-kadang tumpukan meluap, yah, tidak ada yang harus dilakukan, Anda harus menggigit peluru dan mentolerir. <br><br>  Dan saya biasanya cukup sering memperhatikan sendiri (dan untuk orang lain) ini - alih-alih menghabiskan 5 menit di Google dan menemukan solusi sepele - Saya telah hidup dengan masalah saya selama bertahun-tahun. <br><br>  Itu semua untuk saya.  Saya mengerti bahwa saya belum menemukan sesuatu yang secara fundamental baru, tetapi saya belum menemukan artikel yang sudah jadi dengan keputusan seperti itu (setidaknya Joseph Yu sendiri tidak menawarkan ini secara langsung dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang hal ini).  Saya berharap dalam komentar mereka akan memberi tahu saya apakah saya benar atau tidak, dan apa jebakan dari pendekatan ini. <br><br>  <b>UPD:</b> Jika, ketika menambahkan file pencar, Keil mulai mengeluarkan peringatan yang tidak dapat dipahami ala "AppData \ Local \ Temp \ p17af8-2 (33): peringatan: # 1-D: baris terakhir file berakhir tanpa baris baru" - tetapi file ini sendiri tidak terbuka, karena sifatnya sementara, maka cukup tambahkan jeda baris dengan karakter terakhir di file sebar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425071/">https://habr.com/ru/post/id425071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425057/index.html">Pinjaman preferensial untuk pendidikan untuk semua program GeekUniversity dari GeekBrains dan Alfa Bank</a></li>
<li><a href="../id425059/index.html">Hackathon No. 1 di Tinkoff.ru</a></li>
<li><a href="../id425061/index.html">CodeRainbow: pembelajaran kode interaktif dan dokumentasi</a></li>
<li><a href="../id425063/index.html">Migrasi skema database tanpa downtime untuk postgresql menggunakan Django sebagai contoh</a></li>
<li><a href="../id425069/index.html">Menguji presenter menggunakan PromiseKit</a></li>
<li><a href="../id425073/index.html">Pembuatan repositori git yang mudah di OneDrive</a></li>
<li><a href="../id425075/index.html">Visi Mesin: Menginstal, Mengonfigurasi, dan Menggunakan Google Cloud Vision dalam PHP</a></li>
<li><a href="../id425077/index.html">Kotlin di bawah tenda - lihat bytecode yang didekompilasi</a></li>
<li><a href="../id425079/index.html">IPSec yang sulit dengan Linux</a></li>
<li><a href="../id425081/index.html">Negara tidak tahu berapa banyak yang dihabiskan untuk TI. Kami membuktikan pada angka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>