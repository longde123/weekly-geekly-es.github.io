<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆘 🙋🏾 🔃 25 tipos de "César" e palavras em inglês 👐 🙍🏿 🤹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No mundo da criptografia, existem muitas maneiras fáceis de criptografar uma mensagem. Cada um deles é bom à sua maneira. Um deles será discutido. 
 Y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>25 tipos de "César" e palavras em inglês</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464581/"><p>  No mundo da criptografia, existem muitas maneiras fáceis de criptografar uma mensagem.  Cada um deles é bom à sua maneira.  Um deles será discutido. </p><br><h2 id="ylchu-schzkguv">  Ylchu Schzzkgow </h2><br><p>  Ou traduzido de "Cifra de César" para o russo - <strong>Cifra de César</strong> . </p><br><p><img src="https://habrastorage.org/webt/ea/kt/o9/eakto9ydjflofn_mqnunwowmfrc.jpeg" alt="cesar"></p><a name="habracut"></a><br><p>  <strong>- Qual é a sua essência?</strong> <br>  - Ele codifica a mensagem, trocando cada letra por N pontos.  A cifra clássica de César move as letras três passos à frente.  Em palavras simples - era "abv", tornou-se "onde". </p><br><p>  <strong>"Mas e as letras no final do alfabeto?"</strong>  <strong>E os espaços?</strong> <br>  Eles estão bem.  Se mudar a letra, a cifra vai além do escopo do alfabeto - começa a contar novamente.  Ou seja, as letras "Eyuya" se transformam em "abv".  E os espaços permanecem espaços. </p><br><p> <strong>- N deve necessariamente ser igual a três?</strong> <br>  Nem um pouco.  N pode diferir de três.  Qualquer N entre [1: M-1] é permitido, onde M é o número de letras no alfabeto. </p><br><p>  É fácil decifrar essa cifra se você souber sobre a sua existência.  Mas não foi sua "confiabilidade" que me atraiu, mas outra coisa. </p><br><h1 id="zavyazka">  Gravata </h1><br><p>  Um dia de verão, eu queria saber: </p><br><ul><li>  Mas e se eu criptografar uma palavra usando César e obter uma palavra existente na saída? </li><li>  Quantas palavras são "shifters"? </li><li>  E haverá um padrão se N for alterado? </li></ul><br><p>  Comecei a procurar respostas para essas perguntas nos mesmos minutos. </p><br><h1 id="zadacha-nayti-vse-slova">  Tarefa: Encontre todas as palavras </h1><br><p>  Retiro.  Dos shows de Mikhail Zadornov e da experiência pessoal, entendi duas coisas: </p><br><ol><li>  Os americanos não se ofendem com o discurso de comediantes russos. </li><li>  A língua russa é forte e poderosa.  E há muitas palavras nele. </li></ol><br><p>  Por isso, decidi tomar o idioma inglês como minha base.  Além disso, era uma vez uma informação de que os que falam inglês conseguiram montar um dicionário completo de palavras em inglês.  O que me levou a encontrar esse conjunto de dados. </p><br><p>  A primeira linha de pesquisa lenta me levou a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este repositório</a> .  O autor prometeu 479 mil palavras em inglês em formatos convenientes.  Gostei do arquivo json, no qual todas as palavras foram dispostas de forma conveniente para serem carregadas no dicionário Python. </p><br><p>  Após a primeira autópsia, verificou-se que havia menos palavras - 370 101 peças.  "Mas isso não importa, porque, para um bom exemplo, será suficiente", pensei. </p><br><pre><code class="python hljs">words = json.load(open(<span class="hljs-string"><span class="hljs-string">'words_dictionary.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>)) len(words.keys()) &gt;&gt; <span class="hljs-number"><span class="hljs-number">370101</span></span></code> </pre> <br><p>  Primeiro você precisa criar um alfabeto.  Decidi fazer uma lista da maneira mais conveniente para mim.  Também era necessário lembrar o número de letras no alfabeto: </p><br><pre> <code class="python hljs">abc = list(<span class="hljs-string"><span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span></span>) abc_len = len(abc)</code> </pre> <br><p>  A princípio, foi interessante transformar a palavra em criptografada.  Aqui está o que aconteceu: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   - def cesar(word, abc, abc_len, step=3): word_list = list(word) result = [] for w in word_list: i = abc.index(w) i = (i+step) % abc_len wn = abc[i] result.append(wn) result = ''.join(result) return result</span></span></code> </pre> <br><p>  Decidi fazer um grande ciclo de todas as palavras e começar a traduzi-las uma a uma.  Mas me deparei com um problema.  Verificou-se que algumas palavras continham um sinal "-", que era surpreendente e natural ao mesmo tempo. </p><br><p>  Sem pensar duas vezes, contei o número de tais palavras e verificou-se que havia apenas duas delas.  Após o que ele excluiu os dois, porque dificilmente afetará o resultado.  Para me ajudar, nasceu esta função: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   «-»     def rem(words): words_list = list(words.keys()) words = {} for word in words_list: if '-' in word: words_list.remove(word) else: words[word] = 1 return words</span></span></code> </pre> <br><p>  O dicionário parecia: </p><br><pre> <code class="python hljs">{<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'aa'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'aaa'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'aah'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, ... }</code> </pre> <br><p>  Portanto, decidi não ser inteligente e substituí-los por palavras codificadas.  Para fazer isso, escreveu uma função: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   {'word': 1}  {'word': 'cesar-word'} def cesar_all(words, abc, abc_len, step=3): result = words for w in result: result[w] = cesar(w, abc, abc_len, step=step) return result</span></span></code> </pre> <br><p>  E, é claro, precisávamos de um grande ciclo que passasse por todas as palavras, encontrasse as palavras-shifters e salvasse o resultado.  Aqui está: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       def check_all(words_cesar, min_len=0): words_keys = words_cesar.keys() words_result = {} for word in words_keys: if words_cesar[word] in words_keys: if len(word) &gt;= min_len: words_result[word] = words_cesar[word] return words_result</span></span></code> </pre> <br><p>  Você deve ter notado que nos parâmetros da função é "min_len = 0".  Ele será necessário no futuro.  A peculiaridade desse conjunto de dados era um conjunto de palavras "estranho".  Tais como: "aa", "aah" e combinações semelhantes.  Foram eles que deram o primeiro resultado - 660 deslocadores de palavras. </p><br><p>  Portanto, eu tive que colocar um limite de cinco, pelo menos, cinco caracteres, para que as palavras fossem agradáveis ​​aos olhos e semelhantes às existentes. </p><br><pre> <code class="python hljs">words_result = check_all(words_cesar, min_len=<span class="hljs-number"><span class="hljs-number">5</span></span>) words_result &gt;&gt; {<span class="hljs-string"><span class="hljs-string">'abime'</span></span>: <span class="hljs-string"><span class="hljs-string">'delph'</span></span>, <span class="hljs-string"><span class="hljs-string">'biabo'</span></span>: <span class="hljs-string"><span class="hljs-string">'elder'</span></span>, <span class="hljs-string"><span class="hljs-string">'bifer'</span></span>: <span class="hljs-string"><span class="hljs-string">'elihu'</span></span>, <span class="hljs-string"><span class="hljs-string">'cobra'</span></span>: <span class="hljs-string"><span class="hljs-string">'freud'</span></span>, <span class="hljs-string"><span class="hljs-string">'colob'</span></span>: <span class="hljs-string"><span class="hljs-string">'frore'</span></span>, <span class="hljs-string"><span class="hljs-string">'oxime'</span></span>: <span class="hljs-string"><span class="hljs-string">'ralph'</span></span>, <span class="hljs-string"><span class="hljs-string">'pelta'</span></span>: <span class="hljs-string"><span class="hljs-string">'showd'</span></span>, <span class="hljs-string"><span class="hljs-string">'primero'</span></span>: <span class="hljs-string"><span class="hljs-string">'sulphur'</span></span>, <span class="hljs-string"><span class="hljs-string">'teloi'</span></span>: <span class="hljs-string"><span class="hljs-string">'whorl'</span></span>, <span class="hljs-string"><span class="hljs-string">'xerox'</span></span>: <span class="hljs-string"><span class="hljs-string">'ahura'</span></span>}</code> </pre> <br><p>  Sim, dez palavras invertidas foram encontradas graças ao algoritmo.  Minha combinação favorita: <br>  primero [Primeiro] → enxofre [Enxofre].  A maioria dos outros pares que o tradutor do Google não reconhece. </p><br><p>  Nesse estágio, saciei parcialmente a sede de conhecimento.  Mas adiante havia perguntas como: "E o outro N?" </p><br><p>  E usando esta função, encontrei a resposta: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    N def loop_all(words, abc, abc_len, min_len=5): result = {} for istep in range(1, abc_len): words_rem = rem(words) words_cesar = cesar_all(words_rem, abc, abc_len, step=istep) words_result = check_all(words_cesar, min_len=min_len) result[istep] = words_result print('DONE: {}'.format(istep)) return result</span></span></code> </pre> <br><p>  O ciclo terminou em 10 a 15 segundos.  Resta apenas ver os resultados.  Mas, como eu acho que é mais interessante quando há um cronograma.  E aqui está a função final, que nos mostrará o resultado: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   def img_plot(result): lengths = [] for k in result.keys(): l = len(result[k].keys()) lengths.append(l) lengths = np.reshape(lengths, (5,5)) display(lengths) plt.figure(figsize=(20,10)) plt.imshow(lengths, interpolation='sinc') plt.colorbar() plt.show() &gt;&gt; array([[ 12, 5, 10, 41, 4], [116, 23, 18, 20, 29], [ 18, 15, 56, 15, 18], [ 29, 20, 18, 23, 116], [ 4, 41, 10, 5, 12]])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/1h/mh/xw/1hmhxwrfj1q4nwjlcn2vvm1pxds.png" alt="img_plot"></p><br><h1 id="itog">  Sumário </h1><br><h1 id="otvety-na-voprosy-v-nachale">  Respostas às perguntas no início </h1><br><p>  <strong>"E se eu criptografar uma palavra usando César e receber uma palavra existente na saída?"</strong> <br>  - Isso é possível, mesmo muito.  Alguns N dão muito mais palavras que outros. </p><br><p>  <strong>- Quantas palavras “shifters” existem?</strong> <br>  - Depende de N, o comprimento mínimo e, é claro, do conjunto de dados.  No meu caso, com N = 3, o comprimento mínimo de palavras de 0 e 5 é o número de palavras: 660 e 10, respectivamente. </p><br><p>  <strong>- E haverá um padrão se você alterar N?</strong> <br>  Aparentemente sim!  No gráfico (ou mapa de calor), você pode ver que as cores são simétricas.  E os valores na matriz de resultados indicam isso.  E a resposta para a pergunta "Por que isso acontece?"  Vou deixar para o leitor. </p><br><h1 id="minusy-etoy-raboty">  Contras deste trabalho </h1><br><ul><li>  Conjunto de dados não muito correto.  Muitas palavras não são óbvias.  Embora possa ser assim.  Estas são palavras " <strong>todas</strong> " do idioma inglês. </li><li>  Código <del>  sempre </del>  pode ser melhorado. </li><li>  "Código de César" é um caso especial do "código ateniense", em que a fórmula: </li></ul><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">a</span><span class="MJXp-mo" id="MJXp-Span-11" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">A</span><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">L</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">r</span><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">B</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Nova letra = A * Letra anterior + B </script></p><br><p>  Para "Cifra de César" A = 1. A propósito, ele tem mais nuances, o que significa mais interessante. </p><br><p>  Meu arquivo de trabalho com o resultado e uma lista de flip words estão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste repositório</a> </p><br><h1 id="efzp-czhgl">  Efzp zzhgl! </h1></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464581/">https://habr.com/ru/post/pt464581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464561/index.html">Escrevendo aplicativos iOS usando o padrão Redux</a></li>
<li><a href="../pt464563/index.html">Segurança da informação - o que você precisa saber e poder ser considerado um bom especialista em segurança da informação?</a></li>
<li><a href="../pt464565/index.html">IP-KVM via QEMU</a></li>
<li><a href="../pt464571/index.html">Cérebro + VPS por 30 rublos =?</a></li>
<li><a href="../pt464579/index.html">Acampamento de verão da Computer Vision - Escola de verão da Intel Computer Vision</a></li>
<li><a href="../pt464583/index.html">Conjunto de dados 3D maciço ajuda os robôs a entender as coisas</a></li>
<li><a href="../pt464591/index.html">Química de frango frito. Análise detalhada</a></li>
<li><a href="../pt464593/index.html">Nuvem de pontos. Como desenvolvemos a tecnologia digital na construção</a></li>
<li><a href="../pt464595/index.html">Álcool e matemático (a)</a></li>
<li><a href="../pt464597/index.html">Por onde começar a aprender Python: livros para iniciantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>