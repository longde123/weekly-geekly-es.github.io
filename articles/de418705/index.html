<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💷 📞 👩🏾‍🏫 Futex-Grundlagen ↪️ 👩🏿‍🤝‍👩🏼 🤾🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - Abkürzung für "Fast Userspace Mutex") ist ein Mechanismus, der von Linux-Entwicklern von IBM im Jahr 2002 vorgeschlagen und Ende 2003 i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Futex-Grundlagen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  <b>Futex</b> (futex - Abkürzung für "Fast Userspace Mutex") ist ein Mechanismus, der von Linux-Entwicklern von IBM im Jahr 2002 vorgeschlagen und Ende 2003 in den Kernel aufgenommen wurde.  Die Hauptidee bestand darin, eine effizientere Möglichkeit zum Synchronisieren von Benutzer-Threads mit einer minimalen Anzahl von Aufrufen an den Betriebssystemkern bereitzustellen. <br><br>  In diesem Artikel werden wir die Futexe überprüfen, versuchen, die Prinzipien ihrer Arbeit zu verstehen und sie auch als Bausteine ​​verwenden, um übergeordnete (und uns vertraute) Synchronisationsobjekte zu erstellen. <br><br>  Ein wichtiger Punkt: Futexes ist ein eher einfaches Tool, das sich nur bei der Entwicklung grundlegender Bibliotheken wie der Standard-C / C ++ - Bibliothek direkt lohnt.  Es ist sehr unwahrscheinlich, dass Sie in einer regulären Anwendung Futexe verwenden müssen. <br><a name="habracut"></a><br><h3>  Motivation </h3><br>  Vor dem Aufkommen von Futexen war es erforderlich, jedes Mal Systemaufrufe (z. B. mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">semop</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchzuführen</a> , um den Zugriff auf gemeinsam genutzte Ressourcen von mehreren Threads aus zu steuern. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekanntlich</a> ressourcenintensiv, da bei jedem Aufruf der Kontext vom Benutzermodus in den Kernelmodus geändert werden muss.  Mit der Zunahme der Anzahl von Kernen in modernen Prozessoren und der Zunahme der Anzahl von Threads in Anwendungssoftware ist dies zu einem erheblichen Problem geworden.  Es ist sogar noch „beleidigender“, da alle diese Aufrufe keine angewendete Funktion enthalten, keine Geschäftslogik implementieren, sondern nur den korrekten Betrieb des restlichen Codes garantieren. <br><br>  Der Vorschlag, dem Betriebssystem ein neues Konzept von „Futex“ hinzuzufügen, basierte auf einer einfachen Beobachtung: In den meisten Fällen ist der Versuch, ein Synchronisationsobjekt zu erfassen, zum ersten Mal erfolgreich.  Programmierer schreiben Software so, dass vom Sperren des Schlosses bis zum Entsperren so wenig Zeit wie möglich vergeht. Dies bedeutet, dass die Wahrscheinlichkeit sehr hoch ist, dass ein Versuch, einen anderen Thread zu erfassen, nicht auf Hindernisse stößt.  Wenn ein Stream ein solches "freies" Synchronisationsobjekt erreicht, können wir es erfassen, ohne einen Systemaufruf mit relativ billigen atomaren Operationen durchzuführen.  Und es besteht eine sehr große Chance, dass die atomare Operation erfolgreich funktioniert. <br><br>  In diesem seltenen Fall gibt eine atomare Operation einen Fehler zurück, wenn wir immer noch versuchen, auf eine Ressource zuzugreifen, die von einem anderen Thread blockiert wurde.  In diesem Fall haben wir zwei Möglichkeiten.  Wir können entweder eine Spin-Sperre des Benutzermodus aktivieren und auf die Freigabe der Ressource warten (die die CPU-Ressourcen verschlingt), oder den Kernel bitten, uns in den Ruhemodus zu versetzen und auf die Freigabe der Ressource zu warten.  Hier kommen die Futexe ins Spiel. <br><br><h3>  Einfache Verwendung von Futexen - Erwartung und Erwachen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Futex-Systemaufruf</a> kombiniert eine Vielzahl von Funktionen.  Wir werden hier keine komplexen Optionen betrachten (einige davon sind so ausführlich, dass sie nicht einmal in der offiziellen Dokumentation beschrieben werden), aber wir werden uns auf die Operationen FUTEX_WAIT und FUTEX_WAKE konzentrieren.  Die Beschreibung in der offiziellen Dokumentation dient als gute Grundlage: <br><blockquote>  Der Systemaufruf futex () bietet Programmen eine Methode, um darauf zu warten, dass eine bestimmte Bedingung erfüllt wird.  In der Regel verwendet dieser Systemaufruf ein Blockierungskonstrukt im Kontext der Synchronisierung des gemeinsam genutzten Speichers.  Bei Verwendung von Futexen werden die Hauptsynchronisationsvorgänge im Benutzerbereich ausgeführt.  User-Space-Programme führen den Systemaufruf futex () nur aus, wenn das Programm längere Zeit in den Standby-Modus wechseln muss, bis die Bedingung erfüllt ist.  Außerdem kann futex () verwendet werden, um Prozesse oder Threads zu aktivieren, die eine bestimmte Bedingung erwarten. </blockquote>  Einfach ausgedrückt ist ein Futex ein Kernelkonstrukt, mit dessen Hilfe Benutzercode Threads synchronisieren kann, wenn etwas passiert.  Einige Prozesse (oder Threads) können auf Ereignisse in einem FUTEX_WAIT-Aufruf warten, während andere diese Ereignisse mit FUTEX_WAKE aufrufen können.  Das Warten funktioniert effizient - wartende Threads werden vom Kernel angehalten und verwenden keine Prozessorressourcen, bis sie bei Auftreten eines erwarteten Ereignisses aktiviert werden. <br><br>  Nehmen Sie sich Zeit, um die gesamte Dokumentation zu lesen.  Nun, oder lesen Sie zumindest die Abschnitte über FUTEX_WAIT und FUTEX_WAKE. <br><br>  Schauen wir uns ein <a href="">einfaches Beispiel an</a> , das die grundlegende Verwendung von Futexen zur Koordinierung der Arbeit zweier Prozesse demonstriert. <br><br>  Untergeordneter Prozess: <br><br><ol><li>  Wartet auf 0xA im allgemeinen Speichersteckplatz </li><li>  Schreibt den Wert 0xB in diesen Steckplatz </li></ol><br>  Übergeordneter Prozess zu diesem Zeitpunkt: <br><br><ol><li>  Schreibt einen 0xA-Wert in einen gemeinsam genutzten Speichersteckplatz </li><li>  Wartet darauf, dass 0xB darin angezeigt wird </li></ol><br>  Ein solcher „Handschlag“ zwischen zwei Prozessen.  Hier ist der Code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Achten Sie auf POSIX-Aufrufe, um gemeinsam genutzten Speicher zwischen Prozessen zuzuweisen.  Wir konnten hier nicht die übliche Speicherzuordnung verwenden, da selbst die gleiche Adresse von Zeigern in verschiedenen Prozessen tatsächlich auf verschiedene Speicherblöcke verweisen würde (für jeden Prozess eindeutig). <br><br>  Es ist zu beachten, dass dieses Beispiel etwas von den Kanonen abweicht, da der Futex ursprünglich erstellt wurde, um auf eine Änderung einer bestimmten Bedeutung „von etwas Bestimmtem zu etwas“ und nicht „von etwas zu etwas Bestimmtem“ zu warten.  Ich habe dieses Beispiel gegeben, um eine solche Möglichkeit zu demonstrieren, und im Folgenden werden wir die Basisversion betrachten (darauf implementieren wir den Mutex). <br><br>  Und hier ist der Funktionscode wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  Die Hauptaufgabe dieser Funktion (neben dem eigentlichen Aufruf des Futex-Systems) ist ein Zyklus, in dem wir ausgeführt werden, wenn wir falsch aufwachen (nicht an uns interessiert).  Dies kann passieren, wenn ein neuer Wert, der von uns nicht erwartet wird, im gemeinsam genutzten Speichersteckplatz installiert wird.  Nun, oder in dem Fall, in dem ein anderer Prozess früher als bei uns ausgelöst wurde (dies kann in unserem speziellen Fall nicht geschehen, ist aber allgemeiner möglich). <br><br>  Futex-Semantik ist ziemlich knifflig!  Der Aufruf von FUTEX_WAIT wird sofort zurückgegeben, wenn der Wert an der Futex-Adresse nicht dem übergebenen Argument val entspricht.  In unserem Fall kann dies passieren, wenn der untergeordnete Prozess gewartet hat, bevor der übergeordnete Prozess den Wert 0xA in den Steckplatz geschrieben hat.  Der Futex gibt in diesem Fall den Wert EAGAIN zurück. <br><br>  Und hier ist der Funktionscode wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Dies ist ein blockierender Wrapper über FUTEX_WAKE, der schnell arbeitet und einen Wert zurückgibt, unabhängig davon, wie viele Listener ihn erwarten.  In unserem Beispiel wird dies als Teil eines „Handshakes“ verwendet, aber andere Verwendungen sind möglich. <br><br><h3>  Futexe sind Kernel-Warteschlangen für benutzerdefinierten Code. </h3><br>  Einfach ausgedrückt ist ein Futex eine kernelgesteuerte Warteschlange zum Lösen von benutzerdefinierten Codeaufgaben.  Es ermöglicht dem Benutzercode, den Kernel aufzufordern, die Ausführung seines Threads anzuhalten, bis ein Ereignis eintritt, und gleichzeitig dem anderen Thread dieses Ereignis zu signalisieren und alle darauf wartenden Threads zu aktivieren.  Zuvor haben wir die Möglichkeit erwähnt, eine Spin-Sperre im Benutzermodus zu organisieren und darauf zu warten, dass eine Bedingung erfüllt wird.  Die Warteschlange im Kernel ist jedoch eine viel bessere Alternative, da sie uns Milliarden verschwendeter Prozessoranweisungen erspart, die in einer Warteschleife ausgeführt werden. <br><br>  Hier ist das Diagramm aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Eine Futex-Übersicht und ein Update“</a> auf LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="Bild"><br><br>  Im Linux-Kernel-Code sind die Futexe in der Datei kernel / futex.c implementiert.  Der Kernel speichert eine Hash-Tabelle, in der die Schlüssel Adressen sind, um schnell die gewünschte Warteschlange zu finden und den aufrufenden Prozess hinzuzufügen.  Natürlich ist nicht alles so einfach - schließlich muss der Kernel selbst den Zugriff auf die darin enthaltenen Daten synchronisieren und alle möglichen zusätzlichen Optionen für futeksov unterstützen. <br><br><h3>  Zeitlich begrenztes Warten mit FUTEX_WAIT </h3><br>  Der Futex-Systemaufruf verfügt über einen Timeout-Parameter, mit dem der Benutzer angeben kann, wie lange er warten möchte.  Hier ist ein vollständiges <a href="">Beispiel,</a> in dem dies implementiert ist, aber hier ist der Schlüsselteil: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Wenn das Warten um 500 ms verzögert wird, endet die Futex-Funktion und in der nächsten Iteration der Schleife können wir irgendwie darauf reagieren (etwas auf dem Bildschirm anzeigen, in das Protokoll schreiben, das Warten fortsetzen oder anhalten). <br><br><h3>  Verwenden eines Futex zum Implementieren eines Mutex </h3><br>  Wir haben diesen Artikel mit der Tatsache begonnen, dass Futexe bei der Implementierung übergeordneter Synchronisationsobjekte von praktischem Nutzen sind.  Versuchen wir, sie (sowie Atomics) zu verwenden, um den klassischen Mutex zu implementieren.  Die folgende Implementierung basiert auf dem Code aus dem Artikel „Futexes are Tricky“ von Ulrich Drepper. <br><br>  In diesem Beispiel verwende ich C ++, hauptsächlich für die Verwendung von Atomics aus dem C ++ 11-Standard.  Den vollständigen Code finden Sie <a href="">hier</a> , aber der wichtigste Teil ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  In diesem Code ist die cmpxhg-Funktion ein einfacher Wrapper für die bequemere Verwendung von Atomen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Dieses Codebeispiel enthält viele Kommentare, die die Logik seiner Funktionsweise erläutern.  Dies wird nicht schaden, da das Risiko groß ist, dass Sie eine etwas einfachere, aber völlig falsche Version davon schreiben möchten.  Dieser Code ist auch nicht in allem perfekt.  Zum Beispiel versucht er, eine Annahme über ein internes Gerät vom Typ std :: atomic zu machen, indem er seinen Inhalt in int * umwandelt, um ihn an den Futex-Aufruf weiterzuleiten.  Dies ist in der Regel nicht der Fall.  Der Code wird unter Linux x64 kompiliert und ausgeführt, es gibt jedoch keine Garantie für die Kompatibilität mit anderen Plattformen.  Um dies zu erreichen, müssen wir eine Plattformabhängigkeitsschicht für Atome hinzufügen.  Da dies nicht das Thema dieses Artikels ist (und es auch sehr unwahrscheinlich ist, dass Sie Futexe im selben C ++ - Modul mischen), wird diese Implementierung weggelassen.  Dies ist nur eine Demonstration! <br><br><h3>  Glibc-Mutexe und Low-Level-Schlösser </h3><br>  So kamen wir zu dem Punkt, an dem glibc POSIX-Threads implementiert, von denen ein Teil der Typ pthread_mutex_t ist.  Wie ich am Anfang dieses Artikels sagte, sind Futexe nicht ganz das, was ein gewöhnlicher Entwickler braucht.  Sie werden von Laufzeitbibliotheken oder etwas sehr Spezialisiertem verwendet, um übergeordnete Synchronisationsprimitive zu implementieren.  In diesem Zusammenhang ist es interessant, die Implementierung des Mutex für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NPTL zu betrachten</a> .  Im Glibc-Code ist dies die Datei nptl / pthread_mutex_lock.c. <br><br>  Der Code ist ziemlich kompliziert, da verschiedene Arten von Mutexen unterstützt werden müssen, aber wir können auf Wunsch recht vertraute Blöcke finden.  Sie können sich auch die Dateien sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h und nptl / lowlevellock.c ansehen.  Der Code ist etwas verwirrend, aber die Kombination von Vergleichs- und Austausch- und Futex-Aufrufen ist immer noch einfach. <br><br>  Der erste Kommentar der Datei systeds / nptl / lowlevellock.h sollte von Ihnen bereits gut verstanden werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Gehen Sie Laufzeit-Futexe </h3><br>  Rantime Go verwendet libc (in den meisten Fällen) nicht.  Daher kann es sich nicht auf die Implementierung von POSIX-Threads verlassen.  Stattdessen werden direkt untergeordnete Systemaufrufe aufgerufen.  Dies macht es zu einem guten Beispiel für die Verwendung von Futexen.  Da es keine Möglichkeit gibt, pthread_mutex_t aufzurufen, müssen Sie Ihren eigenen Ersatz schreiben.  Lassen Sie uns sehen, wie dies gemacht wird. Beginnen wir mit dem für den Benutzer sichtbaren Typ sync.Mutex (in src / sync / mutex.go). <br><br>  Die Sperrmethode dieses Typs versucht, mithilfe der Atom-Swap-Operation die Sperre schnell zu erfassen.  Wenn sich herausstellt, dass Sie warten müssen, ruft es runtime_SemacquireMutex auf, das runtime.lock aufruft.  Diese Funktion ist in src / runtime / lock_futex.go definiert und deklariert mehrere Konstanten, die Ihnen bekannt vorkommen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock versucht auch, die Sperre mithilfe einer atomaren Funktion zu erfassen.  Dies ist sinnvoll, da runtime.lock an vielen Stellen der Go-Laufzeit aufgerufen wird. Es scheint mir jedoch möglich zu sein, den Code zu optimieren, indem beim Aufrufen von runtime.lock aus Mutex.lock zwei aufeinanderfolgende Aufrufe der atomaren Funktion entfernt werden. <br><br>  Wenn sich herausstellt, dass Sie warten müssen, wird die plattformabhängige Funktion futexsleep aufgerufen, die für Linux in der Datei src / runtime / os_linux.go definiert ist.  Diese Funktion führt einen Futex-Systemaufruf mit dem Code FUTEX_WAIT_PRIVATE durch (in diesem Fall ist dies geeignet, da die Go-Laufzeit in einem Prozess lebt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418705/">https://habr.com/ru/post/de418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Glück im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schlägt zurück</a></li>
<li><a href="../de418699/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 3</a></li>
<li><a href="../de418701/index.html">Wir studieren syntaktische Parser für die russische Sprache</a></li>
<li><a href="../de418709/index.html">Müssen Sie sich zwingen: Treiber und Schnittstellenbarrieren</a></li>
<li><a href="../de418711/index.html">Token Managed Registers 1.0</a></li>
<li><a href="../de418713/index.html">Spiel zur Verbesserung der Qualität von Wikipedia</a></li>
<li><a href="../de418715/index.html">Wie effizient ist das virtuelle procfs-Dateisystem und kann es optimiert werden?</a></li>
<li><a href="../de418717/index.html">Unicode-Geister</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>