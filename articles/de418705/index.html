<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∑ üìû üë©üèæ‚Äçüè´ Futex-Grundlagen ‚Ü™Ô∏è üë©üèø‚Äçü§ù‚Äçüë©üèº ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - Abk√ºrzung f√ºr "Fast Userspace Mutex") ist ein Mechanismus, der von Linux-Entwicklern von IBM im Jahr 2002 vorgeschlagen und Ende 2003 i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Futex-Grundlagen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  <b>Futex</b> (futex - Abk√ºrzung f√ºr "Fast Userspace Mutex") ist ein Mechanismus, der von Linux-Entwicklern von IBM im Jahr 2002 vorgeschlagen und Ende 2003 in den Kernel aufgenommen wurde.  Die Hauptidee bestand darin, eine effizientere M√∂glichkeit zum Synchronisieren von Benutzer-Threads mit einer minimalen Anzahl von Aufrufen an den Betriebssystemkern bereitzustellen. <br><br>  In diesem Artikel werden wir die Futexe √ºberpr√ºfen, versuchen, die Prinzipien ihrer Arbeit zu verstehen und sie auch als Bausteine ‚Äã‚Äãverwenden, um √ºbergeordnete (und uns vertraute) Synchronisationsobjekte zu erstellen. <br><br>  Ein wichtiger Punkt: Futexes ist ein eher einfaches Tool, das sich nur bei der Entwicklung grundlegender Bibliotheken wie der Standard-C / C ++ - Bibliothek direkt lohnt.  Es ist sehr unwahrscheinlich, dass Sie in einer regul√§ren Anwendung Futexe verwenden m√ºssen. <br><a name="habracut"></a><br><h3>  Motivation </h3><br>  Vor dem Aufkommen von Futexen war es erforderlich, jedes Mal Systemaufrufe (z. B. mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">semop</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchzuf√ºhren</a> , um den Zugriff auf gemeinsam genutzte Ressourcen von mehreren Threads aus zu steuern. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bekanntlich</a> ressourcenintensiv, da bei jedem Aufruf der Kontext vom Benutzermodus in den Kernelmodus ge√§ndert werden muss.  Mit der Zunahme der Anzahl von Kernen in modernen Prozessoren und der Zunahme der Anzahl von Threads in Anwendungssoftware ist dies zu einem erheblichen Problem geworden.  Es ist sogar noch ‚Äûbeleidigender‚Äú, da alle diese Aufrufe keine angewendete Funktion enthalten, keine Gesch√§ftslogik implementieren, sondern nur den korrekten Betrieb des restlichen Codes garantieren. <br><br>  Der Vorschlag, dem Betriebssystem ein neues Konzept von ‚ÄûFutex‚Äú hinzuzuf√ºgen, basierte auf einer einfachen Beobachtung: In den meisten F√§llen ist der Versuch, ein Synchronisationsobjekt zu erfassen, zum ersten Mal erfolgreich.  Programmierer schreiben Software so, dass vom Sperren des Schlosses bis zum Entsperren so wenig Zeit wie m√∂glich vergeht. Dies bedeutet, dass die Wahrscheinlichkeit sehr hoch ist, dass ein Versuch, einen anderen Thread zu erfassen, nicht auf Hindernisse st√∂√üt.  Wenn ein Stream ein solches "freies" Synchronisationsobjekt erreicht, k√∂nnen wir es erfassen, ohne einen Systemaufruf mit relativ billigen atomaren Operationen durchzuf√ºhren.  Und es besteht eine sehr gro√üe Chance, dass die atomare Operation erfolgreich funktioniert. <br><br>  In diesem seltenen Fall gibt eine atomare Operation einen Fehler zur√ºck, wenn wir immer noch versuchen, auf eine Ressource zuzugreifen, die von einem anderen Thread blockiert wurde.  In diesem Fall haben wir zwei M√∂glichkeiten.  Wir k√∂nnen entweder eine Spin-Sperre des Benutzermodus aktivieren und auf die Freigabe der Ressource warten (die die CPU-Ressourcen verschlingt), oder den Kernel bitten, uns in den Ruhemodus zu versetzen und auf die Freigabe der Ressource zu warten.  Hier kommen die Futexe ins Spiel. <br><br><h3>  Einfache Verwendung von Futexen - Erwartung und Erwachen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Futex-Systemaufruf</a> kombiniert eine Vielzahl von Funktionen.  Wir werden hier keine komplexen Optionen betrachten (einige davon sind so ausf√ºhrlich, dass sie nicht einmal in der offiziellen Dokumentation beschrieben werden), aber wir werden uns auf die Operationen FUTEX_WAIT und FUTEX_WAKE konzentrieren.  Die Beschreibung in der offiziellen Dokumentation dient als gute Grundlage: <br><blockquote>  Der Systemaufruf futex () bietet Programmen eine Methode, um darauf zu warten, dass eine bestimmte Bedingung erf√ºllt wird.  In der Regel verwendet dieser Systemaufruf ein Blockierungskonstrukt im Kontext der Synchronisierung des gemeinsam genutzten Speichers.  Bei Verwendung von Futexen werden die Hauptsynchronisationsvorg√§nge im Benutzerbereich ausgef√ºhrt.  User-Space-Programme f√ºhren den Systemaufruf futex () nur aus, wenn das Programm l√§ngere Zeit in den Standby-Modus wechseln muss, bis die Bedingung erf√ºllt ist.  Au√üerdem kann futex () verwendet werden, um Prozesse oder Threads zu aktivieren, die eine bestimmte Bedingung erwarten. </blockquote>  Einfach ausgedr√ºckt ist ein Futex ein Kernelkonstrukt, mit dessen Hilfe Benutzercode Threads synchronisieren kann, wenn etwas passiert.  Einige Prozesse (oder Threads) k√∂nnen auf Ereignisse in einem FUTEX_WAIT-Aufruf warten, w√§hrend andere diese Ereignisse mit FUTEX_WAKE aufrufen k√∂nnen.  Das Warten funktioniert effizient - wartende Threads werden vom Kernel angehalten und verwenden keine Prozessorressourcen, bis sie bei Auftreten eines erwarteten Ereignisses aktiviert werden. <br><br>  Nehmen Sie sich Zeit, um die gesamte Dokumentation zu lesen.  Nun, oder lesen Sie zumindest die Abschnitte √ºber FUTEX_WAIT und FUTEX_WAKE. <br><br>  Schauen wir uns ein <a href="">einfaches Beispiel an</a> , das die grundlegende Verwendung von Futexen zur Koordinierung der Arbeit zweier Prozesse demonstriert. <br><br>  Untergeordneter Prozess: <br><br><ol><li>  Wartet auf 0xA im allgemeinen Speichersteckplatz </li><li>  Schreibt den Wert 0xB in diesen Steckplatz </li></ol><br>  √úbergeordneter Prozess zu diesem Zeitpunkt: <br><br><ol><li>  Schreibt einen 0xA-Wert in einen gemeinsam genutzten Speichersteckplatz </li><li>  Wartet darauf, dass 0xB darin angezeigt wird </li></ol><br>  Ein solcher ‚ÄûHandschlag‚Äú zwischen zwei Prozessen.  Hier ist der Code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Achten Sie auf POSIX-Aufrufe, um gemeinsam genutzten Speicher zwischen Prozessen zuzuweisen.  Wir konnten hier nicht die √ºbliche Speicherzuordnung verwenden, da selbst die gleiche Adresse von Zeigern in verschiedenen Prozessen tats√§chlich auf verschiedene Speicherbl√∂cke verweisen w√ºrde (f√ºr jeden Prozess eindeutig). <br><br>  Es ist zu beachten, dass dieses Beispiel etwas von den Kanonen abweicht, da der Futex urspr√ºnglich erstellt wurde, um auf eine √Ñnderung einer bestimmten Bedeutung ‚Äûvon etwas Bestimmtem zu etwas‚Äú und nicht ‚Äûvon etwas zu etwas Bestimmtem‚Äú zu warten.  Ich habe dieses Beispiel gegeben, um eine solche M√∂glichkeit zu demonstrieren, und im Folgenden werden wir die Basisversion betrachten (darauf implementieren wir den Mutex). <br><br>  Und hier ist der Funktionscode wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  Die Hauptaufgabe dieser Funktion (neben dem eigentlichen Aufruf des Futex-Systems) ist ein Zyklus, in dem wir ausgef√ºhrt werden, wenn wir falsch aufwachen (nicht an uns interessiert).  Dies kann passieren, wenn ein neuer Wert, der von uns nicht erwartet wird, im gemeinsam genutzten Speichersteckplatz installiert wird.  Nun, oder in dem Fall, in dem ein anderer Prozess fr√ºher als bei uns ausgel√∂st wurde (dies kann in unserem speziellen Fall nicht geschehen, ist aber allgemeiner m√∂glich). <br><br>  Futex-Semantik ist ziemlich knifflig!  Der Aufruf von FUTEX_WAIT wird sofort zur√ºckgegeben, wenn der Wert an der Futex-Adresse nicht dem √ºbergebenen Argument val entspricht.  In unserem Fall kann dies passieren, wenn der untergeordnete Prozess gewartet hat, bevor der √ºbergeordnete Prozess den Wert 0xA in den Steckplatz geschrieben hat.  Der Futex gibt in diesem Fall den Wert EAGAIN zur√ºck. <br><br>  Und hier ist der Funktionscode wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Dies ist ein blockierender Wrapper √ºber FUTEX_WAKE, der schnell arbeitet und einen Wert zur√ºckgibt, unabh√§ngig davon, wie viele Listener ihn erwarten.  In unserem Beispiel wird dies als Teil eines ‚ÄûHandshakes‚Äú verwendet, aber andere Verwendungen sind m√∂glich. <br><br><h3>  Futexe sind Kernel-Warteschlangen f√ºr benutzerdefinierten Code. </h3><br>  Einfach ausgedr√ºckt ist ein Futex eine kernelgesteuerte Warteschlange zum L√∂sen von benutzerdefinierten Codeaufgaben.  Es erm√∂glicht dem Benutzercode, den Kernel aufzufordern, die Ausf√ºhrung seines Threads anzuhalten, bis ein Ereignis eintritt, und gleichzeitig dem anderen Thread dieses Ereignis zu signalisieren und alle darauf wartenden Threads zu aktivieren.  Zuvor haben wir die M√∂glichkeit erw√§hnt, eine Spin-Sperre im Benutzermodus zu organisieren und darauf zu warten, dass eine Bedingung erf√ºllt wird.  Die Warteschlange im Kernel ist jedoch eine viel bessere Alternative, da sie uns Milliarden verschwendeter Prozessoranweisungen erspart, die in einer Warteschleife ausgef√ºhrt werden. <br><br>  Hier ist das Diagramm aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEine Futex-√úbersicht und ein Update‚Äú</a> auf LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="Bild"><br><br>  Im Linux-Kernel-Code sind die Futexe in der Datei kernel / futex.c implementiert.  Der Kernel speichert eine Hash-Tabelle, in der die Schl√ºssel Adressen sind, um schnell die gew√ºnschte Warteschlange zu finden und den aufrufenden Prozess hinzuzuf√ºgen.  Nat√ºrlich ist nicht alles so einfach - schlie√ülich muss der Kernel selbst den Zugriff auf die darin enthaltenen Daten synchronisieren und alle m√∂glichen zus√§tzlichen Optionen f√ºr futeksov unterst√ºtzen. <br><br><h3>  Zeitlich begrenztes Warten mit FUTEX_WAIT </h3><br>  Der Futex-Systemaufruf verf√ºgt √ºber einen Timeout-Parameter, mit dem der Benutzer angeben kann, wie lange er warten m√∂chte.  Hier ist ein vollst√§ndiges <a href="">Beispiel,</a> in dem dies implementiert ist, aber hier ist der Schl√ºsselteil: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Wenn das Warten um 500 ms verz√∂gert wird, endet die Futex-Funktion und in der n√§chsten Iteration der Schleife k√∂nnen wir irgendwie darauf reagieren (etwas auf dem Bildschirm anzeigen, in das Protokoll schreiben, das Warten fortsetzen oder anhalten). <br><br><h3>  Verwenden eines Futex zum Implementieren eines Mutex </h3><br>  Wir haben diesen Artikel mit der Tatsache begonnen, dass Futexe bei der Implementierung √ºbergeordneter Synchronisationsobjekte von praktischem Nutzen sind.  Versuchen wir, sie (sowie Atomics) zu verwenden, um den klassischen Mutex zu implementieren.  Die folgende Implementierung basiert auf dem Code aus dem Artikel ‚ÄûFutexes are Tricky‚Äú von Ulrich Drepper. <br><br>  In diesem Beispiel verwende ich C ++, haupts√§chlich f√ºr die Verwendung von Atomics aus dem C ++ 11-Standard.  Den vollst√§ndigen Code finden Sie <a href="">hier</a> , aber der wichtigste Teil ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  In diesem Code ist die cmpxhg-Funktion ein einfacher Wrapper f√ºr die bequemere Verwendung von Atomen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Dieses Codebeispiel enth√§lt viele Kommentare, die die Logik seiner Funktionsweise erl√§utern.  Dies wird nicht schaden, da das Risiko gro√ü ist, dass Sie eine etwas einfachere, aber v√∂llig falsche Version davon schreiben m√∂chten.  Dieser Code ist auch nicht in allem perfekt.  Zum Beispiel versucht er, eine Annahme √ºber ein internes Ger√§t vom Typ std :: atomic zu machen, indem er seinen Inhalt in int * umwandelt, um ihn an den Futex-Aufruf weiterzuleiten.  Dies ist in der Regel nicht der Fall.  Der Code wird unter Linux x64 kompiliert und ausgef√ºhrt, es gibt jedoch keine Garantie f√ºr die Kompatibilit√§t mit anderen Plattformen.  Um dies zu erreichen, m√ºssen wir eine Plattformabh√§ngigkeitsschicht f√ºr Atome hinzuf√ºgen.  Da dies nicht das Thema dieses Artikels ist (und es auch sehr unwahrscheinlich ist, dass Sie Futexe im selben C ++ - Modul mischen), wird diese Implementierung weggelassen.  Dies ist nur eine Demonstration! <br><br><h3>  Glibc-Mutexe und Low-Level-Schl√∂sser </h3><br>  So kamen wir zu dem Punkt, an dem glibc POSIX-Threads implementiert, von denen ein Teil der Typ pthread_mutex_t ist.  Wie ich am Anfang dieses Artikels sagte, sind Futexe nicht ganz das, was ein gew√∂hnlicher Entwickler braucht.  Sie werden von Laufzeitbibliotheken oder etwas sehr Spezialisiertem verwendet, um √ºbergeordnete Synchronisationsprimitive zu implementieren.  In diesem Zusammenhang ist es interessant, die Implementierung des Mutex f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NPTL zu betrachten</a> .  Im Glibc-Code ist dies die Datei nptl / pthread_mutex_lock.c. <br><br>  Der Code ist ziemlich kompliziert, da verschiedene Arten von Mutexen unterst√ºtzt werden m√ºssen, aber wir k√∂nnen auf Wunsch recht vertraute Bl√∂cke finden.  Sie k√∂nnen sich auch die Dateien sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h und nptl / lowlevellock.c ansehen.  Der Code ist etwas verwirrend, aber die Kombination von Vergleichs- und Austausch- und Futex-Aufrufen ist immer noch einfach. <br><br>  Der erste Kommentar der Datei systeds / nptl / lowlevellock.h sollte von Ihnen bereits gut verstanden werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Gehen Sie Laufzeit-Futexe </h3><br>  Rantime Go verwendet libc (in den meisten F√§llen) nicht.  Daher kann es sich nicht auf die Implementierung von POSIX-Threads verlassen.  Stattdessen werden direkt untergeordnete Systemaufrufe aufgerufen.  Dies macht es zu einem guten Beispiel f√ºr die Verwendung von Futexen.  Da es keine M√∂glichkeit gibt, pthread_mutex_t aufzurufen, m√ºssen Sie Ihren eigenen Ersatz schreiben.  Lassen Sie uns sehen, wie dies gemacht wird. Beginnen wir mit dem f√ºr den Benutzer sichtbaren Typ sync.Mutex (in src / sync / mutex.go). <br><br>  Die Sperrmethode dieses Typs versucht, mithilfe der Atom-Swap-Operation die Sperre schnell zu erfassen.  Wenn sich herausstellt, dass Sie warten m√ºssen, ruft es runtime_SemacquireMutex auf, das runtime.lock aufruft.  Diese Funktion ist in src / runtime / lock_futex.go definiert und deklariert mehrere Konstanten, die Ihnen bekannt vorkommen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock versucht auch, die Sperre mithilfe einer atomaren Funktion zu erfassen.  Dies ist sinnvoll, da runtime.lock an vielen Stellen der Go-Laufzeit aufgerufen wird. Es scheint mir jedoch m√∂glich zu sein, den Code zu optimieren, indem beim Aufrufen von runtime.lock aus Mutex.lock zwei aufeinanderfolgende Aufrufe der atomaren Funktion entfernt werden. <br><br>  Wenn sich herausstellt, dass Sie warten m√ºssen, wird die plattformabh√§ngige Funktion futexsleep aufgerufen, die f√ºr Linux in der Datei src / runtime / os_linux.go definiert ist.  Diese Funktion f√ºhrt einen Futex-Systemaufruf mit dem Code FUTEX_WAIT_PRIVATE durch (in diesem Fall ist dies geeignet, da die Go-Laufzeit in einem Prozess lebt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418705/">https://habr.com/ru/post/de418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418691/index.html">Rancher: Kubernetes in 5 Minuten auf Bare Metal</a></li>
<li><a href="../de418693/index.html">Warum ist Gl√ºck im Gehirn so schwer zu erkennen?</a></li>
<li><a href="../de418695/index.html">Anti-Piraterie-Kriege - Das Imperium schl√§gt zur√ºck</a></li>
<li><a href="../de418699/index.html">Erstellen eines Emulator-Arcade-Automaten. Teil 3</a></li>
<li><a href="../de418701/index.html">Wir studieren syntaktische Parser f√ºr die russische Sprache</a></li>
<li><a href="../de418709/index.html">M√ºssen Sie sich zwingen: Treiber und Schnittstellenbarrieren</a></li>
<li><a href="../de418711/index.html">Token Managed Registers 1.0</a></li>
<li><a href="../de418713/index.html">Spiel zur Verbesserung der Qualit√§t von Wikipedia</a></li>
<li><a href="../de418715/index.html">Wie effizient ist das virtuelle procfs-Dateisystem und kann es optimiert werden?</a></li>
<li><a href="../de418717/index.html">Unicode-Geister</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>