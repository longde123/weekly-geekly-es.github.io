<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖ üòß üïπÔ∏è Analisis kerentanan Parcel Jahat ü§° üòª üî≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Pada pertengahan April, kami menerbitkan berita tentang trojan Android.InfectionAds.1 , yang mengeksploitasi beberapa kerentanan kritis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis kerentanan Parcel Jahat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457610/"><h3>  Pendahuluan </h3><br>  Pada pertengahan April, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan berita</a> tentang trojan <b>Android.InfectionAds.1</b> , yang mengeksploitasi beberapa kerentanan kritis di Android.  Salah satunya, CVE-2017-13156 (juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janus</a> ), memungkinkan malware menginfeksi file APK tanpa merusak tanda tangan digital.  Yang lainnya adalah CVE-2017-13315.  Ini memberi trojan hak istimewa yang diperluas, sehingga dapat menginstal dan menghapus aplikasi secara terpisah dari pengguna.  Analisis terperinci tentang <b>Android.InfectionAds.1</b> tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan virus kami</a> ;  sementara kita di sini kita akan menyentuh kerentanan CVE-2017-13315 dan melihat apa fungsinya. <br><a name="habracut"></a><br>  CVE-2017-13315 termasuk dalam kelompok kerentanan yang dijuluki EvilParcel.  Mereka ditemukan di berbagai kelas sistem Android.  Kesalahan di kelas-kelas ini memungkinkan untuk mengganti informasi selama pertukaran data antara aplikasi dan sistem.  Malware yang mengeksploitasi kerentanan EvilParcel dengan demikian diberikan hak istimewa yang lebih tinggi dan menjadi mampu melakukan hal berikut: <br><br><ul><li>  menginstal dan menghapus aplikasi dengan izin apa pun tanpa konfirmasi dari pengguna; </li><li>  menginfeksi perangkat lunak yang diinstal pada perangkat dan mengganti dokumen asli yang bersih dengan salinan yang terinfeksi ketika digunakan bersama dengan kerentanan lainnya; </li><li>  mengatur ulang PIN layar kunci pada perangkat Android. </li></ul><br>  Sampai sekarang, kita tahu tentang 7 kerentanan jenis ini: <br><ul><li>  CVE-2017-0806 (kesalahan di kelas GateKeeperResponse), diterbitkan pada Oktober 2017; </li><li>  CVE-2017-13286 (kesalahan dalam kelas OutputConfiguration, diterbitkan pada April 2018; </li><li>  CVE-2017-13287 (kesalahan dalam kelas VerifyCredentialResponse), diterbitkan pada April 2018; </li><li>  CVE-2017-13288 (kesalahan dalam kelas PeriodicAdvertizingReport), diterbitkan pada April 2018; </li><li>  CVE-2017-13289 (kesalahan dalam kelas ParcelableRttResults), diterbitkan pada bulan April 2018; </li><li>  CVE-2017-13311 (kesalahan dalam kelas SparseMappingTable), diterbitkan pada Mei 2018; </li><li>  CVE-2017-13315 (kesalahan dalam kelas DcParamObject), diterbitkan pada Mei 2018. </li></ul><br>  Semuanya menimbulkan ancaman bagi perangkat yang menjalankan Android 5.0 - 8.1 tanpa pemutakhiran Mei 2018 (atau lebih baru) diinstal. <br><br><h3>  Prasyarat untuk kerentanan EvilParcel </h3><br>  Mari kita lihat bagaimana kerentanan EvilParcel dapat muncul.  Pertama-tama, kita perlu melihat beberapa fitur aplikasi Android.  Semua program Android berinteraksi satu sama lain, serta dengan sistem operasi, dengan mengirim dan menerima objek Intent.  Objek-objek ini dapat berisi jumlah pasangan kunci-nilai yang sewenang-wenang di dalam objek Bundle. <br><br>  Ketika mentransfer Intent, objek Bundle dikonversi (serial) menjadi array byte yang dibungkus Parcel, dan kemudian secara otomatis deserialized setelah membaca kunci dan nilai-nilai dari Bundel serial. <br><br>  Di Bundle, kuncinya adalah string, dan nilainya bisa hampir apa saja.  Misalnya, itu bisa menjadi tipe primitif, string, atau wadah dengan tipe atau string primitif.  Ini juga bisa menjadi objek Parcelable. <br><br>  Dengan demikian, Bundle dapat berisi objek jenis apa pun yang mengimplementasikan antarmuka Parcelable.  Untuk ini, kita perlu mengimplementasikan metode writeToParcel () dan createFromParcel () untuk membuat cerita bersambung dan deserialisasi objek. <br><br>  Untuk mengilustrasikan poin kami, mari buat bundel serial sederhana.  Kami akan menulis kode yang menempatkan tiga pasangan nilai kunci di Bundle dan membuat serialisasi: <br><br><img src="https://habrastorage.org/webt/pf/-9/2j/pf-92jsexpyrb7p2dvi8oj3-vbs.png"><br>  Gambar 1. Struktur objek bundel berseri <br><br>  Perhatikan fitur spesifik dari serialisasi bundel: <br><br><ul><li>  semua pasangan kunci-nilai ditulis secara berurutan; </li><li>  tipe nilai ditunjukkan sebelum setiap nilai (13 untuk array byte, 1 untuk integer, 0 untuk string, dll.); </li><li>  ukuran panjang data variabel ditunjukkan sebelum data (panjang untuk string, jumlah byte untuk array); </li><li>  semua nilai selaras 4-byte. </li></ul><br><br>  Semua kunci dan nilai dituliskan dalam Bundle secara berurutan sehingga saat mengakses kunci atau nilai objek Bundle berseri apa pun, yang terakhir ini akan menghilangkan desisialisasi seluruhnya, juga menginisialisasi semua objek Parcelable yang berisi. <br><br>  Jadi, apa masalahnya?  Masalahnya adalah bahwa beberapa kelas sistem yang mengimplementasikan Parcelable mungkin mengandung kesalahan dalam metode createFromParcel () dan writeToParcel ().  Di kelas-kelas ini, jumlah byte yang dibaca di createFromParcel () akan berbeda dari jumlah byte yang ditulis dalam writeToParcel ().  Jika Anda menempatkan objek kelas ini di dalam Bundel, batas objek di dalam Bundel akan berubah setelah reserialisasi.  Ini menciptakan kondisi untuk mengeksploitasi kerentanan EvilParcel. <br><br>  Mari kita lihat contoh kelas yang mengandung kesalahan ini: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Jika ukuran array data adalah 0, maka saat membuat objek, satu int (4 byte) akan dibaca di createFromParcel () dan dua int (8 byte) akan ditulis dalam writeToParcel ().  Int pertama akan ditulis dengan secara eksplisit memanggil writeInt.  Int kedua akan ditulis saat memanggil writeByteArray (), karena panjang array selalu ditulis sebelum array dalam Parcel (lihat Gambar 1). <br><br>  Situasi di mana ukuran array data sama dengan 0 cukup langka.  Tetapi bahkan ketika ini terjadi, program tetap beroperasi, jika Anda hanya mengirimkan satu objek serial pada satu waktu (dalam contoh kami, objek Demo).  Karena itu, kesalahan semacam itu cenderung tidak diperhatikan. <br><br>  Sekarang kita akan mencoba menempatkan objek Demo dengan panjang array nol di Bundel: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  Gambar 2. Hasil menambahkan objek Demo panjang-nol ke Bundel <br><br>  Kami cerita bersambung objek: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  Gambar 3. Objek Bundel setelah serialisasi <br><br>  Sekarang mari kita coba deserialize: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  Gambar 4. Objek Bundel setelah deserialisasi <br><br>  Apa yang kita dapatkan  Mari kita lihat fragmen Parcel: <br><br><img src="https://habrastorage.org/webt/tf/qa/fn/tfqafnxzmsfujmq2xyo-kwvbc2g.png"><br>  Gambar 5. Struktur parsel setelah deserialisasi bundel <br><br>  Dalam Gambar 4 dan 5, kita melihat bahwa alih-alih dua int, satu int dibaca dalam metode createFromParcel selama deserialization.  Oleh karena itu, semua nilai selanjutnya dari Bundel dibaca secara tidak benar.  Nilai 0x0 pada 0x60 dibaca sebagai panjang kunci berikutnya.  Nilai 0x1 pada 0x64 dibaca sebagai kunci.  Nilai 0x31 pada 0x68 dibaca sebagai tipe nilai.  Parcel tidak memiliki nilai dengan tipe 0x31, oleh karena itu readFromParcel () dengan susah payah melaporkan pengecualian. <br><br>  Bagaimana ini bisa digunakan dalam kehidupan nyata dan menjadi kerentanan?  Ayo lihat!  Kesalahan di atas dalam kelas sistem Parcelable memungkinkan pembuatan Bundel yang mungkin berbeda selama deserialisasi yang pertama dan berulang.  Untuk mendemonstrasikan ini, kami akan memodifikasi contoh sebelumnya: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Kode ini menciptakan bundel berseri yang berisi kelas rentan.  Sekarang mari kita lihat apa yang kita dapatkan setelah mengeksekusi kode ini: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  Gambar 6. Membuat Bundel dengan kelas rentan <br><br>  Setelah deserialisasi pertama, Bundel ini akan berisi kunci-kunci berikut: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  Gambar 7. Setelah deserialisasi bundel dengan kelas rentan <br><br>  Sekarang kita akan membuat serial bundel lagi, lalu deserialisasi lagi, dan lihat daftar kunci: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  Gambar 8. Hasil reserializing dan deserializing Bundle dengan kelas rentan <br><br>  Apa yang kita lihat  Bundel sekarang berisi kunci Tersembunyi (dengan nilai string "Hai di sana!"), Yang sebelumnya tidak ada di sana.  Mari kita lihat fragmen Parcel Bundle ini untuk melihat mengapa ini terjadi: <br><br><img src="https://habrastorage.org/webt/i8/up/j1/i8upj1jif-_d41drqii19gw2nce.png"><br>  Gambar 9. Struktur paket objek Bundle dengan kelas rentan setelah dua siklus serialisasi dan deserialisasi <br><br>  Di sinilah kita bisa melihat seluruh titik kerentanan EvilParcel.  Kami dapat secara khusus membuat Bundel yang akan berisi kelas rentan.  Mengubah batas-batas kelas ini akan memungkinkan penempatan objek apa pun di Bundel ini;  misalnya, sebuah Intent, yang hanya akan muncul di Bundel setelah deserialisasi kedua.  Ini membantu menyembunyikan Intent dari mekanisme keamanan OS. <br><br><h3>  Memanfaatkan EvilParcel </h3><br>  <b>Android.InfectionAds.1</b> mengeksploitasi CVE-2017-13315 untuk menginstal dan menghapus perangkat lunak secara mandiri dari pemilik perangkat.  Tapi bagaimana caranya? <br><br>  Pada 2013, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan 7699048</a> , juga dikenal sebagai Launch AnyWhere, ditemukan.  Itu memungkinkan aplikasi pihak ketiga untuk memulai aktivitas sewenang-wenang atas nama pengguna sistem yang lebih istimewa.  Lihat diagram di bawah ini untuk mekanisme tindakan: <br><br><img src="https://habrastorage.org/webt/in/d8/-m/ind8-mnyp5urfsndbkycy3l42f8.png"><br>  Gambar 10. Pengoperasian error 7699048 <br><br>  Aplikasi yang mengeksploitasi dapat menggunakan kerentanan ini untuk mengimplementasikan layanan Authenticator Akun, yang dirancang untuk menambahkan akun baru ke sistem operasi.  Kesalahan 7699048 membantu kegiatan peluncuran mengeksploitasi untuk menginstal, menghapus, mengganti aplikasi, serta mengatur ulang PIN atau Pattern Lock dan menyebabkan lebih banyak masalah. <br><br>  Google Inc.  telah menghilangkan pelanggaran ini dengan melarang peluncuran aktivitas sewenang-wenang dari AccountManager.  Sekarang, AccountManager hanya memungkinkan peluncuran aktivitas yang berasal dari aplikasi yang sama.  Untuk tujuan ini, ia memeriksa dan mencocokkan tanda tangan digital dari perangkat lunak yang memulai aktivitas dengan tanda tangan aplikasi di mana aktivitas tersebut berada.  Ini terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Tampaknya masalah telah diselesaikan, tetapi tidak semudah itu.  Ternyata kerentanan terkenal, EvilParcel CVE-2017-13315, memberikan solusi!  Seperti yang sudah kita ketahui, setelah memperbaiki Launch AnyWhere, sistem memverifikasi tanda tangan digital aplikasi.  Jika berhasil diverifikasi, Bundle ditransfer ke IAccountManagerResponse.onResult ().  Pada saat yang sama, onResult () dipanggil melalui mekanisme IPC, sehingga Bundle diserialisasi lagi.  Saat menerapkan onResult (), berikut ini terjadi: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Kemudian, Bundel mengekstrak kunci maksud, dan aktivitas diluncurkan tanpa verifikasi apa pun. <br>  Dengan demikian, untuk meluncurkan aktivitas sewenang-wenang dengan hak istimewa sistem, Anda hanya perlu membuat Bundel dengan bidang Intent yang disembunyikan pada deserialisasi pertama dan muncul selama deserialisasi berulang. <br>  Seperti yang sudah kita ketahui, kerentanan EvilParcel sebenarnya dapat melakukan tugas ini. <br><br>  Saat ini, semua kerentanan yang diketahui dari tipe ini telah diperbaiki dalam kelas Parcelable yang rentan.  Namun, kelas rentan baru dapat muncul di masa depan.  Implementasi bundel dan mekanisme untuk menambah akun baru masih sama seperti sebelumnya.  Mereka masih memungkinkan kita untuk membuat exploit yang tepat ini ketika mendeteksi kelas Parcelable rentan lama atau baru.  Selain itu, kelas-kelas ini masih diimplementasikan secara manual, dan programmer harus memastikan bahwa panjang objek Parcelable serial tetap sama, yang merupakan faktor manusia dengan semua yang disiratkannya.  Namun, kami berharap akan ada kesalahan sesedikit mungkin, dan kerentanan EvilParcel tidak akan menjadi ancaman bagi pengguna Android. <br><br>  Anda dapat memeriksa kerentanan perangkat seluler EvilParcel Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ruang Keamanan Dr.Web</a> kami untuk Android.  Auditor Keamanan bawaan akan melaporkan masalah yang terdeteksi dan merekomendasikan cara untuk menghilangkannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457610/">https://habr.com/ru/post/id457610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457596/index.html">OSDay 19 atau mengapa bahasa C masih hidup</a></li>
<li><a href="../id457600/index.html">Ikhtisar Headset Snom A150, Snom A100M dan D</a></li>
<li><a href="../id457602/index.html">Meneliti kinerja DBMS MS SQL Server Developer 2016 dan PostgreSQL 10.5 untuk 1C</a></li>
<li><a href="../id457606/index.html">Alan Kay: Apa yang bisa disebut hal paling menakjubkan yang dimungkinkan oleh komputer</a></li>
<li><a href="../id457608/index.html">Cara memvisualisasikan data menjadi cerita yang menarik</a></li>
<li><a href="../id457612/index.html">Bagaimana cara mempercepat dekompresi LZ4 di ClickHouse?</a></li>
<li><a href="../id457614/index.html">Rahasia mencari pekerjaan di luar negeri dari seorang headhunter yang berpraktik</a></li>
<li><a href="../id457616/index.html">"Wow, aku tidak tahu itu!" saat-saat dengan bercanda</a></li>
<li><a href="../id457618/index.html">Menjadi pengembang penuh tumpukan modern</a></li>
<li><a href="../id457622/index.html">Mengukur Kinerja Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>