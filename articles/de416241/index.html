<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ù üë©üèø‚Äç‚öñÔ∏è üåø Abrufen von Levels von Super Mario Bros mit Python üìò üëµüèæ ‚ôæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 F√ºr ein neues Projekt musste ich Level-Daten aus dem klassischen Videospiel Super Mario Bros (SMB) von 1985 extrahieren. Insbesondere wol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abrufen von Levels von Super Mario Bros mit Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2>  Einf√ºhrung </h2><br>  F√ºr ein neues Projekt musste ich Level-Daten aus dem klassischen Videospiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Super Mario Bros (SMB)</a> von 1985 extrahieren.  Insbesondere wollte ich die Hintergrundgrafiken der einzelnen Ebenen des Spiels ohne Benutzeroberfl√§che, bewegte Sprites usw. extrahieren. <br><br>  Nat√ºrlich k√∂nnte ich nur die Bilder aus dem Spiel kleben und m√∂glicherweise den Prozess mithilfe von Bildverarbeitungstechniken automatisieren.  Interessanter erschien mir jedoch die unten beschriebene Methode, mit der Sie die Ebenenelemente untersuchen k√∂nnen, die mit Screenshots nicht erhalten werden k√∂nnen. <br><br>  In der ersten Phase des Projekts lernen wir die Assembler-Sprache 6502 und einen in Python geschriebenen Emulator.  Den vollst√§ndigen Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><a name="habracut"></a><br><h2>  Quellcode-Analyse </h2><br>  Das Reverse Engineering eines Programms ist viel einfacher, wenn Sie seinen Quellcode haben, und wir haben SMB-Quellen in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">17.000 Zeilen Assembler-Code 6502 (NES-Prozessor),</a> die von doppelganger ver√∂ffentlicht wurden.  Da Nintendo nie eine offizielle Quellversion ver√∂ffentlicht hat, wurde der Code durch Zerlegen des SMB-Maschinencodes erstellt, wobei die Bedeutung jedes Teils schmerzhaft entschl√ºsselt, Kommentare und aussagekr√§ftige symbolische Namen hinzugef√ºgt wurden. <br><br>  Nachdem ich eine schnelle Suche in der Datei durchgef√ºhrt hatte, fand ich etwas √Ñhnliches wie die ben√∂tigten Level-Daten: <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br>  Wenn Sie mit Assembler nicht vertraut sind, erkl√§re ich Folgendes: All dies bedeutet einfach "F√ºgen Sie einen solchen Satz von Bytes in das kompilierte Programm ein und lassen Sie dann andere Teile des Programms mit dem Symbol <code>L_GroundArea6</code> darauf verweisen".  Sie k√∂nnen dieses Fragment als Array verwenden, in dem jedes Element ein Byte ist. <br><br>  Das erste, was Sie feststellen k√∂nnen, ist, dass das Datenvolumen sehr klein ist (ca. 100 Byte).  Daher schlie√üen wir alle Arten der Codierung aus, sodass Sie Bl√∂cke beliebig auf der Ebene platzieren k√∂nnen.  Nachdem ich ein bisschen gesucht hatte, stellte ich fest, dass diese Daten (nach mehreren indirekten Adressierungsvorg√§ngen) in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AreaParserCore gelesen wurden</a> .  Diese Unterprozedur ruft wiederum viele andere Unterprozeduren auf und ruft letztendlich bestimmte Unterprozeduren f√ºr jeden in der Szene zul√§ssigen Objekttyp auf (z. B. <code>StaircaseObject</code> , <code>VerticalPipe</code> , <code>RowOfBricks</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i><code>AreaParserCore</code> f√ºr <code>AreaParserCore</code></i> <br><br>  Die Prozedur schreibt in <code>MetatileBuffer</code> : einen 13-Byte-Speicherabschnitt, der eine Spalte von Bl√∂cken in einer Ebene ist, von denen jedes Byte einen separaten Block darstellt.  Eine Metatile ist ein 16x16-Block, aus dem die Hintergr√ºnde eines SMB-Spiels bestehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>Ebene mit Rechtecken, die um Metatile kreisen</i> <br><br>  Sie werden als Metadateien bezeichnet, da jede aus vier 8x8-Pixel-Kacheln besteht, aber dazu weiter unten mehr. <br><br>  Die Tatsache, dass der Decoder mit vordefinierten Objekten arbeitet, erkl√§rt die geringe Gr√∂√üe des Levels: Level-Daten sollten sich nur auf die Objekttypen und deren Position beziehen, z. B. ‚ÄûPositionieren Sie das Rohr am Punkt (20, 16), eine Anzahl von Bl√∂cken am Punkt (10, 5), ... ".  Dies bedeutet jedoch, dass viel Code erforderlich ist, um Rohdaten in Metadateien umzuwandeln. <br><br>  Das Portieren dieser Codemenge zum Erstellen eines eigenen Level-Unpackers w√ºrde zu viel Zeit in Anspruch nehmen. Versuchen wir also einen anderen Ansatz. <br><br><h2>  py65emu </h2><br>  Wenn wir eine Schnittstelle zwischen Python und der Assembler-Sprache 6502 h√§tten, k√∂nnten wir die <code>AreaParserCore</code> f√ºr jede <code>AreaParserCore</code> aufrufen und dann verst√§ndlicheres Python verwenden, um die <code>AreaParserCore</code> in das gew√ºnschte Bild zu konvertieren. <br><br>  Dann erscheint <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">py65emu</a> in der Szene - ein pr√§gnanter 6502-Emulator mit einer Python-Oberfl√§che.  So wird in py65emu dieselbe Speicherkonfiguration wie in NES konfiguriert: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br>  Danach k√∂nnen wir einzelne Anweisungen mit der Methode <code>cpu.step()</code> ausf√ºhren, den Speicher mit <code>mmu.read()</code> , die Maschinenregister mit <code>cpu.ra</code> , <code>cpu.r.pc</code> usw. untersuchen.  Au√üerdem k√∂nnen wir mit <code>mmu.write()</code> in den Speicher schreiben. <br><br>  Es ist erw√§hnenswert, dass dies nur ein NES-Prozessor-Emulator ist: Er emuliert keine andere Hardware, wie z. B. PPU (Picture Processing Unit), und kann daher nicht zum Emulieren des gesamten Spiels verwendet werden.  Es sollte jedoch ausreichen, die Parsing-Unterprozedur aufzurufen, da keine anderen Hardwareger√§te au√üer der CPU und dem Speicher verwendet werden. <br><br>  Es ist geplant, die CPU wie oben gezeigt zu konfigurieren und dann f√ºr jede <code>AreaParserCore</code> die Speicherpartitionen mit den f√ºr <code>AreaParserCore</code> erforderlichen Eingabewerten zu <code>AreaParserCore</code> , <code>AreaParserCore</code> und dann die <code>AreaParserCore</code> zur√ºckzulesen.  Nach Abschluss dieser Vorg√§nge verwenden wir Python, um das Ergebnis zu einem fertigen Bild zusammenzusetzen. <br><br>  Zuvor m√ºssen wir jedoch die Liste in Assemblersprache in Maschinencode kompilieren. <br><br><h2>  x816 </h2><br>  Wie im Quellcode angegeben, wird der Assembler mit x816 kompiliert.  x816 ist ein MS-DOS-Assembler 6502, der von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homebrew-</a> Community f√ºr NES- und ROM-Hacker verwendet wird.  Es funktioniert hervorragend unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DOSBox</a> . <br><br>  Zusammen mit dem ROM des Programms, das f√ºr py65emu erforderlich ist, erstellt der x816-Assembler eine Zeichendatei, die Zeichen ihrem Speicherort im Adressraum der CPU zuordnet.  Hier ist ein Ausschnitt aus der Datei: <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br>  Hier sehen wir, dass auf die <code>AreaParserCore</code> Funktion im Quellcode unter <code>0x93fc</code> zugegriffen werden <code>0x93fc</code> . <br><br>  Der Einfachheit halber habe ich einen Symboldateiparser geschrieben, der mit Symbolnamen und -adressen √ºbereinstimmt: <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2>  Unterverfahren </h2><br>  Wie im obigen Plan angegeben, m√∂chten wir lernen, wie die <code>AreaParserCore</code> von Python aus <code>AreaParserCore</code> . <br><br>  Um die Mechanik eines Unterverfahrens zu verstehen, untersuchen wir ein kurzes Unterverfahren und die entsprechende Herausforderung: <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  Der <code>jsr</code> (Sprung zum Unterprogramm, "Sprung zum Unterprogramm") <code>jsr</code> PC-Register auf den Stapel und weist ihm den Adresswert zu, auf den sich <code>WritePPUReg1</code> bezieht.  Das PC-Register teilt dem Prozessor die Adresse des n√§chsten zu <code>jsr</code> Befehls mit, so dass der n√§chste Befehl, der nach dem <code>jsr</code> ausgef√ºhrt wird, die erste Zeile von <code>WritePPUReg1</code> . <br><br>  Am Ende des Unterprogramms wird die Anweisung <code>rts</code> ausgef√ºhrt (R√ºckgabe vom Unterprogramm, "R√ºckgabe vom Unterprogramm").  Dieser Befehl entfernt den gespeicherten Wert aus dem Stapel und speichert ihn im PC-Register, wodurch die CPU <code>jsr</code> , den Befehl nach dem <code>jsr</code> Aufruf auszuf√ºhren. <br><br>  Eine gro√üartige Funktion von Unterprozeduren besteht darin, dass Sie Inline-Aufrufe erstellen k√∂nnen, dh Unterprozeduraufrufe innerhalb von Unterprozeduren.  R√ºcksprungadressen werden auf den Stapel verschoben und in der richtigen Reihenfolge angezeigt, genau wie bei Funktionsaufrufen in Hochsprachen. <br><br>  Hier ist der Code zum Ausf√ºhren der Unterroutine von Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br>  Der Code speichert den aktuellen Wert der Stapelzeigerregister, emuliert einen <code>jsr</code> Aufruf und f√ºhrt dann Anweisungen aus, bis der Stapel auf seine urspr√ºngliche H√∂he zur√ºckkehrt, was erst nach der R√ºckgabe der ersten Unterprozedur geschieht.  Dies ist n√ºtzlich, da wir jetzt die M√∂glichkeit haben, 6502-Subroutinen direkt von Python aus aufzurufen. <br><br>  Wir haben jedoch etwas vergessen: Wie werden Eingabewerte f√ºr diese Unterprozedur √ºbergeben?  Wir m√ºssen der Prozedur mitteilen, welche Ebene wir rendern m√∂chten und welche Spalte wir analysieren m√ºssen. <br><br>  Im Gegensatz zu Funktionen in Hochsprachen k√∂nnen Unterprogramme der Assemblersprache 6502 keine explizit angegebenen Eingabedaten empfangen.  Stattdessen wird die Eingabe √ºbertragen, indem Speicherpl√§tze irgendwo vor dem Aufruf angegeben werden, die dann innerhalb des Unterprozeduraufrufs gelesen werden.  Angesichts der Gr√∂√üe von <code>AreaParserCore</code> ist das Reverse Engineering der erforderlichen Eingabe durch einfaches Betrachten des Quellcodes sehr komplex und fehleranf√§llig. <br><br><h2>  Valgrind f√ºr NES? </h2><br>  Um einen Weg zu finden, die Eingabewerte von <code>AreaParserCore</code> zu bestimmen, habe ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Memcheck-</a> Tool f√ºr Valgrind als Beispiel verwendet.  Memcheck erkennt Zugriffsvorg√§nge auf nicht initialisierten Speicher, indem der Schattenspeicher parallel zu jedem Fragment des tats√§chlich zugewiesenen Speichers gespeichert wird.  Der Schattenspeicher zeichnet auf, ob eine Aufzeichnung in den entsprechenden realen Speicher erfolgt ist.  Wenn das Programm an die Adresse liest, an die es nie geschrieben hat, wird ein nicht initialisierter Speicherfehler ausgegeben.  Wir k√∂nnen <code>AreaParserCore</code> mit einem Tool <code>AreaParserCore</code> , das uns sagt, welche Eingaben festgelegt werden m√ºssen, bevor die <code>AreaParserCore</code> . <br><br>  Tats√§chlich ist das Schreiben einer einfachen Memcheck-Version f√ºr py65emu sehr einfach: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Hier haben wir die Speicherverwaltungseinheit (MMU) von py65emu verpackt.  Diese Klasse enth√§lt ein nicht <code>_uninitialized</code> Array, dessen Elemente uns mitteilen, ob es jemals in das entsprechende Byte des emulierten RAM geschrieben wurde.  Bei einem nicht initialisierten Lesevorgang werden die Adresse des ung√ºltigen Lesevorgangs und der Name des entsprechenden Zeichens angezeigt. <br><br>  Hier sind die Ergebnisse der <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> MMU beim Aufruf von <code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> : <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br>  Wenn Sie sich den Code ansehen, k√∂nnen Sie sehen, dass viele dieser Werte von der <code>InitializeArea</code> Unterprozedur festgelegt werden. F√ºhren Sie das Skript also erneut aus und rufen Sie zuerst diese Funktion auf.  Wenn wir diesen Vorgang wiederholen, kommen wir zu der folgenden Abfolge von Anrufen, f√ºr die nur die Weltnummer und die Bereichsnummer erforderlich sind: <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br>  Der Code schreibt die ersten 48 Spalten der World 1-1-Ebene in <code>metatile_data</code> , wobei die <code>IncrementColumnPos</code> <code>metatile_data</code> , um die internen Variablen zu erh√∂hen, die zum Verfolgen der aktuellen Spalte erforderlich sind. <br><br>  Und hier ist der Inhalt von <code>metatile_data</code> , der Screenshots aus dem Spiel √ºberlagert ist (Bytes mit dem Wert 0 werden nicht angezeigt): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br>  Offensichtlich <code>metatile_data</code> eindeutig mit Hintergrundinformationen √ºberein. <br><br><h2>  Metagrafiken </h2><br>  (Um das Endergebnis zu sehen, k√∂nnen Sie sofort mit dem Abschnitt ‚ÄûAlles miteinander verbinden‚Äú fortfahren.) <br><br>  Lassen Sie uns nun herausfinden, wie die empfangene Anzahl von Metadateien in echte Bilder umgewandelt werden kann.  Die unten beschriebenen Schritte wurden erfunden, indem die Quellen analysiert und die Dokumentation mit dem erstaunlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nesdev-Wiki gelesen wurden</a> . <br><br>  Um zu verstehen, wie jede Metatilit√§t gerendert wird, m√ºssen wir zun√§chst √ºber NES-Farbpaletten sprechen.  Die NES-Konsolen-PPU kann im Allgemeinen 64 verschiedene Farben rendern, Schwarz wird jedoch mehrmals dupliziert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzelheiten</a> siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nesdev</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br>  Jede Mario-Stufe kann nur 10 dieser 64 Farben f√ºr den Hintergrund verwenden, die in 4 Vierfarbenpaletten unterteilt sind.  Die erste Farbe ist immer die gleiche.  Hier sind vier Paletten f√ºr World 1-1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br>  Schauen wir uns nun ein bin√§res Beispiel f√ºr eine Metadateinummer an.  Hier ist die metatile Zahl der geknackten Steinfliesen, bei der es sich um Land der Stufe 1-1 handelt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br>  Der Palettenindex gibt an, welche Palette beim Rendern der Metatile verwendet werden soll (in unserem Fall Palette 1).  Der Palettenindex ist auch der Index der folgenden zwei Arrays: <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br>  Die Kombination dieser beiden Arrays ergibt eine 16-Bit-Adresse, die in unserem Beispiel auf <code>Palette1_Mtiles</code> : <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br>  Wenn Sie den metatilen Index mit 4 multiplizieren, wird er zum Index dieses Arrays.  Die Daten sind in 4 Datens√§tzen pro Zeile formatiert, daher bezieht sich unser Beispiel metatile auf die zwanzigste Zeile, die mit einem Kommentar zum <code>cracked rock terrain</code> gekennzeichnet ist. <br><br>  Die vier Eintr√§ge dieser Zeile sind tats√§chlich Kachelkennungen: Jede Metatile besteht aus vier 8x8-Pixel-Kacheln, die in der folgenden Reihenfolge angeordnet sind - oben links, unten links, oben rechts und unten rechts.  Diese Kennungen werden direkt an die NES-PPU-Konsole √ºbergeben.  Die Kennung bezieht sich auf 16 Datenbytes in der CHR-ROM-Konsole, und jeder Datensatz beginnt mit der Adresse <code>0x1000 + 16 * &lt; &gt;</code> : <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  CHR-ROM ist ein schreibgesch√ºtzter Speicher, auf den nur PPU zugreifen kann.  Es ist vom PRG-ROM getrennt, in dem der Programmcode gespeichert ist.  Daher sind die obigen Daten im Quellcode nicht verf√ºgbar und m√ºssen aus dem Speicherauszug des ROM des Spiels abgerufen werden. <br><br>  16 Bytes f√ºr jede Kachel bilden eine 2x-8x8-Kachel: Das erste Bit sind die ersten 8 Bytes und das zweite sind die zweiten 8 Bytes: <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br>  Binden Sie diese Daten an Palette 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ... und kombinieren Sie die St√ºcke: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br>  Endlich haben wir eine gerenderte Kachel bekommen. <br><br><h2>  Alles zusammenf√ºgen </h2><br>  Wenn Sie diesen Vorgang f√ºr jede Metadatei wiederholen, erhalten Sie eine vollst√§ndig gerenderte Ebene. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br>  Und dank dessen konnten wir mit Python Grafiken auf SMB-Ebene extrahieren! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416241/">https://habr.com/ru/post/de416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416229/index.html">10 B√ºcher √ºber Marketing und verwandte Themen, die ein Designer lesen sollte</a></li>
<li><a href="../de416231/index.html">√úberwachung der Zadarma Zabbix-R√§ume</a></li>
<li><a href="../de416235/index.html">Erstellen benutzerdefinierter Komponenten f√ºr Bootstrap 4</a></li>
<li><a href="../de416237/index.html">Designer werden: von freiberuflich in einem Hostel √ºber die Zusammenarbeit mit Top-Unternehmen bis hin zur Einf√ºhrung Ihres Produkts</a></li>
<li><a href="../de416239/index.html">Die Rolle und Funktionen von PMO in Designunternehmen</a></li>
<li><a href="../de416243/index.html">Alternativen zu Kobalt, diesem blutigen Diamanten aus Batterien</a></li>
<li><a href="../de416245/index.html">Wir erstellen einen Bot auf Aimylogic, um den Online-Shop zu automatisieren</a></li>
<li><a href="../de416247/index.html">Wie bereite ich mich auf eine Gesch√§ftsreise vor? Tipps von ISPsystem bizdedev</a></li>
<li><a href="../de416251/index.html">3D-Druck auf T-Shirts</a></li>
<li><a href="../de416253/index.html">Sketchfab, Unity, Blend4Web, PlayCanvas und jetzt Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>