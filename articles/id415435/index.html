<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüé§ üëåüèø ‚úçüèª Pengembangan kartu antarmuka pada Soil Xilinx Zynq 7000 untuk perekaman suara dalam format analog dan digital ü¶Ä üë®üèª‚Äçüé® ‚öõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kami akan berbagi pengalaman kami dalam mengembangkan kartu antarmuka unit antarmuka berdasarkan SoC ARM + FPGA Xilinx Zynq 7000. Pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan kartu antarmuka pada Soil Xilinx Zynq 7000 untuk perekaman suara dalam format analog dan digital</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415435/"><img src="https://habrastorage.org/webt/rg/2_/55/rg2_55mpm_gc8ip2vlemo9tel9k.jpeg"><br><br>  Pada artikel ini, kami akan berbagi pengalaman kami dalam mengembangkan kartu antarmuka unit antarmuka berdasarkan SoC ARM + FPGA Xilinx Zynq 7000. Papan dirancang untuk merekam sinyal ucapan dalam format PRI / BRI analog dan digital (ISDN, E1 / T1).  Perangkat terakhir itu sendiri akan digunakan untuk mencatat negosiasi dalam penerbangan sipil. <br><a name="habracut"></a><br><h2>  Besi: pemilihan platform perangkat keras perangkat </h2><br>  Pilihan platform perangkat keras ditentukan oleh dukungan protokol PRI / BRI, yang hanya dapat diimplementasikan pada sisi FPGA.  Mikrokontroler (MCU) dan mikroprosesor (MPU) tidak cocok. <br><br>  Seseorang dapat memilih dua solusi untuk masalah ini: <br><br><ol><li>  Sintesis inti Microblaze IP </li><li>  SoC Zynq-7000. </li></ol><br>  Kami memilih sistem dengan chip Zynq 7000 (SoC), karena  lebih mudah untuk menulis aplikasi perangkat lunak dan menyediakan lebih banyak fungsi untuk tugas saat ini dan masa depan. <br><br>  Secara total, daftar besi berikut dikumpulkan di bawah proyek: <br><br>  <b>1.Xilinx Zynq 7020</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mars-ZX3</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mars EB1</a> ) <br><img src="https://habrastorage.org/webt/ls/g9/4w/lsg94w0qj20bxkf5t8k2gzvzx1e.jpeg"><br>  <i>Enclustra Mars ZX3 SOM</i> <br><img src="https://habrastorage.org/webt/ft/z3/4t/ftz34tc8zkk-9gddjcx2atmufc8.jpeg"><br>  <i>Enclustra Mars EB1 Alas Tiang</i> <br><br>  <b>2. TI TLV320AIC34</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tlv320aic34evm-k</a> dan motherboard USB). <br><br><img src="https://habrastorage.org/webt/3z/ls/g-/3zlsg-yry1k4e4qyqu1g-o0xt4a.jpeg"><br>  <i>Papan debug untuk tlv320aic34 (tlv320aic34evm-k)</i> <br><br><img src="https://habrastorage.org/webt/pb/mk/84/pbmk84mawx1rbpmqreghow9fjim.jpeg"><br>  <i>Papan ekspansi USB-MODEVM untuk tlv320aic34evm-k</i> <br><br>  <b>3. IDT82P2288 - PRI, XHFC-4SU - sirkuit mikro BRI,</b> tidak ada kit debugging, jadi kami hanya meletakkan fondasi sebagai inti ip untuk pengujian, dan baptisan api terjadi tepat dalam proses, setelah membuat papan prototipe. <br><br><h2>  Bekerja dengan sistem pada chip Xilinx Zynq 7000 </h2><br><br><img src="https://habrastorage.org/webt/t5/2n/ka/t52nkauzukagn0mp_aruobwjigm.png"><br>  <i>Struktur internal SoC Xilinx Zynq 7000</i> <br><br><img src="https://habrastorage.org/webt/u9/nn/nl/u9nnnlwp0nib8s4td2drrorqm54.png"><br>  <i>Langkah-langkah untuk menghasilkan file boot untuk Xilinx Zynq</i> <br><br>  Menjalankan / mengunduh executable untuk Zynq berbeda dari unduhan biasa untuk MPU.  Pekerjaan biasa dengan prosesor Cortex-A adalah memuat u-boot, kernel linux, rootfs.  Dan pada Zynq, bitstream muncul, file firmware untuk FPGA.  Bitstream berisi deskripsi blok perangkat keras pada FPGA dan komunikasi internal dengan prosesor.  File ini dimuat saat startup sistem.  Juga di sisi linux ada mekanisme yang memungkinkan Anda untuk mem-flash bagian PL segera selama operasi, perangkat seperti itu disebut xdevcfg ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZYNQ FPGA manager sejak 2018.1</a> ). <br><br><h2>  Antarmuka PRI / BRI </h2><br><img src="https://habrastorage.org/webt/om/zo/dr/omzodrzsfz9d5oqyo-ukvvsozve.jpeg"><br>  <i>Fitur jaringan digital PRI / BRI</i> <br><br>  Primary Rate Interface (PRI) adalah antarmuka jaringan ISDN standar yang mendefinisikan disiplin menghubungkan stasiun ISDN ke batang broadband yang menghubungkan pertukaran lokal dan sentral atau switch jaringan. <br><br><img src="https://habrastorage.org/webt/_5/p0/5k/_5p05km2btytoe7ptkdrfuz_-8o.png"><br>  <i>Jenis frame yang ditransmisikan untuk PRI</i> <br><br><img src="https://habrastorage.org/webt/rp/ux/hd/rpuxhdxujlk8c2cnxxgdga74-tk.png"><br>  <i>Tampilan frame yang ditransmisikan untuk BRI</i> <br><br><img src="https://habrastorage.org/webt/-i/1c/90/-i1c90_mrzspj2jhrog9akk_u4g.png"><br>  <i>Struktur internal fisika PRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IDT82P2288</a></i> <br><br><img src="https://habrastorage.org/webt/ca/iv/s5/caivs5jr2frxcu_xiign_my2db8.png"><br>  <i>Struktur internal fisika BRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XHFC-4SU</a></i> <br><br><h2>  Codec Audio TLV320AIC34 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codec audio TLV320AIC34 audio</a> empat saluran berdaya rendah untuk audio portabel dan telepon adalah solusi yang baik untuk digunakan dalam telepon analog. <br><br><img src="https://habrastorage.org/webt/7i/7g/lr/7i7glrlam_fmxm2inkwcgqinrl8.png"><br>  <i>Tlv320aic34 A-bagian, codec audio berisi dua blok fungsi tersebut</i> <br><br>  Data dapat dikirim melalui antarmuka I2S, serta melalui DSP, PCM, TDM. <br><br>  I2S adalah standar antarmuka serial bus, digunakan untuk menghubungkan perangkat audio digital dan secara elektrik mewakili 3 konduktor yang beralih dari perangkat aktif ke perangkat pasif, serta 4 sinyal yang sesuai dengan mereka sebagai berikut: <br><br><ol><li>  Jam Bit (BCLK). </li><li>  Frame sinyal jam (sesuai dengan kata-kata) sinkronisasi (WCLK). </li><li>  Sinyal data yang dapat mengirim atau menerima 2 saluran yang terbagi waktu (DIN / DOUT). </li></ol><br>  Saluran untuk menerima dan mentransmisikan data dibagi, yaitu, ada saluran terpisah untuk menerima data dan saluran untuk transmisi.  Pengontrol menerima data yang dikirimkan oleh codec audio, tetapi kebalikannya juga dimungkinkan. <br><br><img src="https://habrastorage.org/webt/p5/op/th/p5opthpov06xstxalowbqz_emt8.png"><br>  <i>Bingkai I2S, fitur antarmuka I2S</i> <br><br>  Setelah memilih semua komponen perangkat keras, kami memecahkan masalah menghubungkan codec audio dan Xilinx Zynq 7020. <br><br><h2>  Cari core I2S </h2><br>  Mungkin saat yang paling sulit ketika bekerja dengan aliran audio di Xilinx Zynq 7020 adalah bahwa pada bagian prosesor sistem ini pada dasarnya tidak ada bus I2S pada chip, jadi saya harus menemukan inti I2S.  Tugas ini diperumit dengan syarat bahwa ip core harus bebas. <br><br>  Kami memilih beberapa inti IP.  Ditemukan untuk core logam telanjang I2S <b>Digilent</b> .  Kami menemukan beberapa inti ip pada <b>opencores</b> dan, mungkin, opsi terbaik bagi kami adalah inti ip <b>Perangkat Analog</b> .  Mereka menghasilkan ip-core untuk peralatan mereka, untuk interaksi FPGA / FPGA. <br><br>  Kami tertarik pada ip-core yang disebut <b>AXI-I2S-ADI.</b>  Perangkat Analog sendiri mempromosikan ip core ini untuk platform perangkat kerasnya. <br><br>  Total daftar kasus penggunaan: <br><br><ol><li>  Bare metal - IP core untuk I2S (audio Digilent ZYBO) </li><li>  opencores.org </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengontrol AXI-I2S-ADI</a> (Perangkat Analog) </li></ol><br><h3>  AXI-I2S-ADI IP Core </h3><br>  Inti IP itu sendiri terlihat seperti ini: ia memiliki garis bclk, wclk, din, dout.  Terhubung ke DMA Xilinx Zynq 7000, dalam contoh kami, bagian DMA PS digunakan.  Semua pertukaran data terjadi melalui DMA.  DMA dapat berupa unit mandiri atau bagian integral dari PS SoC. <br><br>  Ketika mengkonfigurasi ip-kernel ini, penting untuk tidak lupa mengirimkan frekuensi master mclk ke tlv320aic34 sendiri, sebagai opsi saat menggunakan kit debugging untuk tlv320aic34 - kirimkan frekuensi master eksternal. <br><br><img src="https://habrastorage.org/webt/i8/xn/z4/i8xnz4rijta_07gc1zgc2a8vfxc.png"><br>  <i>Blok fungsi dengan axi-i2s-adi yang terhubung</i> <br><br>  Setelah prosedur konfigurasi, tugasnya adalah untuk meluncurkan fungsionalitas di OS Linux. <br><br><h2>  Luncurkan dan konfigurasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hierarki perangkat</a> untuk tlv320aic34 </h2><br>  Mengkonfigurasi i2c (tlv320aic34 dikonfigurasikan pada antarmuka ini): <br><br><pre><code class="cpp hljs">i2c0: i2c@e0004000 { ... tlv320aic3x: tlv320aic3x@<span class="hljs-number"><span class="hljs-number">18</span></span> { <span class="hljs-meta"><span class="hljs-meta">#sound-dai-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "ti,tlv320aic3x"; reg = &lt;0x18&gt;; gpio-reset = &lt;&amp;axi_gpio_0 0 0&gt;; ai3x-gpio-func = &lt;&amp;axi_gpio_0 1 0&gt;, /* AIC3X_GPIO1_FUNC_DISABLED */ &lt;&amp;axi_gpio_0 2 0&gt;; /* AIC3X_GPIO2_FUNC_DIGITAL_MIC_INPUT */ AVDD-supply = &lt;&amp;vmmc2&gt;; DRVDD-supply = &lt;&amp;vmmc2&gt;; IOVDD-supply = &lt;&amp;vmmc2&gt;; DVDD-supply = &lt;&amp;vmmc2&gt;; ai3x-micbias-vg = &lt;1&gt;; }; ... };</span></span></span></span></code> </pre> <br>  Mengkonfigurasi i2s (data audio dikirim melalui antarmuka ini): <br><br><pre> <code class="cpp hljs">i2s_clk: i2s_clk { <span class="hljs-meta"><span class="hljs-meta">#clock-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "fixed-clock"; clock-frequency = &lt;11289600&gt;; clock-output-names = "i2s_clk"; }; axi_i2s_adi_0: axi_i2s_adi@43C00000 { compatible = "adi,axi-i2s-1.00.a"; reg = &lt;0x43C00000 0x1000&gt;; xlnx,bclk-pol = &lt;0x0&gt;; xlnx,dma-type = &lt;0x1&gt;; xlnx,has-rx = &lt;0x1&gt;; xlnx,has-tx = &lt;0x1&gt;; xlnx,lrclk-pol = &lt;0x0&gt;; xlnx,num-ch = &lt;0x1&gt;; xlnx,s-axi-min-size = &lt;0x000001FF&gt;; xlnx,slot-width = &lt;0x18&gt;; }; &amp;axi_i2s_adi_0 { #sound-dai-cells = &lt;0&gt;; compatible = "adi,axi-i2s-1.00.a"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;i2s_clk&gt;; clock-names = "axi", "ref"; dmas = &lt;&amp;dmac_s 0 &amp;dmac_s 1&gt;; dma-names = "tx", "rx"; };</span></span></span></span></code> </pre> <br>  Mengatur kartu suara di bagan perangkat (kartu audio): <br><br><pre> <code class="cpp hljs"> sound { compatible = <span class="hljs-string"><span class="hljs-string">"simple-audio-card"</span></span>; simple-audio-card,name = <span class="hljs-string"><span class="hljs-string">"TLV320AIC34"</span></span>; simple-audio-card,format = <span class="hljs-string"><span class="hljs-string">"i2s"</span></span>; simple-audio-card,bitclock-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,frame-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,widgets = ... simple-audio-card,routing = ... dailink0_master: simple-audio-card,cpu { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;axi_i2s_adi_0&gt;; }; simple-audio-card,codec { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;tlv320aic3x&gt;; }; }; };</code> </pre> <br>  Setelah semua manipulasi untuk mengkonfigurasi dan mengkonfigurasi codec di pohon perangkat di Linux, kartu audio yang didambakan muncul dan kami dapat mendengar musik (trek musik pertama kami adalah Highway to Hell, AC / DC). <br><br>  Inilah yang harus kami lakukan untuk ini: <br><br><ul><li>  Menghasilkan frekuensi yang diperlukan menggunakan clk_wiz (pemandu jam) </li><li>  DTS yang dikonfigurasi dengan benar untuk tlv320aic34 </li><li>  Dukungan tambahan untuk driver tlv320aic3x </li><li>  Menambahkan paket audio ke buildroot untuk memutar aliran audio (aplay, madplay, dll.) </li></ul><br>  Dalam proses pengembangan perangkat akhir, kami dihadapkan dengan tugas untuk menghubungkan 4 tlv320aic34 microcircuits.  Chip tlv320aic34 yang dijelaskan di atas berisi 2 blok untuk bekerja dengan stream audio, setiap blok memiliki jalur i2c sendiri untuk mengkonfigurasi dan mengatur parameter audio.  Satu blok hanya dapat memiliki empat alamat, masing-masing, tidak mungkin untuk menghubungkan empat microcircuits tlv320aic34 ke satu antarmuka i2c, Anda perlu menggunakan dua antarmuka i2c (8 blok audio independen).  Untuk setiap blok, jika Anda memulai mclk, blck, wclk, din / dout secara individual, Anda perlu menambahkan 40 garis sinyal secara total, yang tidak mungkin dan tidak rasional dari sudut pandang sirkuit untuk modul som yang kita pilih, karena selain sinyal-sinyal ini, Anda harus menghubungkan banyak jalur lain dan antarmuka. <br><br>  Sebagai hasilnya, kami memutuskan untuk mengganti kartu audio ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode TDM</a> , di mana semua garis mclk, bclk, din, dout digabungkan, yang mengurangi jumlah total jalur komunikasi.  Keputusan ini mempengaruhi pengoperasian axi-i2s-adi, karena fakta bahwa inti ip itu sendiri bekerja dalam mode master.  Juga, perubahan ini tidak memungkinkan kami untuk menggunakan ip-core kami dalam mode TDM, dan keputusan yang berkemauan keras kami harus meninggalkan penggunaan ip-core yang dipilih.  Saya harus menulis sebuah kernel ip untuk mendengarkan lalu lintas i2s dan mengirimkannya ke dma, solusi ini memungkinkan kami untuk membuat antarmuka umum untuk menerima data yang tidak akan tergantung pada jenis kartu untuk merekam panggilan (kartu analog dan digital). <br><br>  Arsitektur awal untuk menerima aliran audio dan pemrosesannya melalui antarmuka i2s: <br><br><img src="https://habrastorage.org/webt/yn/24/2d/yn242d_8cm4kazs2ycwceevqqe8.jpeg"><br><br>  Arsitektur terakhir untuk menerima aliran audio dan pemrosesannya melalui antarmuka i2s: <br><br><img src="https://habrastorage.org/webt/mz/py/dt/mzpydtgravupatvivp_zmpiitig.jpeg"><br><br>  Arsitektur menerima aliran PRI dan pemrosesannya: <br><br><img src="https://habrastorage.org/webt/qx/ee/7w/qxee7wt1mdazgm0tu0eukbm5rmy.jpeg"><br><br>  Arsitektur penerimaan dan pemrosesan aliran BRI: <br><br><img src="https://habrastorage.org/webt/wd/uf/ny/wdufnykenpfxgwyhrnr3x6ep2kg.jpeg"><br><br><h2>  Axi dma </h2><br>  Ini adalah elemen penting dari sistem sinkronisasi data untuk dma. <br><br><img src="https://habrastorage.org/webt/v7/fx/pk/v7fxpk_3eemrqnlmy3iejsjrup4.png"><br>  <i>Jendela Konfigurasi DMA AXI di Xilinx Vivado</i> <br><br>  Pada layar cetak, blok DMA AXI itu sendiri disajikan.  Ini memiliki banyak parameter.  Anda dapat mengkonfigurasi bus berapa banyak data untuk ditransfer.  Data dapat disejajarkan atau dalam format apa pun.  Deskripsi terperinci tentang operasi dan interaksi dengan axi dma dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi teknis</a> (dari versi ke versi ada tambahan dan koreksi ketidakakuratan dalam deskripsi, serta penyempurnaan kernel ip). <br><br><h2>  Verifikasi transfer data melalui AXI DMA, opsi tes AXI DMA </h2><br>  Ketika mengembangkan driver, kami memutuskan untuk mencari sumber terbuka dan menyesuaikannya dengan tugas kami.  Sebagai hasilnya, kami memilih sumber-sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek ezdma github</a> (pun, baca sebagai dma mudah). <br><br>  Langkah selanjutnya adalah pengembangan driver tes, itu adalah tahap persiapan untuk mengantisipasi saat ketika ip core dengan fungsi siap pakai dari departemen pengembangan FPGA mendatangi kami (proses pengembangan yang dijelaskan dibentuk oleh embedded programmer).  Sebelum saat ini kami memutuskan untuk mengambil AXI DMA, AXI DATA FIFO dan membuat loopback untuk memastikan terhadap kesalahan di masa mendatang.  Kami mengulangi pengiriman dan penerimaan data, jadi kami memeriksa hasil pekerjaan kami dan kinerja pengemudi kami.  Kami menyesuaikan fungsi sedikit, membawanya ke keinginan kami pada antarmuka interaksi dan sekali lagi memeriksa pengoperasian driver dan prinsip interaksi yang dipilih. <br><br><img src="https://habrastorage.org/webt/iw/si/uj/iwsiujsbv1tckuamu1lsjalzrao.png"><br>  <i>Desain blok look-back, cara pertama untuk menguji AXI DMA</i> <br><br>  Contoh deskripsi DMA dan ezdma di bagan perangkat: <br><br><pre> <code class="cpp hljs">/ { amba_pl: amba_pl { <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "simple-bus"; ranges ; axi_dma_1: axi_dma { #dma-cells = &lt;1&gt;; compatible = "xlnx,axi-dma-1.00.a"; reg = &lt;0x40400000 0x10000&gt;; clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4 0 30 4&gt;; xlnx,addrwidth = &lt;0x20&gt;; xlnx,include-sg; dma-channel@40400000 { compatible = "xlnx,axi-dma-mm2s-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 29 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; dma-channel@40400030 { compatible = "xlnx,axi-dma-s2mm-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 30 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; }; ezdma0 { compatible = "ezdma"; dmas = &lt;&amp;axi_dma_1 0 &amp;axi_dma_1 1&gt;; dma-names = "loop_tx", "loop_rx"; // used when obtaining reference to above DMA core using dma_request_slave_channel() ezdma,dirs = &lt;2 1&gt;; // direction of DMA channel: 1 = RX (dev-&gt;cpu), 2 = TX (cpu-&gt;dev) }; ... }; };</span></span></span></span></code> </pre> <br>  Anda dapat dengan mudah menghasilkan file dts / dtsi menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Device Tree Generator</a> . <br><br>  Langkah kedua dalam proses pengembangan kami adalah pembuatan ip-kernel test untuk memeriksa kinerja driver, hanya saja kali ini datanya akan bermakna, dengan transfer via AXIS ke AXI_DMA (karena itu akan menjadi versi final dari ip-kernel). <br><br><img src="https://habrastorage.org/webt/uc/nc/iz/ucncizx2gwl3am9mxz5iursdy1q.png"><br>  <i>Alur kerja antarmuka AXIS</i> <br><br>  Kami menerapkan dua varian ip-kernel untuk pembuatan data, versi yang diuji pertama kali dilaksanakan melalui Verilog, yang kedua - pada HLS (dalam konteks ini, HLS muncul di bawah slogan "fashion-fashion-youth"). <br><br>  Generator data Verilog (dan umumnya dalam bahasa keluarga hdl - Verilog, vhdl, dll.) Adalah solusi standar ketika mengembangkan ip-core jenis ini.  Berikut ini beberapa cuplikan kode untuk kernel ip perantara: <br><br><pre> <code class="hljs sql">module GenCnt ( ‚Ä¶. assign HandsHake = m_axis_din_tready &amp; m_axis_dout_tvalid; always @(posedge Clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Rst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sIDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (smCnt) sIDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sDATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sDATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cnt == cTopCnt - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sLAST; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... endmodule</code> </pre> <br>  Tidak perlu deskripsi yang lebih rinci, karena ini adalah tugas khas seorang desainer FPGA. <br><br>  "Binatang buas" yang lebih menarik di sini adalah HLS.  <b>Vivado HLS (Sintesis Tingkat Tinggi)</b> adalah perangkat lunak Xilinx CAD baru untuk membuat perangkat digital menggunakan bahasa tingkat tinggi seperti OpenCL, C atau C ++. <br><br>  C / C ++ adalah bahasa utama untuk insinyur perangkat lunak tertanam, jadi menyelesaikan masalah dengan menggunakan bahasa ini lebih menarik dalam hal implementasi dan analisis komparatif untuk proyek-proyek masa depan. <br><br>  Berikut adalah dua contoh kecil bekerja dengan HLS.  Contoh pertama adalah generator data untuk AXI_DMA, contoh kedua adalah pertukaran data antara bagian prosesor dan logika yang dapat diprogram melalui antarmuka s_axilite. <br><br>  Pertukaran data melalui antarmuka s_axilite (contoh kedua) diimplementasikan sehingga setiap saat di procfs dimungkinkan untuk mengurangi bitstream mana yang dimuat, dan sehingga dimungkinkan untuk melacak kebenaran pekerjaan dengan membuat versi untuk bagian PL dari SoC.  Di sini poin yang sangat menarik muncul dengan s_axilite: Vivado HLS menghasilkan driver untuk Linux (driver, pada gilirannya, kami beradaptasi untuk bekerja melalui procfs untuk menjaga hereditas penulisan).  Contoh kode yang dihasilkan untuk Linux di bawah ini (jalur ke sumber solution1 / impl / ip / drivers / name_xxx / src /). <br><br><img src="https://habrastorage.org/webt/ss/kd/rh/sskdrh3olokqp7miv9qm-ni1gnq.png"><br>  <i>Tahapan sintesis HLS dan pembuatan kode rtl</i> <br><br>  Generator data HLS untuk memeriksa operasi dengan AXI_DMA: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ap_axi_sdata.h&gt; #include &lt;hls_stream.h&gt; #define SIZE_STREAM 1024 struct axis { int tdata; bool tlast; }; void data_generation(axis outStream[SIZE_STREAM]) { #pragma HLS INTERFACE axis port=outStream int i = 0; do{ outStream[i].tdata = i; outStream[i].tlast = (i == (SIZE_STREAM - 1)) ? 1 : 0; i++; }while( i &lt; SIZE_STREAM); }</span></span></span></span></code> </pre> <br>  Contoh untuk mendapatkan versi dan jenis papan antarmuka: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void info( int &amp;aVersion, int &amp;bSubVersion, int &amp;cTypeBoard, int version, int subVersion, int typeBoard ){ #pragma HLS INTERFACE s_axilite port=aVersion #pragma HLS INTERFACE s_axilite port=bSubVersion #pragma HLS INTERFACE s_axilite port=cTypeBoard #pragma HLS INTERFACE ap_ctrl_none port=return aVersion = version; bSubVersion = subVersion; cTypeBoard = typeBoard; }</span></span></span></span></code> </pre> <br>  Seperti yang Anda perhatikan, untuk pengembangan pada hls, sangat penting untuk memahami pekerjaan dan penerapan berbagai pragma (pragma HLS), karena proses sintesis terkait langsung dengan pragma. <br><br>  Driver yang dibuat untuk s_axilite: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== #ifdef __linux__ /***************************** Include Files *********************************/ #include "xinfo.h" /***************** Macros (Inline Functions) Definitions *********************/ #define MAX_UIO_PATH_SIZE 256 #define MAX_UIO_NAME_SIZE 64 #define MAX_UIO_MAPS 5 #define UIO_INVALID_ADDR 0 /**************************** Type Definitions ******************************/ typedef struct { u32 addr; u32 size; } XInfo_uio_map; typedef struct { int uio_fd; int uio_num; char name[ MAX_UIO_NAME_SIZE ]; char version[ MAX_UIO_NAME_SIZE ]; XInfo_uio_map maps[ MAX_UIO_MAPS ]; } XInfo_uio_info; /***************** Variable Definitions **************************************/ static XInfo_uio_info uio_info; /************************** Function Implementation *************************/ static int line_from_file(char* filename, char* linebuf) { char* s; int i; FILE* fp = fopen(filename, "r"); if (!fp) return -1; s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp); fclose(fp); if (!s) return -2; for (i=0; (*s)&amp;&amp;(i&lt;MAX_UIO_NAME_SIZE); i++) { if (*s == '\n') *s = 0; s++; } return 0; } static int uio_info_read_name(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/name", info-&gt;uio_num); return line_from_file(file, info-&gt;name); } static int uio_info_read_version(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/version", info-&gt;uio_num); return line_from_file(file, info-&gt;version); } static int uio_info_read_map_addr(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; info-&gt;maps[n].addr = UIO_INVALID_ADDR; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/addr", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].addr); fclose(fp); if (ret &lt; 0) return -2; return 0; } static int uio_info_read_map_size(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/size", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].size); fclose(fp); if (ret &lt; 0) return -2; return 0; } int XInfo_Initialize(XInfo *InstancePtr, const char* InstanceName) { XInfo_uio_info *InfoPtr = &amp;uio_info; struct dirent **namelist; int i, n; char* s; char file[ MAX_UIO_PATH_SIZE ]; char name[ MAX_UIO_NAME_SIZE ]; int flag = 0; assert(InstancePtr != NULL); n = scandir("/sys/class/uio", &amp;namelist, 0, alphasort); if (n &lt; 0) return XST_DEVICE_NOT_FOUND; for (i = 0; i &lt; n; i++) { strcpy(file, "/sys/class/uio/"); strcat(file, namelist[i]-&gt;d_name); strcat(file, "/name"); if ((line_from_file(file, name) == 0) &amp;&amp; (strcmp(name, InstanceName) == 0)) { flag = 1; s = namelist[i]-&gt;d_name; s += 3; // "uio" InfoPtr-&gt;uio_num = atoi(s); break; } } if (flag == 0) return XST_DEVICE_NOT_FOUND; uio_info_read_name(InfoPtr); uio_info_read_version(InfoPtr); for (n = 0; n &lt; MAX_UIO_MAPS; ++n) { uio_info_read_map_addr(InfoPtr, n); uio_info_read_map_size(InfoPtr, n); } sprintf(file, "/dev/uio%d", InfoPtr-&gt;uio_num); if ((InfoPtr-&gt;uio_fd = open(file, O_RDWR)) &lt; 0) { return XST_OPEN_DEVICE_FAILED; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> slave interface 'Axilites' should be mapped to uioX/map0 InstancePtr-&gt;Axilites_BaseAddress = (u32)mmap(NULL, InfoPtr-&gt;maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr-&gt;uio_fd, 0 * getpagesize()); assert(InstancePtr-&gt;Axilites_BaseAddress); InstancePtr-&gt;IsReady = XIL_COMPONENT_IS_READY; return XST_SUCCESS; } int XInfo_Release(XInfo *InstancePtr) { XInfo_uio_info *InfoPtr = &amp;uio_info; assert(InstancePtr != NULL); assert(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY); munmap((void*)InstancePtr-&gt;Axilites_BaseAddress, InfoPtr-&gt;maps[0].size); close(InfoPtr-&gt;uio_fd); return XST_SUCCESS; } #endif</span></span></code> </pre> <br>  File penting yang memberi tahu Anda lokasi variabel (register) di ruang alamat adalah file x # nama_anda # _hw.h.  Anda selalu dapat memverifikasi kebenaran ip-kernel tertulis menggunakan alat devmem. <br><br>  Isi file ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== // AXILiteS // 0x00 : reserved // 0x04 : reserved // 0x08 : reserved // 0x0c : reserved // 0x10 : Data signal of aVersion // bit 31~0 - aVersion[31:0] (Read) // 0x14 : Control signal of aVersion // bit 0 - aVersion_ap_vld (Read/COR) // others - reserved // 0x18 : Data signal of bSubVersion // bit 31~0 - bSubVersion[31:0] (Read) // 0x1c : Control signal of bSubVersion // bit 0 - bSubVersion_ap_vld (Read/COR) // others - reserved // 0x20 : Data signal of cTypeBoard // bit 31~0 - cTypeBoard[31:0] (Read) // 0x24 : Control signal of cTypeBoard // bit 0 - cTypeBoard_ap_vld (Read/COR) // others - reserved // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake) #define XINFO_AXILITES_ADDR_AVERSION_DATA 0x10 #define XINFO_AXILITES_BITS_AVERSION_DATA 32 #define XINFO_AXILITES_ADDR_AVERSION_CTRL 0x14 #define XINFO_AXILITES_ADDR_BSUBVERSION_DATA 0x18 #define XINFO_AXILITES_BITS_BSUBVERSION_DATA 32 #define XINFO_AXILITES_ADDR_BSUBVERSION_CTRL 0x1c #define XINFO_AXILITES_ADDR_CTYPEBOARD_DATA 0x20 #define XINFO_AXILITES_BITS_CTYPEBOARD_DATA 32 #define XINFO_AXILITES_ADDR_CTYPEBOARD_CTRL 0x24</span></span></code> </pre><br>  File ini menjelaskan alamat register, register sesuai dengan lokasi argumen dalam fungsi.  Setelah sintesis proyek, Anda dapat melihat bagaimana proyek yang dibuat akan dieksekusi dalam siklus. <br><br><img src="https://habrastorage.org/webt/lj/jw/na/ljjwnalfpfgcsi4yindklhqvowe.png"><br>  <i>Contoh Ketukan Proyek</i> <br><br>  Bekerja dengan hls telah menunjukkan bahwa alat ini cocok untuk menyelesaikan tugas dengan cepat, terutama telah membuktikan dirinya untuk memecahkan masalah matematika penglihatan komputer, yang dapat dengan mudah dijelaskan dalam C ++ atau C, serta untuk membuat kernel ip kecil untuk interaksi dan pertukaran informasi dengan antarmuka FPGA standar. <br><br>  Pada saat yang sama, HLS tidak cocok untuk mengimplementasikan antarmuka perangkat keras tertentu, misalnya, dalam kasus kami adalah I2S, dan kode rtl yang dihasilkan membutuhkan lebih banyak ruang pada FPGA daripada ditulis dalam bahasa hdl standar. <br><br>  Langkah terakhir dalam pengujian driver adalah pengembangan generator traffic I2S.  Ip-core ini mengulangi fungsionalitas dari ip-kernel sebelumnya, kecuali bahwa ia menghasilkan data tambahan (lalu lintas) yang sesuai dengan data I2S nyata dalam mode TDM. <br><br><img src="https://habrastorage.org/webt/vc/81/xz/vc81xzbieylxtzhrp6lz-psikva.png"><br>  <i>Blokir desain untuk pengujian inti I2S kustom masa depan dan generator lalu lintas I2S</i> <br><br>  Akibatnya, kami mendapat hasil hls, axi dma dan s_axilite, memeriksa kinerja perangkat lunak dan driver kami. <br><br><h2>  Kesimpulan </h2><br>  Kami berhasil mengembangkan jenis kartu antarmuka yang diperlukan, serta ip-kernel untuk tdm, pri, bri.  Kami telah secara signifikan meningkatkan pendekatan saat ini untuk pengembangan perangkat tersebut dan menciptakan solusi komprehensif yang dapat bersaing dengan papan antarmuka serupa dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asterick</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patton</a> , dan lainnya.  Keuntungan dari solusi kami adalah bahwa pengembang tidak memerlukan tautan perantara antara PC dan PCI untuk transfer data, ia akan dapat secara langsung mengirimkan informasi yang diterima melalui Ethernet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415435/">https://habr.com/ru/post/id415435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415423/index.html">Infrastruktur Kunci Publik: Otoritas Sertifikasi Berdasarkan Utilitas OpenSSL dan SQLite3 (Postcryptum)</a></li>
<li><a href="../id415427/index.html">Seluruh kebenaran tentang RTOS dari Colin Walls. Artikel # 4. Tugas, pengalihan konteks, dan interupsi</a></li>
<li><a href="../id415429/index.html">Seluruh kebenaran tentang RTOS dari Colin Walls. Artikel # 5. Interaksi tugas dan sinkronisasi</a></li>
<li><a href="../id415431/index.html">Pengumuman Hackathon SmartMail Hack 2: Call of Data</a></li>
<li><a href="../id415433/index.html">Mengelola rilis pada perumahan GIS dan layanan komunal - kami berbagi pengalaman dan berjuang dengan intuisi</a></li>
<li><a href="../id415437/index.html">Cara menggulung ML dalam prod: enam garu yang kami injak</a></li>
<li><a href="../id415439/index.html">Apakah komunikasi korporat memaksa Anda untuk berhenti atau menyeret Anda ke dalam proyek seperti permainan?</a></li>
<li><a href="../id415441/index.html">Serangan Ransomware terhadap badan-badan pemerintah berkembang di AS</a></li>
<li><a href="../id415443/index.html">MDG dan ITMO University mengundang ke Machine Learning Summer School</a></li>
<li><a href="../id415445/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Juli 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>