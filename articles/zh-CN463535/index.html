<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 👨🏽‍🎨 ➗ 通过PVS-Studio静态分析器检查.NET Core库源代码 🤺 📑 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET Core库是GitHub上最受欢迎的C＃项目之一。 由于它已广为人知和使用，因此这不足为奇。 因此，试图揭示源代码的黑暗角落变得更加迷人。 这就是我们将尝试在PVS-Studio静态分析仪的帮助下进行的操作。 您怎么看-我们最终会发现一些有趣的东西吗？ 

 一年半来，我一直在朝着这篇文章...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>通过PVS-Studio静态分析器检查.NET Core库源代码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463535/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/bm/pb/-abmpb2yelga7y1zu59bejm6vgo.png" alt="图片19"></div><br>  .NET Core库是GitHub上最受欢迎的C＃项目之一。 由于它已广为人知和使用，因此这不足为奇。 因此，试图揭示源代码的黑暗角落变得更加迷人。 这就是我们将尝试在PVS-Studio静态分析仪的帮助下进行的操作。 您怎么看-我们最终会发现一些有趣的东西吗？ <br><a name="habracut"></a><br> 一年半来，我一直在朝着这篇文章迈进。 在某个时候，我脑子里浮现出一个想法，.NET Core库是一个花哨的东西，它的检查很有希望。 我多次检查了该项目，分析器不断发现越来越多的有趣代码片段，但是它并不仅仅是滚动警告列表。 这就是-终于发生了！ 项目已选中，文章就在您眼前。 <br><br><h2> 有关项目和检查的详细信息 </h2><br> 如果您正在努力进行代码调查-您可以省略此部分。 但是，我非常希望您阅读它，因为在这里我将向您介绍有关项目和分析器的更多信息，以及进行分析和重现错误的更多信息。 <br><br><h3> 检查项目 </h3><br> 也许，我可以跳过讲什么是CoreFX（.NET核心库），但是如果您还没有听说，请在下面进行描述。 与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目页面</a>相同，您也可以在其中下载源代码。 <br><br> 说明： <i>此存储库包含.NET Core的库实现（称为“ CoreFX”）。</i>  <i>它包括System.Collections，System.IO，System.Xml和许多其他组件。</i>  <i>相应的.NET Core运行时存储库（称为“ CoreCLR”）包含.NET Core的运行时实现。</i>  <i>它包括RyuJIT，.NET GC和许多其他组件。</i>  <i>运行时特定的库代码（System.Private.CoreLib）位于CoreCLR存储库中。</i>  <i>它需要与运行时一起构建和版本控制。</i>  <i>其余CoreFX与运行时实现无关，可以在任何兼容的.NET运行时（例如CoreRT）上运行</i> 。 <br><br>
<h3> 二手分析仪及分析方法 </h3><br> 我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>PVS-Studio静态分析器</u></a>检查了代码。 一般来说，PVS-Studio不仅可以分析C＃代码，还可以分析C，C ++，Java。 到目前为止，C＃代码分析仅在Windows下有效，而C，C ++，Java代码则可以在Windows，Linux和macOS下进行分析。 <br><br> 通常对于检查C＃项目，我使用Visual Studio的PVS-Studio插件（支持2010-2019版本），因为在这种情况下，它可能是最简单便捷的分析方案：打开解决方案，运行分析，处理警告列表。 但是，使用CoreFX变得更加复杂。 <br><br> 棘手的部分是该项目没有单个.sln文件，因此无法在Visual Studio中打开该文件并使用PVS-Studio插件执行完整的分析。 这可能是一件好事-我真的不知道Visual Studio如何应对这种规模的解决方案。 <br><br> 但是，分析没有问题，因为PVS-Studio发行版包括用于MSBuild项目（和.sln）的分析器命令行版本。 我要做的就是编写一个小脚本，该脚本将为CoreFX目录中的每个.sln运行“ PVS-Studio_Cmd.exe”，并将结果保存在单独的目录中（由分析器的命令行标志指定） 。 <br><br> 快点！ 结果，我有一个Pandora盒子，里面有一组存储一些有趣内容的报告。 如果需要，可以将这些日志与PlogConverter实用程序合并，作为分发的一部分。 对我来说，使用单独的日志更加方便，因此我没有合并它们。 <br><br> 在描述一些错误时，请参阅docs.microsoft.com和NuGet软件包中的文档，这些文档可从nuget.org下载。 我认为文档/软件包中描述的代码可能与所分析的代码略有不同。 但是，例如，如果文档没有描述具有特定输入数据集时生成的异常，但是新的软件包版本将包含这些异常，这将非常奇怪。 您必须承认这将是一个可疑的惊喜。 使用与调试库相同的输入数据，从NuGet中重现包中的错误，这表明此问题不是新问题。 最重要的是，您可以“触摸”它，而无需从源代码构建项目。 <br><br> 因此，考虑到代码在理论上可能不同步的可能性，我发现可以参考docs.microsoft.com上相关方法的描述并使用nuget.org中的程序包重现问题是可以接受的。 <br><br> 另外，我想指出的是，在撰写本文的过程中，给定链接的描述，包中的信息（注释）（在其他版本中）可能已更改。 <br><br><h3> 其他检查项目 </h3><br> 顺便说一下，本文并不是同类文章中唯一的。 我们在项目检查方面写其他文章。 通过此链接，可以找到已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查项目</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">列表</a> 。 此外，在我们的网站上，您不仅可以找到项目检查的文章，而且还可以找到有关C，C ++，C＃，Java的各种技术文章，以及一些有趣的注释。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>博客中</u></a>找到所有这些内容。 <br><br> 我的同事以前已经在2015年检查过.NET Core库。以前的分析结果可以在相关文章中找到：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>.NET Core库的圣诞节分析（CoreFX）”</u></a> 。 <br><br><h2> 检测到的错误，可疑和有趣的片段 </h2><br> 与往常一样，出于更大的兴趣，我建议您首先自己搜索给定片段中的错误，然后再阅读分析器消息和问题描述。 <br><br> 为了方便起见，我已经使用<b>Issue N</b>标签将各个部分清楚地分开了-这样一来，更容易知道一个错误的描述在哪里结束，接着是下一个错误。 此外，引用特定片段会更容易。 <br><br>  <b>第1期</b> <br><br><pre><code class="cpp hljs">abstract <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Principal</span></span></span><span class="hljs-class"> :</span></span> IDisposable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrincipalContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( context.ContextType == ContextType.Machine || _ctx.ContextType == ContextType.Machine) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( SR.SaveToNotSupportedAgainstMachineStore); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == null) { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unpersisted == <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(SR.NullArguments); } .... } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3095</u></a>在验证是否为null之前使用了“上下文”对象。 检查行：340，346。Principal.cs 340 <br><br> 开发人员明确声明<i>context</i>参数的<i>null</i>值无效，他们想通过使用<i>InvalidOperationException</i>类型的异常来强调这一点。 但是，就在先前条件的上方，我们可以看到对引用<i>context</i> - <i>context.ContextType</i>的无条件取消引用。 结果，如果<i>上下文</i>值为<i>null，</i>则将生成<i>NullReferenceException</i>类型的异常，而不是预期的<i>InvalidOperationExcetion。</i> <br><br> 让我们尝试重现该问题。 我们将对库<i>System.DirectoryServices.AccountManagement的</i>引用添加到项目，并执行以下代码： <br><br><pre> <code class="cpp hljs">GroupPrincipal groupPrincipal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroupPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrincipalContext(ContextType.Machine)); groupPrincipal.Save(null);</code> </pre> <br>  <i>GroupPrincipal</i>继承自<i>Principal</i>抽象类，该类实现了我们感兴趣的<i>Save</i>方法。 因此，我们执行代码并查看需要证明的内容。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/09a/2cc/29009a2cc3a5408808b9814d48bb0dea.png" alt="图片1"></div><br> 为了您的兴趣，您可以尝试从NuGet下载适当的程序包，并以相同的方式重复该问题。 我安装了软件包4.5.0，并获得了预期的结果。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/891/b4a/3de891b4a4ba8100bb63af19e4455842.png" alt="图片2"></div><br>  <b>第2期</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SearchResultCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> findMoreThanOne)</span></span></span><span class="hljs-function"> </span></span>{ searchResult = null; DirectoryEntry clonedRoot = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_assertDefaultNamingContext == null) { clonedRoot = SearchRoot.CloneBrowsable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clonedRoot = SearchRoot.CloneBrowsable(); } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3004'then</u></a> '语句等效于'else'语句。  DirectorySearcher.cs 629 <br><br> 无论<i>_assertDefaultNamingContext == null</i>条件是true还是false，都将执行相同的操作，因为<i>then</i>和<i>if</i>语句的<i>其他</i>分支具有相同的主体。 分支中应该有另一个动作，或者您可以省略<i>if</i>语句，以免混淆开发人员和分析人员。 <br><br>  <b>第3期</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryEntry</span></span></span><span class="hljs-class"> :</span></span> Component { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] propertyNames)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[propertyNames.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; propertyNames.Length; i++) names[i] = propertyNames[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propertyCollection != null &amp;&amp; propertyNames != null) .... .... } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3095</u></a>在对null进行验证之前，已使用'propertyNames'对象。 检查行：990、1004。DirectoryEntry.cs 990 <br><br> 同样，我们看到一个奇怪的动作顺序。 在该方法中，有一个check <i>propertyNames！= Null</i> ，即开发人员从<i>null</i>覆盖方法的基础。 但是在上面，您可以通过此可能为空的引用<i>-propertyNames.Length</i>和<i>propertyNames [i]</i>看到一些访问操作。 结果是非常可预测的-如果将null引用传递给方法，则会发生<i>NullReferenceExcepption</i>类型的异常。 <br><br> 真是巧合！  <i>RefreshCache</i>是公共类中的公共方法。 尝试重现该怎么办？ 为此，我们将需要的库System。Directory <i>Services包含</i>到项目中，并编写如下代码： <br><br><pre> <code class="cpp hljs">DirectoryEntry de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryEntry(); de.RefreshCache(null);</code> </pre> <br> 执行代码后，我们可以看到期望的结果。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/040/d0a/2d9040d0ae8d91394c476d6788aa7275.png" alt="图片3"></div><br> 只是为了踢球，您可以尝试在NuGet软件包的发行版上重现该问题。 接下来，我们将对<i>System.DirectoryServices</i>包的引用（我使用的是4.5.0版）添加到项目中，并执行已经熟悉的代码。 结果如下。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/31e/309/0d631e3096fa8ba00b41fe10ad1001db.png" alt="图片4"></div><br>  <b>第4期</b> <br><br> 现在我们从相反的角度出发-首先，我们将尝试编写使用类实例的代码，然后再向内看。 让我们从<i>System.Drawing.Common</i>库和同名的NuGet包中引用<i>System.Drawing.CharacterRange</i>结构。 <br><br> 我们将使用以下代码： <br><br><pre> <code class="cpp hljs">CharacterRange range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterRange(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> eq = range.Equals(null); Console.WriteLine(eq);</code> </pre> <br> 为了以防万一，为了慢跑我们的记忆，我们将访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>docs.microsoft.com</u></a>以回想一下从<i>obj.Equals（null）</i>表达式期望的返回值： <br><br>  <i>对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><i>Equals（Object）</i></u></a>方法的所有实现，以下语句必须为true。</i>  <i>在列表中，x，y和z表示不为null的对象引用。</i> <br><br>  <i>....</i> <br><br>  <b><i>x.Equals（null）返回false。</i></b> <br><br> 您是否认为“ False”将显示在控制台中？ 当然不是。 这太容易了。  :)因此，我们执行代码并查看结果。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/159/8f6/e871598f6ca5dacdb4a4fae7b5776520.png" alt="图片5"></div><br> 它是上述代码使用版本4.5.1的NuGet <i>System.Drawing.Common</i>包的输出。 下一步是使用调试库版本运行相同的代码。 这是我们看到的： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/f27/f1a/6e9f27f1a78768078fdd940e0a4be0ad.png" alt="图片6"></div><br> 现在，让我们看一下源代码，尤其是<i>CharacterRange</i>结构中<i>Equals</i>方法的实现和分析器警告： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != typeof(CharacterRange)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; CharacterRange cr = (CharacterRange)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_first == cr.First) &amp;&amp; (_length == cr.Length)); }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3115将</u></a> “ null”传递给“ Equals”方法不应导致“ NullReferenceException”。 字符范围56 <br><br> 我们可以观察到，必须证明的是<i>-obj</i>参数处理不当。 因此，在调用实例方法<i>GetType</i>时，条件表达式中会发生<i>NullReferenceException</i>异常<i>。</i> <br><br>  <b>第5期</b> <br><br> 在探索该库时，让我们考虑另一个有趣的片段<i>-Icon。Save</i>方法<i>。</i> 在研究之前，让我们看一下方法的描述。 <br><br> 没有该方法的描述： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/fef/402/ffdfef402f77c462c94b9ff284f42e0c.png" alt="图片7"></div><br> 让我们解决docs.microsoft.com-“ <u>Icon.Save（Stream）方法</u> ”。 但是，对于输入或有关生成的异常的信息也没有限制。 <br><br> 现在让我们继续进行代码检查。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Icon</span></span></span><span class="hljs-class"> :</span></span> MarshalByRefObject, ICloneable, IDisposable, ISerializable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream outputStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_iconData != null) { outputStream.Write(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputStream == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"dataStream"</span></span>); .... } } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3095</u></a>在对null进行验证之前，已使用'outputStream'对象。 检查行：654、672。Icon.Windows.cs 654 <br><br> 同样，这是我们已经知道的故事-可能会取消引用null引用，因为在不检查<i>null的</i>情况下取消引用方法的参数。 再次，情况的成功巧合-类和方法都是公开的，因此我们可以尝试重现该问题。 <br><br> 我们的任务很简单-将代码执行带到表达式<i>outputStream.Write（_iconData，0，_iconData.Length）;</i> 并同时保存变量<i>outputStream</i> - <i>null的值</i> 。 满足条件<i>_iconData！= Null</i>就足够了。 <br><br> 让我们看一下最简单的公共构造函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br> 它只是将工作委托给另一个构造函数。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) { Debug.Assert(f != null, <span class="hljs-string"><span class="hljs-string">"File.OpenRead returned null instead of throwing an exception"</span></span>); _iconData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)f.Length]; f.Read(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } Initialize(width, height); }</code> </pre> <br> 就这样，这就是我们需要的。 调用此构造函数后，如果我们成功地从文件中读取了数据并且<i>Initialize</i>方法没有崩溃，则<i>_iconData</i>字段将包含对对象的引用，这就是我们所需要的。 <br><br> 事实证明，我们必须创建<i>Icon</i>类的实例并指定一个实际的图标文件才能重现该问题。 之后，我们需要调用<i>Save</i>方法，并将<i>null</i>值作为参数传递，这就是我们要做的。 该代码可能看起来像这样，例如： <br><br><pre> <code class="cpp hljs">Icon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(@<span class="hljs-string"><span class="hljs-string">"D:\document.ico"</span></span>); icon.Save(null);</code> </pre> <br> 执行结果是预期的。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b37/fdb/dd1/b37fdbdd1288c054fdaaa0add0ffcfcf.png" alt="图片8"></div><br>  <b>第6期</b> <br><br> 我们继续进行审查并继续。 尝试找出在<i>情况CimType.UInt32</i>和其他<i>情况下</i>执行的操作之间的3个差异。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToNumericValueAndAddToArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> retFunctionName = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; enumType = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(cimType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retFunctionName; }</code> </pre> <br> 当然，没有差异，因为分析仪会向我们发出警告。 <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3139</u></a>两个或更多案例分支执行相同的操作。  WMIGenerator.cs 5220 <br><br> 就个人而言，这种代码风格不是很清楚。 我认为，如果没有错误，则不应将相同的逻辑应用于不同的情况。 <br><br>  <b>第7期</b> <br><br>  <i>Microsoft.CSharp</i>库。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;KeyValuePair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, object&gt;&gt; QueryDynamicObject(object obj) { .... List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mo.GetDynamicMemberNames()); names.Sort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names != null) { .... } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3022</u></a>表达式'names！= Null'始终为true。  DynamicDebuggerProxy.cs 426 <br><br> 我可能会忽略此警告以及诊断程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3022</u></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3063</u></a>发出的许多类似警告。 有很多（很多）奇怪的检查，但这不知何故进入了我的灵魂。 也许原因在于将本地<i>名称</i>变量与<i>null</i>进行比较之前发生了什么<i>。</i> 不仅将引用存储在新创建对象的<i>名称</i>变量中，而且还调用实例<i>Sort</i>方法。 当然，这不是错误，但就我而言，值得关注。 <br><br>  <b>第8期</b> <br><br> 另一段有趣的代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertChildNoGrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol child)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sym?.nextSameName != null) { sym = sym.nextSameName; } Debug.Assert(sym != null &amp;&amp; sym.nextSameName == null); sym.nextSameName = child; .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3042</u></a>可能为NullReferenceException。  '？。' 和“。” 运算符用于访问'sym'对象SymbolStore.cs的成员56 <br><br> 看看是什么东西。 遵循以下两个条件中的至少一个条件，循环结束： <br><br><ul><li>  <i>sym == null</i> ; </li><li>  <i>sym.nextSameName == null</i> 。 </li></ul><br> 第二个条件没有问题，关于第一个条件不能说。 由于<i>名称</i>实例字段是在下面无条件访问的，并且如果为<i>sym</i> - <i>null</i> ，则将发生<i>NullReferenceException</i>类型的异常。 <br><br> 你瞎了吗 在<i>Debug.Assert</i>调用中，检查了<i>sym！= Null</i> ”-有人可能会争论。 恰恰相反，这就是重点！ 在发布版本中工作时， <i>Debug.Assert</i>不会有任何帮助，并且在上述条件下，我们将获得的只是<i>NullReferenceException</i> 。 而且，我已经在Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>Roslyn的</u></a>另一个项目中看到了类似的错误，在<i>Debug.Assert中</i>也发生了类似的情况。 让我为罗斯林转一会儿。 <br><br> 使用<i>Microsoft.CodeAnalysis</i>库时可能会重现此问题，或者使用语法Visualizer时可能会在Visual Studio中重现该问题。 在Visual Studio 16.1.6 +语法Visualizer 1.0中，仍然可以重现此问题。 <br><br> 这段代码就足够了： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br> 此外，在Syntax Visualizer中，我们需要找到<i>ConstantPatternSyntax</i>类型的语法树的节点，该节点对应于代码中的<i>null</i>并<i>为其</i>请求<i>TypeSymbol</i> 。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/b9c/baa/855b9cbaa67c9a5909117d513e154293.png" alt="图片9"></div><br> 之后，Visual Studio将重新启动。 如果转到事件查看器，我们将在库中找到一些有关问题的信息： <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.Resources.MissingManifestResourceException at System.Resources.ManifestBasedResourceGroveler .HandleResourceStreamMissing(System.String) at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet( System.Globalization.CultureInfo, System.Collections.Generic.Dictionary<span class="hljs-string"><span class="hljs-string">'2 &lt;System.String,System.Resources.ResourceSet&gt;, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean) at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo) at Roslyn.SyntaxVisualizer.DgmlHelper.My. Resources.Resources.get_SyntaxNodeLabel() ....</span></span></code> </pre> <br> 至于devenv.exe的问题： <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.1</span></span><span class="hljs-number"><span class="hljs-number">.29102</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5d1c133b</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: KERNELBASE.dll, version: <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.18362</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0xf5733ace</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xe0434352</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x001133d2</span></span> ....</code> </pre> <br> 使用Roslyn库的调试版本，您可以找到发生异常的地方： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } .... }</code> </pre> <br> 在这里，与上述.NET Core库中的代码相同，对<i>Debug.Assert</i>进行了检查，这在使用库的发行版时<i>无济于事</i> 。 <br><br>  <b>第9期</b> <br><br> 我们在这里有些偏离，所以让我们回到.NET Core库。  <i>System.IO.IsolatedStorage</i>程序包包含以下有趣的代码。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsUnknownFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (files.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> || ( (!IsIdFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) || (files.Length == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; !IsIdFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ); }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3088</u></a>该表达式用括号括起来两次：（（表达式））。 不需要一对括号，否则会出现打印错误。 孤立的StorageFile.cs 839 <br><br> 说代码格式令人困惑是另一种无话可说的方法。 简短地看一下这段代码，我会说第一个||的左操作数。 我遇到的运算符是<i>files.Length&gt; 2</i> ，右边的是括号中的一个。 至少代码是这样格式化的。 在仔细查看之后，您可以了解并非如此。 实际上，右操作数- <i>（（！IsIdFile（文件[0]）&amp;&amp;！IsInfoFile（文件[0]）））</i> 。 我认为这段代码非常令人困惑。 <br><br>  <b>第10期</b> <br><br>  PVS-Studio 7.03引入了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3138</u></a>诊断规则，该规则搜索内插字符串中的错误。 更确切地说，在字符串中最有可能必须进行插值，但是由于缺少<i>$</i>符号，它们不是<i>。</i> 在<i>System.Net</i>库中，我发现了此诊断规则的一些有趣事件。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheCredential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SafeFreeCredentials newHandle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ExceptionCheck.IsFatal(e)) { NetEventSource.Fail(null, <span class="hljs-string"><span class="hljs-string">"Attempted to throw: {e}"</span></span>); } } }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3138</u></a>字符串文字包含潜在的内插表达式。 考虑检查：e。  SSPIHandleCache.cs 42 <br><br>  <i>Fail</i>方法的第二个参数很有可能必须是插值字符串，其中将替换<i>e</i>异常的字符串表示形式。 但是，由于缺少<i>$</i>符号，因此未替换任何字符串表示形式。 <br><br>  <b>第11期</b> <br><br> 这是另一个类似的情况。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; GetDigestTokenForCredential(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Error(digestResponse, <span class="hljs-string"><span class="hljs-string">"Algorithm not supported: {algorithm}"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3138</u></a>字符串文字包含潜在的内插表达式。 考虑检查：算法。  AuthenticationHelper.Digest.cs 58 <br><br> 情况与上述情况类似，再次缺少<i>$</i>符号，导致字符串不正确，并进入<i>Error</i>方法<i>。</i> <br><br>  <b>第十二期</b> <br><br>  <i>System.Net.Mail</i>程序包。 该方法很小，我将其全部引用以使搜索错误更有趣。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(stream)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_streamSet) { _stream.Close(); _stream = null; _streamSet = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _stream = stream; _streamSet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _streamUsedOnce = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TransferEncoding = TransferEncoding.Base64; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3008为</u></a> '_streamSet'变量连续两次分配值。 也许这是一个错误。 检查行：123、119。MimePart.cs 123 <br><br> 变量<i>_streamSet的</i>双值分配看起来很奇怪（首先-在条件下，然后-外部）。 重置<i>流</i>变量也是如此。 结果， <i>_stream</i>仍将具有值<i>stream</i> ，并且<i>_streamSet</i>将为<i>true。</i> <br><br>  <b>第13期</b> <br><br>  <i>System.Linq.Expressions</i>库中一个有趣的代码片段，它立即触发2个分析器警告。 在这种情况下，它更像是功能，而不是错误。 但是，这种方法很不寻常... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws NRE when o is null protected static void NullCheck(object o) { if (o == null) { o.GetType(); } }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3010</u></a>需要使用函数“ GetType”的返回值。  Instruction.cs 36 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3080</u></a>可能为空的取消引用。 考虑检查“ o”。  Instruction.cs 36 </li></ul><br> 这里可能没有什么可评论的。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/a88/a22/5c9a88a221d4cd5ba5f4f1d9f74a346b.png" alt="图片20"></div><br>  <b>第14期</b> <br><br> 让我们考虑另一种情况，我们将“从外部”处理。 首先，我们将编写代码，检测问题，然后看内部。 我们将使用<i>System.Configuration.ConfigurationManager</i>库和同名的NuGet包进行检查。 我使用了4.5.0版本的程序包。 我们将处理<i>System.Configuration.CommaDelimitedStringCollection</i>类。 <br><br> 让我们做一些简单的事情。 例如，我们将创建一个对象，提取其字符串表示形式并获取该字符串的长度，然后进行打印。 相关代码： <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); Console.WriteLine(collection.ToString().Length);</code> </pre> <br> 以防万一，我们将检查<i>ToString</i>方法说明： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dc/544/56d/8dc54456dd1296d89fbe447fac71ac17.png" alt="图片11"></div><br> 没什么特别的-返回对象的字符串表示形式。 以防万一，我将签出docs.microsoft.com-“ <u>CommaDelimitedStringCollection.ToString方法</u> ”。 似乎这里没有什么特别的。 <br><br> 好吧，让我们执行代码，aaand ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/89f/1af/fa589f1afc8ceb9415694e1261e59ab7.png" alt="图片12"></div><br> 嗯，惊喜。 好吧，让我们尝试将一个项目添加到集合中，然后获取其字符串表示形式。 接下来，我们“绝对偶然”添加一个空字符串:)。 代码将更改，如下所示： <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); collection.Add(String.Empty); Console.WriteLine(collection.ToString().Length);</code> </pre> <br> 执行并查看... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/4bc/d2e/d374bcd2ed23bd048276493ed19d30fe.png" alt="图片13"></div><br> 又是什么？！ 好了，让我们最后解决<i>CommaDelimitedStringCollection</i>类中<i>ToString</i>方法的<i>实现</i> 。 代码如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); foreach (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ThrowIfContainsDelimiter(str); <span class="hljs-comment"><span class="hljs-comment">// .... sb.Append(str.Trim()); sb.Append(','); } if (sb.Length &gt; 0) sb.Length = sb.Length - 1; return sb.Length == 0 ? null : sb.ToString(); }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3108</u></a>不建议从“ ToSting（）”方法返回“ null”。  StringAttributeCollection.cs 57 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3108</u></a>不建议从“ ToSting（）”方法返回“ null”。  StringAttributeCollection.cs 71 </li></ul><br> 在这里，我们可以看到2个片段，其中当前的<i>ToString</i>实现可以返回<i>null。</i> 至此，我们将回顾Microsoft关于<i>ToString</i>方法实现的建议。 因此，请参考docs.microsoft.com-“ Object.ToString <u>方法</u> ”： <br><br>  <i>对继承者的说明.... ToString（）方法的重写应遵循以下准则：</i> <br><br><ul><li>  <i>....</i> </li><li>  <i>您的ToString（）重写不应返回Empty或</i> <b><i>空</i></b> <i>字符串。</i> </li><li>  <i>....</i> </li></ul><br> 这就是PVS-Studio警告的地方。 上面给出的用于重现该问题的两个代码片段分别具有不同的退出点-分别是第一个和第二个<i>空</i>返回点。 让我们深入一点。 <br><br> 第一种情况。  <i>Count</i>是<i>StringCollection</i>基类的属性。 由于未添加任何元素， <i>Count == 0</i> ，条件<i>Count &lt;= 0</i>为true，则返回<i>空</i>值。 <br><br> 在第二种情况下，我们使用实例<i>CommaDelimitedStringCollection.Add</i>方法添加了该元素。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ ThrowIfReadOnly(); ThrowIfContainsDelimiter(value); _modified = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; base.Add(value.Trim()); }</code> </pre> <br> 在<i>ThrowIf ...</i>方法中检查成功，并且该元素已添加到基本集合中。 因此， <i>Count</i>值变为1。现在回到<i>ToString</i>方法。 表达式<i>Count的</i>值<i>&lt;= 0</i> - <i>false</i> ，因此该方法不返回并且代码执行继续。 遍历内部集合，将2个元素添加到<i>StringBuilder</i>类型的实例-一个空字符串和一个逗号。 结果，结果<i>sb</i>仅包含一个逗号， <i>Length</i>属性的值分别等于1。表达式<i>sb.Length&gt; 0的</i>值为<i>true</i> ，执行了<i>sb.Length的</i>减法和写操作，现在该值<i>sb.Length的of</i>为0。这导致以下事实：从该方法再次返回<i>null</i>值。 <br><br>  <b>第十五期</b> <br><br> 突然之间，我渴望使用<i>System.Configuration.ConfigurationProperty</i>类。 让我们以参数数量最多的构造函数为例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span></span>;</code> </pre> <br> 让我们看一下最后一个参数的描述： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// description: // The description of the configuration entity.</span></span></code> </pre> <br> 在docs.microsoft.com的构造函数说明中也写有相同的内容。 好，让我们看一下如何在构造函数的主体中使用此参数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span><span class="hljs-function"> </span></span>{ ConstructorInit(name, type, options, validator, typeConverter); SetDefaultValue(defaultValue); }</code> </pre> <br> 信不信由你，该参数未使用。 <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3117</u></a>未使用构造函数参数“ description”。  ConfigurationProperty.cs 62 <br><br> 也许代码编写者有意不使用它，但是相关参数的描述却非常混乱。 <br><br>  <b>第16期</b> <br><br> 这是另一个类似的片段：尝试自己找到错误，我在下面提供了构造函数的代码。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SectionXmlInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configKey, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> definitionConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber, object streamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawXml, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSource, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSourceStreamName, object configSourceStreamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protectionProviderName, OverrideModeSetting overrideMode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skipInChildApps)</span></span></span><span class="hljs-function"> </span></span>{ ConfigKey = configKey; DefinitionConfigPath = definitionConfigPath; TargetConfigPath = targetConfigPath; SubPath = subPath; Filename = filename; LineNumber = lineNumber; StreamVersion = streamVersion; RawXml = rawXml; ConfigSource = configSource; ConfigSourceStreamName = configSourceStreamName; ProtectionProviderName = protectionProviderName; OverrideModeSetting = overrideMode; SkipInChildApps = skipInChildApps; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3117</u></a>未使用构造函数参数“ configSourceStreamVersion”。  SectionXmlInfo.cs 16 <br><br> 有一个适当的属性，但是坦率地说，它看起来有点奇怪： <br><br><pre> <code class="cpp hljs">internal object ConfigSourceStreamVersion { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { } }</code> </pre> <br> 通常，该代码看起来可疑。 也许保留参数/属性是为了实现兼容性，但这只是我的猜测。 <br><br>  <b>第17期</b> <br><br> 让我们看一下<i>System.Runtime.WindowsRuntime.UI.Xaml</i>库中的有趣内容以及同名程序包代码。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalToString(null, null); } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3108</u></a>不建议从“ ToSting（）”方法返回“ null”。  RepeatBehavior.cs 113 <br><br> 我们已经知道的熟悉的故事<i>-ToString</i>方法可以返回<i>null</i>值。 因此，调用者代码的作者可能会不愉快地感到惊讶，该调用者的代码假定<i>RepeatBehavior.ToString</i>始终返回非null引用。 同样，它与Microsoft的准则相抵触。 <br><br> 很好，但是该方法并不清楚<i>ToString</i>可以返回<i>null-</i>我们需要更深入地研究<i>InternalToString</i>方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, IFormatProvider formatProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_Type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Forever: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Forever"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Count: StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendFormat( formatProvider, <span class="hljs-string"><span class="hljs-string">"{0:"</span></span> + format + <span class="hljs-string"><span class="hljs-string">"}x"</span></span>, _Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Duration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Duration.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br> 分析器检测到，如果<i>默认</i>分支在<i>switch中</i>执行， <i>InternalToString</i>将返回<i>空</i>值。 因此， <i>ToString</i>也将返回<i>null</i> 。 <br><br>  <i>RepeatBehavior</i>是一个公共结构，而<i>ToString</i>是一个公共方法，因此我们可以尝试在实践中重现该问题。 为此，我们将创建<i>RepeatBehavior</i>实例，从该实例调用<i>ToString</i>方法，同时不要错过<i>_Type</i>不得等于<i>RepeatBehaviorType.Forever</i> ， <i>RepeatBehaviorType.Count</i>或<i>RepeatBehaviorType.Duration</i> 。 <br><br>  <i>_Type</i>是私有字段，可以通过公共属性进行分配： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RepeatBehaviorType _Type; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RepeatBehaviorType Type { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Type; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _Type = value; } } .... }</code> </pre> <br> 到目前为止，一切都很好。 让我们继续前进，看看什么是<i>RepeatBehaviorType</i>类型。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepeatBehaviorType { Count, Duration, Forever }</code> </pre> <br> 如我们所见， <i>RepeatBehaviorType</i>是枚举，包含所有三个元素。 除此之外，我们感兴趣的<i>switch</i>表达式涵盖了所有这三个元素。 但是，这并不意味着默认分支不可访问。 <br><br> 要重现该问题，我们将对<i>System.Runtime.WindowsRuntime.UI.Xaml</i>包的引用添加到项目中（我使用的是4.3.0版本），然后执行以下代码。 <br><br><pre> <code class="cpp hljs">RepeatBehavior behavior = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RepeatBehavior() { Type = (RepeatBehaviorType)<span class="hljs-number"><span class="hljs-number">666</span></span> }; Console.WriteLine(behavior.ToString() is null);</code> </pre> <br>  <i>True</i>在控制台中按预期显示，这意味着<i>ToString</i>返回<i>null</i> ，因为<i>_Type</i>不等于<i>case</i>分支中的任何值，并且<i>默认</i>分支已接收控件。 那就是我们想要做的。 <br><br> 我也想指出，该方法的注释和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>docs.microsoft.com均未</u></a>指定该方法可以返回<i>空</i>值。 <br><br>  <b>第18期</b> <br><br> 接下来，我们将检查<i>System.Private.DataContractSerialization中的</i>一些警告。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte None = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte FirstName = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Name = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Whitespace = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Text = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte AttributeText = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte SpecialWhitespace = <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Comment = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte[] s_charType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">256</span></span>] { .... CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* 9 (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* A (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* B (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* C (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* D (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace, <span class="hljs-comment"><span class="hljs-comment">/* E (.) */</span></span> CharType.None, .... };</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3001</u></a>在'|'的左侧和右侧有相同的子表达式' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CharType.Comment</u></a> '。 操作员。  XmlUTF8TextReader.cs 56 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3001</u></a>在'|'的左侧和右侧有相同的子表达式' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CharType.Comment</u></a> '。 操作员。  XmlUTF8TextReader.cs 58 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3001</u></a>在'|'的左侧和右侧有相同的子表达式' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>CharType.Comment</u></a> '。 操作员。  XmlUTF8TextReader.cs 64 </li></ul><br> 分析器发现<i>CharType.Comment | CharType.Comment</i>表达式的用法可疑。 看起来有点奇怪，如<i>（CharType.Comment | CharType.Comment）== CharType.Comment</i> 。 初始化使用<i>CharType.Comment的</i>其他数组元素时，没有这样的重复。 <br><br>  <b>第19期</b> <br><br> 让我们继续。 让我们在方法说明和docs.microsoft.com-“ <u>XmlBinaryWriterSession.TryAdd（XmlDictionaryString，Int32）方法</u> ”中检查有关<i>XmlBinaryWriterSession.TryAdd</i>方法的返回值的信息： <i>返回：如果可以添加字符串，则返回true；否则，返回false。</i>  <i>否则为假。</i> <br><br> 现在让我们看一下该方法的主体： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlDictionaryString value, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ IntArray keys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperArgumentNull(nameof(value)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_maps.TryGetValue(value.Dictionary, out keys)) { key = (keys[value.Key] - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// If the key is already set, then something is wrong throw System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperError( new InvalidOperationException( SR.XmlKeyAlreadyExists)); } key = Add(value.Value); keys[value.Key] = (key + 1); return true; } key = Add(value.Value); keys = AddKeys(value.Dictionary, value.Key + 1); keys[value.Key] = (key + 1); return true; }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3009</u></a>奇怪的是，此方法始终返回一个相同的“ true”值。  XmlBinaryWriterSession.cs 29 <br><br> 该方法返回<i>true</i>或引发异常似乎很奇怪，但是永远不会返回<i>false</i>值。 <br><br>  <b>第20期</b> <br><br> 我遇到了类似问题的代码，但在这种情况下，恰恰相反，该方法始终返回<i>false</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHandleReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlWriter.depth &lt; depthToCheckCyclicReference) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canContainCyclicReference) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_byValObjectsInScope.Contains(obj)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; _byValObjectsInScope.Push(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3009</u></a>奇怪的是，此方法始终返回一个相同的'false'值。  XmlObjectSerializerWriteContext.cs 415 <br><br> 好吧，我们已经走了很长一段路！ 因此，在继续之前，我建议您休息一会儿：振奋肌肉，四处走走，休息一下眼睛，看着窗外... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/d6a/92d/008d6a92d6f4cf4066e744e4c857b47d.png" alt="图片24"></div><br> 我希望在这一点上您再次充满活力，所以让我们继续。  :) <br><br>  <b>第21期</b> <br><br> 让我们回顾一下<i>System.Security.Cryptography.Algorithms</i>项目的一些引人入胜的片段。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override byte[] GenerateMask(byte[] rgbSeed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cbReturn) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) { byte[] rgbCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; byte[] rgbT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[cbReturn]; uint counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ib = <span class="hljs-number"><span class="hljs-number">0</span></span>; ib &lt; rgbT.Length;) { <span class="hljs-comment"><span class="hljs-comment">// Increment counter -- up to 2^32 * sizeof(Hash) Helpers.ConvertIntToByteArray(counter++, rgbCounter); hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); hasher.TransformFinalBlock(rgbCounter, 0, 4); byte[] hash = hasher.Hash; hasher.Initialize(); Buffer.BlockCopy(hash, 0, rgbT, ib, Math.Min(rgbT.Length - ib, hash.Length)); ib += hasher.Hash.Length; } return rgbT; } }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u>V3080</u></a>可能为空的取消引用。 考虑检查“哈希”。  PKCS1MaskGenerationMethod.cs 37 <br><br> 分析器警告评估<i>哈希器</i>时， <i>哈希器</i>变量的值可以为<i>null</i> <i>TransformBlock</i>表达式会导致<i>NullReferenceException</i>类型的异常。 由于过程间分析，该警告的发生成为可能。 <br><br> 因此，要了解在这种情况下<i>hasher是否</i>可以采用<i>null</i>值，我们需要使用<i>CreateFromName</i>方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateFromName(name, null); }</code> </pre> <br> 到目前为止没有-让我们更深入。 重载的具有两个参数的<i>CreateFromName</i>版本的主体非常大，因此我引用了简短版本。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, params object[] args)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retvalType == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cons == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rci == null || typeof(Delegate).IsAssignableFrom(rci.DeclaringType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，该方法中有多个出口点，其中</font><font style="vertical-align: inherit;">显式返回</font><font style="vertical-align: inherit;">了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。因此，至少在理论上，在上述方法中，该警告触发了警告，</font><font style="vertical-align: inherit;">可能会发生</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理论很棒，但让我们尝试在实践中重现问题。为此，我们将再次查看原始方法并注意要点。同样，我们将减少方法中不相关的代码。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PKCS1MaskGenerationMethod</span></span></span><span class="hljs-class"> :</span></span> .... <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 { .... public PKCS1MaskGenerationMethod() // &lt;= 2 { _hashNameValue = DefaultHash; } .... public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) // &lt;= 3 { using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) // &lt;= 4 { byte[] rgbCounter = new byte[4]; byte[] rgbT = new byte[cbReturn]; // &lt;= 5 uint counter = 0; for (int ib = 0; ib &lt; rgbT.Length;) // &lt;= 6 { .... Helpers.ConvertIntToByteArray(counter++, rgbCounter); // &lt;= 7 hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); .... } .... } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们仔细看一下关键点：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1，3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该类和方法具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公共</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">访问修饰符。因此，当添加对库的引用时，此接口可用-我们可以尝试重现此问题。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该类是非抽象实例，具有公共构造函数。创建实例将很容易，我们将使用它。在我认为的某些情况下，类是抽象的，因此要重现该问题，我必须搜索继承者和获取它们的方法。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CreateFromName</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不得生成任何异常，并且必须返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的一点，我们稍后会再讲。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5、6</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cbReturn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值必须&gt; 0（但是，在成功创建数组的适当范围内）。</font><font style="vertical-align: inherit;">的合规性</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cbReturn&gt; 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件是需要的条件的进一步的满足</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IB &lt;rgbT.Length</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和环回输入到旧体。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helpres.ConvertIntToByteArray</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须正常工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了满足依赖于方法参数的条件，仅传递适当的参数就足够了，例如：</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rgbCeed-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新字节[] {0，1，2，3};</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cbReturn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -42。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消信用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><i><font style="vertical-align: inherit;">CryptoConfig.CreateFromName</font></i><font style="vertical-align: inherit;">方法，我们需要能够更改</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_hashNameValue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">幸运的是，我们有了它，因为该类为此字段定义了包装器属性：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> HashName { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _hashNameValue; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _hashNameValue = value ?? DefaultHash; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HashName</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置一个“合成”值</font><font style="vertical-align: inherit;">（即</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_hashNameValue），</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以</font><font style="vertical-align: inherit;">在标记的第一个出口点</font><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">CreateFromName</font></i><font style="vertical-align: inherit;">方法中</font><font style="vertical-align: inherit;">获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于该方法很大，因此我不会详细分析该方法（希望您对此宽恕）。</font><font style="vertical-align: inherit;">结果，导致</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">异常的代码</font><font style="vertical-align: inherit;">可能如下所示：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">PKCS1MaskGenerationMethod tempObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PKCS1MaskGenerationMethod(); tempObj.HashName = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>; tempObj.GenerateMask(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，我们添加对调试库的引用，运行代码并获得预期的结果： </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/384/8e5/2ab3848e542172cd92a7e03f55bba9fe.png" alt="图片10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 只是为了好玩，我尝试使用4.3.1版本的NuGet包执行相同的代码。 </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/a94/766/7b4a947666444496ca077e7530415c76.png" alt="图片14"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法描述中没有有关生成的异常，输出参数限制的信息。</font><font style="vertical-align: inherit;">Docs.microsoft.com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKCS1MaskGenerationMethod.GenerateMask（Byte []，Int32）方法</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “也未指定。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，在撰写本文并描述重现问题的操作顺序时，我发现了另外两种方法“中断”此方法：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递太大的值作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cbReturn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数；</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rgbSeed传递。</font></font></i> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一种情况下，我们将获得</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OutOfMemoryException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/474/7f9/c504747f9a771843da10a128866811dd.png" alt="图片15"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第二种情况下，</font><font style="vertical-align: inherit;">执行</font><i><font style="vertical-align: inherit;">rgbSeed.Length</font></i><font style="vertical-align: inherit;">表达式</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">，我们将获得</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，重要的是，</font><i><font style="vertical-align: inherit;">哈希</font></i><font style="vertical-align: inherit;">值必须为非null。</font><font style="vertical-align: inherit;">否则，控制流将不会到达</font><i><font style="vertical-align: inherit;">rgbSeed.Length</font></i><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">第22期</font></b><font style="vertical-align: inherit;">我遇到了两个类似的地方。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FormatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DeformatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> AsymmetricSignatureDeformatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeformatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsymmetricAlgorithm key)</span></span></span><span class="hljs-function"> </span></span>{ AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm); item.SetKey(key); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return item; } public virtual AsymmetricSignatureFormatter CreateFormatter( AsymmetricAlgorithm key) { AsymmetricSignatureFormatter item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(FormatterAlgorithm); item.SetKey(key); // &lt;= return item; } .... }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能为空的取消引用。</font><font style="vertical-align: inherit;">考虑检查“项目”。</font><font style="vertical-align: inherit;">SignatureDescription.cs 31</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能为空的取消引用。</font><font style="vertical-align: inherit;">考虑检查“项目”。</font><font style="vertical-align: inherit;">签名说明.cs 38</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FormatterAlgorithm</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeformatterAlgorithm</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性中，我们可以编写这样的值，对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CryptoConfig.CreateFromName</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，在</font><i><font style="vertical-align: inherit;">CreateDeformatter</font></i><font style="vertical-align: inherit;">和</font><i><font style="vertical-align: inherit;">CreateFormatter</font></i><font style="vertical-align: inherit;">方法中</font><font style="vertical-align: inherit;">，它们将</font><font style="vertical-align: inherit;">返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">。此外，在调用</font><i><font style="vertical-align: inherit;">SetKey</font></i><font style="vertical-align: inherit;">实例方法时，</font><font style="vertical-align: inherit;">将生成</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">异常。同样，该问题在实践中很容易重现：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">SignatureDescription signature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureDescription() { DeformatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>, FormatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; signature.CreateDeformatter(null); <span class="hljs-comment"><span class="hljs-comment">// NRE signature.CreateFormatter(null); // NRE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，在调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CreateDeformatter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CreateFormatter时</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将</font><font style="vertical-align: inherit;">引发</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的异常。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第23期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们回顾一下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Private.Xml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中</font><font style="vertical-align: inherit;">有趣的片段</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBase64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_inAttr &amp;&amp; (_inCDataSection || StartCDataSection())) _wrapped.WriteBase64(buffer, index, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _wrapped.WriteBase64(buffer, index, count); }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3004'then</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> '语句等效于'else'语句。</font><font style="vertical-align: inherit;">QueryOutputWriterV1.cs 242 </font><i><font style="vertical-align: inherit;">if</font></i><font style="vertical-align: inherit;">语句的</font><i><font style="vertical-align: inherit;">then</font></i><font style="vertical-align: inherit;">和</font><i><font style="vertical-align: inherit;">else</font></i><font style="vertical-align: inherit;">分支</font><font style="vertical-align: inherit;">包含相同的代码</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来很奇怪</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此处有错误，并且必须在其中一个分支中执行另一项操作，或者</font><font style="vertical-align: inherit;">可以省略</font><i><font style="vertical-align: inherit;">if</font></i><font style="vertical-align: inherit;">语句。</font><b><font style="vertical-align: inherit;">第24期</font></b></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Depends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlSchemaObject item, ArrayList refs)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseType = ((XmlSchemaSimpleTypeRestriction)content).BaseType; baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeList) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == typeof(XmlSchemaSimpleTypeUnion)) { .... } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3003检测到</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用'if（A）{...} else if（A）{...}'模式。</font><font style="vertical-align: inherit;">存在逻辑错误的可能性。</font><font style="vertical-align: inherit;">检查行：381，396。ImportContext.cs 381 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if-else-if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列中，有两个相等的条件表达式- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容为XmlSchemaSimpleTypeRestriction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而且，</font><font style="vertical-align: inherit;">各个语句</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分支的</font><font style="vertical-align: inherit;">主体</font><font style="vertical-align: inherit;">包含一组不同的表达式。</font><font style="vertical-align: inherit;">无论如何，第一个相关</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分支</font><font style="vertical-align: inherit;">的主体</font><font style="vertical-align: inherit;">将被执行（如果条件表达式为true），或者如果相关表达式为false </font><i><font style="vertical-align: inherit;">则不</font></i><font style="vertical-align: inherit;">执行。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第25期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了使在下一个方法中搜索错误更引人入胜，我将引用整个正文。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchesXmlType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IList&lt;XPathItem&gt; seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indexType)</span></span></span><span class="hljs-function"> </span></span>{ XmlQueryType typBase = GetXmlType(indexType); XmlQueryCardinality card; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (seq.Count) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: card = XmlQueryCardinality.Zero; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: card = XmlQueryCardinality.One; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: card = XmlQueryCardinality.More; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(card &lt;= typBase.Cardinality)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; typBase = typBase.Prime; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; seq.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateXmlType(seq[<span class="hljs-number"><span class="hljs-number">0</span></span>]).IsSubtypeOf(typBase)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您已应付-恭喜！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不是，请使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-PVS</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Studio进行救援：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;">V3102</font></u></a><font style="vertical-align: inherit;">通过循环内的常量索引可疑访问“ seq”对象的元素。 XmlQueryRuntime.cs 738 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环被执行时，表达</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我&lt;seq.Count</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被用作与所述一个的退出条件。它提出了开发人员要绕过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列</font><font style="vertical-align: inherit;">的想法</font><font style="vertical-align: inherit;">。但是在循环中，作者访问序列元素不是通过使用counter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-seq [i]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是使用数字文字-零（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq [0]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第26期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个错误仅适用于一小段代码，但这同样有趣。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ WriteValue(value); }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS的工作室预警：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3110</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的可能无限递归内“WriteValue”的方法。 XmlAttributeCache.cs 166 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方法调用自身，形成没有退出条件的递归。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第27期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;XPathNavigator&gt; DocOrderDistinct(IList&lt;XPathNavigator&gt; seq) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq; XmlQueryNodeSequence nodeSeq = (XmlQueryNodeSequence)seq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeSeq == null) nodeSeq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlQueryNodeSequence(seq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeSeq.DocOrderDistinct(_docOrderCmp); }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证之前，已使用'seq'对象。检查行：880、884。XmlQueryRuntime.cs 880 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方法可以获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值作为参数。因此，在访问</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Count</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性时，</font><font style="vertical-align: inherit;">将生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。在变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodeSeq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下方</font><font style="vertical-align: inherit;">进行检查。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodeSeq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是通过显式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强制转换获得的，但尚不清楚为什么进行检查。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则由于异常，控制流将无法进行此检查。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果强制转换失败，</font><font style="vertical-align: inherit;">则将生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidCastException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">；</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果转换成功，则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodeSeq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝对不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第28期，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我遇到了4个构造函数，其中包含未使用的参数。</font><font style="vertical-align: inherit;">也许，它们是出于兼容性考虑，但我发现这些未使用的参数没有其他注释。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用构造函数参数“ securityUrl”。</font><font style="vertical-align: inherit;">XmlSecureResolver.cs 15</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用构造函数参数“ strdata”。</font><font style="vertical-align: inherit;">XmlEntity.cs 18</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不使用构造函数参数“位置”。</font><font style="vertical-align: inherit;">编译.cs 58</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不使用构造函数参数“ access”。</font><font style="vertical-align: inherit;">XmlSerializationILGen.cs 38</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个对我最感兴趣（至少它进入了本文的警告列表）。</font><font style="vertical-align: inherit;">有什么特别的？</font><font style="vertical-align: inherit;">不知道 </font><font style="vertical-align: inherit;">也许是它的名字。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlSecureResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlResolver resolver, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> securityUrl)</span></span></span><span class="hljs-function"> </span></span>{ _resolver = resolver; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是出于兴趣，我检查了docs.microsoft.com上</font><font style="vertical-align: inherit;">有关</font><i><font style="vertical-align: inherit;">securityUrl</font></i><font style="vertical-align: inherit;">参数的</font><font style="vertical-align: inherit;">内容</font><font style="vertical-align: inherit;">-“ </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XmlSecureResolver构造函数</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">：</font><i><font style="vertical-align: inherit;">用于创建将应用于基础XmlResolver的PermissionSet的URL。 XmlSecureResolver在基础XmlResolver上调用GetEntity（Uri，String，Type）之前，在创建的PermissionSet上调用PermitOnly（）。</font></i><b><font style="vertical-align: inherit;">问题29</font></b><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">System.Private.Uri</font></i><font style="vertical-align: inherit;">包中，我找到了该方法，该方法没有完全遵循Microsoft关于</font><i><font style="vertical-align: inherit;">ToString</font></i><font style="vertical-align: inherit;">方法覆盖的</font><font style="vertical-align: inherit;">准则</font><font style="vertical-align: inherit;">。在这里，我们需要回顾页面“ </font><u><font style="vertical-align: inherit;">Object.ToString Method</font></u><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">中的提示之一</font><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font></u><font style="vertical-align: inherit;"></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的ToString（）重写不应引发异常</font></font></i></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被覆盖的方法本身看起来像这样：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_username.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriFormatException(SR.net_uri_BadUserPassword); } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3108</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不建议从“ ToSting（）”方法引发异常。</font><font style="vertical-align: inherit;">UriBuilder.cs 406 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的下面的代码首先设置一个空：字符串为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_username</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段和一个非空的一个对所述</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_password</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段分别通过属性公共</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的用户名</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密码。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，它将调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法。</font><font style="vertical-align: inherit;">最终，此代码将获得异常。</font><font style="vertical-align: inherit;">此类代码的示例：</font></font><br><br><pre> <code class="cpp hljs">UriBuilder uriBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder() { UserName = String.Empty, Password = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; String stringRepresentation = uriBuilder.ToString(); Console.WriteLine(stringRepresentation);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是在这种情况下，开发人员会诚实地警告调用可能会导致异常。</font><font style="vertical-align: inherit;">在对该方法的注释以及docs.microsoft.com-“ </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UriBuilder.ToString方法</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">中对此进行了描述</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第30版</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Data.Common</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目代码</font><font style="vertical-align: inherit;">上发布的警告</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList _tables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tables.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DataTable)_tables[<span class="hljs-number"><span class="hljs-number">0</span></span>]; .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3106</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能索引超出范围。</font><font style="vertical-align: inherit;">索引“ 0”指向“ _tables”界限之外。</font><font style="vertical-align: inherit;">XMLDiffLoader.cs 277 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这段代码看起来异常吗？</font><font style="vertical-align: inherit;">您认为是什么？</font><font style="vertical-align: inherit;">一种异常的方式来生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArgumentOutOfRangeException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">我不会为这种方法感到惊讶。</font><font style="vertical-align: inherit;">总体而言，这是非常奇怪和可疑的代码。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第31期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal XmlNodeOrder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComparePosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XPathNodePointer other)</span></span></span><span class="hljs-function"> </span></span>{ RealFoliate(); other.RealFoliate(); Debug.Assert(other != null); .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在验证是否为空之前使用了“其他”对象。</font><font style="vertical-align: inherit;">检查行：1095，1096。XPathNodePointer.cs 1095 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other！= Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">的参数，这</font><font style="vertical-align: inherit;">表明</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComparePosition</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法可以获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值作为参数。</font><font style="vertical-align: inherit;">至少，目的是要抓住这种情况。</font><font style="vertical-align: inherit;">但是同时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other.RealFoliate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例方法</font><font style="vertical-align: inherit;">上方的行</font><font style="vertical-align: inherit;">被调用。</font><font style="vertical-align: inherit;">结果，如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值，</font><font style="vertical-align: inherit;">则在通过</font><i><font style="vertical-align: inherit;">Assert</font></i><font style="vertical-align: inherit;">检查之前，将生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第32期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyDescriptorCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attribute[] attributes)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (Attribute attribute in attributes) { Attribute attr = property.Attributes[attribute.GetType()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (attr == null &amp;&amp; !attribute.IsDefaultAttribute()) || !attr.Match(attribute)) { match = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3080</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能为空的取消引用。考虑检查“ attr”。 DbConnectionStringBuilder.cs 534 </font><i><font style="vertical-align: inherit;">if</font></i><font style="vertical-align: inherit;">语句的</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件表达式</font><font style="vertical-align: inherit;">看起来非常可疑。</font><i><font style="vertical-align: inherit;">Match</font></i><font style="vertical-align: inherit;">是一个实例方法。根据check </font><i><font style="vertical-align: inherit;">attr == null</font></i><font style="vertical-align: inherit;">，</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">是此变量的可接受（预期）值。因此，如果控制流到达||的正确操作数运算符（如果</font><i><font style="vertical-align: inherit;">attr</font></i><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">），我们将获得</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，异常发生的条件如下：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><ol><li> The value of <i>attr</i> — <i>null</i> . The right operand of the &amp;&amp; operator is evaluated. </li><li> The value of <i>!attribute.IsDefaultAttribute()</i> — <i>false</i> . The overall result of the expression with the &amp;&amp; operator — <i>false</i> . </li><li> Since the left operand of the || operator is of the <i>false</i> value, the right operand is evaluated. </li><li> Since <i>attr</i> — <i>null</i> , when calling the <i>Match</i> method, an exception is generated. </li></ol><br> <b>Issue 33</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadOldRowData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataSet ds, ref DataTable table, ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, XmlReader row)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table == null) { row.Skip(); <span class="hljs-comment"><span class="hljs-comment">// need to skip this element if we dont know about it, // before returning -1 return -1; } .... if (table == null) throw ExceptionBuilder.DiffgramMissingTable( XmlConvert.DecodeName(row.LocalName)); .... }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3021</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两个带有相同条件表达式的'if'语句。第一个'if'语句包含方法return。这意味着第二个'if'语句是毫无意义的XMLDiffLoader.cs301。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句包含相等的expression- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。与，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些语句的分支包含不同的动作-在第一种情况下，与该值的方法退出-1，在第二个-生成异常。的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该表</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量没有改变用于检查之间。因此，不会生成考虑的异常。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第34期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font><i><font style="vertical-align: inherit;">System.ComponentModel</font></i><font style="vertical-align: inherit;">看有趣的方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。类型转换器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目。好吧，让我们先阅读注释，并对其进行描述：</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从格式化的字符串中删除最后一个字符。 （删除虚拟字符串中的最后一个字符）。退出时，out参数包含实际执行操作的位置。此位置相对于测试字符串。 MaskedTextResultHint输出参数可提供有关操作结果的更多信息。</font></font></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">成功</font></i><i><font style="vertical-align: inherit;">返回</font></i></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">否则</font></i><i><font style="vertical-align: inherit;">返回</font></i></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回值的关键点：如果操作成功，则该方法返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，否则</font><font style="vertical-align: inherit;">返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让我们看看实际上发生了什么。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> testPosition, out MaskedTextResultHint resultHint)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastAssignedPos == INVALID_INDEX) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nothing to remove. } .... return true; }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3009</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇怪的是，此方法始终返回一个相同的“ true”值。 MaskedTextProvider.cs 1529 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，事实证明该方法的唯一返回值为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第35期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table.fInitInProgress &amp;&amp; _delayLoadingConstraints != null) { .... } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在验证为空后使用了'_table'对象。检查线路：437，423 ConstraintCollection.cs 437 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！_table = NULL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查不言自明-在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">γ_表</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量可以有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值。至少在这种情况下，代码作者可以得到重新保险。但是，它们在下面通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_table</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理实例字段，</font><font style="vertical-align: inherit;">但不检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_table .fInitInProgress</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第36期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们考虑为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Runtime.Serialization.Formatters</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">的代码发出的一些警告</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberNameInfo != null) { .... _serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((objectInfo._objectId == _topId) &amp;&amp; (_topName != null)) { _serWriter.WriteObjectEnd(topNameInfo, typeNameInfo); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReferenceEquals(objectInfo._objectType, Converter.s_typeofString)) { _serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo); } }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3038</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数多次传递给方法。</font><font style="vertical-align: inherit;">可能应改为传递其他参数。</font><font style="vertical-align: inherit;">BinaryObjectWriter.cs 262 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析仪的那句话：迷茫的呼吁最后</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_serWriter.WriteObjectEnd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的论据等于二两- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typeNameInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它看起来像是一个错字，但我不能肯定地说。</font><font style="vertical-align: inherit;">我决定检查什么是被调用方的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WriteObjectEnd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteObjectEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NameInfo memberNameInfo, NameInfo typeNameInfo)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 好吧...继续前进。 </font></font> :) <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第37期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSerializationHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion)</span></span></span><span class="hljs-function"> </span></span>{ var record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationHeaderRecord( BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion); record.Write(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在查看此代码时，我不会立即说这里有什么问题或看起来可疑。但是分析仪很可能会说是什么。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3066</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递给“ SerializationHeaderRecord”构造函数的参数的可能错误顺序：“ minorVersion”和“ majorVersion”。 BinaryFormatterWriter.cs 111 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请参见</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SerializationHeaderRecord</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">的被调用方构造函数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializationHeaderRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BinaryHeaderEnum binaryHeaderEnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion)</span></span></span><span class="hljs-function"> </span></span>{ _binaryHeaderEnum = binaryHeaderEnum; _topId = topId; _headerId = headerId; _majorVersion = majorVersion; _minorVersion = minorVersion; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如我们所见，构造函数的参数遵循</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">majorVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minorVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的顺序</font><font style="vertical-align: inherit;">；而在调用构造函数时</font><font style="vertical-align: inherit;">，</font><i><font style="vertical-align: inherit;">将按</font></i><font style="vertical-align: inherit;">以下顺序传递它们：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minorVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">majorVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。好像是错字。如果是故意制作的（如果呢？）-我认为这需要附加评论。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第38期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISurrogateSelector selector, StreamingContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkSecurity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isCrossAppDomain)</span></span></span><span class="hljs-function"> </span></span>{ _objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectHolder[DefaultInitialSize]; _selector = selector; _context = context; _isCrossAppDomain = isCrossAppDomain; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用构造函数参数'checkSecurity'。</font><font style="vertical-align: inherit;">ObjectManager.cs 33 </font><font style="vertical-align: inherit;">构造函数</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkSecurity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数未得到任何使用。</font><font style="vertical-align: inherit;">尚无评论。</font><font style="vertical-align: inherit;">我想这是为了兼容性，但是无论如何，在最近的安全性对话中，它看起来很有趣。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第39期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这对我来说似乎是不寻常的代码。</font><font style="vertical-align: inherit;">模式在所有三个检测到的情况下看起来都是相同的，并且位于名称和变量名称相同的方法中。</font><font style="vertical-align: inherit;">因此：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我或者没有足够的悟性来达到这种重复的目的； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 或者错误是通过复制粘贴方法传播的。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码本身： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnlargeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLength = _values.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException(SR.Serialization_TooManyElements); } newLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } FixupHolder[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FixupHolder[newLength]; Array.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">0</span></span>, _count); _values = temp; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'newLength == int.MaxValue'始终为false。</font><font style="vertical-align: inherit;">ObjectManager.cs 1423</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'newLength == int.MaxValue'始终为false。</font><font style="vertical-align: inherit;">ObjectManager.cs 1511</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'newLength == int.MaxValue'始终为false。</font><font style="vertical-align: inherit;">对象管理器.cs 1558</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他方法的不同之处在于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">临时</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组元素</font><font style="vertical-align: inherit;">的类型</font><font style="vertical-align: inherit;">（不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FixupHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">long</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">因此，我仍然怀疑是否存在复制粘贴... </font><i><font style="vertical-align: inherit;">System.Data.Odbc</font></i><font style="vertical-align: inherit;">项目中的</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题40</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnquoteIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(quotePrefix) || quotePrefix != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { .... } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'！String.IsNullOrEmpty（quotePrefix）|| quotePrefix！=“”'始终为true。 OdbcCommandBuilder.cs 338 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器假定给定表达式始终具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真实</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。真的是这样。甚至</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quotePrefix中的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际值是多少也</font><i><font style="vertical-align: inherit;">没关系</font></i><font style="vertical-align: inherit;"> -条件本身写得不正确。让我们深入到此。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有||操作者，所以表达式值将是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果左侧或右侧（或两者）的操作数将具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。左边的一句话很清楚。仅当左边的一个为</font><i><font style="vertical-align: inherit;">false时，</font></i><font style="vertical-align: inherit;">才会评估右边的一个</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">价值。</font><font style="vertical-align: inherit;">意味着这一点，如果表达式在那的右操作数的值总是方式组成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的时候的一个左的值是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则整个表达式的结果永远会的是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面的代码上面的从结果我们那知道如果有合适的操作数是评估的价值表达</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">string.IsNullOrEmpty（quotePrefix）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，所以一对这些声明的是真实的：</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quotePrefix == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quotePrefix.Length == 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果这些语句之一为true，则表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quotePrefix！=“”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也将为true，我们想证明这一点。意味着</font><font style="vertical-align: inherit;">无论</font><i><font style="vertical-align: inherit;">quotePrefix</font></i><font style="vertical-align: inherit;">内容</font><font style="vertical-align: inherit;">如何，</font><font style="vertical-align: inherit;">整个表达式的值始终为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">第41期</font></b><font style="vertical-align: inherit;">返回具有未使用参数的构造函数：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dueTime, DbConnection owner, TaskCompletionSource&lt;DbConnectionInternal&gt; completion, DbConnectionOptions userOptions)</span></span></span><span class="hljs-function"> </span></span>{ DueTime = dueTime; Owner = owner; Completion = completion; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> DueTime { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnection Owner { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskCompletionSource&lt;DbConnectionInternal&gt; Completion { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnectionOptions UserOptions { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3117</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未使用构造函数参数“ userOptions”。</font><font style="vertical-align: inherit;">DbConnectionPool.cs 26 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从分析器警告和代码中可以看到，仅一个构造函数的参数未使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-userOptions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而另一个则用于初始化同名属性。</font><font style="vertical-align: inherit;">似乎开发人员忘记了初始化属性之一。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第42期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一个可疑的代码，我们已经遇到了2次。</font><font style="vertical-align: inherit;">模式是相同的。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (DataRow row in schemaTable.Rows) { resultTable.Columns .Add(row[<span class="hljs-string"><span class="hljs-string">"ColumnName"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, (Type)row[<span class="hljs-string"><span class="hljs-string">"DataType"</span></span>] as Type); } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3051</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;">转换</font></u></a><font style="vertical-align: inherit;">过多。</font><font style="vertical-align: inherit;">该对象已经是“类型”类型。</font><font style="vertical-align: inherit;">dbMetaDataFactory.cs 176</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3051</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;">转换</font></u></a><font style="vertical-align: inherit;">过多。</font><font style="vertical-align: inherit;">该对象已经是“类型”类型。</font><font style="vertical-align: inherit;">OdbcMetaDataFactory.cs 1109</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的表达式</font><i><font style="vertical-align: inherit;">（Type）行[“ DataType”]</font></i><font style="vertical-align: inherit;">看起来可疑。首先，将执行显式转换，之后-通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符进行转换。如果值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行[“ DataType”]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则它将成功地“传递”两个转换，并将其作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">的参数</font><font style="vertical-align: inherit;">。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行[“ DataType”]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回无法转换为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的值，</font><font style="vertical-align: inherit;">则将在显式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转换</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期间立即生成</font><i><font style="vertical-align: inherit;">InvalidCastException</font></i><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。最后，为什么在这里需要两个铸件？问题是开放的。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第43期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看一下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Runtime.InteropServices.RuntimeInformation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FrameworkDescription { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_frameworkDescription == null) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> versionString = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)AppContext.GetData(<span class="hljs-string"><span class="hljs-string">"FX_PRODUCT_VERSION"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (versionString == null) { .... versionString = typeof(object).Assembly .GetCustomAttribute&lt; AssemblyInformationalVersionAttribute&gt;() ?.InformationalVersion; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> plusIndex = versionString.IndexOf(<span class="hljs-string"><span class="hljs-string">'+'</span></span>); .... } .... } .... } }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过空条件运算符分配了'versionString'变量后，使用该变量。</font><font style="vertical-align: inherit;">NullReferenceException是可能的。</font><font style="vertical-align: inherit;">RuntimeInformation.cs 29 </font><font style="vertical-align: inherit;">当调用</font><i><font style="vertical-align: inherit;">versionString</font></i><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">IndexOf</font></i><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">时</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，分析器会警告</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">可能存在异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">收到变量的值时，代码作者使用“？”。</font><font style="vertical-align: inherit;">操作员</font><font style="vertical-align: inherit;">在访问</font><i><font style="vertical-align: inherit;">InfromationalVersion</font></i><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">避免</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">诀窍是，如果</font><i><font style="vertical-align: inherit;">GetCustomAttribute &lt;...&gt;</font></i><font style="vertical-align: inherit;">的调用</font><font style="vertical-align: inherit;">返回</font><i><font style="vertical-align: inherit;">null</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仍然会生成异常，但是在下面-调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IndexOf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法时，因为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versionString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行第44期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们解决</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.ComponentModel.Composition</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目并浏览几个警告。</font><font style="vertical-align: inherit;">针对以下代码发出了两个警告：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSpecialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] genericParameterConstraints = ....; GenericParameterAttributes[] genericParameterAttributes = ....; <span class="hljs-comment"><span class="hljs-comment">// if no constraints and attributes been specifed, anything can be created if ((genericParameterConstraints == null) &amp;&amp; (genericParameterAttributes == null)) { return true; } if ((genericParameterConstraints != null) &amp;&amp; (genericParameterConstraints.Length != partArity)) { return false; } if ((genericParameterAttributes != null) &amp;&amp; (genericParameterAttributes.Length != partArity)) { return false; } for (int i = 0; i &lt; partArity; i++) { if (!GenericServices.CanSpecialize( specialization[i], (genericParameterConstraints[i] as Type[]). CreateTypeSpecializations(specialization), genericParameterAttributes[i])) { return false; } } return true; }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证之后，使用了'genericParameterConstraints'对象。</font><font style="vertical-align: inherit;">检查行：603、589。GenericSpecializationPartCreationInfo.cs 603</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证后，使用了'genericParameterAttributes'对象。</font><font style="vertical-align: inherit;">检查行：604、594。GenericSpecializationPartCreationInfo.cs 604</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码中有检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genericParameterAttributes！= Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genericParameterConstraints！= Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些变量的可接受值，我们将考虑在内。如果两个变量都为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值，我们将毫无疑问地退出该方法。如果上述两个变量之一为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但这样做了，我们不退出该方法怎么办？如果可能发生这种情况，并且执行要遍历循环，则将获得</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第45期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将转到该项目的另一个有趣警告。但是，让我们做些不同的事情-首先，我们将再次使用该类，然后查看代码。接下来，我们将添加对项目中最后一个可用的预发行版本的同名NuGet包的引用（我安装了版本4.6.0-preview6.19303.8的包）。让我们编写简单的代码，例如：</font></font><br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(null); Console.WriteLine(eq);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了equals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法不评论，我并没有在找到.NET核心的这种方法描述AT docs.microsoft.com，只为.NET框架。</font><font style="vertical-align: inherit;">如果我们查看它（“ </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LazyMemberInfo.Equals（Object）方法</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”）-无论它返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">我们都不会看到任何特别的东西</font><font style="vertical-align: inherit;">，因为它没有关于生成的异常的信息。</font><font style="vertical-align: inherit;">我们将执行代码并查看：</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/8f7/aa4/8e58f7aa4e5a274751cde57da4d9497f.png" alt="图片16"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们可能会有点扭曲，并编写以下代码，并获得有趣的输出： </font></font><br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(typeof(String)); Console.WriteLine(eq);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码执行的结果。 </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/199/292/e74199292d39b2df8a7b205218c9c1fe.png" alt="图片17"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的是，这两个异常都是在同一表达式中生成的。</font><font style="vertical-align: inherit;">让我们看一下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Equals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ LazyMemberInfo that = (LazyMemberInfo)obj; <span class="hljs-comment"><span class="hljs-comment">// Difefrent member types mean different members if (_memberType != that._memberType) { return false; } // if any of the lazy memebers create accessors in a delay-loaded fashion, // we simply compare the creators if ((_accessorsCreator != null) || (that._accessorsCreator != null)) { return object.Equals(_accessorsCreator, that._accessorsCreator); } // we are dealing with explicitly passed accessors in both cases if(_accessors == null || that._accessors == null) { throw new Exception(SR.Diagnostic_InternalExceptionMessage); } return _accessors.SequenceEqual(that._accessors); }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3115将</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ null”传递给“ Equals”方法不应导致“ NullReferenceException”。 LazyMemberInfo.cs 116 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，在这种情况下，分析器花了点时间，因为它为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that._memberType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式</font><font style="vertical-align: inherit;">发出了警告</font><font style="vertical-align: inherit;">。但是，在执行表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（LazyMemberInfo）obj</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时，异常会更早发生</font><font style="vertical-align: inherit;">。我们已经记下了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidCastException非常</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清楚</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">为什么会</font><font style="vertical-align: inherit;">生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？事实是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LazyMemberInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个结构，因此将其取消装箱。的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值拆箱功能，在转弯，导致发生</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException异常</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型。</font><font style="vertical-align: inherit;">注释中也有一些错别字-作者可能应该修复它们。</font><font style="vertical-align: inherit;">作者仍然有明确的异常抛出方法。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四十六期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，我</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">TriState</font></i><font style="vertical-align: inherit;">结构的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Drawing.Common</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">遇到了类似的情况</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ TriState state = (TriState)o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == state._value; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3115将</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ null”传递给“ Equals”方法不应导致“ NullReferenceException”。</font><font style="vertical-align: inherit;">TriState.cs 53 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题与上述情况相同。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第47期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们考虑一下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Text.Json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的几个片段</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还记得我写过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定不能返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吗？</font><font style="vertical-align: inherit;">是时候巩固这些知识了。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (TokenType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.None: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Null: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.True: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.TrueString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.False: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.FalseString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Number: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartArray: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartObject: { <span class="hljs-comment"><span class="hljs-comment">// null parent should have hit the None case Debug.Assert(_parent != null); return _parent.GetRawValueAsString(_idx); } case JsonTokenType.String: return GetString(); case JsonTokenType.Comment: case JsonTokenType.EndArray: case JsonTokenType.EndObject: default: Debug.Fail($"No handler for {nameof(JsonTokenType)}.{TokenType}"); return string.Empty; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乍一看，此方法不会返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但分析器会反其道而行之。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3108</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不建议从“ ToSting（）”方法返回“ null”。</font><font style="vertical-align: inherit;">JsonElement.cs 1460 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器通过调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetString（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">指向该行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们来看看它。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CheckValidInstance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent.GetString(_idx, JsonTokenType.String); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们更深入地了解</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">的重载版本</font><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, JsonTokenType expectedType)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenType == JsonTokenType.Null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们看到该条件之后，立即执行该条件将导致返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值-既来自此方法，也来自</font><font style="vertical-align: inherit;">我们最初考虑的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToString</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四十八期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个有趣的片段：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal JsonPropertyInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePolymorphicProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ JsonPropertyInfo runtimeProperty = CreateProperty(property.DeclaredPropertyType, runtimePropertyType, property.ImplementedPropertyType, property?.PropertyInfo, Type, options); property.CopyRuntimeSettingsTo(runtimeProperty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtimeProperty; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3042</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能为NullReferenceException。 '？。'和“。” 179操作员用于访问“属性”对象JsonClassInfo.AddProperty.cs的成员。179 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CreateProperty</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法时，通过变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多次引用</font><i><font style="vertical-align: inherit;">属性</font></i><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property.DeclaredPropertyType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property.ImplementedPropertyType</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property？.PropertyInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如您所见，在一种情况下，代码作者使用“？”。</font></font>操作员。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果此处位置合适，并且</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值，则此操作符将没有任何帮助，因为</font><font style="vertical-align: inherit;">将通过直接访问生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题49</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Security.Cryptography.Xml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">中找到以下可疑片段</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们已经配对，与多次其他警告一样。</font><font style="vertical-align: inherit;">再次，代码看起来像复制粘贴，您自己比较。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个片段：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.Write( childNode, strBuilder, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第二个片段。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.WriteHash( childNode, hash, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc); } } }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3061</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数'docPos'总是在使用前在方法主体中重写。</font><font style="vertical-align: inherit;">CanonicalXmlDocument.cs 37</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3061</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数'docPos'总是在使用前在方法主体中重写。</font><font style="vertical-align: inherit;">CanonicalXmlDocument.cs 54</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这两种方法中，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docPos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数在使用其值之前</font><i><font style="vertical-align: inherit;">都会</font></i><font style="vertical-align: inherit;">被覆盖。</font><font style="vertical-align: inherit;">因此，用作方法参数的值将被忽略。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行50，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们考虑对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Data.SqlClient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">的代码的几个警告</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBOMNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaType type, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.NullableType == TdsEnums.SQLXMLTYPE) { Type currentType = value.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlString)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlString)value).IsNull &amp;&amp; ((((SqlString)value).Value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((SqlString)value).Value[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currentType == typeof(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) &amp;&amp; (((String)value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((value != null) &amp;&amp; (((<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlXml)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlXml)value).IsNull) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(XmlDataFeed)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Values will eventually converted to unicode string here } } return false; }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对空值进行验证之前，已使用“值”对象。检查行：8696，8708。TdsParser.cs 8696 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器被检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弄糊涂了</font><i><font style="vertical-align: inherit;">！=</font></i><font style="vertical-align: inherit;">在其中一种情况下</font><i><font style="vertical-align: inherit;">为空</font></i><font style="vertical-align: inherit;">。好像它在重构期间丢失了，因为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被多次取消引用。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值-情况不好。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第51期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个错误是来自测试，但对我而言似乎很有趣，因此我决定引用它。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TDSMessageCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQueryResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"state"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"databases"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"db_name"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// SELECT [name], [state] FROM [sys].[databases] WHERE [name] = db_name() { // Delegate to current database response responseMessage = _PrepareDatabaseResponse(session); } .... }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3053</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式过多。检查子字符串“名称”和“ db_name”。 QueryEngine.cs 151 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实是，在这种情况下，子表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowerBatchText.Contains（“ name”）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowerBatchText.Contains（“ db_name”）的组合</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是多余的。确实，如果检查的字符串包含子字符串</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ db_name”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么它也将包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ name”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子字符串。如果字符串不包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ name”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么它也将不包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ db_name”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。结果，结果是检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowerBatchText.Contains（“名称”）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是多余的。如果所检查的字符串不包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ name”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则除非它可以减少评估表达式的数量，否则它是可以的</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行52问题</font></font></b> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">System.Net.Requests</font></i><font style="vertical-align: inherit;">项目</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的代码中的可疑片段</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override PipelineInstruction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipelineCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PipelineEntry entry, ResponseDescription response, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $<span class="hljs-string"><span class="hljs-string">"Command:{entry?.Command} Description:{response?.StatusDescription}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// null response is not expected if (response == null) return PipelineInstruction.Abort; .... if (entry.Command == "OPTS utf8 on\r\n") .... .... }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">验证为空后使用了“入口”对象。检查行：270，227。FtpControlStream.cs 270 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编写插值字符串时，使用诸如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry ?、命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">响应之</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的表达式</font><font style="vertical-align: inherit;">。 '？。'使用运算符代替“。” </font><font style="vertical-align: inherit;">如果任何相应的参数具有</font><i><font style="vertical-align: inherit;">空</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，则</font><font style="vertical-align: inherit;">运算符不会获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。在这种情况下，此技术有效。此外，正如我们从代码中看到的那样，可能</font><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">响应</font></i><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">被拆分（如果</font><i><font style="vertical-align: inherit;">response == null，</font></i><font style="vertical-align: inherit;">则从方法中退出）</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），而没有类似的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条目。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甲作为时，如果结果的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条目</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外沿着下面的代码评估时</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry.Command</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由BE的异常生成意志，一个（带的，不使用“”？'）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，相当详细的代码审查正在等待我们，因此我建议您再休息一下-放松一下，喝点茶或咖啡。</font><font style="vertical-align: inherit;">之后，我将在这里继续。</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/3fc/f07/56a3fcf075284f021a56249627e518bb.png" alt="图片21"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你回来了吗 </font><font style="vertical-align: inherit;">那我们继续吧。</font></font> :) <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第53期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Collections.Immutable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中</font><font style="vertical-align: inherit;">找到一些有趣的东西</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这次我们将对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Collections.Immutable.ImmutableArray &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">进行一些实验</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IStructuralEquatable.Equals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IStructuralComparable.CompareTo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对我们来说特别有意义。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IStructuralEquatable.Equals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下面给出了代码，我建议您尝试自己找出问题所在：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你有事吗 </font><font style="vertical-align: inherit;">如果是-恭喜。</font></font> :) <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在将其验证为null后使用了“我们的”对象。检查行：1212，1204。ImmutableArray_1.cs 1212 </font><font style="vertical-align: inherit;">通过</font><font style="vertical-align: inherit;">最后一个</font><i><font style="vertical-align: inherit;">返回</font></i><font style="vertical-align: inherit;">表达式中</font><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">ours</font></i><font style="vertical-align: inherit;">变量</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用实例</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Equals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">使分析器感到困惑</font><font style="vertical-align: inherit;">，因为它暗示</font><font style="vertical-align: inherit;">此处可能发生</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。分析仪为何如此建议？为了更容易解释，我在下面提供了相同方法的简化代码片段。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { .... } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后的表达式中，我们可以看到，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">来自</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self.array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上面多次执行了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self.array == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查</font><font style="vertical-align: inherit;">。这意味着，</font><font style="vertical-align: inherit;">与</font><i><font style="vertical-align: inherit;">self.array</font></i><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">可以为</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">。至少在理论上。在实践中可以达到这种状态吗？让我们尝试找出答案。为此，我再次引用具有设置关键点的方法的主体。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 Array otherArray = other as Array; if (otherArray == null) // &lt;= 2 { var theirs = other as IImmutableArray; if (theirs != null) // &lt;= 3 { otherArray = theirs.Array; if (self.array == null &amp;&amp; otherArray == null) { return true; } else if (self.array == null) // &lt;= 4 { return false; } } IStructuralEquatable ours = self.array; // &lt;= 5 return ours.Equals(otherArray, comparer); }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键点1. </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self.array == this.array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self = this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。因此，在调用该方法之前，我们需要获取条件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this.array == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重点2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们可以忽略</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这将是获得我们想要的最简单的方法。若要忽略</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们只需要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型或派生</font><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">，而不包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。这样，在使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符之后，将在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otherArray中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入非null引用，</font><font style="vertical-align: inherit;">而我们将忽略第一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重点3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这一点需要更复杂的方法。</font><font style="vertical-align: inherit;">我们绝对需要在第二条</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句（具有条件表达式“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们的！”的那条</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句）中</font><font style="vertical-align: inherit;">退出</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果没有发生，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分支开始执行，则最肯定的是</font><font style="vertical-align: inherit;">由于关键点4 </font><font style="vertical-align: inherit;">，在条件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self.array == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的情况下，我们不会获得所需</font><font style="vertical-align: inherit;">的点5。为避免输入关键点的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句3，必须满足以下条件之一：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值与所述BE </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型一定不能实现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IImmutableArray</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口。</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重点5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self.array == null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值达到这一点</font><font style="vertical-align: inherit;">，则意味着我们已经达到了目标，并且</font><font style="vertical-align: inherit;">将生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们获得以下数据集，这些数据集将引导我们到达所需的位置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this.array-null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二-以下之一：</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型或从其派生的类型；</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型或它的派生类，因此没有实现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IImmutableArray</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口。</font></font></li></ul><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字段，通过以下方式声明：</font></font><br><br><pre> <code class="cpp hljs">internal T[] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImmutableArray &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是结构，因此它具有默认构造函数（不带参数），该默认构造函数将导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段默认采用值，该值为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是我们所需要的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">别忘了我们正在研究接口方法的显式实现，因此，必须在调用之前完成转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以通过三种方式来处理异常。</font><font style="vertical-align: inherit;">我们添加对调试库版本的引用，编写代码，执行并查看会发生什么。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码片段1。</font></font></b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(null, comparer);</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码片段2。</font></font></b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] { }, comparer);</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码片段3。</font></font></b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(typeof(Object), comparer);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这三个代码段的执行结果将是相同的，只是通过不同的输入项数据和执行路径才能实现。 </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/a3b/e8a/13aa3be8a0b68a646aee130773f2c862.png" alt="图片18"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第54期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您没有忘记，我们还有另一种需要抹黑的方法。</font><font style="vertical-align: inherit;">:)但是这一次我们不会详细介绍。</font><font style="vertical-align: inherit;">而且，我们已经从前面的示例中了解了一些信息。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IStructuralComparable.CompareTo(object other, IComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null ^ otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( SR.ArrayInitializedStateNotEqual, nameof(other)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray != null) { IStructuralComparable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.CompareTo(otherArray, comparer); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } throw new ArgumentException(SR.ArrayLengthsNotEqual, nameof(other)); }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在将其验证为null后使用了“我们的”对象。</font><font style="vertical-align: inherit;">检查行：1265、1251。ImmutableArray_1.cs 1265 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，情况与前面的示例非常相似。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们编写以下代码：</font></font><br><br><pre> <code class="cpp hljs">Object other = ....; var comparer = Comparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralComparable)immutableArray).CompareTo(other, comparer);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将尝试查找一些条目数据以达到</font><font style="vertical-align: inherit;">可能发生</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的</font><font style="vertical-align: inherit;">异常的地步</font><font style="vertical-align: inherit;">：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值：</font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new String [] {}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果：</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/d77/08a/eefd7708a187f5060f2074e642f18434.png" alt="图片22"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们再次设法找出此类数据，方法中会发生异常。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第55期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Net。HTTP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侦听器项目中，我偶然发现了几个可疑和非常相似的地方。</font><font style="vertical-align: inherit;">再一次，我对在这里进行的复制粘贴感到震惊。</font><font style="vertical-align: inherit;">由于模式相同，因此我们将看一个代码示例。</font><font style="vertical-align: inherit;">对于其余情况，我将引用分析器警告。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) { NetEventSource.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"buffer.Length:"</span></span> + buffer.Length + <span class="hljs-string"><span class="hljs-string">" size:"</span></span> + size + <span class="hljs-string"><span class="hljs-string">" offset:"</span></span> + offset); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(buffer)); } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证之前，已使用“缓冲区”对象。检查行：51，53。HttpRequestStream.cs 51 </font><font style="vertical-align: inherit;">在条件</font><i><font style="vertical-align: inherit;">缓冲区== null</font></i><font style="vertical-align: inherit;">下</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArgumentNullException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">显然表明</font><font style="vertical-align: inherit;">该变量的</font><i><font style="vertical-align: inherit;">null值</font></i><font style="vertical-align: inherit;">是不可接受的。但是，如果</font><i><font style="vertical-align: inherit;">NetEventSource.IsEnabled</font></i><font style="vertical-align: inherit;">表达式的值为</font><i><font style="vertical-align: inherit;">true</font></i><font style="vertical-align: inherit;">且</font><i><font style="vertical-align: inherit;">buffer</font></i><font style="vertical-align: inherit;"> - </font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">，则在计算</font><i><font style="vertical-align: inherit;">buffer.Length</font></i><font style="vertical-align: inherit;">表达式时，</font><font style="vertical-align: inherit;">将生成</font><i><font style="vertical-align: inherit;">NullReferenceException</font></i><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。如我们所见，我们甚至都无法达到</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，</font><i><font style="vertical-align: inherit;">缓冲区==空</font></i><font style="vertical-align: inherit;">检查。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">针对使用以下模式的其他方法发出的PVS-Studio警告：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证之前，已使用'buffer'对象。</font><font style="vertical-align: inherit;">检查行：49，51。HttpResponseStream.cs 49</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证之前，已使用'buffer'对象。</font><font style="vertical-align: inherit;">检查行：74，75。HttpResponseStream.cs 74</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行56</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Transactions.Local</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中</font><font style="vertical-align: inherit;">也有类似的代码片段</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalTransaction tx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx._outcomeSource._isoLevel == IsolationLevel.Snapshot) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TransactionException.CreateInvalidOperationException( TraceSourceType.TraceSourceLtm, SR.CannotPromoteSnapshot, null, tx == null ? Guid.Empty : tx.DistributedTxId); } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3095</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在验证是否为空之前使用了'tx'对象。检查行：3282，3285。TransactionState.cs 3282 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在特定条件下，作者希望引发</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InvalidOperationException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。在调用用于创建异常对象的方法时，代码作者使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数，将其检查为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以避免</font><font style="vertical-align: inherit;">在评估</font><i><font style="vertical-align: inherit;">tx.DistributedTxId</font></i><font style="vertical-align: inherit;">表达式</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">出现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。具有讽刺意味的是，检查将无济于事，因为在评估</font><i><font style="vertical-align: inherit;">if</font></i><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">的条件时</font><font style="vertical-align: inherit;">，实例字段是通过</font><i><font style="vertical-align: inherit;">tx</font></i><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">访问的</font><font style="vertical-align: inherit;">-</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx._outcomeSource._isoLevel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">System.Runtime.Caching</font></i><font style="vertical-align: inherit;">项目中的</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第57期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cacheMemoryLimitMegabytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cacheMemoryLimit = cacheMemoryLimitMegabytes; cacheMemoryLimit = cacheMemoryLimit &lt;&lt; MEGABYTE_SHIFT; _memoryLimit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// never override what the user specifies as the limit; // only call AutoPrivateBytesLimit when the user does not specify one. if (cacheMemoryLimit == 0 &amp;&amp; _memoryLimit == 0) { // Zero means we impose a limit _memoryLimit = EffectiveProcessMemoryLimit; } else if (cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0) { // Take the min of "cache memory limit" and // the host's "process memory limit". _memoryLimit = Math.Min(_memoryLimit, cacheMemoryLimit); } else if (cacheMemoryLimit != 0) { // _memoryLimit is 0, but "cache memory limit" // is non-zero, so use it as the limit _memoryLimit = cacheMemoryLimit; } .... }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表达式'cacheMemoryLimit！= 0 &amp;&amp; _memoryLimit！= 0'始终为false。 CacheMemoryMonitor.cs 250 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果仔细查看代码，您会注意到以下表达式之一</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-cacheMemoryLimit！= 0 &amp;&amp; _memoryLimit！= 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将始终为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_memoryLimit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值为0（在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">之前设置</font><font style="vertical-align: inherit;">），因此&amp;&amp;运算符的右操作数为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，整个表达式的结果为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第58期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我从</font><font style="vertical-align: inherit;">下面</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Diagnostics.TraceSource</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">引用了可疑的代码片段</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackNode n = _stack.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == null) { base.Pop(); } _stack.Value = n.Prev; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.Value; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3125</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对null进行验证后，使用了'n'对象。检查行：115，111。CorrelationManager.cs 115 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，这是一个有趣的情况。由于检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n == null，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我假设</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是此局部变量的期望值。如果是这样，</font><font style="vertical-align: inherit;">则在访问实例属性</font><i><font style="vertical-align: inherit;">-n.Prev</font></i><font style="vertical-align: inherit;">时将生成</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。如果在这种情况下</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">永远不能为</font><i><font style="vertical-align: inherit;">null</font></i><font style="vertical-align: inherit;">，</font><i><font style="vertical-align: inherit;">那么</font></i><font style="vertical-align: inherit;">将永远不会调用</font><i><font style="vertical-align: inherit;">base.Pop（）</font></i><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">发行59</font></b><font style="vertical-align: inherit;">来自</font><i><font style="vertical-align: inherit;">System.Drawing.Primitives</font></i><font style="vertical-align: inherit;">的有趣代码片段</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目。</font><font style="vertical-align: inherit;">同样，我建议您尝试自己发现问题。</font><font style="vertical-align: inherit;">这是代码：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToHtml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Color c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> colorString = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> colorString; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ColorUtil.IsSystemColor(c)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"activeborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientActiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"activecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.AppWorkspace: colorString = <span class="hljs-string"><span class="hljs-string">"appworkspace"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Desktop: colorString = <span class="hljs-string"><span class="hljs-string">"background"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDark: colorString = <span class="hljs-string"><span class="hljs-string">"buttonshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlText: colorString = <span class="hljs-string"><span class="hljs-string">"buttontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"captiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GrayText: colorString = <span class="hljs-string"><span class="hljs-string">"graytext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HotTrack: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Highlight: colorString = <span class="hljs-string"><span class="hljs-string">"highlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuHighlight: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HighlightText: colorString = <span class="hljs-string"><span class="hljs-string">"highlighttext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"inactiveborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientInactiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaptiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Info: colorString = <span class="hljs-string"><span class="hljs-string">"infobackground"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InfoText: colorString = <span class="hljs-string"><span class="hljs-string">"infotext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuBar: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Menu: colorString = <span class="hljs-string"><span class="hljs-string">"menu"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuText: colorString = <span class="hljs-string"><span class="hljs-string">"menutext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ScrollBar: colorString = <span class="hljs-string"><span class="hljs-string">"scrollbar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDarkDark: colorString = <span class="hljs-string"><span class="hljs-string">"threeddarkshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLightLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonhighlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Window: colorString = <span class="hljs-string"><span class="hljs-string">"window"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowFrame: colorString = <span class="hljs-string"><span class="hljs-string">"windowframe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowText: colorString = <span class="hljs-string"><span class="hljs-string">"windowtext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsNamedColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == Color.LightGray) { <span class="hljs-comment"><span class="hljs-comment">// special case due to mismatch between Html and enum spelling colorString = "LightGrey"; } else { colorString = c.Name; } } else { colorString = "#" + cRToString("X2", null) + cGToString("X2", null) + cBToString("X2", null); } return colorString; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，好吧，只是在开玩笑...还是您还找到了什么？</font><font style="vertical-align: inherit;">无论如何，让我们减少代码以清楚地说明问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是短代码版本：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3139</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个或更多案例分支执行相同的操作。</font><font style="vertical-align: inherit;">ColorTranslator.cs 302 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不能肯定地说，但是我认为这是一个错误。</font><font style="vertical-align: inherit;">在其他情况下，当开发人员想要为多个枚举数返回相同的值时，他会依次使用多个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小写</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我认为，在此处复制粘贴很容易犯错。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们深入一点。</font><font style="vertical-align: inherit;">要从</font><font style="vertical-align: inherit;">分析的</font><i><font style="vertical-align: inherit;">ToHtml</font></i><font style="vertical-align: inherit;">方法中</font><font style="vertical-align: inherit;">获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ buttonface”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，可以将以下值之一传递给它（预期）：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemColors.Control</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemColors.ControlLight</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们检查每种颜色的ARGB值，我们将看到以下内容： </font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemColors.Control</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（255，240，240，240）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemColors.ControlLight-（255，227，227，227）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们</font><font style="vertical-align: inherit;">对接收到的值（</font><i><font style="vertical-align: inherit;">“ buttonface”</font></i><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">调用逆转换方法</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FromHtml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则将获得</font><font style="vertical-align: inherit;">颜色</font><i><font style="vertical-align: inherit;">Control（</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">255、240、240、240 </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们可以</font><font style="vertical-align: inherit;">从</font><i><font style="vertical-align: inherit;">FromHtml</font></i><font style="vertical-align: inherit;">获取</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlLight</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色</font><font style="vertical-align: inherit;">吗？</font><font style="vertical-align: inherit;">是的 </font><font style="vertical-align: inherit;">此方法包含颜色表，该表是构成颜色的基础（在这种情况下）。</font><font style="vertical-align: inherit;">该表的初始化程序包含以下行：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">s_htmlSysColorTable[<span class="hljs-string"><span class="hljs-string">"threedhighlight"</span></span>] = ColorUtil.FromKnownColor(KnownColor.ControlLight);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FromHtml</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回</font><i><font style="vertical-align: inherit;">“ threedhighlight”</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlLight（</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">255、227、227、227 </font></i><i><font style="vertical-align: inherit;">）</font></i><font style="vertical-align: inherit;">颜色</font><font style="vertical-align: inherit;">。我认为，这正是在</font><i><font style="vertical-align: inherit;">KnownColor.ControlLight情况下</font></i><font style="vertical-align: inherit;">应该使用的内容</font><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">发行60，</font></b><font style="vertical-align: inherit;">我们将从</font><i><font style="vertical-align: inherit;">System.Text.RegularExpressions</font></i><font style="vertical-align: inherit;">项目中</font><font style="vertical-align: inherit;">检查出一些有趣的警告</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <b><font style="vertical-align: inherit;"></font></b> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextposDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remaining; sb.Append(runtextpos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) sb.Append(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> - sb.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runtextpos &gt; runtextbeg) sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - <span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sb.Append(<span class="hljs-string"><span class="hljs-string">'^'</span></span>); sb.Append(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); remaining = runtextend - runtextpos; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = runtextpos; i &lt; runtextend; i++) { sb.Append(RegexCharClass.CharDescription(runtext[i])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { sb.Length = <span class="hljs-number"><span class="hljs-number">61</span></span>; sb.Append(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sb.Append(<span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3137</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配了“剩余”变量，但在功能结束时未使用。 RegexRunner.cs 612 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本地</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剩余</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量中</font><font style="vertical-align: inherit;">写入了一个值</font><font style="vertical-align: inherit;">，但该方法不再使用它。也许删除了一些使用它的代码，但是变量本身被遗忘了。或存在严重错误，并且必须以某种方式使用此变量。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第61期</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last)</span></span></span><span class="hljs-function"> </span></span>{ _rangelist.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingleRange(first, last)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_canonical &amp;&amp; _rangelist.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; first &lt;= _rangelist[_rangelist.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Last) { _canonical = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3063</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件表达式的一部分被评估为：_rangelist.Count&gt;0。RegexCharClass.cs 523 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器正确地指出，表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_rangelist.Count&gt; 0的一部分</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将始终为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果执行此代码。即使此列表（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_rangelist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指向的</font><font style="vertical-align: inherit;">列表</font><font style="vertical-align: inherit;">）为空，在添加元素</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_rangelist.Add（....）之后，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它也不相同。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行第62期</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看一下</font><i><font style="vertical-align: inherit;">System.Drawing.Common</font></i><font style="vertical-align: inherit;">和</font><i><font style="vertical-align: inherit;">System.Transactions.Local</font></i><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">中的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3128</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诊断规则</font><font style="vertical-align: inherit;">警告</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-class"> :</span></span> IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object _item; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _startIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _endIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ _array = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; _startIndex = startIndex; _endIndex = _index + count; _index = _startIndex; } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3128</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在构造器中初始化“ _index”字段之前，必须先使用该字段。 PrinterSettings.Windows.cs 1679 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_endIndex</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段时，</font><font style="vertical-align: inherit;">将使用</font><font style="vertical-align: inherit;">另一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段，该字段在使用时具有标准值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">default（int）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段是初始化的下方。如果不是错误</font><font style="vertical-align: inherit;">，则此表达式中应省略</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量，以免造成混淆。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第63期</font></font></b> <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _timerInterval; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a timer that is initially disabled by specifing // an Infinite time to the first interval _timer = new Timer(new TimerCallback(ThreadTimer), null, Timeout.Infinite, _timerInterval); .... // Store the timer interval _timerInterval = 1 &lt;&lt; TransactionTable.timerInternalExponent; .... } }</span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3128</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在构造器中初始化“ _timerInterval”字段之前，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;">请先使用</font></u></a><font style="vertical-align: inherit;">该字段。 TransactionTable.cs 151 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况与以上类似。首先，使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_timerInterval</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">（虽然它仍然是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认值（int）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）来初始化</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_timer。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有在此之后，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_timerInterval</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段本身才会被初始化。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题64问题</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诊断规则发出了下一个警告，该规则仍在开发中。没有文档或最终信息，但是在它的帮助下我们已经找到了几个有趣的片段。同样，这些片段看起来像</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy-paste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们将仅考虑一个代码片段。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessNotifyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... WeakReference reference = (WeakReference)( LdapConnection.s_handleTable[referralFromConnection]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reference != null &amp;&amp; reference.IsAlive &amp;&amp; null != ((LdapConnection)reference.Target)._ldapHandle) { .... } .... }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告（存根）：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VXXXX TODO_MESSAGE。 LdapSessionOptions.cs 974 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技巧是，在检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference.IsAlive之后</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可能会收集垃圾，而</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WeakReference</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指向</font><font style="vertical-align: inherit;">的对象</font><font style="vertical-align: inherit;">将被垃圾收集。在这种情况下，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。结果，当访问实例字段</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_ldapHandle时</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">将发生</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NullReferenceException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">的异常</font><font style="vertical-align: inherit;">。 Microsoft自己使用支票IsAlive警告此陷阱。 docs.microsoft.com-“ </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WeakReference.IsAlive属性</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”的</font><font style="vertical-align: inherit;">引文</font><font style="vertical-align: inherit;">：</font></font><i>Because an object could potentially be reclaimed for garbage collection immediately after the IsAlive property returns true, using this property is not recommended unless you are testing only for a false return value.</i> <br><br><h2> Summary on Analysis </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分析过程中是否找到了所有这些错误和有趣的地方？当然不是！查看分析结果时，我正在彻底检查警告。随着数量的增加，而且很显然有足够的篇幅来撰写一篇文章，我正在浏览结果，试图仅选择对我而言最有趣的那些。当我到达最后一个（最大的原木）时，我只能查看警告，直到发现异常情况为止。因此，如果您四处挖掘，我相信您会找到更多有趣的地方。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，我几乎忽略了所有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3022</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3063</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告。可以这么说，如果我遇到过这样的代码：</font></font><br><br><pre> <code class="cpp hljs">String str = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == null) ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我会忽略它，因为我想描述许多其他有趣的地方。被警告，对有不安全使用的锁</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock语句</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与锁定</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的这</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3090</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;不安全事件调用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-V3083</font></font></u></a> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象时，其类型都实现</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了IDisposable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但对于其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的Dispose</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关闭</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不叫- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3072</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和广告商选择相似的诊断等等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我也没有注意到用测试编写的问题。至少，我尝试过，但可能会不小心服用一些。除了几个我发现足以引起人们注意的有趣地方。但是测试代码也可能包含错误，由于这些错误，测试将无法正常工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，仍有许多事情需要调查-但我无意标记</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有发现的问题</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码的质量对我来说似乎并不平衡。一些项目非常干净，其他项目包含可疑的地方。也许我们可能希望有一个干净的项目，尤其是涉及最常用的库类时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">综上所述，我们可以说该代码质量很高，因为它的数量很多。但是，正如本文所建议的那样，这里有一些阴暗的角落。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，这个规模的项目对分析仪也是一个很好的测试。</font><font style="vertical-align: inherit;">我设法找到了一些我选择要研究和纠正的错误/怪异的警告。</font><font style="vertical-align: inherit;">因此，作为分析的结果，我设法找到了必须在PVS-Studio本身上进行工作的地方。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您通过阅读整篇文章到达了这个地方-让我握手！</font><font style="vertical-align: inherit;">希望我能够向您展示有趣的错误并证明静态分析的好处。</font><font style="vertical-align: inherit;">如果您为自己学习了一些新知识，那将使您编写更好的代码-我将倍加高兴。</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/dbc/f2d/6efdbcf2d984bef000cf44face04c6a4.png" alt="图片23"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论如何，静态分析的一些帮助不会受到损害，因此建议您</font><font style="vertical-align: inherit;">在项目上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试使用PVS-Studio</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并查看使用它可以发现哪些有趣的地方。</font><font style="vertical-align: inherit;">如果您有任何疑问，或者您只想分享发现的有趣片段，请随时发送电子邮件至</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">support@viva64.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最好的问候！ </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS for .NET Core库开发人员 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常感谢您所做的一切！</font><font style="vertical-align: inherit;">干得好！</font><font style="vertical-align: inherit;">希望本文能帮助您使代码更好。</font><font style="vertical-align: inherit;">记住，我还没有写所有可疑的地方，所以您最好自己使用分析仪检查项目。</font><font style="vertical-align: inherit;">这样，您将能够详细调查所有警告。</font><font style="vertical-align: inherit;">而且，使用它会比使用简单的文本日志/错误列表（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在这里更详细地介绍过</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）更方便。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463535/">https://habr.com/ru/post/zh-CN463535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463513/index.html">2019年最佳Web开发框架</a></li>
<li><a href="../zh-CN463515/index.html">使用HTMS API来处理关系网络数据库</a></li>
<li><a href="../zh-CN463525/index.html">硒，硒化物，硒化物，硒化物……这是什么意思？</a></li>
<li><a href="../zh-CN463527/index.html">弹出！ 在iOS上转录</a></li>
<li><a href="../zh-CN463533/index.html">每个开发人员从一开始就应该知道什么</a></li>
<li><a href="../zh-CN463537/index.html">通过PVS-Studio静态分析器验证.NET Core库的源代码</a></li>
<li><a href="../zh-CN463541/index.html">培训Cisco 200-125 CCNA v3.0。 第17天。CCNA课程摘要和路线图</a></li>
<li><a href="../zh-CN463551/index.html">如何与员工联系并组织大型IT公司的工作流程</a></li>
<li><a href="../zh-CN463553/index.html">“你是谷歌人吗？” 或我们录用时做的5件事（但不再）</a></li>
<li><a href="../zh-CN463559/index.html">培训Cisco 200-125 CCNA v3.0。 第18天。路由基础</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>