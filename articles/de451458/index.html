<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 🧝🏻 🧚🏾 Wir brauen einen Spielentwickler. Teil 1 👨🏼‍🚀 👃🏽 🤟🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Die Geschichte begann mit einem Blockchain-basierten Hackathon. Zu Beginn der Veranstaltung traf ich einen Mann, der Brettspiele als Hobb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir brauen einen Spielentwickler. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Einführung</font> </h2><br>  Die Geschichte begann mit einem Blockchain-basierten Hackathon.  Zu Beginn der Veranstaltung traf ich einen Mann, der Brettspiele als Hobby entwickelt (ich war beim Spieltest eines solchen Spiels). Wir haben uns zusammengetan und ein Team gefunden, mit dem sie über das Wochenende ein einfaches strategisches Spiel „geblendet“ haben.  Der Hackathon ging vorbei, aber die Begeisterung blieb.  Und wir hatten die Idee eines Multiplayer-Kartenspiels über Glück, die Weltgemeinschaft und Wahlen. <br><br>  In der Artikelserie werden wir unseren Weg zur Erstellung eines Spiels reflektieren, mit einer Beschreibung des Rakes, auf den wir bereits getreten sind, und auf dem wir vorwärts gehen werden. <br clear="all">  Unter dem Schnitt wird sein: <br><br><ul><li>  Spielübersicht </li><li> Wie die Entscheidung getroffen wurde, was im Backend zu tun ist.  Wo wird es „leben“, damit es sich in der Entwicklungsphase nicht bezahlt macht? </li><li>  Erste Schritte in der Entwicklung - Spielerauthentifizierung und Organisation des Matchmaking </li><li>  Weitere Pläne </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">Worum geht es in dem Spiel?</font> </h2><br>  Die Menschheit hat die Weltkriege, die Erschöpfung der Ressourcen und den ständigen Wettbewerb satt.  Die wichtigsten Fraktionen waren sich einig, moderne Technologie einzusetzen, um eine einzige Führung auszuwählen.  Zum festgelegten Zeitpunkt muss die Weltwählerschaft über die Wahl eines Bruchteils entscheiden, der den Planeten für das nächste Jahrtausend regieren wird.  Schlüsselfraktionen führen einen „ehrlichen“ Machtkampf.  In einer Spielsitzung repräsentiert jeder Spieler einen Bruchteil. <br><br>  In diesem Kartenspiel geht es um Wahlen.  Jede Fraktion hat ein Budget für die Durchführung des Wahlkampfs, Einnahmequellen, die das Budget erhöhen, und Startstimmen.  Zu Beginn des Spiels wird das Deck mit den Aktionskarten gemischt und jedem Teilnehmer werden 4 Karten ausgegeben.  In jeder Runde können die Spieler bis zu zwei Spielaktionen ausführen.  Um die Karte zu verwenden, legt der Spieler sie auf den Tisch und bestimmt gegebenenfalls das Ziel und zieht die Kosten für die Verwendung der Karte vom Budget ab.  Nach dem Ende der Runde kann der Spieler nur eine der nicht verwendeten Karten behalten.  Zu Beginn jeder Runde erhalten die Spieler Karten vom Stapel, so dass jeder Spieler zu Beginn jeder Runde 4 Aktionskarten zur Hand hat. <br><br>  Am Ende der Runden 3, 6 und 9 wird der Spieler mit der geringsten Stimmenzahl aus dem Spiel entfernt.  Wenn mehrere Spieler die gleiche Mindestanzahl an Stimmen haben, werden alle Spieler mit diesem Ergebnis aus dem Spiel ausgeschlossen.  Die Stimmen dieser Spieler gehen in den allgemeinen Pool der Wähler. <br><br>  Am Ende der 12. Runde ist der Gewinner derjenige mit den meisten Stimmen. <br><br><h2>  <font color="#292e5b">Auswahl eines Tools für das Backend</font> </h2><br>  Aus der Beschreibung des Spiels folgt: <br><br><ol><li>  Dies ist Multiplayer </li><li>  Es ist notwendig, Spieler irgendwie zu identifizieren und Konten zu verwalten </li><li>  Das Vorhandensein einer sozialen Komponente würde dem Spiel zugute kommen - Freunde, Gemeinschaften (Clans), Chats, Erfolge (Erfolge) </li><li>  Bestenlisten und Matchmaking-Funktionen sind erforderlich. </li><li>  Die Funktionen zur Turnierverwaltung werden in Zukunft nützlich sein </li><li>  Da es sich bei dem Spiel um ein Kartenspiel handelt, müssen Sie den Kartenkatalog verwalten und möglicherweise Karten speichern, die dem Spieler zur Verfügung stehen, sowie kompilierte Decks </li><li>  In Zukunft kann eine In-Game-Wirtschaft erforderlich sein, einschließlich In-Game-Währung und Austausch virtueller Güter (Karten). </li></ol><br>  Als ich mir die Liste der Bedürfnisse ansah, kam ich sofort zu dem Schluss, dass es keinen Sinn macht, in der Anfangsphase ein eigenes Backend zu erstellen, und ging zu Google, was andere Optionen sind.  Daher fand ich heraus, dass es spezielle Cloud-Gaming-Backends gibt, unter denen sich PlayFab (von Microsoft gekauft) und GameSparks (von Amazon gekauft) hervorheben. <br><br>  Im Allgemeinen sind sie funktional ähnlich und decken die Grundbedürfnisse ab.  Darüber hinaus ist ihre interne Architektur sehr unterschiedlich, dieselben Aufgaben werden etwas unterschiedlich gelöst und explizite Entsprechungen in den Merkmalen sind schwer nachzuvollziehen.  Nachfolgend finden Sie die positiven und negativen Merkmale jeder Plattform sowie Überlegungen zum Thema Ihrer Wahl. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Positive Eigenschaften: <br><br><ul><li>  Konten aus verschiedenen Spielen werden zu einem Hauptkonto zusammengefasst </li><li>  Die Gaming-Wirtschaft wird ohne eine einzige Codezeile beschrieben, einschließlich der Preisgestaltung für ein separates virtuelles Geschäft </li><li>  Freundliche Benutzeroberfläche </li><li>  Microsoft erwirbt Produkt nach der Akquisition </li><li>  Die Betriebskosten für die Produktion im Indie Studio-Abonnement betragen 99 USD (bis zu 100.000 MAU). Wenn Sie zum Professional 1k MAU-Abonnement wechseln, kosten Sie 8 USD (Mindestkonto 300 USD). </li></ul><br>  Negative Merkmale: <br><br><ul><li>  Die Speicherung von Spieldaten ist streng begrenzt, z. B. in einem kostenlosen Abonnement zum Speichern von Daten für eine bestimmte Spielsitzung (wenn ich alles richtig verstehe, werden dafür Entitätsgruppen verwendet). Es sind 3 Slots mit jeweils 500 Byte verfügbar </li><li>  Um den Mehrspielermodus zu organisieren, müssen Sie Server von Drittanbietern verbinden, die Ereignisse von Clients verarbeiten und die Spielelogik berechnen.  Dies ist entweder Photon auf Ihrer Hardware oder Azure Thunderhead, und Sie müssen nicht nur den Server organisieren, sondern auch Ihr Abonnement auf mindestens Indie Studio aktualisieren </li><li>  Es ist notwendig zu ertragen, dass der Cloud-Code ohne automatische Vervollständigung und es keine Möglichkeit gibt, in Module zu brechen (oder nicht gefunden?) </li><li>  Es gibt keinen normalen Debugger. Sie können nur Protokolle in CloudScript schreiben und anzeigen </li></ul><br><h3>  <font color="#9cc2ce">Gamesparks</font> </h3><br>  Positive Eigenschaften: <br><br><ul><li>  Speicherung von Spieldaten.  Es gibt nicht nur viele Orte, an denen Sie Daten speichern können (allgemeine Spielmetadaten, virtuelle Güter, Spielerprofil, Mehrspielersitzungen usw.), sondern die Plattform bietet auch eine vollwertige Datenbank als Service, die an nichts gebunden ist. Darüber hinaus sind sowohl MongoDB als auch Redis für verschiedene Datentypen sofort verfügbar.  In der Entwicklungsumgebung können Sie 10 MB speichern, im Kampf 10 GB </li><li>  Multiplayer ist in einem kostenlosen Abonnement (Entwicklung) mit einem Limit von 10 gleichzeitigen Verbindungen und 10 Anforderungen pro Sekunde verfügbar </li><li>  Bequeme Arbeit mit CloudCode, einschließlich eines integrierten Tools zum Testen und Debuggen (Test Harness) </li></ul><br>  Negative Merkmale: <br><br><ul><li>  Das Gefühl, dass seit dem Kauf durch Amazon (Winter 2018) das Tool stagniert hat, gibt es keine Innovationen </li><li>  Nach der Übernahme von Amazon verschlechterten sich die Tarife erneut, und früher war es möglich, bis zu 10.000 MAU kostenlos in der Produktion zu verwenden </li><li>  Die Produktionsbetriebskosten beginnen bei 300 USD (Standardabonnement). </li></ul><br><h3>  <font color="#9cc2ce">Reflexionen</font> </h3><br>  Zuerst müssen Sie das Konzept des Spiels überprüfen.  Zu diesem Zweck möchte ich einen Prototyp aus Stöcken und Klebeband ohne Geldinvestitionen bauen und mit dem Testen der Spielmechanik beginnen.  Daher möchte ich bei der Auswahl zunächst die Möglichkeit eröffnen, einen Mechaniker mit einem kostenlosen Abonnement zu entwickeln und zu testen. <br>  GameSparks erfüllt dieses Kriterium, PlayFab jedoch nicht, da Sie einen Server benötigen, der die Ereignisse von Spieleclients verarbeitet, und ein Abonnement auf Indie-Studio-Ebene (99 US-Dollar). <br><br>  Gleichzeitig akzeptiere ich das Risiko, dass Amazon keine GameSparks entwickelt, was bedeutet, dass es "sterben" kann.  Angesichts dieser und immer noch der Betriebskosten in der Produktion denke ich an die potenzielle Notwendigkeit, entweder auf eine andere Plattform oder in mein eigenes Backend zu wechseln. <br><br><h2>  <font color="#292e5b">Erste Schritte in der Entwicklung</font> </h2><br><h3>  <font color="#9cc2ce">Verbindung und Authentifizierung</font> </h3><br>  Die Wahl fiel also auf GameSparks als Backend in der Prototyping-Phase.  Der erste Schritt besteht darin, zu lernen, wie Sie eine Verbindung zur Plattform herstellen und den Player authentifizieren.  Ein wichtiger Punkt ist, dass der Benutzer unmittelbar nach der Installation des Spiels ohne Registrierung und SMS spielen kann.  Zu diesem Zweck bietet GameSparks die Möglichkeit, ein anonymes Profil durch Aufrufen der DeviceAuthenticationRequest-Methode zu erstellen. Später können Sie auf der Grundlage eines anonymen Profils ein vollwertiges Profil erstellen, indem Sie beispielsweise eine Verbindung mit Ihrem Google-Konto herstellen. <br><br>  Da ich eine Gehirn-TDD habe, habe ich zunächst einen Test erstellt, um den Client mit dem Spiel zu verbinden.  Da CloudCode in Zukunft in JS geschrieben werden muss, werde ich Integrationstests in JS mit mocha.js und chai.js durchführen.  Der erste Test verlief wie folgt: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Standardmäßig beträgt das Timeout in mocha.js 2 Sekunden. Ich mache es sofort endlos, da es sich bei den Tests um Integration handelt.  Im Test erstelle ich einen Spielclient, der noch nicht implementiert wurde, überprüfe, ob keine Verbindung zum Server besteht, rufe den Befehl zum Herstellen einer Verbindung zum Backend auf und überprüfe, ob der Client erfolgreich eine Verbindung hergestellt hat. <br><br>  Damit der Test grün wird, müssen Sie das GameSparks JS SDK herunterladen und zum Projekt hinzufügen, seine Abhängigkeiten (crypto-js und ws) verbinden und natürlich GameClientModule implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  Bei der Startimplementierung des Spielclients werden die Schlüssel, die für die technische Autorisierung zum Herstellen einer Verbindung aus der Clientanwendung erforderlich sind, aus der Konfiguration gelesen.  Die verbundene Methode umschließt dasselbe Feld aus dem SDK.  Das Wichtigste, was bei der Verbindungsmethode passiert, ist, dass sie ein Versprechen mit Rückrufen für eine erfolgreiche Verbindung oder einen Fehler zurückgibt und den onMessage-Handler an denselben Rückruf bindet.  onMessage fungiert vom Backend aus als Nachrichtenverarbeitungsmanager. Lassen Sie es jetzt Nachrichten in der Konsole protokollieren. <br><br>  Es scheint, dass die Arbeit abgeschlossen ist, aber der Test bleibt rot.  Es stellt sich heraus, dass das GameSparks JS SDK nicht mit node.js funktioniert. Ihnen fehlt der Browserkontext.  Lassen Sie ihn denken, dass der Knoten Chrome auf der Mohnblume ist.  Wir gehen zu gamesparks.js und fügen ganz am Anfang hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  Der Test wurde grün und ging weiter. <br><br>  Wie ich bereits geschrieben habe, sollte ein Spieler in der Lage sein, sofort mit dem Spielen zu beginnen, sobald er das Spiel betritt, während ich anfangen möchte, Analysen in Aktivitäten zu sammeln.  Dazu binden wir entweder an die Gerätekennung oder an eine zufällig generierte Kennung.  Überprüfen Sie, ob dies ein solcher Test ist: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  Ich habe mich entschlossen, sofort 2 Clients zu überprüfen, um sicherzustellen, dass jeder Client sein eigenes Profil im Backend erstellt.  Dazu benötigt der Spielclient eine Methode, mit der Sie eine bestimmte Kennung außerhalb von GameSparks übertragen und dann überprüfen können, ob der Client das gewünschte Spielerprofil kontaktiert hat.  Im Voraus erstellte Profile auf dem GameSparks-Portal. <br><br>  Für die Implementierung in GameClient fügen Sie Folgendes hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  Bei der Implementierung wird eine DeviceAuthenticationRequest-Anforderung gesendet, die Kennung des Spielers aus der Antwort empfangen und in die Eigenschaft des Clients gestellt.  In einer separaten Methode schickte der Helfer sofort Anfragen mit einem Wrapper in einem Promis an GameSparks. <br><br>  Beide Tests sind grün, es bleibt noch das Schließen der Verbindung und des Refaktors hinzuzufügen. <br>  In GameClient habe ich eine Methode hinzugefügt, die die Verbindung zum Server schließt (trennen) und connectAsAnonymous, indem connect und authWithCustomId kombiniert werden.  Einerseits verstößt connectAsAnonymous gegen das Prinzip der Einzelverantwortung, scheint aber nicht zu verletzen ... Gleichzeitig erhöht es die Benutzerfreundlichkeit, da in Tests häufig die Authentifizierung von Clients erforderlich ist.  Was denkst du darüber? <br><br>  In Tests fügte er einen Factory-Methoden-Helfer hinzu, der eine neue Instanz des Spiel-Clients erstellt und das Array der erstellten Clients erweitert.  Im speziellen Mokka-Handler rufe ich nach jedem Test für Clients im Array die Trennungsmethode auf und lösche dieses Array.  Ich mag "magische Zeichenfolgen" im Code noch nicht, daher habe ich ein Wörterbuch mit benutzerdefinierten Bezeichnern hinzugefügt, die in den Tests verwendet wurden. <br><br>  Der endgültige Code kann im Repository angezeigt werden, ein Link, den ich am Ende des Artikels geben werde. <br><br><h3>  <font color="#9cc2ce">Organisation der Spielsuche (Matchmaking)</font> </h3><br>  Ich starte die Matchmaking-Funktion, die für den Mehrspielermodus sehr wichtig ist.  Dieses System beginnt zu funktionieren, wenn wir in einem Spiel auf die Schaltfläche „Spiel suchen“ klicken.  Sie nimmt entweder Rivalen oder Teamkollegen oder beide auf (je nach Spiel).  In solchen Systemen hat jeder Spieler in der Regel einen numerischen Indikator MMR (Match Making Ratio) - eine persönliche Bewertung des Spielers, mit der andere Spieler mit den gleichen Fähigkeiten ausgewählt werden. <br><br>  Um diese Funktionalität zu testen, habe ich folgenden Test entwickelt: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Drei Clients sind mit dem Spiel verbunden (in Zukunft ist dies ein notwendiges Minimum, um einige Szenarien zu überprüfen) und für die Suche nach dem Spiel registriert.  Nach der Registrierung des 3. Spielers auf dem Server wird eine Spielsitzung gebildet, und die Spieler müssen eine Verbindung herstellen.  Gleichzeitig ändert sich der Status der Clients und der Kontext der Spielsitzung mit derselben Kennung wird angezeigt. <br><br>  Bereiten Sie zuerst das Backend vor.  In GameSparks gibt es ein vorgefertigtes Tool zum Anpassen der Suche nach Spielen, das unter dem Pfad „Konfigurator-&gt; Übereinstimmungen“ verfügbar ist.  Ich erstelle eine neue und fahre mit dem Setup fort.  Zusätzlich zu den Standardparametern wie Code, Name und Beschreibung des Spiels wird die minimale und maximale Anzahl von Spielern angegeben, die für einen benutzerdefinierten Spielmodus erforderlich sind.  Ich werde dem erstellten Match den Code "StandardMatch" zuweisen und die Anzahl der Spieler von 2 bis 3 angeben. <br><br>  Jetzt müssen Sie die Regeln für die Auswahl der Spieler im Abschnitt „Schwellenwerte“ konfigurieren.  Für jeden Schwellenwert werden der Zeitpunkt seiner Aktion, der Typ (absolut, relativ und in Prozent) und die Grenzen angegeben. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Angenommen, ein Spieler mit einer MMR von 19 beginnt mit der Suche. Im obigen Beispiel werden in den ersten 10 Sekunden andere Spieler mit einer MMR von 19 bis 21 ausgewählt. Wenn die Spieler nicht ausgewählt werden können, wird der zweite Suchrand aktiviert, wodurch der Suchbereich für die nächsten 20 Sekunden von 16 erweitert wird ( 19-3) bis 22 (19 + 3).  Als nächstes wird der dritte Schwellenwert aufgenommen, innerhalb dessen eine Suche für 30 Sekunden im Bereich von 14 (19-25%) bis 29 (19 + 50%) durchgeführt wird, während das Spiel als abgeschlossen gilt, wenn die erforderliche Mindestanzahl von Spielern angesammelt wurde (Min. Akzeptieren) Spieler). <br><br>  Tatsächlich ist der Mechanismus komplizierter, da er die MMR aller Spieler berücksichtigt, die es geschafft haben, an einem bestimmten Spiel teilzunehmen.  Ich werde diese Details analysieren, wenn es an der Zeit ist, den Bewertungsmodus des Spiels festzulegen (nicht in diesem Artikel).  Für den Standardspielmodus, in dem ich MMR noch nicht verwenden möchte, benötige ich nur einen Schwellenwert. <br><br>  Wenn alle Spieler ausgewählt wurden, müssen Sie eine Spielsitzung erstellen und die Spieler damit verbinden.  In GameSparks ist die Spielsitzungsfunktion die „Herausforderung“.  Als Teil dieser Entität werden Spielsitzungsdaten gespeichert und Nachrichten zwischen Spielclients ausgetauscht.  Um einen neuen Herausforderungstyp zu erstellen, müssen Sie dem Pfad „Konfigurator-&gt; Herausforderungen“ folgen.  Dort füge ich einen neuen Typ mit dem Code "StandardChallenge" hinzu und gebe an, dass diese Art von Spielsitzung rundenbasiert ist, d. H.  Spieler wechseln sich ab, nicht gleichzeitig.  Gleichzeitig übernimmt GameSparks die Kontrolle über die Reihenfolge der Züge. <br><br>  Damit sich ein Client registrieren kann, um nach einem Spiel zu suchen, können Sie eine Anfrage vom Typ MatchmakingRequest verwenden, die ich jedoch nicht empfehlen würde, da der MMR-Wert des Spielers als einer der Parameter erforderlich ist.  Dies kann zu Betrug seitens des Spielclients führen, und der Client sollte keine MMR kennen, dies ist ein Backend-Geschäft.  Um mich korrekt für die Spielsuche zu registrieren, erstelle ich ein beliebiges Ereignis vom Client.  Dies erfolgt im Abschnitt „Konfigurator-&gt; Ereignisse“.  Ich rufe das Ereignis FindStandardMatch ohne Attribute auf.  Jetzt müssen Sie die Reaktion auf dieses Ereignis konfigurieren. Dazu gehe ich zum Abschnitt "Konfigurator-&gt; Cloud-Code" des Cloud-Codes. Ich schreibe den folgenden Handler für FindStandardMatch im Abschnitt "Ereignisse": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Dieser Code registriert einen Spieler in StandardMatch mit einem MMR von 0, sodass alle Spieler, die für die Suche nach einem Standardspiel registriert sind, zum Erstellen einer Spielsitzung geeignet sind.  Bei der Auswahl eines Bewertungsspiels kann auf die privaten Daten des Spielerprofils zurückgegriffen werden, um die MMR dieser Art von Spiel zu erhalten. <br><br>  Wenn genügend Spieler vorhanden sind, um eine Spielsitzung zu starten, sendet GameSparks eine MatchFoundMessage-Nachricht an alle ausgewählten Spieler.  Hier können Sie automatisch eine Spielsitzung erstellen und Spieler hinzufügen.  Fügen Sie dazu unter „User Messages-&gt; MatchFoundMessage“ den folgenden Code hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  Der Code überprüft zunächst, ob es sich um den ersten Spieler auf der Teilnehmerliste handelt.  Als nächstes wird im Namen des ersten Spielers eine Instanz von StandardChallenge erstellt und die verbleibenden Spieler werden eingeladen.  Eingeladene Spieler erhalten eine ChallengeIssuedMessage-Nachricht.  Hier können Sie sich ein Verhalten vorstellen, wenn eine Einladung zur Teilnahme am Spiel auf dem Client angezeigt wird und eine Bestätigung durch Senden von AcceptChallengeRequest erfordert, oder Sie können die Einladung im stillen Modus annehmen.  Also werde ich es tun. Dazu füge ich unter "User Messages-&gt; ChallengeIssuedMessage" den folgenden Code hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  Im nächsten Schritt sendet GameSparks das ChallengeStartedMessage-Ereignis.  Der globale Handler dieses Ereignisses ("Globale Nachrichten-&gt; ChallengeStartedMessage") ist ein idealer Ort zum Initialisieren einer Spielsitzung. Ich werde mich bei der Implementierung der Spielelogik darum kümmern. <br><br>  Es ist Zeit für die Client-Anwendung.  Änderungen im Client-Modul: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  In Übereinstimmung mit dem Test wurden einige Felder auf dem Client-Status und der Herausforderung angezeigt.  Die onMessage-Methode hat ein aussagekräftiges Aussehen erhalten und antwortet nun auf Nachrichten zum Start einer Spielsitzung und auf die Nachricht, dass es nicht möglich war, ein Spiel aufzunehmen.  Die findStandardMatch-Methode wurde ebenfalls hinzugefügt, die die entsprechende Anforderung an das Backend sendet.  Der Test ist grün, aber ich bin zufrieden, die Auswahl der Spiele gemeistert. <br><br><h2>  <font color="#292e5b">Was weiter?</font> </h2><br>  In den folgenden Artikeln werde ich den Prozess der Entwicklung der Spielelogik beschreiben, von der Initialisierung einer Spielsitzung bis zur Verarbeitung von Zügen.  Ich werde die Funktionen zum Speichern verschiedener Datentypen analysieren - eine Beschreibung der Metadaten des Spiels, Eigenschaften der Spielwelt, Daten aus Spielsitzungen und Daten über Spieler.  Die Spielelogik wird durch zwei Arten von Tests entwickelt - Einheit und Integration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich werde die Quellen auf Github in</a> Teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hochladen, die</a> an Artikel gebunden sind. <br><br>  Es besteht das Verständnis, dass Sie unser Team von Enthusiasten erweitern müssen, um bei der Erstellung eines Spiels effektiv voranzukommen.  Der Künstler / Designer wird bald beitreten.  Und der Guru in Unity3D, der die Front für mobile Plattformen bilden wird, bleibt abzuwarten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451458/">https://habr.com/ru/post/de451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451446/index.html">Produktentwicklung Visual Aid: Design</a></li>
<li><a href="../de451448/index.html">Warum Do-Not-Track erforderlich sein kann</a></li>
<li><a href="../de451452/index.html">Build2019, um zu verstehen, was wir gesehen haben</a></li>
<li><a href="../de451454/index.html">Wir ändern den Inhalt der Benachrichtigungsanwendung iOS</a></li>
<li><a href="../de451456/index.html">Russischer AERODISK-Speicher: Lasttest. IOPS drücken</a></li>
<li><a href="../de451460/index.html">Julia im Labyrinth</a></li>
<li><a href="../de451462/index.html">Schreiben Sie weniger doppelten Code mit Bindemitteln in Laravel</a></li>
<li><a href="../de451464/index.html">Frontend Weekly Digest (6. - 12. Mai 2019)</a></li>
<li><a href="../de451466/index.html">graphql - Fallstricke</a></li>
<li><a href="../de451468/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 364 (6. - 12. Mai 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>