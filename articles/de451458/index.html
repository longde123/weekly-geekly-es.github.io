<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüåæ üßùüèª üßöüèæ Wir brauen einen Spielentwickler. Teil 1 üë®üèº‚ÄçüöÄ üëÉüèΩ ü§üüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Die Geschichte begann mit einem Blockchain-basierten Hackathon. Zu Beginn der Veranstaltung traf ich einen Mann, der Brettspiele als Hobb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir brauen einen Spielentwickler. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Einf√ºhrung</font> </h2><br>  Die Geschichte begann mit einem Blockchain-basierten Hackathon.  Zu Beginn der Veranstaltung traf ich einen Mann, der Brettspiele als Hobby entwickelt (ich war beim Spieltest eines solchen Spiels). Wir haben uns zusammengetan und ein Team gefunden, mit dem sie √ºber das Wochenende ein einfaches strategisches Spiel ‚Äûgeblendet‚Äú haben.  Der Hackathon ging vorbei, aber die Begeisterung blieb.  Und wir hatten die Idee eines Multiplayer-Kartenspiels √ºber Gl√ºck, die Weltgemeinschaft und Wahlen. <br><br>  In der Artikelserie werden wir unseren Weg zur Erstellung eines Spiels reflektieren, mit einer Beschreibung des Rakes, auf den wir bereits getreten sind, und auf dem wir vorw√§rts gehen werden. <br clear="all">  Unter dem Schnitt wird sein: <br><br><ul><li>  Spiel√ºbersicht </li><li> Wie die Entscheidung getroffen wurde, was im Backend zu tun ist.  Wo wird es ‚Äûleben‚Äú, damit es sich in der Entwicklungsphase nicht bezahlt macht? </li><li>  Erste Schritte in der Entwicklung - Spielerauthentifizierung und Organisation des Matchmaking </li><li>  Weitere Pl√§ne </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">Worum geht es in dem Spiel?</font> </h2><br>  Die Menschheit hat die Weltkriege, die Ersch√∂pfung der Ressourcen und den st√§ndigen Wettbewerb satt.  Die wichtigsten Fraktionen waren sich einig, moderne Technologie einzusetzen, um eine einzige F√ºhrung auszuw√§hlen.  Zum festgelegten Zeitpunkt muss die Weltw√§hlerschaft √ºber die Wahl eines Bruchteils entscheiden, der den Planeten f√ºr das n√§chste Jahrtausend regieren wird.  Schl√ºsselfraktionen f√ºhren einen ‚Äûehrlichen‚Äú Machtkampf.  In einer Spielsitzung repr√§sentiert jeder Spieler einen Bruchteil. <br><br>  In diesem Kartenspiel geht es um Wahlen.  Jede Fraktion hat ein Budget f√ºr die Durchf√ºhrung des Wahlkampfs, Einnahmequellen, die das Budget erh√∂hen, und Startstimmen.  Zu Beginn des Spiels wird das Deck mit den Aktionskarten gemischt und jedem Teilnehmer werden 4 Karten ausgegeben.  In jeder Runde k√∂nnen die Spieler bis zu zwei Spielaktionen ausf√ºhren.  Um die Karte zu verwenden, legt der Spieler sie auf den Tisch und bestimmt gegebenenfalls das Ziel und zieht die Kosten f√ºr die Verwendung der Karte vom Budget ab.  Nach dem Ende der Runde kann der Spieler nur eine der nicht verwendeten Karten behalten.  Zu Beginn jeder Runde erhalten die Spieler Karten vom Stapel, so dass jeder Spieler zu Beginn jeder Runde 4 Aktionskarten zur Hand hat. <br><br>  Am Ende der Runden 3, 6 und 9 wird der Spieler mit der geringsten Stimmenzahl aus dem Spiel entfernt.  Wenn mehrere Spieler die gleiche Mindestanzahl an Stimmen haben, werden alle Spieler mit diesem Ergebnis aus dem Spiel ausgeschlossen.  Die Stimmen dieser Spieler gehen in den allgemeinen Pool der W√§hler. <br><br>  Am Ende der 12. Runde ist der Gewinner derjenige mit den meisten Stimmen. <br><br><h2>  <font color="#292e5b">Auswahl eines Tools f√ºr das Backend</font> </h2><br>  Aus der Beschreibung des Spiels folgt: <br><br><ol><li>  Dies ist Multiplayer </li><li>  Es ist notwendig, Spieler irgendwie zu identifizieren und Konten zu verwalten </li><li>  Das Vorhandensein einer sozialen Komponente w√ºrde dem Spiel zugute kommen - Freunde, Gemeinschaften (Clans), Chats, Erfolge (Erfolge) </li><li>  Bestenlisten und Matchmaking-Funktionen sind erforderlich. </li><li>  Die Funktionen zur Turnierverwaltung werden in Zukunft n√ºtzlich sein </li><li>  Da es sich bei dem Spiel um ein Kartenspiel handelt, m√ºssen Sie den Kartenkatalog verwalten und m√∂glicherweise Karten speichern, die dem Spieler zur Verf√ºgung stehen, sowie kompilierte Decks </li><li>  In Zukunft kann eine In-Game-Wirtschaft erforderlich sein, einschlie√ülich In-Game-W√§hrung und Austausch virtueller G√ºter (Karten). </li></ol><br>  Als ich mir die Liste der Bed√ºrfnisse ansah, kam ich sofort zu dem Schluss, dass es keinen Sinn macht, in der Anfangsphase ein eigenes Backend zu erstellen, und ging zu Google, was andere Optionen sind.  Daher fand ich heraus, dass es spezielle Cloud-Gaming-Backends gibt, unter denen sich PlayFab (von Microsoft gekauft) und GameSparks (von Amazon gekauft) hervorheben. <br><br>  Im Allgemeinen sind sie funktional √§hnlich und decken die Grundbed√ºrfnisse ab.  Dar√ºber hinaus ist ihre interne Architektur sehr unterschiedlich, dieselben Aufgaben werden etwas unterschiedlich gel√∂st und explizite Entsprechungen in den Merkmalen sind schwer nachzuvollziehen.  Nachfolgend finden Sie die positiven und negativen Merkmale jeder Plattform sowie √úberlegungen zum Thema Ihrer Wahl. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Positive Eigenschaften: <br><br><ul><li>  Konten aus verschiedenen Spielen werden zu einem Hauptkonto zusammengefasst </li><li>  Die Gaming-Wirtschaft wird ohne eine einzige Codezeile beschrieben, einschlie√ülich der Preisgestaltung f√ºr ein separates virtuelles Gesch√§ft </li><li>  Freundliche Benutzeroberfl√§che </li><li>  Microsoft erwirbt Produkt nach der Akquisition </li><li>  Die Betriebskosten f√ºr die Produktion im Indie Studio-Abonnement betragen 99 USD (bis zu 100.000 MAU). Wenn Sie zum Professional 1k MAU-Abonnement wechseln, kosten Sie 8 USD (Mindestkonto 300 USD). </li></ul><br>  Negative Merkmale: <br><br><ul><li>  Die Speicherung von Spieldaten ist streng begrenzt, z. B. in einem kostenlosen Abonnement zum Speichern von Daten f√ºr eine bestimmte Spielsitzung (wenn ich alles richtig verstehe, werden daf√ºr Entit√§tsgruppen verwendet). Es sind 3 Slots mit jeweils 500 Byte verf√ºgbar </li><li>  Um den Mehrspielermodus zu organisieren, m√ºssen Sie Server von Drittanbietern verbinden, die Ereignisse von Clients verarbeiten und die Spielelogik berechnen.  Dies ist entweder Photon auf Ihrer Hardware oder Azure Thunderhead, und Sie m√ºssen nicht nur den Server organisieren, sondern auch Ihr Abonnement auf mindestens Indie Studio aktualisieren </li><li>  Es ist notwendig zu ertragen, dass der Cloud-Code ohne automatische Vervollst√§ndigung und es keine M√∂glichkeit gibt, in Module zu brechen (oder nicht gefunden?) </li><li>  Es gibt keinen normalen Debugger. Sie k√∂nnen nur Protokolle in CloudScript schreiben und anzeigen </li></ul><br><h3>  <font color="#9cc2ce">Gamesparks</font> </h3><br>  Positive Eigenschaften: <br><br><ul><li>  Speicherung von Spieldaten.  Es gibt nicht nur viele Orte, an denen Sie Daten speichern k√∂nnen (allgemeine Spielmetadaten, virtuelle G√ºter, Spielerprofil, Mehrspielersitzungen usw.), sondern die Plattform bietet auch eine vollwertige Datenbank als Service, die an nichts gebunden ist. Dar√ºber hinaus sind sowohl MongoDB als auch Redis f√ºr verschiedene Datentypen sofort verf√ºgbar.  In der Entwicklungsumgebung k√∂nnen Sie 10 MB speichern, im Kampf 10 GB </li><li>  Multiplayer ist in einem kostenlosen Abonnement (Entwicklung) mit einem Limit von 10 gleichzeitigen Verbindungen und 10 Anforderungen pro Sekunde verf√ºgbar </li><li>  Bequeme Arbeit mit CloudCode, einschlie√ülich eines integrierten Tools zum Testen und Debuggen (Test Harness) </li></ul><br>  Negative Merkmale: <br><br><ul><li>  Das Gef√ºhl, dass seit dem Kauf durch Amazon (Winter 2018) das Tool stagniert hat, gibt es keine Innovationen </li><li>  Nach der √úbernahme von Amazon verschlechterten sich die Tarife erneut, und fr√ºher war es m√∂glich, bis zu 10.000 MAU kostenlos in der Produktion zu verwenden </li><li>  Die Produktionsbetriebskosten beginnen bei 300 USD (Standardabonnement). </li></ul><br><h3>  <font color="#9cc2ce">Reflexionen</font> </h3><br>  Zuerst m√ºssen Sie das Konzept des Spiels √ºberpr√ºfen.  Zu diesem Zweck m√∂chte ich einen Prototyp aus St√∂cken und Klebeband ohne Geldinvestitionen bauen und mit dem Testen der Spielmechanik beginnen.  Daher m√∂chte ich bei der Auswahl zun√§chst die M√∂glichkeit er√∂ffnen, einen Mechaniker mit einem kostenlosen Abonnement zu entwickeln und zu testen. <br>  GameSparks erf√ºllt dieses Kriterium, PlayFab jedoch nicht, da Sie einen Server ben√∂tigen, der die Ereignisse von Spieleclients verarbeitet, und ein Abonnement auf Indie-Studio-Ebene (99 US-Dollar). <br><br>  Gleichzeitig akzeptiere ich das Risiko, dass Amazon keine GameSparks entwickelt, was bedeutet, dass es "sterben" kann.  Angesichts dieser und immer noch der Betriebskosten in der Produktion denke ich an die potenzielle Notwendigkeit, entweder auf eine andere Plattform oder in mein eigenes Backend zu wechseln. <br><br><h2>  <font color="#292e5b">Erste Schritte in der Entwicklung</font> </h2><br><h3>  <font color="#9cc2ce">Verbindung und Authentifizierung</font> </h3><br>  Die Wahl fiel also auf GameSparks als Backend in der Prototyping-Phase.  Der erste Schritt besteht darin, zu lernen, wie Sie eine Verbindung zur Plattform herstellen und den Player authentifizieren.  Ein wichtiger Punkt ist, dass der Benutzer unmittelbar nach der Installation des Spiels ohne Registrierung und SMS spielen kann.  Zu diesem Zweck bietet GameSparks die M√∂glichkeit, ein anonymes Profil durch Aufrufen der DeviceAuthenticationRequest-Methode zu erstellen. Sp√§ter k√∂nnen Sie auf der Grundlage eines anonymen Profils ein vollwertiges Profil erstellen, indem Sie beispielsweise eine Verbindung mit Ihrem Google-Konto herstellen. <br><br>  Da ich eine Gehirn-TDD habe, habe ich zun√§chst einen Test erstellt, um den Client mit dem Spiel zu verbinden.  Da CloudCode in Zukunft in JS geschrieben werden muss, werde ich Integrationstests in JS mit mocha.js und chai.js durchf√ºhren.  Der erste Test verlief wie folgt: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Standardm√§√üig betr√§gt das Timeout in mocha.js 2 Sekunden. Ich mache es sofort endlos, da es sich bei den Tests um Integration handelt.  Im Test erstelle ich einen Spielclient, der noch nicht implementiert wurde, √ºberpr√ºfe, ob keine Verbindung zum Server besteht, rufe den Befehl zum Herstellen einer Verbindung zum Backend auf und √ºberpr√ºfe, ob der Client erfolgreich eine Verbindung hergestellt hat. <br><br>  Damit der Test gr√ºn wird, m√ºssen Sie das GameSparks JS SDK herunterladen und zum Projekt hinzuf√ºgen, seine Abh√§ngigkeiten (crypto-js und ws) verbinden und nat√ºrlich GameClientModule implementieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  Bei der Startimplementierung des Spielclients werden die Schl√ºssel, die f√ºr die technische Autorisierung zum Herstellen einer Verbindung aus der Clientanwendung erforderlich sind, aus der Konfiguration gelesen.  Die verbundene Methode umschlie√üt dasselbe Feld aus dem SDK.  Das Wichtigste, was bei der Verbindungsmethode passiert, ist, dass sie ein Versprechen mit R√ºckrufen f√ºr eine erfolgreiche Verbindung oder einen Fehler zur√ºckgibt und den onMessage-Handler an denselben R√ºckruf bindet.  onMessage fungiert vom Backend aus als Nachrichtenverarbeitungsmanager. Lassen Sie es jetzt Nachrichten in der Konsole protokollieren. <br><br>  Es scheint, dass die Arbeit abgeschlossen ist, aber der Test bleibt rot.  Es stellt sich heraus, dass das GameSparks JS SDK nicht mit node.js funktioniert. Ihnen fehlt der Browserkontext.  Lassen Sie ihn denken, dass der Knoten Chrome auf der Mohnblume ist.  Wir gehen zu gamesparks.js und f√ºgen ganz am Anfang hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  Der Test wurde gr√ºn und ging weiter. <br><br>  Wie ich bereits geschrieben habe, sollte ein Spieler in der Lage sein, sofort mit dem Spielen zu beginnen, sobald er das Spiel betritt, w√§hrend ich anfangen m√∂chte, Analysen in Aktivit√§ten zu sammeln.  Dazu binden wir entweder an die Ger√§tekennung oder an eine zuf√§llig generierte Kennung.  √úberpr√ºfen Sie, ob dies ein solcher Test ist: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  Ich habe mich entschlossen, sofort 2 Clients zu √ºberpr√ºfen, um sicherzustellen, dass jeder Client sein eigenes Profil im Backend erstellt.  Dazu ben√∂tigt der Spielclient eine Methode, mit der Sie eine bestimmte Kennung au√üerhalb von GameSparks √ºbertragen und dann √ºberpr√ºfen k√∂nnen, ob der Client das gew√ºnschte Spielerprofil kontaktiert hat.  Im Voraus erstellte Profile auf dem GameSparks-Portal. <br><br>  F√ºr die Implementierung in GameClient f√ºgen Sie Folgendes hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  Bei der Implementierung wird eine DeviceAuthenticationRequest-Anforderung gesendet, die Kennung des Spielers aus der Antwort empfangen und in die Eigenschaft des Clients gestellt.  In einer separaten Methode schickte der Helfer sofort Anfragen mit einem Wrapper in einem Promis an GameSparks. <br><br>  Beide Tests sind gr√ºn, es bleibt noch das Schlie√üen der Verbindung und des Refaktors hinzuzuf√ºgen. <br>  In GameClient habe ich eine Methode hinzugef√ºgt, die die Verbindung zum Server schlie√üt (trennen) und connectAsAnonymous, indem connect und authWithCustomId kombiniert werden.  Einerseits verst√∂√üt connectAsAnonymous gegen das Prinzip der Einzelverantwortung, scheint aber nicht zu verletzen ... Gleichzeitig erh√∂ht es die Benutzerfreundlichkeit, da in Tests h√§ufig die Authentifizierung von Clients erforderlich ist.  Was denkst du dar√ºber? <br><br>  In Tests f√ºgte er einen Factory-Methoden-Helfer hinzu, der eine neue Instanz des Spiel-Clients erstellt und das Array der erstellten Clients erweitert.  Im speziellen Mokka-Handler rufe ich nach jedem Test f√ºr Clients im Array die Trennungsmethode auf und l√∂sche dieses Array.  Ich mag "magische Zeichenfolgen" im Code noch nicht, daher habe ich ein W√∂rterbuch mit benutzerdefinierten Bezeichnern hinzugef√ºgt, die in den Tests verwendet wurden. <br><br>  Der endg√ºltige Code kann im Repository angezeigt werden, ein Link, den ich am Ende des Artikels geben werde. <br><br><h3>  <font color="#9cc2ce">Organisation der Spielsuche (Matchmaking)</font> </h3><br>  Ich starte die Matchmaking-Funktion, die f√ºr den Mehrspielermodus sehr wichtig ist.  Dieses System beginnt zu funktionieren, wenn wir in einem Spiel auf die Schaltfl√§che ‚ÄûSpiel suchen‚Äú klicken.  Sie nimmt entweder Rivalen oder Teamkollegen oder beide auf (je nach Spiel).  In solchen Systemen hat jeder Spieler in der Regel einen numerischen Indikator MMR (Match Making Ratio) - eine pers√∂nliche Bewertung des Spielers, mit der andere Spieler mit den gleichen F√§higkeiten ausgew√§hlt werden. <br><br>  Um diese Funktionalit√§t zu testen, habe ich folgenden Test entwickelt: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Drei Clients sind mit dem Spiel verbunden (in Zukunft ist dies ein notwendiges Minimum, um einige Szenarien zu √ºberpr√ºfen) und f√ºr die Suche nach dem Spiel registriert.  Nach der Registrierung des 3. Spielers auf dem Server wird eine Spielsitzung gebildet, und die Spieler m√ºssen eine Verbindung herstellen.  Gleichzeitig √§ndert sich der Status der Clients und der Kontext der Spielsitzung mit derselben Kennung wird angezeigt. <br><br>  Bereiten Sie zuerst das Backend vor.  In GameSparks gibt es ein vorgefertigtes Tool zum Anpassen der Suche nach Spielen, das unter dem Pfad ‚ÄûKonfigurator-&gt; √úbereinstimmungen‚Äú verf√ºgbar ist.  Ich erstelle eine neue und fahre mit dem Setup fort.  Zus√§tzlich zu den Standardparametern wie Code, Name und Beschreibung des Spiels wird die minimale und maximale Anzahl von Spielern angegeben, die f√ºr einen benutzerdefinierten Spielmodus erforderlich sind.  Ich werde dem erstellten Match den Code "StandardMatch" zuweisen und die Anzahl der Spieler von 2 bis 3 angeben. <br><br>  Jetzt m√ºssen Sie die Regeln f√ºr die Auswahl der Spieler im Abschnitt ‚ÄûSchwellenwerte‚Äú konfigurieren.  F√ºr jeden Schwellenwert werden der Zeitpunkt seiner Aktion, der Typ (absolut, relativ und in Prozent) und die Grenzen angegeben. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Angenommen, ein Spieler mit einer MMR von 19 beginnt mit der Suche. Im obigen Beispiel werden in den ersten 10 Sekunden andere Spieler mit einer MMR von 19 bis 21 ausgew√§hlt. Wenn die Spieler nicht ausgew√§hlt werden k√∂nnen, wird der zweite Suchrand aktiviert, wodurch der Suchbereich f√ºr die n√§chsten 20 Sekunden von 16 erweitert wird ( 19-3) bis 22 (19 + 3).  Als n√§chstes wird der dritte Schwellenwert aufgenommen, innerhalb dessen eine Suche f√ºr 30 Sekunden im Bereich von 14 (19-25%) bis 29 (19 + 50%) durchgef√ºhrt wird, w√§hrend das Spiel als abgeschlossen gilt, wenn die erforderliche Mindestanzahl von Spielern angesammelt wurde (Min. Akzeptieren) Spieler). <br><br>  Tats√§chlich ist der Mechanismus komplizierter, da er die MMR aller Spieler ber√ºcksichtigt, die es geschafft haben, an einem bestimmten Spiel teilzunehmen.  Ich werde diese Details analysieren, wenn es an der Zeit ist, den Bewertungsmodus des Spiels festzulegen (nicht in diesem Artikel).  F√ºr den Standardspielmodus, in dem ich MMR noch nicht verwenden m√∂chte, ben√∂tige ich nur einen Schwellenwert. <br><br>  Wenn alle Spieler ausgew√§hlt wurden, m√ºssen Sie eine Spielsitzung erstellen und die Spieler damit verbinden.  In GameSparks ist die Spielsitzungsfunktion die ‚ÄûHerausforderung‚Äú.  Als Teil dieser Entit√§t werden Spielsitzungsdaten gespeichert und Nachrichten zwischen Spielclients ausgetauscht.  Um einen neuen Herausforderungstyp zu erstellen, m√ºssen Sie dem Pfad ‚ÄûKonfigurator-&gt; Herausforderungen‚Äú folgen.  Dort f√ºge ich einen neuen Typ mit dem Code "StandardChallenge" hinzu und gebe an, dass diese Art von Spielsitzung rundenbasiert ist, d. H.  Spieler wechseln sich ab, nicht gleichzeitig.  Gleichzeitig √ºbernimmt GameSparks die Kontrolle √ºber die Reihenfolge der Z√ºge. <br><br>  Damit sich ein Client registrieren kann, um nach einem Spiel zu suchen, k√∂nnen Sie eine Anfrage vom Typ MatchmakingRequest verwenden, die ich jedoch nicht empfehlen w√ºrde, da der MMR-Wert des Spielers als einer der Parameter erforderlich ist.  Dies kann zu Betrug seitens des Spielclients f√ºhren, und der Client sollte keine MMR kennen, dies ist ein Backend-Gesch√§ft.  Um mich korrekt f√ºr die Spielsuche zu registrieren, erstelle ich ein beliebiges Ereignis vom Client.  Dies erfolgt im Abschnitt ‚ÄûKonfigurator-&gt; Ereignisse‚Äú.  Ich rufe das Ereignis FindStandardMatch ohne Attribute auf.  Jetzt m√ºssen Sie die Reaktion auf dieses Ereignis konfigurieren. Dazu gehe ich zum Abschnitt "Konfigurator-&gt; Cloud-Code" des Cloud-Codes. Ich schreibe den folgenden Handler f√ºr FindStandardMatch im Abschnitt "Ereignisse": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Dieser Code registriert einen Spieler in StandardMatch mit einem MMR von 0, sodass alle Spieler, die f√ºr die Suche nach einem Standardspiel registriert sind, zum Erstellen einer Spielsitzung geeignet sind.  Bei der Auswahl eines Bewertungsspiels kann auf die privaten Daten des Spielerprofils zur√ºckgegriffen werden, um die MMR dieser Art von Spiel zu erhalten. <br><br>  Wenn gen√ºgend Spieler vorhanden sind, um eine Spielsitzung zu starten, sendet GameSparks eine MatchFoundMessage-Nachricht an alle ausgew√§hlten Spieler.  Hier k√∂nnen Sie automatisch eine Spielsitzung erstellen und Spieler hinzuf√ºgen.  F√ºgen Sie dazu unter ‚ÄûUser Messages-&gt; MatchFoundMessage‚Äú den folgenden Code hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  Der Code √ºberpr√ºft zun√§chst, ob es sich um den ersten Spieler auf der Teilnehmerliste handelt.  Als n√§chstes wird im Namen des ersten Spielers eine Instanz von StandardChallenge erstellt und die verbleibenden Spieler werden eingeladen.  Eingeladene Spieler erhalten eine ChallengeIssuedMessage-Nachricht.  Hier k√∂nnen Sie sich ein Verhalten vorstellen, wenn eine Einladung zur Teilnahme am Spiel auf dem Client angezeigt wird und eine Best√§tigung durch Senden von AcceptChallengeRequest erfordert, oder Sie k√∂nnen die Einladung im stillen Modus annehmen.  Also werde ich es tun. Dazu f√ºge ich unter "User Messages-&gt; ChallengeIssuedMessage" den folgenden Code hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  Im n√§chsten Schritt sendet GameSparks das ChallengeStartedMessage-Ereignis.  Der globale Handler dieses Ereignisses ("Globale Nachrichten-&gt; ChallengeStartedMessage") ist ein idealer Ort zum Initialisieren einer Spielsitzung. Ich werde mich bei der Implementierung der Spielelogik darum k√ºmmern. <br><br>  Es ist Zeit f√ºr die Client-Anwendung.  √Ñnderungen im Client-Modul: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  In √úbereinstimmung mit dem Test wurden einige Felder auf dem Client-Status und der Herausforderung angezeigt.  Die onMessage-Methode hat ein aussagekr√§ftiges Aussehen erhalten und antwortet nun auf Nachrichten zum Start einer Spielsitzung und auf die Nachricht, dass es nicht m√∂glich war, ein Spiel aufzunehmen.  Die findStandardMatch-Methode wurde ebenfalls hinzugef√ºgt, die die entsprechende Anforderung an das Backend sendet.  Der Test ist gr√ºn, aber ich bin zufrieden, die Auswahl der Spiele gemeistert. <br><br><h2>  <font color="#292e5b">Was weiter?</font> </h2><br>  In den folgenden Artikeln werde ich den Prozess der Entwicklung der Spielelogik beschreiben, von der Initialisierung einer Spielsitzung bis zur Verarbeitung von Z√ºgen.  Ich werde die Funktionen zum Speichern verschiedener Datentypen analysieren - eine Beschreibung der Metadaten des Spiels, Eigenschaften der Spielwelt, Daten aus Spielsitzungen und Daten √ºber Spieler.  Die Spielelogik wird durch zwei Arten von Tests entwickelt - Einheit und Integration. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich werde die Quellen auf Github in</a> Teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hochladen, die</a> an Artikel gebunden sind. <br><br>  Es besteht das Verst√§ndnis, dass Sie unser Team von Enthusiasten erweitern m√ºssen, um bei der Erstellung eines Spiels effektiv voranzukommen.  Der K√ºnstler / Designer wird bald beitreten.  Und der Guru in Unity3D, der die Front f√ºr mobile Plattformen bilden wird, bleibt abzuwarten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451458/">https://habr.com/ru/post/de451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451446/index.html">Produktentwicklung Visual Aid: Design</a></li>
<li><a href="../de451448/index.html">Warum Do-Not-Track erforderlich sein kann</a></li>
<li><a href="../de451452/index.html">Build2019, um zu verstehen, was wir gesehen haben</a></li>
<li><a href="../de451454/index.html">Wir √§ndern den Inhalt der Benachrichtigungsanwendung iOS</a></li>
<li><a href="../de451456/index.html">Russischer AERODISK-Speicher: Lasttest. IOPS dr√ºcken</a></li>
<li><a href="../de451460/index.html">Julia im Labyrinth</a></li>
<li><a href="../de451462/index.html">Schreiben Sie weniger doppelten Code mit Bindemitteln in Laravel</a></li>
<li><a href="../de451464/index.html">Frontend Weekly Digest (6. - 12. Mai 2019)</a></li>
<li><a href="../de451466/index.html">graphql - Fallstricke</a></li>
<li><a href="../de451468/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 364 (6. - 12. Mai 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>