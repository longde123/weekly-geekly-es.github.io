<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏼 👨🏾‍🎓 🍗 Mengasuransikan sumber daya di Kuba 😁 🕊️ 🐮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manajemen sumber daya cluster selalu menjadi topik yang kompleks. Bagaimana cara menjelaskan kebutuhan untuk mengkonfigurasi sumber daya untuk penggun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengasuransikan sumber daya di Kuba</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473908/"><p><img src="https://habrastorage.org/webt/bp/bf/_p/bpbf_pwx_8zuvlwptjwkfnbxb5y.jpeg" alt="gambar"></p><br><p>  Manajemen sumber daya cluster selalu menjadi topik yang kompleks.  Bagaimana cara menjelaskan kebutuhan untuk mengkonfigurasi sumber daya untuk pengguna yang menyebarkan aplikasi mereka ke cluster?  Mungkin lebih mudah untuk mengotomatisasi ini? </p><a name="habracut"></a><br><h3 id="opisanie-problemy">  Deskripsi masalah </h3><br><p>  Manajemen sumber daya adalah tugas penting dalam konteks administrasi cluster Kubernetes.  Tetapi mengapa penting jika Kubernetes melakukan semua kerja keras untuk Anda?  Karena tidak.  Kubernetes memberi Anda alat yang mudah untuk menyelesaikan banyak masalah ... jika Anda menggunakan alat ini.  Untuk setiap pod di cluster Anda, Anda dapat menentukan sumber daya yang dibutuhkan untuk kontainernya.  Dan Kubernetes akan menggunakan informasi ini untuk mendistribusikan contoh aplikasi Anda di seluruh node cluster. </p><br><p> Hanya sedikit orang yang menganggap manajemen sumber daya di Kubernetes serius.  Ini normal untuk kluster yang ringan dengan beberapa aplikasi statis.  Tetapi bagaimana jika Anda memiliki kluster yang sangat dinamis?  Di mana aplikasi datang dan pergi, di mana namespace dibuat dan dihapus sepanjang waktu?  Cluster dengan sejumlah besar pengguna yang dapat membuat namespace mereka sendiri dan menggunakan aplikasi?  Nah, dalam hal ini, alih-alih orkestrasi yang stabil dan dapat diprediksi, Anda akan memiliki banyak crash acak dalam aplikasi, dan kadang-kadang bahkan dalam komponen Kubernetes sendiri! </p><br><p>  Berikut adalah contoh dari kluster tersebut: </p><br><p><img src="https://habrastorage.org/webt/0y/ar/2p/0yar2pe_8-bk-8cwrkd95bz8leu.png" alt="gambar"></p><br><p>  Anda melihat 3 perapian di negara bagian "Terminating".  Tapi ini bukan penghilangan perapian yang biasa - mereka terjebak dalam keadaan ini karena daemon yang berisi pada node mereka dihantam oleh sesuatu yang sangat haus sumber daya. </p><br><p>  Masalah seperti itu dapat diatasi dengan menangani dengan benar kekurangan sumber daya, tetapi ini bukan topik dari artikel ini (ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> bagus), dan juga bukan peluru perak untuk menyelesaikan semua masalah dengan sumber daya. </p><br><p>  Alasan utama untuk masalah seperti itu adalah salah atau kurangnya manajemen sumber daya di cluster.  Dan jika masalah semacam ini bukan merupakan bencana bagi penyebaran, karena mereka akan dengan mudah membuat yang baru bekerja di bawah, maka untuk entitas seperti DaemonSet, atau bahkan lebih untuk StatefulSet, pembekuan seperti itu akan berakibat fatal dan memerlukan intervensi manual. </p><br><p>  Anda dapat memiliki cluster besar dengan banyak CPU dan memori.  Saat Anda menjalankan banyak aplikasi di atasnya tanpa pengaturan sumber daya yang tepat, ada kemungkinan semua pod sumber daya intensif akan ditempatkan pada node yang sama.  Mereka akan memperjuangkan sumber daya, bahkan jika node yang tersisa dari cluster tetap praktis gratis. </p><br><p>  Anda juga dapat sering melihat kasus-kasus yang kurang kritis di mana beberapa aplikasi dipengaruhi oleh tetangga mereka.  Bahkan jika aplikasi "tidak bersalah" ini memiliki sumber daya mereka dikonfigurasi dengan benar, yang keliling mungkin datang dan membunuh mereka.  Contoh skenario seperti itu: </p><br><ol><li>  Aplikasi Anda meminta memori 4 GB, tetapi pada awalnya hanya membutuhkan 1 GB. </li><li>  Mengembara di bawah, tanpa konfigurasi sumber daya, ditugaskan ke node yang sama. </li><li>  Berkeliaran di bawah menghabiskan semua memori yang tersedia. </li><li>  Aplikasi Anda mencoba mengalokasikan lebih banyak memori dan macet karena tidak ada lagi. </li></ol><br><p>  Kasus lain yang cukup populer adalah revaluasi.  Beberapa pengembang membuat permintaan besar dalam manifes "berjaga-jaga" dan tidak pernah menggunakan sumber daya ini.  Hasilnya adalah buang-buang uang. </p><br><h3 id="teoriya-resheniya">  Teori keputusan </h3><br><p>  Horor!  Benar? <br>  Untungnya, Kubernetes menawarkan cara untuk memberlakukan beberapa pembatasan pada pod dengan menentukan konfigurasi sumber daya default serta nilai minimum dan maksimum.  Ini diimplementasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek LimitRange</a> .  LimitRange adalah alat yang sangat nyaman ketika Anda memiliki jumlah ruang nama yang terbatas atau kendali penuh atas proses pembuatannya.  Bahkan tanpa konfigurasi sumber daya yang tepat, aplikasi Anda akan terbatas dalam penggunaannya.  "Innocent", perapian yang disetel dengan benar akan aman dan terlindungi dari tetangga yang berbahaya.  Jika seseorang menyebarkan aplikasi serakah tanpa konfigurasi sumber daya, aplikasi ini akan menerima nilai default dan mungkin akan macet.  Dan itu saja!  Aplikasi tidak akan lagi menyeret siapa pun. </p><br><p>  Jadi, kami memiliki alat untuk mengontrol dan memaksa konfigurasi sumber daya untuk perapian, sekarang tampaknya kami aman.  Jadi?  Tidak juga.  Faktanya adalah bahwa, seperti yang kami jelaskan sebelumnya, ruang nama kami dapat dibuat oleh pengguna, dan oleh karena itu, LimitRange mungkin tidak ada di ruang nama tersebut, karena itu harus dibuat di setiap ruang nama secara terpisah.  Oleh karena itu, kita memerlukan sesuatu tidak hanya di level namespace, tetapi juga di level cluster.  Tetapi belum ada fungsi seperti itu di Kubernetes. </p><br><p>  Itu sebabnya saya memutuskan untuk menulis solusi untuk masalah ini.  Biarkan saya memperkenalkan Anda - Batasi Operator.  Ini adalah operator yang dibuat atas dasar kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator SDK</a> , yang menggunakan sumber daya khusus ClusterLimit dan membantu mengamankan semua aplikasi "tidak bersalah" di dalam kluster.  Dengan menggunakan operator ini, Anda dapat mengontrol nilai default dan batas sumber daya untuk semua ruang nama menggunakan jumlah minimum konfigurasi.  Ini juga memungkinkan Anda untuk memilih di mana tepatnya menerapkan konfigurasi menggunakan namespaceSelector. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh ClusterLimit</b> <div class="spoiler_text"><pre><code class="python hljs">apiVersion: limit.myafq.com/v1alpha1 kind: ClusterLimit metadata: name: default-limit spec: namespaceSelector: matchLabels: limit: <span class="hljs-string"><span class="hljs-string">"limited"</span></span> limitRange: limits: - type: Container max: cpu: <span class="hljs-string"><span class="hljs-string">"800m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"1Gi"</span></span> min: cpu: <span class="hljs-string"><span class="hljs-string">"100m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"99Mi"</span></span> default: cpu: <span class="hljs-string"><span class="hljs-string">"700m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"900Mi"</span></span> defaultRequest: cpu: <span class="hljs-string"><span class="hljs-string">"110m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"111Mi"</span></span> - type: Pod max: cpu: <span class="hljs-string"><span class="hljs-string">"2"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"2Gi"</span></span></code> </pre> </div></div><br><p>  Dengan konfigurasi ini, operator akan membuat LimitRange hanya di namespace dengan label <code>limit: limited</code> .  Ini akan berguna untuk memberikan batasan yang lebih ketat dalam kelompok ruang nama tertentu.  Jika namespaceSelector tidak ditentukan, operator akan menerapkan LimitRange ke semua ruang nama.  Jika Anda ingin mengonfigurasi LimitRange secara manual untuk namespace tertentu, Anda dapat menggunakan anotasi <code>"limit.myafq.com/unlimited": true</code> ini akan memberitahu operator untuk melewati namespace ini dan tidak membuat LimitRange secara otomatis. </p><br><p>  Contoh skrip untuk menggunakan operator: </p><br><ul><li>  Buat ClusterLimit default dengan batasan liberal dan tanpa namespaceSelector - itu akan diterapkan di mana-mana. </li><li>  Untuk sekumpulan ruang nama dengan aplikasi ringan, buat ClusterLimit tambahan, lebih ketat, dengan namespaceSelector.  Letakkan label pada ruang nama ini sesuai. </li><li>  Pada namespace dengan aplikasi yang sangat intensif sumber daya, letakkan anotasi "limit.myafq.com/unlimited": true dan konfigurasikan LimitRange secara manual dengan batas yang jauh lebih luas daripada yang ditentukan dalam ClusteLimit default. </li></ul><br><blockquote>  <strong>Hal penting yang perlu diketahui tentang beberapa LimitRange dalam satu ruang nama:</strong> <br>  Ketika sub dibuat di namespace dengan beberapa LimitRange, default terbesar akan diambil untuk mengkonfigurasi sumber dayanya.  Tetapi nilai maksimum dan minimum akan diperiksa sesuai dengan LimitRange yang paling ketat. </blockquote><br><h3 id="prakticheskiy-primer">  Contoh praktis </h3><br><p>  Operator akan melacak semua perubahan di semua namespace, ClusterLimits, child LimitRanges dan akan memulai koordinasi keadaan cluster dengan setiap perubahan pada objek yang dipantau.  Mari kita lihat cara kerjanya dalam praktik. </p><br><p>  Untuk memulai, buat di bawah tanpa batasan apa pun: </p><br><div class="spoiler">  <b class="spoiler_title">kubectl jalankan / dapatkan output</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">❯() kubectl run --generator=run-pod/v1 --image=bash bash pod/bash created ❯() kubectl get pod bash -o yaml apiVersion: v1 kind: Pod metadata: labels: run: bash name: bash namespace: default spec: containers: - image: bash name: bash resources: {}</code> </pre> <br><p>  <em>Catatan: bagian dari output perintah telah dihilangkan untuk menyederhanakan contoh.</em> </p></div></div><br><p>  Seperti yang Anda lihat, bidang "sumber daya" kosong, yang berarti sub ini dapat diluncurkan di mana saja. <br>  Sekarang kita akan membuat ClusterLimit default untuk seluruh cluster dengan nilai yang cukup liberal: </p><br><div class="spoiler">  <b class="spoiler_title">default-limit.yaml</b> <div class="spoiler_text"><pre> <code class="python hljs">apiVersion: limit.myafq.com/v1alpha1 kind: ClusterLimit metadata: name: default-limit spec: limitRange: limits: - type: Container max: cpu: <span class="hljs-string"><span class="hljs-string">"4"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"5Gi"</span></span> default: cpu: <span class="hljs-string"><span class="hljs-string">"700m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"900Mi"</span></span> defaultRequest: cpu: <span class="hljs-string"><span class="hljs-string">"500m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"512Mi"</span></span></code> </pre> </div></div><br><p>  Dan juga lebih ketat untuk subset ruang nama: </p><br><div class="spoiler">  <b class="spoiler_title">restriktif-limit.yaml</b> <div class="spoiler_text"><pre> <code class="python hljs">apiVersion: limit.myafq.com/v1alpha1 kind: ClusterLimit metadata: name: restrictive-limit spec: namespaceSelector: matchLabels: limit: <span class="hljs-string"><span class="hljs-string">"restrictive"</span></span> limitRange: limits: - type: Container max: cpu: <span class="hljs-string"><span class="hljs-string">"800m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"1Gi"</span></span> default: cpu: <span class="hljs-string"><span class="hljs-string">"100m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"128Mi"</span></span> defaultRequest: cpu: <span class="hljs-string"><span class="hljs-string">"50m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"64Mi"</span></span> - type: Pod max: cpu: <span class="hljs-string"><span class="hljs-string">"2"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"2Gi"</span></span></code> </pre> </div></div><br><p>  Kemudian buat ruang nama dan pod di dalamnya untuk melihat cara kerjanya. <br>  Namespace normal dengan batasan default: </p><br><pre> <code class="python hljs">apiVersion: v1 kind: Namespace metadata: name: regular</code> </pre> <br><p>  Dan namespace yang sedikit lebih terbatas, menurut legenda - untuk aplikasi ringan: </p><br><pre> <code class="python hljs">apiVersion: v1 kind: Namespace metadata: labels: limit: <span class="hljs-string"><span class="hljs-string">"restrictive"</span></span> name: lightweight</code> </pre> <br><p>  Jika Anda melihat log operator segera setelah membuat namespace, Anda dapat menemukan sesuatu seperti itu di bawah spoiler: </p><br><div class="spoiler">  <b class="spoiler_title">log operator</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{...,"msg":"Reconciling ClusterLimit","Triggered by":"/regular"} {...,"msg":"Creating new namespace LimitRange.","Namespace":"regular","LimitRange":"default-limit"} {...,"msg":"Updating namespace LimitRange.","Namespace":"regular","Name":"default-limit"} {...,"msg":"Reconciling ClusterLimit","Triggered by":"/lightweight"} {...,"msg":"Creating new namespace LimitRange.","Namespace":"lightweight","LimitRange":"default-limit"} {...,"msg":"Updating namespace LimitRange.","Namespace":"lightweight","Name":"default-limit"} {...,"msg":"Creating new namespace LimitRange.","Namespace":"lightweight","LimitRange":"restrictive-limit"} {...,"msg":"Updating namespace LimitRange.","Namespace":"lightweight","Name":"restrictive-limit"}</code> </pre> <br><p>  <em>Bagian log yang hilang berisi 3 bidang lainnya yang tidak relevan saat ini</em> </p></div></div><br><p>  Seperti yang Anda lihat, pembuatan setiap namespace memulai pembuatan LimitRange baru.  Namespace yang lebih terbatas mendapat dua LimitRange - default dan lebih ketat. </p><br><p>  Sekarang mari kita coba membuat sepasang perapian di ruang nama ini. </p><br><div class="spoiler">  <b class="spoiler_title">kubectl jalankan / dapatkan output</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">❯() kubectl run --generator=run-pod/v1 --image=bash bash -n regular pod/bash created ❯() kubectl get pod bash -o yaml -n regular apiVersion: v1 kind: Pod metadata: annotations: kubernetes.io/limit-ranger: 'LimitRanger plugin set: cpu, memory request for container bash; cpu, memory limit for container bash' labels: run: bash name: bash namespace: regular spec: containers: - image: bash name: bash resources: limits: cpu: 700m memory: 900Mi requests: cpu: 500m memory: 512Mi</code> </pre> </div></div><br><p>  Seperti yang Anda lihat, meskipun fakta bahwa kami belum mengubah cara pod dibuat, bidang sumber daya sekarang diisi.  Anda mungkin juga memperhatikan anotasi yang dibuat secara otomatis oleh LimitRanger. </p><br><p>  Sekarang buat di bawah dalam namespace yang ringan: </p><br><div class="spoiler">  <b class="spoiler_title">kubectl jalankan / dapatkan output</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">❯() kubectl run --generator=run-pod/v1 --image=bash bash -n lightweight pod/bash created ❯() kubectl get pods -n lightweight bash -o yaml apiVersion: v1 kind: Pod metadata: annotations: kubernetes.io/limit-ranger: 'LimitRanger plugin set: cpu, memory request for container bash; cpu, memory limit for container bash' labels: run: bash name: bash namespace: lightweight spec: containers: - image: bash name: bash resources: limits: cpu: 700m memory: 900Mi requests: cpu: 500m memory: 512Mi</code> </pre> </div></div><br><p>  Harap perhatikan bahwa sumber daya di perapian sama dengan contoh sebelumnya.  Ini karena dalam kasus beberapa LimitRange, nilai standar yang kurang ketat akan digunakan saat membuat pod.  Tetapi mengapa kita membutuhkan LimitRange yang lebih terbatas?  Ini akan digunakan untuk memeriksa nilai sumber daya maksimum dan minimum.  Untuk menunjukkan, kami akan membuat ClusterLimit terbatas kami semakin terbatas: </p><br><div class="spoiler">  <b class="spoiler_title">restriktif-limit.yaml</b> <div class="spoiler_text"><pre> <code class="python hljs">apiVersion: limit.myafq.com/v1alpha1 kind: ClusterLimit metadata: name: restrictive-limit spec: namespaceSelector: matchLabels: limit: <span class="hljs-string"><span class="hljs-string">"restrictive"</span></span> limitRange: limits: - type: Container max: cpu: <span class="hljs-string"><span class="hljs-string">"200m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"250Mi"</span></span> default: cpu: <span class="hljs-string"><span class="hljs-string">"100m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"128Mi"</span></span> defaultRequest: cpu: <span class="hljs-string"><span class="hljs-string">"50m"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"64Mi"</span></span> - type: Pod max: cpu: <span class="hljs-string"><span class="hljs-string">"2"</span></span> memory: <span class="hljs-string"><span class="hljs-string">"2Gi"</span></span></code> </pre> </div></div><br><p>  Perhatikan bagian: </p><br><pre> <code class="plaintext hljs">- type: Container max: cpu: "200m" memory: "250Mi"</code> </pre> <br><p>  Sekarang kita telah menetapkan CPU 200m dan memori 250Mi sebagai maksimum untuk wadah di perapian.  Dan sekarang lagi, coba buat di bawah: </p><br><pre> <code class="plaintext hljs">❯() kubectl run --generator=run-pod/v1 --image=bash bash -n lightweight Error from server (Forbidden): pods "bash" is forbidden: [maximum cpu usage per Container is 200m, but limit is 700m., maximum memory usage per Container is 250Mi, but limit is 900Mi.]</code> </pre> <br><p>  Sub kami memiliki nilai besar yang ditetapkan oleh LimitRange default dan tidak dapat memulai karena tidak lulus pemeriksaan sumber daya maksimum yang diizinkan. </p><br><hr><br><p>  Ini adalah contoh penggunaan Operator Batas.  Cobalah sendiri dan mainkan dengan ClusterLimit dalam instance Kubernetes lokal Anda. </p><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori Operator Batas</a> GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> Anda dapat menemukan manifes untuk penggunaan operator, serta kode sumber.  Jika Anda ingin memperluas fungsionalitas operator, pencarian-tarik dan pencarian-fitur dipersilakan! </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Manajemen sumber daya di Kubernetes sangat penting untuk stabilitas dan keandalan aplikasi Anda.  Sesuaikan sumber daya perapian Anda jika memungkinkan.  Dan gunakan LimitRange untuk memastikan terhadap kasus-kasus ketika itu tidak mungkin.  Mengotomatiskan pembuatan LimitRange menggunakan Operator Batas. </p><br><p>  Ikuti kiat-kiat ini, dan kluster Anda akan selalu aman dari kekacauan sumber daya alam yang tersesat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473908/">https://habr.com/ru/post/id473908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473888/index.html">Berita dari dunia OpenStreetMap No. 483 (15/10/2019 - 21/10/2019)</a></li>
<li><a href="../id473890/index.html">Operation Calypso: Grup APT Baru Menyerang Kantor Pemerintah di Seluruh Dunia</a></li>
<li><a href="../id473894/index.html">Enam Tugas untuk Pengembang Front-End</a></li>
<li><a href="../id473904/index.html">Vivaldi 2.9 - Perbaikan Peningkatan</a></li>
<li><a href="../id473906/index.html">7 kursus gratis untuk pengembang dari Microsoft</a></li>
<li><a href="../id473910/index.html">Kode bahasa inggris</a></li>
<li><a href="../id473916/index.html">Kisah-kisah dari pusat data: kisah-kisah horor Halloween tentang mesin diesel, diplomasi, dan sekrup self-sapping di pemanas</a></li>
<li><a href="../id473918/index.html">Bepergian Internet di Rusia: Kecepatan dan Peluang</a></li>
<li><a href="../id473922/index.html">Konferensi Akademi Jaringan Selectel</a></li>
<li><a href="../id473924/index.html">Tidak hanya SMS dan token: otentikasi multi-faktor berdasarkan pada Layanan Otentikasi SafeNet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>