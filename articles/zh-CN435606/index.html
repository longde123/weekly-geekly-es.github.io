<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 👑 👨🏽‍🌾 如何为演员编写单元测试？ SObjectizer方法 👉 ⚾️ 👩🏾‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Actor通过避免共享的，共享的可变状态来简化多线程编程。 每个演员都拥有自己的数据，任何人都看不到。 Actor仅通过异步消息进行交互。 因此，使用actor时以种族和死锁的形式出现的最令人恐惧的多线程恐怖并不可怕（尽管actor遇到了麻烦，但这不是现在所要解决的）。 

 通常，使用actor编...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何为演员编写单元测试？ SObjectizer方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Actor通过避免共享的，共享的可变状态来简化多线程编程。 每个演员都拥有自己的数据，任何人都看不到。  Actor仅通过异步消息进行交互。 因此，使用actor时以种族和死锁的形式出现的最令人恐惧的多线程恐怖并不可怕（尽管actor遇到了麻烦，但这不是现在所要解决的）。 <br><br> 通常，使用actor编写多线程应用程序既容易又愉快。 包括因为演员本身写得轻松自然。 您甚至可以说编写演员代码是工作中最简单的部分。 但是当演员被写作时，一个很好的问题出现了：“如何检查作品的正确性？” <br><br> 这个问题真的很好。 我们经常被问及何时谈论一般的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参与者</a> ，特别是关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SObjectizer的</a>问题。 直到最近，我们只能笼统地回答这个问题。 <br><br> 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布了5.5.24版本</a> ，其中对参与者进行单元测试的可能性提供了实验性支持。 在本文中，我们将尝试讨论它是什么，如何使用它以及实现它。 <br><a name="habracut"></a><br><h1> 演员测试是什么样的？ </h1><br> 我们将通过几个示例考虑SObjectizer的新功能，并介绍什么是什么。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此存储库中</a>找到所讨论示例的源代码。 <br><br> 在整个故事中，术语“演员”和“代理人”将互换使用。 它们指定相同的内容，但是在SObjectizer中，术语“代理”在历史上一直使用，因此，更多的“代理”将被更频繁地使用。 <br><br><h2>  Pinger和Ponger的最简单示例 </h2><br> 演员Pinger和Ponger的例子可能是演员框架最常见的例子。 可以说是经典。 好吧，如果是这样，那么让我们从经典开始。 <br><br> 因此，我们有一个Pinger代理，在其工作开始时，它将Ping消息发送给Ponger代理。 然后，Ponger代理会发回Pong消息。 这就是C ++代码中的样子： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br> 我们的任务是编写一个测试，以验证在向SObjectizer注册这些代理后，Ponger将收到Ping消息，而Pinger将收到Pong消息作为响应。 <br><br> 好啦 我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">doctest</a>单元测试框架编写了这样的测试，并获得： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br> 这似乎很容易。 让我们看看这里发生了什么。 <br><br> 首先，我们下载代理测试支持工具的描述： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br> 所有这些工具都在so_5 ::实验::测试名称空间中进行了描述，但是为了不重复这么长的名称，我们引入了一个更简短，更方便的别名： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br> 以下是对单个测试用例的描述（此处我们不需要更多内容）。 <br><br> 在测试用例中，有几个关键点。 <br><br> 首先，这是为SObjectizer创建和启动一个特殊的测试环境： <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br> 没有这种环境，代理的“测试运行”将无法完成，但是稍后我们将讨论。 <br><br>  testing_env_t类与SObjectizer中的wrapped_env_t类非常相似。 同样，SObjectizer在构造函数中启动，在析构函数中停止。 因此，在编写测试时，您不必考虑启动和停止SObjectizer。 <br><br> 接下来，我们需要创建并注册Pinger和Ponger代理。 在这种情况下，我们需要使用这些代理来确定所谓的。  “测试方案。” 因此，我们分别存储指向代理的指针： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br> 然后，我们开始使用“测试方案”。 <br><br> 测试用例是由直接的步骤序列组成的部分，这些步骤必须从头到尾完成。 短语“来自直接序列”表示在SObjectizer-5.5.24中，脚本严格按顺序执行“工作”，没有任何分支或循环。 <br><br> 为代理编写测试是需要执行的测试脚本的定义。 即 从最开始到最后，测试方案的所有步骤都应该起作用。 <br><br> 因此，在我们的测试案例中，我们定义了一个两步方案。 第一步，验证Ponger代理将接收并处理Ping消息： <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br> 第二步检查Pinger代理是否收到Pong消息： <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br> 这两个步骤对于我们的测试用例已经足够了，因此，在确定了它们之后，我们继续执行脚本。 我们运行脚本，并允许其运行不超过100毫秒： <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br> 对于两个代理交换消息而言，一百毫秒应该绰绰有余（即使测试是在非常慢的虚拟机中运行的，例如Travis CI有时也是如此）。 好吧，如果我们在编写代理时犯了一个错误或错误地描述了一个测试脚本，那么等待一个错误脚本的完成超过100毫秒是没有意义的。 <br><br> 因此，从run_for（）返回之后，我们的脚本可以成功完成，也可以不成功完成。 因此，我们只需检查脚本的结果： <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br> 如果脚本未成功完成，则将导致我们的测试用例失败。 <br><br><h3> 一些说明和补充 </h3><br> 如果我们在普通的SObjectizer中运行以下代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br> 然后，很可能Pinger和Ponger代理将设法交换消息并完成工作，然后再从Introduction_coop返回（多线程的奇迹就是这样）。 但是在由testing_env_t创建的测试环境中，这种情况不会发生，Pinger和Ponger代理耐心地等待直到我们运行测试脚本。 这是怎么发生的？ <br><br> 事实是，在测试环境中，代理似乎处于冻结状态。 即 注册后，它们出现在SObjectizer中，但是它们无法处理任何消息。 因此，在运行测试脚本之前，甚至没有为代理调用so_evt_start（）。 <br><br> 当我们使用run_for（）方法运行测试脚本时，测试脚本首先会解冻所有冻结的代理。 然后，脚本开始从SObjectizer接收有关代理发生什么情况的通知。 例如，Ponger代理收到Ping消息，而Ponger代理处理了该消息，但没有拒绝它。 <br><br> 当此类通知开始出现在测试脚本中时，脚本会尝试将其“尝试”到第一步。 因此，我们收到了Ponger接收并处理了Ping的通知-对我们来说是否有趣？ 事实证明，这很有趣，因为该步骤的描述恰好说明了这一点：当Ponger对Ping做出反应时，它就起作用了。 我们在代码中看到的是： <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br> 好啦 因此，第一步成功了，请转到下一步。 <br><br> 接下来是一条通知，告知特工Pinger对Pong做出了反应。 这就是第二步工作所需的内容： <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br> 好啦 所以第二步成功了，我们还有其他东西吗？ 不行 这意味着整个测试脚本已完成，您可以从run_for（）返回控制。 <br><br> 原则上，这里是测试脚本的工作方式。 实际上，一切都有些复杂，但是当我们考虑一个更复杂的示例时，我们将涉及更复杂的方面。 <br><br><h2> 餐饮哲学家榜样 </h2><br> 在解决众所周知的任务“吃饭的哲学家”中，可以看到测试代理的更复杂的例子。 在演员上，可以通过多种方式解决此问题。 接下来，我们将考虑最简单的解决方案：演员和哲学家都以演员的形式代表，而哲学家必须为此而斗争。 每个哲学家思考了一会儿，然后尝试拿起左边的叉子。 如果成功，他将尝试在右边进行分叉。 如果成功，那么哲学家会吃上一段时间，然后放下叉子开始思考。 如果无法将插头插入右侧（即由另一位哲学家使用），则哲学家将插头返回左侧，并思考了更多时间。 即 从某种哲学家可能饿死太久的意义上来说，这不是一个好的解决方案。 但这很简单。 并具有证明代理商测试能力的范围。 <br><br> 可以在<a href="">此处</a>找到使用Fork和Philosopher代理实现的源代码，在本文中，我们不会将它们视为节省空间。 <br><br><h3> 测试叉 </h3><br> 餐饮哲学家对代理商的第一个测试将是对叉子的代理商。 <br><br> 该代理根据一个简单的方案工作。 他有两种状态：“自由”和“已采取”。 当代理处于“空闲”状态时，它会响应“接受”消息。 在这种情况下，代理将进入“已接受”状态，并以“已接受”响应消息进行响应。 <br><br> 座席处于“接受”状态时，它对“接受”消息的响应有所不同：座席的状态不变，并且“忙”作为响应消息发送。 同样在“采用”状态下，代理对“放置”消息作出响应：代理返回“空闲”状态。 <br><br> 在“释放”状态下，“放置”消息将被忽略。 <br><br> 我们将尝试通过以下测试案例来测试这一点： <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br> 有很多代码，因此我们将分部分处理，跳过那些本应清晰的片段。 <br><br> 我们需要做的第一件事是替换真正的Philosopher代理。  Fork代理必须从某人接收消息并作出响应。 但是我们不能在这个测试案例中使用真正的Philosopher，因为真正的Philosopher代理具有自己的行为逻辑，他自己发送消息，并且这种独立性会在这里干扰我们。 <br><br> 因此，我们进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模拟</a> ，即 我们将代替它来代替真正的哲学家：一个空代理，它本身不发送任何内容，而仅接收已发送的消息，而没有进行任何有用的处理。 这是在代码中实现的伪哲学家： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br> 接下来，我们从Fork代理和PseudoPhilospher代理创建协作，并开始确定测试用例的内容。 <br><br> 脚本的第一步是验证处于“空闲”状态（这是其初始状态）的“叉”是否不响应“放置”消息。 这是这种支票的写法： <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br> 引起注意的第一件事是冲击的构造。 <br><br> 需要她是因为我们的代理商Fork自己什么也不做，他只对收到的消息做出反应。 因此，有人应该向代理发送消息。 可是谁 <br><br> 但是脚本步骤本身会传递影响。 实际上，影响与通常的发送功能类似（格式相同）。 <br><br> 好吧，脚本步骤本身将通过影响发送消息。 但是他什么时候会做呢？ <br><br> 轮到他时，他会这样做。 即 如果脚本中的步骤是第一步，则在输入run_for之后立即执行影响。 如果脚本中的步骤不是第一步，则将在上一步执行后立即执行影响，脚本将继续处理下一步。 <br><br> 我们需要在这里讨论的第二件事是调用忽略。 此辅助函数表示，当代理处理消息时将触发该步骤。 即 在这种情况下，Fork代理必须拒绝处理Put消息。 <br><br> 让我们更详细地考虑测试场景的另一步骤： <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br> 首先，在这里我们看到when_all而不是when。 这是因为要触发一个步骤，我们需要立即满足多个条件。  fork代理需要处理Take。 哲学家需要处理“采取”的回应。 因此，我们编写when_all而不是when。 顺便说一下，还有when_any，但是在今天考虑的例子中我们将不与他见面。 <br><br> 其次，我们还需要检查以下事实：在执行Take处理后，Fork代理将处于Taken状态。 我们按以下方式进行验证：首先，我们指出，当Fork代理完成处理Take时，应使用标签标签“ fork”保存其当前状态的名称。 此构造仅保留代理的状态名称： <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br> 然后，当脚本成功完成时，我们检查此保存的名称： <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br> 即 我们询问脚本：给我们提供与fork标签一起保存的名称，名为步骤take_when_free，然后将其与期望值进行比较。 <br><br> 在这里，也许是Fork代理的测试用例中可以说明的所有内容。 如果读者有任何疑问，请在评论中提问，我们将很高兴为您解答。 <br><br><h3> 哲学家的成功脚本测试 </h3><br> 对于Philosopher代理，我们将仅考虑一个测试用例-对于Philosopher可以同时使用叉子和进餐的情况。 <br><br> 该测试用例将如下所示： <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br> 相当大，但微不足道。 首先，检查哲学家已经完成思考并开始准备食物。 然后我们检查他是否尝试过左叉。 接下来，他应该尝试拿正确的叉子。 然后他应该吃饭并停止这项活动。 然后他必须把两个叉子都拿走。 <br><br> 总的来说，一切都很简单。 但是您应该专注于两件事。 <br><br> 首先，testing_env_t类（如其原型wrapped_env_t）允许您自定义SObjectizer Environment。 我们将使用它来启用消息传递跟踪机制： <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br> 该机制使您可以“可视化”消息传递过程，这有助于调查代理行为（我们已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细讨论</a>过）。 <br><br> 其次，代理哲学家不是立即而是在一段时间后执行一系列动作。 因此，代理开始工作后，必须向自己发送未决的StopThinking消息。 因此，此消息应在几毫秒后到达代理。 我们通过为某个步骤设置必要的限制来表明这一点： <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br> 即 在这里，我们说我们对Philosopher代理对StopThinking的任何反应不感兴趣，而只对开始执行此步骤后不超过250毫秒的反应感兴趣。 <br><br>  not_before类型的限制告诉脚本，应忽略在指定的超时到期之前发生的所有事件。 <br><br> 还有一个形式为not_after的限制，它以另一种方式起作用：仅考虑在指定的超时时间到期之前发生的那些事件。 <br><br> 可以组合not_before和not_after约束，例如： <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br> 但是在这种情况下，SObjectizer不会检查给定值的一致性。 <br><br><h1> 您如何实现这一目标？ </h1><br> 我想谈一谈所有工作原理。 毕竟，总的来说，我们面临着一个重大的意识形态问题：“如何从原则上测试代理商？” 还有一个较小的问题，已经是技术性的：“如何实施？” <br><br> 而且，如果关于测试意识形态有可能会被您遗忘，那么对于实现而言，情况就更加复杂了。 有必要找到一种解决方案，该解决方案首先不需要对SObjectizer的内部进行彻底的更改。 其次，它被认为是可以在可预见且非常理想的短时间内实施的解决方案。 <br><br> 由于抽烟过程很困难，因此找到了解决方法。 为此，实际上只需要对SObjectizer的常规行为进行一次小的创新。 解决方案的基础是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消息信封机制，该机制已在5.5.23版本中添加，我们已经讨论过</a> 。 <br><br> 在测试环境中，每个发送的消息都包装在一个特殊的信封中。 当带有消息的信封被提供给代理进行处理（或者相反，被代理拒绝）时，测试方案就会意识到这一点。 多亏了这些信封，测试脚本才知道发生了什么，并可以确定脚本执行“工作”的时刻。 <br><br> 但是，如何使SObjectizer将每个消息包装在一个特殊的信封中？ <br><br> 这是一个有趣的问题。 他决定如下：发明了诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">event_queue_hook</a>的概念。 这是一个特殊的对象，具有两个方法-on_bind和on_unbind。 <br><br> 当代理绑定到特定的调度程序时，调度程序将代理event_queue分发给该代理。 通过此event_queue，对代理的请求进入必要的队列，并可供调度程序处理。 当代理在SObjectizer中运行时，它具有指向event_queue的指针。 从SObjectizer中删除代理后，指向event_queue的指针将无效。 <br><br> 因此，从5.5.24版开始，代理在收到event_queue时必须调用event_queue_hook的on_bind方法。 代理将接收到的指针传递给event_queue的位置。 并且event_queue_hook可以返回相同的指针或另一个指针作为响应。 并且代理必须使用返回的值。 <br><br> 从SObjectizer中删除代理后，它必须在event_queue_hook上调用on_unbind。 在on_unbind中，代理传递on_bind方法返回的值。 <br><br> 整个厨房在SObjectizer内部执行，用户看不到任何东西。 而且，原则上，您可能根本不知道这一点。 但是SObjectizer的测试环境（相同的testing_env_t）恰好利用了event_queue_hook。 在testing_env_t内部，创建了event_queue_hook的特殊实现。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on_bind中的此实现将每个event_queue包装在一个特殊的代理对象中。</font><font style="vertical-align: inherit;">并且此代理对象已经将发送到代理的消息放入一个特殊的信封中。</font></font><br><br> 但这还不是全部。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可能还记得，在测试环境中，必须冻结代理。</font><font style="vertical-align: inherit;">这也可以通过提到的代理对象来实现。</font><font style="vertical-align: inherit;">当测试脚本未运行时，代理对象会在家中存储发送给代理的消息。</font><font style="vertical-align: inherit;">但是，在运行脚本时，代理对象会将所有先前累积的消息传输到代理的当前消息队列。</font></font><br><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我想说两件事。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们实现了关于如何在SObjectizer中测试代理的观点。我的看法是因为周围没有那么多好的榜样。我们朝</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka.Testing看去</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是Akka和SObjectizer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">太不同了，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法将Akka中可用的方法移植到SObjectizer。而且C ++不是Scala / Java，其中与内省相关的某些事情可以通过反射来完成。因此，我不得不想出一种可以在SObjectizer上使用的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在5.5.24版中，第一个实验性实现可用。当然可以做得更好。但是，如何理解什么是有用的，什么是无用的幻想呢？不幸的是，什么都没有。您需要尝试一下，看看实际情况如何。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们制作了一个最低版本，您可以试用。我们建议为所有人做的事情：尝试，尝试并与我们分享您的印象。你喜欢什么，你不喜欢什么？也许缺少什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2017年初</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所说的话变得更加相关</font><font style="vertical-align: inherit;">：</font></font><br><blockquote> …       ,   ,   ,    .      -      —      .             .      . :  ,   . <br><br>    ,  ,   ,       —    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，对于那些正在寻找现成的演员框架的人，我的建议是：不仅要关注思想的原创性和实例的美感。</font><font style="vertical-align: inherit;">还要查看各种辅助性的东西，这些东西可以帮助您弄清应用程序中正在发生的事情：例如，找出现在有多少个actor，它们的队列大小是什么，如果消息没有到达接收者，那么它将去哪里……如果框架可以提供类似的东西，对您来说会更容易。</font><font style="vertical-align: inherit;">如果没有，那么您将有更多工作。</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当涉及到测试参与者时，以上所有这些都更加重要。</font><font style="vertical-align: inherit;">因此，在为自己选择一个参与者框架时，要注意其中的内容和没有的内容。</font><font style="vertical-align: inherit;">例如，我们已经在工具包中简化了测试：)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435606/">https://habr.com/ru/post/zh-CN435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435592/index.html">亚速尔群岛：大西洋中部的最后一个植物区系</a></li>
<li><a href="../zh-CN435594/index.html">Apache Camel的路由图</a></li>
<li><a href="../zh-CN435600/index.html">如何迁移到其他移动运营商而不会破产（适用于iOS所有者）</a></li>
<li><a href="../zh-CN435602/index.html">Azure考试准备</a></li>
<li><a href="../zh-CN435604/index.html">BlaBlaCar变成了原本不想要的东西</a></li>
<li><a href="../zh-CN435608/index.html">DIY屏幕</a></li>
<li><a href="../zh-CN435610/index.html">ZX Spectrum的复活节彩蛋-音乐专辑和电影中</a></li>
<li><a href="../zh-CN435612/index.html">相信科德还是您的设施？</a></li>
<li><a href="../zh-CN435614/index.html">Rust新闻＃4（2018年12月）</a></li>
<li><a href="../zh-CN435616/index.html">Peer Zoning如何简化我们的生活并帮助平衡EMC VPLEX的负载</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>