<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🔬 🛂 🤱🏻 Toute la vérité sur RTOS. Article # 26. Canaux: services auxiliaires et structures de données 🛥️ 🧑🏾‍🤝‍🧑🏽 🚵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous continuerons à considérer les canaux de transmission de données. 

 Services de support de canal 
 Nucleus RTOS dispose de quat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vérité sur RTOS. Article # 26. Canaux: services auxiliaires et structures de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433374/"><img src="https://habrastorage.org/webt/ok/ll/ke/okllkejturanltd2yqnjeofmqxu.jpeg"><br><br>  Dans cet article, nous continuerons à considérer les canaux de transmission de données. <br><br><h2>  Services de support de canal </h2><br>  Nucleus RTOS dispose de quatre appels d'API qui fournissent des fonctions auxiliaires liées aux canaux: réinitialisation d'un canal, récupération des informations de canal, récupération du nombre de canaux dans une application et récupération de pointeurs vers tous les canaux d'une application.  Les trois premières fonctions sont implémentées dans Nucleus SE. <br><a name="habracut"></a><br>  Articles précédents de la série: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de données: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boîtes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: services auxiliaires et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sémaphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'événements: services d'assistance et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'événements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de mémoire: services et structures de données</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de mémoire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de données de tâche et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches: configuration et introduction à l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalités avancées et préservation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: implémentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et déploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des tâches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps réel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br><br><h3>  Réinitialisation des canaux </h3><br>  Cet appel d'API réinitialise le canal à son état d'origine non utilisé.  Tous les messages qui y sont stockés seront perdus.  Toutes les tâches suspendues sur le canal reprennent avec le code retour <b>NUSE_PIPE_WAS_RESET</b> . <br><br>  <b><i>Appel de réinitialisation de canal dans Nucleus RTOS</i></b> <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NU_Reset_Pipe (NU_PIPE * pipe);</b> <br><br>  Paramètres: <br><br>  <b>pipe</b> - un pointeur vers un bloc de contrôle de canal défini par l'utilisateur. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_PIPE</b> - pointeur de canal invalide. <br><br>  <b><i>Défi de réinitialisation de canal dans Nucleus SE</i></b> <br><br>  Cet appel de service d'API prend en charge la fonctionnalité de base de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NUSE_Pipe_Reset (canal NUSE_PIPE);</b> <br><br>  Paramètres: <br><br>  <b>pipe</b> est l'index (ID) du <b>tuyau en cours de</b> suppression. <br><br>  Valeur de retour: <br><br>  <b>NUSE_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NUSE_INVALID_PIPE</b> - index de canal invalide. <br><br>  <b><i>Implémentation de réinitialisation de canal dans Nucleus SE</i></b> <br><br>  Le code de la fonction <b>NUSE_Pipe_Reset ()</b> (après vérification des paramètres) est assez simple.  Les indices de début et de fin du canal, ainsi que le compteur de messages dans le canal, sont définis sur 0. <br><br>  Si le verrouillage des tâches est activé, un code supplémentaire est responsable de la restauration des tâches suspendues: <br><br><pre><code class="plaintext hljs">while (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this pipe */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_PIPE_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Pipe_Blocking_Count[pipe]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Chaque tâche suspendue sur le canal se voit attribuer le statut «prêt» avec le code retour <b>NUSE_PIPE_WAS_RESET</b> .  Une fois ce processus terminé, si le planificateur de priorité est utilisé, la fonction <b>NUSE_Reschedule ()</b> est <b>appelée</b> , car une ou plusieurs tâches avec une priorité élevée peuvent être prêtes à être exécutées. <br><br><h3>  Infos sur la chaîne </h3><br>  Cet appel de service renvoie des informations sur le canal.  L'implémentation de cet appel dans Nucleus SE diffère de Nucleus RTOS en ce qu'il renvoie moins d'informations.  En effet, la dénomination des objets, les messages de longueur variable et l'ordre de pause des tâches ne sont pas pris en charge dans Nucleus SE et la pause des tâches peut être désactivée. <br><br>  <b><i>Appel pour des informations sur les canaux dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br><br>  <b>STATUS NU_Pipe_Information (NU_PIPE * pipe, CHAR * name, VOID ** start_address, UNSIGNED * pipe_size, UNSIGNED * available, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * tasks_waask **; first</b> <br><br>  Paramètres: <br><br>  <b>pipe</b> - pointeur vers le bloc de contrôle de canal fourni par l'utilisateur; <br>  <b>nom</b> - pointeur vers la zone de 8 caractères pour le nom du message du canal; <br>  <b>start_address</b> - un pointeur vers un pointeur dans lequel l'adresse du début de la zone de données de canal sera écrite; <br>  <b>pipe_size</b> - un pointeur vers une variable pour stocker le nombre total d'octets dans le canal; <br>  <b>available</b> - pointeur sur une variable pour stocker le nombre d'octets disponibles dans le canal; <br>  <b>messages</b> - un pointeur sur une variable pour stocker le nombre de messages dans le canal; <br>  <b>message_type</b> - un pointeur vers une variable pour stocker le type de message pris en charge par le canal.  Il peut prendre les valeurs <b>NU_FIXED_SIZE</b> et <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> - pointeur vers une variable pour stocker le nombre d'octets dans chaque message de canal.  Si le canal prend en charge les messages de longueur variable, ce nombre sera la taille maximale du message; <br>  <b>suspend_type</b> - un pointeur vers une variable pour stocker le type de tâche de suspension.  Il peut prendre les valeurs <b>NU_FIFO</b> et <b>NU_PRIORITY</b> ; <br>  <b>tasks_waiting</b> - un pointeur sur une variable pour stocker le nombre de tâches suspendues sur ce canal; <br>  <b>first_task</b> - un pointeur vers un pointeur vers la première tâche suspendue. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_PIPE</b> - pointeur de canal invalide. <br><br>  <b><i>Appelez pour obtenir des informations sur les chaînes dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalité principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NUSE_Pipe_Information (NUSE_PIPE pipe, ADDR * start_address, U8 * pipe_size, U8 * available, U8 * messages, U8 * message_size, U8 * tasks_waiting, NUSE_TASK * first_task);</b> <br><br>  Paramètres: <br><br>  <b>pipe</b> - index du canal, dont les informations sont demandées; <br>  <b>start_address</b> - pointeur vers une variable de type <b>ADDR</b> pour stocker l'adresse du début de la zone de données de canal; <br>  <b>pipe_size</b> - un pointeur vers une variable de type <b>U8</b> pour stocker le nombre total de messages que le canal peut recevoir; <br>  <b>disponible</b> - un pointeur sur une variable de type <b>U8</b> pour stocker le nombre de messages pour lesquels de l'espace libre est laissé dans le canal; <br>  <b>messages</b> - un pointeur vers une variable de type <b>U8</b> pour stocker le nombre actuel de messages dans le canal; <br>  <b>message_size</b> - pointeur vers une variable de type <b>U8</b> pour stocker la taille des messages traités par ce canal; <br>  <b>tasks_waiting</b> - un pointeur sur une variable pour stocker le nombre de tâches suspendues sur ce canal (rien n'est retourné si la suspension des tâches est désactivée); <br>  <b>first_task</b> - un pointeur vers une variable de type <b>NUSE_TASK</b> , qui prendra l'index de la première tâche suspendue (rien n'est retourné si la suspension de la tâche est désactivée). <br><br>  Valeur de retour: <br><br>  <b>NUSE_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NUSE_INVALID_PIPE</b> - index de canal invalide; <br>  <b>NUSE_INVALID_POINTER</b> - un ou plusieurs paramètres de pointeur sont incorrects. <br><br>  <b><i>Implémentation des informations de canal dans Nucleus SE</i></b> <br><br>  L'implémentation de cet appel d'API est assez simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Pipe_Data[pipe]; *pipe_size = NUSE_Pipe_Size[pipe]; *available = NUSE_Pipe_Size[pipe] - NUSE_Pipe_Items[pipe]; *messages = NUSE_Pipe_Items[pipe]; *message_size = NUSE_Pipe_Message_Size[pipe]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Pipe_Blocking_Count[pipe]; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La fonction renvoie l'état du canal.  Ensuite, si les verrous de tâche sont activés, le nombre de tâches en attente et l'index de la première d'entre elles sont renvoyés (sinon, ces deux paramètres sont définis sur 0). <br><br><h3>  Obtenir le nombre de canaux </h3><br>  Cet appel de service renvoie le nombre de canaux configurés dans l'application.  Dans Nucleus RTOS, cette valeur peut changer avec le temps et la valeur de retour indiquera le nombre actuel de canaux.  Dans Nucleus SE, la valeur de retour est définie pendant la phase de génération et ne peut pas être modifiée. <br><br>  <b><i>Appel à un compteur de canaux dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br><br>  <b>UNSIGNED NU_Established_Pipes (VOID);</b> <br><br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de canaux créés dans le système. <br><br>  <b><i>Appel à un compteur de canaux dans Nucleus SE</i></b> <br>  Cet appel d'utilitaire prend en charge les fonctionnalités de base de l'API RTOS Nucleus <br><br>  Prototype d'appel de service: <br>  <b>U8 NUSE_Pipe_Count (void);</b> <br><br>  Paramètres: <br>  Sont absents. <br><br>  Valeur de retour: <br>  Le nombre de canaux configurés dans l'application. <br><br>  <b><i>Implémentation d'un compteur de canaux dans Nucleus SE</i></b> <br>  L'implémentation de cet appel API est assez simple: la valeur du symbole <b>#define</b> <b>NUSE_PIPE_NUMBER</b> est <b>retournée</b> . <br><br><h2>  Structures de données </h2><br>  Les canaux utilisent six ou sept structures de données (qui sont soit en RAM ou en ROM), qui sont (comme les autres objets Nucleus SE) un ensemble de tables, dont la taille et le nombre correspondent au nombre de canaux configurés et à leurs paramètres. <br><br>  Je recommande fortement que le code d'application n'utilise pas un accès direct à ces structures de données, mais s'y réfère via les fonctions API fournies.  Cela évitera l'incompatibilité avec les futures versions de Nucleus SE et les effets secondaires indésirables, ainsi que simplifiera le portage des applications vers Nucleus RTOS.  Voici un aperçu détaillé des structures de données pour simplifier la compréhension des appels de service et du code de débogage. <br><br><h3>  Données du noyau dans la RAM </h3><br>  Ces données ont la structure suivante: <br><br>  <b>NUSE_Pipe_Head []</b> est un tableau de pointeurs de type <b>U8</b> , ayant une entrée pour chaque canal configuré et indiquant le début du canal de message.  Utilisé comme index d'adresse dans <b>NUSE_Pipe_Data []</b> (voir ci-dessous). <br>  <b>NUSE_Pipe_Tail []</b> est un tableau <b>U8</b> qui a une entrée pour chaque canal configuré et pointe vers la fin du canal de message.  Utilisé comme index d'adresse dans <b>NUSE_Pipe_Data []</b> (voir ci-dessous). <br>  <b>NUSE_Pipe_Items []</b> est un tableau de type <b>U8</b> , qui a une entrée pour chaque canal configuré et est un compteur du nombre actuel de messages dans le canal.  Ces données sont redondantes, car cette valeur peut être obtenue via les indices de début et de fin de canal, mais la présence d'un compteur simplifie le code. <br>  <b>NUSE_Pipe_Blocking_Count []</b> - ce tableau de type <b>U8</b> contient des compteurs du nombre de tâches bloquées sur chaque canal.  Ce tableau est créé uniquement si la prise en charge du verrouillage des tâches est activée. <br><br>  Toutes ces structures de données sont initialisées avec des zéros par la fonction <b>NUSE_Init_Pipe () au</b> démarrage de Nucleus SE.  C'est logique, car tous les canaux sont créés vides (inutilisés).  L'un des articles suivants contiendra une description complète des procédures de démarrage de Nucleus SE. <br><br>  Voici les définitions de ces structures de données dans le fichier <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Pipe_Head[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Tail[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Items[NUSE_PIPE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Pipe_Blocking_Count[NUSE_PIPE_NUMBER]; #endif</code> </pre><br><h3>  Données utilisateur RAM </h3><br>  Il est de la responsabilité de l'utilisateur de fournir une zone de données en RAM pour stocker les données de chaque canal configuré.  La taille de cette zone doit contenir un tableau de type <b>U8</b> , dans lequel tous les messages de canal s'adapteront. <br><br><h3>  Données ROM </h3><br>  La structure de ces données est la suivante: <br><br>  <b>NUSE_Pipe_Data []</b> est un tableau de type <b>ADDR</b> qui a un enregistrement pour chaque canal configuré et indique la zone de données de chaque canal (voir la section "Données utilisateur en RAM" ci-dessus). <br>  <b>NUSE_Pipe_Size []</b> est un tableau de type <b>U8</b> , ayant une entrée pour chaque canal configuré et indiquant le nombre de messages pouvant tenir dans chaque canal. <br>  <b>NUSE_Pipe_Message_Size []</b> est un tableau de type <b>U8</b> qui a un enregistrement pour chaque canal configuré et montre la taille des messages (en octets) qui peuvent être placés sur chaque canal. <br><br>  Ces structures de données sont déclarées et initialisées (statiquement) dans le fichier <b>nuse_config.c</b> , ainsi: <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Pipe_Data[NUSE_PIPE_NUMBER] = { /* addresses of pipe data areas ------ */ }; ROM U8 NUSE_Pipe_Size[NUSE_PIPE_NUMBER] = { /* pipe sizes ------ */ }; ROM U8 NUSE_Pipe_Message_Size[NUSE_PIPE_NUMBER] = { /* pipe message sizes ------ */ };</code> </pre><br><h3>  Mémoire des canaux </h3><br>  Comme tous les autres objets principaux de Nucleus SE, la quantité de mémoire nécessaire pour les canaux est prévisible. <br><br>  La quantité de données dans la ROM (en octets) pour tous les canaux de l'application peut être calculée comme suit: <br><br>  <b>NUSE_PIPE_NUMBER * (taille de (ADDR) + 2)</b> <br><br>  La quantité de données du noyau dans la RAM (en octets) pour tous les canaux d'application lorsque les tâches sont activées peut être calculée comme suit: <br><br>  <b>NUSE_PIPE_NUMBER * 4</b> <br><br>  Sinon: <br><br>  <b>NUSE_PIPE_NUMBER * 3</b> <br><br>  La quantité de données utilisateur en RAM (en octets) pour le canal avec l'index de <b>canal</b> : <br><br>  <b>NUSE_Pipe_Size [pipe] * NUSE_Pipe_Message_Size [pipe]</b> <br><br><h2>  Appels d'API non réalisés </h2><br>  Quatre appels de service API Nucleus RTOS ne sont pas implémentés dans Nucleus SE. <br><br><h3>  Création de chaîne </h3><br>  Cet appel API crée un canal.  Nucleus SE n'en a pas besoin car les canaux sont créés statiquement. <br><br>  Prototype d'appel de service: <br><br>  <b>STATUS NU_Create_Pipe (NU_PIPE * pipe, CHAR * name, VOID * start_address, UNSIGNED pipe_size, OPTION message_type, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Paramètres: <br><br>  <b>pipe</b> - un pointeur vers le bloc de contrôle de canal fourni par l'utilisateur; il sera utilisé comme activateur de canal principal dans d'autres appels d'API; <br>  <b>nom</b> - pointeur vers un nom de canal à 7 caractères avec un zéro de fin; <br>  <b>start_address</b> - adresse de début de canal; <br>  <b>pipe_size</b> - le nombre total d'octets dans le canal; <br>  <b>message_type</b> - type de message pris en charge par le canal.  Il peut prendre les valeurs <b>NU_FIXED_SIZE</b> ou <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> - si le canal prend en charge les messages de longueur fixe, ce paramètre indique la taille exacte de chaque message.  Sinon, si le canal prend en charge les messages de longueur variable, cette valeur sera la taille maximale du message; <br>  <b>suspend_type</b> - Indique le type de suspension de tâche sur le canal.  Il peut prendre les valeurs <b>NU_FIFO</b> et <b>NU_PRIORITY</b> (ordonnanceur FIFO et ordonnanceur <b>PRIORITY</b> , respectivement). <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_PIPE</b> - pointeur nul vers l'unité de contrôle de canal ( <b>NULL</b> ), ou l'unité de contrôle est déjà en cours d'utilisation; <br>  <b>NU_INVALID_MEMORY</b> - une zone de données incorrecte a été spécifiée dans <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - paramètre de type de <b>message</b> non valide; <br>  <b>NU_INVALID_SIZE</b> - soit la taille du message est supérieure à la taille du canal, soit la taille du canal ou du message est nulle; <br>  <b>NU_INVALID_SUSPEND</b> - paramètre <b>suspend_type</b> non <b>valide</b> . <br><br><h3>  Supprimer la chaîne </h3><br>  Cet appel d'API supprime un canal créé précédemment.  Nucleus SE n'en a pas besoin car les canaux sont créés statiquement et ne peuvent pas être supprimés. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Delete_Pipe (NU_PIPE * pipe);</b> <br><br>  Paramètres: <br>  <b>pipe</b> - un pointeur vers un bloc de contrôle de canal. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_PIPE</b> - pointeur de canal invalide. <br><br><h3>  Pointeurs de canal </h3><br>  Cet appel API crée une liste séquentielle de pointeurs vers tous les canaux du système.  Dans Nucleus SE, ce n'est pas nécessaire, car les canaux sont identifiés par un simple index, pas un pointeur, par conséquent, une telle fonction serait redondante. <br><br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Pipe_Pointers (NU_PIPE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Paramètres: <br>  <b>pointer_list</b> - un pointeur vers un tableau de pointeurs <b>NU_PIPE</b> .  Ce tableau sera rempli de pointeurs vers des canaux précédemment créés dans le système; <br>  <b>pointeurs maximum</b> - le nombre maximum de pointeurs dans le tableau. <br><br>  Valeur de retour: <br>  Le nombre de pointeurs <b>NU_PIPE</b> dans le tableau <br><br><h3>  Diffusion sur une chaîne </h3><br>  Cet appel d'API transmet le message à toutes les tâches en attente de messages provenant d'un canal spécifique.  Dans Nucleus SE, cette fonctionnalité n'a pas été implémentée car elle ajoute une complexité redondante. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Broadcast_To_Pipe (canal NU_PIPE *, message VOID *, taille UNSIGNED, suspension UNSIGNED);</b> <br><br>  Paramètres: <br>  <b>pipe</b> - un pointeur vers un bloc de contrôle de canal; <br>  <b>message</b> - pointeur vers le message transmis; <br>  <b>size</b> - le nombre d'éléments de données <b>UNSIGNED</b> dans le message.  Si le canal prend en charge les messages de longueur variable, ce paramètre doit être égal ou inférieur à la taille du message pris en charge par le canal.  Si le canal prend en charge les messages de longueur fixe, ce paramètre doit être exactement égal à la taille des messages pris en charge par le canal; <br>  <b>suspend</b> - indique s'il faut suspendre la tâche appelante si le canal est déjà plein.  Il peut s'agir de <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> ou d'une valeur de délai d'expiration. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est terminé avec succès; <br>  <b>NU_INVALID_PIPE</b> - pointeur non valide vers le canal; <br>  <b>NU_INVALID_POINTER</b> - pointeur nul vers un message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - la taille de message spécifiée est incompatible avec la taille de message spécifiée lors de la création du canal; <br>  <b>NU_INVALID_SUSPEND</b> - tentative de suspension à partir d'un thread non lié à une tâche; <br>  <b>NU_PIPE_FULL</b> - il n'y a pas assez d'espace dans le canal pour le message; <br>  <b>NU_TIMEOUT</b> - le canal est toujours plein, même après l'expiration du délai spécifié; <br>  <b>NU_PIPE_DELETED</b> - le canal a été supprimé alors que la tâche a été suspendue; <br>  <b>NU_PIPE_RESET</b> - Le canal a été réinitialisé alors que la tâche était suspendue. <br><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Comme pour tous les autres objets Nucleus SE, mon objectif était de maximiser la compatibilité du code d'application avec Nucleus RTOS.  Les canaux ne font pas exception et, du point de vue de l'utilisateur, ils sont implémentés de la même manière que dans Nucleus RTOS.  Il y a aussi une certaine incompatibilité, que j'ai jugée acceptable, étant donné que le code deviendra ainsi plus compréhensible et plus efficace en termes de quantité de mémoire requise.  Sinon, les appels d'API Nucleus RTOS peuvent être portés presque directement vers Nucleus SE. <br><br><h3>  Identificateurs d'objet </h3><br>  Dans Nucleus RTOS, tous les objets sont décrits par une structure de données (bloc de contrôle) qui a un type de données spécifique.  Un pointeur vers cette unité de contrôle sert d'identifiant de canal.  J'ai décidé que dans Nucleus SE, une approche différente est nécessaire pour une utilisation efficace de la mémoire: tous les objets du noyau sont décrits par un ensemble de tables en RAM et / ou ROM.  La taille de ces tables est déterminée par le nombre d'objets configurés de chaque type.  L'identifiant d'un objet particulier est l'index dans ce tableau.  J'ai donc défini <b>NUSE_PIPE</b> comme l'équivalent de <b>U8</b> , une variable (pas un pointeur) de ce type sert d'identifiant de canal.  Cette légère incompatibilité est facile à gérer si le code est porté de Nucleus SE vers Nucleus RTOS et vice versa.  En règle générale, aucune opération n'est effectuée sur les identificateurs d'objet autres que le déplacement et le stockage. <br><br>  Nucleus RTOS prend également en charge la dénomination des canaux.  Ces noms sont utilisés uniquement pour le débogage.  Je les ai exclus de Nucleus SE pour économiser de la mémoire. <br><br><h3>  Taille et type du message </h3><br>  Dans Nucleus RTOS, un canal peut être configuré pour traiter des messages composés d'un nombre arbitraire d'octets, tout comme Nucleus SE.  Nucleus RTOS prend également en charge les canaux de messages de longueur variable pour lesquels seule la taille maximale des messages est spécifiée au moment de la création.  Les messages de longueur variable ne sont pas pris en charge dans Nucleus SE. <br><br><h3>  Taille du canal </h3><br>  Dans Nucleus SE, le nombre maximal de messages par canal est de 256, car toutes les variables et constantes sont de type <b>U8</b> .  Nucleuts RTOS n'a pas de telles limitations. <br><br><h3>  Appels d'API non réalisés </h3><br>  Nucleus RTOS prend en charge les frais généraux de dix canaux.  Quatre d'entre eux ne sont pas implémentés dans Nucleus SE.  Une description détaillée de ces appels, ainsi que les raisons de cette décision, se trouvent dans la section «Appels d'API non réalisés» plus haut dans cet article. <br><br>  Dans l'article suivant, nous considérerons l'heure système. <br><br>  <b>À propos de l'auteur:</b> Colin Walls travaille dans l'industrie électronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ingénieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de conférences et séminaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433374/">https://habr.com/ru/post/fr433374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433364/index.html">LDraw + Unity. Comment j'ai généré Lego</a></li>
<li><a href="../fr433366/index.html">Utilisation de ressources externes dans Unity3D</a></li>
<li><a href="../fr433368/index.html">Comment appliquer la pensée épicerie au monde: un exemple de sweat-shirt</a></li>
<li><a href="../fr433370/index.html">Théorie du sharding</a></li>
<li><a href="../fr433372/index.html">Vélo de voiture</a></li>
<li><a href="../fr433376/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 1</a></li>
<li><a href="../fr433378/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 2</a></li>
<li><a href="../fr433380/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 3</a></li>
<li><a href="../fr433382/index.html">[Illustré] Guide de mise en réseau dans Kubernetes. 3e partie</a></li>
<li><a href="../fr433384/index.html">Nos données personnelles sont toujours vendues effrontément</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>