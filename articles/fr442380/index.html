<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙃 💃 👷 Sort Chaos 🚣🏻 💓 🥨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme le montre la pratique, une grande partie des problèmes ne se posent pas à cause des solutions elles-mêmes, mais à cause de la façon dont la comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sort Chaos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442380/"><p> Comme le montre la pratique, une grande partie des problèmes ne se posent pas à cause des solutions elles-mêmes, mais à cause de la façon dont la communication entre les composants du système se produit.  S'il y a un gâchis dans la communication entre les composants du système, alors, comme vous n'essayez pas de bien écrire les composants individuels, le système dans son ensemble échouera. </p><br><p>  Attention  À l'intérieur du vélo. </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi">  Problème ou énoncé du problème </h1><br><p>  Il y a quelque temps, il est arrivé de travailler sur un projet pour une entreprise qui apporte aux masses des délices tels que le CRM, les systèmes ERM et les dérivés.  En outre, la société a publié un produit assez complet, du logiciel pour les caisses enregistreuses au centre d'appels, avec la possibilité de louer des opérateurs jusqu'à 200 âmes. </p><br><p>  J'ai moi-même travaillé sur une application front-end de call-center. </p><br><p>  Il est facile d’imaginer que ce sont les informations de tous les composants du système qui circulent dans l’application de l’opérateur.  Et si nous prenons en compte le fait qu'il ne s'agit pas d'un seul opérateur, mais également d'un gestionnaire et d'un administrateur, alors vous pouvez imaginer la quantité de communication et d'informations que l'application doit «digérer» et relier les unes aux autres. </p><br><p>  Lorsque le projet était déjà lancé et fonctionnait même de manière assez stable pour lui-même, le problème de la transparence du système se posait dans toute sa croissance. </p><br><p>  Voilà le point.  Il existe de nombreux composants et ils fonctionnent tous avec leurs sources de données.  Mais presque tous ces composants ont déjà été écrits en tant que produits autonomes.  Ce n'est pas en tant qu'élément du système global, mais en tant que décisions distinctes à vendre.  En conséquence, il n'y a pas d'API (système) unique et pas de normes de communication communes entre elles. </p><br><p>  Je vais vous expliquer.  Certains composants envoient du JSON, «quelqu'un» envoie des lignes avec la clé: value inside, «quelqu'un» envoie le binaire en général et faites ce que vous voulez avec.  Mais, et la demande finale pour le centre d'appels devait obtenir tout cela et le traiter d'une manière ou d'une autre.  Eh bien et surtout, il n'y avait aucun lien dans le système qui pouvait reconnaître que le format / la structure des données avait changé.  Si un composant a envoyé JSON hier et a décidé aujourd'hui d'envoyer du binaire - personne ne le verra.  Seule l'application finale commencera à planter comme prévu. </p><br><p>  Il est vite devenu évident (pour ceux qui m'entouraient, pas pour moi, car j'avais parlé du problème au stade de la conception) que l'absence d'un «langage de communication unifié» entre les composants entraînait de graves problèmes. </p><br><p>  Le cas le plus simple est lorsque le client a demandé de modifier un ensemble de données.  Ils annulent la tâche au jeune homme qui «détient» le composant pour travailler avec des bases de données de biens / services, par exemple.  Il fait son travail, implémente un nouvel ensemble de données, et pour lui, connard, tout fonctionne.  Mais, le lendemain de la mise à jour ... oh ... l'application du centre d'appels commence soudainement à ne pas fonctionner comme prévu. </p><br><p>  Vous l'avez probablement déjà deviné.  Notre héros a changé non seulement l'ensemble de données, mais aussi la structure de données que son composant envoie au système.  En conséquence, l'application de centre d'appels n'est tout simplement plus en mesure de travailler avec ce composant, et d'autres dépendances volent le long de la chaîne. </p><br><p>  Ils ont commencé à réfléchir à ce que nous voulons en fait sortir.  En conséquence, nous avons formulé les exigences suivantes pour une solution potentielle: </p><br><p>  <strong>D'abord</strong> et avant tout: tout changement dans la structure des données doit être immédiatement «mis en évidence» dans le système.  Si quelqu'un a apporté des modifications quelque part et que ces modifications sont incompatibles avec les attentes du système, une erreur doit se produire lors de la phase de test des composants, qui a été modifiée. </p><br><p>  <strong>Le deuxième</strong> .  Les types de données doivent être vérifiés non seulement lors de la compilation, mais également lors de l'exécution. </p><br><p>  <strong>Le troisième</strong> .  Étant donné qu'un grand nombre de personnes ayant des niveaux de compétence complètement différents travaillent sur des composants, le langage de description devrait être plus simple. </p><br><p>  <strong>Quatrièmement</strong> .  Quelle que soit la solution, il devrait être aussi pratique que possible de travailler avec elle.  Si possible, l'IDE doit mettre en évidence autant que possible. </p><br><p>  La première pensée a été d'implémenter protobuf.  Simple, lisible et facile.  Saisie stricte des données.  Il semble que ce soit ce que le médecin a ordonné.  Mais hélas, toute la syntaxe du protobuf ne semblait pas simple.  De plus, même le protocole compilé nécessitait une bibliothèque supplémentaire, mais Javascript n'était pas pris en charge par protobuf et était le résultat d'un travail communautaire.  En général, ils ont refusé. </p><br><p>  Puis l'idée est venue de décrire le protocole en JSON.  Eh bien, combien plus facile? </p><br><p>  Eh bien, je quitte.  Et à ce sujet, ce poste aurait pu être achevé, car après mon départ, personne d'autre n'a commencé à traiter le problème de manière particulièrement étroite. </p><br><p>  Cependant, étant donné quelques projets personnels où la question de la communication entre les composants a de nouveau atteint son plein potentiel, j'ai décidé de commencer à mettre en œuvre l'idée par moi-même.  Ce qui sera discuté ci-dessous. </p><br><p>  Je présente donc à votre attention le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres</a> , qui comprend: </p><br><ul><li>  générateur de protocole </li><li>  fournisseur </li><li>  le client </li><li>  mise en place de transports </li></ul><br><h1 id="protokol">  Protocole </h1><br><p>  La tâche était de faire en sorte que: </p><br><ul><li>  il était facile de définir la structure des messages dans le système. </li><li>  il était facile de déterminer le type de données de tous les champs de message. </li><li>  il a été possible de définir des entités auxiliaires et de s'y référer. </li><li>  et bien sûr, pour que tout cela soit mis en évidence par l'IDE </li></ul><br><p>  Je pense que d'une manière tout à fait naturelle, en tant que langue dans laquelle le protocole est converti, Typescript a été choisi non pas en pur Javascript.  Autrement dit, tout ce que fait le générateur de protocole est de transformer JSON en Typescript. </p><br><p>  Pour décrire les messages disponibles dans le système, il vous suffit de savoir ce qu'est JSON.  Avec qui, je suis sûr que personne n'a de problème. </p><br><p>  Au lieu de Hello World, je vous propose un exemple non moins galvaudé - le chat. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Tout est incroyablement simple.  Nous avons quelques événements NewMessage et UsersListUpdated;  ainsi que quelques requêtes UsersList et AddUserResult.  Il existe deux autres entités: ChatMessage et User. </p><br><p>  Comme vous pouvez le voir, la description est assez transparente et compréhensible.  Un peu sur les règles. </p><br><ul><li>  Un objet en JSON deviendra une classe dans le protocole généré </li><li>  La valeur de la propriété est une définition de type de données ou une référence à une classe (entité) </li><li>  Du point de vue du protocole généré, les objets imbriqués deviendront des classes "imbriquées", c'est-à-dire que les objets imbriqués hériteront de toutes les propriétés de leurs parents. </li></ul><br><p>  Il ne vous reste plus qu'à générer un protocole pour commencer à l'utiliser. </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p>  En conséquence, nous obtenons un protocole généré par Typescript.  Nous connectons et utilisons: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="image"><br><p>  Ainsi, le protocole donne déjà quelque chose au développeur: </p><br><ul><li>  L'IDE met en évidence ce que nous avons dans le protocole.  L'IDE met également en évidence toutes les propriétés attendues. </li><li>  Type de script, qui nous dira certainement si quelque chose ne va pas avec les types de données.  Bien sûr, cela se fait au stade du développement, mais le protocole lui-même vérifiera déjà les types de données au moment de l'exécution et lèvera une exception si une violation est détectée </li><li>  En général, vous pouvez oublier la validation.  Le protocole fera toutes les vérifications nécessaires. </li><li>  Le protocole généré ne nécessite aucune bibliothèque supplémentaire.  Tout ce dont il a besoin pour travailler, il le contient déjà.  Et c'est très pratique. </li></ul><br><blockquote>  Oui, la taille du protocole généré peut vous surprendre, c'est le moins qu'on puisse dire.  Mais n'oubliez pas la minification à laquelle le fichier de protocole généré se prête bien. </blockquote><p>  Maintenant, nous pouvons "emballer" le message et l'envoyer </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p>  Il est important de faire une réservation ici, le paquet sera un tableau d'octets, ce qui est très bon et correct du point de vue de la charge de trafic, car envoyer les mêmes "coûts" JSON, bien sûr, plus chers.  Cependant, le protocole a une fonctionnalité - en mode débogage, il générera un JSON lisible afin que le développeur puisse «regarder» le trafic et voir ce qui se passe. </p><br><p>  Cela se fait directement au moment de l'exécution. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p>  Sur le serveur (ou tout autre destinataire), nous pouvons facilement décompresser le message: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p>  Le protocole prend en charge tous les principaux types de données: </p><br><table><thead><tr><th>  Tapez </th><th>  Les valeurs </th><th>  La description </th><th>  Taille, octets </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  Chaîne codée UTF8 </td><td>  x </td></tr><tr><td>  asciiString </td><td></td><td>  chaîne ascii </td><td>  1 caractère - 1 octet </td></tr><tr><td>  int8 </td><td>  -128 à 127 </td><td></td><td>  1 </td></tr><tr><td>  int16 </td><td>  -32768 à 32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648 à 2147483647 </td><td></td><td>  4 </td></tr><tr><td>  uint8 </td><td>  0 à 255 </td><td></td><td>  1 </td></tr><tr><td>  uint16 </td><td>  0 à 65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0 à 4294967295 </td><td></td><td>  4 </td></tr><tr><td>  float32 </td><td>  1,2x10 <sup>-38</sup> à 3,4x10 <sup>38</sup> </td><td></td><td>  4 </td></tr><tr><td>  float64 </td><td>  5,0x10 <sup>-324</sup> à 1,8x10 <sup>308</sup> </td><td></td><td>  8 </td></tr><tr><td>  booléen </td><td></td><td></td><td>  1 </td></tr></tbody></table><br><p>  Dans le protocole, ces types de données sont appelés primitifs.  Cependant, une autre caractéristique du protocole est qu'il vous permet d'ajouter vos propres types de données (appelés "types de données supplémentaires"). </p><br><p>  Par exemple, vous avez probablement déjà remarqué que <strong>ChatMessage</strong> a un champ <strong>créé</strong> avec un type de données <strong>datetime</strong> .  Au niveau de l'application - ce type correspond à <strong>Date</strong> , et à l'intérieur du protocole est stocké (et envoyé) en tant que <strong>uint32</strong> . </p><br><p>  Ajouter votre type au protocole est assez simple.  Par exemple, si nous voulons avoir un type de données <strong>e-mail</strong> , disons pour le message suivant dans le protocole: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Tout ce que vous avez à faire est d'écrire une définition du type d'e-mail. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p>  C’est tout.  En générant le protocole, nous obtenons la prise en charge du nouveau type de données de <strong>messagerie</strong> .  Lorsque nous essayons de créer une entité avec la mauvaise adresse, nous obtenons une erreur </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p>  Oh ... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p>  Ainsi, le protocole n'autorise tout simplement pas les «mauvaises» données dans le système. </p><br><p>  Notez que lors de la définition d'un nouveau type de données, nous avons spécifié quelques propriétés clés: </p><br><ul><li>  <strong>binaryType</strong> - une référence à un type de données primitif qui doit être utilisé pour stocker, encoder / décoder des données.  Dans ce cas, nous indiquons que l'adresse est une chaîne ascii. </li><li>  <strong>tsType</strong> est une référence au type Javascript, c'est-à-dire comment le type de données doit être représenté dans l'environnement Javascript.  Dans ce cas, nous parlons de <strong>chaîne</strong> </li><li>  Il convient également de noter que nous devons définir un nouveau type de données uniquement au moment de la génération du protocole.  En sortie, nous obtenons un protocole généré qui contient déjà un nouveau type de données. </li></ul><br><blockquote>  Vous pouvez voir des informations détaillées sur toutes les fonctionnalités du protocole ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.protocol</a> . </blockquote><br><h1 id="provayder-i-klient">  Fournisseur et client </h1><br><p>  Dans l'ensemble, le protocole lui-même peut être utilisé pour organiser la communication.  Cependant, si nous parlons du navigateur et de nodejs, le fournisseur et le client sont disponibles. </p><br><h2 id="klient">  Client </h2><br><h3 id="sozdanie">  La création </h3><br><p>  Pour créer un client, vous avez besoin du client et du transport. </p><br><p>  L'installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p>  La création </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote>  Le client, ainsi que le fournisseur, sont conçus spécifiquement pour le protocole.  Autrement dit, ils ne fonctionneront qu'avec le protocole (ceres.protocol). </blockquote><br><h3 id="sobytiya">  Les événements </h3><br><p>  Une fois le client créé, le développeur peut s'abonner aux événements </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Veuillez noter que le client n'appellera le gestionnaire d'événements que si les données du message sont complètement correctes.  En d'autres termes, notre application est protégée contre les données incorrectes et le <strong>gestionnaire d'</strong> événements <strong>NewMessage</strong> sera toujours appelé avec une instance de <strong>Protocol.Events.NewMessage</strong> comme argument. </p><br><p>  Naturellement, le client peut générer des événements. </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Notez que nous ne spécifions aucun nom d'événement nulle part, nous utilisons simplement un lien vers la classe à partir du protocole, ou passons une instance de celui-ci. </p><br><p>  Nous pouvons également envoyer un message à un groupe limité de destinataires en spécifiant un simple objet de type <code>{ [key: string]: string }</code> comme deuxième argument.  Dans ceres, cet objet est appelé <strong>requête</strong> . </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Ainsi, en indiquant en plus <code>{ location: "UK" }</code> , nous pouvons être sûrs que seuls les clients qui ont identifié leur position comme UK recevront ce message. </p><br><p>  Pour associer le client lui-même à une <strong>requête</strong> spécifique, il suffit d'appeler la méthode <strong>ref</strong> : </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p>  Après avoir connecté le client à la <strong>requête</strong> , il a la possibilité de recevoir des messages "personnels" ou "de groupe". </p><br><h3 id="zaprosy">  Demandes </h3><br><p>  Nous pouvons également faire des demandes </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Il convient de noter qu'en tant que deuxième argument, nous spécifions le résultat attendu ( <strong>Protocol.Responses.UsersList</strong> ), ce qui signifie que notre demande ne sera menée à bien que si la réponse est une instance de <strong>UsersList</strong> , dans tous les autres cas, nous «tomberons» sur attraper  Encore une fois, cela nous empêche de traiter des données incorrectes. </p><br><p>  Le client lui-même peut également parler à ceux qui peuvent traiter les demandes.  Pour ce faire, il vous suffit de vous "identifier" comme "responsable" de la demande. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Notez, facultativement, que le troisième argument, nous pouvons spécifier un objet de <strong>requête</strong> qui peut être utilisé pour identifier le client.  Ainsi, si quelqu'un envoie une requête avec une <strong>requête</strong> , disons <code>{ location: "RU" }</code> , alors notre client ne recevra pas une telle requête, car sa requête <code>{ location: "UK" }</code> . </p><br><p>  Une <strong>requête</strong> peut inclure un nombre illimité de propriétés.  Par exemple, vous pouvez spécifier les éléments suivants </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p>  Ensuite, en plus d'une correspondance de <strong>requête</strong> complète, nous traiterons également avec succès les requêtes suivantes: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p>  ou </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder">  Fournisseur </h2><br><h3 id="sozdanie-1">  La création </h3><br><p>  Pour créer un fournisseur (ainsi que pour créer un client), vous avez besoin du fournisseur et du transport. </p><br><p>  L'installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p>  La création </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p>  À partir du moment où le fournisseur est créé, il peut accepter les connexions des clients. </p><br><h3 id="sobytiya-1">  Les événements </h3><br><p>  En plus du client, le fournisseur peut "écouter" les messages et les générer. </p><br><p>  Écoute </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p>  Générer </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1">  Demandes </h3><br><p>  Naturellement, le fournisseur peut (et devrait) «écouter» les demandes </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Il n'y a qu'une seule différence par rapport au client, le fournisseur en plus du corps de la demande recevra un <strong>clientId</strong> unique, qui est attribué automatiquement à tous les clients connectés. </p><br><h1 id="primer">  Exemple </h1><br><p>  En fait, je ne veux vraiment pas vous ennuyer avec des extraits de la documentation, je suis sûr qu'il sera plus facile et plus intéressant pour vous de simplement voir un court morceau de code. </p><br><p>  Vous pouvez facilement installer l'exemple de discussion en téléchargeant les <a href="">sources</a> et en effectuant quelques actions simples </p><br><p>  Installation et lancement du client </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p>  Le client sera disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 3000</a> .  Ouvrez immédiatement quelques onglets avec le client pour voir la "communication". </p><br><p>  Installation et lancement du fournisseur (serveur) </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p>  Je suis sûr que vous connaissez le paquet <strong>ts-node</strong> , mais sinon, il vous permet d'exécuter des fichiers TS.  Si vous ne souhaitez pas installer, compilez simplement le serveur, puis exécutez le fichier JS. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat">  Quoi?  Encore?! </h1><br><p>  Anticipant les questions sur pourquoi diable inventer une autre moto, car il y a tellement de solutions éprouvées autour, à partir de protobuf et se terminant par le joynr hardcore de BMW, je peux seulement dire que c'était intéressant pour moi.  L'ensemble du projet a été réalisé uniquement sur une initiative personnelle sans aucun soutien, dans mon temps libre du travail. </p><br><p>  C'est pourquoi vos commentaires sont <strong>particulièrement précieux</strong> pour moi.  Dans une tentative de vous motiver d'une manière ou d'une autre, je peux vous promettre que pour chaque étoile sur github, je vais caresser le hamster (ce qui, pour le dire doucement, je n'aime pas).  Pour la fourchette, euhhh, je vais gratter son pussiko ... brrrr. </p><br><p>  <em>Le hamster n'est pas le mien, le hamster du fils</em> . </p><br><p>  De plus, dans quelques semaines, le projet sera testé pour mes anciens collègues (que j'ai mentionnés au début de l'article et qui étaient intéressés par la version alfa).  L'objectif est le débogage et l'exécution sur plusieurs composants.  J'espère vraiment que ça marche. </p><br><h1 id="ssylki-i-pakety">  Liens et packages </h1><br><p>  Le projet est hébergé par deux référentiels </p><br><ul><li>  sources de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres</a> : ceres.provider, ceres.consumer et tous les transports disponibles aujourd'hui. </li><li>  sources du générateur de protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.protocol</a> </li></ul><br><p>  NPM packages suivants disponibles </p><br><ul><li>  générateur de protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.protocol</a> </li><li>  fournisseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.provider</a> </li><li>  client <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.consumer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.provider.node.longpoll</a> transport pour un fournisseur basé sur une longue interrogation </li><li>  transport <a href="">ceres.provider.node.ws</a> pour un fournisseur basé sur Web Socket </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceres.consumer.browser.longpoll</a> transport pour le client basé sur une longue interrogation </li><li>  <a href="">ceres.consumer.browser.ws</a> transport pour un client basé sur Web Socket </li></ul><br><p>  Bon et léger. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442380/">https://habr.com/ru/post/fr442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442370/index.html">Chargement paresseux du module de fonctions depuis le dossier "node_modules"</a></li>
<li><a href="../fr442372/index.html">Programmation fiable dans le contexte des langages. Partie 2 - Challengers</a></li>
<li><a href="../fr442374/index.html">Développement de boost boost sur DSP: principe de fonctionnement, calculs, prototypage</a></li>
<li><a href="../fr442376/index.html">Densité de parcelle au détail</a></li>
<li><a href="../fr442378/index.html">Un clic dans l'interface de Booking com peut gâcher des vacances ou pourquoi un système de notation fonctionnel est important</a></li>
<li><a href="../fr442384/index.html">Extension des fonctionnalités du système audio standard</a></li>
<li><a href="../fr442386/index.html">Thymeleaf: Disposition des dialectes + Spring Boot 2</a></li>
<li><a href="../fr442392/index.html">La journalisation NodeJS est bien faite</a></li>
<li><a href="../fr442396/index.html">Événements numériques à Moscou du 04 mars au 10 mars</a></li>
<li><a href="../fr442402/index.html">Le plus important. Intégration avec des services externes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>