<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏌️ 💢 👍🏽 Alat analisis kode statis PVS-Studio sebagai perlindungan terhadap kerentanan zero-day ☝🏾 🦂 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zero Day Threat adalah istilah untuk kerentanan pembangunan yang belum ditemukan. Kerentanan semacam itu dapat dieksploitasi oleh penjahat cyber, yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alat analisis kode statis PVS-Studio sebagai perlindungan terhadap kerentanan zero-day</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477840/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/wn/yg/mo/wnygmobm1xqfcuxn4cmsqzay8lg.png" alt="Alat analisis kode statis PVS-Studio sebagai perlindungan terhadap kerentanan zero-day"></div><br>  Zero Day Threat adalah istilah untuk kerentanan pembangunan yang belum ditemukan.  Kerentanan semacam itu dapat dieksploitasi oleh penjahat cyber, yang pada akhirnya akan mempengaruhi reputasi perusahaan.  Pengembang dihadapkan pada tugas meminimalkan jumlah cacat dalam kode yang dapat menyebabkan kerentanan seperti itu.  Salah satu alat untuk membantu mengidentifikasi kelemahan keamanan adalah penganalisis kode statis PVS-Studio untuk C, C ++, C #, Java. <br><a name="habracut"></a><br><h2>  Ancaman nol hari </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%258F%25D0%25B7%25D0%25B2%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BD%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B4%25D0%25BD%25D1%258F">Ancaman zero-day</a> adalah istilah yang mengidentifikasi kesenjangan dan kerentanan yang diizinkan oleh pengembang, tetapi belum ditemukan.  Hingga kerentanan diperbaiki, dapat digunakan untuk mengakses jaringan, mengontrol komputer dari jarak jauh, memanipulasi data, dll.  Nama istilah ini sudah mapan karena fakta bahwa pengembang tidak punya waktu untuk memperbaiki cacat, karena belum ada yang tahu tentang itu.  Pada waktunya, perusahaan besar dan peranti lunak seperti <a href="https://www.anti-malware.ru/news/2010-10-28/3192">Adobe</a> , <a href="https://threatpost.ru/windows-deletebug-zero-day-allows-privilege-escalation-destruction/28888/">Windows</a> , <a href="https://www.make-info.com/zero-day-vulnerability-in-tor/">peramban Tor</a> , dan banyak lainnya menderita kerawanan tersebut. <br><br>  Beberapa organisasi beruntung, kerentanan mereka ditemukan oleh orang-orang yang tidak akan menggunakannya, dan mereka hanya memberikan informasi tentang masalah tersebut.  Misalnya, ini dengan <a href="https://securityaffairs.co/wordpress/86543/hacking/synthetic-clicks-macos-0day.html">MacOS</a> .  Atau ada pembaruan yang, selain fitur baru, juga secara tidak sengaja memperbaiki ancaman zero-day. <br><br>  Namun, ada situasi lain.  Sebagai contoh, Google Chrome pada suatu waktu sangat mendesak untuk memperbaiki <a href="https://3dnews.ru/996818">kerentanan</a> yang memungkinkan penyerang untuk mengeksekusi kode arbitrer dari jarak jauh pada perangkat korban. <br><br>  Masalah dengan ancaman ini adalah bahwa tidak mungkin untuk bertahan melawannya 100%, karena sulit untuk mempertahankan diri terhadap apa yang belum Anda ketahui.  Namun, ada cara untuk mengurangi kemungkinan ancaman seperti itu dalam proyek Anda, dan kami akan membahasnya nanti, tetapi untuk memulai dengan sedikit teori. <br><br><h2>  Analisis statis </h2><br>  Analisis kode statis adalah proses pengecekan kode program oleh penganalisa tanpa memulai program itu sendiri.  Analisis statis dapat dianggap sebagai proses peninjauan kode otomatis.  Dalam beberapa kasus, efektivitas analisis statis lebih unggul daripada tinjauan kode, tetapi tidak dapat dianggap sebagai alternatif lengkap untuk tinjauan kode oleh beberapa programmer.  Di bawah ini saya mencoba untuk menguraikan secara singkat pro dan kontra dari tinjauan kode dan analisis kode statis satu sama lain. <br><div class="scrollable-table"><table><tbody><tr><th>  Ulasan Kode <br></th><th>  Analisis statis <br></th></tr><tr><td>  Kemampuan untuk mengidentifikasi tidak hanya kesalahan sederhana, tetapi juga tingkat tinggi <br></td><td>  Anda dapat menemukan kesalahan tanpa mengetahui pola cacat atau kerentanan seperti itu <br></td></tr><tr><td>  Arsitektur aplikasi meningkat dan gaya pengkodean terpadu dikembangkan. <br></td><td>  Anda mungkin menemukan kesalahan yang sulit dicari selama peninjauan kode (misalnya, kesalahan ketik) <br></td></tr><tr><td>  Harga tinggi <br></td><td>  Harga lebih rendah dari review kode <br></td></tr><tr><td> Butuh banyak waktu dari programmer.  Perlu istirahat, karena perhatian cepat tumpul <br></td><td>  Positif palsu yang tak terhindarkan dan kebutuhan untuk menyetel penganalisa <br></td></tr></tbody></table></div><h2>  CVE dan CWE </h2><br>  Kerentanan dan Eksposur Umum (CVE) adalah basis data kesalahan perangkat lunak yang dapat digunakan oleh penjahat cyber.  CVE dibuat untuk merampingkan cacat perangkat lunak yang dikenal.  Sebagian besar alat keamanan informasi menggunakan database dan nama mereka sendiri, dan untuk menghilangkan kekacauan ini dan menambah kompatibilitas dengan berbagai alat, MITER pada tahun 1999 menciptakan CVE.  Namun, CVE tidak cukup untuk mengevaluasi keamanan kode.  Ini membutuhkan sesuatu yang lebih tepat, dengan deskripsi terperinci tentang masalah dan kurang kasar dari dia.  Oleh karena itu, basis Weakness Enumeration (CWE) umum telah dibuat yang memenuhi persyaratan ini.  Jika kesalahan ada di daftar CWE, maka kemungkinan akan menyebabkan kerentanan yang dapat dieksploitasi oleh penyerang dan masuk ke daftar CVE.  Untuk kejelasan, Anda dapat melihat diagram Euler di bawah ini. <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/02/l7/ec02l74mwthliqvd97vw2cqmblq.png" alt="CVE, CWE"></div><br>  Beberapa analisis statis dapat memberi tahu pengembang bahwa, misalnya, proyek menggunakan pustaka tempat kerentanan ditemukan.  Ini memungkinkan Anda untuk memilih versi perpustakaan yang lebih baru di mana kerentanan telah diperbaiki, dan mengurangi kemungkinan masalah dengan ancaman yang timbul dari kode orang lain. <br><br>  Dengan perkembangan daftar CVE dan CWE, banyak alat keamanan informasi telah menjaga dukungan mereka, termasuk analisa statis.  Analisis semacam itu dapat dianggap sebagai solusi SAST.  SAST (Pengujian Keamanan Aplikasi Statis) memungkinkan pengembang untuk menemukan kerentanan dalam kode sumber aplikasi yang sudah dalam tahap awal siklus hidup pengembangan perangkat lunak. <br><br>  Menggunakan SAST dalam pengembangan adalah pilihan lain untuk meminimalkan kemungkinan ancaman zero-day.  Analisator, mengklasifikasikan kesalahannya menurut CWE, dapat mengetahui di mana kerentanan mungkin bersembunyi.  Dan dengan memperbaiki kesalahan ini, pengembang membuat aplikasinya lebih dapat diandalkan dan mengurangi kemungkinan ancaman 0 hari. <br><br>  Ada berbagai alat untuk pengujian keamanan statis.  Untuk menunjukkan kemampuan dalam menangani kerentanan, marilah kita memikirkan alat <a href="https://www.viva64.com/ru/sast/">PVS-Studio</a> .  Peringatan dari penganalisa ini dapat diklasifikasikan sebagai CWE.  Mari kita lihat beberapa contoh. <br><br>  Peringatan PVS-Studio: <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> : Dead Code ( <a href="https://www.viva64.com/ru/w/v3021/">V3021</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncodeImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"inputPath"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrWhiteSpace(inputPath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"outputPath"</span></span>); } .... }</code> </pre> <br>  Kode ini secara tidak sengaja membuat kesalahan ketik.  Dalam dua kondisi <i>jika</i> , variabel yang sama diperiksa.  Dilihat oleh pengecualian yang dihasilkan, dalam kondisi kedua <i>outputPath</i> variabel harus diperiksa.  Akibatnya, bagian dari kode tidak dapat dijangkau. <br><br>  Pandangan seperti itu kelihatannya tidak berbahaya pada pandangan pertama.  Namun, kesan ini bisa sangat menyesatkan.  Pertimbangkan kesalahan tidak berbahaya yang sangat sederhana dan sekilas terkait dengan duplikasi operator <i>goto</i> . <br><br>  Pada suatu waktu, kesalahan ini menyebabkan kerentanan pada sistem operasi iOS. <br><br>  Deskripsi Kerentanan <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2014-1266">CVE-2014-1266</a> : Fungsi SSLVerifySignedServerKeyExchange di libsecurity_ssl / lib / sslKeyExchange.c dalam fitur Transportasi Aman dalam komponen Keamanan Data di Apple iOS 6.x sebelum 6.1.6 dan 7.x sebelum 7.0.6, Apple TV 6.x sebelum 6.0.2, dan Apple OS X 10.9.x sebelum 10.9.2 tidak memeriksa tanda tangan di pesan TLS Server Key Exchange, yang memungkinkan penyerang man-in-the-middle untuk menipu server SSL dengan menggunakan sewenang-wenang kunci pribadi untuk langkah penandatanganan atau menghilangkan langkah penandatanganan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OSStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SSLVerifySignedServerKeyExchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSLContext *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isRsa, SSLBuffer signedParams, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *signature, UInt16 signatureLen)</span></span></span><span class="hljs-function"> </span></span>{ OSStatus err; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; .... fail: SSLFreeBuffer(&amp;signedHashes); SSLFreeBuffer(&amp;hashCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br>  Karena <i>goto</i> ganda, situasi dengan kode yang tidak terjangkau juga muncul.  Terlepas dari kondisinya, <i>pernyataan</i> kebagian kedua akan dieksekusi dalam pernyataan <i>if</i> .  Ini mengarah pada fakta bahwa verifikasi tanda tangan tidak terjadi.  Fungsi mengembalikan 0, yang berarti semuanya baik-baik saja dengan tanda tangan, dan kemudian program menerima kunci dari server, bahkan jika ada masalah dengan tanda tangan.  Kunci ini diperlukan untuk mengenkripsi data selama transmisi. <br><br>  Konsekuensi dari kesalahan sederhana seperti itu sangat serius.  Oleh karena itu, tidak masuk akal untuk berdebat betapa berbahayanya kesalahan ini atau itu diklasifikasikan sebagai CWE.  Itu hanya perlu diperbaiki, sehingga membuat kode lebih aman. <br><br>  By the way, kesalahan yang dijelaskan dapat dengan mudah dideteksi oleh penganalisa PVS-Studio.  Dia akan memberikan dua peringatan CWE di sini segera: <br><br><ul><li>  <a href="https://cwe.mitre.org/data/definitions/561.html">CWE-561</a> ( <a href="https://www.viva64.com/ru/w/v779/">V779</a> ): Kode Mati </li><li>  <a href="https://cwe.mitre.org/data/definitions/483.html">CWE-483</a> ( <a href="https://www.viva64.com/ru/w/v640/">V640</a> ): Pembatasan Blok Salah </li></ul><br>  Mari kita lihat contoh lain.  Kembali pada tahun 2012, diketahui tentang masalah keamanan di MySQL, di mana penyerang dapat memasuki database MySQL.  Saya akan memberikan potongan kode yang menjadi alasannya. <br><br>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2012-2122">CVE-2012-2122 Keterangan</a> : sql / password.c di Oracle MySQL 5.1.x sebelum 5.1.63, 5.5.x sebelum 5.5.24, dan 5.6.x sebelum 5.6.6, dan MariaDB 5.1.x sebelum 5.1.62, 5.2.x sebelum 5.2.12, 5.3.x sebelum 5.3.6, dan 5.5.x sebelum 5.5.23, ketika berjalan di lingkungan tertentu dengan implementasi tertentu dari fungsi memcmp, memungkinkan penyerang jarak jauh untuk memotong otentikasi dengan berulang kali mengotentikasi dengan yang sama kata sandi salah, yang akhirnya menyebabkan perbandingan token berhasil karena nilai pengembalian yang tidak diperiksa dengan benar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> my_bool; <span class="hljs-function"><span class="hljs-function">my_bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_scramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scramble_arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Tipe <i>kembalinya</i> fungsi <i>memcmp adalah int</i> , dan tipe kembalinya dari fungsi <i>check_scramble adalah my_bool</i> , pada kenyataannya, <i>char</i> .  Akibatnya, sebuah <i>int</i> dilemparkan ke <i>char</i> , di mana bit orde tinggi dibuang.  Ini mengarah pada fakta bahwa dalam sekitar 1 kasus dari 256, dimungkinkan untuk terhubung dengan kata sandi, mengetahui nama pengguna. <br><br>  Sekali lagi, kesalahan CWE ini dapat dinetralkan dan dicegah dari berubah menjadi CVE bahkan pada tahap penulisan kode.  Sebagai contoh, analisa statis PVS-Studio menghasilkan peringatan berikut: <a href="https://cwe.mitre.org/data/definitions/197.html">CWE-197</a> ( <a href="https://www.viva64.com/ru/w/v642/">V642</a> ): Kesalahan Pemotongan Numerik. <br><br>  Sebagai kelanjutan dari topik ini, saya mengusulkan untuk melihat artikel " <a href="https://www.viva64.com/ru/b/0514/">Bagaimana PVS-Studio dapat membantu dalam menemukan kerentanan?</a> ". <br><br><h2>  Kesimpulan </h2><br>  Kerentanan 0-hari - suatu hal yang tidak ada jaminan perlindungannya.  Tetapi kemungkinan terjadinya mereka dapat dikurangi secara signifikan.  Untuk ini, solusi SAST khusus seperti PVS-Studio dapat digunakan.  Jika proyek Anda mendeteksi kesalahan yang dapat diklasifikasikan sebagai CWE, maka Anda harus memperhatikannya dan memperbaikinya.  Terlepas dari kenyataan bahwa hanya sejumlah kecil CWE yang akan mengisi daftar CVE dengan menghilangkan kesalahan CWE, Anda melindungi aplikasi Anda dari banyak ancaman potensial. <br><br><h2>  Tautan situs </h2><br><ol><li>  <a href="https://www.viva64.com/ru/pvs-studio-download/">Unduh dan coba PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/ru/b/0592/">Teknologi yang digunakan dalam penganalisa kode PVS-Studio untuk mencari kesalahan dan kerentanan potensial</a> </li><li>  <a href="https://www.viva64.com/ru/cwe/">Klasifikasi peringatan PVS-Studio menurut Common Weakness Enumeration (CWE)</a> </li><li>  <a href="https://www.viva64.com/ru/cert/">Klasifikasi peringatan PVS-Studio menurut SEI CERT Coding Standard</a> </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477838/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Ekaterina Nikiforova.  <a href="https://habr.com/en/company/pvs-studio/blog/477838/">PVS-Studio Static Analyzer sebagai Alat Perlindungan terhadap Kerentanan Zero-Day</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477840/">https://habr.com/ru/post/id477840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477820/index.html">VMware, Hyper-V, OpenStack, Kubernetes, Swarm - pemantauan dari satu antarmuka tunggal di Quest Foglight</a></li>
<li><a href="../id477822/index.html">PHP 7.4 dirilis! Bagaimana Badoo Meng-upgrade</a></li>
<li><a href="../id477824/index.html">Mari kita hidup sampai Senin atau bagaimana bertahan Jumat hitam</a></li>
<li><a href="../id477832/index.html">Cara bergaul dengan generasi Z</a></li>
<li><a href="../id477834/index.html">Prinsip untuk membangun sistem analisis streaming</a></li>
<li><a href="../id477842/index.html">Kisah Gennady Zelenko dan Sergey Popov - populariser teknologi di Uni Soviet</a></li>
<li><a href="../id477844/index.html">5 langkah dari ide hingga aplikasi praktis pembelajaran mesin dengan SAP Data Intelligence</a></li>
<li><a href="../id477846/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Desember 2019</a></li>
<li><a href="../id477848/index.html">Rahasia kecil hati besar: kardiogram paus biru pertama dalam sejarah</a></li>
<li><a href="../id477850/index.html">Bereaksi Asli - peluru perak untuk semua masalah? Bagaimana kami memilih alat lintas platform untuk Profi.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>