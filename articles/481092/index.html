<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüî¨ üî¢ üèáüèæ Lo m√°s interesante en PHP 8 üê¨ üë®‚Äç‚úàÔ∏è üë®üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4 acaba de ser declarado estable, y ya hemos presentado a√∫n m√°s mejoras. Y lo mejor de todo, lo que PHP est√° esperando puede decirle a Dmitry St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo m√°s interesante en PHP 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  PHP 7.4 acaba de ser declarado estable, y ya hemos presentado a√∫n m√°s mejoras.  Y lo mejor de todo, lo que PHP est√° esperando puede decirle a Dmitry Stogov, uno de los desarrolladores l√≠deres de PHP de c√≥digo abierto y, probablemente, el colaborador activo m√°s antiguo. <br><br>  Todos los informes de Dmitry son solo sobre aquellas tecnolog√≠as y soluciones en las que √©l trabaja personalmente.  En las mejores tradiciones de Ontiko, debajo del corte, una versi√≥n de texto de la <a href="https://youtu.be/7UOWus-5yxg">historia</a> sobre lo m√°s interesante desde el punto de vista de las innovaciones de Dmitry de PHP 8, que puede abrir nuevos casos de uso.  En primer lugar, JIT y FFI, no en la clave de "perspectivas sorprendentes", sino con detalles de implementaci√≥n y dificultades. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>Como referencia:</i> Dmitry Stogov se familiariz√≥ con la programaci√≥n en 1984, cuando no todos los lectores nacieron, y lograron hacer una contribuci√≥n significativa al desarrollo de herramientas de desarrollo, y PHP en particular (aunque Dmitry mejora el rendimiento de PHP no espec√≠ficamente para los desarrolladores rusos, <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">expresaron</a> mi agradecimiento en forma del Premio HighLoad ++).  Dmitry es el autor de Turck MMCache para PHP (eAccelerator), mantenedor de Zend OPcache, l√≠der del proyecto PHPNG, que form√≥ la base de PHP 7, y l√≠der en el desarrollo de JIT para PHP. <br><a name="habracut"></a><br><h2>  Desarrollo de rendimiento PHP </h2><br>  Comenc√© a trabajar en el rendimiento de PHP hace 15 a√±os cuando me un√≠ a Zend.  Luego lanzamos la versi√≥n 5.0, la primera en la que el lenguaje se volvi√≥ verdaderamente orientado a objetos.  Desde entonces, hemos podido mejorar el rendimiento en pruebas sint√©ticas en 40 veces, y en aplicaciones reales en 6 veces. <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br>  Durante este tiempo, hubo dos momentos decisivos: <br><br><ul><li>  Versi√≥n 5.1, en la que pudimos aumentar significativamente la velocidad de interpretaci√≥n.  Implementamos un int√©rprete especializado, y esto afect√≥ principalmente las pruebas sint√©ticas. </li><li> Versi√≥n 7.0, en la que se procesaron todas las estructuras de datos clave y, por lo tanto, optimiz√≥ el trabajo con memoria y cach√© del procesador (lea m√°s sobre estas optimizaciones <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">aqu√≠</a> ).  Esto condujo a una aceleraci√≥n de m√°s del doble tanto en pruebas sint√©ticas como en aplicaciones reales. </li></ul><br>  Todas las dem√°s versiones aumentaron gradualmente la productividad al implementar muchas ideas menos efectivas.  En la versi√≥n 7.1, por ejemplo, se prest√≥ mucha atenci√≥n a la optimizaci√≥n de bytecode ( <a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">un art√≠culo</a> sobre estas soluciones). <br><br>  El diagrama muestra que tanto al final del desarrollo de la quinta versi√≥n como al final del ciclo de desarrollo de la s√©ptima versi√≥n, vamos a una meseta y disminuimos la velocidad.  Entonces, durante el √∫ltimo a√±o de trabajo en v7.4, solo se ha logrado un aumento del 2% en la productividad.  Y esto no es malo, porque han aparecido nuevas caracter√≠sticas, como las propiedades escritas y los tipos covariantes que ralentizan PHP (Nikita Popov <a href="https://youtu.be/teKnckg5x7I">habl√≥</a> sobre estos nuevos productos en PHP Rusia). <br><br>  Y ahora todos se preguntan qu√© esperar de la octava versi√≥n, ¬øpuede repetir el √©xito de v7? <br><br><h3>  JIT o no JIT </h3><br>  Las ideas para mejorar el int√©rprete a√∫n no se han agotado, pero todas requieren un estudio muy sustancial.  Muchos de ellos tienen que ser rechazados en la etapa de prueba de concepto, porque la ganancia que se puede obtener resulta inconmensurable con la complicaci√≥n o las limitaciones t√©cnicas impuestas. <br><br>  Pero sigue habiendo esperanza de una nueva tecnolog√≠a innovadora; por supuesto, recuerdo el JIT y la historia de √©xito de los motores JavaScript. <br><br>  De hecho, el trabajo en JIT para PHP se lleva a cabo desde 2012.  Hubo 3 o 4 implementaciones, trabajamos con colegas de Intel, hackers de JavaScript, pero de alguna manera no fue posible incluir JIT en la rama principal.  Al final, en PHP 8, incluimos JIT en el compilador y vimos doble aceleraci√≥n, pero solo en pruebas sint√©ticas, pero en aplicaciones reales, por el contrario, desaceleraci√≥n. <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br>  Por supuesto, esto no es lo que buscamos. <br><br>  Cual es el problema  Tal vez estamos haciendo algo mal, tal vez WordPress es tan malo y ning√∫n JIT lo ayudar√° (s√≠, en realidad lo es).  Tal vez ya hemos hecho que el int√©rprete sea demasiado bueno, pero en JavaScript es peor.  En las pruebas computacionales, esto es cierto: <strong>el int√©rprete PHP es uno de los mejores</strong> . <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br>  En la prueba de Mandelbrot, supera incluso gemas como LuaJIT, un int√©rprete escrito en lenguaje ensamblador.  En esta prueba, solo estamos 4 veces detr√°s del compilador optimizador GCC-5.3.  Con JIT, podr√≠amos obtener mejores resultados en la prueba de Mandelbrot.  En realidad, ya hacemos esto, es decir, somos capaces de generar c√≥digo que compite con el compilador de C. <br><br>  ¬øPor qu√© entonces no podemos acelerar las aplicaciones reales?  Para entenderlo, te dir√© c√≥mo hacemos JIT.  Comencemos con lo b√°sico. <br><br><h3>  C√≥mo funciona PHP </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br>  El servidor acepta la solicitud, la compila en bytecode, que a su vez se env√≠a a la m√°quina virtual para su ejecuci√≥n.  Al ejecutar el bytecode, la m√°quina virtual tambi√©n puede llamar a otros archivos PHP, que nuevamente se vuelven a compilar en bytecode y se ejecutan nuevamente. <br><br>  Al completar la consulta, toda la informaci√≥n que se relaciona con ella, incluido el c√≥digo de bytes, se elimina de la memoria.  Es decir, cada script PHP debe compilarse en cada solicitud nuevamente.  Por supuesto, es simplemente imposible integrar la compilaci√≥n JIT en dicho esquema, porque el compilador debe ser muy r√°pido. <br><br>  Pero lo m√°s probable es que nadie use PHP en su forma desnuda, todos lo usan con OPcache. <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  El objetivo principal de OPcache es deshacerse de la compilaci√≥n de scripts en cada solicitud.  Est√° incrustado en un punto especialmente dise√±ado para √©l, intercepta todas las solicitudes de compilaci√≥n y almacena en cach√© el c√≥digo de bytes compilado en la memoria compartida. <br><br>  Al mismo tiempo, no solo se guarda el tiempo de compilaci√≥n, sino tambi√©n la memoria, porque la memoria de c√≥digo de bytes anterior se asign√≥ en el espacio de direcciones de cada proceso, y ahora existe en una sola copia. <br><br>  Ya puedes insertar JIT en este circuito, lo que haremos.  Pero primero, te mostrar√© c√≥mo funciona el int√©rprete. <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br>  Un int√©rprete es ante todo un bucle que llama a su propio controlador para cada instrucci√≥n. <br><br>  Usamos dos registros: <br><br><ul><li>  execute_data: puntero al marco de activaci√≥n actual; </li><li>  opline: puntero a la instrucci√≥n virtual ejecutable actual. </li></ul><br>  Usando la extensi√≥n gcc, estos dos tipos de registros se asignan a registros de hardware reales, y debido a esto funcionan muy r√°pidamente. <br><br>  En el bucle, simplemente llamamos al controlador para cada instrucci√≥n, despu√©s de lo cual, al final de cada controlador, movemos el puntero a la siguiente instrucci√≥n. <br><br>  Es importante tener en cuenta que la direcci√≥n del controlador se escribe directamente en el c√≥digo de bytes.  Puede haber varios manejadores diferentes para una sola instrucci√≥n.  Originalmente se invent√≥ para la especializaci√≥n, de modo que los manejadores puedan especializarse en tipos de operandos.  Se utiliza la misma tecnolog√≠a para JIT, porque si escribe la direcci√≥n en el nuevo c√≥digo generado como un controlador, los controladores JIT se iniciar√°n sin cambios en el int√©rprete. <br><br>  En el ejemplo anterior, a la derecha hay un controlador escrito para la declaraci√≥n de suma.  Toma operandos (aqu√≠ el primero y el segundo pueden ser una variable constante, temporal o local), lee operandos, verifica tipos, produce l√≥gica directa (suma) y luego regresa al ciclo, que transfiere el control al siguiente controlador. <br><br>  Las funciones especializadas se generan a partir de esta descripci√≥n.  Como hab√≠a tres primeros operandos posibles, tres segundos posibles, obtenemos 9 funciones diferentes. <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br>  En estas funciones, en lugar de m√©todos universales para obtener operandos, se utilizan m√©todos espec√≠ficos que no realizan ninguna comprobaci√≥n. <br><br><h3>  M√°quina virtual h√≠brida </h3><br>  Otra complicaci√≥n que hicimos en la versi√≥n 7.2 es la llamada m√°quina virtual h√≠brida. <br><br>  Si antes siempre llamamos al controlador usando una llamada indirecta directamente en el bucle de int√©rprete, ahora para cada controlador ingresamos adicionalmente una etiqueta en el cuerpo del bucle, al cual saltamos para usar el salto indirecto y donde llamamos al controlador en s√≠, pero directamente. <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br>  Parec√≠a que antes realizaban una llamada indirecta, ahora dos: una transici√≥n indirecta y una llamada directa, y ese sistema deber√≠a funcionar m√°s lentamente.  Pero en realidad funciona m√°s r√°pido, porque ayudamos al procesador a predecir las transiciones.  Anteriormente, hab√≠a un punto desde el cual se realizaba la transici√≥n a diferentes lugares.  El procesador a menudo se equivocaba, porque simplemente no pod√≠a recordar que era necesario saltar primero en una instrucci√≥n, luego en otra.  Ahora, despu√©s de cada llamada directa, hay una transici√≥n indirecta a la siguiente etiqueta.  Como resultado, cuando se ejecuta el bucle PHP, las instrucciones virtuales de PHP se organizan en secuencias estables, que luego se ejecutan casi linealmente. <br><br>  La m√°quina virtual h√≠brida permiti√≥ aumentar la productividad en otro 5-10%. <br><br><h3>  PHP + OPcache + JIT </h3><br>  JIT se implementa como parte de OPcache. <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br>  Despu√©s de compilar y optimizar el bytecode, se inicia un compilador JIT para √©l, que ya no funciona con el c√≥digo fuente.  Desde el c√≥digo de bytes PHP, el compilador JIT genera c√≥digo nativo, despu√©s de lo cual la direcci√≥n de la primera instrucci√≥n (de hecho, la funci√≥n) se cambia en el c√≥digo de bytes. <br><br>  Despu√©s de eso, el c√≥digo nativo, ya generado, comienza a llamarse desde el int√©rprete existente sin ning√∫n cambio.  Te mostrar√© un ejemplo simple. <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br>  A la izquierda, se escribe una determinada funci√≥n en PHP que cuenta la suma de n√∫meros del 0 al 100. A la derecha, el c√≥digo de bytes generado.  La primera instrucci√≥n asigna 0 a la suma, la segunda hace lo mismo para i, luego un salto incondicional a la etiqueta.  En la etiqueta L1, se verifica la condici√≥n para salir del ciclo: si se cumple, salga, si no, vaya al ciclo.  Luego, agregue a la suma i, escriba el resultado en la cantidad, aumente i en 1. <br><br>  Directamente desde aqu√≠ generamos c√≥digo ensamblador, que resulta bastante bueno. <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br>  La primera instrucci√≥n <code>QM_ASSIGN</code> compila en solo dos instrucciones de m√°quina (2-3 l√≠neas).  El registro <code>%esi</code> contiene un puntero al marco de activaci√≥n actual.  En el desplazamiento 30 se encuentra una cantidad variable.  La primera instrucci√≥n escribe el valor 0, la segunda escribe 4: este es un identificador de un tipo entero ( <code>IS_LONG</code> ).  Para la variable <code>i</code> compilador se dio cuenta de que siempre es larga y que no es necesario almacenar el tipo.  Adem√°s, se puede almacenar en un registro de m√°quina.  Por lo tanto, aqu√≠ simplemente XOR del registro consigo mismo es la instrucci√≥n m√°s simple y econ√≥mica para restablecer. <br><br>  Luego, de la misma manera, una transici√≥n incondicional, verificamos si ha ocurrido alg√∫n evento externo, verificamos la condici√≥n del ciclo, entramos en el ciclo.  En el ciclo, se verifica si la suma es entera: si es as√≠, leemos el valor entero, le agregamos el valor i, verificamos si hay un desbordamiento, escribimos el resultado en la suma y agregamos 1 a <code>%edx</code> . <br><br>  Se puede ver que el c√≥digo es casi √≥ptimo.  Ser√≠a posible optimizarlo a√∫n m√°s, eliminando la comprobaci√≥n de la suma del tipo en cada iteraci√≥n del bucle.  Pero esto ya es una optimizaci√≥n bastante complicada, todav√≠a no lo hacemos.  <strong>Estamos desarrollando JIT como una tecnolog√≠a bastante simple</strong> , no estamos tratando de hacer lo que Java HotSpot est√° tratando de hacer, V8: tenemos menos poder. <br><br><h2>  ¬øQu√© hay de malo con jit </h2><br>  ¬øPor qu√©, con un c√≥digo de ensamblador tan bueno, no podemos acelerar las aplicaciones reales? <br><br>  En realidad, ¬ødeber√≠an? <br><br><ul><li>  Si el cuello de botella no est√° en la CPU, entonces JIT no ayudar√°. </li><li>  Se genera demasiado c√≥digo (c√≥digo hinchado). </li><li>  La inferencia de tipo est√°tico no siempre funciona. </li><li>  C√≥digo honesto (para casos que nunca se ejecutan). </li><li>  Soporte para el estado consistente de la m√°quina virtual (y de repente una excepci√≥n). </li><li>  Las clases viven solo para una solicitud. </li></ul><br>  Si la aplicaci√≥n espera el 80% del tiempo una respuesta de la base de datos, JIT no ayudar√°.  Si llamamos funciones externas intensivas en recursos, por ejemplo, haciendo coincidir una expresi√≥n regular, entonces JIT tambi√©n llamar√° a las mismas funciones de la misma manera.  Adem√°s, si una aplicaci√≥n construye grandes estructuras de datos: √°rboles, gr√°ficos y luego los lee, con la ayuda de JIT generamos c√≥digo que leer√° en menos instrucciones, pero para cargar los datos en s√≠, tomar√° todo el mismo tiempo, pero Tambi√©n deber√° cargar el c√≥digo. <br><br>  Como ya ha visto, JIT puede incluso ralentizar una aplicaci√≥n real, ya que genera mucho c√≥digo y leerlo se convierte en un problema: al leer grandes cantidades de c√≥digo, otros datos se expulsan del cach√©, lo que conduce a una desaceleraci√≥n. <br><br><h2>  Planes modestos para PHP 8 </h2><br>  Una de las mejoras que queremos lograr en PHP 8 es <strong>generar menos c√≥digo</strong> .  Ahora, como dije, generamos c√≥digo nativo para todo el script, que cargamos en la etapa de carga.  Pero la mitad de las funciones ciertamente no ser√°n llamadas.  As√≠ que fuimos un poco m√°s all√° e introdujimos un disparador que nos permite configurar cu√°ndo queremos ejecutar JIT.  Se puede ejecutar: <br><br><ul><li>  para todas las funciones; </li><li>  solo para funciones cuando se llaman por primera vez; </li><li>  puede colgar un contador en cada funci√≥n y compilar solo aquellas funciones que est√°n realmente activas. </li></ul><br>  Tal esquema puede funcionar un poco mejor, pero a√∫n no es √≥ptimo, porque nuevamente en cada funci√≥n hay rutas que se ejecutan y rutas que nunca se ejecutan.  Como PHP es un lenguaje de programaci√≥n din√°mico, es decir, cada variable puede tener diferentes tipos, resulta que necesita admitir todos los tipos que predice el analizador est√°tico.  Y a menudo lo hace con precauci√≥n cuando no pudo probar que el otro tipo no pod√≠a hacerlo. <br><br>  <strong>En estas condiciones, nos alejaremos de la compilaci√≥n honesta y comenzaremos a hacerlo especulativamente.</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br>  En el futuro, planeamos primero durante alg√∫n tiempo durante el trabajo de la aplicaci√≥n analizar las funciones "m√°s populares", ver qu√© rutas recorre el programa, qu√© tipos de variables son, tal vez incluso recordar las condiciones de contorno, y solo entonces generar el c√≥digo de funci√≥n √≥ptimo para la corriente forma de ejecuci√≥n: solo para aquellas secciones que realmente se ejecutan. <br><br>  Para todo lo dem√°s, pondremos talones.  De todos modos, habr√° comprobaciones y posibles salidas en las que comenzar√° el proceso de desoptimizaci√≥n, es decir, restauraremos el estado de la m√°quina virtual necesaria para la interpretaci√≥n y se la daremos al int√©rprete para su ejecuci√≥n. <br><br>  Se utiliza un esquema similar en HotSpot Java VM y V8.  Pero adaptar la tecnolog√≠a a PHP tiene varias dificultades.  En primer lugar, esto es que hemos compartido bytecode y c√≥digo nativo compartido utilizado desde diferentes procesos.  No podemos cambiarlos directamente en la memoria compartida, primero debemos copiar en alg√∫n lugar, cambiar y luego volver a confirmar en la memoria compartida. <br><br><h2>  Precarga  El problema de la vinculaci√≥n de clases </h2><br>  De hecho, muchas de las ideas para mejoras de PHP que se han incluido durante mucho tiempo en PHP 7 e incluso PHP 5 provienen del trabajo relacionado con JIT.  Hoy hablar√© sobre otra tecnolog√≠a de este tipo: esta es la precarga.  Esta tecnolog√≠a ya est√° incluida en PHP 7.4 y permite especificar un conjunto de archivos, cargarlos al inicio del servidor y hacer que todas las funciones de estos archivos sean permanentes. <br><br>  Uno de los problemas que resuelve la tecnolog√≠a de precarga es el problema del enlace de clases.  El hecho es que cuando simplemente compilamos archivos en PHP, cada archivo se compila por separado de los dem√°s.  Esto se hace porque cada uno de ellos se puede cambiar por separado.  No puede asociar una clase de un script con una clase de otro script, porque en la pr√≥xima solicitud uno de ellos puede cambiar y algo saldr√° mal.  Adem√°s, en varios archivos puede haber una clase con el mismo nombre, y con una solicitud se usa uno de ellos como padre, y con el otro, se usa otra clase de otro archivo (con el mismo nombre, pero con uno completamente diferente).  Resulta que al generar c√≥digo que se ejecutar√° en varias solicitudes, no puede hacer referencia a clases o m√©todos, porque se recrean cada vez (la vida √∫til del c√≥digo excede la vida √∫til de la clase). <br><br>  La precarga le permite vincular las clases inicialmente y, en consecuencia, generar el c√≥digo de manera m√°s √≥ptima.  Como m√≠nimo, para los marcos que se cargar√°n mediante la precarga. <br><br>  Esta tecnolog√≠a ayuda no solo para el enlace de clases.  Algo similar se implementa en Java como Class Data Sharing.  All√≠, esta tecnolog√≠a est√° destinada principalmente a acelerar el lanzamiento de aplicaciones y reducir la cantidad total de memoria consumida.  Las mismas ventajas se obtienen en PHP, porque ahora el enlace de clase no se realiza en tiempo de ejecuci√≥n, sino que se realiza solo una vez.  Adem√°s, las clases asociadas ahora se almacenan no en el espacio de direcciones de cada proceso, sino en la memoria compartida y, por lo tanto, el consumo total de memoria disminuye. <br><br>  El uso de la precarga tambi√©n ayuda con la optimizaci√≥n global de todos los scripts PHP, elimina por completo la sobrecarga de OPcache y le permite generar un c√≥digo JIT m√°s eficiente. <br><br>  Pero tambi√©n hay desventajas.  <strong>Las secuencias de comandos cargadas al inicio no se pueden reemplazar sin reiniciar PHP.</strong>  Si descargamos algo y lo hicimos permanente, ya no podemos descargarlo.  Por lo tanto, la tecnolog√≠a se puede usar con marcos estables, pero si implementa la aplicaci√≥n varias veces al d√≠a, lo m√°s probable es que no funcione para usted. <br><br>  La tecnolog√≠a se concibi√≥ como transparente, es decir, permiti√≥ cargar aplicaciones existentes (o partes de las mismas) sin ning√∫n cambio.  Pero despu√©s de la implementaci√≥n, result√≥ que esto no es del todo cierto. <strong>No todas las aplicaciones funcionan como se pretend√≠a si se cargaran con precarga</strong> .  Por ejemplo, si se llama a un c√≥digo en la aplicaci√≥n en funci√≥n de los resultados de la comprobaci√≥n de <code>function_exists</code> o <code>class_exists</code> , y la funci√≥n se vuelve constante, respectivamente, <code>function_exists</code> siempre devuelve <code>true</code> , y se supon√≠a que se deb√≠a llamar al c√≥digo que se llam√≥ previamente. <br><br>  T√©cnicamente, la precarga se habilita con solo una directiva de configuraci√≥n opcache.preload, a la entrada de la cual se le da un archivo de script, un archivo PHP normal que se iniciar√° en la etapa de inicio de la aplicaci√≥n (no solo cargado, sino ejecutado). <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br>  Este es uno de los escenarios posibles que lee recursivamente todos los archivos en alg√∫n directorio (en este caso, ZendFramework).  Puede implementar absolutamente cualquier secuencia de comandos en PHP: lea con una lista, agregue excepciones o incluso cruce con el compositor para que pueda colocar los archivos necesarios para la precarga.  Todo esto es cuesti√≥n de tecnolog√≠a, y lo m√°s interesante no es c√≥mo enviar, sino qu√© enviar. <br><br><h3>  Qu√© cargar en precarga </h3><br>  Prob√© esta tecnolog√≠a en WordPress.  Si solo carga todos los archivos * .php, WordPress dejar√° de funcionar debido a la funci√≥n mencionada anteriormente: tiene una comprobaci√≥n de funci√≥n_existe, que siempre se cumple.  Por lo tanto, tuve que modificar ligeramente el script del ejemplo anterior (agregar excepciones), y luego, sin ning√∫n cambio en WordPress, funcion√≥. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  Velocidad [req / seq] </td><td>  Memoria [MB] </td><td>  Numero de guiones </td><td>  Numero de funciones </td><td>  Numero de clases </td></tr><tr><td>  Nada </td><td>  378 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  Todos (casi *) </td><td>  395 </td><td>  7.5 </td><td>  254 </td><td>  1770 </td><td>  148 </td></tr><tr><td>  Solo guiones usados </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br>  Como resultado, <strong>debido a la precarga, obtuvimos una aceleraci√≥n de ~ 5%</strong> , lo que ya no est√° mal. <br><br>  Descargu√© casi todos los archivos, pero la mitad de ellos no se usaron.  Puede hacerlo a√∫n mejor: maneje la aplicaci√≥n, vea qu√© archivos se han descargado.  Puede hacerlo utilizando la funci√≥n <code>opcache_get_status()</code> , que devolver√° todos los archivos en cach√© de OPcache y crear√° una lista para su precarga.  Por lo tanto, puede ahorrar 3 MB y obtener un poco m√°s de aceleraci√≥n.  El hecho es que cuanto m√°s memoria se necesita, m√°s cach√© del procesador se ensucia y menos eficiente es.  <strong>Mientras menos memoria se use, mayor ser√° la velocidad.</strong> <br><br><h2>  FFI - Interfaz de funci√≥n externa </h2><br>  Otra tecnolog√≠a relacionada con JIT que se desarroll√≥ para PHP es FFI (Foreign Function Interface) o, en ruso, la capacidad de llamar funciones escritas en otros lenguajes de programaci√≥n compilados sin compilaci√≥n.  Las implementaciones de dicha tecnolog√≠a en Python impresionaron a mi jefe (Zeev Surazki), y qued√© muy impresionado cuando comenc√© a adaptarlo a PHP. <br><br>  Ya ha habido varios intentos en PHP para crear una extensi√≥n para FFI, pero todos usaron su propio lenguaje o API para describir las interfaces.  Vi la idea en LuaJIT, donde se usa el lenguaje C (un subconjunto) para describir las interfaces, y el resultado es un juguete genial.  Ahora, cuando necesito verificar c√≥mo funciona algo en C, lo escribo en PHP; sucede, directamente en la l√≠nea de comandos. <br><br>  FFI le permite trabajar con estructuras de datos definidas en C y puede integrarse con JIT para generar c√≥digo m√°s eficiente.  Su implementaci√≥n basada en libffi ya est√° incluida en PHP 7.4. <br><br>  Pero: <br><br><ul><li>  Estas son 1000 nuevas formas de dispararte en el pie. </li><li>  Requiere conocimiento de C y, a veces, gesti√≥n manual de la memoria. </li><li>  No es compatible con el preprocesador C (#include, #define, ...) y C ++. </li><li>  El rendimiento sin JIT es bastante bajo. </li></ul><br>  Aunque, tal vez para algunos sea conveniente, porque el compilador no es necesario.  Incluso en Windows, esto funcionar√° sin ning√∫n Visual-C de PHP. <br><br>  Le mostrar√© c√≥mo usar FFI para implementar una aplicaci√≥n GUI real para Linux. <br><br>  No se alarme por el c√≥digo C, yo mismo escrib√≠ una GUI en C hace unos 20 a√±os, pero encontr√© este ejemplo en Internet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br>  El programa crea la aplicaci√≥n, se bloquea en el evento de devoluci√≥n de llamada de activaci√≥n, inicia la aplicaci√≥n.  En la devoluci√≥n de llamada, cree una ventana, as√≠gnele el tama√±o del t√≠tulo y mu√©strela. <br><br>  Y ahora, lo mismo reescrito en PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" ‚Ä¶ // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br>  Aqu√≠, el objeto FFI se crea primero.  Se le env√≠a una descripci√≥n de la interfaz como entrada, en esencia, un archivo h, y la biblioteca que queremos descargar.  Despu√©s de eso, todas las funciones descritas en la interfaz est√°n disponibles como m√©todos del objeto ffi, y todos los par√°metros transferidos se traducen de forma autom√°tica y absolutamente transparente en la representaci√≥n de m√°quina necesaria. <br><br>  Se puede ver que todo es exactamente igual que en el ejemplo anterior.  La √∫nica diferencia es que en C enviamos una devoluci√≥n de llamada como direcci√≥n, y en PHP, la conexi√≥n se produce por el nombre dado por la cadena. <br><br>  Ahora veamos c√≥mo se ve la interfaz.  En la primera parte, determinamos los tipos y funciones en C, y en la √∫ltima l√≠nea cargamos la biblioteca compartida: <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br>  En este caso, estas definiciones C se copian de los archivos h de la biblioteca GTK, casi sin cambios. <br><br>  Para no interferir con C y PHP en el mismo archivo, puede poner todo el c√≥digo C en un archivo separado, por ejemplo, con el nombre gtk-ffi.h y agregar un par de define'ov especiales al principio que especifiquen el nombre de la interfaz y la biblioteca para cargar: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br>  Por lo tanto, seleccionamos la descripci√≥n completa de la interfaz C en un archivo.  Este gtk-ffi.h es casi real, pero desafortunadamente, a√∫n no hemos implementado un preprocesador C, lo que significa que las macros e inclusiones no funcionar√°n. <br><br>  Ahora carguemos esta interfaz en PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Dado que FFI es una tecnolog√≠a bastante peligrosa, no queremos d√°rsela a nadie.  Al menos, ocultemos el objeto FFI, es decir, hag√°moslo privado dentro de la clase.  Y crearemos un objeto FFI que no use <code>FFI::cdef</code> , sino que use <code>FFI::load</code> , que lee solo nuestro archivo h del ejemplo anterior. <br><br>  El resto del c√≥digo no ha cambiado mucho, solo como un controlador de eventos comenzamos a usar una funci√≥n sin nombre y pasamos el t√≠tulo usando el enlace l√©xico.  Es decir, utilizamos C y las fortalezas de PHP, que no est√°n disponibles en C. <br><br>  Una biblioteca creada de esta manera ya podr√≠a usarse en su aplicaci√≥n.  Pero es bueno si funciona <strong>solo en la l√≠nea de comandos</strong> , y si lo coloca dentro del servidor web, entonces, en cada solicitud, se leer√° el archivo gtk_ffi.h, se crear√° y cargar√° una biblioteca, se realizar√° un enlace ... Y todo este trabajo repetitivo cargar√° su servidor. <br><br>  Para evitar esto y, de hecho, permitir escribir extensiones PHP en el propio PHP, decidimos cruzar FFI con precarga. <br><br><h3>  Precarga FFI + </h3><br>  El c√≥digo no ha cambiado mucho, solo que ahora asignamos los archivos h a la precarga, y ejecutamos <code>FFI::load</code> directamente en el momento de la precarga, y no cuando creamos el objeto.  Es decir, al cargar la biblioteca, todos los an√°lisis y enlaces se realizan una vez (cuando se inicia el servidor), y usando <code>FFI::scope("GTK")</code> obtenemos acceso a la interfaz precargada por nombre en nuestro script. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  En esta realizaci√≥n, FFI puede usarse desde un servidor web.  Por supuesto, esto no es para la GUI, pero de esta manera puede escribir, por ejemplo, un enlace a la base de datos. <br><br>  Una extensi√≥n creada de esta manera se puede usar directamente desde la l√≠nea de comando: <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  Otra ventaja del cruce y precarga de FFI es la capacidad de prohibir el uso de FFI para todos los scripts de nivel de usuario.  Puede especificar ffi.enable = preload, lo que significa que confiamos en los archivos precargados, pero est√° prohibido llamar a FFI desde scripts PHP normales. <br><br><h3>  Trabajando con estructuras de datos C </h3><br>  Otra caracter√≠stica interesante de FFI es que puede funcionar con estructuras de datos nativas.  En cualquier momento puede crear en la memoria cualquier estructura de datos descrita en C. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>    100  (  FFI::new != new FFI),     integer.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td> Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  Php </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , ‚Äî <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481092/">https://habr.com/ru/post/481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481074/index.html">Calculadora Python</a></li>
<li><a href="../481078/index.html">La participaci√≥n fall√≥: llevamos a AgentTesla a agua limpia. Parte 3</a></li>
<li><a href="../481082/index.html">¬°Mohnatiki captura el mercado para la industria del juego! Peregrine Labs anuncia colaboraci√≥n con Epic Games</a></li>
<li><a href="../481084/index.html">Python, introducci√≥n a la base de datos</a></li>
<li><a href="../481086/index.html">Vivaldi 2.10 - Agente encubierto</a></li>
<li><a href="../481094/index.html">Acerca de los auriculares inal√°mbricos JBL con energ√≠a solar y qu√© les pasa</a></li>
<li><a href="../481100/index.html">Angular 9, ¬øqu√© hay de nuevo?</a></li>
<li><a href="../481102/index.html">Kit de herramientas multiplataforma .NET UI versi√≥n AvaloniaUI 0.9</a></li>
<li><a href="../481104/index.html">Mezcla de OpenJDK y NodeJS: interacciones entre idiomas y arquitectura vertical</a></li>
<li><a href="../481106/index.html">C√≥mo LANIT dispar√≥ una comedia de bricolaje en su oficina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>