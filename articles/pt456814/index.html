<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♉️ 🙆🏽 🧝🏾 Aprenda programação funcional em Python em 10 minutos 🗺️ 👨‍⚕️ 🎽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foto: Chris Ried 

 Neste artigo, você entenderá o que é um paradigma funcional e como usar a programação funcional no Python. Você também aprenderá s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprenda programação funcional em Python em 10 minutos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456814/"><img src="https://habrastorage.org/getpro/habr/post_images/539/971/24e/53997124e1acc9aa28c273b0daa540b3.jpg" alt="imagem"><br>  <i>Foto:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chris Ried</a> <br><br>  Neste artigo, você entenderá o que é um paradigma funcional e como usar a programação funcional no Python.  Você também aprenderá sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abstração de lista</a> e outras compreensões de lista. <br><br><h3>  Paradigma funcional </h3><br>  Em um paradigma imperativo, você escreve um programa especificando uma sequência de ações que são executadas posteriormente.  Neste momento, os estados ( <i>aprox. Tradutor: variáveis, matrizes, etc.</i> ) mudam.  Por exemplo, deixe a variável A armazenar o valor 5, depois você altera o valor dessa variável.  Você usa variáveis ​​para que seus valores mudem. <a name="habracut"></a><br><br>  Em um paradigma funcional, você não diz ao computador o que fazer, mas especifica a natureza das próprias ações.  Qual é o maior divisor comum de um número, o resultado de cálculos de 1 a n etc. <br><br>  Portanto, as variáveis ​​não mudam.  Depois que uma variável é inicializada, seu valor é salvo para sempre (observe que, em linguagens funcionais puras, elas nem são chamadas de variáveis).  Portanto, no paradigma funcional, as funções não têm <i>efeitos colaterais</i> .  Um efeito colateral pode ser definido como o momento durante o qual uma função muda algo além de seus limites.  Veja um exemplo: <br><br><pre><code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> a a = <span class="hljs-number"><span class="hljs-number">5</span></span> some_func() print(a)</code> </pre> <br>  O resultado da execução desse código é 5. Na programação funcional, a alteração de variáveis ​​é proibida e a alteração de funções de algo além de suas fronteiras.  Tudo o que a função pode fazer é calcular / processar algo e retornar o resultado. <br><br>  Agora, você pode estar pensando: “Sem variáveis, sem efeitos colaterais?  Por que isso é bom?  Realmente boa pergunta. <br><br>  Se uma função foi chamada duas vezes com os mesmos parâmetros, obviamente ela retornará o mesmo resultado.  Se você estudou algo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">funções matemáticas</a> , apreciará esta oportunidade.  Isso é chamado de transparência do link ou transparência referencial.  Como as funções não têm efeitos colaterais, se você estiver desenvolvendo um programa de cálculo, poderá acelerar o processo de execução.  Se o programa souber que func (2) é 3, podemos lembrar disso.  Isso evita que a função seja chamada novamente quando já sabemos o resultado. <br><br>  Geralmente, na programação funcional, os loops não são usados.  Recursão é usada.  Recursão é um conceito matemático; na verdade, significa "alimentar algo para si mesmo".  Em uma função recursiva, a própria função se autodenomina o papel de uma subfunção.  Aqui está um exemplo de uma função recursiva no Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Base case: 1! = 1 #   if n == 1: return 1 # Recursive case: n! = n * (n-1)! #    else: return n * factorial_recursive(n-1)</span></span></code> </pre> <br>  Algumas linguagens de programação são <b>preguiçosas</b> .  Isso significa que eles estão calculando tudo no último momento.  Suponha que se o código deve executar 2 + 2, o programa funcional calculará o resultado somente quando o resultado for necessário.  Aprenderemos sobre a preguiça do Python um pouco mais tarde. <br><br><h3>  <font color="#9933FF">Mapa</font> </h3><br>  Para entender o mapa, você deve primeiro lidar com contêineres iteráveis.  Esse é um contêiner no qual você pode "passar por cima".  Geralmente, são listas ou matrizes, mas existem muitos contêineres no Python.  Você pode até criar seu próprio contêiner, introduzindo <i>métodos mágicos</i> .  Esses métodos, como APIs, ajudam os objetos a se tornarem mais pitônicos.  Existem 2 métodos para tornar um objeto iterável: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, low, high)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># set class attributes inside the magic method __init__ # for "inistalise" #      self.current = low self.high = high def __iter__(self): # first magic method to make this object iterable #    return self def __next__(self): # second magic method #    if self.current &gt; self.high: raise StopIteration else: self.current += 1 return self.current - 1</span></span></code> </pre> <br>  O primeiro método mágico é "___iter__" ou dunder (sublinhado duas vezes por sublinhados) iter retorna um objeto iterável, geralmente usado no início de um loop.  Dunder next (__next__) retorna o próximo objeto. <br><br>  Verifique isto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Counter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>): print(c)</code> </pre> <br>  Resultado da execução: <br><br> <code>3 <br> 4 <br> 5 <br> 6 <br> 7 <br> 8</code> <br> <br>  No Python, um iterador é um objeto que possui apenas o método __iter__.  Isso significa que você pode acessar o local das células do objeto (contêiner), mas não pode "caminhar" por elas.  Alguns objetos têm apenas o maravilhoso método __next__, sem o método mágico __iter__, por exemplo, definido (mais sobre isso posteriormente).  Neste artigo, abordaremos tudo relacionado a objetos iteráveis. <br><br>  Agora que sabemos o que é um objeto iterável, vamos retornar à função map.  Essa função nos permite aplicar a ação de alguma outra função a cada elemento em um contêiner iterado.  Queremos aplicar uma função a cada elemento da lista, isso é possível para quase todos os contêineres iteráveis.  Map, utiliza dois argumentos: a função a ser aplicada e o contêiner (lista, etc.). <br><br><pre> <code class="python hljs">map(function, iterable)</code> </pre> <br>  Suponha que tenhamos uma lista com os seguintes elementos: <br><br> <code>[1, 2, 3, 4, 5]</code> <br> <br>  E queremos colocar cada elemento ao quadrado, isso pode ser feito assim: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num*num print(list(map(square, x)))</code> </pre> <br>  Funções funcionais no Python são preguiçosas.  Se não adicionarmos "list ()", a função armazenará a descrição do contêiner (lista), e não a própria lista.  Precisamos dizer diretamente ao Python para converter isso em uma lista. <br><br>  É um pouco estranho passar de uma definição não preguiçosa para uma preguiçosa tão repentinamente.  Você se acostumará a isso se pensar mais de uma maneira funcional do que um imperativo. <br><br>  As funções de escrita, por exemplo, “quadrado (num)” são normais, mas não totalmente corretas.  Precisamos declarar uma função inteira apenas para usá-la no mapa?  Isso pode ser simplificado através da introdução de funções lambda (anônimas). <br><br><h3>  <font color="#9933FF">Expressões lambda</font> </h3><br>  Expressões lambda são funções em uma linha, por exemplo, aqui está uma expressão lambda que esquadrinha o número resultante: <br><br><pre> <code class="python hljs">square = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  E, execute o seguinte: <br><br> <code>&gt;&gt;&gt; square(3) <br> 9</code> <br> <br>  Eu posso te ouvir.  "Brandon, onde estão os argumentos?"  O que é isso tudo?  Isso não é como uma função. ” <br><br>  Sim, pode ser confuso, mas pode ser explicado.  Nesta linha, atribuímos algo à variável "quadrado".  Esta parte: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * x</code> </pre> <br>  Diz ao Python que estamos usando a função lambda, e a entrada é chamada x.  Tudo depois dos dois pontos é o que acontecerá com a entrada e obteremos o resultado automaticamente mais tarde. <br><br>  Para o nosso programa assumiu a forma de uma linha, você precisa fazer o seguinte: <br><br><pre> <code class="python hljs">x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] print(list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, x)))</code> </pre> <br>  Portanto, nas expressões lambda, os argumentos estão à esquerda e as ações nelas estão à direita.  Isso é um pouco desarrumado, ninguém nega.  A verdade é que há algo nele, para escrever esse código funcional.  Além disso, é muito legal converter funções em linha única. <br><br><h3>  <font color="#9933FF">Reduzir</font> </h3><br>  Reduzir é uma função que transforma um contêiner iterável em uma coisa.  Ou seja, são feitos cálculos que transformam a lista em um único número.  É assim: <br><br><pre> <code class="python hljs">reduce(function, list)</code> </pre> <br>  Nós podemos (e freqüentemente usaremos) funções lambda como argumento da função. <br><br>  Se quisermos multiplicar todos os números da lista, isso pode ser feito assim: <br><br><pre> <code class="python hljs">product = <span class="hljs-number"><span class="hljs-number">1</span></span> x = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: product = product * num</code> </pre> <br>  E com reduzir ficará assim: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce product = reduce((<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x * y),[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>])</code> </pre> <br>  O resultado será o mesmo, mas o código é mais curto e com o conhecimento de programação funcional para usá-lo com mais precisão. <br><br><h3>  <font color="#9933FF">Filtro</font> </h3><br>  A função de filtro pega um contêiner iterável e o filtra de acordo com uma regra especificada (também uma função). <br><br>  Normalmente, é necessária uma função e uma lista como entrada.  Posteriormente, aplica uma função a cada elemento da lista, se a função retornar True, nada acontecerá e, se False, o elemento será removido da lista. <br><br>  Sintaxe: <br><br><pre> <code class="python hljs">filter(function, list)</code> </pre> <br>  Vejamos um exemplo sem usar o filtro: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) new_list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: new_list.append(num)</code> </pre> <br>  Juntamente com o filtro: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))</code> </pre> <br><h3>  <font color="#9933FF">Funções de ordem superior</font> </h3><br>  Funções de ordem superior podem aceitar funções como argumentos e retorná-las.  Um exemplo simples seria assim: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nums)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(nums) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func, numbers)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func(numbers) print(action(summation, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])) <span class="hljs-comment"><span class="hljs-comment"># Output is 6 #  6</span></span></code> </pre><br>  Ou um exemplo é ainda mais simples: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnBrandon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"brandon"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnJohn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"john"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rtnPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> age = int(input(<span class="hljs-string"><span class="hljs-string">"What's your age?"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> age == <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnBrandon() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rtnJohn()</code> </pre> <br>  Lembre-se anteriormente, eu disse que a programação funcional real não usa variáveis.  Funções de ordem superior tornam isso possível.  Você não precisa salvar a variável em algum lugar se estiver passando informações através de um longo "túnel" de funções. <br><br>  Todas as funções no Python são objetos de primeira classe.  Um objeto da primeira classe é definido como tal, que corresponde a um ou mais dos seguintes parâmetros: <br><br><ul><li>  Cria um ciclo de serviço </li><li>  Atribuído a uma variável ou item em uma estrutura de dados </li><li>  Passado como argumento de função </li><li>  Retornado como resultado da execução da função </li></ul><br>  Portanto, todas as funções no Python são objetos de primeira classe e podem ser usadas como funções de ordem superior. <br><br><h3>  <font color="#9933FF">Aplicação parcial</font> </h3><br>  O uso parcial (também interrupção) é um pouco estranho, mas muito legal.  Você pode chamar a função sem usar todos os argumentos fornecidos.  Vejamos um exemplo.  Queremos criar uma função que use 2 argumentos, a base e o grau, e retorne a base elevada ao poder, assim: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base, exponent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base ** exponent</code> </pre><br>  Agora precisamos criar uma função separada para quadratura e calculá-la usando a função power: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> power(base, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Funciona, mas e se quisermos cubar um número?  Ou no 4º grau?  Você deve escrever essas funções para sempre?  Claro que você pode.  Mas os programadores são preguiçosos.  Se você repetir a mesma coisa várias vezes, provavelmente existe uma maneira de fazê-lo mais rapidamente e parar de repetir.  Aplicação parcial pode ser usada aqui.  Vejamos um exemplo da função power usando aplicação parcial: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial square = partial(power, exponent=<span class="hljs-number"><span class="hljs-number">2</span></span>) print(square(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 4 #  4</span></span></code> </pre><br>  Não é legal?  Podemos chamar uma função que precisa de 2 argumentos, usando apenas 1 e especificando qual será o segundo por si próprio. <br><br>  Você também pode usar um loop para simular uma função de potência que funcione com cubos até a 1000ª potência. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial powers = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1001</span></span>): powers.append(partial(power, exponent = x)) print(powers[<span class="hljs-number"><span class="hljs-number">0</span></span>](<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># output is 9 #  9</span></span></code> </pre> <br><h3>  <font color="#9933FF">A programação funcional não corresponde aos cânones pitônicos</font> </h3><br>  Você deve ter notado que muitas das coisas que queremos fazer na programação funcional giram em torno de listas.  Além da função de redução e aplicação parcial, todas as funções que você viu geram listas.  Guido (o criador do Python`a) não gosta de coisas funcionais no Python`e, pois o Python possui seu próprio método de criação de listas. <br><br>  Se você escrever "import this" no console, você obterá: <br> <code>&gt;&gt;&gt; import this <br> <br> The Zen of Python, by Tim Peters <br> <br> Beautiful is better than ugly. <br> Explicit is better than implicit. <br> Simple is better than complex. <br> Complex is better than complicated. <br> Flat is better than nested. <br> Sparse is better than dense. <br> Readability counts. <br> Special cases aren't special enough to break the rules. <br> Although practicality beats purity. <br> Errors should never pass silently. <br> Unless explicitly silenced. <br> In the face of ambiguity, refuse the temptation to guess. <br> There should be one — and preferably only one — obvious way to do it. <br> Although that way may not be obvious at first unless you're Dutch. <br> Now is better than never. <br> Although never is often better than *right* now. <br> If the implementation is hard to explain, it's a bad idea. <br> If the implementation is easy to explain, it may be a good idea. <br> Namespaces are one honking great idea — let's do more of those!</code> <br> <br>  Este é o Python Zen.  Este é um versículo sobre o que significa ser um pythonist.  A parte que nos interessa é: <br><br><blockquote>  Deve haver uma - e de preferência apenas uma - maneira óbvia de fazê-lo. </blockquote><br><blockquote>  <i>Deve haver apenas uma - e de preferência apenas uma - maneira óbvia de fazer alguma coisa.</i> </blockquote><br>  No Python, o mapa e o filtro podem fazer o mesmo que a abstração da lista ( <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a></i> ).  Isso viola uma das regras do Python-Zen, portanto, essa parte da programação funcional não é "pitônica". <br><br>  As próximas coisas a serem discutidas são a função lambda.  No Python, uma função lambda é uma função normal.  E, de fato, é açúcar sintático.  Ambas as partes fazem a mesma coisa: <br><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> a: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Uma função padrão ainda pode ser a mesma que uma função lambda, mas não vice-versa.  Uma função Lambda não pode ser a mesma que uma função normal. <br><br>  Essa foi uma pequena observação sobre por que a programação funcional não se encaixa perfeitamente na ideologia pitônica.  Mencionei a abstração das listas ( <i>também inclusão na lista</i> ), agora vamos falar sobre isso. <br><br><h3>  <font color="#9933FF">Abstração de lista</font> </h3><br>  Eu já disse que tudo o que pode ser feito usando o mapa e o filtro pode ser feito usando a abstração da lista.  Nesta parte, discutiremos isso. <br><br>  Abstração de lista é uma maneira de criar listas em Python.  Sintaxe: <br><br><pre> <code class="python hljs">[function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable]</code> </pre> <br>  Vamos agrupar cada item da lista, por exemplo: <br><br><pre> <code class="python hljs">print([x * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]])</code> </pre> <br>  Ok, podemos ver como aplicar a função a cada elemento da lista.  Como contornar o filtro?  Dê uma olhada neste código: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x)) print(all_less_than_zero)</code> </pre> <br>  Agora use a abstração da lista: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  A abstração de lista suporta expressões condicionais desse tipo.  Você não precisa mais usar um milhão de funções para obter algo.  De fato, se você está tentando fazer algo com uma lista, existe a possibilidade de ser mais limpo e fácil de obter com a abstração de listas. <br><br>  E se quisermos colocar todos os elementos da lista abaixo de zero?  Com a função lambda, mapear e filtrar, ficará assim: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num * num, list(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> num: num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, x))))</code> </pre><br>  Esta entrada não é racional e não é muito simples.  Usando a abstração da lista, ficará assim: <br><br><pre> <code class="python hljs">x = range(<span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) all_less_than_zero = [num * num <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> num &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  A abstração de lista é boa, curiosamente, para listas.  Mapear e filtrar o trabalho para cada contêiner iterável, o que há de errado? .. Sim, você pode usar a abstração para cada contêiner iterável que encontrar. <br><br><h3>  <font color="#9933FF">Outras abstrações</font> </h3><br>  Você pode aplicar a abstração para cada contêiner iterável. <br><br>  Cada contêiner iterável pode ser criado usando abstração.  A partir da versão 2.7, você pode até criar um dicionário (tabela de hash). <br><br>  Se algo é um contêiner iterável, pode ser gerado algo.  Vejamos o último exemplo usando set.  Se você não souber o que é conjunto, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> escrito por mim também.  Em resumo: <br><br><ul><li>  Set é um contêiner de elementos; os elementos nele não são repetidos </li><li>  A ordem não é importante </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># taken from page 87, chapter 3 of Fluent Python by Luciano Ramalho #    Fluent Python, . 87, . 3 &gt;&gt;&gt; from unicodedata import name &gt;&gt;&gt; {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')} {'×', '¥', '°', '£', '', '#', '¬', '%', 'µ', '&gt;', '¤', '±', '¶', '§', '&lt;', '=', '', '$', '÷', '¢', '+'}</span></span></code> </pre><br>  Como você deve ter notado, o conjunto, como um dicionário, usa chaves.  Python é realmente inteligente.  Ele vai adivinhar se você está usando uma abstração de dicionário ou um conjunto de abstrações, com base em se você especifica parâmetros adicionais para o dicionário ou não.  Se você quiser saber mais sobre abstrações, leia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isto</a> .  Se sobre abstrações e geração, então <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> . <br><br><h3>  <font color="#9933FF">Sumário</font> </h3><br>  A programação funcional é ótima.  O código funcional pode ser limpo ou não muito.  Alguns pythonists incondicionais não aceitam o paradigma funcional no Python.  Você deve usar o que deseja e o que combina com você. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Página do autor</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456814/">https://habr.com/ru/post/pt456814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456804/index.html">Siga o dinheiro: como o grupo RTM começou a ocultar os endereços dos servidores C&C em uma carteira criptográfica</a></li>
<li><a href="../pt456806/index.html">Um bot de todas as preocupações</a></li>
<li><a href="../pt456808/index.html">Como melhorar o desempenho de aplicativos Web front-end: cinco dicas</a></li>
<li><a href="../pt456810/index.html">Os primeiros. Uma história livre de Tesla</a></li>
<li><a href="../pt456812/index.html">O que há na Universidade ITMO - festivais de TI, hackers, conferências e seminários abertos</a></li>
<li><a href="../pt456818/index.html">O administrador do sistema em uma empresa inacessível. O fardo insuportável do ser?</a></li>
<li><a href="../pt456820/index.html">Argila → Tijolo → Fogão</a></li>
<li><a href="../pt456824/index.html">O que é probabilidade e como calculá-lo</a></li>
<li><a href="../pt456826/index.html">Escalonamento automático DIY com AWX, Ansible, haproxy e CROC Cloud</a></li>
<li><a href="../pt456828/index.html">Vias de ajuste para placas de circuito impresso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>