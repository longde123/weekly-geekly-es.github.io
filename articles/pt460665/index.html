<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíö ü§≥ üöã Rascunho de FAQ: Por que os padr√µes C ++ s√£o lan√ßados a cada tr√™s anos? ‚õπüèø ü§úüèΩ üëãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O WG21 possui um cronograma r√≠gido (consulte a P1000 ) para libera√ß√£o padr√£o a cada tr√™s anos. E sem atrasos. 

 Durante cada ciclo, recebemos regular...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rascunho de FAQ: Por que os padr√µes C ++ s√£o lan√ßados a cada tr√™s anos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  O WG21 possui um cronograma r√≠gido (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1000</a> ) para libera√ß√£o padr√£o a cada tr√™s anos.  E sem atrasos. <br><br>  Durante cada ciclo, recebemos regularmente perguntas ‚ÄúPor que isso √© t√£o rigoroso?‚Äù, Especialmente de novos membros do comit√™ que n√£o est√£o familiarizados com a sua hist√≥ria e as raz√µes do estado atual das coisas.  E durante uma teleconfer√™ncia preliminar com o governo de Col√¥nia, v√°rias pessoas recomendaram descrever por que est√°vamos fazendo isso e como foi tomada a decis√£o de adotar esse cronograma. <br><br>  Pintei tudo isso na forma de perguntas e respostas para o pr√≥ximo rascunho do P1000 e enviei uma c√≥pia aos membros do comit√™ a caminho de Col√¥nia.  Este material ser√° publicado na pr√≥xima vers√£o p√∫blica do P1000; enviaremos em algumas semanas a partir do momento atual. <br><br>  No entanto, o rascunho das perguntas frequentes pode ser de interesse do p√∫blico, por isso ofere√ßo uma c√≥pia dele.  Espero que, na maioria das vezes, seja √∫til para voc√™, esclarecer de alguma forma e talvez at√© divertir um pouco. <br><br><a name="habracut"></a><br><h2>  Existem erros no padr√£o, voc√™ deve adiar o C ++ 20? </h2><br>  Claro que sim e n√£o. <br><br>  Estamos nos movendo em uma determinada dire√ß√£o na velocidade escolhida: as corre√ß√µes est√£o planejadas para este ano passado, portanto a programa√ß√£o no in√≠cio do C ++ ‚Äú19‚Äù (Kona) estabelece um prazo para interromper a adi√ß√£o de recursos (congelamento de recursos) no C ++ ‚Äú20‚Äù, para que tivemos um ano para corrigir bugs, inclusive trabalhando com coment√°rios de diferentes pa√≠ses neste ver√£o.  Antes do in√≠cio de 2020 (reuni√µes em Col√¥nia, Belfast e Praga), devemos fornecer feedback e aplicar outras solu√ß√µes para os problemas, bem como corre√ß√µes de bugs. <br><br><h2>  Se tivermos mais uma ou duas reuni√µes, podemos adicionar um &lt;nome do recurso&gt;, que est√° quase pronto, ent√£o voc√™ deve adiar o C ++ 20? </h2><br>  Claro que sim e n√£o. <br><br>  Aguarde mais algumas reuni√µes (depois de Praga), e o C ++ 23 estar√° aberto para neg√≥cios, e antes de tudo votaremos em adicionar &lt;nome do recurso&gt; ao rascunho de trabalho do C ++ 23.  Foi o que fizemos com os conceitos: eles n√£o estavam prontos para a transi√ß√£o do TS diretamente para o C ++ 17.  Portanto, na primeira reuni√£o do C ++ 20 (em Toronto), eles votaram na transfer√™ncia da funcionalidade b√°sica dos conceitos para o rascunho do C ++ 20, que deu muito tempo para melhorar e refinar o restante da parte contradit√≥ria do TS (sintaxe n√£o-modelo), introduzida ano que vem (San Diego).  Agora toda a funcionalidade est√° pronta. <br><br><h2>  Isso parece ser muito rigoroso.  Por que liberar vers√µes IS em intervalos fixos (tr√™s anos)? </h2><br>  Como no caso do lan√ßamento do C ++ IS, essa √© uma das duas principais op√ß√µes para gerenciamento de projetos, e a experi√™ncia mostra que essa op√ß√£o √© melhor que a segunda. <br><br><h2>  Quais s√£o as duas op√ß√µes para gerenciamento de projetos para o lan√ßamento do C ++ IS? </h2><br>  Que bom que voc√™ perguntou. <br><br>  No caso de uma libera√ß√£o, h√° duas op√ß√µes principais: escolha um recurso ou uma data de libera√ß√£o e, quando voc√™ seleciona uma, perde o controle sobre a defini√ß√£o da outra.  Voc√™ n√£o pode controlar os dois simultaneamente.  Em resumo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Se n√≥s controlamos <br></th><th>  Vamos parar de control√°-lo <br></th><th> Podemos trabalhar em "grandes" recursos plurianuais? <br></th><th>  Quando adicionamos recursos ao rascunho de IS? <br></th><th>  O que fazemos se encontrarmos problemas com recursos adicionais? <br></th></tr><tr><td>  <b>"O qu√™": recursos que enviamos</b> <br></td><td>  "Quando": data de lan√ßamento. <br></td><td>  Sim, nos documentos com as propostas e o rascunho de SI. <br></td><td>  Geralmente mais cedo para realizar mais testes de integra√ß√£o ‚Üí a estabilidade m√©dia do rascunho de trabalho √© reduzida. <br></td><td>  Adiamos o lan√ßamento do padr√£o. <br></td></tr><tr><td>  <b>Quando: Data de Lan√ßamento</b> <br></td><td>  "O qu√™": recursos que enviamos <br></td><td>  Sim, em documentos com ofertas e "ramos de recursos" no TS. <br></td><td>  Geralmente mais tarde, quando o recurso √© melhor elaborado ‚Üí a estabilidade m√©dia do rascunho de trabalho aumenta. <br></td><td>  Removemos o recurso, depois podemos adicion√°-lo novamente se estiver pronto no momento em que o pr√≥ximo trem IS for enviado. <br></td></tr></tbody></table></div><br>  Eu explico: <br><br>  <b>(1) ‚ÄúO qu√™‚Äù: selecionamos recursos e enviamos como prontos, sem necessidade de escolher um hor√°rio de lan√ßamento</b> .  Se voc√™ precisar de mais tempo para finalizar um recurso do rascunho do padr√£o, o mundo inteiro ter√° que esperar por voc√™.  Voc√™ trabalha em grandes recursos que requerem v√°rios anos de desenvolvimento e tenta parar de trabalhar em novos recursos enquanto estabiliza o lan√ßamento. <br><br>  O mesmo ocorreu com o C ++ 98 (era esperado por volta de 1994, Bj√∂rn disse que, se o lan√ßamento n√£o fosse lan√ßado, seria um fracasso) com o C ++ 11 (chamado 0x porque x era esperado em 2007 )  Essa √© uma abordagem ‚Äúdeixe o paciente sem prote√ß√£o‚Äù por um per√≠odo indeterminado, o que levou a um atraso nos testes e na libera√ß√£o da integra√ß√£o.  E isso, por sua vez, levou a uma grande incerteza no mercado em rela√ß√£o ao momento do pr√≥ximo padr√£o e se ele ser√° lan√ßado (sim, n√£o apenas os participantes do desenvolvimento, mas mesmo alguns membros do comit√™ duvidaram seriamente em 1996 e 2009). existem lan√ßamentos relevantes).  Por v√°rios anos, a maioria dos compiladores n√£o atendeu ao padr√£o, porque ningu√©m sabia quantas mudan√ßas incompat√≠veis o comit√™ lan√ßaria no novo lan√ßamento ou quando seria esperado?  Isso levou a uma ampla variedade e fragmenta√ß√£o do suporte a C ++ nos compiladores dispon√≠veis para a comunidade. <br><br>  Por que fizemos isso, somos idiotas?  Na verdade, eles eram inexperientes e ... digamos "otimistas".  Era uma estrada pavimentada com as melhores inten√ß√µes.  Em 1994-1996 e em 2007-2009, acredit√°vamos realmente que agora promover√≠amos mais uma, duas ou tr√™s reuni√µes e far√≠amos tudo, e cada vez que elas seriam adiadas por at√© quatro anos.  E agora eles viram por sua pr√≥pria experi√™ncia que n√£o pode haver transfer√™ncia por um ano ou dois. <br><br>  Felizmente, tudo mudou gra√ßas √† op√ß√£o (2). <br><br>  <b>(2) ‚ÄúQuando‚Äù: selecionamos a data de lan√ßamento e enviamos os recursos que est√£o prontos, voc√™ n√£o precisa selecionar um conjunto de recursos</b> .  Se for necess√°rio mais tempo para refinar um recurso de um rascunho de padr√£o, n√≥s o descartamos e enviamos o que est√° pronto.  Voc√™ pode continuar trabalhando em grandes recursos, cuja cria√ß√£o leva tempo como em v√°rias vers√µes, mas em "ramifica√ß√µes" de terceiros, adicionando-as √† ramifica√ß√£o mestre do IS assim que poss√≠vel.  E voc√™ trabalha constantemente nos recursos, porque o desenvolvimento deles √© completamente separado da vers√£o atual (n√£o h√° grande ponto de conex√£o). <br><br>  N√≥s aderimos a essa abordagem desde 2012 e n√£o queremos abandon√°-la.  Essa √© a abordagem de "remendar regularmente o paciente", que leva √† expectativa de maior qualidade devido √†s integra√ß√µes regulares for√ßadas e √† recusa de adicionar trabalho ao rascunho do SI at√© que ele atinja um certo n√≠vel de estabilidade, geralmente dentro do ramo de recursos.  Tamb√©m cria um ciclo de libera√ß√£o previs√≠vel em que o mercado pode confiar.  Ao longo dos anos, os autores dos compiladores come√ßaram cada vez mais cedo, ap√≥s o pr√≥ximo lan√ßamento, a lan√ßar vers√µes de seus produtos em conformidade com o padr√£o, o que nunca havia acontecido antes.  E em 2020, esperamos o lan√ßamento de implementa√ß√µes totalmente compat√≠veis em um ano com o lan√ßamento do padr√£o, o que tamb√©m nunca aconteceu antes.  Isso √© apenas para o benef√≠cio de todo o mercado - desenvolvedores, usu√°rios, professores. <br><br>  Observe tamb√©m que, desde que come√ßamos a aderir a essa abordagem, come√ßamos a fazer mais (se medido por recursos grandes, m√©dios e pequenos) e com maior qualidade (se medido por uma redu√ß√£o rigorosa no n√∫mero de relat√≥rios de bugs e coment√°rios sobre rascunhos de cada norma).  Apesar de enviarmos o que conseguimos preparar (e se n√£o conseguimos algo, n√£o enviamos). <br><br><h2>  Voc√™ est√° falando s√©rio sobre a abordagem (2)?  Se, de acordo com um membro autorit√°rio do comit√™, algum grande recurso estiver "quase pronto", voc√™ ficar√° tentado a esperar um pouco, certo? </h2><br>  Muito a s√©rio, e n√£o. <br><br>  Temos estat√≠sticas: em 2016 em Jacksonville, quando finalmente decidimos os recursos do C ++ 17, Bj√∂rn Straustrup falou em uma reuni√£o plen√°ria com uma proposta para incluir conceitos no C ++ 17.  Quando nenhum consenso foi alcan√ßado, foi perguntado diretamente a Straustrup se ele queria adiar o lan√ßamento do C ++ 17 por um ano para incluir conceitos nele.  Bj√∂rn respondeu "n√£o" sem hesita√ß√£o e evas√£o e acrescentou que o C ++ 17 sem conceitos era mais importante que o C ++ 18 ou o C ++ 19 com conceitos, embora a Straustrup os trabalhasse h√° cerca de 15 anos.  A escolha foi a seguinte: (2) lan√ßamos o C ++ 17 sem conceitos e depois o C ++ 20 com os conceitos (o que fizemos), ou (1) renomeamos o C ++ 17 para C ++ 20, que √© isom√≥rfico (2) com exce√ß√£o de pular o C ++ 17 e recusar-se a liberar o que j√° estava pronto para o C ++ 17. <br><br><h2>  E a troca entre (1) e (2)?  Digamos, geralmente aderimos a (2), mas com "pouca" flexibilidade em termos de "um pouco" de tempo extra, se voc√™ precisar refinar o recurso? </h2><br>  N√£o, porque acontece (1). <br><br>  Fred Brooks, no <i>The Mythical Man-Month,</i> explicou popularmente ‚Äúa pequena transfer√™ncia m√≠tica‚Äù e concluiu: ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√£o permita nenhuma transfer√™ncia pequena</a> ‚Äù. <br><br>  Imagine que portamos o C ++ 20.  Ter√≠amos que voltar de (2) a (1), por mais que tent√°ssemos evit√°-lo e, ao mesmo tempo, n√£o receber√≠amos nenhum benef√≠cio.  Se decid√≠ssemos adiar o C ++ 20 para aperfei√ßo√°-lo, adiar√≠amos o padr√£o por pelo menos dois anos.  N√£o existem conceitos como a transfer√™ncia de uma ou tr√™s reuni√µes, porque durante esse per√≠odo outros continuar√£o (razoavelmente) a dizer: "Bem, meu recurso precisa apenas de mais uma reuni√£o, ainda a remarcamos, vamos transferir outra".  E se transferirmos pelo menos dois anos, isso significa que o C ++ 20 se torna C ++ 22 e provavelmente C ++ 23 ... mas j√° vamos enviar o C ++ 23!  - Ou seja, em qualquer caso, enviaremos o C ++ 23, e a √∫nica diferen√ßa √© que <b>n√£o</b> transferimos o C ++ 20 com uma grande quantidade de trabalho realizado, pronto para o lan√ßamento, e n√£o fazemos o mundo inteiro esperar mais tr√™s anos.  O atraso n√£o beneficiar√° esses recursos, a maioria deles ou todos juntos. <br><br>  Portanto, a frase √© equivalente a "vamos transformar C ++ 20 em C ++ 22 ou C ++ 23" e a resposta simples: "sim, teremos C ++ 23, mas al√©m de C ++ 20, e n√£o em seu lugar. "  Um atraso no C ++ 20 significa pular o C ++ 20 em vez de liberar um produto final bom, est√°vel e est√°vel, e n√£o haver√° benef√≠cio disso. <br><br><h2>  Mas o recurso X est√° quebrado / leva mais tempo do que resta para corrigir bugs no C ++ 20! </h2><br>  Nenhuma pergunta!  N√≥s podemos simplesmente cort√°-lo. <br><br>  Nesse caso, algu√©m precisar√° escrever uma carta em EWG ou LEWG (dependendo da situa√ß√£o) com uma descri√ß√£o da situa√ß√£o e oferecer a remo√ß√£o do recurso do rascunho de IS.  Esses grupos considerar√£o a apela√ß√£o e, se decidirem que o recurso est√° quebrado (e o plen√°rio concordar com eles), o recurso ser√° adiado para a pr√≥xima vers√£o do C ++.  J√° fizemos isso com os conceitos de C ++ 0x. <br><br>  Mas no caso de (1), transferiremos n√£o apenas esse recurso, mas <b>todo o conjunto de recursos</b> de C ++ 20 para C ++ 23!  Isso seria ... busto. <br><br><h2>  A abordagem (2) significa lan√ßamentos "principais / secund√°rios"? </h2><br>  N√£o.  No come√ßo, dissemos isso at√© percebermos que (2) significa apenas que voc√™ n√£o precisa escolher um conjunto de recursos, mesmo do ponto de vista da vers√£o "principal / secund√°ria". <br><br>  A abordagem (2) significa apenas "enviamos o que est√° pronto".  Lan√ßamentos s√£o obtidos: <br><br><ul><li>  o mesmo tamanho (ou seja, geralmente m√©dio) dos recursos √© "menor" porque menos tempo √© gasto em seu desenvolvimento (digamos, menos de tr√™s anos cada) e, em geral, obtemos o mesmo n√∫mero de recursos conclu√≠dos no lan√ßamento; <br></li><li>  e um tamanho vari√°vel (n√£o √© necess√°rio uma ou duas vezes) para os recursos "maiores", que levam mais tempo (digamos, mais de tr√™s anos cada), e cada vers√£o do IS inclui tantos desses recursos quanto eles conseguem concluir para a vers√£o.  Portanto, em alguns lan√ßamentos h√° mais, em outros menos. <br></li></ul><br>  C ++ 14 e C ++ 17 eram relativamente pequenos, porque muito esfor√ßo de padroniza√ß√£o foi gasto em recursos de longa execu√ß√£o descritos nas propostas de implementa√ß√£o (por exemplo, contratos) e "ramifica√ß√µes de recursos" no TS (por exemplo, conceitos). <br><br><h2>  C ++ 20 √© um √≥timo lan√ßamento ... </h2><br>  Sim  O C ++ 20 possui muitos recursos principais.  Tr√™s dos maiores come√ßam com ‚Äúko‚Äù (conceitos, contratos, corotinas), ent√£o podemos cham√°-lo de co_cpp20.  Ou co_dependente. <br><br><h2>  ... e n√£o √© muito feito no ciclo de tr√™s anos para C ++ 20? </h2><br>  N√£o, veja acima "uma vez por vez n√£o √© necess√°rio". <br><br>  O C ++ 20 √© grande, n√£o porque fizemos mais em tr√™s anos, mas porque h√° muitos desenvolvimentos longos (incluindo pelo menos dois nos quais estamos trabalhando no formul√°rio atual desde 2012 na forma de frases P e TS) ) atingiram o est√°gio de prontid√£o e decidiram inclu√≠-los no rascunho de IS da mesma vers√£o. <br><br>  Quase sempre, os principais recursos s√£o desenvolvidos por muitos anos.  A principal diferen√ßa entre a abordagem (1) para C ++ 98 e C ++ 11 e a abordagem (2) √© que, em C ++ 98 e C ++ 11, o lan√ßamento foi adiado at√© que todos esses recursos estivessem prontos, e agora enviamos grandes assim que estiver pronto, e junto com eles lan√ßaremos muito mais. <br><br>  O C ++ 20 passou pelo mesmo ciclo de tr√™s anos que o C ++ 14 e o C ++ 17.  N√£o fizemos mais nos √∫ltimos tr√™s anos do que nos dois ciclos anteriores, apenas acrescentamos mais aos principais recursos.  Se algum deles n√£o estivesse pronto, j√° o ter√≠amos descartado e j√° terminado para o C ++ 23.  Se isso acontecer, reportaremos isso na proposta de implementa√ß√£o e explicaremos os motivos. <br><br>  C ++ 14 + 17 + 20 comp√¥s nosso terceiro ciclo de nove anos (2011-2020) ap√≥s C ++ 98 (1989-1998) e C ++ 11 (2002-2011).  Mas desde que aderimos √† abordagem (2), <b>tamb√©m</b> lan√ßamos desenvolvimentos prontos para o final dos ciclos de tr√™s e seis anos. <br><br><h2>  N√£o √© melhor detectar bugs quando um produto est√° em desenvolvimento e n√£o depois que ele √© lan√ßado? </h2><br>  Claro que √© melhor. <br><br>  Mas se estivermos falando sobre os motivos do atraso no lan√ßamento do padr√£o C ++, essa pergunta implica duas suposi√ß√µes falsas: <br><br><ul><li>  que antes do lan√ßamento do padr√£o, os recursos n√£o sa√≠am e n√£o eram usados ‚Äã‚Äã(muitos j√° t√™m experi√™ncia em produ√ß√£o); <br></li><li>  e que todos os recursos possam ser usados ‚Äã‚Äãjuntos at√© que o padr√£o seja lan√ßado (n√£o permitido). <br></li></ul><br>  Eu explico: <br><br><ol><li>  A maioria dos principais recursos do C ++ 20 foi implementada da forma em que s√£o refletidos no rascunho atual do padr√£o em pelo menos um compilador e, na maioria dos casos, j√° foram usados ‚Äã‚Äãno c√≥digo de produ√ß√£o (ou seja, j√° est√£o dispon√≠veis para usu√°rios muito satisfeitos) .  Por exemplo, as corotinas (introduzidas apenas cinco meses antes deste artigo) foram usadas por dois anos em produ√ß√£o na MSVC e um ano na Clang, que ficou muito satisfeito com os grandes clientes (por exemplo, Azure e Facebook). </li><li>  N√£o vamos encontrar muitos problemas de intera√ß√£o entre os recursos at√© que os usu√°rios comecem a us√°-los na produ√ß√£o, ou seja, antes do lan√ßamento do padr√£o, porque muitos desenvolvedores esperam que ele seja lan√ßado para implementar projetos diferentes.  E se mostrarmos incerteza sobre o momento do lan√ßamento, essas implementa√ß√µes tamb√©m ser√£o atrasadas.  Bem, eles ainda implementam algo, mas muito ser√° pausado at√© que os desenvolvedores tenham certeza de que estamos prontos para o lan√ßamento.  Pergunte aos criadores do &lt;nome do compilador favorito&gt; o que aconteceu quando eles implementaram o &lt;nome do recurso grande&gt; antes de aparecer no padr√£o publicado.  Em muitos casos, √© necess√°rio implementar repetidamente e interromper os consumidores repetidamente.  Portanto, os desenvolvedores preferem esperar o comit√™ aprovar determinados recursos. </li></ol><br>  Por fim, n√£o se esque√ßa do problema dos recursos de intera√ß√£o.  N√≥s n√£o apenas as liberamos quando estamos prontos, depois disso ainda precisamos de tempo para procurar problemas de intera√ß√£o entre os recursos e adicionar suporte para essas intera√ß√µes, o que simplesmente n√£o conseguimos descobrir antes que os novos recursos sejam amplamente utilizados.  E n√£o importa o quanto adiamos o lan√ßamento do padr√£o, sempre haver√° intera√ß√µes que poderemos explorar apenas muito mais tarde.  Voc√™ precisa gerenciar esse risco com a ajuda do design flex√≠vel, garantindo a compatibilidade dos recursos, e n√£o espere para se livrar de todos os riscos. <br><br><h2>  O padr√£o nunca ser√° perfeito ... voc√™ n√£o libera bugs? </h2><br>  Sim <br><br>  Se percebermos que o recurso n√£o est√° pronto, devemos remov√™-lo do lan√ßamento. <br><br>  Se percebermos que um recurso pode ser melhor e sabemos que a mudan√ßa pode ser compat√≠vel com vers√µes anteriores, esse n√£o √© um motivo para recusar seu lan√ßamento agora.  Ele pode ser lan√ßado como uma extens√£o no C ++ a seguir. <br><br>  Intencionalmente, lan√ßamos recursos que planejamos melhorar no futuro, enquanto estamos confiantes de que podemos manter a compatibilidade com vers√µes anteriores. <br><br><h2>  Mas voc√™ n√£o deve tentar minimizar os erros de libera√ß√£o? </h2><br>  Sim  Estamos tentando. <br><br>  Mas n√£o tentamos evitar todos os riscos.  H√° tamb√©m um risco e (poss√≠vel) pre√ßo de se recusar a liberar o que parece pronto para n√≥s.  E mais frequentemente do que n√£o, estamos certos. <br><br><h2>  Tem certeza de que agora a qualidade √© melhor do que usar a abordagem (1)? </h2><br>  Sim <br><br>  De acordo com as m√©tricas objetivas, o volume de coment√°rios de diferentes pa√≠ses e os relat√≥rios de erros, C ++ 14 e C ++ 17 foram nossos lan√ßamentos mais est√°veis ‚Äã‚Äãe, por essas m√©tricas, foram 3-4 vezes maiores que C ++ 98 e C ++ 11.  E o motivo est√° justamente na regularidade dos lan√ßamentos, na coloca√ß√£o de grandes recursos em primeiro lugar nos ramos TS (incluindo descri√ß√µes completas de sua integra√ß√£o com o padr√£o principal) e na infus√£o subsequente, quando estamos convencidos da disponibilidade. <br><br>  Desde 2012, o padr√£o principal <b>sempre foi</b> mantido em um estado quase pronto para o envio (portanto, at√© rascunhos de rascunhos da mesma alta qualidade que os lan√ßamentos dos padr√µes C ++ 98 e C ++ 11).  Isso nunca aconteceu antes, quando mantivemos o paciente inseguro por um longo tempo, com longas listas de problemas e √≥rg√£os espalhados, os quais vamos colocar em breve.  Agora sabemos que podemos manter um cronograma com trabalho de alta qualidade, porque sempre permanecemos em um estado de prontid√£o para libera√ß√£o.  Se preferir, voc√™ pode lan√ßar um CD agora mesmo, sem se reunir em Col√¥nia, e ainda assim a qualidade seria muito maior do que nunca com um CD C ++ 98 ou C ++ 11 (na verdade, e seus padr√µes publicados) .  E considerando que C ++ 98 e C ++ 11 foram bem-sucedidos, o entendimento de que agora a qualidade √© ainda mais alta significa que estamos no caminho certo. <br><br><h2>  C ++ 98 e C ++ 11 foram desenvolvidos por cerca de 9 anos e eram produtos muito bons ... </h2><br>  Sim: 1989-1998 e 2002-2011. <br><br><h2>  ... e C ++ 14 e C ++ 17 foram lan√ßamentos menores.  O C ++ 20 √© uma vers√£o importante? </h2><br>  Repito, acredito que √© correto comparar C ++ 14 + 17 + 20 como um todo: este √© o nosso ciclo de nove anos, mas desde que aderimos √† abordagem (2), tamb√©m lan√ßamos os desenvolvimentos que estavam prontos para concluir os ciclos de tr√™s e seis anos. . <br><br><h2>  A abordagem (2) permite atingir objetivos baseados em recursos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P0592</a> para o pr√≥ximo C ++? </h2><br>  Claro!  Embora n√£o haja palavras como "deve incluir esses recursos", porque ser√° a abordagem (1). <br><br>  Lutar por um determinado conjunto de recursos e dar prioridade a um deles √© normal, mas √© uma quest√£o de prioridade.  At√© o momento, pegaremos apenas o que est√° pronto, mas podemos escolher o que trabalhar antes de tudo, a fim de nos preparar o mais r√°pido poss√≠vel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460665/">https://habr.com/ru/post/pt460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460647/index.html">Solu√ß√£o de um trabalho com pwnable.kr 05 - c√≥digo de acesso. Reescreva a tabela de links de procedimentos atrav√©s da vulnerabilidade de cadeia de formato</a></li>
<li><a href="../pt460651/index.html">Reuni√£o da Sociedade de Testadores An√¥nimos: TMS, monitoramento, monitoramento, avalia√ß√£o da qualidade da pesquisa e testes iOS nativos</a></li>
<li><a href="../pt460655/index.html">Como quebrei o Telegram</a></li>
<li><a href="../pt460659/index.html">Usando Tubos para Giro</a></li>
<li><a href="../pt460661/index.html">Tudo o que voc√™ precisa saber sobre o Node.js</a></li>
<li><a href="../pt460667/index.html">Automa√ß√£o de teste de servi√ßos pagos no iOS</a></li>
<li><a href="../pt460669/index.html">Como garantir a seguran√ßa do desenvolvimento, economizando tempo e nervosismo</a></li>
<li><a href="../pt460671/index.html">Propriedade e empr√©stimos em D</a></li>
<li><a href="../pt460673/index.html">Expor a magia do DiffUtil</a></li>
<li><a href="../pt460675/index.html">Extra√ß√£o de dados de aprendizado de m√°quina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>