<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🤳 🚋 Rascunho de FAQ: Por que os padrões C ++ são lançados a cada três anos? ⛹🏿 🤜🏽 👋🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O WG21 possui um cronograma rígido (consulte a P1000 ) para liberação padrão a cada três anos. E sem atrasos. 

 Durante cada ciclo, recebemos regular...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rascunho de FAQ: Por que os padrões C ++ são lançados a cada três anos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  O WG21 possui um cronograma rígido (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1000</a> ) para liberação padrão a cada três anos.  E sem atrasos. <br><br>  Durante cada ciclo, recebemos regularmente perguntas “Por que isso é tão rigoroso?”, Especialmente de novos membros do comitê que não estão familiarizados com a sua história e as razões do estado atual das coisas.  E durante uma teleconferência preliminar com o governo de Colônia, várias pessoas recomendaram descrever por que estávamos fazendo isso e como foi tomada a decisão de adotar esse cronograma. <br><br>  Pintei tudo isso na forma de perguntas e respostas para o próximo rascunho do P1000 e enviei uma cópia aos membros do comitê a caminho de Colônia.  Este material será publicado na próxima versão pública do P1000; enviaremos em algumas semanas a partir do momento atual. <br><br>  No entanto, o rascunho das perguntas frequentes pode ser de interesse do público, por isso ofereço uma cópia dele.  Espero que, na maioria das vezes, seja útil para você, esclarecer de alguma forma e talvez até divertir um pouco. <br><br><a name="habracut"></a><br><h2>  Existem erros no padrão, você deve adiar o C ++ 20? </h2><br>  Claro que sim e não. <br><br>  Estamos nos movendo em uma determinada direção na velocidade escolhida: as correções estão planejadas para este ano passado, portanto a programação no início do C ++ “19” (Kona) estabelece um prazo para interromper a adição de recursos (congelamento de recursos) no C ++ “20”, para que tivemos um ano para corrigir bugs, inclusive trabalhando com comentários de diferentes países neste verão.  Antes do início de 2020 (reuniões em Colônia, Belfast e Praga), devemos fornecer feedback e aplicar outras soluções para os problemas, bem como correções de bugs. <br><br><h2>  Se tivermos mais uma ou duas reuniões, podemos adicionar um &lt;nome do recurso&gt;, que está quase pronto, então você deve adiar o C ++ 20? </h2><br>  Claro que sim e não. <br><br>  Aguarde mais algumas reuniões (depois de Praga), e o C ++ 23 estará aberto para negócios, e antes de tudo votaremos em adicionar &lt;nome do recurso&gt; ao rascunho de trabalho do C ++ 23.  Foi o que fizemos com os conceitos: eles não estavam prontos para a transição do TS diretamente para o C ++ 17.  Portanto, na primeira reunião do C ++ 20 (em Toronto), eles votaram na transferência da funcionalidade básica dos conceitos para o rascunho do C ++ 20, que deu muito tempo para melhorar e refinar o restante da parte contraditória do TS (sintaxe não-modelo), introduzida ano que vem (San Diego).  Agora toda a funcionalidade está pronta. <br><br><h2>  Isso parece ser muito rigoroso.  Por que liberar versões IS em intervalos fixos (três anos)? </h2><br>  Como no caso do lançamento do C ++ IS, essa é uma das duas principais opções para gerenciamento de projetos, e a experiência mostra que essa opção é melhor que a segunda. <br><br><h2>  Quais são as duas opções para gerenciamento de projetos para o lançamento do C ++ IS? </h2><br>  Que bom que você perguntou. <br><br>  No caso de uma liberação, há duas opções principais: escolha um recurso ou uma data de liberação e, quando você seleciona uma, perde o controle sobre a definição da outra.  Você não pode controlar os dois simultaneamente.  Em resumo: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Se nós controlamos <br></th><th>  Vamos parar de controlá-lo <br></th><th> Podemos trabalhar em "grandes" recursos plurianuais? <br></th><th>  Quando adicionamos recursos ao rascunho de IS? <br></th><th>  O que fazemos se encontrarmos problemas com recursos adicionais? <br></th></tr><tr><td>  <b>"O quê": recursos que enviamos</b> <br></td><td>  "Quando": data de lançamento. <br></td><td>  Sim, nos documentos com as propostas e o rascunho de SI. <br></td><td>  Geralmente mais cedo para realizar mais testes de integração → a estabilidade média do rascunho de trabalho é reduzida. <br></td><td>  Adiamos o lançamento do padrão. <br></td></tr><tr><td>  <b>Quando: Data de Lançamento</b> <br></td><td>  "O quê": recursos que enviamos <br></td><td>  Sim, em documentos com ofertas e "ramos de recursos" no TS. <br></td><td>  Geralmente mais tarde, quando o recurso é melhor elaborado → a estabilidade média do rascunho de trabalho aumenta. <br></td><td>  Removemos o recurso, depois podemos adicioná-lo novamente se estiver pronto no momento em que o próximo trem IS for enviado. <br></td></tr></tbody></table></div><br>  Eu explico: <br><br>  <b>(1) “O quê”: selecionamos recursos e enviamos como prontos, sem necessidade de escolher um horário de lançamento</b> .  Se você precisar de mais tempo para finalizar um recurso do rascunho do padrão, o mundo inteiro terá que esperar por você.  Você trabalha em grandes recursos que requerem vários anos de desenvolvimento e tenta parar de trabalhar em novos recursos enquanto estabiliza o lançamento. <br><br>  O mesmo ocorreu com o C ++ 98 (era esperado por volta de 1994, Björn disse que, se o lançamento não fosse lançado, seria um fracasso) com o C ++ 11 (chamado 0x porque x era esperado em 2007 )  Essa é uma abordagem “deixe o paciente sem proteção” por um período indeterminado, o que levou a um atraso nos testes e na liberação da integração.  E isso, por sua vez, levou a uma grande incerteza no mercado em relação ao momento do próximo padrão e se ele será lançado (sim, não apenas os participantes do desenvolvimento, mas mesmo alguns membros do comitê duvidaram seriamente em 1996 e 2009). existem lançamentos relevantes).  Por vários anos, a maioria dos compiladores não atendeu ao padrão, porque ninguém sabia quantas mudanças incompatíveis o comitê lançaria no novo lançamento ou quando seria esperado?  Isso levou a uma ampla variedade e fragmentação do suporte a C ++ nos compiladores disponíveis para a comunidade. <br><br>  Por que fizemos isso, somos idiotas?  Na verdade, eles eram inexperientes e ... digamos "otimistas".  Era uma estrada pavimentada com as melhores intenções.  Em 1994-1996 e em 2007-2009, acreditávamos realmente que agora promoveríamos mais uma, duas ou três reuniões e faríamos tudo, e cada vez que elas seriam adiadas por até quatro anos.  E agora eles viram por sua própria experiência que não pode haver transferência por um ano ou dois. <br><br>  Felizmente, tudo mudou graças à opção (2). <br><br>  <b>(2) “Quando”: selecionamos a data de lançamento e enviamos os recursos que estão prontos, você não precisa selecionar um conjunto de recursos</b> .  Se for necessário mais tempo para refinar um recurso de um rascunho de padrão, nós o descartamos e enviamos o que está pronto.  Você pode continuar trabalhando em grandes recursos, cuja criação leva tempo como em várias versões, mas em "ramificações" de terceiros, adicionando-as à ramificação mestre do IS assim que possível.  E você trabalha constantemente nos recursos, porque o desenvolvimento deles é completamente separado da versão atual (não há grande ponto de conexão). <br><br>  Nós aderimos a essa abordagem desde 2012 e não queremos abandoná-la.  Essa é a abordagem de "remendar regularmente o paciente", que leva à expectativa de maior qualidade devido às integrações regulares forçadas e à recusa de adicionar trabalho ao rascunho do SI até que ele atinja um certo nível de estabilidade, geralmente dentro do ramo de recursos.  Também cria um ciclo de liberação previsível em que o mercado pode confiar.  Ao longo dos anos, os autores dos compiladores começaram cada vez mais cedo, após o próximo lançamento, a lançar versões de seus produtos em conformidade com o padrão, o que nunca havia acontecido antes.  E em 2020, esperamos o lançamento de implementações totalmente compatíveis em um ano com o lançamento do padrão, o que também nunca aconteceu antes.  Isso é apenas para o benefício de todo o mercado - desenvolvedores, usuários, professores. <br><br>  Observe também que, desde que começamos a aderir a essa abordagem, começamos a fazer mais (se medido por recursos grandes, médios e pequenos) e com maior qualidade (se medido por uma redução rigorosa no número de relatórios de bugs e comentários sobre rascunhos de cada norma).  Apesar de enviarmos o que conseguimos preparar (e se não conseguimos algo, não enviamos). <br><br><h2>  Você está falando sério sobre a abordagem (2)?  Se, de acordo com um membro autoritário do comitê, algum grande recurso estiver "quase pronto", você ficará tentado a esperar um pouco, certo? </h2><br>  Muito a sério, e não. <br><br>  Temos estatísticas: em 2016 em Jacksonville, quando finalmente decidimos os recursos do C ++ 17, Björn Straustrup falou em uma reunião plenária com uma proposta para incluir conceitos no C ++ 17.  Quando nenhum consenso foi alcançado, foi perguntado diretamente a Straustrup se ele queria adiar o lançamento do C ++ 17 por um ano para incluir conceitos nele.  Björn respondeu "não" sem hesitação e evasão e acrescentou que o C ++ 17 sem conceitos era mais importante que o C ++ 18 ou o C ++ 19 com conceitos, embora a Straustrup os trabalhasse há cerca de 15 anos.  A escolha foi a seguinte: (2) lançamos o C ++ 17 sem conceitos e depois o C ++ 20 com os conceitos (o que fizemos), ou (1) renomeamos o C ++ 17 para C ++ 20, que é isomórfico (2) com exceção de pular o C ++ 17 e recusar-se a liberar o que já estava pronto para o C ++ 17. <br><br><h2>  E a troca entre (1) e (2)?  Digamos, geralmente aderimos a (2), mas com "pouca" flexibilidade em termos de "um pouco" de tempo extra, se você precisar refinar o recurso? </h2><br>  Não, porque acontece (1). <br><br>  Fred Brooks, no <i>The Mythical Man-Month,</i> explicou popularmente “a pequena transferência mítica” e concluiu: “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Não permita nenhuma transferência pequena</a> ”. <br><br>  Imagine que portamos o C ++ 20.  Teríamos que voltar de (2) a (1), por mais que tentássemos evitá-lo e, ao mesmo tempo, não receberíamos nenhum benefício.  Se decidíssemos adiar o C ++ 20 para aperfeiçoá-lo, adiaríamos o padrão por pelo menos dois anos.  Não existem conceitos como a transferência de uma ou três reuniões, porque durante esse período outros continuarão (razoavelmente) a dizer: "Bem, meu recurso precisa apenas de mais uma reunião, ainda a remarcamos, vamos transferir outra".  E se transferirmos pelo menos dois anos, isso significa que o C ++ 20 se torna C ++ 22 e provavelmente C ++ 23 ... mas já vamos enviar o C ++ 23!  - Ou seja, em qualquer caso, enviaremos o C ++ 23, e a única diferença é que <b>não</b> transferimos o C ++ 20 com uma grande quantidade de trabalho realizado, pronto para o lançamento, e não fazemos o mundo inteiro esperar mais três anos.  O atraso não beneficiará esses recursos, a maioria deles ou todos juntos. <br><br>  Portanto, a frase é equivalente a "vamos transformar C ++ 20 em C ++ 22 ou C ++ 23" e a resposta simples: "sim, teremos C ++ 23, mas além de C ++ 20, e não em seu lugar. "  Um atraso no C ++ 20 significa pular o C ++ 20 em vez de liberar um produto final bom, estável e estável, e não haverá benefício disso. <br><br><h2>  Mas o recurso X está quebrado / leva mais tempo do que resta para corrigir bugs no C ++ 20! </h2><br>  Nenhuma pergunta!  Nós podemos simplesmente cortá-lo. <br><br>  Nesse caso, alguém precisará escrever uma carta em EWG ou LEWG (dependendo da situação) com uma descrição da situação e oferecer a remoção do recurso do rascunho de IS.  Esses grupos considerarão a apelação e, se decidirem que o recurso está quebrado (e o plenário concordar com eles), o recurso será adiado para a próxima versão do C ++.  Já fizemos isso com os conceitos de C ++ 0x. <br><br>  Mas no caso de (1), transferiremos não apenas esse recurso, mas <b>todo o conjunto de recursos</b> de C ++ 20 para C ++ 23!  Isso seria ... busto. <br><br><h2>  A abordagem (2) significa lançamentos "principais / secundários"? </h2><br>  Não.  No começo, dissemos isso até percebermos que (2) significa apenas que você não precisa escolher um conjunto de recursos, mesmo do ponto de vista da versão "principal / secundária". <br><br>  A abordagem (2) significa apenas "enviamos o que está pronto".  Lançamentos são obtidos: <br><br><ul><li>  o mesmo tamanho (ou seja, geralmente médio) dos recursos é "menor" porque menos tempo é gasto em seu desenvolvimento (digamos, menos de três anos cada) e, em geral, obtemos o mesmo número de recursos concluídos no lançamento; <br></li><li>  e um tamanho variável (não é necessário uma ou duas vezes) para os recursos "maiores", que levam mais tempo (digamos, mais de três anos cada), e cada versão do IS inclui tantos desses recursos quanto eles conseguem concluir para a versão.  Portanto, em alguns lançamentos há mais, em outros menos. <br></li></ul><br>  C ++ 14 e C ++ 17 eram relativamente pequenos, porque muito esforço de padronização foi gasto em recursos de longa execução descritos nas propostas de implementação (por exemplo, contratos) e "ramificações de recursos" no TS (por exemplo, conceitos). <br><br><h2>  C ++ 20 é um ótimo lançamento ... </h2><br>  Sim  O C ++ 20 possui muitos recursos principais.  Três dos maiores começam com “ko” (conceitos, contratos, corotinas), então podemos chamá-lo de co_cpp20.  Ou co_dependente. <br><br><h2>  ... e não é muito feito no ciclo de três anos para C ++ 20? </h2><br>  Não, veja acima "uma vez por vez não é necessário". <br><br>  O C ++ 20 é grande, não porque fizemos mais em três anos, mas porque há muitos desenvolvimentos longos (incluindo pelo menos dois nos quais estamos trabalhando no formulário atual desde 2012 na forma de frases P e TS) ) atingiram o estágio de prontidão e decidiram incluí-los no rascunho de IS da mesma versão. <br><br>  Quase sempre, os principais recursos são desenvolvidos por muitos anos.  A principal diferença entre a abordagem (1) para C ++ 98 e C ++ 11 e a abordagem (2) é que, em C ++ 98 e C ++ 11, o lançamento foi adiado até que todos esses recursos estivessem prontos, e agora enviamos grandes assim que estiver pronto, e junto com eles lançaremos muito mais. <br><br>  O C ++ 20 passou pelo mesmo ciclo de três anos que o C ++ 14 e o C ++ 17.  Não fizemos mais nos últimos três anos do que nos dois ciclos anteriores, apenas acrescentamos mais aos principais recursos.  Se algum deles não estivesse pronto, já o teríamos descartado e já terminado para o C ++ 23.  Se isso acontecer, reportaremos isso na proposta de implementação e explicaremos os motivos. <br><br>  C ++ 14 + 17 + 20 compôs nosso terceiro ciclo de nove anos (2011-2020) após C ++ 98 (1989-1998) e C ++ 11 (2002-2011).  Mas desde que aderimos à abordagem (2), <b>também</b> lançamos desenvolvimentos prontos para o final dos ciclos de três e seis anos. <br><br><h2>  Não é melhor detectar bugs quando um produto está em desenvolvimento e não depois que ele é lançado? </h2><br>  Claro que é melhor. <br><br>  Mas se estivermos falando sobre os motivos do atraso no lançamento do padrão C ++, essa pergunta implica duas suposições falsas: <br><br><ul><li>  que antes do lançamento do padrão, os recursos não saíam e não eram usados ​​(muitos já têm experiência em produção); <br></li><li>  e que todos os recursos possam ser usados ​​juntos até que o padrão seja lançado (não permitido). <br></li></ul><br>  Eu explico: <br><br><ol><li>  A maioria dos principais recursos do C ++ 20 foi implementada da forma em que são refletidos no rascunho atual do padrão em pelo menos um compilador e, na maioria dos casos, já foram usados ​​no código de produção (ou seja, já estão disponíveis para usuários muito satisfeitos) .  Por exemplo, as corotinas (introduzidas apenas cinco meses antes deste artigo) foram usadas por dois anos em produção na MSVC e um ano na Clang, que ficou muito satisfeito com os grandes clientes (por exemplo, Azure e Facebook). </li><li>  Não vamos encontrar muitos problemas de interação entre os recursos até que os usuários comecem a usá-los na produção, ou seja, antes do lançamento do padrão, porque muitos desenvolvedores esperam que ele seja lançado para implementar projetos diferentes.  E se mostrarmos incerteza sobre o momento do lançamento, essas implementações também serão atrasadas.  Bem, eles ainda implementam algo, mas muito será pausado até que os desenvolvedores tenham certeza de que estamos prontos para o lançamento.  Pergunte aos criadores do &lt;nome do compilador favorito&gt; o que aconteceu quando eles implementaram o &lt;nome do recurso grande&gt; antes de aparecer no padrão publicado.  Em muitos casos, é necessário implementar repetidamente e interromper os consumidores repetidamente.  Portanto, os desenvolvedores preferem esperar o comitê aprovar determinados recursos. </li></ol><br>  Por fim, não se esqueça do problema dos recursos de interação.  Nós não apenas as liberamos quando estamos prontos, depois disso ainda precisamos de tempo para procurar problemas de interação entre os recursos e adicionar suporte para essas interações, o que simplesmente não conseguimos descobrir antes que os novos recursos sejam amplamente utilizados.  E não importa o quanto adiamos o lançamento do padrão, sempre haverá interações que poderemos explorar apenas muito mais tarde.  Você precisa gerenciar esse risco com a ajuda do design flexível, garantindo a compatibilidade dos recursos, e não espere para se livrar de todos os riscos. <br><br><h2>  O padrão nunca será perfeito ... você não libera bugs? </h2><br>  Sim <br><br>  Se percebermos que o recurso não está pronto, devemos removê-lo do lançamento. <br><br>  Se percebermos que um recurso pode ser melhor e sabemos que a mudança pode ser compatível com versões anteriores, esse não é um motivo para recusar seu lançamento agora.  Ele pode ser lançado como uma extensão no C ++ a seguir. <br><br>  Intencionalmente, lançamos recursos que planejamos melhorar no futuro, enquanto estamos confiantes de que podemos manter a compatibilidade com versões anteriores. <br><br><h2>  Mas você não deve tentar minimizar os erros de liberação? </h2><br>  Sim  Estamos tentando. <br><br>  Mas não tentamos evitar todos os riscos.  Há também um risco e (possível) preço de se recusar a liberar o que parece pronto para nós.  E mais frequentemente do que não, estamos certos. <br><br><h2>  Tem certeza de que agora a qualidade é melhor do que usar a abordagem (1)? </h2><br>  Sim <br><br>  De acordo com as métricas objetivas, o volume de comentários de diferentes países e os relatórios de erros, C ++ 14 e C ++ 17 foram nossos lançamentos mais estáveis ​​e, por essas métricas, foram 3-4 vezes maiores que C ++ 98 e C ++ 11.  E o motivo está justamente na regularidade dos lançamentos, na colocação de grandes recursos em primeiro lugar nos ramos TS (incluindo descrições completas de sua integração com o padrão principal) e na infusão subsequente, quando estamos convencidos da disponibilidade. <br><br>  Desde 2012, o padrão principal <b>sempre foi</b> mantido em um estado quase pronto para o envio (portanto, até rascunhos de rascunhos da mesma alta qualidade que os lançamentos dos padrões C ++ 98 e C ++ 11).  Isso nunca aconteceu antes, quando mantivemos o paciente inseguro por um longo tempo, com longas listas de problemas e órgãos espalhados, os quais vamos colocar em breve.  Agora sabemos que podemos manter um cronograma com trabalho de alta qualidade, porque sempre permanecemos em um estado de prontidão para liberação.  Se preferir, você pode lançar um CD agora mesmo, sem se reunir em Colônia, e ainda assim a qualidade seria muito maior do que nunca com um CD C ++ 98 ou C ++ 11 (na verdade, e seus padrões publicados) .  E considerando que C ++ 98 e C ++ 11 foram bem-sucedidos, o entendimento de que agora a qualidade é ainda mais alta significa que estamos no caminho certo. <br><br><h2>  C ++ 98 e C ++ 11 foram desenvolvidos por cerca de 9 anos e eram produtos muito bons ... </h2><br>  Sim: 1989-1998 e 2002-2011. <br><br><h2>  ... e C ++ 14 e C ++ 17 foram lançamentos menores.  O C ++ 20 é uma versão importante? </h2><br>  Repito, acredito que é correto comparar C ++ 14 + 17 + 20 como um todo: este é o nosso ciclo de nove anos, mas desde que aderimos à abordagem (2), também lançamos os desenvolvimentos que estavam prontos para concluir os ciclos de três e seis anos. . <br><br><h2>  A abordagem (2) permite atingir objetivos baseados em recursos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P0592</a> para o próximo C ++? </h2><br>  Claro!  Embora não haja palavras como "deve incluir esses recursos", porque será a abordagem (1). <br><br>  Lutar por um determinado conjunto de recursos e dar prioridade a um deles é normal, mas é uma questão de prioridade.  Até o momento, pegaremos apenas o que está pronto, mas podemos escolher o que trabalhar antes de tudo, a fim de nos preparar o mais rápido possível. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460665/">https://habr.com/ru/post/pt460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460647/index.html">Solução de um trabalho com pwnable.kr 05 - código de acesso. Reescreva a tabela de links de procedimentos através da vulnerabilidade de cadeia de formato</a></li>
<li><a href="../pt460651/index.html">Reunião da Sociedade de Testadores Anônimos: TMS, monitoramento, monitoramento, avaliação da qualidade da pesquisa e testes iOS nativos</a></li>
<li><a href="../pt460655/index.html">Como quebrei o Telegram</a></li>
<li><a href="../pt460659/index.html">Usando Tubos para Giro</a></li>
<li><a href="../pt460661/index.html">Tudo o que você precisa saber sobre o Node.js</a></li>
<li><a href="../pt460667/index.html">Automação de teste de serviços pagos no iOS</a></li>
<li><a href="../pt460669/index.html">Como garantir a segurança do desenvolvimento, economizando tempo e nervosismo</a></li>
<li><a href="../pt460671/index.html">Propriedade e empréstimos em D</a></li>
<li><a href="../pt460673/index.html">Expor a magia do DiffUtil</a></li>
<li><a href="../pt460675/index.html">Extração de dados de aprendizado de máquina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>