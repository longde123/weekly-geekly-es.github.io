<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèæ üßíüèΩ ‚õÖÔ∏è WBOIT no OpenGL: transpar√™ncia sem classifica√ß√£o üõåüèæ üë©üèæ‚Äç‚öñÔ∏è ‚ôêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Falaremos sobre ‚ÄúTranspar√™ncia ponderada independente de ordem combinada‚Äù (a seguir denominada WBOIT) - a t√©cnica descrita no JCGT em 2013 ( link ). 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT no OpenGL: transpar√™ncia sem classifica√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/">  Falaremos sobre ‚ÄúTranspar√™ncia ponderada independente de ordem combinada‚Äù (a seguir denominada WBOIT) - a t√©cnica descrita no JCGT em 2013 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ). <br><a name="habracut"></a><br>  Quando v√°rios objetos transparentes aparecem na tela, a cor do pixel depende de qual deles est√° mais pr√≥ximo do observador.  Aqui est√° uma f√≥rmula de mistura de cores bem conhecida para este caso: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  A ordem do arranjo do fragmento √© importante para ele: a cor do fragmento pr√≥ximo e sua opacidade s√£o denotadas como C <sub>pr√≥ximo</sub> e <i>Œ±</i> , e a cor resultante de todos os fragmentos que est√£o localizados atr√°s dele √© denotada como C <sub>distante</sub> .  Opacidade √© uma propriedade que leva valores de 0 a 1, em que 0 significa que o objeto √© t√£o transparente que n√£o √© vis√≠vel e 1 - que √© t√£o opaco que nada √© vis√≠vel <i>por tr√°s dele</i> . <br><br>  Para usar essa f√≥rmula, voc√™ deve primeiro classificar os fragmentos por profundidade.  Imagine quanta dor de cabe√ßa isso envolve!  Em geral, a classifica√ß√£o deve ser feita em cada quadro.  Se voc√™ estiver classificando objetos, alguns objetos de forma complexa precisar√£o ser cortados em peda√ßos e classificados pela profundidade das partes cortadas (em particular, para superf√≠cies que se cruzam, isso definitivamente precisar√° ser feito).  Se voc√™ classificar os fragmentos, a classifica√ß√£o ocorrer√° nos shaders.  Essa abordagem √© chamada de "transpar√™ncia independente do pedido" (OIT) e usa uma lista vinculada armazenada na mem√≥ria da placa de v√≠deo.  Prever quanta mem√≥ria precisar√° ser alocada para esta lista √© quase irreal.  E se n√£o houver mem√≥ria suficiente, os artefatos aparecer√£o na tela. <br><br>  Sorte para quem pode controlar quantos objetos transl√∫cidos s√£o colocados no palco e onde eles s√£o relativos um ao outro.  Mas se voc√™ fizer CAD, ter√° tantos objetos transparentes quanto o usu√°rio desejar, e eles ser√£o localizados aleatoriamente. <br><br>  Agora voc√™ entende o desejo de algumas pessoas de simplificar suas vidas e criar uma f√≥rmula para misturar cores que n√£o exijam classifica√ß√£o.  Essa f√≥rmula est√° no artigo a que me referi no come√ßo.  Existem at√© v√°rias f√≥rmulas l√°, mas a melhor de acordo com os autores (e na minha opini√£o tamb√©m) √© esta: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Na captura de tela h√° grupos de tri√¢ngulos transl√∫cidos localizados em quatro camadas de profundidade.  √Ä esquerda, eles s√£o renderizados usando a t√©cnica WBOIT.  √Ä direita, uma imagem obtida usando a f√≥rmula (1), mistura cl√°ssica de cores, levando em considera√ß√£o a ordem de disposi√ß√£o dos fragmentos.  Em seguida, chamarei CODB (mistura dependente de ordem cl√°ssica). <br><br>  Antes de come√ßarmos a renderizar objetos transparentes, devemos renderizar todos os opacos.  Depois disso, objetos transparentes s√£o renderizados com um teste de profundidade, mas sem gravar no buffer de profundidade (isso √© feito assim: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  Ou seja, √© o que acontece em um ponto com algumas coordenadas da tela (x, y): fragmentos transparentes mais pr√≥ximos do que opacos passam no teste de profundidade, independentemente de como est√£o localizados em profundidade em rela√ß√£o aos fragmentos transparentes j√° desenhados e aos fragmentos transparentes que aparecem mais longe opaco, n√£o passe no teste de profundidade e, portanto, ser√° descartado. <br><br>  C <sub>0</sub> na f√≥rmula (2) √© a cor de um fragmento opaco, sobre o qual s√£o desenhados fragmentos transparentes, dos quais temos n pe√ßas, indicadas pelos √≠ndices 1 a n.  Ci √© a cor do i-√©simo fragmento transparente, <i>Œ±i</i> √© sua opacidade. <br><br>  Se voc√™ olhar atentamente, a f√≥rmula (2) √© um pouco como a f√≥rmula (1).  Se voc√™ imaginar isso <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  C est√° <sub>pr√≥ximo</sub> , C <sub>0</sub> est√° C <sub>distante</sub> e <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - este √© <i>Œ±</i> , ent√£o esta ser√° a 1¬™ f√≥rmula, um a um.  E realmente <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - esta √© a m√©dia ponderada das cores dos fragmentos transparentes (o centro de massa √© determinado na mec√¢nica pela mesma f√≥rmula); ser√° a cor do fragmento C mais <sub>pr√≥ximo</sub> mais <sub>pr√≥ximo</sub> .  C <sub>0</sub> √© a cor do fragmento opaco localizado atr√°s de todos os fragmentos, para o qual calculamos essa m√©dia ponderada e passar√° para C <sub>distante</sub> .  Ou seja, substitu√≠mos todos os fragmentos transparentes por um fragmento ‚Äúm√©dio‚Äù e aplicamos a f√≥rmula padr√£o para misturar cores - f√≥rmula (1).  Qual √© essa f√≥rmula astuta para <i>Œ±</i> que os autores do artigo original nos oferecem? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhcvqDUlyenfqiNSZpVsMNkrSys5Q#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Essa √© uma fun√ß√£o escalar no espa√ßo n-dimensional, ent√£o vamos relembrar a an√°lise diferencial das fun√ß√µes de v√°rias vari√°veis.  Dado que todos os <i>Œ±i</i> pertencem ao intervalo de 0 a 1, a derivada parcial em rela√ß√£o a qualquer uma das vari√°veis ‚Äã‚Äãsempre ser√° uma constante n√£o negativa.  Isso significa que a opacidade do fragmento ‚Äúm√©dio‚Äù aumenta com o aumento da opacidade de qualquer um dos fragmentos transparentes, e √© exatamente isso que precisamos.  Al√©m disso, aumenta linearmente. <br><br>  Se a opacidade de um fragmento for 0, n√£o ser√° vis√≠vel, n√£o afetar√° a cor resultante. <br><br>  Se a opacidade de pelo menos um fragmento for 1, ent√£o <i>Œ±</i> ser√° 1. Ou seja, o fragmento opaco se tornar√° invis√≠vel, o que geralmente √© bom.  Somente os fragmentos transparentes localizados atr√°s do fragmento com opacidade = 1 ainda brilham atrav√©s dele e afetam a cor resultante: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Aqui, um tri√¢ngulo laranja est√° acima, verde embaixo, cinza e ciano sob verde, e tudo isso contra um fundo preto.  Opacidade azul = 1, todos os outros - 0,5.  A imagem √† direita √© como deveria ser.  Como voc√™ pode ver, o WBOIT parece nojento.  O √∫nico lugar em que a cor laranja normal aparece √© a borda do tri√¢ngulo verde, cercada por uma linha branca opaca.  Como eu disse, um fragmento opaco √© invis√≠vel se a opacidade do fragmento transparente for 1. <br><br>  Isso √© ainda melhor visto aqui: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  O tri√¢ngulo laranja tem uma opacidade 1, o verde com a transpar√™ncia desativada √© simplesmente desenhado com os objetos opacos.  Parece que o tri√¢ngulo VERDE brilha atrav√©s da laranja atrav√©s do tri√¢ngulo laranja. <br><br>  Para fazer a imagem parecer decente, a maneira mais f√°cil √© n√£o atribuir objetos com alta opacidade.  No meu projeto de trabalho, n√£o permito definir opacidade maior que 0,5.  Este √© o CAD 3D, no qual os objetos s√£o desenhados esquematicamente e n√£o √© necess√°rio realismo especial; portanto, essa restri√ß√£o √© permitida l√°. <br><br>  Com baixos valores de opacidade, as imagens √† esquerda e √† direita t√™m quase a mesma apar√™ncia: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  E com alto eles diferem acentuadamente: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  √â assim que um poliedro transparente se parece: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  O poliedro possui faces horizontais alaranjadas laterais e verdes.  Infelizmente, voc√™ n√£o entender√° isso √† primeira vista, ou seja,  a imagem n√£o parece convincente.  Onde h√° uma parede laranja na frente, voc√™ precisa de mais que laranja e onde verde √© mais que verde.  Ser√° muito melhor desenhar rostos de uma cor: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  WBOIT baseado em profundidade </h3><br>  Para compensar de alguma forma a falta de classifica√ß√£o por profundidade, os autores do artigo apresentaram v√°rias op√ß√µes para adicionar profundidade √† f√≥rmula (2).  Isso torna a implementa√ß√£o mais dif√≠cil e o resultado menos previs√≠vel e dependente das caracter√≠sticas de uma cena tridimensional espec√≠fica.  Eu n√£o mergulhei neste t√≥pico, ent√£o quem se importa - proponho ler o artigo. <br><br>  Argumenta-se que o WBOIT √†s vezes √© capaz de algo que a transpar√™ncia de classifica√ß√£o cl√°ssica n√£o pode.  Por exemplo, voc√™ extrai a fuma√ßa como um sistema de part√≠culas usando apenas duas part√≠culas - com fuma√ßa escura e clara.  Quando uma part√≠cula passa por outra, a mistura cl√°ssica de cores com a classifica√ß√£o produz um resultado feio - a cor da fuma√ßa da luz se torna nitidamente escura.  O artigo diz que o WBOIT sens√≠vel √† profundidade permite uma transi√ß√£o suave e parece mais cr√≠vel.  O mesmo pode ser dito sobre a modelagem de p√™los e cabelos na forma de tubos finos. <br><br><h3>  C√≥digo </h3><br>  Agora, sobre como implementar a f√≥rmula (2) no OpenGL.  O c√≥digo de exemplo est√° no Github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ), e a maioria das imagens no artigo √© de l√°.  Voc√™ pode colecionar e brincar com meus tri√¢ngulos.  A estrutura Qt √© usada. <br><br>  Para aqueles que est√£o come√ßando a estudar a renderiza√ß√£o de objetos transparentes, recomendo estes dois artigos: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Li√ß√£o 4.3 - Misturando cores</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algoritmo de transpar√™ncia independente do pedido usando listas vinculadas no Direct3D 11 e OpenGL 4</a> <br><br>  O segundo, no entanto, n√£o √© t√£o importante para a compreens√£o desse material, mas o primeiro √© uma leitura obrigat√≥ria. <br><br>  Para calcular a f√≥rmula (2), precisamos de 2 buffers de quadros adicionais, 3 texturas com v√°rias amostras e um buffer de renderiza√ß√£o, no qual escreveremos a profundidade.  Na primeira textura - colorTextureNT (NT significa n√£o transparente) - renderizaremos objetos opacos.  Possui o tipo GL_RGB10_A2.  A segunda textura (colorTexture) ser√° do tipo GL_RGBA16F;  nos 3 primeiros componentes desta textura, escreveremos este peda√ßo de f√≥rmula (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  no quarto - <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Outra textura do tipo GL_R16 (alphaTexture) conter√° <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Primeiro, voc√™ precisa criar esses objetos para obter seus identificadores no OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Como eu disse, a estrutura Qt √© usada aqui e todas as chamadas do OpenGL passam por um objeto do tipo QOpenGLFunctions_4_5_Core, que √© sempre referido como f para mim. <br><br>  Agora voc√™ deve alocar mem√≥ria: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  E configure framebuffers: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Na segunda passagem de renderiza√ß√£o, a sa√≠da do shader de fragmento ir√° para duas texturas ao mesmo tempo, e isso deve ser especificado explicitamente usando glDrawBuffers. <br><br>  A maior parte desse c√≥digo √© executada uma vez, na inicializa√ß√£o do programa.  O c√≥digo que aloca mem√≥ria para texturas e buffers de renderiza√ß√£o √© chamado toda vez que a janela √© redimensionada.  Em seguida, vem o c√≥digo de renderiza√ß√£o, que √© chamado toda vez que a janela √© redesenhada. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  Acabamos de desenhar todos os objetos opacos na textura colorTextureNT e gravamos as profundidades no buffer de renderiza√ß√£o.  Antes de usar o mesmo renderbuffer no pr√≥ximo est√°gio do desenho, √© necess√°rio garantir que todas as profundidades dos objetos opacos j√° estejam gravadas l√°.  Para isso, GL_FRAMEBUFFER_BARRIER_BIT √© usado.  Ap√≥s renderizar objetos transparentes, chamamos a fun√ß√£o ApplyTextures (), que iniciar√° o est√°gio final de renderiza√ß√£o, no qual o shader de fragmento ler√° os dados das texturas colorTextureNT, colorTexture e alphaTexture para aplicar a f√≥rmula (2).  As texturas deveriam ter sido completamente escritas at√© ent√£o, portanto, antes de chamar ApplyTextures (), usamos GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO √© o buffer de quadros atrav√©s do qual exibimos a imagem.  Na maioria dos casos, √© 0, mas no Qt √© QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Cada vez que o shader do fragmento √© chamado, teremos informa√ß√µes sobre a cor e a opacidade do fragmento atual.  Por√©m, na sa√≠da da textura colorTexture, queremos obter a soma (e na textura alphaTexture o produto) de algumas fun√ß√µes dessas quantidades.  A mistura √© usada para isso.  Al√©m disso, como para a primeira textura calculamos a soma e para a segunda - o produto, as configura√ß√µes de mesclagem (glBlendFunc e glBlendEquation) para cada anexo devem ser definidas separadamente. <br><br>  Aqui est√° o conte√∫do da fun√ß√£o PrepareToTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  E o conte√∫do da fun√ß√£o CleanupAfterTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  No meu shader de fragmento, a opacidade √© indicada pela letra w.  O produto da cor por w e w propriamente dito produzimos para um par√¢metro de sa√≠da e 1 - w para outro.  Para cada par√¢metro de sa√≠da, um qualificador de layout √© definido no formato "location = X", em que X √© o √≠ndice do elemento na matriz de anexos, que passamos para glDrawBuffers na 3¬™ listagem (especificamente, o par√¢metro de sa√≠da com location = 0 √© enviado para a textura associada a GL_COLOR_ATTACHMENT0 e o par√¢metro com location = 1 - na textura anexada a GL_COLOR_ATTACHMENT1).  Os mesmos n√∫meros s√£o usados ‚Äã‚Äãnas fun√ß√µes glBlendFunci e glBlendEquationi para indicar o n√∫mero do anexo para o qual definimos os par√¢metros de mesclagem. <br><br>  Shader do fragmento: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  Na fun√ß√£o ApplyTextures (), simplesmente desenhamos um ret√¢ngulo sobre a janela inteira.  O shader de fragmento solicita dados de todas as texturas que criamos, usando as coordenadas da tela atual como coordenadas de textura e o n√∫mero da amostra atual (gl_SampleID) como o n√∫mero da amostra na textura de v√°rias amostras.  O uso da vari√°vel gl_SampleID no sombreador ativa automaticamente o modo quando o sombreador de fragmento √© chamado uma vez para cada amostra (em condi√ß√µes normais, √© chamado uma vez para todo o pixel e o resultado √© gravado em todas as amostras que estavam dentro do primitivo). <br><br>  N√£o h√° nada not√°vel no shader de v√©rtice: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Shader do fragmento: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  E, finalmente, o conte√∫do da fun√ß√£o ApplyTextures (): <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Bem, seria bom liberar recursos do OpenGL ap√≥s o t√©rmino.  Eu tenho esse c√≥digo chamado no destruidor do meu widget OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457284/">https://habr.com/ru/post/pt457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457262/index.html">An√°lise das qualifica√ß√µes do campeonato de programa√ß√£o entre desenvolvedores de back-end</a></li>
<li><a href="../pt457266/index.html">Crise √°gil. O que fazer</a></li>
<li><a href="../pt457270/index.html">Prisma-CMS como um mecanismo para criar rapidamente MVP</a></li>
<li><a href="../pt457276/index.html">Sete amea√ßas de bot ao seu site</a></li>
<li><a href="../pt457282/index.html">"Morte de Deus" ou o colapso de leis geralmente aceitas para formar equipes de TI e criar sistemas de TI no s√©culo 21</a></li>
<li><a href="../pt457286/index.html">A solu√ß√£o das tarefas WorldSkills do m√≥dulo Rede na compet√™ncia de "CCA". Parte 1 - Configura√ß√£o b√°sica</a></li>
<li><a href="../pt457288/index.html">Esta√ß√£o de trabalho criptogr√°fica baseada em tokens PKCS # 11. Assinatura eletr√¥nica. Parte 2</a></li>
<li><a href="../pt457290/index.html">Confer√™ncia DEFCON 25. Garry Kasparov. "A √∫ltima batalha do c√©rebro." Parte 2</a></li>
<li><a href="../pt457292/index.html">WBOIT no OpenGL: transpar√™ncia sem classifica√ß√£o</a></li>
<li><a href="../pt457294/index.html">"Viva alto" ou minha hist√≥ria, da procrastina√ß√£o ao autodesenvolvimento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>