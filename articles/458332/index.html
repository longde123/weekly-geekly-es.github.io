<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üë©üèΩ‚Äçüé§ üë©üèΩ‚Äçüöí Programaci√≥n as√≠ncrona: rendimiento as√≠ncrono: comprenda los costos de as√≠ncrono y aguarde üìç üêú üåÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es bastante antiguo, pero no perdi√≥ su relevancia. Cuando se trata de as√≠ncrono / espera, generalmente aparece un enlace. No pude encont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n as√≠ncrona: rendimiento as√≠ncrono: comprenda los costos de as√≠ncrono y aguarde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458332/"><p>  Este art√≠culo es bastante antiguo, pero no perdi√≥ su relevancia.  Cuando se trata de as√≠ncrono / espera, generalmente aparece un enlace.  No pude encontrar una traducci√≥n al ruso, decid√≠ ayudar a alguien que no habla con fluidez. </p><br><hr><br><p> La programaci√≥n asincr√≥nica ha sido durante mucho tiempo el reino de los desarrolladores m√°s experimentados con ansias de masoquismo: aquellos que ten√≠an suficiente tiempo libre, inclinaci√≥n y capacidad ps√≠quica para pensar en las devoluciones de llamadas en un flujo de ejecuci√≥n no lineal.  Con el advenimiento de Microsoft .NET Framework 4.5, C # y Visual Basic nos trajeron a todos asincron√≠a, por lo que los simples mortales ahora pueden escribir m√©todos asincr√≥nicos casi tan f√°cilmente como los s√≠ncronos.  Las devoluciones de llamada ya no son necesarias.  No m√°s c√≥digo de c√°lculo expl√≠cito de un contexto de sincronizaci√≥n a otro.  No m√°s preocupaciones sobre c√≥mo se mueven los resultados de ejecuci√≥n o las excepciones.  No hay necesidad de trucos que distorsionen los medios de los lenguajes de programaci√≥n para la conveniencia de desarrollar c√≥digo asincr√≥nico.  En resumen, no hay m√°s problemas y dolor de cabeza. </p><a name="habracut"></a><br><p>  Por supuesto, aunque ahora es f√°cil comenzar a escribir m√©todos asincr√≥nicos (ver los art√≠culos de Eric Lippert y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mads Torgersen</a> en esta <em>revista MSDN [OCTUBRE 2011]</em> ), se requiere comprensi√≥n para hacerlo correctamente. lo que pasa debajo del cap√≥  Cada vez que un lenguaje o biblioteca eleva el nivel de abstracci√≥n que un desarrollador puede usar, esto inevitablemente se acompa√±a de costos ocultos que reducen la productividad.  En muchos casos, estos costos son insignificantes, por lo que la mayor√≠a de los programadores pueden descuidarlos en la mayor√≠a de los casos.  Sin embargo, los desarrolladores avanzados deben comprender completamente qu√© costos est√°n presentes para tomar las medidas necesarias y resolver posibles problemas si se manifiestan.  Esto es necesario cuando se utilizan herramientas de programaci√≥n asincr√≥nicas en C # y Visual Basic. </p><br><p>  En este art√≠culo, describir√© las entradas y salidas de los m√©todos asincr√≥nicos, describir√© c√≥mo se implementan los m√©todos asincr√≥nicos y analizar√© algunos de los costos m√°s peque√±os.  Tenga en cuenta que esto no es una recomendaci√≥n para distorsionar el c√≥digo legible en algo que es dif√≠cil de mantener, en nombre de la microoptimizaci√≥n y el rendimiento.  Esto es solo el conocimiento que ayudar√° a diagnosticar los problemas que pueda encontrar, y un conjunto de herramientas para superar estos problemas.  Adem√°s, este art√≠culo se basa en la vista previa de .NET Framework versi√≥n 4.5, y probablemente los detalles de implementaci√≥n espec√≠ficos pueden cambiar en la versi√≥n final. </p><br><h4 id="poluchit-udobnuyu-model-myshleniya">  Consigue un modelo de pensamiento c√≥modo </h4><br><p>  Durante d√©cadas, los programadores han estado utilizando lenguajes de programaci√≥n de alto nivel C #, Visual Basic, F # y C ++ para desarrollar aplicaciones productivas.  Esta experiencia permiti√≥ a los programadores evaluar los costos de varias operaciones y obtener conocimiento sobre las mejores t√©cnicas de desarrollo.  Por ejemplo, en la mayor√≠a de los casos, invocar un m√©todo s√≠ncrono es relativamente econ√≥mico, especialmente si el compilador puede incrustar los contenidos del m√©todo invocado directamente en el punto de llamada.  Por lo tanto, los desarrolladores est√°n acostumbrados a dividir el c√≥digo en m√©todos peque√±os y f√°ciles de mantener, sin tener que preocuparse por las consecuencias negativas de aumentar el n√∫mero de llamadas.  El modelo de pensamiento de estos programadores est√° dise√±ado para manejar llamadas a m√©todos. </p><br><p>  Con la llegada de los m√©todos asincr√≥nicos, se requiere un nuevo modelo de pensamiento.  C # y Visual Basic con sus compiladores pueden crear la ilusi√≥n de que el m√©todo asincr√≥nico funciona como su contraparte s√≠ncrona, aunque todo est√° completamente mal por dentro.  El compilador genera una gran cantidad de c√≥digo para el programador, muy similar a la plantilla est√°ndar que los desarrolladores escribieron para admitir la asincron√≠a durante el tiempo en que era necesario hacerlo a mano.  Adem√°s, el c√≥digo que gener√≥ el compilador contiene llamadas a las funciones de la biblioteca de .NET Framework, lo que reduce a√∫n m√°s la cantidad de trabajo que un programador debe hacer.  Para tener el modelo correcto de pensamiento y usarlo para tomar decisiones informadas, es importante comprender qu√© genera el compilador para usted. </p><br><h4 id="bolshe-razmer-metodov-menshe-vyzovov">  M√°s m√©todos, menos llamadas. </h4><br><p>  Cuando se trabaja con c√≥digo s√≠ncrono, la ejecuci√≥n de m√©todos con contenido vac√≠o es pr√°cticamente in√∫til.  Para m√©todos asincr√≥nicos, este no es el caso.  Considere este m√©todo asincr√≥nico, que consiste en una instrucci√≥n (y que, debido a la falta de sentencias de espera, se ejecutar√° sincr√≥nicamente): </p><br><pre><code class="plaintext hljs">public static async Task SimpleBodyAsync() { Console.WriteLine("Hello, Async World!"); }</code> </pre> <br><p>  Un descompilador de lenguaje intermedio (IL) revelar√° los verdaderos contenidos de esta funci√≥n despu√©s de la compilaci√≥n, dando como resultado algo similar a la Figura 1. Lo que era una l√≠nea simple convertida en dos m√©todos, uno de los cuales pertenece a la clase auxiliar de la m√°quina de estados.  El primero es un m√©todo de c√≥digo auxiliar que tiene una firma similar a la escrita por el programador (este m√©todo tiene el mismo nombre, el mismo alcance, toma los mismos par√°metros y devuelve el mismo tipo), pero no contiene c√≥digo escrito por el programador.  Contiene solo una placa est√°ndar para la configuraci√≥n inicial.  El c√≥digo de configuraci√≥n inicial inicializa la m√°quina de estados necesaria para representar el m√©todo asincr√≥nico y lo inicia utilizando una llamada al m√©todo de utilidad MoveNext.  El tipo de objeto de la m√°quina de estado contiene una variable con el estado de ejecuci√≥n del m√©todo asincr√≥nico, lo que le permite guardarlo al cambiar entre puntos de espera asincr√≥nicos.  Tambi√©n contiene c√≥digo escrito por un programador, modificado para garantizar la transferencia de resultados de ejecuci√≥n y excepciones al objeto de tarea devuelto;  mantener la posici√≥n actual en el m√©todo para que la ejecuci√≥n pueda continuar desde esta posici√≥n despu√©s de reanudar, etc. </p><br><p>  <strong>Figura 1</strong> Plantilla de m√©todo asincr√≥nico </p><br><pre> <code class="plaintext hljs">[DebuggerStepThrough] public static Task SimpleBodyAsync() { &lt;SimpleBodyAsync&gt;d__0 d__ = new &lt;SimpleBodyAsync&gt;d__0(); d__.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); d__.MoveNext(); return d__.&lt;&gt;t__builder.Task; } [CompilerGenerated] [StructLayout(LayoutKind.Sequential)] private struct &lt;SimpleBodyAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public void MoveNext() { try { if (this.&lt;&gt;1__state == -1) return; Console.WriteLine("Hello, Async World!"); } catch (Exception e) { this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetException(e); return; } this.&lt;&gt;1__state = -1; this.&lt;&gt;t__builder.SetResult(); } ... }</code> </pre> <br><p>  Cuando se pregunte cu√°nto cuestan las llamadas a m√©todos asincr√≥nicos, recuerde este patr√≥n.  El bloque try / catch en el m√©todo MoveNext es necesario para evitar un posible intento de incrustar este m√©todo por parte del compilador, por lo que al menos obtenemos el costo de la llamada al m√©todo, mientras que al usar el m√©todo sincr√≥nico, lo m√°s probable es que esta llamada no lo haga (siempre que contenido minimalista).  Recibiremos varias llamadas a los procedimientos de Framework (por ejemplo, SetResult).  Adem√°s de varias operaciones de escritura en los campos del objeto m√°quina de estado.  Por supuesto, debemos comparar todos estos costos con los costos de Console.WriteLine, que probablemente prevalecer√°n (incluyen los costos de bloqueo, E / S, etc.) Preste atenci√≥n a las optimizaciones que el entorno hace por usted.  Por ejemplo, un objeto de una m√°quina de estados se implementa como una estructura (estructura).  Esta estructura se encuadrar√° en un mont√≥n administrado solo si el m√©todo necesita pausar la ejecuci√≥n, esperando que finalice la operaci√≥n, y esto nunca suceder√° en este m√©todo simple.  Por lo tanto, el patr√≥n de este m√©todo asincr√≥nico no requerir√° la asignaci√≥n de memoria del mont√≥n.  El compilador y el tiempo de ejecuci√≥n intentar√°n minimizar el n√∫mero de operaciones de asignaci√≥n de memoria. </p><br><h4 id="kogda-ne-nuzhno-ispolzovat-async">  Cu√°ndo no usar Async </h4><br><p>  .NET Framework intenta generar implementaciones eficientes para m√©todos asincr√≥nicos utilizando varios m√©todos de optimizaci√≥n.  Sin embargo, los desarrolladores, seg√∫n su experiencia, a menudo aplican sus m√©todos de optimizaci√≥n, que pueden ser riesgosos y poco pr√°cticos para la automatizaci√≥n por parte del compilador y el tiempo de ejecuci√≥n, ya que intentan utilizar enfoques universales.  Si no se olvida de esto, el rechazo del uso de m√©todos as√≠ncronos es beneficioso en varios casos espec√≠ficos, en particular, esto se aplica a los m√©todos en bibliotecas que se pueden usar con configuraciones m√°s finas.  Por lo general, esto sucede cuando se sabe con certeza que el m√©todo se puede ejecutar de forma sincr√≥nica, ya que los datos de los que depende ya est√°n listos. </p><br><p>  Al crear m√©todos asincr√≥nicos, los desarrolladores de .NET Framework dedicaron mucho tiempo a optimizar la cantidad de operaciones de administraci√≥n de memoria.  Esto es necesario porque la administraci√≥n de memoria incurre en el mayor costo en el desempe√±o de una infraestructura asincr√≥nica.  La operaci√≥n de asignaci√≥n de memoria para un objeto suele ser relativamente econ√≥mica.  Asignar memoria para objetos es similar a llenar el carrito con productos en el supermercado: no gasta nada cuando los coloca en el carrito.  El gasto ocurre cuando paga en la caja, saca su billetera y da dinero decente.  Y si la asignaci√≥n de memoria es f√°cil, la posterior recolecci√≥n de basura puede afectar gravemente el rendimiento de la aplicaci√≥n.  Cuando comienza la recolecci√≥n de basura, se realiza el escaneo y el marcado de los objetos que actualmente se encuentran en la memoria pero que no tienen enlaces.  Cuantos m√°s objetos se coloquen, m√°s tiempo llevar√° marcarlos.  Adem√°s, cuanto mayor sea el n√∫mero de objetos de gran tama√±o colocados, m√°s a menudo se requiere la recolecci√≥n de basura.  Este aspecto de trabajar con la memoria tiene un impacto global en el sistema: cuanto m√°s basura se produzca por m√©todos asincr√≥nicos, m√°s lenta ser√° la ejecuci√≥n de la aplicaci√≥n, incluso si las microprotestas no demuestran costos significativos. </p><br><p>  Para los m√©todos asincr√≥nicos que suspenden su ejecuci√≥n (esperando datos que a√∫n no est√°n listos), el entorno debe crear un objeto de tipo Tarea, que ser√° devuelto por el m√©todo, ya que este objeto sirve como referencia √∫nica para la llamada.  Sin embargo, a menudo se pueden hacer llamadas a m√©todos asincr√≥nicos sin suspensi√≥n.  Luego, el tiempo de ejecuci√≥n puede devolver del cach√© el objeto de tarea completado previamente, que se usa una y otra vez sin la necesidad de crear nuevos objetos de tarea.  Es cierto, esto solo se permite bajo ciertas condiciones, por ejemplo, cuando el m√©todo asincr√≥nico devuelve un objeto no universal (no gen√©rico) Tarea, Tarea, o cuando la Tarea universal se especifica mediante un tipo de referencia TResult, y el m√©todo devuelve un valor nulo.  Aunque la lista de estas condiciones se expande con el tiempo, a√∫n es mejor si sabe c√≥mo se implementa la operaci√≥n. <br></p><p>  Considere una implementaci√≥n de este tipo como MemoryStream.  MemoryStream se hereda de Stream y redefine los nuevos m√©todos implementados en .NET 4.5: ReadAsync, WriteAsync y FlushAsync, para proporcionar una optimizaci√≥n de c√≥digo espec√≠fica de la memoria.  Dado que la operaci√≥n de lectura se realiza desde un b√∫fer ubicado en la memoria, es decir, en realidad es una copia del √°rea de memoria, el mejor rendimiento ser√° si ReadAsync se ejecuta en modo s√≠ncrono.  Una implementaci√≥n de esto en un m√©todo asincr√≥nico podr√≠a verse as√≠: </p><br><pre> <code class="plaintext hljs">public override async Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { cancellationToken.ThrowIfCancellationRequested(); return this.Read(buffer, offset, count); }</code> </pre> <br><p>  Bastante simple  Y dado que Read es una llamada s√≠ncrona, y el m√©todo no tiene instrucciones de espera para controlar las expectativas, todas las llamadas a esta ReadAsync se ejecutar√°n de forma s√≠ncrona.  Ahora veamos un caso est√°ndar de uso de hilos, por ejemplo, una operaci√≥n de copia: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Tenga en cuenta que en el ejemplo de ReadAsync dado, la secuencia fuente siempre se llama con el mismo par√°metro de longitud de b√∫fer, lo que significa que es muy probable que el valor de retorno (el n√∫mero de bytes le√≠dos) tambi√©n se repita.  Excepto en algunas circunstancias raras, es poco probable que la implementaci√≥n de ReadAsync use el objeto Tarea en cach√© como valor de retorno, pero puede hacerlo. </p><br><p>  Considere otra opci√≥n de implementaci√≥n para este m√©todo, presentada en la Figura 2. Usando las ventajas de sus aspectos inherentes en escenarios est√°ndar para este m√©todo, podemos optimizar la implementaci√≥n al excluir las operaciones de asignaci√≥n de memoria, lo cual es poco probable que se espere del tiempo de ejecuci√≥n.  Podemos eliminar por completo la p√©rdida de memoria devolviendo el mismo objeto Task que se us√≥ en la llamada anterior ReadAsync si se ley√≥ la misma cantidad de bytes.  Y para una operaci√≥n de tan bajo nivel, que probablemente ser√° muy r√°pida y se llamar√° repetidamente, esta optimizaci√≥n tendr√° un efecto significativo, especialmente en el n√∫mero de recolecciones de basura. </p><br><p>  <strong>Figura 2</strong> Optimizaci√≥n de la creaci√≥n de tareas. </p><br><pre> <code class="plaintext hljs">private Task&lt;int&gt; m_lastTask; public override Task&lt;int&gt; ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken) { if (cancellationToken.IsCancellationRequested) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetCanceled(); return tcs.Task; } try { int numRead = this.Read(buffer, offset, count); return m_lastTask != null &amp;&amp; numRead == m_lastTask.Result ? m_lastTask : (m_lastTask = Task.FromResult(numRead)); } catch(Exception e) { var tcs = new TaskCompletionSource&lt;int&gt;(); tcs.SetException(e); return tcs.Task; } }</code> </pre> <br><p>  Se puede utilizar un m√©todo de optimizaci√≥n similar al eliminar la creaci√≥n innecesaria de objetos de Tarea si es necesario el almacenamiento en cach√©.  Considere un m√©todo dise√±ado para recuperar el contenido de una p√°gina web y almacenarlo en cach√© para referencia futura.  Como m√©todo asincr√≥nico, esto se puede escribir de la siguiente manera (usando la nueva biblioteca System.Net.Http.dll para .NET 4.5): </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,string&gt; s_urlToContents; public static async Task&lt;string&gt; GetContentsAsync(string url) { string contents; if (!s_urlToContents.TryGetValue(url, out contents)) { var response = await new HttpClient().GetAsync(url); contents = response.EnsureSuccessStatusCode().Content.ReadAsString(); s_urlToContents.TryAdd(url, contents); } return contents; }</code> </pre> <br><p>  Esta es una implementaci√≥n de la frente.  Y para las llamadas GetContentsAsync que no encuentran datos en la memoria cach√©, la sobrecarga de crear un nuevo objeto de Tarea puede descuidarse en comparaci√≥n con el costo de recibir datos a trav√©s de la red.  Sin embargo, en el caso de obtener datos de la memoria cach√©, estos costos se vuelven significativos si simplemente ajusta y proporciona los datos locales disponibles. <br></p><p>  Para eliminar estos costos (si es necesario para lograr un alto rendimiento), puede volver a escribir el m√©todo como se muestra en la Figura 3. Ahora tenemos dos m√©todos: un m√©todo p√∫blico s√≠ncrono y un m√©todo privado as√≠ncrono, al que delega el p√∫blico.  La colecci√≥n Diccionario ahora almacena en cach√© los objetos de Tarea creados, no sus contenidos, por lo que los intentos futuros de recuperar el contenido de una p√°gina que se obtuvo previamente con √©xito se pueden realizar simplemente accediendo a la colecci√≥n para devolver el objeto de Tarea existente.  En el interior, puede aprovechar el uso de los m√©todos ContinueWith del objeto Task, que nos permite guardar el objeto ejecutado en la colecci√≥n, en caso de que la carga de la p√°gina haya sido exitosa.  Por supuesto, este c√≥digo es m√°s complejo y requiere mucho desarrollo y soporte, como es habitual cuando se optimiza el rendimiento: no querr√° pasar tiempo escribi√©ndolo hasta que las pruebas de rendimiento muestren que estas complicaciones conducen a su mejora, lo cual es impresionante y obvio.  Qu√© mejoras depender√°n realmente del m√©todo de aplicaci√≥n.  Puede tomar un conjunto de pruebas que simule casos de uso comunes y evaluar los resultados para determinar si el juego vale la pena. </p><br><p>  <strong>Figura 3</strong> Tareas de almacenamiento en cach√© manual </p><br><pre> <code class="plaintext hljs">private static ConcurrentDictionary&lt;string,Task&lt;string&gt;&gt; s_urlToContents; public static Task&lt;string&gt; GetContentsAsync(string url) { Task&lt;string&gt; contents; if (!s_urlToContents.TryGetValue(url, out contents)) { contents = GetContentsInternalAsync(url); contents.ContinueWith(delegate { s_urlToContents.TryAdd(url, contents); }, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion | TaskContinuatOptions.ExecuteSynchronously, TaskScheduler.Default); } return contents; } private static async Task&lt;string&gt; GetContentsInternalAsync(string url) { var response = await new HttpClient().GetAsync(url); return response.EnsureSuccessStatusCode().Content.ReadAsString(); }</code> </pre> <br><p>  Otro m√©todo de optimizaci√≥n asociado con los objetos de la Tarea es determinar si se devuelve dicho objeto del m√©todo asincr√≥nico.  Tanto C # como Visual Basic admiten m√©todos asincr√≥nicos que devuelven un valor nulo (nulo), y no crean objetos de tarea en absoluto.  Los m√©todos asincr√≥nicos en las bibliotecas siempre deben devolver Tarea y Tarea, ya que al dise√±ar una biblioteca no se puede saber que no se usar√°n esperando su finalizaci√≥n.  Sin embargo, al desarrollar aplicaciones, los m√©todos que devuelven vac√≠o pueden encontrar su lugar.  La raz√≥n principal de la existencia de tales m√©todos es proporcionar entornos existentes controlados por eventos, como ASP.NET y Windows Presentation Foundation (WPF).  Utilizando async y wait, estos m√©todos facilitan la implementaci√≥n de controladores de botones, eventos de carga de p√°gina, etc.  Si tiene la intenci√≥n de utilizar el m√©todo asincr√≥nico con void, tenga cuidado al manejar las excepciones: las excepciones aparecer√°n en cualquier SynchronizationContext que estaba activo en el momento en que se llam√≥ al m√©todo. <br></p><h4 id="ne-zabyvayte-o-kontekste">  No olvides el contexto </h4><br><p>  Hay muchos contextos diferentes en .NET Framework: LogicalCallContext, SynchronizationContext, HostExecutionContext, SecurityContext, ExecutionContext y otros (su cantidad gigantesca puede sugerir que los creadores del Framework estaban econ√≥micamente motivados para crear nuevos contextos, pero estoy seguro de que esto no es as√≠).  Algunos de estos contextos afectan fuertemente los m√©todos asincr√≥nicos, no solo en t√©rminos de funcionalidad, sino tambi√©n en rendimiento. </p><br><p>  <strong>SynchronizationContext</strong> SynchronizationContext juega un papel importante para los m√©todos asincr√≥nicos.  Un "contexto de sincronizaci√≥n" es solo una abstracci√≥n para garantizar que se invoque una invocaci√≥n de delegado con los detalles de una biblioteca o entorno en particular.  Por ejemplo, WPF tiene un DispatcherSynchronizationContext para representar una secuencia de interfaz de usuario (UI) para Dispatcher: enviar un delegado a este contexto de sincronizaci√≥n hace que este delegado se ponga en cola para su ejecuci√≥n por el Dispatcher en su secuencia.  ASP.NET proporciona un AspNetSynchronizationContext que se utiliza para garantizar que las operaciones asincr√≥nicas involucradas en el procesamiento de una solicitud ASP.NET tengan garantizada su ejecuci√≥n secuencial y est√©n vinculadas al estado HttpContext correcto.  Bueno, etc.  En general, hay alrededor de 10 especializaciones del SynchronizationContext en .NET Framework, algunas abiertas, otras internas. </p><br><p>  Al esperar Tareas u objetos de otros tipos para los cuales .NET Framework puede implementar esto, los objetos que los esperan (por ejemplo, TaskAwaiter) capturan el SynchronizationContext actual en el momento en que comienza la espera (espera).  Al finalizar la espera, si se captur√≥ el SynchronizationContext, la continuaci√≥n del m√©todo asincr√≥nico se env√≠a a este contexto de sincronizaci√≥n.  Debido a esto, los programadores que escriben m√©todos asincr√≥nicos que se invocan desde el flujo de la interfaz de usuario no necesitan reunir manualmente las llamadas al flujo de la interfaz de usuario para actualizar los controles de la interfaz de usuario: el Framework realiza este c√°lculo de referencias autom√°ticamente. </p><br><p>  Desafortunadamente, esta clasificaci√≥n tiene un precio.  Para los desarrolladores de aplicaciones que usan wait para implementar su flujo de control, la clasificaci√≥n autom√°tica es la soluci√≥n correcta.  Las bibliotecas a menudo tienen una historia completamente diferente.  Para los desarrolladores de aplicaciones, este c√°lculo de referencias es principalmente necesario para que el c√≥digo controle el contexto en el que se ejecuta, por ejemplo, para acceder a los controles de la interfaz de usuario o para acceder al HttpContext correspondiente a la solicitud ASP.NET requerida.  Sin embargo, generalmente no se requiere que las bibliotecas satisfagan tal requisito.  Como resultado, el c√°lculo autom√°tico a menudo conlleva costos adicionales completamente innecesarios.  Echemos otro vistazo al c√≥digo que copia datos de una secuencia a otra: </p><br><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead); }</code> </pre> <br><p>  Si se llama a esta copia desde la secuencia de IU, cada operaci√≥n de lectura y escritura forzar√° la ejecuci√≥n para volver a la secuencia de IU.  En el caso de un megabyte de datos en la fuente y las secuencias que leen y escriben de forma as√≠ncrona (es decir, la mayor√≠a de sus implementaciones), esto significa unos 500 conmutadores de la secuencia de fondo a la secuencia de la interfaz de usuario.  Para manejar este comportamiento en la tarea y los tipos de tarea, se crea el m√©todo ConfigureAwait.  Este m√©todo acepta el par√°metro continueOnCapturedContext de un tipo booleano que controla el c√°lculo de referencias.  Si es verdadero (el valor predeterminado), esperar autom√°ticamente devuelve el control al SynchronizationContext capturado.  Si se utiliza falso, se ignorar√° el contexto de sincronizaci√≥n y el entorno continuar√° ejecutando la operaci√≥n asincr√≥nica en el subproceso donde se interrumpi√≥.  La implementaci√≥n de esta l√≥gica dar√° una versi√≥n m√°s eficiente del c√≥digo de copia entre hilos: <br></p><pre> <code class="plaintext hljs">byte [] buffer = new byte[0x1000]; int numRead; while((numRead = await source.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) &gt; 0) { await source.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); }</code> </pre> <br><p>  Para los desarrolladores de bibliotecas, tal aceleraci√≥n en s√≠ misma es suficiente para pensar siempre en usar ConfigureAwait, con la excepci√≥n de las raras condiciones en las que la biblioteca conoce lo suficiente sobre el tiempo de ejecuci√≥n y tendr√° que ejecutar el m√©todo con acceso al contexto correcto. </p><br><p>  Adem√°s del rendimiento, hay otra raz√≥n por la que necesita usar ConfigureAwait al desarrollar bibliotecas.  Imagine que el m√©todo CopyStreamToStreamAsync implementado con la versi√≥n del c√≥digo sin ConfigureAwait se llama desde la secuencia de IU en WPF, por ejemplo, as√≠: </p><br><pre> <code class="plaintext hljs">private void button1_Click(object sender, EventArgs args) { Stream src = ‚Ä¶, dst = ‚Ä¶; Task t = CopyStreamToStreamAsync(src, dst); t.Wait(); // deadlock! }</code> </pre> <br><p>  En este caso, el programador tuvo que escribir button1_Click como un m√©todo asincr√≥nico en el que se espera que el operador de espera ejecute la Tarea, y no use el m√©todo de espera sincr√≥nico de este objeto.  El m√©todo Wait debe usarse en muchos otros casos, pero casi siempre ser√° un error usarlo para esperar en una secuencia de IU, como se muestra aqu√≠.  El m√©todo de espera no volver√° hasta que se complete la tarea.  En el caso de CopyStreamToStreamAsync, su secuencia asincr√≥nica intenta devolver la ejecuci√≥n con el env√≠o de datos al SynchronizationContext capturado, y no puede completarse hasta que se completen dichas transferencias (porque son necesarias para continuar su operaci√≥n).  Pero estos despachos, a su vez, no se pueden ejecutar, porque la llamada de espera bloquea el subproceso de la interfaz de usuario que debe manejarlos.  Esta es una dependencia c√≠clica que conduce a un punto muerto.  Si CopyStreamToStreamAsync se implementa con ConfigureAwait (falso), no habr√° dependencia ni bloqueo. </p><br><p>  <strong>ExecutionContext</strong> ExecutionContext es una parte importante de .NET Framework, pero a√∫n as√≠ la mayor√≠a de los programadores desconocen su existencia. ExecutionContext ‚Äì  ,        SecurityContext  LogicalCallContext,   ,         .  ,    ThreadPool.QueueUserWorkItem, Task.Run, Delegate.BeginInvoke, Stream.BeginRead, WebClient.DownloadStringAsync      Framework,    ExecutionContext   ExecutionContext.Run ( ). ,  ,  ThreadPool.QueueUserWorkItem,  Windows  (identity),           WaitCallback.   ,   Task.Run    LogicalCallContext,         LogicalCallContext    Action. ExecutionContext     . </p><br><p>  Framework    ,          ExecutionContext,     ,      .     Windows      LogicalCallContext     .     (WindowsIdentity.Impersonate  CallContext.LogicalSetData)               . </p><br><h4 id="osvobodites-ot-sborki-musora">     </h4><br><p>        .    C#  Visual Basic     ,        .          await.  ,      ,    -   .   C#  Visual Basic  (¬´¬ª)      ,     await  (boxed)  ,     . </p><br><p>                  .   ,     . ,       ,     ,     . </p><br><p>       C#  Visual Basic      ,      . ,     </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dto = DateTimeOffset.Now; var dt = dto.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>    dto      await,     .    ,  , -    dto: </p><br><p> <strong>Figure 4</strong>    </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Sequential), CompilerGenerated] private struct &lt;FooAsync&gt;d__0 : &lt;&gt;t__IStateMachine { private int &lt;&gt;1__state; public AsyncTaskMethodBuilder &lt;&gt;t__builder; public Action &lt;&gt;t__MoveNextDelegate; public DateTimeOffset &lt;dto&gt;5__1; public DateTime &lt;dt&gt;5__2; private object &lt;&gt;t__stack; private object &lt;&gt;t__awaiter; public void MoveNext(); [DebuggerHidden] public void &lt;&gt;t__SetMoveNextDelegate(Action param0); }</code> </pre> <br><p>         ,     .   ,     ,  , ,        .       ,        : </p><br><pre> <code class="plaintext hljs">public static async Task FooAsync() { var dt = DateTimeOffset.Now.DateTime; await Task.Yield(); Console.WriteLine(dt); }</code> </pre> <br><p>  ,   .NET (GC)    ,  ,      ,  :      0,  ,    ,     (.NET GC    0, 1  2).      ,    GC        .     ,  ,   ,    ,     ,     ,   .     0,   ,    ,   .   ,     ,         ,    . </p><br><p>                (        ,       ).    JIT   ,        ,               ,        ,      .          ,    ,        .   ,      ,  ,     ,     .   ,          ,     .  ,  C#  Visual Basic        ,       ,     . </p><br><h4 id="izbegayte-slozhnosti">   </h4><br><p>  C#  Visual Basic  ,       awaits:  .   await      ,     Task  ,       ,  . ,   ,      : <br></p><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return Sum(await a, await b, await c); } private static int Sum(int a, int b, int c) { return a + b + c; }</code> </pre> <br><p>  C#     ‚Äúawait b‚Äù    Sum.      await,       Sum,  -       async ,   ¬´¬ª     await.    ,       await       .   ,  ,       CLR,    ,      ,       .         ,                 &lt;&gt;t__stack.         ,   ,   Tuple&lt;int, int&gt;             &lt;&gt;__stack.  ,     ,    ,          . ,    SumAsync : </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int ra = await a; int rb = await b; int rc = await c; return Sum(ra, rb, rc); }</code> </pre> <br><p>            ,   ra, rb  rc,    .  ,    :                   .          ,           ,        ,    .  ,           ,    ,       ,          . </p><br><p> ,        ,        .      Sum   ,    await   ,       .     ,    await   ,  .      await  ,      Task.WhenAll: </p><br><pre> <code class="plaintext hljs">public static async Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { int [] results = await Task.WhenAll(a, b, c); return Sum(results[0], results[1], results[2]); }</code> </pre> <br><p>  Task.WhenAll  Task&lt;TResult[]&gt;,    ,       ,     ,       .           .     ,         WhenAll,    Task  Task.        ,          ,    ,   ,   ,    WhenAll ,    .         WhenAll,     , ,   params,       .    ,  ,         .   Figure 5 <br></p><p> <strong>Figure 5</strong>     </p><br><pre> <code class="plaintext hljs">public static Task&lt;int&gt; SumAsync(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { return (a.Status == TaskStatus.RanToCompletion &amp;&amp; b.Status == TaskStatus.RanToCompletion &amp;&amp; c.Status == TaskStatus.RanToCompletion) ? Task.FromResult(Sum(a.Result, b.Result, c.Result)) : SumAsyncInternal(a, b, c); } private static async Task&lt;int&gt; SumAsyncInternal(Task&lt;int&gt; a, Task&lt;int&gt; b, Task&lt;int&gt; c) { await Task.WhenAll((Task)a, b, c).ConfigureAwait(false); return Sum(a.Result, b.Result, c.Result); }</code> </pre> <br><h4 id="asinhronnost-i-proizvoditelnost">    </h4><br><p>      ,           .  ,         .            ,            . ,      ,     :      ,      ,      /          ,       .     .NET Framework              ,       .   ,       .NET Framework,     .  ,  ,       Framework,   ,     ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458332/">https://habr.com/ru/post/458332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458316/index.html">Yandex Retro Games Battle 2019 - desarrollo de juegos para ZX Spectrum</a></li>
<li><a href="../458324/index.html">Todo lo que necesitas para comenzar con Vue.js</a></li>
<li><a href="../458326/index.html">Yandex abre conjuntos de datos de Toloka para investigadores</a></li>
<li><a href="../458328/index.html">C√≥mo duplicar objetivos de Yandex.Metrica en Google Analytics</a></li>
<li><a href="../458330/index.html">No hay l√≠mite para la perfecci√≥n: c√≥mo las interfaces neuronales ayudan a la humanidad</a></li>
<li><a href="../458334/index.html">Replicaci√≥n continua de PostgreSQL antiguo a nuevo con Slony</a></li>
<li><a href="../458336/index.html">El ciclo completo de desarrollo de productos de TI utilizando el ejemplo del proyecto: roles de equipo, tareas del cliente, etapas</a></li>
<li><a href="../458338/index.html">Gerente de Seguridad de Aplicaciones. Desarrollador o seguridad?</a></li>
<li><a href="../458342/index.html">Texturizado, o lo que necesitas saber para convertirte en un Artista de Surface. Parte 1. Pixel</a></li>
<li><a href="../458344/index.html">Uso de mensajer√≠a asincr√≥nica para mejorar la disponibilidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>