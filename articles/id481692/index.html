<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚≠êÔ∏è ü¶ñ üßöüèø Menggunakan Pelacakan Prosesor Intel untuk Melacak Kode Mode Manajemen Sistem üê≥ ü¶ã üëãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini dikhususkan untuk menguji kemungkinan penggunaan teknologi Intel Processor Trace (Intel PT) untuk merekam jejak dalam mode System Manageme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan Pelacakan Prosesor Intel untuk Melacak Kode Mode Manajemen Sistem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/481692/"><p><img src="https://habrastorage.org/webt/ek/w6/yn/ekw6ynxfsk4gnib6pbdy0glmkxy.png"></p><br><p>  Artikel ini dikhususkan untuk menguji kemungkinan penggunaan teknologi Intel Processor Trace (Intel PT) untuk merekam jejak dalam mode System Management Mode (SMM).  Pekerjaan ini dilakukan sebagai bagian dari Summer Of Hack 2019. Diposting oleh <a href="https://twitter.com/sysenter_eip">@sysenter_eip</a> . </p><br><p>  Sebagian besar alat yang digunakan ditulis oleh orang lain (khususnya <a href="https://twitter.com/d_olex">@d_olex</a> , <a href="https://twitter.com/aionescu">@aionescu</a> ).  Hasilnya hanyalah kombinasi alat yang tersedia untuk mendapatkan jalur eksekusi kode dalam mode SMM untuk <strong>satu</strong> motherboard <strong>tertentu</strong> .  Namun, materi mungkin menarik bagi mereka yang ingin mengulang ini untuk platform mereka atau hanya tertarik pada pekerjaan SMM. </p><a name="habracut"></a><br><h2 id="system-management-mode">  Mode manajemen sistem </h2><br><p> SMM adalah mode khusus dan istimewa dari prosesor arsitektur x86, yang tersedia saat sistem operasi berjalan, tetapi sama sekali tidak terlihat olehnya.  Ini dirancang untuk interaksi tingkat rendah dengan perangkat keras, manajemen daya, emulasi warisan perangkat, transisi ke mode tidur (S3), akses ke TPM dan banyak lagi.  Ini berfungsi sepenuhnya terisolasi dari OS.  Selama durasi eksekusi SMM, OS berhenti sepenuhnya.  Kode program yang berjalan dalam mode ini disimpan dalam memori SPI-Flash pada motherboard dan merupakan bagian dari firmware UEFI BIOS. </p><br><p>  Beralih ke mode SMM dilakukan menggunakan interupsi SMI khusus (System Management Interrupt).  Salah satu opsi untuk interupsi ini tersedia untuk digunakan dalam deringan nol (mis., Dari kernel OS) - Level Aplikasi SMI Interrupt (Software SMI).  Selanjutnya kami akan fokus pada gangguan ini. </p><br><p>  Karena keistimewaannya yang tinggi, SMM menjadi minat khusus untuk penelitian keamanan.  Kompromi SMM mengarah pada pelanggaran serius terhadap integritas dan kerahasiaan seluruh sistem, dan dalam kebanyakan kasus memungkinkan Anda untuk menyuntikkan kode berbahaya yang tidak dapat dihapus dan tidak dapat dideteksi oleh sistem operasi ke dalam firmware UEFI BIOS. </p><br><h2 id="intel-processor-trace">  Intel Processor Trace </h2><br><p>  Salah satu perangkap dari proses debugging untuk berbagai aplikasi yang sangat dimuat adalah biaya overhead - biaya alat debugging.  Mereka dapat dikurangi dengan solusi yang mendukung perangkat keras. </p><br><p>  Prosesor generasi kelima dari Intel (Broadwell) telah menghadirkan teknologi dengan dunia seperti Intel Processor Trace.  Bagaimana ini bermanfaat?  Intel PT memungkinkan Anda untuk mendapatkan alur eksekusi penuh (Aliran Kontrol) aplikasi debugged dengan overhead yang minimal (&lt;5%).  Pada saat yang sama, ini mendukung multithreading dan dapat membantu memperbaiki kesalahan seperti "kondisi balapan" karena stempel waktu saat merekam jejak aplikasi.  Tidak diragukan lagi, teknologi Intel PT menawarkan peluang besar untuk menulis alat pencarian kerentanan dalam aplikasi. </p><br><p>  Saat ini, teknologi ini digunakan dalam berbagai alat untuk melacak, debugging, dan mengevaluasi cakupan kode - baik dalam aplikasi tingkat pengguna dan kernel.  Contoh alat dapat ditemukan di situs web <a href="https://software.intel.com/en-us/node/721535">Intel</a> .  Opsi fuzzer AFL yang memanfaatkan Intel PT tersedia di repositori <a href="https://github.com/hunter-ht-2018/ptfuzzer">PTfuzzer</a> .  Dari proyek-proyek terbaru, perhatikan <a href="https://github.com/ohjeongwook/iptanalyzer">iptanalyzer</a> . </p><br><p>  Namun, kami belum melihat adanya kerja pada penggunaan Intel PT dalam mode SMM.  Karena tidak ada yang mencegah kami menggunakan Intel PT dalam konteks ini, kami memutuskan untuk mencari tahu apakah mungkin untuk melacak kode Mode Manajemen Sistem dengannya. </p><br><h2 id="podgotovka-k-rabote">  Persiapan untuk bekerja </h2><br><p>  Ini mengikuti dari <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.html">Manual Pengembang Intel</a> bahwa tidak mungkin untuk mengaktifkan pelacakan PT Intel di SMM dari luar menggunakan cara biasa.  Jika aktif pada saat SMI dipicu, prosesor akan menonaktifkannya sebelum mentransfer kontrol ke titik masuk pengendali SMI.  Satu-satunya metode aktivasi adalah inklusi sukarela handler SMI oleh kode itu sendiri. </p><br><p>  Bahkan jika prosesor pada awalnya tidak memberikan kesempatan seperti itu, kami dapat mencegatnya dan mengaktifkan Intel PT secara manual.  Namun, Anda perlu menentukan bahwa sistem siap merekam jejak (alamat buffer output diatur), dan juga mematikan pelacakan di akhir eksekusi prosesor (eksekusi instruksi RSM).  Jika tidak, prosesor akan mematikan seluruh sistem. </p><br><p>  Pertama-tama, Anda perlu mengakses SMRAM (area RAM tempat kode dijalankan dalam mode SMM).  Karena wilayah RAM ini dilindungi, kami tidak dapat mengaksesnya dari sistem operasi (bahkan ini tidak dapat dilakukan dengan DMA).  Ada beberapa skenario: </p><br><ol><li>  mengeksploitasi kelemahan yang diketahui dalam SMM dan dapatkan primitif R / W darinya.  Ini bisa berupa kesalahan perangkat lunak (kerentanan pada prosesor SMI itu sendiri; sebagai aturan, di SMM ada cukup kode yang ditambahkan oleh OEM, sehingga kerentanan tidak jarang terjadi), serta konfigurasi platform yang rentan (membuka / memindahkan SMRAM); </li><li>  untuk menambal gambar UEFI sedemikian rupa sehingga kami memiliki antarmuka untuk membaca dan menulis ke alamat sewenang-wenang - pintu belakang.  Untuk menerapkan opsi ini, Anda perlu menemukan motherboard yang Intel Boot Guard dinonaktifkan atau ada kerentanan yang dapat menghindarinya. </li></ol><br><h2 id="vnedrenie-svoego-koda-v-proshivku">  Sematkan kode Anda di firmware </h2><br><p>  Terlepas dari kenyataan bahwa kerentanan SMM dalam kode berbagai produsen ditemukan dari <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">waktu</a> ke <a href="https://embedi.org/blog/uefi-bios-holes-so-much-magic-dont-come-inside/">waktu</a> , akan lebih baik jika kita tidak bergantung pada mereka.  Lebih menarik bagi kami untuk melacak kode pada firmware baru dan, karenanya, mencoba menemukan kerentanan di dalamnya.  Kami sudah memiliki motherboard GIGABYTE GA-Q270M-D3H dengan Intel Boot Guard dinonaktifkan, jadi yang harus kami lakukan adalah menambahkan pintu belakang ke SMM. </p><br><p><img src="https://habrastorage.org/webt/cj/gs/ub/cjgsubzj6xwovbitbn7dob_tsz4.jpeg"><br>  Gambar 1. Test bench </p><br><p>  Sudah ada <a href="https://github.com/Cr4sh/SmmBackdoor">kerangka kerja untuk "menginfeksi" SMM dan bekerja dengan backdoor</a> .  Ini terdiri dari tiga komponen: driver UEFI di C, "infector", dan skrip klien dengan Python.  Untuk operasinya, Anda perlu mengekstrak driver DXE sembarang (Anda dapat melakukan ini menggunakan <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> ) dan memprosesnya dengan infector.  Modul asli diganti dengan "ditingkatkan", dan firmware diunggah ke memori SPI (untuk kenyamanan menginstal flash drive SPI dihapus dari papan). </p><br><p><img src="https://habrastorage.org/webt/bv/2a/ih/bv2aihyunbskeqjvp6ppqvqhzmi.jpeg"><br>  Gambar 2. Chip memori SPI-Flash </p><br><p>  Sistem dimulai dengan sukses, dan sekarang kami memiliki akses penuh ke SMRAM dari Python (contoh penggunaan disediakan dengan backdoor).  Karena skrip klien untuk pintu belakang didasarkan pada <a href="https://github.com/chipsec/chipsec">CHIPSEC</a> , Anda perlu memberinya akses ke mode kernel (kami menggunakan driver RWEverything; akan lebih mudah bagi seseorang untuk menggunakan driver CHIPSEC mereka sendiri dengan verifikasi tanda tangan dimatikan dalam sistem). </p><br><p>  Anda dapat memeriksa pintu belakang dengan meminta dump SMRAM. </p><br><p><code>$ python SmmBackdoor.py -d</code> </p> <br><p>  Setelah menjalankan perintah ini, file SMRAM_dump_cb000000_cb7fffff.bin akan dibuat berisi keadaan SMRAM saat ini.  Nilai cb000000 dan cb7fffff, masing-masing, adalah alamat fisik awal dan akhir SMRAM. </p><br><h2 id="rabota-s-dampom-smram">  Bekerja dengan dump SMRAM </h2><br><p>  Dump SMRAM dapat dimuat ke disassembler atau diteruskan untuk dianalisis ke skrip <a href="https://github.com/Cr4sh/smram_parse">smram_parse.py</a> , yang akan mengekstrak banyak informasi berguna bagi kami.  Yang paling penting bagi kami adalah alamat titik masuk SMI.  Ini adalah alamat fungsi yang kontrolnya akan ditransfer ketika SMI dipicu.  Setiap CPU memiliki titik masuknya sendiri. </p><br><p><img src="https://habrastorage.org/webt/8a/20/jq/8a20jq29bgn7rhqeim16vqhfxam.png"><br>  Gambar 3. Output skrip smram_parse </p><br><p>  Mari kita lihat kodenya.  Sejak SMM memulai eksekusi dalam Mode Real 16-bit (4 GB RAM pertama tercermin dalam ruang virtual), hal pertama yang dilakukan kode adalah beralih ke mode 64-bit.  Pada saat yang sama, seluruh SMRAM tersedia dengan hak tulis dan eksekusi, karena hanya satu segmen yang dibuat (apakah ada vendor yang melakukannya secara berbeda?). </p><br><p>  Kami tidak ingin menulis kode 16-bit atau menyiapkan segala yang diperlukan untuk beralih ke mode 64-bit sendiri, jadi kami akan menempatkan interceptor kami tepat sebelum memanggil fungsi manajer SMI (fungsi ini menentukan modul SMM mana yang harus ditransfer oleh eksekusi tergantung pada layanan apa yang dipanggil atau peristiwa apa yang terjadi). </p><br><p><img src="https://habrastorage.org/webt/_u/b0/4k/_ub04kwpncdmptrknltqyl0i3jg.png"><br>  Gambar 4. Penempatan untuk pengait </p><br><p>  Cara termudah untuk mengambil kendali adalah mengganti alamat pengirim dengan alamat kami.  Semua titik masuk memiliki kode yang sama, sehingga tambalan perlu diulang untuk masing-masing. </p><br><p>  <strong>Catatan:</strong> Mengenai lokasi kode interseptor.  Karena struktur SMRAM tidak sepenuhnya diketahui oleh kami, kami memilih sepotong memori nol acak di dekat salah satu titik masuk, tempat kami meletakkan kode interseptor.  Opsi terbaik adalah menambahkan modul SMM Anda ke firmware, yang UEFI akan tempatkan secara hukum di SMRAM, agar tidak khawatir bahwa sesuatu yang penting akan ditimpa dengan kode kami. </p><br><h2 id="realizaciya-perehvatchika-dispetchera-smi">  Menerapkan Interceptor Manajer SMI </h2><br><p>  Mari kita tentukan apa yang akan kita lakukan di dalam pencegat kita.  Pertama kita perlu menentukan apakah Intel PT dihidupkan sebelum pindah ke SMM.  Diketahui dari dokumentasi Intel bahwa setiap prosesor memiliki basis SMBASE sendiri (MSR 0x9E) dan ruangnya sendiri untuk menyimpan status prosesor (area SMM Save State) pada saat transisi ke SMM. </p><br><p><img src="https://habrastorage.org/webt/bz/ti/i2/bztii2soe7myxor_zprtytfr09q.png"><br>  Gambar 5. Tata letak SMBASE </p><br><h3 id="opredelyaem-sostoyanie-intel-pt">  Kami menentukan status Intel PT </h3><br><p>  Dalam SMM Save State, nilai register MSR IA32_RTIT_CTL, yang bertanggung jawab untuk mengelola pelacakan PT Intel, harus disimpan.  Sayangnya, Intel Manual tidak menunjukkan di mana prosesor menyimpan status IA32_RTIT_CTL.TraceEn pada saat transisi ke SMM (apakah pelacakan diaktifkan, nol bit).  Namun, kami dapat menentukan sendiri dengan membuang SMM Simpan Status dua kali: dengan dan tanpa pelacakan diaktifkan. </p><br><p>  Kami menggunakan alat <a href="https://ionescu007.github.io/winipt/">WinIPT</a> untuk mengaktifkan pelacakan pada proses interpreter Python (pid <strong>1337</strong> ), mengalokasikan 2 ^ <strong>12</strong> (4096) byte ke buffer jejak, dan kemudian menjalankan skrip SmmBackdoor.py di dalam interpreter (argumen <strong>0</strong> adalah bendera, bagi kami mereka tidak penting, karena di SMM Anda masih harus memaksakan pengaturan jejak Anda). </p><br><p> <code>$ ipttool.exe --start 1337 12 0</code> </p> <br><p>  Dengan membandingkan snapshot SMRAM, kami menentukan lokasi register IA32_RTIT_CTL dalam struktur SMM Save State.  Ini disimpan di offset SMBASE + 0xFE3C.  Keadaan bit IA32_RTIT_CTL.TraceEn adalah syarat utama untuk aktivasi ulang Intel PT di dalam SMM.  Bidang pada offset ini ditandai sebagai Dicadangkan dalam Manual Pengembang Intel. </p><br><p><img src="https://habrastorage.org/webt/tf/uy/hx/tfuyhxbfmhemoyy8gh003uo37s8.png"><br>  Gambar 6. Menandai bahwa bidang disediakan </p><br><h3 id="pishem-shellcode">  Menulis shellcode </h3><br><p>  Kami tidak ingin mengonfigurasi Intel PT di dalam SMM sendiri, karena ini akan menyulitkan shellcode kami (misalnya, berada di SMM, akan sulit untuk mengalokasikan sejumlah besar RAM sehingga tidak digunakan oleh sistem operasi itu sendiri).  Oleh karena itu, kami memutuskan untuk menggunakan pelacak yang sudah dikonfigurasi dan cukup "lewati" di dalam SMM, terutama karena sudah memiliki fungsi menyimpan jejak ke file. </p><br><p>  Karena kami menggunakan WinIPT untuk tujuan ini, yang pada saat itu tidak mendukung pelacakan kode kernel (CPL == 0), jelas bahwa bahkan ketika penelusuran disertakan dalam SMM, tidak ada yang akan muncul di log, karena kode SMM dieksekusi di CPL = 0 .  Kita perlu memodifikasi beberapa filter agar pelacak dapat bekerja sepanjang waktu yang dihabiskan di SMM.  Kami mencantumkan semua yang perlu diperiksa dan diinstal: </p><br><ol><li>  Pelacakan dengan CPL = 0 harus diaktifkan. </li><li>  Pelacakan untuk CPL&gt; 0 harus diaktifkan (opsional). </li><li>  Rentang IP yang valid untuk acara perekaman harus dinonaktifkan. </li><li>  IA32_RTIT_STATUS.PacketByteCnt harus diatur ulang. </li><li>  Pemfilteran CR3 harus dinonaktifkan. </li></ol><br><p>  Beberapa kata harus dikatakan tentang PacketByteCnt.  Penghitung ini menentukan pada titik apa Anda perlu memasukkan paket sinkronisasi (urutan beberapa perintah PSB) ke dalam penelusuran.  Kita perlu mengatur ulang penghitung ini, jika tidak, selama pemrosesan jejak, saat memasuki SMM akan terlewatkan, dan jejak akan mulai dari tempat acak ketika PSB dihasilkan secara alami. </p><br><p>  Di bawah ini adalah shellcode yang kami gunakan: </p><br><pre> <code class="plaintext hljs"> sub rsp, 0x18 ; this will align stack at 16 byte boundary (in case SMM ; code uses align dependent instructions) mov qword ptr ss:[rsp+0x10], rcx ; need to save rcx for SMI_Dispatcher mov ecx, 0x9E ; MSR_IA32_SMBASE rdmsr test byte ptr ds:[rax+0xFE3C], 0x1 ; Save State area contains saved ; IA32_RTIT_CTL.TraceEn je short @NoTrace call @Trace_Enable mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall ; (first argument in rcx) mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax call @Trace_Disable add rsp, 0x18 ret @NoTrace: mov rcx, qword ptr ss:[rsp+0x10] ; SMI_Dispatcher is __fastcall mov eax, 0xCB7DDAA4 ; original SMI_Dispatcher !!!!!!!!!!!!!!!!!!!!! call rax add rsp, 0x18 ret @Trace_Disable: mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov rax, qword ptr ss:[rsp+0x10] ; restore IA32_RTIT_STATUS wrmsr mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov rax, qword ptr ss:[rsp+0x8] ; restore IA32_RTIT_CTL wrmsr ret @Trace_Enable: mov ecx, 0x571 ; IA32_RTIT_STATUS rdmsr mov qword ptr ss:[rsp+0x8], rax ; save IA32_RTIT_STATUS and edx, 0xFFFF0000 ; IA32_RTIT_STATUS.PacketByteCnt = 0 wrmsr mov ecx, 0x570 ; IA32_RTIT_CTL rdmsr mov qword ptr ss:[rsp+0x10], rax ; save IA32_RTIT_CTL and eax, 0xFFFFFFBF ; IA32_RTIT_CTL.CR3Filter = 0 or eax, 0x5 ; IA32_RTIT_CTL.OS = 1; IA32_RTIT_CTL.User = 1; and edx, 0xFFFF0000 ; IA32_RTIT_CTL.ADDRx_CFG = 0 wrmsr ret</code> </pre> <br><p>  Kode ini harus ditempatkan di SMRAM, dan transisi ke manajer SMI harus ditambal untuk menuju ke kode kami.  Semua ini dilakukan dengan menggunakan SmmBackdoor. </p><br><h2 id="rabota-s-trassoy">  Bekerja dengan trek </h2><br><p>  Pencegat manajer SMI memungkinkan kami untuk menulis jejak kode pertama dari SMM.  Perintah berikut dapat meminta <strong>WinIPT</strong> untuk menyimpan <strong>jejak</strong> ke file: </p><br><p> <code>$ ipttool.exe --trace 1337 trace_file_name</code> </p> <br><p>  Menonaktifkan pelacakan pada suatu proses: </p><br><p> <code>$ ipttool.exe --stop 1337</code> </p> <br><p>  Anda dapat mencoba membongkar <strong>jejak</strong> menggunakan utilitas <a href="https://github.com/intel/libipt">dumppt</a> dari <a href="https://github.com/intel/libipt">libipt</a> . </p><br><p> <code>$ ptdump.exe --no-pad ./examples/trace_smm_handler_33 &gt; ./examples/trace_smm_handler_33_pt_dump.txt</code> </p> <br><p>  Contoh Keluaran: </p><br><p><img src="https://habrastorage.org/webt/rr/iq/0e/rriq0ex1jsozdb6yuvicvg0i_ao.png"><br>  Gambar 7. Jalur instruksi SMM pertama </p><br><p>  Kita dapat melihat beberapa alamat, namun sangat sulit untuk menggunakan informasi ini, karena sangat rendah. </p><br><p>  Untuk mendapatkan tampilan yang lebih mudah dibaca, ada utilitas <strong>ptxed</strong> (dari libipt) yang mengubah jejak menjadi log instruksi assembler yang dieksekusi.  Tentu saja, kita harus menyediakan utilitas dengan dump memori SMRAM, karena log IPT tidak mengandung informasi tentang nilai-nilai sel memori atau instruksi apa yang dijalankan;  itu hanya berisi informasi tentang perubahan apa yang terjadi dalam aliran kontrol. </p><br><p> <code>$ ptxed.exe --pt tracesmm_12 --raw SMRAM_dump_cb000000_cb7fffff.bin:0xcb000000 &gt; tracesmm_12_ptasm</code> </p> <br><p><img src="https://habrastorage.org/webt/zb/5q/mh/zb5qmhqp5rlqaa2xi6qydeu0i_o.png"><br>  Gambar 8. Daftar assembler yang sesuai dengan log IPT </p><br><p>  Ini sudah terlihat jauh lebih baik, tetapi jika kode tersebut berisi loop, output akan tersumbat dengan instruksi yang sama. </p><br><h2 id="opredelyaem-pokrytie-koda-pri-pomoschi-trassy">  Tentukan cakupan kode menggunakan jejak </h2><br><p>  Untuk mendapatkan visualisasi cakupan, kami memilih plugin <a href="https://github.com/gaasedelen/lighthouse">Lighthouse</a> untuk IDA Pro, yang menggunakan format drcov. </p><br><p>  Tidak ada alat siap pakai yang ditemukan, jadi kami memodifikasi <strong>ptx</strong> sehingga juga menghasilkan file cakupan dalam proses.  Patched <strong>ptxed</strong> tersedia di <a href="https://github.com/sysenter-eip/smm_intel_pt/commit/8b7e23b3353fc04f886b9a226c1a34f768200822">repositori</a> .  Lihatlah histori komit untuk menentukan apa yang sebenarnya ditambahkan. </p><br><p>  Setelah ptxed selesai, file SMRAM_dump_cb000000_cb7fffff.bin.log muncul, yang akan berisi informasi cakupan dalam format drcov. </p><br><p>  <strong>Catatan:</strong> Ada sedikit masalah dengan sinkronisasi disassembler pada PSB pertama.  Untuk alasan yang tidak sepenuhnya jelas, jika PSB dihasilkan sebelum PGE (penghitung diatur ulang ke nol sebelum jejak diaktifkan kembali), maka <strong>ptxed</strong> tidak dapat disinkronkan di atasnya.  Untuk mengatasi masalah ini, kami membuat tambalan kecil.  Tidak jelas apakah ini masalah untuk <strong>ptxed</strong> itu sendiri, atau apakah kami melakukan sesuatu yang salah dengan mengatur ulang IA32_RTIT_STATUS.PacketByteCnt. </p><br><p><img src="https://habrastorage.org/webt/pj/es/cq/pjescq_texdfmus7ljkpzxnrcaq.png"><br>  Gambar 9. Patch yang memungkinkan Anda untuk menggunakan PSB yang terletak tepat di depan PGE </p><br><p>  File cakupan yang dihasilkan dapat diunduh ke IDA Pro dan mendapatkan sorotan yang indah, serta statistik pada cakupan persen untuk setiap fungsi. </p><br><p><img src="https://habrastorage.org/webt/xl/7x/al/xl7xalcnynzuvjrrnrniamo-mzw.png"><br>  Gambar 10. Plugin IDA Pro Lighthouse dengan informasi cakupan kode </p><br><p>  <strong>Catatan:</strong> Plugin Lighthouse bekerja sedikit aneh pada database yang dianalisis secara tidak lengkap (kode yang dapat dieksekusi tidak diberi label, fungsi belum dibuat).  Kami melacak "masalah" ini ke fungsi get_instructions_slice di file \ lighthouse \ metadata.py, di mana ia mengembalikan 0 instruksi bahkan untuk alamat tempat fungsi itu dibuat secara manual.  Pengaya tampaknya menggunakan cache dan mengabaikan kode spesifik baru.  Ini dapat dielakkan dengan memanggil Reanalyze pada program dan membuka kembali IDB.  Hanya setelah itu plugin akan dapat melihat kode baru dan mulai mempertimbangkannya.  Karena masalah ini sangat merepotkan dalam kasus dump SMRAM (yang pada boot pertama hampir seluruhnya terdiri dari kode yang tidak ditentukan), kami membuat satu perubahan kecil pada kode Mercusuar sehingga kami dapat secara manual mendefinisikan kode baru lebih cepat. </p><br><p><img src="https://habrastorage.org/webt/rq/4m/d8/rq4md80-4y5bjhzyqvpgmjeyjpe.png"><br>  Gambar 11. Menambahkan pesan log untuk membantu mengidentifikasi kode baru </p><br><h2 id="podderzhka-linux">  Dukungan Linux </h2><br><p>  Karena semua pengujian kami dilakukan pada Windows 10 x64 (kami membutuhkan ipt.sys, yang muncul di Windows October Creators Update 2018), katakanlah beberapa kata tentang kemungkinan penerapan ini di Linux. </p><br><ul><li>  Ada modul <strong>perf</strong> kernel Linux yang dapat melakukan tindakan WinIPT (ipt.sys) yang sama, termasuk kemampuan untuk melacak kode dalam mode kernel. </li><li>  Karena antarmuka SMM backdoor didasarkan pada kerangka CHIPSEC lintas-platform, tambalan kami akan bekerja pada sistem Linux tanpa modifikasi apa pun. </li></ul><br><h2 id="vyvod">  Kesimpulan </h2><br><p>  Kami berhasil mengatasi tugas mendapatkan jejak kode yang dieksekusi di SMM menggunakan teknologi Intel Processor Trace.  Hasil serupa dapat dicapai dengan bantuan peralatan dan perangkat lunak mahal yang tidak dijual kepada semua orang.  Sudah cukup bagi kami untuk memiliki satu motherboard dan SPI-programmer.  Kecepatan penghapusan trek sangat mengesankan, dan tidak ada keluhan tentang keakuratan hasilnya. </p><br><p>  Kami berharap artikel ini membantu orang lain memanfaatkan teknologi Intel PT untuk menyelidiki dan mencari kerentanan dalam kode SMM.  Menyesuaikan pekerjaan kami dengan motherboard lain seharusnya tidak menyebabkan kesulitan (jangan lupa tentang Intel Boot Guard).  Hal utama adalah untuk sepenuhnya memahami cara kerjanya.  Bagian yang paling sulit adalah menentukan cara mencegat dispatcher SMI dan menulis shellcode untuk pencegat.  Dalam versi kami, alamat "berkabel" digunakan, jadi Anda harus dengan hati-hati mentransfer shellcode ke sistem lain. </p><br><p>  Semua alat dan skrip yang digunakan tersedia di <a href="https://github.com/sysenter-eip/smm_intel_pt">repositori di GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481692/">https://habr.com/ru/post/id481692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481674/index.html">Corong penjualan mobil atau bagaimana tidak menggabungkan pelanggan dan bahkan bekerja dengan mereka yang telah menolak layanan Anda?</a></li>
<li><a href="../id481676/index.html">Minggu Keamanan 52: Keamanan untuk Speaker Cerdas dan Kamera IP</a></li>
<li><a href="../id481680/index.html">Menulis TodoMVC di dap. Bagian 2</a></li>
<li><a href="../id481684/index.html">Laptop dari Powerbank?</a></li>
<li><a href="../id481688/index.html">Mengapa mempelajari Java dan bagaimana melakukannya dengan efisien. Laporan Yandex</a></li>
<li><a href="../id481694/index.html">Cara saya mempartisi di PostgreSQL</a></li>
<li><a href="../id481696/index.html">ruleeguard: pemeriksaan dinamis untuk Go</a></li>
<li><a href="../id481698/index.html">Streaming WebRTC di dan sekitar realitas virtual</a></li>
<li><a href="../id481700/index.html">Tentang seorang bibi</a></li>
<li><a href="../id481702/index.html">Dari pemanggang ke drone. Bagaimana Internet bisa terjadi dan mengapa Internet hanya menyala 30 tahun kemudian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>