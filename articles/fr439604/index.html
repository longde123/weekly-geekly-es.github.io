<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👜 ➿ 👨🏻‍🚒 Comment le code-barres est-il organisé? ❓ 👩🏿‍🚒 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Une personne moderne rencontre chaque jour des codes-barres, sans même y penser. Lorsque nous achetons des produits au supermarché, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment le code-barres est-il organisé?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439604/">  Bonjour, Habr! <br><br>  Une personne moderne rencontre chaque jour des codes-barres, sans même y penser.  Lorsque nous achetons des produits au supermarché, leurs codes sont lus précisément à l'aide d'un code-barres.  Aussi des colis, des marchandises dans des entrepôts, etc.  Cependant, peu de gens savent comment cela fonctionne vraiment. <br><br>  Comment le code-barres est-il organisé et qu'est-ce qui est encodé dans cette image? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Essayons de le comprendre, en même temps, nous allons écrire un décodeur de ces codes. <a name="habracut"></a><br><br><h2>  Présentation </h2><br>  L'utilisation de codes-barres a une longue histoire.  Les premières tentatives d'automatisation ont commencé dans les années 1950; un brevet pour un lecteur de code a été obtenu en 1952.  L'ingénieur impliqué dans le tri des wagons sur la voie ferrée a souhaité simplifier le processus.  L'idée était évidente: coder le nombre à l'aide de bandes et les lire à l'aide de photocellules.  En 1962, les codes ont commencé à être officiellement utilisés pour identifier les voitures sur le chemin de fer américain (système <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KarTrak</a> ), en 1968, le projecteur a été remplacé par un faisceau laser, ce qui a augmenté la précision et réduit la taille du lecteur.  En 1973, le format «Universal Product Code» est apparu et, en 1974, le premier produit a été vendu à l'aide d'un scanner de code (le chewing-gum de Wrigley est aux États-Unis;) dans un supermarché.  En 1984, un tiers des magasins utilisaient des banderoles, mais en Russie, ils ont commencé à être utilisés vers les années 90. <br><br>  Beaucoup de codes différents sont utilisés pour différentes tâches, par exemple, la séquence "12345678" peut être représentée de cette manière (et ce n'est pas tout): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Commençons l'analyse syntaxique au niveau du bit.  De plus, tout ce qui est décrit ci-dessous fera référence au formulaire «Code-128» - simplement parce que son format est assez simple et direct.  Ceux qui souhaitent expérimenter avec d'autres espèces peuvent ouvrir un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générateur en ligne</a> et voir par eux-mêmes. <br><br>  À première vue, le code à barres semble être juste une séquence aléatoire de lignes, en fait, sa structure est clairement fixée: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espace vide nécessaire pour identifier clairement le début du code <br>  2 - Symbole de départ.  Pour le Code-128, 3 options sont possibles (appelées A, B et C): 11010000100, 11010010000 ou 11010011100, elles correspondent à différentes tables de codes (pour plus de détails, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> ). <br>  3 - En fait, le code contenant les données dont nous avons besoin <br>  4 - Somme de contrôle <br>  5 - Symbole d'arrêt.  Pour Code-128, il s'agit de 1100011101011. <br>  6 (1) - Espace vide. <br><br>  Maintenant, comment les bits sont encodés.  Tout est très simple ici - si vous prenez la largeur de la ligne la plus mince comme «1», alors la ligne à double largeur donnera le code «11», un triple «111», et ainsi de suite.  L'espace vide sera "0" ou "00" ou "000" selon le même principe.  Ceux qui le souhaitent peuvent comparer le code de départ dans l'image pour s'assurer que la règle est respectée. <br><br>  Vous pouvez maintenant commencer la programmation. <br><br><h2>  Obtenez la séquence de bits </h2><br>  En principe, c'est la partie la plus difficile, et bien sûr, algorithmiquement, elle peut être mise en œuvre de différentes manières.  Je ne suis pas sûr que l'algorithme ci-dessous soit optimal, mais il suffit amplement pour une étude de cas. <br><br>  Tout d'abord, chargez l'image, étirez-la en largeur, prenez une ligne horizontale à partir du milieu de l'image, convertissez-la en n / b et chargez-la en tant que tableau. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Sur le code-barres, "1" correspond au noir, et en RVB, au contraire, 0, donc le tableau doit être inversé.  Dans le même temps, nous calculons la valeur moyenne. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Nous démarrons le programme pour nous assurer que le code-barres est correctement chargé: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Vous devez maintenant déterminer la largeur d'un "bit".  Pour ce faire, nous mettons en évidence le début de la séquence de départ "1101", en enregistrant les moments de transition du graphe à travers la ligne médiane. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Nous enregistrons uniquement les transitions par le milieu, de sorte que le code "1101" sera écrit "101", mais cela nous suffit pour connaître sa largeur en pixels. <br><br>  Maintenant, le décodage réel.  Nous trouvons la transition suivante par le milieu et déterminons le nombre de bits qui tombent dans l'intervalle.  Comme la correspondance n'est pas absolue (le code peut être légèrement incurvé ou étiré), nous utilisons l'arrondi. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Je ne sais pas si c'est la meilleure option, peut-être y a-t-il une meilleure façon, ceux qui le souhaitent peuvent écrire dans les commentaires. <br><br>  Si tout a été fait correctement, nous obtenons alors la séquence de sortie suivante: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Décodage </h2><br>  Ici, en principe, il n'y a pas de difficultés.  Les caractères du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code 128</a> sont codés avec un code à 11 bits, qui a 3 variétés (A, B et C) et peuvent stocker soit des codages de caractères différents soit des nombres de 00 à 99. <br><br>  Dans notre cas, le début de la séquence est 11010010000, ce qui correspond au «Code B».  Il était terriblement cassé de piloter manuellement tous les codes de Wikipedia, donc le tableau a été simplement copié à partir du navigateur et son analyse a également été effectuée en Python (indice: ce n'est pas nécessaire pour la production). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Maintenant, la chose la plus simple reste.  Nous divisons notre séquence de bits en blocs de 11 caractères: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Enfin, nous formons la ligne et l'affiche à l'écran: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Je ne donnerai pas la réponse à ce qui est encodé dans le tableau, que ce soit un devoir pour les lecteurs (l'utilisation de programmes prêts à l'emploi pour smartphones sera considérée comme de la triche :). <br><br>  Le code n'implémente pas non plus la vérification CRC, ceux qui le souhaitent peuvent le faire eux-mêmes. <br><br>  Bien sûr, l'algorithme est imparfait et a été écrit en une demi-heure.  À des fins plus professionnelles, il existe des bibliothèques prêtes à l'emploi, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyzbar</a> .  Le code utilisant une telle bibliothèque ne prendra que 4 lignes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (vous devez d'abord installer la bibliothèque en entrant la commande pip install pyzbar) <br><br>  <b>Addition</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">vinograd19 a</a> écrit dans les commentaires sur le comptage CRC: <br><br>  <i>L'histoire du chiffre de contrôle est intéressante.</i>  <i>Il est né évolutivement.</i> <i><br></i>  <i>Le chiffre de contrôle est nécessaire afin d'éviter un décodage incorrect.</i>  <i>Si le code à barres était 1234 et qu'il a été reconnu comme 7234, vous avez besoin d'une validation qui empêchera le remplacement de 1 par 7. La validation peut être inexacte de sorte qu'au moins 90% des numéros invalides soient déterminés à l'avance.</i> <i><br><br></i>  <i>1ère approche: Prenons simplement le montant.</i>  <i>Pour que le reste de la division par 10 soit 0. Eh bien, c'est-à-dire que les 12 premiers caractères portent une charge d'informations, et le dernier chiffre est sélectionné de sorte que la somme des chiffres soit divisée par 10. Décodez la séquence, si la somme n'est pas divisible par dix, cela signifie décodé avec un bogue et vous devez le faire cette fois encore.</i>  <i>Par exemple, le code 1234 est valide.</i>  <i>1 + 2 + 3 + 4 = 10. Le code 1216 est également valide, mais 1218 ne l'est pas.</i> <i><br><br></i>  <i>Cela évite les problèmes d'automatisation.</i>  <i>Cependant, au moment de la création des codes-barres, il y a eu un repli sous la forme de la saisie d'un nombre sur les touches.</i>  <i>Et il y a un mauvais cas: si vous changez l'ordre des deux chiffres, la somme de contrôle ne change pas, et c'est mauvais.</i>  <i>Autrement dit, si le code à barres 1234 a été martelé comme 2134, la somme de contrôle convergera, mais nous avons entré le mauvais numéro.</i>  <i>Il s'avère que le mauvais ordre des numéros est un cas courant si vous frappez rapidement les clés.</i> <i><br><br></i>  <i>2ème approche.</i>  <i>Eh bien, rendons le montant un peu plus compliqué.</i>  <i>Pour que les chiffres sur les places paires soient pris en compte deux fois.</i>  <i>Ensuite, lors du changement de commande, le montant ne convergera certainement pas vers celui souhaité.</i>  <i>Par exemple, le code 2364 est valide (2 + 3 + 3 + 6 + 4 + 4 = 20) et le code 3264 n'est pas valide (3+ 2 + 2 + 6 + 4 + 4 = 19).</i>  <i>Mais voici un autre mauvais exemple de conduite.</i>  <i>Certains claviers sont tels que dix chiffres sont disposés sur deux rangées.</i>  <i>la première ligne est 12345 et en dessous la deuxième deuxième ligne est 67890. Si, au lieu de la touche "1", appuyez sur la touche "2" vers la droite, la somme de contrôle empêchera la saisie incorrecte.</i>  <i>Mais si au lieu de la touche «1», appuyez sur la touche «6» ci-dessous, il ne peut pas avertir.</i>  <i>Après tout, 6 = 1 + 5, et dans le cas où ce chiffre est à un même endroit lors du calcul de la somme de contrôle, nous avons 2 * 6 = 2 * 1 + 2 * 5.</i>  <i>C'est-à-dire que la somme de contrôle a augmenté exactement de 10, donc son dernier chiffre n'a pas changé.</i>  <i>Par exemple, les sommes de contrôle des codes 2134 et 2634 sont identiques.</i>  <i>La même erreur se produira si nous appuyons sur 7 au lieu de 2, au lieu de 3 sur 8, etc.</i> <i><br><br></i>  <i>3ème approche.</i>  <i>Ok, reprenons la somme, seuls les nombres aux endroits pairs seront pris en compte ... trois fois.</i>  <i>Autrement dit, le code 1234565 est valide, car 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>La méthode décrite est devenue la norme pour calculer la somme de contrôle EAN13 avec quelques corrections: le nombre de chiffres est devenu fixe et égal à 13, où le 13e est la même somme de contrôle.</i>  <i>Les nombres sur les endroits impairs sont comptés trois fois, sur ceux pairs - une fois.</i> <br><br><h2>  Conclusion </h2><br>  Comme vous pouvez le voir, même une chose aussi simple qu'un code à barres contient beaucoup de choses intéressantes.  Au fait, un autre hack de vie pour ceux qui ont lu jusqu'ici - le texte sous le code-barres (le cas échéant) duplique complètement son contenu.  Ceci est fait de sorte qu'en cas de code illisible, l'opérateur puisse le saisir manuellement.  Donc, pour découvrir le contenu d'un code-barres est généralement simple - il suffit de regarder le texte en dessous. <br><br>  Comme suggéré dans les commentaires, le plus populaire dans le commerce est le code EAN-13, le codage binaire est le même là-bas, et ceux qui le souhaitent peuvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir la</a> structure des caractères <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eux-mêmes</a> . <br><br>  Si les lecteurs n'ont pas perdu tout intérêt, vous pouvez considérer séparément les codes QR. <br><br>  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439604/">https://habr.com/ru/post/fr439604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439594/index.html">Annotations de printemps: AOP Magic</a></li>
<li><a href="../fr439596/index.html">Comment j'ai accéléré le traitement d'image sur Android 15 fois</a></li>
<li><a href="../fr439598/index.html">Microsoft a parlé du coût de l'assistance payante pour Windows 7</a></li>
<li><a href="../fr439600/index.html">La Finlande résume les résultats préliminaires d'une expérience sur le revenu de base garanti</a></li>
<li><a href="../fr439602/index.html">L'éthique dans l'espace numérique - les règles de base des relations numériques internationales</a></li>
<li><a href="../fr439606/index.html">Production pilote d'électronique pour un prix minimum</a></li>
<li><a href="../fr439608/index.html">Religion moderne: qu'est-ce que Google, Facebook, Amazon et Apple donnent aux gens?</a></li>
<li><a href="../fr439610/index.html">Comme dans mon véhicule électrique Chevrolet Bolt, sous garantie, deux modules de batterie ont été remplacés, et le troisième sous surveillance</a></li>
<li><a href="../fr439612/index.html">JavaScript robuste: chasser un mythe</a></li>
<li><a href="../fr439614/index.html">Comment distinguer une bonne réparation d'une mauvaise, ou comment nous, dans SRG, avons créé une bibliothèque Java multi-thread à partir de l'analyseur Tomit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>