<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ˆğŸ½ ğŸ¤ ğŸ¤ [Terjemahan] Utusan model threading â³ ğŸ’³ âœ”ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan artikel â€œUtusan model threadingâ€ oleh Matt Klein. 

 Artikel ini sepertinya cukup menarik bagi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[Terjemahan] Utusan model threading</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449826/">  Halo, Habr!  Saya mempersembahkan untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">â€œUtusan model threadingâ€</a> oleh Matt Klein. <br><br>  Artikel ini sepertinya cukup menarik bagi saya, dan karena Utusan paling sering digunakan sebagai bagian dari "istio" atau hanya sebagai kubernet "pengendali masuk", oleh karena itu kebanyakan orang tidak memiliki interaksi langsung yang sama dengannya seperti misalnya dengan instalasi Nginx atau Haproxy yang khas.  Namun, jika sesuatu pecah, akan lebih baik untuk memahami cara kerjanya dari dalam.  Saya mencoba menerjemahkan teks sebanyak mungkin ke dalam bahasa Rusia, termasuk kata-kata khusus, bagi mereka yang sulit melihat ini, saya meninggalkan aslinya dalam tanda kurung.  Selamat datang di kucing. <br><a name="habracut"></a><br>  Dokumentasi teknis tingkat rendah pada basis kode Utusan saat ini cukup langka.  Untuk memperbaikinya, saya berencana membuat serangkaian artikel blog tentang berbagai subsistem Utusan.  Karena ini adalah artikel pertama, beri tahu saya apa yang Anda pikirkan dan apa yang mungkin Anda minati dalam artikel-artikel berikut. <br><br>  Salah satu pertanyaan teknis paling umum yang saya dapatkan tentang Utusan adalah permintaan untuk deskripsi tingkat rendah dari model threading yang digunakan.  Dalam posting ini, saya akan menjelaskan bagaimana Utusan memetakan koneksi ke utas, serta deskripsi sistem Penyimpanan Lokal Thread, yang digunakan secara internal untuk membuat kode lebih paralel dan berkinerja tinggi. <br><br><h1>  Ikhtisar pengaliran </h1><br><img src="https://habrastorage.org/webt/jy/46/yw/jy46ywgcjdk8zvrpwyeisan8hzm.png"><br><br>  <b>Utusan menggunakan tiga jenis aliran:</b> <br><br><ul><li>  <b>Utama:</b> Utas ini mengontrol awal dan akhir proses, semua pemrosesan XDS (xDiscovery Service) API, termasuk DNS, pemeriksaan kesehatan, klaster umum dan manajemen layanan (runtime), pengaturan ulang statistik, administrasi dan manajemen umum proses - sinyal Linux, restart panas, dll. Segala sesuatu yang terjadi di utas ini asinkron dan non-pemblokiran.  Secara umum, utas utama mengoordinasikan semua proses fungsional yang penting, yang tidak memerlukan CPU dalam jumlah besar untuk diselesaikan.  Ini memungkinkan sebagian besar kode kontrol ditulis seolah-olah satu-utas. </li><li>  <b>Pekerja:</b> Secara default, Utusan membuat utas pekerja untuk setiap utas perangkat keras dalam sistem, ini dapat dikontrol menggunakan opsi <code>--concurrency</code> .  Setiap utas pekerja memulai perulangan acara "non-pemblokiran", yang bertanggung jawab untuk mendengarkan setiap pendengar, pada saat penulisan (29 Juli 2017) tidak ada pecahan dari pendengar, menerima yang baru koneksi, membuat instance dari tumpukan filter untuk terhubung, dan memproses semua operasi I / O selama masa koneksi.  Sekali lagi, ini memungkinkan sebagian besar kode pemrosesan koneksi ditulis seolah-olah itu adalah single-threaded. </li><li>  <b>File flusher:</b> Setiap file yang ditulis Utusan, terutama akses log, saat ini memiliki aliran pemblokiran independen.  Ini disebabkan oleh fakta bahwa menulis ke file yang di-cache oleh sistem file, bahkan ketika menggunakan <code>O_NONBLOCK</code> , kadang-kadang dapat diblokir (desah).  Ketika utas pekerja perlu menulis ke file, data tersebut sebenarnya dipindahkan ke buffer dalam memori, di mana akhirnya dialirkan melalui aliran <b>flush file</b> .  Ini adalah salah satu area kode di mana secara teknis semua utas pekerja dapat memblokir kunci yang sama saat mencoba mengisi buffer memori. </li></ul><br><h1>  Penanganan koneksi </h1><br>  Sebagaimana dibahas secara singkat di atas, semua utas pekerja mendengarkan semua pendengar tanpa segmentasi apa pun.  Dengan demikian, kernel digunakan untuk mengirim soket yang diterima ke thread pekerja dengan benar.  Core modern umumnya sangat pandai dalam hal ini, mereka menggunakan fitur-fitur seperti meningkatkan prioritas input-output (IO) untuk mencoba mengisi utas dengan kerja, sebelum mulai menggunakan utas lain yang juga mendengarkan pada soket yang sama, dan juga tidak menggunakan penguncian melingkar. (Spinlock) untuk menangani setiap permintaan. <br><br>  Setelah koneksi diterima pada utas pekerja, itu tidak pernah meninggalkan utas ini.  Semua pemrosesan lebih lanjut dari koneksi sepenuhnya diproses di utas pekerja, termasuk perilaku penerusan. <br><br>  <b>Ini memiliki beberapa konsekuensi penting:</b> <br><br><ul><li>  <u>Semua kumpulan koneksi di Utusan berada dalam alur kerja.</u>  <u>Dengan demikian, meskipun kumpulan koneksi HTTP / 2 hanya membuat satu koneksi ke setiap host upstream pada suatu waktu, jika ada empat utas pekerja, akan ada empat koneksi HTTP / 2 ke host upstream dalam kondisi mapan.</u> </li><li>  Alasan Utusan bekerja dengan cara ini adalah karena dengan menyimpan segala sesuatu dalam satu alur kerja, hampir semua kode dapat ditulis tanpa memblokir dan seolah-olah itu adalah single-threaded.  Desain ini membuat penulisan banyak kode lebih mudah dan skala sangat baik untuk jumlah alur kerja yang hampir tak terbatas. </li><li>  Namun, salah satu kesimpulan utama adalah bahwa dari sudut pandang kumpulan memori dan efisiensi koneksi, sebenarnya sangat penting untuk mengkonfigurasi parameter <code>--concurrency</code> .  Memiliki lebih banyak utas pekerja daripada yang diperlukan akan menyebabkan hilangnya memori, membuat lebih banyak koneksi tidak aktif dan memperlambat kecepatan masuk ke kolam koneksi.  Di Lyft, wadah sespan utusan kami bekerja dengan konkurensi sangat rendah, sehingga kinerjanya kira-kira setara dengan layanan yang mereka duduki di sebelahnya.  Kami menjalankan Utusan sebagai proxy tepi (edge) hanya dengan konkurensi maksimum. </li></ul><br><h1>  Apa yang dimaksud dengan non-blocking? </h1><br>  Istilah "non-blocking" sejauh ini telah digunakan beberapa kali dalam membahas cara kerja utas utama dan pekerja.  Semua kode ditulis asalkan tidak ada yang diblokir.  Namun, ini tidak sepenuhnya benar (yang tidak sepenuhnya benar?). <br><br>  <b>Utusan menggunakan beberapa kunci proses yang panjang:</b> <br><br><ul><li>  Seperti yang telah disebutkan, saat menulis log akses, semua utas pekerja mendapatkan kunci yang sama sebelum mengisi buffer log dalam memori.  Waktu penahanan kunci harus sangat rendah, tetapi ada kemungkinan bahwa kunci ini akan ditantang dengan konkurensi tinggi dan throughput tinggi. </li><li>  Utusan menggunakan sistem yang sangat canggih untuk memproses statistik yang bersifat lokal ke aliran.  Ini akan menjadi topik posting terpisah.  Namun, saya akan secara singkat menyebutkan bahwa sebagai bagian dari pemrosesan statistik aliran lokal, kadang-kadang diperlukan untuk mendapatkan kunci untuk "toko statistik" pusat.  Kunci ini seharusnya tidak diperlukan. </li><li>  Utas utama secara berkala membutuhkan koordinasi dengan semua alur kerja.  Ini dilakukan dengan "menerbitkan" dari utas utama ke utas pekerja, dan terkadang dari utas pekerja kembali ke utas utama.  Untuk mengirim, pemblokiran diperlukan agar pesan yang diterbitkan dapat antri untuk pengiriman berikutnya.  Kunci ini seharusnya tidak pernah mengalami persaingan serius, tetapi mereka masih dapat diblokir secara teknis. </li><li>  Ketika Utusan menulis log ke aliran kesalahan sistem (kesalahan standar), ia menerima kunci pada seluruh proses.  Secara keseluruhan, logging lokal Utusan dianggap mengerikan dalam hal kinerja, jadi tidak ada banyak perhatian yang diberikan untuk memperbaikinya. </li><li>  Ada beberapa kunci acak lainnya, tetapi tidak satupun dari mereka yang kinerjanya kritis dan tidak boleh diperdebatkan. </li></ul><br><h1>  Utas penyimpanan lokal </h1><br>  Karena cara Utusan memisahkan tanggung jawab utas utama dari tanggung jawab alur kerja, ada persyaratan bahwa pemrosesan rumit dapat dilakukan pada utas utama dan kemudian diberikan kepada masing-masing alur kerja dengan konkurensi tingkat tinggi.  Bagian ini menjelaskan sistem Utusan Penyimpanan Lokal Utas (TLS) di tingkat tinggi.  Di bagian selanjutnya, saya akan menjelaskan bagaimana ini digunakan untuk mengelola cluster. <br><br><img src="https://habrastorage.org/webt/hc/e4/bs/hce4bsjgfljckbekacfilceotyq.png"><br><br>  Seperti yang sudah dijelaskan, utas utama memproses hampir semua fungsi manajemen dan fungsionalitas bidang kontrol dalam proses Utusan.  Pesawat kendali agak kelebihan beban di sini, tetapi jika Anda melihatnya dalam proses Utusan itu sendiri dan membandingkannya dengan penerusan yang dilakukan ulir pekerja, ini sepertinya tepat.  Sebagai aturan umum, proses utas utama berfungsi, dan kemudian perlu memperbarui setiap utas pekerja sesuai dengan hasil pekerjaan ini, <u>sedangkan utas pekerja tidak perlu menetapkan kunci pada setiap akses</u> . <br><br>  <b>Sistem Utusan TLS (Thread local storage) berfungsi sebagai berikut:</b> <br><br><ul><li>  Kode yang berjalan di utas utama dapat mengalokasikan slot TLS untuk seluruh proses.  Meskipun ini diabstraksikan, dalam praktiknya ini adalah indeks dalam vektor yang menyediakan akses O (1). </li><li>  Aliran utama dapat mengatur data acak di slotnya.  Ketika ini dilakukan, data diterbitkan dalam setiap alur kerja sebagai peristiwa loop peristiwa reguler. </li><li>  Utas pekerja dapat membaca dari slot TLS mereka dan mengambil data utas lokal yang tersedia di sana. </li></ul><br>  Meskipun ini adalah paradigma yang sangat sederhana dan sangat kuat, ini sangat mirip dengan konsep pemblokiran RCU (Read-Copy-Update).  Intinya, alur kerja tidak pernah melihat perubahan data apa pun di slot TLS saat dijalankan.  Perubahan hanya terjadi selama periode istirahat antara acara kerja. <br><br>  <b>Utusan menggunakan ini dalam dua cara berbeda:</b> <br><br><ul><li>  Dengan menyimpan berbagai data pada setiap alur kerja, akses ke data ini dilakukan tanpa pemblokiran. </li><li>  Dengan menyimpan pointer global ke data global dalam mode baca-saja di setiap utas pekerja.  Dengan demikian, setiap utas pekerja memiliki penghitung referensi data, yang tidak dapat dikurangi selama pelaksanaan pekerjaan.  Hanya ketika semua pekerja tenang dan mengunggah data baru yang dibagikan maka data lama akan dihancurkan.  Ini identik dengan RCU. </li></ul><br><h1>  Threading pembaruan cluster </h1><br>  Di bagian ini, saya akan menjelaskan bagaimana TLS (Thread local storage) digunakan untuk mengelola sebuah cluster.  Manajemen klaster mencakup pemrosesan xDS dan / atau DNS API, serta pemeriksaan kesehatan. <br><br><img src="https://habrastorage.org/webt/by/jw/4q/byjw4qhlo9xjsprdu9ngi9dop_y.png"><br><br>  <b>Manajemen aliran Cluster meliputi komponen dan langkah-langkah berikut:</b> <br><br><ol><li>  Cluster Manager adalah komponen dalam Utusan yang mengelola semua cluster hulu yang diketahui, API CDS (Cluster Discovery Service), SDS (Secret Discovery Service) dan EDS (Endpoint Discovery Service), DNS dan pemeriksaan eksternal aktif kesehatan (pemeriksaan kesehatan).  Dia bertanggung jawab untuk menciptakan representasi â€œakhirnya konsistenâ€ dari setiap klaster hulu yang mencakup inang yang ditemukan, serta status kesehatan. </li><li>  Pemeriksa kesehatan melakukan pemeriksaan kesehatan aktif dan melaporkan perubahan status kesehatan kepada manajer klaster. </li><li>  CDS (Cluster Discovery Service) / SDS (Secret Discovery Service) / EDS (Endpoint Discovery Service) / DNS dilakukan untuk menentukan keanggotaan cluster.  Perubahan status dikembalikan ke manajer kluster. </li><li>  Setiap alur kerja terus-menerus menjalankan loop acara. </li><li>  Ketika manajer cluster menentukan bahwa status untuk cluster telah berubah, itu membuat snapshot cluster read-only baru dan mengirimkannya ke setiap utas pekerja. </li><li>  Selama periode tidak aktif berikutnya, alur kerja akan memperbarui foto di slot TLS khusus. </li><li>  Selama acara I / O yang tuan rumah harus menentukan untuk load balancing, load balancer akan meminta slot TLS (Thread local storage) untuk mendapatkan informasi host.  Tidak diperlukan kunci untuk ini.  Perhatikan juga bahwa TLS juga dapat memicu peristiwa selama pemutakhiran, sehingga penyeimbang muatan dan komponen lainnya dapat menghitung ulang cache, struktur data, dll.  Ini di luar ruang lingkup tulisan ini, tetapi digunakan di berbagai tempat dalam kode. </li></ol><br>  Dengan menggunakan prosedur di atas, Utusan dapat memproses setiap permintaan tanpa kunci apa pun (selain yang dijelaskan sebelumnya).  Selain kompleksitas kode TLS itu sendiri, sebagian besar kode tidak perlu memahami cara kerja multithreading, dan dapat ditulis dalam mode single-threaded.  Ini membuatnya lebih mudah untuk menulis sebagian besar kode di samping kinerja yang unggul. <br><br><h1>  Subsistem lain yang menggunakan TLS </h1><br>  TLS (Thread local storage) dan RCU (Read Copy Update) banyak digunakan di Utusan. <br><br>  <b>Contoh penggunaan:</b> <br><br><ul><li>  <b>Mekanisme mengubah fungsionalitas selama eksekusi:</b> Daftar fungsi yang diaktifkan saat ini dihitung di utas utama.  Setiap alur kerja kemudian dilengkapi dengan snapshot read-only menggunakan semantik RCU. </li><li>  <b>Mengganti tabel rute</b> : untuk tabel rute yang disediakan oleh RDS (Route Discovery Service), tabel rute dibuat di utas utama.  Cuplikan baca-saja nantinya akan diberikan ke setiap alur kerja menggunakan semantik RCU (Baca Salin Pembaruan).  Ini membuat memodifikasi tabel rute secara efisien. </li><li>  <b>Caching Header HTTP:</b> Ternyata, menghitung header HTTP untuk setiap permintaan (saat melakukan ~ 25K + RPS per core) cukup mahal.  Utusan menghitung header secara terpusat kira-kira setiap setengah detik dan memberikannya kepada setiap karyawan melalui TLS dan RCU. </li></ul><br>  Ada kasus lain, tetapi contoh sebelumnya harus memberikan pemahaman yang baik tentang apa yang digunakan untuk TLS. <br><br><h1>  Perangkap kinerja yang dikenal </h1><br>  Meskipun Utusan bekerja secara keseluruhan dengan cukup baik, ada beberapa area terkenal yang perlu perhatian ketika digunakan dengan konkurensi dan bandwidth yang sangat tinggi: <br><br><ul><li>  Seperti yang sudah dijelaskan dalam artikel ini, saat ini semua utas pekerja terkunci ketika mereka menulis ke buffer memori log akses.  Dengan konkurensi tinggi dan throughput tinggi, akan perlu untuk mengemas log akses untuk setiap alur kerja karena pengiriman yang tidak teratur saat menulis ke file akhir.  Atau, Anda dapat membuat log akses terpisah untuk setiap alur kerja. </li><li>  Meskipun statistik sangat dioptimalkan, dengan konkurensi dan throughput yang sangat tinggi, kemungkinan ada persaingan atom pada statistik individu.  Solusi untuk masalah ini adalah penghitung per satu alur kerja dengan reset berkala penghitung pusat.  Ini akan dibahas dalam posting selanjutnya. </li><li>  Arsitektur yang ada tidak akan berfungsi dengan baik jika Utusan digunakan dalam skenario di mana ada sangat sedikit koneksi yang membutuhkan sumber daya pemrosesan yang signifikan.  Tidak ada jaminan bahwa komunikasi akan didistribusikan secara merata di antara alur kerja.  Ini dapat diselesaikan dengan menyeimbangkan koneksi kerja, di mana kemampuan untuk bertukar koneksi antara aliran kerja akan direalisasikan. </li></ul><br><h1>  Kesimpulan </h1><br>  Model threading Utusan dirancang untuk memberikan kemudahan pemrograman dan konkurensi besar karena penggunaan memori dan koneksi yang berpotensi boros jika tidak dikonfigurasi dengan benar.  Model ini memungkinkannya bekerja dengan sangat baik dengan jumlah utas dan throughput yang sangat tinggi. <br><br>  Seperti yang saya sebutkan secara singkat di Twitter, desain juga dapat berjalan di atas tumpukan jaringan yang berfungsi penuh dalam mode pengguna, seperti DPDK (Data Plane Development Kit), yang dapat menyebabkan server reguler memproses jutaan permintaan per detik dengan pemrosesan L7 penuh.  Akan sangat menarik untuk melihat apa yang akan dibangun dalam beberapa tahun mendatang. <br><br>  Satu komentar cepat terakhir: Saya sering ditanya mengapa kami memilih C ++ untuk Utusan.  Alasannya, seperti sebelumnya, adalah bahwa itu masih satu-satunya bahasa tingkat industri yang digunakan secara luas untuk membangun arsitektur yang dijelaskan dalam posting ini.  C ++ jelas tidak cocok untuk semua atau bahkan untuk banyak proyek, tetapi untuk kasus penggunaan tertentu itu masih satu-satunya alat untuk menyelesaikan pekerjaan (untuk menyelesaikan pekerjaan). <br><br><h1>  Tautan ke kode </h1><br>  <b>Tautan ke file dengan antarmuka dan implementasi header yang dibahas dalam posting ini:</b> <br><br><ul><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/thread_local/thread_local.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/thread_local/thread_local_impl.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/include/envoy/upstream/cluster_manager.h</a> </li><li>  <a href="">github.com/lyft/envoy/blob/master/source/common/upstream/cluster_manager_impl.h</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449826/">https://habr.com/ru/post/id449826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449808/index.html">Eksperimen Hack Days 9 Positif: Bagaimana Cara Berpikir Kritis Membantu Kehidupan dan Pekerjaan</a></li>
<li><a href="../id449814/index.html">Windows XP secara resmi mati, sekarang akhirnya</a></li>
<li><a href="../id449818/index.html">Statistik dan pemantauan skrip PHP secara real time. ClickHouse dan Grafana pergi ke Pinba untuk bantuan</a></li>
<li><a href="../id449820/index.html">Sesuaikan asosiasi file yang dikenal secara instan</a></li>
<li><a href="../id449824/index.html">Petualangan Startup Besi di Rusia: Membangun Tim</a></li>
<li><a href="../id449828/index.html">"Tikus menangis dan menusuk .." Impor substitusi dalam praktek. Bagian 4 (teoritis, final). Sistem dan Layanan</a></li>
<li><a href="../id449830/index.html">Kontrol saluran listrik HD44780</a></li>
<li><a href="../id449832/index.html">Masa depan kuantum</a></li>
<li><a href="../id449836/index.html">Dell U2419HC: monitor 24-inci penuh gaya dengan Full HD dan USB-C</a></li>
<li><a href="../id449840/index.html">Inception bar: metode phishing baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>