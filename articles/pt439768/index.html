<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•í ‚ùáÔ∏è üçº Como funciona um c√≥digo de barras? ‚úåüèæ üë®üèæ üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° a todos! 

 Hoje em dia, todo mundo usa c√≥digos de barras, principalmente sem perceber. Quando compramos as compras na loja, seus identificadores ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como funciona um c√≥digo de barras?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439768/">  Ol√° a todos! <br><br>  Hoje em dia, todo mundo usa c√≥digos de barras, principalmente sem perceber.  Quando compramos as compras na loja, seus identificadores s√£o obtidos a partir de c√≥digos de barras.  Tamb√©m √© o mesmo com mercadorias nos armaz√©ns, encomendas postais e assim por diante.  Mas poucas pessoas realmente sabem como isso funciona. <br><br>  O que √© 'dentro' do c√≥digo de barras e o que √© codificado nesta imagem? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Vamos descobrir e tamb√©m vamos escrever nosso pr√≥prio decodificador de barras. <a name="habracut"></a><br><br><h2>  1. Introdu√ß√£o </h2><br>  O uso de c√≥digos de barras tem uma longa hist√≥ria.  As primeiras tentativas de fazer a automa√ß√£o foram feitas nos anos 50, a patente de um sistema de leitura de c√≥digos foi concedida.  David Collins, que trabalhava na Pennsylvania Railroad, decidiu facilitar o processo de classifica√ß√£o dos carros.  A id√©ia era √≥bvia - codificar os identificadores de carros com faixas de cores diferentes e l√™-los usando uma c√©lula fotogr√°fica.  Em 1962, esses c√≥digos se tornaram um padr√£o da Associa√ß√£o das Ferrovias Americanas.  (o sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KarTrak</a> ).  Em 1968, a l√¢mpada foi substitu√≠da por um laser, permitindo aumentar a precis√£o e reduzir o tamanho do leitor.  Em 1973, o C√≥digo Universal do Produto foi desenvolvido e, em 1974, o primeiro produto de supermercado (um chiclete Wrigley - obviamente estava nos EUA;) foi vendido.  Em 1984, a terceira parte de todas as lojas usava c√≥digos de barras; em outros pa√≠ses, tornou-se popular mais tarde. <br><br>  Existem muitos tipos diferentes de c√≥digos de barras para aplicativos diferentes, por exemplo, a string "12345678" pode ser codificada dessa maneira (e nem todas elas): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Vamos come√ßar a an√°lise.  Todas as informa√ß√µes abaixo ser√£o sobre o tipo "Code-128" - apenas porque √© f√°cil entender o princ√≠pio.  Quem quiser testar outros modos, pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerador de c√≥digo de barras on-line</a> e testar outros tipos por conta pr√≥pria. <br><br>  √Ä primeira vista, um c√≥digo de barras se parece com um conjunto aleat√≥rio de n√∫meros, mas na verdade sua estrutura √© bem organizada: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espa√ßo vazio, necess√°rio para determinar a posi√ß√£o inicial do c√≥digo. <br>  2 - Iniciar s√≠mbolo.  Est√£o dispon√≠veis tr√™s tipos de C√≥digo-128 (chamados A, B e C) e os s√≠mbolos de in√≠cio podem ser 11010000100, 11010010000 ou 11010011100, respectivamente.  Para esses tipos, as tabelas de codifica√ß√£o s√£o diferentes (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o do Code_128 para obter mais detalhes</a> ). <br>  3 - O pr√≥prio c√≥digo, contendo dados do usu√°rio. <br>  4 - Cheque soma. <br>  5 - S√≠mbolo de parada, para o Code-128 √© 1100011101011. <br>  6 (1) - espa√ßo vazio. <br><br>  Agora vamos dar uma olhada em como os bits est√£o codificando.  √â realmente f√°cil - se levarmos a largura da linha mais fina para "1", a linha de largura dupla ser√° "11", a linha de largura tripla ser√° "111" e assim por diante.  O espa√ßo vazio ser√° respectivamente "0", "00" ou "000", de acordo com o mesmo princ√≠pio.  Quem estiver interessado, pode comparar a sequ√™ncia de in√≠cio na imagem acima, para ver se a regra √© respeitada. <br><br>  Agora podemos come√ßar a codificar. <br><br><h2>  Obtendo a sequ√™ncia de bits </h2><br>  Em geral, √© a parte mais complicada e pode ser feita de maneiras diferentes.  N√£o tenho certeza de que minha abordagem seja √≥tima, mas para a nossa tarefa √© definitivamente suficiente. <br><br>  Primeiro, vamos carregar a imagem, esticar sua largura, cortar uma linha horizontal a partir do meio, convert√™-la em cor preto e branco e salv√°-la como uma matriz. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  No c√≥digo de barras, a linha preta corresponde a "1", mas no RGB o preto √© contr√°rio, 0, portanto a matriz precisa ser invertida.  Tamb√©m calcularemos o valor m√©dio. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Vamos executar o programa para verificar se o c√≥digo de barras foi carregado corretamente: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Agora precisamos determinar a largura de um 'bit'.  Para fazer isso, extrairemos a sequ√™ncia, salvando as posi√ß√µes do cruzamento m√©dio de linha. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Como estamos salvando apenas os cruzamentos m√©dios de linha, o c√≥digo "1101" ser√° salvo como "101", o suficiente para obter a largura dos pixels. <br><br>  Agora vamos fazer a decodifica√ß√£o em si.  Precisamos encontrar todos os cruzamentos de linha m√©dios e encontrar o n√∫mero de bits no √∫ltimo intervalo encontrado.  Os n√∫meros n√£o ser√£o perfeitos (o c√≥digo pode ser esticado ou dobrado um pouco); portanto, precisamos arredondar o valor para inteiro. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Talvez haja uma maneira melhor de fazer isso, os leitores podem escrever nos coment√°rios. <br><br>  Se tudo foi perfeito, obteremos uma sequ√™ncia como esta: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Decodifica√ß√£o </h2><br>  Em geral, √© muito f√°cil.  Os s√≠mbolos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Code-128</a> s√£o codificados com c√≥digo de 11 bits, que podem ter codifica√ß√£o diferente (de acordo com essa codifica√ß√£o - A, B ou C, podem ser letras ou d√≠gitos de 00 a 99). <br><br>  No nosso caso, o in√≠cio da sequ√™ncia √© 11010010000, que corresponde a um "C√≥digo B".  Eu estava com pregui√ßa de inserir todos os c√≥digos manualmente, ent√£o copiei e colei de uma p√°gina da Wikipedia.  A an√°lise dessas linhas tamb√©m foi feita no Python (dica - n√£o fa√ßa coisas assim na produ√ß√£o). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  As √∫ltimas partes s√£o f√°ceis.  Primeiro, vamos dividir a sequ√™ncia em blocos de 11 bits: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Por fim, vamos gerar a sequ√™ncia de sa√≠da e exibi-la: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  N√£o mostrarei aqui o resultado decodificado da imagem superior, que seja o dever de casa para os leitores (usar os aplicativos baixados para smartphones ser√° considerado trapa√ßa :). <br><br>  A verifica√ß√£o CRC n√£o est√° implementada neste c√≥digo; quem quiser, pode fazer isso sozinho. <br><br>  Com certeza, esse algoritmo n√£o √© perfeito, foi feito em meia hora.  Para tarefas profissionais, existem bibliotecas prontas para usar, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pyzbar</a> .  Para decodificar a imagem, basta 4 linhas de c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (primeiro a biblioteca deve ser instalada usando o comando "pip install pyzbar") <br><br>  <b>Al√©m disso, o</b> usu√°rio do site <i>vinograd19</i> enviou um coment√°rio interessante sobre o hist√≥rico de c√°lculo da soma de verifica√ß√£o de c√≥digo de barras. <br><br>  <i>O c√°lculo do n√∫mero do cheque √© interessante, originou-se evolutivamente.</i> <i><br></i>  <i>A soma de verifica√ß√£o √© obviamente necess√°ria para evitar decodifica√ß√£o incorreta.</i>  <i>Se o c√≥digo de barras era 1234 e foi decodificado como 7234, precisamos de um m√©todo para rejeitar a substitui√ß√£o de 1 a 7. A valida√ß√£o pode n√£o ser perfeita, mas pelo menos 90% dos c√≥digos devem ser verificados corretamente.</i> <i><br><br></i>  <i>1¬™ abordagem: basta pegar a soma, para ter 0 como o restante da divis√£o.</i>  <i>Os primeiros s√≠mbolos cont√™m dados e o √∫ltimo d√≠gito √© assim, que a soma de todos os n√∫meros √© dividida por 10. Ap√≥s a decodifica√ß√£o, se a quantidade n√£o for divis√≠vel por 10 - a decodifica√ß√£o est√° incorreta e precisa ser repetida.</i>  <i>Por exemplo, o c√≥digo 1234 √© v√°lido - 1 + 2 + 3 + 4 = 10. C√≥digo 1216 - tamb√©m √© v√°lido, mas 1218 n√£o √©.</i> <i><br><br></i>  <i>Isso ajuda a evitar problemas de decodifica√ß√£o.</i>  <i>Mas os c√≥digos tamb√©m podem ser inseridos manualmente, usando o teclado de hardware.</i>  <i>Usando isso, outro caso incorreto foi encontrado - se a ordem de dois d√≠gitos for alterada, a soma de verifica√ß√£o ainda estar√° correta, √© definitivamente ruim.</i>  <i>Por exemplo, se o c√≥digo de barras 1234 foi inserido como 2134, a soma de verifica√ß√£o ser√° a mesma.</i>  <i>Verificou-se que uma ordem incorreta de d√≠gitos era o caso comum, se uma pessoa est√° tentando digitar d√≠gitos rapidamente.</i> <i><br><br></i>  <i>2¬™ abordagem.</i>  <i>Vamos melhorar o algoritmo de soma de verifica√ß√£o - vamos calcular os n√∫meros √≠mpares duas vezes.</i>  <i>Ent√£o, se a ordem for alterada, a soma estar√° incorreta.</i>  <i>Por exemplo, o c√≥digo 2364 √© v√°lido (2 + 3 * 2 + 6 + 4 * 2 = 20), mas o c√≥digo 3264 n√£o √© (3 + 2 * 2 + 6 + 4 * 2 = 19).</i>  <i>√â melhor, mas outro caso apareceu.</i>  <i>Existem alguns teclados, com 10 teclas em duas linhas, a primeira linha √© 12345 e a segunda √© 67890. Se, em vez de "1", o usu√°rio digitar "2", a verifica√ß√£o da soma de verifica√ß√£o falhar√°.</i>  <i>Mas se o usu√°rio digitar "6" em vez de "1" - a soma de verifica√ß√£o pode estar correta algumas vezes.</i>  <i>√â porque 6 = 1 + 5, e se o d√≠gito tiver um lugar √≠mpar, obtemos 2 * 6 = 2 * 1 + 2 * 5 - a soma aumentou em 10. O mesmo erro ocorrer√°, se o usu√°rio digitar "7 "Em vez de" 2 "," 8 "em vez de" 3 "e assim por diante.</i> <i><br><br></i>  <i>3¬™ abordagem.</i>  <i>Vamos pegar a soma novamente, mas vamos obter n√∫meros √≠mpares ... 3 vezes.</i>  <i>Por exemplo, o c√≥digo 1234565 - √© v√°lido, porque 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>Este m√©todo tornou-se um padr√£o para o c√≥digo EAN13, com algumas altera√ß√µes: o n√∫mero de d√≠gitos √© fixo e igual a 13, onde o 13¬∫ d√≠gito - √© a soma de verifica√ß√£o.</i>  <i>Os n√∫meros em lugares √≠mpares s√£o contados tr√™s vezes, em lugares pares uma vez.</i> <br><br>  A prop√≥sito, o c√≥digo EAN-13 √© o mais amplamente usado em shoppings e lojas, portanto as pessoas o veem com mais frequ√™ncia do que outros tipos de c√≥digo.  Sua codifica√ß√£o de bits √© a mesma do c√≥digo 128, a estrutura de dados pode ser encontrada no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> . <br><br><h2>  Conclus√£o </h2><br>  Como podemos ver, mesmo uma coisa f√°cil como um c√≥digo de barras, pode conter coisas legais.  A prop√≥sito, outro pequeno truque para os leitores, que foram pacientes o suficiente para ler at√© este local - o texto sob o c√≥digo de barras √© totalmente id√™ntico aos dados do c√≥digo de barras.  Foi feito para os operadores, que podem inserir manualmente o c√≥digo, se n√£o for leg√≠vel pelo scanner.  Portanto, √© f√°cil conhecer o conte√∫do do c√≥digo de barras - basta ler o texto abaixo. <br><br>  Obrigado pela leitura. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439768/">https://habr.com/ru/post/pt439768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439758/index.html">No meio do caminho "Juno"</a></li>
<li><a href="../pt439760/index.html">Os engenheiros "distorceram" a luz da fibra - uma nova tecnologia acelerar√° a transfer√™ncia de dados centenas de vezes</a></li>
<li><a href="../pt439762/index.html">No ensino superior, programadores e empregos de colarinho azul</a></li>
<li><a href="../pt439764/index.html">Frutas Corporativas</a></li>
<li><a href="../pt439766/index.html">Aumente isso! Aumento da resolu√ß√£o moderna</a></li>
<li><a href="../pt439772/index.html">Escrevendo testes de unidade no Swift para testar tarefas ass√≠ncronas</a></li>
<li><a href="../pt439774/index.html">Automatize o teste de seletores de redux no aplicativo</a></li>
<li><a href="../pt439776/index.html">Frontend Weekly Digest (4-10 de fevereiro de 2019)</a></li>
<li><a href="../pt439778/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 351 (4 a 10 de fevereiro de 2019)</a></li>
<li><a href="../pt439780/index.html">PHP Digest No. 149 (28 de janeiro a 11 de fevereiro de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>