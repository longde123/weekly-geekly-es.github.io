<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¢ üëÇüèº üîÅ Membuat Editor JaCarta üßíüèº üëç üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúAku hanya bisa mengatakan satu hal tentang Kerajaan Bayangan: ada kenyataan dan ada Bayangannya; inilah esensi dari segalanya. Di Dunia nyata, hanya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat Editor JaCarta</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441476/">  <i>‚ÄúAku hanya bisa mengatakan satu hal tentang Kerajaan Bayangan: ada kenyataan dan ada Bayangannya;</i>  <i>inilah esensi dari segalanya.</i>  <i>Di Dunia nyata, hanya ada Amber, kota sebenarnya di Bumi yang asli, tempat semua benda dikumpulkan.</i>  <i>Dan Kerajaan Bayangan hanyalah ketidakterbatasan yang tidak nyata.</i>  <i>Di sini Anda juga dapat menemukan segalanya - tetapi itu akan menjadi bayangan, refleksi realitas yang terdistorsi.</i>  <i>Kingdom of Shadows mengelilingi Amber dari semua sisi.</i>  <i>Dan selanjutnya, kekacauan memerintah.</i>  <i>Segalanya mungkin dalam perjalanan dari Amber ke Kingdom of Chaos. ‚Äù</i> <br>  Roger Zhelyazny.  Sembilan Pangeran Amber <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/kl/ek/hiklekzlry8wpcjn7hg3nroukac.jpeg"></div><br>  Semuanya dimulai dengan kebutuhan untuk bekerja dengan kunci yang sama pada etoken dari workstation yang berbeda, jauh secara signifikan (USB Over IP akan sedikit mahal untuk beberapa token) dan keinginan besar saya untuk membuka dunia yang tertutup ini.  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menemukan</a> work <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/post/276057</a> yang penulisnya sangat hormati, dalam proyek saya sebagian besar fungsi yang dibalik digunakan (kode terbuka).  Benar, ternyata, semua yang bekerja dengan etsdk.dll hanya berfungsi dengan ikan biru.  Oleh karena itu, untuk JaCarta, fungsi-fungsi baru harus ditulis ulang, dan bagian dari yang diedit. <br><br>  Sebagai hasil dari penelitian yang panjang, Editor JaCarta muncul - sebuah program yang menunjukkan dan memungkinkan Anda untuk mengedit entitas (begitulah objek sistem file token dipanggil dalam dokumentasi resmi, tampaknya mengisyaratkan ephemerality dan irreality mereka) pada token dari Aladdin, termasuk yang paling modern. <br><a name="habracut"></a><br>  Aplikasi serupa untuk Rutoken tersedia untuk umum sebagai bagian dari Rutoken SDK (Editor Rutoken), tetapi untuk Aladdin, setidaknya itu tidak ada dalam domain publik, meskipun sekitar 15 tahun yang lalu, dilihat dari dokumentasi yang ditemukan di Internet, itu adalah (ETEditor). <br><br>  Program ini ditulis dalam Autoit, diuji dengan EToken PRO Java 72 K, JaCarta LT, JaCarta Pro, JaCarta GOST-2. <br><br>  Program tidak akan berfungsi jika driver Rutoken diinstal pada komputer (diperlukan bahwa EToken atau Ja Carta memiliki pembaca nomor 0). <br><br>  Untuk alasan yang sama, hanya satu token yang harus terhubung untuk operasi yang benar. <br><br>  Script menggunakan panggilan sistem Windows $, dan hanya diuji dengan keluarga OS ini. <br><br>  <b>Agar berfungsi, Anda perlu menginstal "JaCarta Single Client"</b> (unduhan gratis dari situs web pabrikan), ketika Anda menginstalnya, versi etsdk.dll dan jcFS.dll yang jauh lebih baru yang berisi fungsi-fungsi Sistem File JaCarta (sangat mirip dengan yang ada di etsdk.dll, tetapi di jcFS ada lebih banyak fungsi yang tanpanya bekerja dengan beberapa jakarts modern, seperti GOST-2, tidak mungkin).  Ketika Unified Client diinstal, tentu saja tidak perlu mencari dan meletakkan dll ini di folder dengan program, jika tidak, dengan driver diinstal jenis token tertentu, dll ini harus berada di folder program. <br><br>  Semua fungsi jcFS dijelaskan secara rinci di situs web pabrikan, namun demikian, beberapa parameter fungsi ini harus dipilih secara eksperimental. <br><br>  Untuk mengakses direktori root token, Anda harus memanggil fungsi ETRootDirOpen atau JCRootDirOpen (yang sama, karena yang pertama di dll memanggil yang kedua, ini berlaku untuk hampir semua fungsi, tetapi ada beberapa pengecualian) dengan pengidentifikasi vendor sama dengan 0 (konstanta seperti 0xF007 akan memungkinkan lihat hanya direktori individual dari sebagian besar eToken lama yang menyimpan kunci bank yang dihasilkan menggunakan utilitas seperti PKIAdmin dan MessagePRO). <br><br>  Fitur penting berikutnya dari jakarta modern adalah kebutuhan untuk mengetahui id applet yang diinstal pada token, fungsi JCSelectApplet bertanggung jawab untuk ini. <br><br>  Token yang lebih lama biasanya memiliki applet default dan memanggil fungsi ini tidak secara khusus diperlukan, tetapi jakarts baru dan relatif baru tanpa mengetahui id applet tidak berfungsi lebih lanjut.  Memanggil semua fungsi yang menerima informasi dari token dalam kasus ini mengembalikan False.  Dalam proyek saya, dalam hal ini, kekuatan dua tahap diimplementasikan (token selalu merespon dua id, tetapi hanya satu dari mereka yang bekerja) id dan bekerja lebih lanjut dengan nilai yang diinginkan. <br><br>  Semua informasi ditampilkan di jendela output yang terletak di bawah pohon direktori. <br>  Kode PIN telah dimasukkan, informasi tentang upaya yang tersisa untuk memasukkannya juga ditampilkan. <br>  Isi direktori dan informasi singkat tentang file ditampilkan: nama, apakah file tersebut informasi pribadi adalah kode PIN pribadi - huruf p: (file bersifat publik setelahnya, unit bersifat pribadi) dan ukuran file dalam byte setelah "s:".  File dibuka dengan mengklik dua kali. <br><br>  Anda dapat melihat dan, jika perlu, menyalin konten file token dalam heksadesimal ke buffer atau menyimpan dalam bentuk biner ke komputer. <br><br>  Anda juga dapat mengubah konten file dan memilih "Simpan Perubahan" di menu (kode PIN harus dimasukkan terlebih dahulu, jika belum dimasukkan, pesan yang sesuai akan ditampilkan, dalam hal ini data yang diedit dapat dipilih dan disalin ke clipboard). <br><br>  Untuk menghapus file, pilih dan klik "Hapus", setelah itu jendela konfirmasi akan muncul. <br><br>  Sistem File JaCarta memiliki fitur menarik, yang hadir pada semua token yang saya uji.  Jika Anda membuat direktori atau beberapa direktori tanpa file pada token, selama sesi berikutnya bekerja dengan token, mereka akan menghilang, tampaknya dengan cara ini sistem file menangani penyimpanan memori token dan membersihkan semua sampah. <br><br>  Oleh karena itu, ketika Anda mengklik tombol Buat di program, rantai dibuat segera dari direktori atau dua direktori dan file.  Kedalaman bersarang direktori dalam program ini adalah dua, tidak termasuk root.  Di direktori root, Anda hanya bisa membuat direktori, tetapi bukan file. <br>  Sebelum membuat, mengedit, atau menghapus entitas, Anda harus memasukkan kode PIN. <br><br>  Catatan yang sangat penting tentang nama direktori! <br><br>  Pada token tempat konten dibuat oleh pabrikan, Anda tidak akan pernah melihat direktori dengan nama yang sama, di mana pun mereka berada.  Ini karena fitur sistem file. <br><br>  Misalkan kita memiliki entitas berikut pada token: // <u>0001</u> / A001 / 0008 (yaitu, folder 0001 ada di direktori root, folder A001 di dalamnya, dan file 0008 di dalamnya) dan kami membuat entitas baru di token: // CC00 / <u>0001/1010</u> .  Saat mengakses file 1010, pencarian untuk direktori 0001 akan dimulai, yang terletak di root dan akan ditemukan pertama kali, tetapi tidak ada file seperti itu di dalamnya.  Akibatnya, fungsi mengembalikan False dan entitas menjadi hilang, Anda tidak dapat mengakses dan menghapusnya.  Hanya inisialisasi token yang akan membantu. <br><br>  Dari catatan khusus adalah EToken PRO dan JA Carta Pro, yang hanya berbeda dalam penampilan, mereka memiliki file sistem di direktori root (mereka ditampilkan di layar), di mana salah satu hash dari kode pin disimpan, mengubah file-file ini mengarah pada kenyataan bahwa otorisasi menjadi tidak mungkin (kode pin menjadi salah) dan setelah itu hanya inisialisasi yang akan membantu. <br><br>  Mengenai kunci pribadi, dimungkinkan untuk menetapkan yang berikut: jika sebuah wadah yang dibuat oleh penyedia kriptografi pihak ketiga, seperti CryptoPro, disimpan pada token, maka semua kontennya, termasuk kunci pribadi, akan tersedia, itu hanya flash drive dengan kode PIN (seperti yang ditunjukkan pada gambar).  Jika pasangan kunci dibuat di papan token menggunakan PKCS11, maka hanya sertifikat dan kunci publik yang akan tersedia. <br><br>  Karena ini adalah program eksperimental, saya tidak merekomendasikan menggunakannya dengan token yang berisi kunci EDS yang valid, semua operasi dilakukan pada ketakutan dan risiko eksperimen.  Ini terutama benar untuk penciptaan entitas baru, dalam beberapa kasus hasilnya sulit untuk diprediksi. <br><br>  Semua informasi untuk membuat program diperoleh dari sumber terbuka, tujuan pembuatannya adalah murni penelitian. <br><br>  Naskah itu sendiri <br><br><div class="spoiler">  <b class="spoiler_title">JACartaEditor.au3</b> <div class="spoiler_text"><pre><code class="vbscript hljs">#include &lt;GUIConstantsEx.au3&gt; #include &lt;WindowsConstants.au3&gt; #include &lt;EditConstants.au3&gt; #include &lt;TreeViewConstants.au3&gt; #include &lt;GuiTreeView.au3&gt; #include &lt;GuiMenu.au3&gt; #include &lt;MsgBoxConstants.au3&gt; #include &lt;StaticConstants.au3&gt; #include &lt;GuiButton.au3&gt; #NoTrayIcon ;  jcFS.dll <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> $ETSdkDll=DllOpen(<span class="hljs-comment"><span class="hljs-comment">'jcFS.dll') Func ETTokenLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenUnLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenUnLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETReadersEnumOpen() Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumOpen', _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETReadersEnumNext($EnumId) Local $Reader=DllStructCreate('CHAR name[260]; BYTE etoken;') Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Reader) _ ) Local $Result[2]=[ DllStructGetData($reader,'name'), _ DllStructGetData($reader,'etoken')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETReadersEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETReadersEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenBind($ReaderName) Local $In=DllStructCreate('BYTE['&amp;(StringLen($ReaderName)+1)&amp;']') Local $Out=DllStructCreate('DWORD') DllStructSetData($In,1,$ReaderName) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenBind', _ 'PTR',DllStructGetPtr($Out), _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETTokenRebind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenRebind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenUnbind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenUnbind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLogin($BindId,$Pin='') Local $In=DllStructCreate('BYTE['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLogin', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenPinChange($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenPinChange', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLogout($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLogout', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETRootDirOpen($BindId,$Dir=0xF007) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETRootDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$BindId, _ 'DWORD',$Dir _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirOpen($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirCreate($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId, _ 'DWORD',0 _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirGetInfo($DirId) Local $Out=DllStructCreate('WORD wDirName; WORD wSize') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirGetInfo', _ 'DWORD',$DirId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[2]=[ DllStructGetData($Out,'wDirName'), _ DllStructGetData($Out,'wSize')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETDirClose($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirClose', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETDirDelete($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirDelete', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETDirEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETDirEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETDirEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileOpen($File,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileCreate($File,$DirId,$Size,$Private=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File, _ 'DWORD',$Size, _ 'DWORD',$Private _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileGetInfo($FileId) Local $Out=DllStructCreate('WORD name;WORD private;WORD;WORD size') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileGetInfo', _ 'DWORD',$FileId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[3]=[ DllStructGetData($Out,'name'), _ DllStructGetData($Out,'private'), _ DllStructGetData($Out,'size')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func ETFileRead($FileId) Local $FileInfo=ETFileGetInfo($FileId) If @error Then Return SetError(@error,0,False) Local $Out=DllStructCreate('BYTE ['&amp;$FileInfo[2]&amp;']') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileRead', _ 'DWORD',$FileId, _ 'DWORD',0, _ 'DWORD',0xFFFF, _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$FileInfo[2] _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFileWrite($FileId,$Data,$Pos=0) $Data=Binary($Data) Local $DataSize=BinaryLen($Data) Local $In=DllStructCreate('BYTE['&amp;$DataSize&amp;']') DllStructSetData($In,1,$Data) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileWrite', _ 'DWORD',$FileId, _ 'DWORD',$Pos, _ 'PTR',DllStructGetPtr($In), _ 'DWORD',$DataSize _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileClose($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileClose', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFileDelete($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFileDelete', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETFilesEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFilesEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETFilesEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','ETFilesEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func ETTokenLabelGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','ETTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func ETTokenIDGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','ETTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func ETTokenMaxPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenMaxPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETTokenMinPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','ETTokenMinPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func ETSelectApplet($BindId, $Applet) Local $In=DllStructCreate('DWORD') DllStructSetData($In,1,$Applet) Local $CallRes=DllCall($ETSdkDll,'WORD','ETSelectApplet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Applet) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCSelectApplet($BindId, $Applet) Local $In=DllStructCreate('WORD') DllStructSetData($In,1,$Applet) Local $CallRes=DllCall($ETSdkDll,'WORD','JCSelectApplet', _ 'DWORD',$BindId, _ 'WORD',$Applet _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCReadersEnumOpen() Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumOpen', _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCReadersEnumNext($EnumId) Local $Reader=DllStructCreate('CHAR name[260]; BYTE etoken;') Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Reader) _ ) Local $Result[2]=[ DllStructGetData($reader,'name'), _ DllStructGetData($reader,'etoken')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func JCReadersEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCReadersEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenBind($ReaderName) Local $In=DllStructCreate('CHAR['&amp;(StringLen($ReaderName)+1)&amp;']') Local $Out=DllStructCreate('DWORD') DllStructSetData($In,1,$ReaderName) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenBind', _ 'PTR',DllStructGetPtr($Out), _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenRebind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenRebind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenUnbind($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenUnbind', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLogin($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLogin', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenPinChange($BindId,$Pin) Local $In=DllStructCreate('CHAR['&amp;(StringLen($Pin)+1)&amp;']') DllStructSetData($In,1,$Pin) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenPinChange', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($In) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLogout($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLogout', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCRootDirOpen($BindId,$Dir=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCRootDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$BindId, _ 'WORD',$Dir _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirOpen($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirCreate($Dir,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$Dir, _ 'DWORD',$DirId, _ 'DWORD',0 _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirGetInfo($DirId) Local $Out=DllStructCreate('BYTE[8]') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirGetInfo', _ 'DWORD',$DirId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirClose($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirClose', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCDirDelete($DirId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirDelete', _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCDirEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCDirEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCDirEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileOpen($File,$DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileCreate($File,$DirId,$Size,$Private=0) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileCreate', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId, _ 'DWORD',$File, _ 'DWORD',$Size, _ 'DWORD',$Private _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileGetInfo($FileId) Local $Out=DllStructCreate('WORD name;WORD private;WORD;WORD size') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileGetInfo', _ 'DWORD',$FileId, _ 'PTR',DllStructGetPtr($Out) _ ) Local $Result[3]=[ DllStructGetData($Out,'name'), _ DllStructGetData($Out,'private'), _ DllStructGetData($Out,'size')] Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :$Result EndFunc Func JCFileRead($FileId) Local $FileInfo=JCFileGetInfo($FileId) If @error Then Return SetError(@error,0,False) Local $Out=DllStructCreate('BYTE ['&amp;$FileInfo[2]&amp;']') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileRead', _ 'DWORD',$FileId, _ 'DWORD',0, _ 'DWORD',0xFFFF, _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$FileInfo[2] _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFileWrite($FileId,$Data,$Pos=0) $Data=Binary($Data) Local $DataSize=BinaryLen($Data) Local $In=DllStructCreate('BYTE['&amp;$DataSize&amp;']') DllStructSetData($In,1,$Data) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileWrite', _ 'DWORD',$FileId, _ 'DWORD',$Pos, _ 'PTR',DllStructGetPtr($In), _ 'DWORD',$DataSize _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileClose($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileClose', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFileDelete($FileId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFileDelete', _ 'DWORD',$FileId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCFilesEnumOpen($DirId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumOpen', _ 'PTR',DllStructGetPtr($Out), _ 'DWORD',$DirId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFilesEnumNext($EnumId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumNext', _ 'DWORD',$EnumId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCFilesEnumClose($EnumId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCFilesEnumClose', _ 'DWORD',$EnumId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLabelGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLabelGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func JCTokenIDGet($BindId) Local $Out1=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',0, _ 'PTR',DllStructGetPtr($Out1) _ ) If $CallRes[0] Then Return SetError($CallRes[0],0,False) Local $Out2=DllStructCreate('CHAR['&amp;DllStructGetData($Out1,1)&amp;']') $CallRes=DllCall($ETSdkDll,'WORD','JCTokenIDGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out2), _ 'PTR',DllStructGetPtr($Out1) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out2,1) EndFunc Func JCTokenMaxPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenMaxPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenMinPinGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenMinPinGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc Func JCTokenUnLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenUnLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenLock($BindId) Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenLock', _ 'DWORD',$BindId _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :True EndFunc Func JCTokenPinAttemptsGet($BindId) Local $Out=DllStructCreate('DWORD') Local $CallRes=DllCall($ETSdkDll,'WORD','JCTokenPinAttemptsGet', _ 'DWORD',$BindId, _ 'PTR',DllStructGetPtr($Out) _ ) Return $CallRes[0] _ ?SetError($CallRes[0],0,False) _ :DllStructGetData($Out,1) EndFunc ;  Opt("GUIOnEventMode", 1) Dim $BindId, $filelog, $Result, $DirIdRoot=False, $Edit, $msg, $Fileinfo, $treeview, $generalitem, $displayitem, $diritem, $Edit, $SrcSubId, $Output, $pinbutton, $hPinWin, $PinEdit, $pinokbutton, $pincancelbutton, $Pin, $Edit1, $Reader, $Applet, $AppletID, $text, $CreateDirWin Global $Dir1, $Dir2 Dim $hParentWin, $hChildWin, $sItemText, $folderbutton, $filebutton, $deletebutton, $CreateFileWin, $FileEdit, $fileokbutton, $filecancelbutton, $publicbutton, $privatebutton, $sizefile Dim $hFile, $hMain Global Enum $idSave= 1000, $Save Dim $Appname = 'JaCarta Editor' ;  applet ID  Func Applet() GUICtrlSetData($Output, '  applet ID... '&amp;@CRLF,1) Local $Result, $AppletTemp= 0 For $Applet = 0 To 65535 Step 1 $Result = 0 $Result=JCSelectApplet($BindId,$Applet) ; 0x2001 PROJAVA  E-token, 0x1002 PRO, 0x1001 R2, 0x2202 GOST, 0x2205 DATASTORE, 0x2206 -2, 0x2201, 0x2204 ( JaCarta) If $Result = True Then $AppletTemp=$Applet $AppletID=$Applet ExitLoop EndIf Next Local $Id=ETTokenLabelGet($BindId) if $Id= False Then For $Applet=$AppletTemp+1 To 65535 Step 1 $Result=0 $Result=JCSelectApplet($BindId,$Applet) If $Result = True Then ExitLoop EndIf Next EndIf JCSelectApplet($BindId,$Applet) GUICtrlSetData($Output, 'Select applet 0x'&amp;hex($Applet,4)&amp;@CRLF,1) $AppletID=$Applet EndFunc ;      Func PrintDir($Id,$Prefix) Local $EnumId=ETDirEnumOpen($Id) While 1 Local $dir=ETDirEnumNext($EnumId) If @error Then ExitLoop Local $DirId=ETDirOpen($dir,$Id) Local $Dirinfo $Dirinfo=ETDirGetInfo($DirId) Local $Dirtext='(dir)'&amp;hex($dir,4) $diritem = _GUICtrlTreeView_AddChild($treeview,$Prefix, $Dirtext) PrintDir($DirId,$diritem) ETDirClose($DirId) WEnd ETDirEnumClose($EnumId) $EnumId=ETFilesEnumOpen($Id) While 1 Local $file=ETFilesEnumNext($EnumId) If @error Then ExitLoop Local $FileId=ETFileOpen($file,$Id) $Fileinfo=ETFileGetInfo($FileId) Local $filetext='(file)'&amp;hex($file,5)&amp;' '&amp;'p: '&amp;$Fileinfo[1]&amp;' s: '&amp;$Fileinfo[2]&amp;@CRLF _GUICtrlTreeView_AddChild($treeview,$Prefix,$filetext) WEnd ETFilesEnumClose($EnumId) EndFunc ;         Func List() GUICtrlSetData($Output, '') Local $text Local $EnumId=ETReadersEnumOpen() GUICtrlSetData($Output, '   :'&amp;@CRLF,1) While 1 $Reader=ETReadersEnumNext($EnumId) If @error Then ExitLoop GUICtrlSetData($Output, $Reader[0]&amp;@CRLF,1) WEnd ETReadersEnumClose($EnumId) Local $EnumId=ETReadersEnumOpen() $Reader=ETReadersEnumNext($EnumId) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) GUICtrlSetData($Output, '  '&amp;$Reader[0]&amp;@CRLF,1) ;    ID ,    AppletID $Result=ETTokenIDGet($BindId) if $Result= False Then if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) Else Applet() EndIf EndIf $Result=ETTokenIDGet($BindId) $text=$Reader[0]&amp;' ID '&amp;$Result $generalitem = _GUICtrlTreeView_AddChild($treeview,0,$text) $Result=ETTokenLabelGet($BindId) GUICtrlSetData($Output, 'Label: '&amp;$Result&amp;@CRLF,1) $DirIdRoot=ETRootDirOpen($BindId,0) ;0xF007   0x0001    $Result=JCTokenPinAttemptsGet($BindId) ;       If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) Else GUICtrlSetData($Output, 'Login OK'&amp;@CRLF,1) EndIf EndIf $Result=JCTokenPinAttemptsGet($BindId) GUICtrlSetData($Output, '   PIN : '&amp;$Result&amp;@CRLF,1) PrintDir($DirIdRoot,0) ETTokenUnbind($BindId) ETReadersEnumClose($EnumId) EndFunc ;     Func onClose() GUISetState(@SW_HIDE, $hPinWin) GUISetState(@SW_HIDE, $hChildWin) GUISetState(@SW_HIDE, $CreateFileWin) if @GUI_WinHandle=$hParentWin Then Exit EndIf EndFunc ;     Func onPin() GUISetState(@SW_SHOW, $hPinWin ) EndFunc ;       Func onPinOK() $Pin=GUICtrlRead($PinEdit) GUISetState(@SW_HIDE, $hPinWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndFunc ;    Func onPinCancel() GUISetState(@SW_HIDE, $hPinWin) EndFunc ;  Func Delete() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $Del = _GUICtrlTreeView_GetText($treeview, $hItem) if _GUICtrlTreeView_GetChildren($treeview, $hItem)=False Then $Del=StringTrimLeft ( $Del, 6 ) Local $p=0 $p=StringInStr ($Del,"p:") $Del=StringMid ( $Del, 1, $p-2 ) if MsgBox(4 + 32, $Appname, ' '&amp; $Del &amp;' ?') = 6 Then Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $Dir=StringTrimLeft ( $Dir, 5 ) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result) EndIf EndIf Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir) Local $DELFile =JCFileOpen(Dec ($Del), $HDir) JCFileDelete($DELFile ) ETDirClose($HDir) ETTokenUnbind($BindId) _GUICtrlTreeView_DeleteAll ($treeview) List() EndIf Else MsgBox(0x10,$Appname,'           ' ) EndIf EndIf EndFunc ;     Func onFileCreate() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $FileText = 0, $Dir1=0, $Dir2=0 $FileText = _GUICtrlTreeView_GetText($treeview, $hItem) ;      if StringLen($FileText) &gt;20 Then GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '//',0) Else $Dir1=StringTrimLeft ( $FileText, 5 ) Local $ParentID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $ParentDir= _GUICtrlTreeView_GetText($treeview, $ParentID) if StringInStr ($ParentDir,"Dir")=0 Then $ParentDir='' GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '//'&amp;$Dir1&amp;'/',0) Else $Dir2=StringTrimLeft ( $ParentDir, 5 ) $Dir2='/'&amp;$Dir2 GUICtrlSetData($FileEdit, '') GUICtrlSetData($FileEdit, '/'&amp;$Dir2&amp;'/'&amp;$Dir1&amp;'/',0) EndIf EndIf GUISetState(@SW_SHOW, $CreateFileWin) EndIf EndFunc ;   Func onFileCancel() GUISetState(@SW_HIDE, $CreateFileWin) EndFunc ;   Func onFileOK() Local $filename=GUICtrlRead($FileEdit) Local $isPrivate=_GUICtrlButton_GetCheck($privatebutton) Local $fileSize=GUICtrlRead($sizefile) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) EndIf EndIf Local $rootdir=ETRootDirOpen($BindId,0) Local $text=StringTrimLeft ( $filename, 2 ) Local $text1=StringLeft($text, 4) $dir1=JCDirOpen(Dec ($text1), $rootdir) if $dir1=false Then $dir1= ETDirCreate(Dec ($text1), $rootdir) EndIf if StringLen($text) &gt;12 Then $text=StringTrimLeft ( $text, 5 ) $text1=StringLeft($text, 4) $dir2=JCDirOpen(Dec ($text1), $dir1) if $dir2=false Then $dir2= ETDirCreate(Dec ($text1), $dir1) EndIf $text=StringTrimLeft ( $text, 5 ) Local $DstFile=JCFileCreate(Dec ($text),$Dir2,$fileSize,$isPrivate) JCFileClose($DstFile) Else $text=StringTrimLeft ( $text, 5 ) Local $DstFile=JCFileCreate(Dec ($text),$Dir1,$fileSize,$isPrivate) JCFileClose($DstFile) EndIf ETTokenUnbind($BindId) GUISetState(@SW_HIDE, $CreateFileWin) GUISetState(@SW_SHOW, $hParentWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndFunc ;     Func SaveFile() If $Pin=0 Then MsgBox(0x10,$Appname,'      ' ) Else Local $filebody=GUICtrlRead($Edit1) Local $hItem = _GUICtrlTreeView_GetSelection($treeview) Local $FileEd = _GUICtrlTreeView_GetText($treeview, $hItem) $FileEd=StringTrimLeft ( $FileEd, 6 ) Local $p=0 $p=StringInStr ($FileEd,"p:") $FileEd=StringMid ( $FileEd, 1, $p-2 ) Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $Dir=StringTrimLeft ( $Dir, 5 ) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result) EndIf EndIf Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir) Local $File=JCFileOpen(Dec ($FileEd),$HDir) Local $Data =Binary('0x' &amp; $filebody) JCFileWrite($File, $Data) JCFileClose($File) ETDirClose($HDir) ETTokenUnbind($BindId) GUISetState(@SW_HIDE, $hChildWin) _GUICtrlTreeView_DeleteAll ($treeview) List() EndIf EndFunc ;       Func SaveFileAs() Local $varFile = 0 $varFile = FileSaveDialog( " ", @MyDocumentsDir &amp; "\", "  (*.bin)", 16,'',$hParentWin) If StringLen($varFile) &gt; 3 Then Local $filedest $filedest = FileOpen($varFile, 17) ; Check if file open If $filedest = -1 Then MsgBox(0, "Error", "Unable to open file.") Exit EndIf FileWrite($filedest, $text) FileClose($filedest) EndIf EndFunc ;        Func WM_COMMAND($hWnd, $iMsg, $wParam, $lParam) #forceref $hWnd, $iMsg, $lParam Switch $wParam Case $Save SaveFile() Case $idSave SaveFileAs() EndSwitch EndFunc ;==&gt;WM_COMMAND ;   Func GUIInit() $hParentWin= GUICreate($Appname, 560, 400) GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') ;   $treeview = GUICtrlCreateTreeView(6, 6, 400, 300, BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS), $WS_EX_CLIENTEDGE) $Output = GUICtrlCreateEdit("" , 6, 320, 400, 70, $ES_AUTOVSCROLL + $WS_VSCROLL + $ES_NOHIDESEL + $ES_WANTRETURN) $pinbutton = GUICtrlCreateButton("&amp; PIN ", 430, 20, 100, 50) $filebutton = GUICtrlCreateButton("&amp;", 430, 80, 100, 50) $deletebutton = GUICtrlCreateButton("&amp;", 430, 140, 100, 50) ;     $hPinWin = GUICreate(' PIN ', 200, 200, -1, -1, $WS_SYSMENU, -1, $hParentWin) $PinEdit = GUICtrlCreateInput ("" , 50, 40, 100, 25, $ES_PASSWORD + $ES_NOHIDESEL + $ES_WANTRETURN) $pinokbutton = GUICtrlCreateButton("&amp;OK", 20, 100, 60, 40) $pincancelbutton = GUICtrlCreateButton("&amp;", 110, 100, 60, 40) ;   $CreateFileWin = GUICreate('   ', 340, 350, -1, -1, $WS_SYSMENU, -1, $hParentWin) $FileEdit = GUICtrlCreateInput ("" , 50, 70, 230, 25) $fileokbutton= GUICtrlCreateButton("&amp;OK", 70, 240, 60, 40) $filecancelbutton = GUICtrlCreateButton("&amp;", 210, 240, 60, 40) $publicbutton= _GUICtrlButton_Create($CreateFileWin, "Public", 100, 120, 50, 30, $BS_AUTORADIOBUTTON, 0) $privatebutton=_GUICtrlButton_Create($CreateFileWin, "Private", 160, 120, 50, 30, $BS_AUTORADIOBUTTON, 0) _GUICtrlButton_SetCheck($publicbutton, $BST_CHECKED) Local $label=GUICtrlCreateLabel('      hex  1001 ', 70, 20, 170, 40, $SS_CENTER) $sizefile = GUICtrlCreateInput ("10" , 220, 175, 50, 20) Local $label1=GUICtrlCreateLabel('    ', 20, 180, 200, 60, $SS_CENTER) ;   $hChildWin = GUICreate($sItemText, 300, 230, -1, -1, $WS_SYSMENU, -1, $hParentWin) $Edit1 = GUICtrlCreateEdit("", 10, 10, 240, 160, $ES_AUTOVSCROLL + $WS_VSCROLL + $ES_NOHIDESEL + $ES_WANTRETURN) ;   ""     $hFile = _GUICtrlMenu_CreateMenu () _GUICtrlMenu_InsertMenuItem ($hFile, 0, ' ...', $idSave) _GUICtrlMenu_InsertMenuItem ($hFile, 1, ' ', $Save) $hMain = _GUICtrlMenu_CreateMenu () _GUICtrlMenu_InsertMenuItem ($hMain, 0, '', 0, $hFile) _GUICtrlMenu_SetMenu ($hChildWin, $hMain) ;  GUICtrlSetOnEvent($filebutton,'onFileCreate') GUICtrlSetOnEvent($deletebutton,'Delete') GUICtrlSetOnEvent($pinbutton,'onPin') GUICtrlSetOnEvent($pinokbutton,'onPinOK') GUICtrlSetOnEvent($pincancelbutton,'onPinCancel') GUICtrlSetOnEvent($fileokbutton,'onFileOK') GUICtrlSetOnEvent($filecancelbutton,'onFileCancel') GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') GUISetState(@SW_SHOW, $hParentWin) GUIRegisterMsg(0x0111, "WM_COMMAND") EndFunc ;    GUIInit() List() ;          GUIRegisterMsg($WM_NOTIFY, "MY_WM_NOTIFY") Global $iDoubleClick = 0 Func MY_WM_NOTIFY($hWnd, $Msg, $wParam, $lParam) Local $tagNMHDR, $vEvent Switch $wParam Case $treeview $tagNMHDR = DllStructCreate("int;int;int", $lParam) If @error Then Return $vEvent = DllStructGetData($tagNMHDR, 3) If $vEvent = $NM_DBLCLK Then $iDoubleClick = 1 EndIf EndSwitch $tagNMHDR = 0 EndFunc ;==&gt;MY_WM_NOTIFY ;  ,      Func GetDir( $Id,$Dir_Id) Local $DirId=0 Local $DirResult=0 Local $EnumId=ETDirEnumOpen($Id) While 1 Local $dir=ETDirEnumNext($EnumId) If @error Then ExitLoop $DirId=ETDirOpen($dir,$Id) if hex($dir,4)=$Dir_Id Then $DirResult=$DirId ExitLoop EndIf $DirResult=GetDir( $DirId, $Dir_Id) ETDirClose($DirId) WEnd ETDirEnumClose($EnumId) Return $DirResult EndFunc ;            Func ListFile($file, $Dir_Id) $BindId=ETTokenBind($Reader[0]) $Result=JCTokenLock($BindId) if $AppletID&lt;&gt;0 Then JCSelectApplet($BindId,$AppletID) EndIf If $Pin &lt;&gt; 0 Then $Result=JCTokenLogin($BindId,$Pin) If $Result=False Then $Result=JCTokenPinAttemptsGet($BindId) MsgBox(0x10,$Appname,' PIN '&amp;@CRLF&amp;'   PIN : '&amp;$Result ) EndIf EndIf if StringLen($Dir_Id)&gt;10 Then $HDir=ETRootDirOpen($BindId,0) Else Local $HDir=GetDir(ETRootDirOpen($BindId,0), $Dir_Id) EndIf $SrcSubId=JCFileOpen(Dec ($file), $HDir) $text=JCFileRead($SrcSubId) GUICtrlSetData($Edit1, hex($text)) JCFileClose($SrcSubId) ETDirClose($HDir) ETTokenUnbind($BindId) EndFunc ;          While 1 if $iDoubleClick Then Local $hItem = _GUICtrlTreeView_GetSelection($treeview) if _GUICtrlTreeView_GetChildren($treeview, $hItem)=False Then Local $hItem = _GUICtrlTreeView_GetSelection($treeview) $sItemText = _GUICtrlTreeView_GetText($treeview, $hItem) if StringInStr ($sItemText,"Dir")=0 Then Local $text1=0 $text1=StringTrimLeft ( $sItemText, 6 ) Local $p=0 $p=StringInStr ($text1,"p:") $sItemText=0 $sItemText=StringMid ( $text1, 1, $p-2 ) GUISetState(@SW_SHOW, $hChildWin) GUISetOnEvent($GUI_EVENT_CLOSE,'onClose') Local $DirID=_GUICtrlTreeView_GetParentHandle($treeview, $hItem) Local $Dir= _GUICtrlTreeView_GetText($treeview, $DirID) $text1=StringTrimLeft ( $Dir, 5 ) $Dir=$text1 ListFile($sItemText, $Dir) EndIf EndIf $iDoubleClick = 0 EndIf WEnd</span></span></code> </pre> <br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber informasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eToken Developer's Guide Versi 3.50 (Desember 2003)</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441476/">https://habr.com/ru/post/id441476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441456/index.html">Enam cerita bagaimana kode ditulis ulang dari awal</a></li>
<li><a href="../id441458/index.html">Senjata dan manipulator mekanik - beri tahu Anda apa yang dilakukan laboratorium robotika Universitas ITMO</a></li>
<li><a href="../id441460/index.html">Dan bagaimana Anda melihat pendidikan TI?</a></li>
<li><a href="../id441468/index.html">Facebook akan menutup spyware Onavo VPN-nya</a></li>
<li><a href="../id441472/index.html">Jaringan saraf diajarkan untuk menggambar detail yang hilang di foto orang</a></li>
<li><a href="../id441478/index.html">Game interaktif di XSLT</a></li>
<li><a href="../id441482/index.html">Kronologi baru Iyon Pasifik</a></li>
<li><a href="../id441484/index.html">Karyawan Microsoft menentang penggunaan HoloLens di ketentaraan, karena perang berubah menjadi permainan komputer</a></li>
<li><a href="../id441490/index.html">Apa yang harus dicari ketika memilih pembaca - sistem operasi dan perangkat keras</a></li>
<li><a href="../id441496/index.html">Sound on the wire: sejarah telegraf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>