<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏾 👩🏼‍🍳 🕟 Amazon Cloud Services et analyse de portefeuille d'investissement 🗺️ 👃🏽 🐧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, il y a eu une forte volatilité sur les marchés boursiers lorsque, par exemple, un papier stable d'une société bien connue peut perdre plusi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Amazon Cloud Services et analyse de portefeuille d'investissement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/">  Récemment, il y a eu une forte volatilité sur les marchés boursiers lorsque, par exemple, un papier stable d'une société bien connue peut perdre plusieurs pour cent à la fois en raison de sanctions contre sa direction ou vice versa s'envoler dans le ciel sur un rapport positif et les attentes des investisseurs concernant les dividendes extra-profit. <br><br>  Comment déterminer si la propriété d'un titre donné a généré des revenus ou seulement des pertes et des déceptions? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(Source)</a> <br><br>  Dans cet article, je vais vous expliquer comment identifier et visualiser le résultat financier ajusté des titres. <br><br>  En utilisant l'exemple du reporting client Opening Broker, nous considérerons l'analyse et la consolidation des rapports de courtage pour le marché boursier, en construisant l'architecture d'un système de reporting cloud avec une analyse simple et pratique ultérieure dans AWS Quicksight. <br><a name="habracut"></a><br><h2>  Description de la tâche </h2><br>  De nombreuses formations et leçons de formation nous parlent de la nécessité d'un journal du commerçant, où tous les paramètres de transaction sont enregistrés pour une analyse plus approfondie et résumer les résultats de la stratégie de trading.  Je suis d'accord que cette approche du travail sur la Bourse vous permet de discipliner un commerçant, d'augmenter sa conscience, mais cela peut aussi vous fatiguer d'un processus fastidieux. <br><br>  J'avoue qu'au début, j'ai essayé soigneusement de suivre les conseils de la journalisation, écrit méticuleusement chaque transaction avec ses paramètres dans un tableau Excel, construit des rapports, des graphiques récapitulatifs, planifié les transactions futures, mais ... J'en ai vite été fatigué. <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi tenir un journal d'un commerçant manuellement n'est pas pratique?</b> <div class="spoiler_text"><ul><li>  le remplissage manuel du journal (même en utilisant une automatisation partielle, sous forme de déchargement des transactions quotidiennes du terminal de trading) se fatigue rapidement; </li><li>  il y a un risque élevé d'erreur ou de faute de frappe avec la saisie manuelle; </li><li>  il peut arriver qu'un trader actif devienne un investisseur passif et il revient de moins en moins dans ce magazine, puis l'oublie complètement (mon cas);  enfin et enfin </li><li>  nous pouvons programmer, pourquoi ne pas en profiter et automatiser l'ensemble du processus?  Alors allons-y! </li></ul></div></div><br>  Souvent, les sociétés de courtage sont des organisations de haute technologie qui fournissent à leurs clients des analyses d'assez bonne qualité sur presque toutes les questions d'intérêt.  Il est juste de dire que ces rapports s'améliorent de plus en plus avec chaque mise à jour, mais même les plus avancés d'entre eux peuvent ne pas avoir la personnalisation et la consolidation que les clients exigeants et curieux veulent voir. <br><br>  Par exemple, Opening Broker vous permet de recevoir des rapports de courtage au format XML dans votre compte personnel, mais si vous avez un IIA et un compte de courtage régulier à la Bourse de Moscou (MOEX), ce seront deux rapports différents, et si vous avez un autre compte sur St. Petersburg Stock Exchange (SPB), puis les deux premiers en ajouteront un de plus. <br><br>  Au total, pour obtenir un journal consolidé de l'investisseur, il faudra traiter trois fichiers au format XML. <br><br>  Les rapports susmentionnés sur le MOEX et le SPB diffèrent légèrement dans leurs formats, qui devront être pris en compte dans le processus de mise en œuvre de la cartographie des données. <br><br><h2>  Architecture du système en cours de développement </h2><br>  Le schéma ci-dessous montre le modèle d'architecture du système en cours de développement: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Implémentation de l'analyseur </h2><br>  Nous recevrons des rapports sur les trois comptes dans le compte personnel pour la période maximale possible (peut être divisé en plusieurs rapports pour chaque année), les enregistrer au format XML et les mettre dans un dossier.  Comme données de test pour l'étude, nous utiliserons un portefeuille de clients fictifs, mais avec des paramètres aussi proches que possible des réalités du marché. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Supposons que l'investisseur M. X considéré ait un petit portefeuille de cinq titres: <br><br><ol><li>  Le rapport sur l'échange SPB comprendra deux articles: Apple et Microsoft; </li><li>  Le rapport sur la bourse MOEX (courtage) contient un document: FGC UES; </li><li>  Le rapport sur le MOEX Exchange (IIS) contient deux titres: MMK et OFZ 24019; </li></ol><br>  Selon nos cinq titres, il peut y avoir des transactions sur l'achat / la vente, le paiement de dividendes et d'un coupon, le prix peut changer, etc.  Nous voulons voir la situation actuelle, à savoir: le résultat financier, en tenant compte de tous les paiements, transactions et valeur marchande actuelle. <br><br>  Et ici Python entre en jeu, nous lisons les informations de tous les rapports dans un tableau: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  Pour l'analyse, les rapports nécessitent plusieurs entités, à savoir: <br><br><ul><li>  Positions de titres dans un portefeuille; </li><li>  Accords conclus; </li><li>  Opérations non commerciales et autres mouvements de compte; </li><li>  Prix ​​moyens des positions ouvertes </li></ul></blockquote>  Afin de préparer l'échantillon, nous utiliserons quatre dictionnaires pour décrire les ensembles ci-dessus. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  Quelques mots sur la signification de ces dictionnaires. <br><br><div class="spoiler">  <b class="spoiler_title">Dictionnaire Dict_stocks</b> <div class="spoiler_text">  Le dictionnaire dict_stocks est nécessaire pour stocker des informations générales sur le portefeuille: <br><br><ul><li>  Nom du papier (nom_stock); </li><li>  Nom du compte (SPB, MOEX BROK, MOEX IIS) (compte); </li><li>  Devise utilisée pour les règlements sur ce papier (devise); </li><li>  Valeur actuelle (au moment de la génération du rapport dans le courtier d'ouverture de compte personnel) (current_cost).  Ici, je tiens à noter que pour les clients trop exigeants, il est possible d'apporter des améliorations supplémentaires à l'avenir et d'utiliser la réception dynamique d'un devis de sécurité à partir d'un terminal de trading ou du site Web de la bourse correspondante; </li><li>  La valeur actuelle de la position de sécurité au moment où le rapport a été généré (current_cost_rub) <br>  De manière similaire à l'article ci-dessus, vous pouvez également obtenir ici le taux de la Banque centrale au moment actuel ou le taux de change, comme vous le souhaitez. </li><li>  Solde courant des titres (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dictionnaire dict_deals</b> <div class="spoiler_text">  Le dictionnaire dict_deals est nécessaire pour stocker les informations suivantes sur les transactions terminées: <br><br><ul><li>  Nom du papier (nom_stock); </li><li>  Nom du compte (SPB, MOEX BROK, MOEX IIS) (compte); </li><li>  Date de transaction, c.-à-d.  T0 (date_oper); </li><li>  Type d'opération (type_oper); </li><li>  Le volume de titres participant à la transaction (quantité); </li><li>  Le prix auquel la transaction a été exécutée (prix); </li><li>  Devise dans laquelle la transaction a été effectuée (devise); </li><li>  Commission de courtage pour une transaction (courtage); </li><li>  Le résultat financier de la transaction (résultat) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dictionnaire Dict_flows</b> <div class="spoiler_text">  Le dictionnaire dict_flows reflète le mouvement des fonds sur le compte client et est utilisé pour stocker les informations suivantes: <br><br><ul><li>  Nom du papier (nom_stock); </li><li>  Nom du compte (SPB, MOEX BROK, MOEX IIS) (compte); </li><li>  Date de transaction, c.-à-d.  T0 (date_oper); </li><li>  Type d'opération (type_oper).  Il peut prendre plusieurs valeurs: div, NKD, tax; </li><li>  Devise dans laquelle la transaction a été effectuée (devise); </li><li>  Le résultat financier de l'opération (résultat) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dictionnaire dict_avg_price</b> <div class="spoiler_text">  Le dictionnaire dict_avg_price est nécessaire pour les informations comptables au prix d'achat moyen pour chaque papier: <br><br><ul><li>  Nom du papier (nom_stock); </li><li>  Nom du compte (SPB, MOEX BROK, MOEX IIS) (compte); </li><li>  Prix ​​moyen d'une position ouverte (avg_open_price) </li></ul></div></div><br>  Nous traitons un tableau de documents XML et remplissons ces dictionnaires avec les données appropriées: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  Tout le traitement passe par la boucle sur toutes les données XML des rapports.  Les informations sur la plateforme de trading, le code client sont les mêmes dans tous les rapports, vous pouvez donc les extraire en toute sécurité des mêmes balises sans utiliser de mappage. <br><br>  Mais nous devons ensuite utiliser une conception spéciale qui fournira l'alias nécessaire pour la balise basée sur le rapport (SPB ou MOEX), car  les données de nature identique dans ces rapports sont appelées différemment. <br><br><div class="spoiler">  <b class="spoiler_title">Écarts de balise</b> <div class="spoiler_text"><ul><li>  La commission de courtier de transactions dans le rapport SBP se trouve dans la balise de <b>courtage</b> et dans le rapport <b>MOEX</b> - <b>broker_commission</b> ; </li><li>  La date de transaction du compte non commercial dans le rapport SPB est <b>operationdate</b> et dans MOEX, c'est <b>operation_date</b> , etc. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemple de mappage de balises</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  La fonction get_allias renvoie le nom de la balise nécessaire pour le traitement, en prenant le nom de la plateforme de trading en entrée: <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_allias</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  La fonction get_briefcase est responsable du traitement des informations sur l'état du portefeuille client: <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Ensuite, la fonction get_deals récupère des informations sur les transactions: <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_deals</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  En plus de traiter un tableau avec des informations sur les paramètres de la transaction, le prix moyen d'une position ouverte et réalisé par PNL en utilisant la méthode FIFO est également calculé ici.  La classe PnlSnapshot est responsable de ce calcul, dont la création avec les petites modifications le code présenté ici a été prise comme base: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">calcul P&amp;L</a> <br><br>  Et enfin, le plus difficile à mettre en œuvre est la fonction d'obtention d'informations sur les opérations non commerciales - <b>get_nontrade_operation</b> .  Sa complexité réside dans le fait que dans le bloc de rapport utilisé pour les opérations non commerciales, il n'y a pas d'informations claires sur le type de transaction et la sécurité à laquelle cette opération est liée. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de destinations de paiement pour les opérations non commerciales</b> <div class="spoiler_text">  Le paiement de dividendes ou de revenus de coupons accumulés peut être indiqué comme suit: <br><br><ol><li>  Paiement des revenus du client &lt;777777&gt; <font color="#cc0000">dividendes</font> &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; paiement des dividendes du rapport SPB; </li><li>  Paiement des revenus du client &lt;777777&gt; <font color="#cc0000">dividendes</font> &lt; <font color="#cc0000">MICROSOFT</font> COM-&gt; </li><li>  Paiement des revenus des clients 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) retenue à la source 0,00 roubles -&gt; paiement du coupon du rapport MOEX; </li><li>  Paiement des revenus au client 777777 <font color="#cc0000">dividendes de FGC UES</font> -ao précompte mobilier XX.XX roubles -&gt; paiement des dividendes du rapport MOEX.  etc. </li></ol></div></div><br>  En conséquence, il sera difficile de se passer d'expressions régulières, nous les utiliserons donc au maximum.  L'autre côté du problème est que le nom de l'entreprise ne coïncide pas toujours avec le nom dans le portefeuille ou dans les transactions aux fins du paiement.  Par conséquent, le nom reçu de l'émetteur du but du paiement doit être corrélé en plus avec le dictionnaire.  En tant que dictionnaire, nous utiliserons un éventail d'offres, car  il y a la liste la plus complète des entreprises. <br><br>  La fonction <b>get_company_from_str</b> récupère le nom de l'émetteur dans le commentaire: <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_company_from_str</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  La fonction <b>get_company_from_briefcase</b> mène le nom de la société au dictionnaire si elle trouve une correspondance parmi les sociétés qui ont participé aux transactions: <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_company_from_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  Et enfin, la fonction finale de la collecte de données sur les opérations non commerciales est <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Get_nontrade_operation</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  Le résultat de la collecte de données à partir des rapports sera trois DataFrames, qui sont approximativement les suivants: <br><br><ol><li>  DataFrame avec des informations sur les prix moyens des positions ouvertes: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Deal DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame avec des informations sur les opérations non commerciales: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  Il ne nous reste donc plus qu'à effectuer une union externe de la table des transactions avec la table d'informations du portefeuille: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  Enfin, la dernière étape du traitement du tableau de données est la fusion du tableau de données obtenu à l'étape précédente avec le DataFrame pour les transactions non commerciales. <br>  Le résultat du travail effectué est une grande table plate avec toutes les informations nécessaires à l'analyse: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  L'ensemble de données résultant (rapport final) du DataFrame est facilement téléchargé sur le CSV et peut ensuite être utilisé pour une analyse détaillée dans n'importe quel système de BI. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Charger et traiter des données dans AWS </h2><br>  Les progrès ne sont pas en reste et les services cloud et les modèles informatiques sans serveur gagnent désormais en popularité dans le traitement et le stockage des données.  Cela est en grande partie dû à la simplicité et au coût peu élevé de cette approche, lorsque vous n'avez pas besoin d'acheter un équipement coûteux pour construire une architecture système pour le calcul complexe ou le traitement de données volumineuses, mais que vous louez simplement l'énergie dans le cloud pour le temps dont vous avez besoin et déployez les ressources nécessaires assez rapidement pour un coût relativement faible. . <br><br>  Amazon est l'un des fournisseurs de cloud les plus importants et les plus connus du marché.  Regardons l'exemple de l'environnement Amazon Web Services (AWS) pour construire un système analytique de traitement des données sur notre portefeuille d'investissement. <br><br>  AWS dispose d'une vaste sélection d'outils, mais nous utiliserons les éléments suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amazon S3</a> - stockage d'objets, qui vous permet de stocker des quantités presque illimitées d'informations; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AWS Glue</a> - le service ETL cloud le plus puissant qui peut lui-même déterminer la structure et générer le code ETL à partir des données source données; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amazon Athena</a> , un service de requête SQL en ligne sans serveur, vous permet d'analyser rapidement les données de S3 sans trop de préparation.  Il a également accès aux métadonnées qu'AWS Glue prépare, ce qui vous permet d'accéder aux données immédiatement après avoir passé l'ETL; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amazon QuickSight</a> - BI-service sans serveur, vous pouvez créer n'importe quelle visualisation, des rapports analytiques "à la volée", etc. </li></ul><br>  La documentation d'Amazon est correcte, en particulier, il existe un bon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meilleures pratiques lors de l'utilisation d'Athena avec AWS Glue</a> , qui décrit comment créer et utiliser des tables et des données à l'aide d'AWS Glue.  Profitons des idées principales de cet article et appliquons-les pour créer notre propre architecture d'un système de rapports analytiques. <br><br>  Les fichiers CSV préparés par notre analyseur de rapports seront ajoutés au compartiment S3.  Il est prévu que le dossier correspondant sur S3 soit réapprovisionné tous les samedis - à la fin de la semaine de négociation, de sorte que vous ne pouvez pas vous passer du partitionnement des données à la date de formation et de traitement du rapport. <br>  En plus d'optimiser le fonctionnement des requêtes SQL sur de telles données, cette approche nous permettra de mener des analyses complémentaires, par exemple, pour obtenir la dynamique des changements dans le résultat financier de chaque article, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Travailler avec Amazon S3</b> <div class="spoiler_text"><ul><li>  Créez un compartiment sur S3, appelez-le «report-parser»; </li><li>  Dans ce bucket "report-parser" créez un dossier appelé "my_trader_diary"; </li><li>  Dans le répertoire "my_trader_diary", créez un répertoire avec la date du rapport actuel, par exemple, "date_report = 2018-10-01" et placez-y le fichier CSV; </li><li>  Dans le seul but d'expérimenter et de mieux comprendre le partitionnement, nous allons créer deux répertoires supplémentaires: "date_report = 2018-09-27" et "date_report = 2018-10-08".  Nous y mettons le même fichier CSV; </li><li>  Le dernier "analyseur de rapports" du compartiment S3 devrait ressembler à celui illustré dans les images ci-dessous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Travailler avec AWS Glue</b> <div class="spoiler_text">  En gros, vous ne pouvez faire qu'Amazon Athena pour créer une table externe à partir des données se trouvant sur S3, mais AWS Glue est un outil plus flexible et pratique pour cela. <br><br><ul><li>  Nous allons dans AWS Glue et créons un nouveau robot, qui collectera une table à partir de fichiers CSV distincts par date de rapport: <br><ul><li>  Définissez le nom du nouveau robot; </li><li>  Nous indiquons le référentiel d'où obtenir les données (s3: // report-parser / my_trader_diary /) </li><li>  Nous sélectionnons ou créons un nouveau rôle IAM qui aura accès au lancement du robot et à la ressource spécifiée sur S3; </li><li>  Ensuite, vous devez définir la fréquence de démarrage.  Nous l'avons mis sur demande pour l'instant, mais à l'avenir, je pense que cela va changer et le lancement deviendra hebdomadaire; </li><li>  Enregistrez et attendez la création du robot. </li></ul></li><li>  Lorsque le robot entre en état Prêt, démarrez-le! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Une fois que cela fonctionne, une nouvelle table my_trader_diary apparaîtra dans l'onglet AWS Glue: Base de données -&gt; Tables: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Considérez le tableau généré plus en détail. <br>  Si vous cliquez sur le nom de la table créée, nous irons à la page avec la description des métadonnées.  En bas, il y a une disposition de table et la plus récente est une colonne qui n'était pas dans le fichier CSV source - date_report.  Cette colonne qu'AWS Glue crée automatiquement en fonction de la définition des sections des données source (dans Bucket S3, nous avons spécialement nommé les dossiers date_report = YYYY-MM-DD, ce qui nous a permis de les utiliser comme sections séparées par date). <br><br><div class="spoiler">  <b class="spoiler_title">Partitionnement de table</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  Sur la même page dans le coin supérieur droit, il y a un bouton Afficher les partitions, en cliquant sur lequel nous pouvons voir quelles sections notre tableau généré comprend: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Analyse des données </h2><br>  Ayant à notre disposition des données traitées téléchargées, nous pouvons facilement commencer à les analyser.  Pour commencer, considérez les capacités d'Amazon Athena comme le moyen le plus simple et le plus rapide d'effectuer des requêtes analytiques.  Pour ce faire, accédez au service Amazon Athena, sélectionnez la base de données dont nous avons besoin (financière) et écrivez le code SQL suivant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  Cette demande nous affichera un résultat financier net pour chaque titre pour toutes les dates de déclaration.  Parce que  nous avons téléchargé le même rapport trois fois pour des dates différentes, le résultat ne changera pas, ce qui, bien sûr, sur un marché réel sera différent: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  Mais que se passe-t-il si nous voulons visualiser les données reçues sous forme de tableaux ou de diagrammes flexibles?  Ici, Amazon QuickSight vient à la rescousse, avec l'aide de laquelle vous pouvez configurer des analyses flexibles presque aussi rapidement que l'écriture d'une requête SQL.  Nous allons accéder au service Amazon QuickSight (si vous n'y êtes pas encore inscrit, l'inscription est obligatoire). <br><br>  Cliquez sur le bouton Nouvelles analyses -&gt; Nouvel ensemble de données et dans la fenêtre qui apparaît sélectionnez les sources pour l'ensemble de données, cliquez sur Athéna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  Nous allons trouver un nom pour notre source de données, par exemple, "PNL_analysis" et cliquer sur le bouton "Créer une source de données". <br><br>  Ensuite, la fenêtre Choisissez votre table s'ouvre, où vous devez sélectionner la base de données et la table de source de données.  Nous sélectionnons la base de données - financière, et la table qu'elle contient: my_traider_diary.  Par défaut, la table entière est utilisée, mais si vous sélectionnez «Utiliser SQL personnalisé», vous pouvez personnaliser et affiner l'échantillon de données dont vous avez besoin.  Par exemple, nous utilisons l'ensemble du tableau et cliquez sur le bouton Modifier / Aperçu des données. <br><br>  Une nouvelle page s'ouvrira où vous pourrez effectuer des réglages supplémentaires et traiter les données existantes. <br><br>  Nous devons maintenant ajouter des champs calculés supplémentaires à notre jeu de données: trimestre et année de fonctionnement.  Un lecteur attentif peut remarquer que de telles manipulations étaient plus faciles à faire du côté de l'analyseur avant d'enregistrer le rapport final au format CSV.  Sans aucun doute, mon objectif est maintenant de démontrer les capacités et la flexibilité des paramètres du système BI à la volée.  Nous continuons à créer des champs calculés en cliquant sur le bouton «Nouveau champ». <br><br><div class="spoiler">  <b class="spoiler_title">Créer un nouveau champ</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  Pour mettre en évidence l'année de l'opération et le trimestre, des formules simples sont utilisées: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Remplir des formules pour un nouveau champ</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  Lorsque les champs calculés ont été créés avec succès et ajoutés à la sélection, donnez un nom à notre jeu de données, par exemple, "my_pnl_analyze" et cliquez sur le bouton "Enregistrer et visualiser". <br><br>  Après cela, nous transférons vers la carte principale d'Amazon QuickSight et la première chose que nous devons faire est de configurer un filtre pour la date du rapport (en tenant compte du fait que les mêmes données ont été collectées dans trois sections).  Sélectionnez la date du rapport 2018-10-01 et cliquez sur le bouton Appliquer et accédez à l'onglet Visualiser. <br><br><div class="spoiler">  <b class="spoiler_title">Réglage du filtre</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br>          , ,       ,        (..      )   .      BI –  .      ,       (   MS Excel) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote>     ,          ,      , ..     1 509.91 .     (1 763.36 . –     174 . –   ).         . </blockquote><br>   –  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br>    ,   ,      ,               .       : sum_investment  count_days. <br><br><div class="spoiler"> <b class="spoiler_title"> sum_investment</b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       –     (    – 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"> count_days</b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br>      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2>    </h2><br>              « »    Amazon.          , ..            , ,          ,  . <br><br>              ,     (  )     .   ,        ,     ,       –     . <br><br> ,           . ,      PNL        (,    ),       .…     Quicksight     ,    ,        Python      . <br><br>     -  ,      :          XML-! ,    ,  API               .       Amazon:   ETL-job  AWS Glue           Amazon QuickSight    . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426027/">https://habr.com/ru/post/fr426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426017/index.html">Comment réduire le nombre d'expériences sur des animaux</a></li>
<li><a href="../fr426019/index.html">Station météo sur Arduino de A à Z. Partie 5</a></li>
<li><a href="../fr426021/index.html">libgdx et sentiments</a></li>
<li><a href="../fr426023/index.html">Leçon ouverte "Laboratoire virtuel à Vagrant"</a></li>
<li><a href="../fr426025/index.html">Utiliser des méthodes offensives pour enrichir Threat Intelligence</a></li>
<li><a href="../fr426029/index.html">Vous abandonnez et souhaitez quitter la tâche? Voici à quoi ressemble une formation de développeur efficace</a></li>
<li><a href="../fr426031/index.html">S'inquiéter de capturer le monde avec l'intelligence artificielle peut être basé sur des hypothèses non scientifiques</a></li>
<li><a href="../fr426033/index.html">Les titans des maths s'affrontent sur la preuve épique de l'hypothèse abc</a></li>
<li><a href="../fr426039/index.html">Lancement d'urgence "Soyouz MS-10" (équipage sauvé, retransmis)</a></li>
<li><a href="../fr426041/index.html">Solution symbolique d'équations et de systèmes différentiels linéaires par la méthode de transformation de Laplace utilisant SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>