<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳🏿 🍟 👲 Glanz und Armut Atomtausch ☝🏾 👨🏾‍⚕️ 📵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum Atomswaps schlecht sind und wie die Kanäle ihnen helfen, was in der harten Gabel von Konstantinopel passiert ist und was zu tun ist, wenn für Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Glanz und Armut Atomtausch</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483828/">  Warum Atomswaps schlecht sind und wie die Kanäle ihnen helfen, was in der harten Gabel von Konstantinopel passiert ist und was zu tun ist, wenn für Benzin nichts zu bezahlen ist. <br><br>  Die Hauptmotivation eines Sicherheitsexperten ist der Wunsch, Verantwortung zu vermeiden. <br><br>  Die Vorsehung war gnädig, ich verließ das ICO und wartete nicht auf die erste irreversible Transaktion, sondern befand mich bald hinter der Entwicklung eines Kryptowährungsaustauschs. <br><a name="habracut"></a><br>  Ich bin definitiv kein Malchish Kibalchish, und ein strenger Blick genügt mir, um alle Schlüssel und Passwörter zu übergeben.  Mein Hauptziel als Architekt war es daher, den glühenden Stich der Kryptoanalyse so weit wie möglich von den für mich wichtigen Infrastrukturelementen zu entfernen. <br><br><h2>  Nicht deine Schlüssel, nicht deine Probleme </h2><br>  Wir bauen ein System für den Austausch von Vermögenswerten auf und möchten die Zwischenlagerung dieser Vermögenswerte zu Hause ausschließen, müssen jedoch die Sicherheit der Transaktion gewährleisten. <br><br>  Sie können in einer kontroversen Situation als Richter auftreten und Transaktionen mit Brieftaschen durchführen, für die zwei der drei Unterschriften erforderlich sind: Käufer, Verkäufer und Treuhänder. <br><br>  Wenn ein Teilnehmer jedoch eine Übertragungsurkunde erfolgreich angreift, erhält er die erforderlichen zwei Signaturen. <br><br>  Atomic Swap ist ein Tauschprogramm, bei dem ein intelligenter Vertrag als Garant fungiert und nur ehrliches Verhalten zulässt. <br><br>  Wie in einem Rätsel um Wolfsziege und Kohl kann man nur nach dem einzig richtigen Szenario handeln und Verluste erleiden, wenn man davon zurücktritt. <br><br>  Nur anstelle von gefräßigen Tieren bietet die Reihenfolge eine Hash-Funktion, bei der es so schwierig ist, eine Kollision zu finden, dass es sich nicht lohnt, damit zu beginnen. <br><br><h4>  Erster Schritt: Das Rätsel </h4><br>  Angenommen, Alice möchte Bob an einem schönen Morgen Bitcoin für eine Handvoll „Krypto-Yuan“ geben. <br><br><ul><li>  Sie macht ein großes Geheimnis </li><li>  Erhält einen Hash davon </li><li>  Er überträgt Bitcoins in einen intelligenten Vertrag, von dem Bob Geld durch Vorlage eines Geheimnisses abheben kann (der Hash muss dem im Vertrag angegebenen entsprechen). </li><li>  Für den Fall, dass Bob abends nicht bei seinen Bitcoins ist, kann Alice sie wieder für sich selbst auswählen. </li></ul><br><h4>  Zweiter Schritt: Köder </h4><br>  Bob betritt das Spiel und überträgt "cryptoeuro" auf seinen Vertrag, der so geschrieben ist, dass: <br><br><ul><li>  Alice kann Kryptomünzen mit einer Geheimzahl aufheben </li><li>  Spätestens zum Mittagessen kann Bob die Kaution zurückerstatten, falls Alice nicht erscheint <br></li></ul><br><h4>  Schritt drei: Die Lösung im Köder </h4><br>  Alice kommt für ihr Geld und nimmt das Geld von Bobs Vertrag, während sie ihr Geheimnis preisgibt. <br><br><h4>  Der letzte Schritt: Das Rätsel ist gelöst </h4><br>  Bob sieht die Transaktion und isoliert mit seinem Blick das Geheimnis, das Alice dem Vertrag verraten hat.  Mit diesem Geheimnis sammelt er seine Bitcoins. <br><br><h3>  Wenn etwas schief geht </h3><br>  Wenn sich Alice plötzlich als sterblich herausstellt, nimmt Bob seinen Yuan zum Mittagessen. <br><br>  Am Abend gibt Alice ihrerseits Bitcoin zurück, wenn der verräterische Bob beschließt, das Geld bis zu besseren Zeiten aufzubewahren. <br><br>  Wenn Sie einem Text ein Bild vorziehen, gibt es auf Habré eine detailliertere und klarere <a href="https://habr.com/en/post/458646/">Erklärung für die Arbeit von Atomtauschern</a> . <br><br>  Die Differenz zwischen Timeouts soll uns vor der böswilligen Alice schützen, die im allerletzten Moment Bobs Geld nimmt, und die Timeout-Zeit läuft ab, während er mit zitternden Fingern das Hex in die Transaktion treibt. <br><br>  Teilnehmer können ihr Geld nicht verlieren, der Höchstbetrag muss auf eine Rückerstattung warten. <br><br><div class="spoiler">  <b class="spoiler_title">Blockchain-Unterstützung</b> <div class="spoiler_text">  Dies ist ein einfaches Schema wie Filzstiefel, das nichts von den interagierenden Blockchains erfordert: <br><br><ul><li>  Unterstützung für intelligente Verträge mit mindestens einer Niederlassung </li><li>  Beide Blockchains müssen die gleichen Hashing-Algorithmen unterstützen (nicht vergessen, die Länge des Geheimnisses zu überprüfen) </li><li>  Zeitschlösser. </li></ul><br></div></div><br>  Auf den ersten Blick kann man zum Austausch schon sagen, "Auf Wiedersehen, unser Treffen war ein Fehler", aber es war nicht da. <br><br>  Atomic-Swap-Lösungen sind trotz aller Vorzüge nicht liquiditätswirksam.  Vor allem, weil im beliebtesten Paar von BTC-USD der Fiat-Teil nicht vollständig gekennzeichnet war. <br>  Der Erfolg von USDT hat zu einer Welle stabiler Münzen im ERC20-Format für jeden Geschmack geführt, vom USDC für die Verwahrung bis zum algorithmischsten DAI. <br><br>  Der Einfachheit halber argumentieren wir weiterhin, dass Alice Bobcoins für einige ERC20-Token an Bob verkauft, und wir hoffen auf den Erfolg der Stabilisatoren, da wir viel mehr technische Probleme haben. <br><br><h3>  Geschwindigkeit </h3><br>  Bitcoin und Ethereum alleine sind nicht zu schnell, aber hier müssen wir erst auf eine Einzahlung mit allen Bestätigungen warten, dann auf die zweite. <br><br>  Dies ist alles, weil der Teilnehmer, der das Geheimnis zuerst kennt, das Geld verdient und der Gegner auf das Finale wartet und erst dann seinen Teil überträgt. <br><br>  Darüber hinaus haben wir es mit einem sehr volatilen Vermögenswert zu tun, sodass sich der Kurs in dieser Zeit erheblich ändern kann und es nicht einfach ist, die Bedingungen zu ändern. <br><br><h3>  Vertraulichkeit </h3><br>  Jeder Austausch hinterlässt Artefakte auf beiden Blockketten.  Ein aufmerksamer Beobachter kann die gleichen Hashes in intelligenten Verträgen feststellen und daraus logisch schließen, dass hier ein Geschäft abgeschlossen wurde, aus dem viele Schlussfolgerungen vom Wechselkurs zur Steuer gezogen werden können. <br><br>  Wenn der Austausch über Ihre Angelegenheiten Bescheid weiß - das ist äußerst unangenehm, wenn jeder davon weiß - ist es doppelt unangenehm. <br><br><h3>  Benutzerfreundlichkeit </h3><br>  Das Blockchain-Pferd im Allgemeinen und der Äther im Besonderen.  Mal sehen, welche Körperbewegungen der Verkäufer und der Käufer machen müssen. <br><br>  Aus Sicht des Verkäufers ist alles relativ einfach: Sie müssen nur Bitcoin an eine p2sh-Adresse übertragen.  Mit Äther ist alles viel schwieriger. <br><br><div class="spoiler">  <b class="spoiler_title">Der Vertrag</b> <div class="spoiler_text">  Betrachten Sie einen durchschnittlichen Gigab-Swap-Kontrakt: <br><br><pre><code class="plaintext hljs">contract iERC20 { function totalSupply() public view returns (uint256); function transfer(address receiver, uint numTokens) public returns (bool); function balanceOf(address tokenOwner) public view returns (uint); function approve(address delegate, uint numTokens) public returns (bool); function allowance(address owner, address delegate) public view returns (uint); function transferFrom(address owner, address buyer, uint numTokens) public returns (bool); } contract Swapper { struct Swap { iERC20 token; bytes32 hash; uint amount; uint refundTime; bytes32 secret; } mapping (address =&gt; mapping(address =&gt; Swap)) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, uint refundTime) public { require(swaps[msg.sender][receiver].amount == 0); // check is swap with given hash already exists require(token.transferFrom(msg.sender, address(this), amount)); // transfer locked tokens to swap contract swaps[msg.sender][receiver] = Swap(token, hash, amount, refundTime, 0x00); //create swap } function hashOf(bytes32 secret) public pure returns(bytes32) { return sha256(abi.encodePacked(secret)); } function withdraw(address owner, bytes32 secret) public { Swap memory swap = swaps[owner][msg.sender]; require(swap.secret == bytes32(0)); require(swap.hash == sha256(abi.encodePacked(secret))); // swap exists swaps[owner][msg.sender].secret = secret; swap.token.transfer(msg.sender, swap.amount); } function refund(address receiver) public { Swap memory swap = swaps[msg.sender][receiver]; require(now &gt; swap.refundTime); delete swaps[msg.sender][receiver]; swap.token.transfer(msg.sender, swap.amount); } }</code> </pre> <br>  <b>Achtung!</b>  Verwenden Sie diesen und andere Verträge aus einem Produktionsartikel nicht, sie werden ausschließlich zu Demonstrationszwecken geschrieben.  <b>Besonders dieser</b> . <br></div></div><br><ul><li>  Bob muss die <code>approve</code> für den Token-Vertrag aufrufen und dem Swap-Vertrag Zugriff auf seine Token gewähren <br></li><li>  Bob erstellt einen Swap und ein Vertrag mit der <code>transferFrom</code> Methode nimmt Absendertoken an seine Adresse <br></li><li>  Alice im <code>withdraw</code> deckt ein Geheimnis auf und der Vertrag ruft die <code>transfer</code> <br></li></ul><br>  Die meisten Brieftaschen und <code>approve</code> unterstützen aus gutem Grund keine <code>approve</code> Token. <br><br>  Benutzer selbst irren sich oft und übertragen Token einfach in den Vertrag. Danach gehen die Token einfach verloren.  Kommentare zu Etherscan sind voll von klagenden Elenden. <br><br>  Und um einen Vertrag zu kündigen, muss an der ETH eine Provision gezahlt werden. Beide Teilnehmer müssen sich also vor Beginn der Transaktion mit ihnen eindecken, und das wollen nur wenige. <br><br><h3>  Gasbehälter </h3><br>  Zunächst lohnt es sich, den Scheck des Absenders zu entfernen, wo immer dies möglich ist, und vorauszusetzen, dass jemand unter überschüssigem Benzin leidet und Verträge für alle zustande bringt. <br><br><div class="spoiler">  <b class="spoiler_title">Verbesserter Vertrag</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">contract Swapper { struct Swap { iERC20 token; address receiver; uint amount; address refundAddress; uint refundTime; } mapping (bytes32 =&gt; Swap) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public { require(swaps[hash].amount == 0); // use hash once require(token.transferFrom(msg.sender, address(this), amount)); swaps[hash] = Swap(token, receiver, amount, refundAddress, refundTime); } function withdraw(bytes memory secret) public { bytes32 hash = sha256(secret); Swap memory swap = swaps[hash]; require(swap.amount &gt; 0); delete swaps[hash]; swap.token.transfer(swap.receiver, swap.amount); } function refund(bytes32 hash) public { Swap memory swap = swaps[hash]; require(now &gt; swap.refundTime); delete swaps[hash]; swap.token.transfer(swap.refundAddress, swap.amount); } }</code> </pre><br></div></div><br><h3>  Contract-Key Dualism und EIP 712 </h3><br>  Wie wir wissen, kann die Adresse in der Luft ein Vertrag sein, oder es kann ein Thema sein, mit anderen Worten, ein Schlüssel. <br>  Die Hauptbeschäftigung des Schlüssels ist das Signieren von Nachrichten. <br><br>  Wir können den Bob-Vertrag als Absender verwenden, der alle erforderlichen Ausweise vornimmt, bevor die Signatur des Bob-Schlüssels überprüft wird. <br><br>  Jetzt kann jeder die Provision eines Mitglieds sponsern, aber nur derjenige, der den Schlüssel kennt, trifft die Entscheidung. <br><br><div class="spoiler">  <b class="spoiler_title">Bob Vertrag</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library EIP712ProxyLibrary { function hashCommand(address sender, iERC20 token, Swapper swapper, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public view returns(bytes32); } contract ProxyBob { address owner; constructor(address _owner) public { owner = _owner; } function createSwap(Swapper swapper, iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime, uint8 v, bytes32 r, bytes32 s) public { require(owner == ecrecover(EIP712ProxyLibrary.hashCommand(address(this), token, swapper, hash, receiver, amount, refundAddress, refundTime), v, r, s)); token.approve(address(swapper), amount); swapper.create(token, hash, receiver, amount, refundAddress, refundTime); } }</code> </pre><br></div></div><br>  Ethereum verfügt über einen <a href="" rel="nofollow">EIP 712-</a> Standard für die Arbeit mit Signaturen komplexer Datenstrukturen. Weitere <a href="https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26" rel="nofollow">Informationen finden</a> Sie im <a href="https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26" rel="nofollow">Metamask-Wallet-Blog.</a> <br><br><h3>  Teilen und erobern </h3><br>  Häufig sieht das Szenario, einen Ethereum-Vertrag zu hacken, so aus: <br><br><ul><li>  Der Teilnehmer zahlt Geld auf den Vertrag </li><li>  Dann nimmt das Geld </li><li>  Irgendwas läuft schief </li><li>  Ein Angreifer nimmt immer wieder Geld </li></ul><br>  Wenn wir zu unserem ersten Beispiel zurückkehren, geht etwas schief, wenn das Rätsel eine leere Byte-Menge ist. <br><br><div class="spoiler">  <b class="spoiler_title">Wie man eine Million stiehlt</b> <div class="spoiler_text">  Erstellen Sie einen Swap mit einem Hash <code>0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925</code> <br>  Dies ist sha256 von <code>0x0000000000000000000000000000000000000000000000000000000000000000</code> <br>  Wir geben das Geheimnis weiter und sammeln unsere Token <br>  Wir passieren es noch einmal und nehmen die Fremden, alle weil 0 = 0 <br></div></div><br>  Durch das Erstellen eines separaten Vertrags für jede Transaktion können wir Verträge auf EVM-Ebene isolieren. <br><br>  Das ist aber noch nicht alles: Jetzt hat jede Transaktion ihre eigene Adresse, an die Sie Token von jedem Geldbeutel oder Geldwechsel senden können. <br><br><h2>  Verlassene Verträge und create2 </h2><br>  Aber jetzt müssen wir für jede Transaktion einen Vertrag abschließen und warten, bis der Käufer die Arbeit „cryptofening“ dorthin transferiert.  Im Schema „Morgenverträge, Abendgeld“ besteht immer die Gefahr, dass der Käufer abfällt und der Äther bereits für die Vertragserstellung aufgewendet wurde. <br><br>  Kann man morgens Geld und abends Bytes verdienen? <br><br>  In der Hard Fork von Konstantinopel haben die <a href="https://eips.ethereum.org/EIPS/eip-1014" rel="nofollow">EIP 1014-</a> Entwickler eine Anweisung create2 hinzugefügt, mit der ein neuer Vertrag an einer deterministischen Adresse erstellt wird <br><br><pre> <code class="plaintext hljs">keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]</code> </pre><br>  Wo <br><br><ul><li>  Adresse - Fabrikvertragsadresse </li><li>  Salz - eine Zahl, deren Bedeutung wir in der nächsten Reihe erfahren werden </li><li>  init_code - Vertragsbytecode und Konstruktorparameter. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Die Fabrik</b> <div class="spoiler_text">  Die Anleitung funktioniert nur durch Montage, daher sieht die Fabrik ein bisschen einschüchternd aus: <br><br><pre> <code class="plaintext hljs">contract Factory { event Deployed(address addr, uint256 salt); function create2(bytes memory code, uint256 salt) public { address addr; assembly { addr := create2(0, add(code, 0x20), mload(code), salt) } emit Deployed(addr, salt); } }</code> </pre><br>  Ihren Vertragscode erhalten Sie über web3: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyContract = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(ABI, {}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ode = MyContract.deploy({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: BYTECODE, <span class="hljs-attr"><span class="hljs-attr">arguments</span></span>: contructorArgs }).encodeABI(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(FACTORY_ABI, factoryAddress); tx = factory.methods.create2(ode, salt);</code> </pre><br>  Aufgrund der eingeschränkten Solidität kann es sein, dass das Gas für den Vertrag aufgrund einiger Feinheiten des Äthers nicht korrekt berechnet wird. <br><br>  Besonders schön ist, dass im Falle eines Gasmangels der Vertrag mit einem internen Fehler abfällt, ohne darauf hinzuweisen, dass erwartungsgemäß nicht genug Gas vorhanden ist. <br></div></div><br>  Jetzt können wir Tokens auf Verträge übertragen, ohne sie im Voraus zu erstellen, und bis wir sie im Netzwerk veröffentlichen, ahnt niemand, was genau der Vertrag bewirkt. <br><br><h3>  Der Rabe pickt die Krähe nicht aus </h3><br>  Es ist klar, dass die Tricks eines solchen Kindes einen echten Analytiker nicht aufhalten werden, insbesondere einen, der gute Investitionen in die Bekämpfung der <s>Feinde des</s> Geldwäscheregimes erhalten hat, und nach Abschluss des Vertrags wird er immer noch einen Haschisch sehen. <br><br>  Wie kann man sicherstellen, dass der Hash nicht aufleuchtet? <br><br>  Wir übertragen den Swap selbst an die Kette: Die Teilnehmer tauschen ihre Unterschriften aus, um sie auf einen Swap-Vertrag zu übertragen, und dann wird das Geheimnis privat gelüftet. <br><br><div class="spoiler">  <b class="spoiler_title">Schritt für Schritt</b> <div class="spoiler_text">  Es werden zwei "Multisig" erstellt, von denen Sie Geld abheben können, wenn Sie die Unterschriften von Alice und Bob haben. <br><br>  Damit einer der Teilnehmer nicht zur Tragödie wurde, fügen wir die gute alte Auszeit hinzu. <br><br>  Alice und Bob tätigen parallel Einzahlungen <br><br><ul><li>  Alice macht ein Geheimnis und gibt Bob den Hash des Geheimnisses und die Signatur der Transaktion, die die Bitcoins an die Swap-Adresse überträgt </li><li>  Bob gibt Alice eine Unterschrift über die Entnahme von Token für einen Swap-Vertrag mit einem versteckten Hash. </li><li>  Alice erzählt Bob das Geheimnis. </li></ul><br></div></div><br>  In diesem Moment entsteht Harmonie: Sowohl Alice als auch Bob können den Deal jederzeit abschließen.  In einer so freundlichen Umgebung können sie Unterschriften austauschen, um Geld an ihre endgültige Adresse abzuheben. <br><br>  Für einen externen Beobachter sieht es so aus, als ob das Geld einen Vertrag mit einer Mehrfachunterschrift 2 von 2 durchlaufen hat. <br><br>  Und auch ein solches Schema ermöglicht es beiden Parteien, gleichzeitig eine Einzahlung zu tätigen, da das Geheimnis nach allen Bestätigungen bereits erfunden ist. <br><br><h2>  Stufe 2 </h2><br>  Da wir Geld an eine Adresse abheben können und keine Zwischentransaktion veröffentlichen, hindert uns nichts daran, Geld an mehrere Adressen abzuheben und eine unbegrenzte Anzahl von Zwischentransaktionen durchzuführen.  Nicht, dass dies ein notwendiges Set für einen Tausch gewesen wäre, aber wenn Sie mit dem Sammeln eines Swaps begonnen haben, ist es schwer aufzuhören. <br><br>  Jetzt können sich Alice und Bob mit aller Kraft umdrehen.  Berechnen Sie zum Beispiel automatisch den Durchschnittspreis, indem Sie Satoshi pro Sekunde tauschen, oder verbinden Sie einfach den Market Maker und den Liquiditätsempfänger direkt. <br><br><div class="spoiler">  <b class="spoiler_title">Schritt für Schritt</b> <div class="spoiler_text"><ul><li>  Der Verkäufer macht ein Geheimnis und gibt dem Käufer einen Hash der Geheim- und Transaktionsunterschrift, wobei ein Teil des Geldes an die p2sh-Swap-Adresse überwiesen wird und der Rest an die Adresse des Verkäufers zurückgeschickt wird <br></li><li>  Der Käufer übermittelt eine Unterschrift, mit der er die Token für den Tausch und die Lieferung an die Adresse des Empfängers abheben kann. <br></li><li>  Der Verkäufer verrät ein Geheimnis </li><li>  Die Geschichte wird mit einem neuen Geheimnis wiederholt, während dem Tausch und der Übergabe die Ausgabe hinzugefügt wird, die zuvor an die Adresse des Käufers gekauft und bereits an die Adresse des Verkäufers bezahlt wurde </li></ul><br></div></div><br>  Jetzt haben wir Zugang zum Hochgeschwindigkeits-P2P-Handel. Die Hauptsache ist, die Zeit zu überwachen und den Deal vor dem Timeout abzuschließen. <br><br>  Wenn wir jedoch unsere Verträge leicht angepasst haben, können wir unseren Kanälen Unsterblichkeit verleihen, was die Schaffung eines Netzwerks für uns erheblich vereinfacht. <br><br>  Aber darüber werden wir in der nächsten Serie sprechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483828/">https://habr.com/ru/post/de483828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483818/index.html">Engine, Skriptsprache und visueller Roman - in 45 Stunden</a></li>
<li><a href="../de483820/index.html">Was beeinflusst die Kreditvergabe? Home Credit Default Risk Wettbewerbsübersicht</a></li>
<li><a href="../de483822/index.html">5 JavaScript-Funktionen, ohne die ich keinen Code schreiben könnte</a></li>
<li><a href="../de483824/index.html">Wie Sie die Arbeit Ihrer Träume erreichen, positiv denken und vorankommen, nachdem Sie meine fünf Regeln studiert haben ...</a></li>
<li><a href="../de483826/index.html">Anschließen eines CO2-Sensors Modell MH-Z19B über den analogen Vo-Ausgang</a></li>
<li><a href="../de483830/index.html">Routing für iOS: Universelle Navigation ohne Umschreiben der Anwendung</a></li>
<li><a href="../de483832/index.html">RxJava nach Coroutines: End-to-End-Feature-Migration</a></li>
<li><a href="../de483834/index.html">Debian: einfach i386 in amd64 verwandeln</a></li>
<li><a href="../de483842/index.html">Die Entstehungsgeschichte einer Home Cloud. Teil 5. Aktualisierung 2019 - PHP 7.2, MariaDB 10.4 und Nextcloud 17</a></li>
<li><a href="../de483844/index.html">Analyse von Regulierungsdokumenten zum Informationsschutz im russischen Kredit- und Finanzsektor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>