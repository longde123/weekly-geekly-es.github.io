<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ„ ğŸ•‘ ğŸ° Eksplorasi shader pasir dari game Journey ğŸ ğŸ‘  ğŸ‘¨ğŸ»â€ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di antara banyak game indie yang dirilis selama 10 tahun terakhir, salah satu favorit saya adalah Journey . Berkat estetika yang menakjubkan dan sound...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eksplorasi shader pasir dari game Journey</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Di antara banyak game indie yang dirilis selama 10 tahun terakhir, salah satu favorit saya adalah <em>Journey</em> .  Berkat estetika yang menakjubkan dan soundtrack yang indah, <em>Journey</em> telah menjadi contoh keunggulan di hampir setiap aspek pembangunan. <br><br>  Saya adalah pengembang game dan artis teknis, jadi saya paling tertarik dengan cara rendering yang diberikan.  Ini tidak hanya cantik, tetapi juga terkait langsung dengan gameplay dasar dan gameplay secara keseluruhan.  <em>Journey</em> secara harfiah dibangun dari pasir, dan tanpa efek yang luar biasa, permainan itu sendiri tidak akan ada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  Dalam artikel dua posting ini, saya akan memberikan penghormatan kepada warisan <em>Journey</em> dengan mengajari Anda cara membuat ulang rendering pasir yang sama persis dengan menggunakan shader.  Terlepas dari apakah bukit pasir dibutuhkan dalam gim Anda, seri tutorial ini akan memungkinkan Anda belajar cara membuat ulang estetika tertentu di gim Anda sendiri.  Jika Anda ingin membuat ulang shader pasir indah yang digunakan dalam <em>Journey</em> , Anda harus terlebih dahulu memahami bagaimana itu dibuat.  Dan meskipun terlihat sangat kompleks, sebenarnya terdiri dari beberapa efek yang relatif sederhana.  Pendekatan ini untuk menulis shader diperlukan untuk menjadi seniman teknis yang sukses.  Oleh karena itu, saya berharap Anda akan melakukan <em>perjalanan</em> ini bersama saya, di mana kami tidak hanya mengeksplorasi penciptaan shader, tetapi juga belajar bagaimana menggabungkan estetika dan gameplay. <br><a name="habracut"></a><br><h1>  Analisis pasir dalam Journey </h1><br>  Artikel ini, seperti banyak upaya lain untuk menciptakan rendering pasir <em>Journey</em> , didasarkan pada laporan dari GDC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">bahwa</a> insinyur utama perusahaan John Edwards yang berjudul " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Sand Rendering in Journey</a> ".  Dalam pembicaraan ini, John Edwards berbicara tentang semua lapisan efek yang ditambahkan ke bukit pasir <em>Journey</em> untuk mendapatkan tampilan yang tepat. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Laporan ini sangat berguna, tetapi dalam konteks tutorial ini, banyak batasan dan keputusan yang dibuat oleh John Edwards tidak penting.  Kami akan mencoba menciptakan kembali shaders pasir, yang mengingatkan pada <em>Journey</em> shader, terutama dengan referensi visual. <br><br>  Mari kita mulai dengan jaring 3D sederhana dari bukit pasir yang sangat halus.  Kredibilitas rendering pasir tergantung pada dua aspek: pencahayaan dan butiran.  Cara menarik untuk memantulkan cahaya dari pasir disediakan oleh <strong>model pencahayaan yang</strong> dimodifikasi.  Dalam konteks pengkodean shader, model pencahayaan menentukan bayangan dan sorotan berdasarkan sifat-sifat model dan kondisi pencahayaan adegan. <br><br>  Namun, semua ini tidak cukup untuk menciptakan ilusi realisme.  Masalahnya adalah bahwa pasir tidak bisa dimodelkan dengan permukaan datar.  Butir pasir harus dipertimbangkan.  Itulah sebabnya ada dua efek terpisah yang bekerja secara langsung dengan <strong>normal ke permukaan</strong> , yang dapat digunakan untuk mensimulasikan partikel pasir kecil di permukaan bukit pasir. <br><br>  Diagram di bawah ini menunjukkan semua efek yang akan kita pelajari dalam tutorial ini.  Dari sudut pandang teknis, perhitungan normal dilakukan sebelum pencahayaan diproses.  Untuk kemudahan belajar, efeknya akan dijelaskan dalam urutan yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Warna menyebar </h6><br>  Efek shader pasir yang paling sederhana adalah <strong>warna difusnya</strong> , yang secara kasar menggambarkan komponen <em>kusam</em> dari keseluruhan penampilan.  Warna difus dihitung berdasarkan warna asli objek dan kondisi pencahayaan.  Sebuah bola yang dicat putih tidak akan menjadi putih sempurna di mana-mana, karena warna difus tergantung pada insiden cahaya di atasnya.  Warna difus dihitung menggunakan model matematika yang mendekati pantulan cahaya dari suatu permukaan.  Berkat laporan oleh John Edwards dengan GDC, kami tahu persis persamaan yang digunakan, yang ia sebut <strong>reflektansi kontras difus</strong> ;  ini didasarkan pada model <strong>refleksi Lambert yang</strong> terkenal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Sebelum dan sesudah menerapkan persamaan</i> <br><br><h6>  Pasir normal </h6><br>  Geometri asli sepenuhnya mulus.  Untuk mengimbangi ini, <strong>permukaan normal</strong> model diubah menggunakan teknik yang disebut <strong>pemetaan bump</strong> .  Ini memungkinkan Anda menggunakan tekstur untuk mensimulasikan geometri yang lebih kompleks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  Pencahayaan tepi </h6><br>  Setiap tingkat <em>Perjalanan</em> menggunakan palet warna terbatas.  Karena ini, sangat sulit untuk memahami di mana satu gundukan berakhir dan yang lainnya dimulai.  Untuk meningkatkan keterbacaan, teknik penyorotan kecil dari apa yang terlihat hanya di sepanjang tepi bukit pasir digunakan.  Ini disebut <strong>pencahayaan rim</strong> , dan ada banyak cara untuk menerapkannya.  Untuk tutorial ini, saya memilih metode berdasarkan refleksi <strong>Fresnel</strong> yang memodelkan refleksi pada permukaan yang dipoles pada apa yang disebut <em>sudut kejadian</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Cermin pantulan lautan </h6><br>  Salah satu aspek yang paling menyenangkan dari gameplay <em>Journey</em> adalah kemampuan untuk "menjelajahi" bukit pasir.  Ini mungkin mengapa perusahaan itu ingin pasir terasa lebih seperti cairan daripada padat.  Untuk ini, pantulan yang kuat digunakan, yang sering dapat ditemukan di water shader.  John Edwards menyebut efek ini <strong>specular laut</strong> , dan dalam tutorial kami menerapkannya menggunakan <strong>refleksi Blinn-Fong</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Refleksi cahaya </h6><br>  Menambahkan komponen specular laut ke shader pasir memberikannya tampilan yang lebih cair.  Namun, itu masih tidak memungkinkan salah satu aspek visual terpenting dari pasir untuk disampaikan: refleksi yang terjadi secara acak.  Dalam bukit pasir nyata, efek ini terjadi karena setiap butiran pasir memantulkan cahaya ke arahnya dan sangat sering salah satu dari sinar pantulan ini memasuki mata kita.  <strong>Refleksi kilau</strong> seperti itu (pantulan pantulan) terjadi bahkan di tempat-tempat di mana sinar matahari langsung tidak jatuh;  itu melengkapi specular lautan dan meningkatkan rasa kredibilitas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Gelombang pasir </h6><br>  Mengubah normals memungkinkan kita untuk mensimulasikan efek butiran kecil pasir yang menutupi permukaan bukit pasir.  Di bukit pasir di dunia nyata, ombak yang disebabkan oleh angin sering muncul.  Bentuknya bervariasi tergantung pada kemiringan dan posisi masing-masing bukit pasir relatif terhadap arah angin.  Berpotensi, pola seperti itu dapat dibuat melalui tekstur benjolan, tetapi dalam hal ini tidak mungkin untuk mengubah bentuk bukit pasir secara real time.  Solusi yang diajukan oleh John Edwards mirip dengan teknik yang disebut <strong>triplanar shading</strong> : menggunakan empat tekstur yang berbeda, dicampur tergantung pada posisi dan kemiringan masing-masing gundukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Journey Sand Shader Anatomy </h1><br>  Unity memiliki banyak template shader untuk membantu Anda memulai.  Karena kita tertarik pada bahan yang dapat menerima pencahayaan dan bayangan, kita harus mulai dengan <strong>pelindung</strong> permukaan (surface shader). <br><br>  Semua <strong>permukaan shader</strong> dilakukan dalam dua tahap.  Pertama, <strong>fungsi permukaan</strong> disebut yang mengumpulkan sifat-sifat permukaan yang perlu dirender, misalnya <em>albedo</em> , <em>kekasaran</em> , <em>sifat logam</em> , <em>transparansi</em> , dan <em>arah normal</em> .  Kemudian semua properti ini dipindahkan ke <strong>fungsi pencahayaan</strong> , yang memperhitungkan pengaruh sumber cahaya eksternal dan menghitung naungan dan pencahayaan. <br><br><h2>  Fungsi permukaan </h2><br>  Mari kita mulai dengan apa yang menjadi inti dari fungsi permukaan kita, yang disebut dalam kode <code>surf</code> bawah ini.  Satu-satunya properti yang perlu kita atur adalah <em>warna pasir</em> dan <strong>normal ke permukaan</strong> .  Normal dari model 3D adalah vektor yang menunjukkan posisi permukaan.  Vektor normal digunakan oleh fungsi pencahayaan untuk menghitung bagaimana cahaya akan dipantulkan.  Mereka biasanya dihitung selama impor mesh.  Namun, mereka dapat dimodifikasi untuk mensimulasikan geometri yang lebih kompleks.  Di sinilah efek <strong>normal</strong> <strong>gelombang</strong> <strong>pasir</strong> dan <strong>gelombang</strong> <strong>pasir</strong> mendistorsi norma pasir untuk mensimulasikan kekasarannya. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Saat menulis normals ke <code>o.Normal</code> mereka harus diekspresikan dalam <strong>ruang singgung</strong> .  Ini berarti bahwa vektor dipilih relatif terhadap permukaan model 3D.  Artinya, <code>float3(0, 0, 1)</code> sebenarnya berarti bahwa tidak ada perubahan yang sebenarnya dilakukan pada model 3D normal. <br><br>  Kedua fungsi, <code>RipplesNormal</code> , dan <code>SandNormal</code> menerima vektor normal dan memodifikasinya.  Nanti kita akan lihat bagaimana ini bisa dilakukan. <br><br><h2>  Fungsi pencahayaan </h2><br>  Dalam fungsi pencahayaanlah semua efek lain diterapkan.  Kode di bawah ini menunjukkan bagaimana masing-masing komponen dihitung dalam fungsi terpisah (warna difus, pencahayaan tepi, specular laut dan pantulan glitter).  Kemudian semuanya digabungkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  Metode menggabungkan komponen cukup sewenang-wenang dan memungkinkan kami mengubahnya untuk mempelajari kemungkinan artistik. <br><br>  Biasanya, pantulan specular menumpuk di atas warna yang menyebar.  Karena di sini kita tidak memiliki satu, tetapi tiga refleksi specular ( <em>pelek cahaya</em> , <em>specular laut</em> dan <em>glitter specular</em> ), kita perlu lebih berhati-hati agar tidak membuat pasir <em>terlalu</em> berkelap-kelip.  Karena rim light dan specular laut adalah bagian dari efek yang sama, kita hanya dapat memilih nilai maksimum dari mereka.  Glitter specular ditambahkan secara terpisah karena komponen ini menciptakan pasir yang berkedip-kedip. <br><br><h2>  Bagian 2. Warna Diffuse </h2><br>  Di bagian kedua posting, kita akan fokus pada model pencahayaan yang digunakan dalam game dan itu.  cara membuatnya kembali di Unity. <br><br>  Pada bagian sebelumnya, kami meletakkan dasar untuk apa yang secara bertahap akan berubah menjadi versi kami dari shader pasir Journey.  Seperti disebutkan sebelumnya, <strong>fungsi pencahayaan</strong> digunakan dalam <strong>shader permukaan</strong> untuk menghitung efek pencahayaan, sehingga bayangan dan sorotan muncul di permukaan.  Kami menemukan bahwa Journey memiliki beberapa efek yang termasuk dalam kategori ini.  Kita akan mulai dengan efek paling dasar (dan paling sederhana) yang ditemukan di inti shader ini: <strong>pencahayaan</strong> difus ( <strong>pencahayaan</strong> difus / difus). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Untuk saat ini, kami menghilangkan semua efek dan komponen lainnya, dengan fokus pada <strong>pencahayaan pasir</strong> . <br><br>  Fungsi pencahayaan yang kami <code>DiffuseColor</code> di bagian sebelumnya dari postingan yang disebut <code>LightingJourney</code> hanya mendelegasikan perhitungan warna pasir yang difus ke fungsi yang disebut <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Karena fakta bahwa setiap efek mandiri dan disimpan dalam fungsinya sendiri, kode kami akan lebih modular dan bersih. <br><br><h2>  Lambert Reflection </h2><br>  Sebelum membuat pencahayaan yang tersebar "seperti di Journey", ada baiknya untuk melihat seperti apa fungsi pencahayaan yang tersebar "dasar".  Teknik naungan paling sederhana untuk bahan matte disebut <strong>reflektansi Lambertian</strong> .  Model ini mendekati penampilan sebagian besar permukaan non-mengkilap dan non-logam.  Namanya diambil dari ilmuwan ensiklopedis Swiss <strong>Johann Heinrich Lambert</strong> , yang mengusulkan konsepnya pada 1760. <br><br>  Konsep refleksi Lambert didasarkan pada ide sederhana: <em>kecerahan permukaan tergantung pada jumlah insiden cahaya di atasnya</em> .  Secara geometris, ini dapat ditunjukkan pada diagram di bawah ini, di mana bola diterangi oleh sumber cahaya jarak jauh.  Meskipun area merah dan hijau pada bola menerima jumlah iluminasi yang sama, area permukaannya sangat berbeda.  Jika lampu di wilayah merah didistribusikan ke area yang lebih besar, ini berarti bahwa setiap unit dari kotak merah menerima lebih sedikit cahaya daripada hijau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Secara teoritis, pantulan Lambert tergantung pada sudut relatif antara <em>permukaan</em> dan <em>cahaya yang datang</em> .  Dari sudut pandang matematika, kita mengatakan bahwa ini adalah fungsi dari <strong>normal ke permukaan</strong> dan <strong>arah iluminasi</strong> .  Kuantitas ini dinyatakan dengan menggunakan dua vektor satuan panjang (disebut <strong>vektor satuan</strong> ) <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Vektor tunggal adalah cara standar untuk menentukan <em>arah</em> dalam konteks pengkodean shader. <br><br><div class="spoiler">  <b class="spoiler_title">Nilai N dan L</b> <div class="spoiler_text">  <strong>Normal</strong> ke permukaan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Adalah satuan vektor yang diarahkan <em>menjauh dari</em> permukaan itu sendiri. <br><br>  Dengan analogi, kita dapat mengasumsikan bahwa <strong>arah pencahayaan</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L.</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  menunjuk <em>dari</em> sumber cahaya dan mengikuti ke arah mana cahaya bergerak.  Tetapi tidak demikian: arah iluminasi adalah vektor tunggal yang menunjuk <em>ke</em> arah dari mana cahaya datang. <br><br>  Ini bisa membingungkan, terutama jika Anda baru membuat shader.  Namun, berkat notasi tersebut, persamaan menjadi lebih sederhana. </div></div><br><div class="spoiler">  <b class="spoiler_title">Refleksi Lambert dalam Persatuan</b> <div class="spoiler_text">  Sebelum <strong>Standar</strong> Unity 5 <strong>Shader</strong> , refleksi Lambert adalah model standar untuk permukaan yang diarsir. <br><br>  Anda masih dapat mengaksesnya di Inspektur Material: di <em>Legacy shader,</em> itu disebut <em>Diffuse</em> . <br><br>  Jika Anda menulis shader permukaan Anda sendiri, maka refleksi Lambert tersedia sebagai fungsi pencahayaan yang disebut <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Implementasinya dapat ditemukan dalam fungsi <code>LightingLambert</code> didefinisikan dalam file <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Lambert Reflection and Climate</b> <div class="spoiler_text">  Refleksi Lambert adalah model yang cukup lama, tetapi memberikan pemahaman tentang konsep-konsep kompleks seperti bayangan permukaan.  Ini juga dapat digunakan untuk menjelaskan banyak fenomena lainnya.  Sebagai contoh, diagram yang sama menjelaskan mengapa lebih dingin di kutub planet daripada di ekuator. </div></div><br>  Setelah melihat lebih dekat, kita dapat melihat bahwa permukaan menerima jumlah iluminasi maksimum ketika normalnya sejajar dengan arah iluminasi.  Dan sebaliknya: tidak ada cahaya jika dua vektor satuan saling tegak lurus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  Jelas, sudut antara <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhhXBEATs08ZifENZKQRiVf4rM0opg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  kritis untuk refleksi menurut Lambert.  Apalagi kecerahannya maksimum dan sama dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">100</span><span class="MJXp-mi" id="MJXp-Span-15">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> 100 \% </script>  ketika sudutnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  dan minimal ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mn" id="MJXp-Span-19">0</span><span class="MJXp-mi" id="MJXp-Span-20">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> 0 \% </script>  ) ketika sudut cenderung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mn" id="MJXp-Span-23" style="margin-right: 0.05em;">90</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-24" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">c</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> 90 ^ {\ circ} </script>  .  Jika Anda terbiasa dengan <em>aljabar vektor</em> , Anda bisa memahami bahwa kuantitas mewakili refleksi Lambert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> I </script>  sama dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">N</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> N \ cdot L </script>  dimana operatornya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mtext" id="MJXp-Span-41">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> \ cdot </script>  disebut <strong>produk skalar</strong> . <br><br>  (1) <p><math> </math> $$ menampilkan $$ \ mulai {persamaan *} I = N \ cdot L \ end {persamaan *} $$ menampilkan $$ </p><br>  Produk skalar adalah ukuran "kebetulan" dari dua vektor relatif satu sama lain, dan bervariasi dalam interval dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-54">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> + 1 </script>  (untuk dua vektor identik) ke <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0.111em;">âˆ’</span><span class="MJXp-mn" id="MJXp-Span-57">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> -1 </script>  (untuk dua vektor yang berlawanan).  Produk skalar adalah dasar dari peneduhan, yang saya teliti secara rinci dalam tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering dan Model Pencahayaan Berbasis Fisik</a> . <br><br><h3>  Implementasi </h3><br>  Dan untuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N </script>  dan untuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> L </script>  Anda dapat dengan mudah mengakses fitur pencahayaan shader permukaan melalui <code>s.Normal</code> dan <code>gi.light.dirin</code> .  Untuk mempermudah, kami akan mengganti nama mereka dalam kode shader menjadi <code>N</code> dan <code>L</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Fungsi <code>saturate</code> membatasi nilai dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mn" id="MJXp-Span-65">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  .  Namun, karena produk skalar berada dalam kisaran dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.111em;">âˆ’</span><span class="MJXp-mn" id="MJXp-Span-68">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> -1 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> + 1 </script>  , kita hanya perlu bekerja dengan nilai negatifnya.  Itulah sebabnya refleksi Lambert sering dilaksanakan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  Refleksi kontras cahaya sekitar </h2><br>  Meskipun refleksi Lambert menaungi sebagian besar material, itu tidak akurat secara fisik maupun fotorealistik.  Dalam game yang lebih lama, shader Lambert digunakan secara luas.  Game yang menggunakan teknik ini sering <em>tampak</em> kuno karena secara tidak sengaja dapat mereproduksi estetika game lama.  Jika Anda tidak berusaha untuk ini, maka refleksi Lambert harus dihindari dan menggunakan teknologi yang lebih modern. <br><br>  Salah satu model tersebut adalah model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">refleksi Oren-Nayyar</a> , yang pada awalnya ditetapkan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Generalisasi Lamect's Reflectance Model</a> , yang diterbitkan pada 1994 oleh Michael Oren dan Sri C. Nayyar.  Model Oren-Nayyar adalah generalisasi dari refleksi Lambert dan dirancang khusus untuk permukaan kasar.  Awalnya, pengembang Journey ingin menggunakan refleksi Oren-Nayyar sebagai dasar untuk shader pasir mereka.  Namun, ide ini ditinggalkan karena biaya komputasi yang tinggi. <br><br>  Dalam laporannya tahun 2013, seniman teknis John Edwards menjelaskan bahwa model refleksi yang dibuat untuk Journey sand didasarkan pada serangkaian trial and error. Pengembang bermaksud untuk tidak menciptakan rendering fotorealistik gurun, tetapi untuk menghidupkan kembali kehidupan menjadi beton, estetika yang segera dikenali. <br><br>  Menurutnya, model bayangan yang dihasilkan sesuai dengan persamaan ini: <br><br>  (2) <p><math> </math> $$ menampilkan $$ \ mulai {persamaan *} I = 4 * \ kiri (\ kiri (N \ odot \ kiri [1, 0,3, 1 \ kanan] \ kanan) \ cdot L \ kanan) \ end {persamaan *} $$ tampilan $$ </p><br>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mtext" id="MJXp-Span-96">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> \ odot </script>  - <strong>elemen</strong> - <strong>produk bijak dari</strong> dua vektor. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Reflection Model (2) John Edwards menyebut <strong>kontras kontras</strong> , jadi kami akan menggunakan nama ini sepanjang tutorial. <br><br>  Animasi di bawah ini menunjukkan perbedaan dalam naungan Lambert (kiri) dan kontras yang berbeda dari Journey (kanan). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Apa arti dari 4 dan 0,3?</b> <div class="spoiler_text">  Meskipun perbedaan kontras tidak dirancang untuk akurat secara fisik, kita masih dapat mencoba untuk memahami apa fungsinya. <br><br>  Pada intinya, masih menggunakan refleksi Lambert.  Perbedaan yang jelas pertama adalah bahwa hasil keseluruhan dikalikan dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-25"> 4 </script>  .  Ini berarti bahwa semua piksel yang biasanya diterima <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 </font></font></span><span class="MJXp-mi" id="MJXp-Span-105"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-26"> 25 \% </script>  pencahayaan sekarang akan bersinar seolah menerima <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mn" id="MJXp-Span-107"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 </font></font></span><span class="MJXp-mi" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-27"> 100 \% </script>  pencahayaan.  Dengan mengalikan semuanya dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-28"> 4 </script>  naungan yang lemah menurut Lambert menjadi jauh lebih kuat, dan wilayah transisi antara gelap dan terang lebih kecil.  Dalam hal ini, bayangan menjadi lebih tajam. <br><br>  Pengaruh penggandaan komponen <code>y</code> pada arah normal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mn" id="MJXp-Span-112"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-113" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-114"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span></span><script type="math/tex" id="MathJax-Element-29"> 0,3 </script>  menjelaskan jauh lebih sulit.  Sebagai komponen dari perubahan vektor, arah umum di mana ia menunjuk perubahan.  Mengurangi nilai komponen <code>y</code> untuk semuanya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-115"><span class="MJXp-mn" id="MJXp-Span-116"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mi" id="MJXp-Span-117"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-30"> 30 \% </script>  dari nilai aslinya, pantulan kontras yang menyebar menyebabkan bayangan menjadi lebih vertikal. <br><br>  Catatan: produk skalar secara langsung mengukur sudut antara dua vektor hanya jika keduanya memiliki panjang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mn" id="MJXp-Span-119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-31"> 1 </script>  .  Perubahan yang dibuat mengurangi panjang normal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><script type="math/tex" id="MathJax-Element-32"> N </script>  yang tidak lagi menjadi vektor satuan. </div></div><br><h2>  Dari nuansa abu-abu hingga warna </h2><br>  Semua animasi yang ditunjukkan di atas memiliki nuansa abu-abu, karena mereka menunjukkan nilai-nilai model refleksi mereka, bervariasi dalam interval dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mn" id="MJXp-Span-125">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  ". Kita dapat dengan mudah menambahkan warna dengan menggunakan <code>NdotL</code> sebagai koefisien interpolasi antara dua warna: satu untuk teduh sepenuhnya dan yang lainnya untuk pasir yang menyala sepenuhnya. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Bagian 3. Pasir normal </h2><br>  Pada bagian ketiga, kita akan fokus pada pembuatan peta normal yang mengubah model 3D halus menjadi bukit pasir. <br><br>  Di bagian sebelumnya dari tutorial, kami menerapkan pencahayaan difus dari pasir Journey.  Bila hanya menggunakan efek ini, bukit pasir gurun akan terasa agak datar dan membosankan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  Salah satu efek Journey yang paling menarik adalah butiran pasir.  Melihat screenshot apa pun, tampaknya bagi kita bahwa bukit pasir tidak mulus dan homogen, tetapi dibuat dari jutaan butiran pasir mikroskopis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Efek ini dapat dicapai dengan menggunakan teknik yang disebut <strong>pemetaan benjolan</strong> , yang memungkinkan cahaya memantul dari permukaan datar seolah-olah lebih kompleks.  Lihat bagaimana efek ini mengubah tampilan render: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  Perbedaan kecil dapat dilihat dengan meningkatnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Kami berurusan dengan peta normal </h2><br>  Pasir terdiri dari butiran pasir yang tak terhitung jumlahnya, masing-masing memiliki bentuk dan komposisi sendiri (lihat di bawah).  Setiap partikel individu memantulkan cahaya ke arah yang berpotensi acak.  Salah satu cara untuk mewujudkan efek ini adalah dengan membuat model 3D yang mengandung semua butiran pasir mikroskopis ini.  Tetapi karena banyaknya jumlah poligon yang diperlukan, pendekatan ini tidak layak. <br><br>  Tetapi ada solusi lain yang sering digunakan untuk mensimulasikan geometri yang lebih kompleks dibandingkan dengan model 3D nyata.  Setiap dhuwur atau muka model 3D dikaitkan dengan parameter yang disebut <strong>arah normalnya</strong> .  Ini adalah vektor satuan panjang yang digunakan untuk menghitung pantulan cahaya pada permukaan model 3D.  Artinya, untuk mensimulasikan pasir, Anda perlu mensimulasikan distribusi butiran pasir yang tampaknya acak ini, dan oleh karena itu bagaimana mereka memengaruhi permukaan normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Ini bisa dilakukan dengan banyak cara.  Yang paling sederhana adalah membuat tekstur yang mengubah arah normals asli dari model bukit pasir. <br><br>  <strong>Normal ke permukaan</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> N </script>  dalam kasus umum, dihitung dengan geometri model 3D.  Namun, Anda dapat memodifikasinya menggunakan <strong>peta normal</strong> .  Peta normal adalah tekstur yang memungkinkan Anda mensimulasikan geometri yang lebih kompleks dengan mengubah orientasi lokal normals ke permukaan.  Teknik ini sering disebut <strong>pemetaan benjolan</strong> . <br><br>  Mengubah normals adalah tugas yang cukup sederhana yang dapat dilakukan dalam fungsi <code>surf</code> <strong>permukaan shader</strong> .  Fungsi ini mengambil dua parameter, salah satunya adalah <code>struct</code> disebut <code>SurfaceOutput</code> .  Ini berisi semua properti yang diperlukan untuk rendering bagian dari model 3D, dari warnanya ( <code>o.Albedo</code> ) ke transparansi ( <code>o.Alpha</code> ).  Parameter lain yang dikandungnya adalah arah normal ( <code>o.Normal</code> ), yang dapat ditulis ulang untuk mengubah cara cahaya tercermin pada model. <br><br>  Menurut dokumentasi Unity pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Surface Shaders</a> , semua normals yang ditulis ke struktur <code>o.Normal</code> harus dinyatakan dalam <strong>ruang singgung</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Dengan demikian, kami dapat melaporkan bahwa vektor satuan harus dinyatakan dalam sistem koordinat relatif terhadap normal mesh.  Misalnya, saat menulis ke <code>o.Normal</code> nilai <code>float3(0, 0, 1)</code> normal akan tetap tidak berubah. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Ini karena vektor <code>float3(0, 0, 1)</code> sebenarnya adalah vektor normal yang dinyatakan relatif terhadap geometri model 3D. <br><br>  Jadi, untuk mengubah normal ke permukaan di <strong>permukaan shader</strong> , kita hanya perlu menulis vektor baru di <strong>fungsi permukaan</strong> di <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  Di sisa posting, kita akan membuat perkiraan awal, yang akan kita susun pada bagian keenam dari tutorial. <br><br><h2>  Pasir normal </h2><br>  Bagian yang paling bermasalah adalah memahami <em>bagaimana</em> butiran pasir berubah normal ke permukaan.  Meskipun secara individual setiap butir pasir dapat menyebarkan cahaya ke segala arah, secara keseluruhan, sesuatu yang lain terjadi.  Setiap pendekatan yang akurat secara fisik harus mempelajari distribusi vektor normal pada permukaan pasir dan memodelkannya secara matematis.  Model seperti itu benar-benar ada, tetapi solusi yang disajikan dalam tutorial kami jauh lebih sederhana, dan pada saat yang sama sangat efektif. <br><br>  Pada setiap titik dalam model, <strong>vektor satuan acak</strong> disampel dari tekstur.  Kemudian, normal ke permukaan miring dengan jumlah tertentu ke arah vektor ini.  Dengan terciptanya tekstur acak yang benar dan pemilihan jumlah pencampuran yang tepat, kita dapat menggeser normal ke permukaan sedemikian rupa untuk menciptakan rasa butiran, tanpa kehilangan kelengkungan keseluruhan bukit pasir. <br><br>  Nilai acak dapat disampel menggunakan tekstur yang diisi dengan warna acak.  Komponen R, G, dan B dari setiap piksel digunakan sebagai komponen X, Y, dan Z dari vektor normal.  Komponen warna berada dalam kisaran <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-128"><span class="MJXp-mtext" id="MJXp-Span-129">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">t</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-135">0</span><span class="MJXp-mo" id="MJXp-Span-136" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-137">1</span><span class="MJXp-mtext" id="MJXp-Span-138">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">t</span><span class="MJXp-mo" id="MJXp-Span-144" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> \ left [0, 1 \ right] </script>  , jadi mereka perlu dikonversi ke interval <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-145"><span class="MJXp-mtext" id="MJXp-Span-146">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150">i</span><span class="MJXp-mo" id="MJXp-Span-151" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0.267em; margin-right: 0.267em;">âˆ’</span><span class="MJXp-mn" id="MJXp-Span-153">1</span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-155" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-156">1</span><span class="MJXp-mtext" id="MJXp-Span-157">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">n</span><span class="MJXp-mo" id="MJXp-Span-163" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> \ kiri [-1, + 1 \ kanan] </script>  .  Kemudian vektor yang dihasilkan dinormalisasi sehingga panjangnya sama dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-164"><span class="MJXp-mn" id="MJXp-Span-165">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Buat tekstur acak</b> <div class="spoiler_text">  Ada banyak cara untuk menghasilkan tekstur acak.  Untuk mendapatkan efek yang diinginkan, yang terpenting adalah distribusi umum vektor acak yang dapat disampel dari tekstur. <br><br>  Pada gambar di atas, setiap piksel benar-benar acak.  Tidak ada arah umum (warna) yang berlaku dalam tekstur, karena setiap nilai memiliki probabilitas yang sama dengan yang lainnya.  Tekstur ini memberi kita sejenis pasir yang menyebarkan cahaya ke segala arah. <br><br>  Selama pembicaraan GDC, John Edwards memperjelas bahwa tekstur acak yang digunakan untuk pasir di Journey dihasilkan dari distribusi Gaussian.  Ini memastikan bahwa arah yang berlaku bertepatan dengan normal ke permukaan. </div></div><br><div class="spoiler">  <b class="spoiler_title">Apakah vektor acak perlu dinormalisasi?</b> <div class="spoiler_text">  Gambar yang saya gunakan untuk sampel vektor acak dihasilkan menggunakan proses yang sepenuhnya acak.  Tidak hanya setiap piksel yang dihasilkan secara individual: komponen R, G dan B dari satu piksel juga tidak tergantung satu sama lain.  Artinya, dalam kasus umum, vektor sampel dari tekstur ini tidak akan dijamin memiliki panjang yang sama dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-166"><span class="MJXp-mn" id="MJXp-Span-167"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-39"> 1 </script>  . <br><br>  Tentu saja, Anda dapat menghasilkan tekstur di mana setiap piksel saat mengkonversi dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-168"><span class="MJXp-mtext" id="MJXp-Span-169">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-173"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-174" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-176" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-177"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-183"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-178">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-183"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-40"> \ left [0, 1 \ right] </script>  masuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-185"><span class="MJXp-mtext" id="MJXp-Span-186">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190">i</span><span class="MJXp-mo" id="MJXp-Span-191" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0.267em; margin-right: 0.267em;">âˆ’</span><span class="MJXp-mn" id="MJXp-Span-193">1</span><span class="MJXp-mo" id="MJXp-Span-194" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-195" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-196">1</span><span class="MJXp-mtext" id="MJXp-Span-197">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202">n</span><span class="MJXp-mo" id="MJXp-Span-203" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-41"> \ kiri [-1, + 1 \ kanan] </script>  dan sebenarnya harus memiliki panjang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-mn" id="MJXp-Span-205">1</span></span></span><script type="math/tex" id="MathJax-Element-42"> 1 </script>  .  Namun, dua masalah muncul di sini. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Implementasi </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian sebelumnya tutorial, kami memperkenalkan konsep "peta normal" ketika muncul di garis pertama </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi permukaan</font></font></strong> <code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mengingat diagram yang ditunjukkan di awal artikel, Anda dapat melihat bahwa dua efek diperlukan untuk membuat ulang rendering pasir Journey. Yang pertama ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasir normal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) yang kita </font><em><font style="vertical-align: inherit;">bahas</font></em><font style="vertical-align: inherit;"> di bagian artikel ini, dan yang kedua ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gelombang pasir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kita pelajari di bagian keenam.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian sebelumnya, kami memperkenalkan konsep pemetaan benjolan, yang menunjukkan kepada kami bahwa bagian dari efek akan memerlukan pengambilan sampel tekstur (disebut dalam kode </font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dengan kode di atas adalah bahwa untuk perhitungan Anda perlu mengetahui posisi sebenarnya dari titik yang kita gambar. Faktanya, Anda memerlukan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">koordinat UV</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk sampel tekstur </font><font style="vertical-align: inherit;">, yang menentukan piksel mana yang akan dibaca. Jika model 3D yang kita gunakan relatif datar dan memiliki konversi UV, maka kita dapat menggunakan UV-nya untuk sampel tekstur acak.</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atau Anda juga dapat menggunakan posisi di dunia ( </font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dari titik yang diberikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita akhirnya bisa fokus pada </font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementasinya. </font><font style="vertical-align: inherit;">Seperti yang dinyatakan sebelumnya di bagian ini, idenya adalah untuk mengambil sampel piksel dari tekstur acak dan menggunakannya (setelah dikonversi ke vektor satuan) sebagai normal baru.</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara memperbesar tekstur acak?</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Miringkan normals </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuplikan kode yang ditunjukkan di atas berfungsi, tetapi tidak memberikan hasil yang sangat baik. Alasannya sederhana: jika kita hanya mengembalikan normal secara acak, tetapi pada dasarnya kehilangan perasaan kelengkungan. Bahkan, arah normal digunakan untuk menghitung bagaimana cahaya harus dipantulkan dari permukaan, dan tujuan utamanya adalah untuk menaungi model sesuai dengan kelengkungannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaannya bisa dilihat pada gambar di bawah ini. Di atas, normals dari bukit pasir sepenuhnya acak, dan tidak mungkin untuk memahami di mana ujung yang satu dan yang lainnya dimulai. Dari bawah, hanya model normal yang digunakan, karena itu permukaannya terlalu halus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua solusi tidak cocok untuk kita. </font><font style="vertical-align: inherit;">Kami membutuhkan sesuatu di antaranya. </font><font style="vertical-align: inherit;">Arah acak yang diambil dari tekstur harus digunakan untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiringkan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normal dengan jumlah tertentu, seperti yang ditunjukkan di bawah ini:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi yang dijelaskan dalam diagram disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan singkatan dari </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linear bola (interpolasi linear bola). </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekerja persis sama dengan lerp, dengan satu pengecualian - dapat digunakan untuk interpolasi dengan aman di antara vektor satuan, dan hasil operasi akan menjadi vektor satuan lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, implementasi slerp yang benar cukup mahal. </font><font style="vertical-align: inherit;">Dan untuk efeknya, setidaknya berdasarkan kebetulan, tidak logis untuk menggunakannya.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunjukkan pada saya persamaan slerp</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-206"><span class="MJXp-msubsup" id="MJXp-Span-207"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-209" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-210"><span class="MJXp-msubsup" id="MJXp-Span-211"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-213" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script>   ,       .  Lalu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-214"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-218">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">p</span></span></span><script type="math/tex" id="MathJax-Element-45">slerp</script>    : <br><br> (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-220"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-224">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-225">p</span><span class="MJXp-mrow" id="MJXp-Span-226"><span class="MJXp-mo" id="MJXp-Span-227" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-228"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-230" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-231" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-234" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-236">t</span><span class="MJXp-mo" id="MJXp-Span-237" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-238" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-239" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-240">sin</span><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-242"><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-244"><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-246">1</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0.267em; margin-right: 0.267em;">âˆ’</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-248">t</span><span class="MJXp-mo" id="MJXp-Span-249" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-250">Î©</span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-252">sin</span><span class="MJXp-mo" id="MJXp-Span-253" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-254"><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-256">Î©</span><span class="MJXp-mo" id="MJXp-Span-257" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-258"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-260" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-261" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-262" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-263">sin</span><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-265"><span class="MJXp-mo" id="MJXp-Span-266" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267">t</span><span class="MJXp-mi" id="MJXp-Span-268">Î©</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-270">sin</span><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-272"><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-274">Î©</span><span class="MJXp-mo" id="MJXp-Span-275" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-276"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-278" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-46">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-279"><span class="MJXp-mi" id="MJXp-Span-280">Î©</span></span></span><script type="math/tex" id="MathJax-Element-47">\Omega</script> â€”     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-281"><span class="MJXp-msubsup" id="MJXp-Span-282"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-283" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-284" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-48">p_0</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-285"><span class="MJXp-msubsup" id="MJXp-Span-286"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-287" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-288" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-49">p_1</script> ,       : <br><br> (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-289"><span class="MJXp-mi" id="MJXp-Span-290">Î©</span><span class="MJXp-mo" id="MJXp-Span-291" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293">o</span><span class="MJXp-msubsup" id="MJXp-Span-294"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-295" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-296" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-297">âˆ’</span><span class="MJXp-mn" id="MJXp-Span-298">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-299"><span class="MJXp-mo" id="MJXp-Span-300" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-301"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-302" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-303" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-304" style="margin-left: 0.267em; margin-right: 0.267em;">â‹…</span><span class="MJXp-msubsup" id="MJXp-Span-305"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-306" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-307" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-308" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk dicatat bahwa jika kita menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolasi linier</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tradisional </font><font style="vertical-align: inherit;">, vektor yang dihasilkan akan terlihat sangat berbeda:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operasi Lerp antara dua vektor satuan yang terpisah tidak selalu membuat vektor satuan lainnya. </font><font style="vertical-align: inherit;">Sebenarnya, ini tidak pernah terjadi, kecuali jika koefisiennya</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mn" id="MJXp-Span-310"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51">1</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-311"><span class="MJXp-mn" id="MJXp-Span-312"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52">0</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meskipun demikian, menormalkan hasil lerp sebenarnya menghasilkan vektor satuan yang secara mengejutkan mendekati hasil yang dihasilkan oleh slerp: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknik ini, yang disebut </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , memberikan perkiraan dekat dari slerp. </font><font style="vertical-align: inherit;">Penggunaannya dipopulerkan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casey Muratori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , salah satu pengembang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witness</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda tertarik untuk mempelajari lebih lanjut tentang topik ini, saya sarankan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memahami artikel Slerp. </font><font style="vertical-align: inherit;">Then Not Using It oleh </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonathan Blow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math Magician - Lerp, Slerp, dan Nlerp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat nlerp, sekarang kita dapat memiringkan vektor normal secara efisien ke sisi acak, diambil sampel dari </font></font><code>_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasilnya ditunjukkan di bawah ini: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Apa selanjutnya </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada bagian selanjutnya, kita akan mempertimbangkan refleksi yang berkelap-kelip, berkat bukit-bukit pasir yang akan menyerupai lautan. </font></font><br><br><h3>  Ucapan Terima Kasih </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permainan video </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikembangkan oleh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan diterbitkan oleh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini tersedia untuk PC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan PS4 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model 3D latar belakang bukit pasir dan opsi pencahayaan diciptakan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jiadi Deng</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model 3D karakter Journey ditemukan di forum FacePunch (sekarang sudah ditutup).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket Persatuan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin membuat ulang efek ini, maka paket Unity lengkap dapat diunduh dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini mencakup semua yang Anda butuhkan, dari shader hingga model 3D.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476448/">https://habr.com/ru/post/id476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476434/index.html">Kami menulis driver USB untuk perangkat yang ditinggalkan</a></li>
<li><a href="../id476436/index.html">Laporan dari pertemuan pertama di Rusia tentang pengembang robot tentang Sistem Operasi Robot</a></li>
<li><a href="../id476442/index.html">Berikan ruang atau mikrokontroler seperti pengukur frekuensi</a></li>
<li><a href="../id476444/index.html">Demistifikasi prinsip-prinsip komputasi kuantum</a></li>
<li><a href="../id476446/index.html">Jira Plugins: Beberapa Contoh Penemuan Sepeda yang Berhasil</a></li>
<li><a href="../id476450/index.html">Gambaran umum cPanel - konsol berbasis web untuk mengelola situs dan hosting</a></li>
<li><a href="../id476452/index.html">Penyimpanan bernilai kunci, atau bagaimana aplikasi kita menjadi lebih nyaman</a></li>
<li><a href="../id476454/index.html">5G akan datang: perusahaan mana yang akan memastikan pengenalan teknologi baru pada tahun 2020</a></li>
<li><a href="../id476456/index.html">Sistem kredit sosial Cina, pertama-tama, bukan sistem penilaian warga, tetapi API besar-besaran</a></li>
<li><a href="../id476460/index.html">Format file hit pertama di Internet bukan MP3, tetapi MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>