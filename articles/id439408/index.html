<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ö üôåüèΩ üòë Pseudo Lens Flare üê∞ üí™üèæ üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Pseudo Lens Flare" oleh John Chapman. 



 Lens suar (lens suar) adalah artefak fotog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pseudo Lens Flare</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439408/">  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pseudo Lens Flare"</a> oleh John Chapman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/905/ced/087/905ced087e506e2a67793bb663eb43f9.png" alt="gambar"><br><br>  <b>Lens suar</b> (lens suar) adalah artefak fotografi yang timbul dari hamburan dan pembiasan cahaya dalam sistem lensa.  Meskipun ini adalah artefak, ada banyak alasan untuk menggunakan <b>suar lensa</b> dalam grafik komputer: <br><br><ul><li>  itu meningkatkan kecerahan yang dirasakan dan rentang dinamis gambar yang terlihat. </li><li>  <b>suar lensa</b> sering ditemukan dalam foto, sehingga ketidakhadirannya bisa mencolok </li><li>  itu dapat memainkan peran penting dalam gaya atau drama, atau dapat menjadi bagian dari gameplay dalam game (bayangkan silau membutakan pemain) </li></ul><br>  Secara tradisional, <b>suar lensa</b> secara realtime telah diimplementasikan menggunakan teknologi berbasis sprite.  Meskipun sprite memberikan hasil yang mudah dikontrol dan sangat realistis, mereka harus ditempatkan secara eksplisit dan membutuhkan data oklusi untuk ditampilkan dengan benar.  Di sini saya akan menjelaskan efek ruang layar yang sederhana dan relatif murah yang menciptakan <b>suar lensa</b> semu dari buffer warna input.  Ini tidak didasarkan pada fisika, sehingga hasilnya sedikit berbeda dari yang fotorealistik, tetapi dapat digunakan dalam kombinasi dengan (atau sebagai pengganti) untuk efek berbasis sprite tradisional. <br><a name="habracut"></a><br><h2>  Algoritma </h2><br>  Terdiri dari 4 tahap: <br><br><ol><li>  Downsample / ambang batas. </li><li>  Generasi elemen <b>suar lensa</b> . </li><li>  Kabur </li><li>  Kelas atas / blending dengan gambar asli. </li></ol><br><h3>  1. Downsample / Ambang Batas </h3><br>  <b>Downsampling</b> - optimisasi untuk mengurangi biaya langkah selanjutnya.  Selain itu, kami ingin memilih subset piksel paling terang di gambar asli.  Menggunakan <b>skala / bias</b> (skala / bias) menyediakan cara yang fleksibel untuk mencapai ini: <br><br><pre><code class="cpp hljs">uniform sampler2D uInputTex; uniform vec4 uScale; uniform vec4 uBias; noperspective in vec2 vTexcoord; out vec4 fResult; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fResult = max(vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), texture(uInputTex, vTexcoord) + uBias) * uScale; }</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/35d/775/c6d/35d775c6d8258a1485f52cb92b6430e5.jpg" alt="gambar"><br><br>  Penyesuaian <b>skala / bias</b> adalah cara utama untuk menyesuaikan efek;  pengaturan terbaik akan tergantung pada rentang dinamis buffer warna, serta seberapa tipis Anda ingin melihat hasilnya.  Karena fakta bahwa tekniknya adalah pendekatan, kehalusan lebih cenderung terlihat lebih baik. <br><br><h3>  2. Generasi elemen suar lensa </h3><br>  Elemen <b>suar lensa</b> cenderung berputar di tengah gambar.  Dengan mensimulasikan efek ini, kita dapat memperluas hasil tahap sebelumnya secara horizontal / vertikal.  Ini mudah dilakukan pada tahap pembuatan elemen dengan memperluas koordinat tekstur: <br><br><pre> <code class="cpp hljs">vec2 texcoord = -vTexcoords + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre><br>  Ini tidak perlu;  pembuatan elemen bekerja dengan baik dengan dan tanpa itu.  Namun, hasil perubahan koordinat tekstur membantu memisahkan secara visual efek <b>suar lensa</b> dari gambar asli. <br><br><h4>  Hantu </h4><br>  " <b>Hantu</b> " (hantu) mengulangi sorotan yang mencerminkan area terang di buffer warna, terbentang relatif ke tengah gambar.  Pendekatan yang saya pilih untuk menghasilkan adalah untuk mendapatkan vektor dari piksel saat ini ke tengah layar, dan kemudian membuat beberapa pilihan di sepanjang vektor ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/a06/097/305a06097b4e8ea7917a3635eb28f308.jpg" alt="gambar"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; uniform <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uGhosts; <span class="hljs-comment"><span class="hljs-comment">// number of ghost samples uniform float uGhostDispersal; // dispersion factor noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec2 texcoord = -vTexcoord + vec2(1.0); vec2 texelSize = 1.0 / vec2(textureSize(uInputTex, 0)); // ghost vector to image centre: vec2 ghostVec = (vec2(0.5) - texcoord) * uGhostDispersal; // sample ghosts: vec4 result = vec4(0.0); for (int i = 0; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * float(i)); result += texture(uInputTex, offset); } fResult = result; }</span></span></code> </pre><br>  Perhatikan bahwa saya menggunakan <i>fract ()</i> untuk memastikan bahwa koordinat tekstur membungkus;  ekuivalen Anda dapat menggunakan mode bungkus <i>GL_REPEAT</i> untuk tekstur. <br><br>  Inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/204/502/804/204502804fdf82167d0748821d8bac72.jpg" alt="gambar"><br><br>  Anda dapat meningkatkan hasilnya dengan hanya mengizinkan area terang lebih dekat ke tengah gambar untuk menghasilkan hantu.  Kami dapat mencapai ini dengan menambahkan bobot yang akan berkurang dari pusat sampel: <br><br><pre> <code class="cpp hljs">vec4 result = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; uGhosts; ++i) { vec2 offset = fract(texcoord + ghostVec * <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(i)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - offset) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)); weight = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - weight, <span class="hljs-number"><span class="hljs-number">10.0</span></span>); result += texture(uInputTex, offset) * weight; }</code> </pre><br>  Fungsi beratnya sesederhana mungkin - linier.  Alasan kami menghitung berat di dalam loop adalah karena area terang di tengah gambar input dapat "melemparkan" hantu ke perbatasan, tetapi area terang di perbatasan tidak dapat melemparkan hantu ke tengah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/c83/d61/0bdc83d61fc9195c6578bd37145d3aed.jpg" alt="gambar"><br><br>  Peningkatan terakhir adalah perubahan warna radial hantu, sesuai dengan tekstur 1D: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/591/5c9/199/5915c9199899554fd2b545a9e882c5cc.jpg" alt="gambar"><br><br>  Ini diterapkan setelah siklus untuk mempengaruhi warna akhir hantu: <br><br><pre> <code class="cpp hljs">result *= texture(uLensColor, length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) - texcoord) / length(vec2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)));</code> </pre><br><h4>  HALOS (lingkaran cahaya) </h4><br>  Jika kita mengambil vektor ke tengah gambar, seperti dalam perhitungan <b>hantu</b> , tetapi memperbaiki panjang vektor, kita mendapatkan efek yang berbeda: gambar asli terdeformasi secara radial: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/280/b54/c7d280b54391cc3507c3f3c5cd713078.jpg" alt="gambar"><br>  Kita dapat menggunakan ini untuk membuat "halo" dengan mengalikan berat dengan sampel, sehingga membatasi kontribusi gambar cacat ke cincin yang jari-jarinya dikendalikan oleh <b>uHaloWidth</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// sample halo: vec2 haloVec = normalize(ghostVec) * uHaloWidth; float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5)); weight = pow(1.0 - weight, 5.0); result += texture(uInputTex, texcoord + haloVec) * weight;</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/bad/cdb/40a/badcdb40a06b62ba0732b8fa54fe2f88.jpg" alt="gambar"><br><br><h4>  DISTORSI KROMATIK (distorsi warna) </h4><br>  Beberapa suar lensa memiliki distorsi warna yang disebabkan oleh variasi dalam refraksi cahaya pada panjang gelombang yang berbeda.  Kita dapat mensimulasikan ini dengan membuat fungsi yang memilih saluran merah, hijau, dan biru secara terpisah dengan offset yang sedikit berbeda di sepanjang vektor sampel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textureDistorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( in sampler2D tex, in vec2 texcoord, in vec2 direction, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// direction of distortion in vec3 distortion // per-channel distortion factor ) { return vec3( texture(tex, texcoord + direction * distortion.r).r, texture(tex, texcoord + direction * distortion.g).g, texture(tex, texcoord + direction * distortion.b).b ); }</span></span></span></span></span></span></code> </pre><br>  Ini dapat digunakan sebagai pengganti langsung untuk <b>tekstur</b> panggilan <b>()</b> dalam daftar sebelumnya.  Saya menghitung <b>arah</b> dan <b>distorsi</b> sebagai berikut: <br><br><pre> <code class="cpp hljs">vec2 texelSize = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / vec2(textureSize(uInputTex, <span class="hljs-number"><span class="hljs-number">0</span></span>)); vec3 distortion = vec3(-texelSize.x * uDistortion, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, texelSize.x * uDistortion); vec3 direction = normalize(ghostVec);</code> </pre><br>  Meskipun fungsi pengambilannya sederhana, biaya sampel x3 dari tekstur, meskipun mereka semua harus ramah cache kecuali Anda mengatur <b>uDistortion</b> ke beberapa nilai raksasa. <br><br>  Dengan generasi elemen, semuanya.  Inilah hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a8/fea/9e7/2a8fea9e783d8b254d2c738fc3362a45.jpg" alt="gambar"><br><br><h3>  3. Kabur </h3><br>  Tanpa buram, elemen <b>suar lensa</b> (khususnya, hantu) cenderung mempertahankan tampilan gambar.  Dengan menambahkan blur ke elemen <b>suar lensa</b> , kami melemahkan frekuensi tinggi dan dengan demikian mengurangi kontras dengan gambar input, yang membantu kami menjual efeknya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/bad/099/93fbad09987037e5d1fd5aa29441bc5c.jpg" alt="gambar"><br><br>  Saya tidak akan memberi tahu cara membuat buram;  Anda dapat membacanya di berbagai sumber daya Internet (Gaussian blur). <br><br><h3>  4. Kelas atas / menyatu dengan gambar asli </h3><br>  Jadi, kita memiliki elemen <b>suar lensa</b> kita, kabur dengan baik.  Bagaimana kita bisa menggabungkannya dengan gambar sumber asli?  Ada beberapa pertimbangan penting mengenai seluruh pipa render: <br><br><ul><li>  Setiap <b>kekaburan gerakan</b> atau <b>kedalaman bidang selanjutnya</b> harus diterapkan sebelum digabungkan dengan <b>suar lensa</b> , sehingga elemen <b>suar lensa</b> tidak akan ikut serta dalam efek ini. </li><li>  <b>Suar lensa</b> harus diterapkan sebelum melakukan <b>pemetaan ton</b> .  Ini masuk akal secara fisik, karena <b>tonemapping</b> meniru respons film / CMOS terhadap cahaya yang masuk, di mana <b>suar lensa</b> merupakan bagian integral. </li></ul><br>  Dengan mengingat hal itu, ada beberapa hal yang dapat kita lakukan pada tahap ini untuk meningkatkan hasilnya: <br><br><h4>  LENS DIRT </h4><br>  Pertama, Anda perlu memodifikasi elemen <b>suar lensa</b> dengan tekstur kotor dalam resolusi penuh (yang banyak digunakan di Battlefield 3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c1/f6a/f9e/6c1f6af9e3c34aeff34a174870c31f74.jpg" alt="gambar"><br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  Kunci untuk ini adalah tekstur yang sangat kotor pada lensa.  Jika kontrasnya rendah, bentuk <b>suar lensa</b> cenderung mendominasi hasilnya.  Dengan meningkatnya kontras, elemen <b>suar lensa</b> teredam, yang memberikan tampilan estetika yang berbeda dan juga menyembunyikan beberapa cacat. <br><br><h4>  STARBURST DIFFRACTION </h4><br>  Sebagai peningkatan tambahan, kita dapat menggunakan tekstur <b>starburst</b> dengan menambahkannya ke <b>kotoran lensa</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23b/81b/27e/23b81b27e47a3f5983b649ea0d368edb.jpg" alt="gambar"><br>  Sebagai tekstur, <b>starburst</b> tidak terlihat sangat bagus.  Namun demikian, kita dapat meneruskan matriks transformasi ke shader, yang akan memungkinkan kita untuk memutar / merusak <b>starburst</b> setiap frame dan mendapatkan efek dinamis yang diinginkan: <br><br><pre> <code class="cpp hljs">uniform sampler2D uInputTex; <span class="hljs-comment"><span class="hljs-comment">// source image uniform sampler2D uLensFlareTex; // input from the blur stage uniform sampler2D uLensDirtTex; // full resolution dirt texture uniform sampler2D uLensStarTex; // diffraction starburst texture uniform mat3 uLensStarMatrix; // transforms texcoords noperspective in vec2 vTexcoord; out vec4 fResult; void main() { vec4 lensMod = texture(uLensDirtTex, vTexcoord); vec2 lensStarTexcoord = (uLensStarMatrix * vec3(vTexcoord, 1.0)).xy; lensMod += texture(uLensStarTex, lensStarTexcoord); vec4 lensFlare = texture(uLensFlareTex, vTexcoord) * lensMod; fResult = texture(uInputTex, vTexcoord) + lensflare; }</span></span></code> </pre><br>  <b>Matriks</b> transformasi <b>uLensStarMatrix</b> didasarkan pada nilai yang diperoleh dari orientasi kamera sebagai berikut: <br><br><pre> <code class="cpp hljs">vec3 camx = cam.getViewMatrix().col(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// camera x (left) vector vec3 camz = cam.getViewMatrix().col(1); // camera z (forward) vector float camrot = dot(camx, vec3(0,0,1)) + dot(camz, vec3(0,1,0));</span></span></code> </pre><br>  Ada cara lain untuk mendapatkan nilai camrot;  yang paling penting, itu harus berubah terus menerus ketika kamera diputar.  Matriks itu sendiri dibangun sebagai berikut: <br><br><pre> <code class="cpp hljs">mat3 scaleBias1 = ( <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 rotation = ( <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), -<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(camrot), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(camrot), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ); mat3 scaleBias2 = ( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, ); mat3 uLensStarMatrix = scaleBias2 * rotation * scaleBias1;</code> </pre><br>  Matriks <b>skala</b> dan <b>bias</b> membutuhkan offset asal tekstur sehingga kita dapat memutar <b>starburst</b> relatif ke tengah gambar. <br><br><h2>  Kesimpulan </h2><br>  Jadi sekarang semuanya!  Metode ini menunjukkan bagaimana proses pos yang relatif disederhanakan memberikan <b>suar lensa yang</b> tampak layak.  Ini tidak sepenuhnya fotorealistik, tetapi jika digunakan dengan benar, itu dapat menghasilkan hasil yang sangat baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a8/168/c34/8a8168c3447b9f9b97c7c240557e2f32.jpg" alt="gambar"><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AjSr0zLBnx8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">UPD</b> <div class="spoiler_text">  Penulis juga menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> dengan sedikit optimasi. <br>  Kode sumber dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439408/">https://habr.com/ru/post/id439408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439392/index.html">Musim kejuaraan 2019 terbuka! SNA Hackathon Ala ML Boot Camp 8 dimulai</a></li>
<li><a href="../id439394/index.html">Sebagai seorang programmer, kernel datacenter menulis</a></li>
<li><a href="../id439396/index.html">Setel Ulang Kata Sandi Pengontrol UniFi</a></li>
<li><a href="../id439402/index.html">JavaScript: The Big Whole Well Why</a></li>
<li><a href="../id439404/index.html">Sejarah singkat pengadaan publik elektronik di Rusia</a></li>
<li><a href="../id439410/index.html">Jeff Hawkins akhirnya siap menjelaskan penelitian otaknya</a></li>
<li><a href="../id439414/index.html">Klien untuk "Server Pesan Push"</a></li>
<li><a href="../id439416/index.html">Artikel Peninjauan A-Frame</a></li>
<li><a href="../id439418/index.html">Integrasi Data Pentaho (PDI), Python dan Deep Learning</a></li>
<li><a href="../id439420/index.html">Membangun paket transportasi tanpa menginstal MODX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>