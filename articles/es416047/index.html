<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÜ üèπ üëæ Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 2: "Control de ataques de hackers", parte 2 üë∏üèΩ üë∂üèº üö£üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnolog√≠a de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas inform√°ticos". Nikolai Zeldovich, James Mickens. A√±o 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 2: "Control de ataques de hackers", parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Instituto de Tecnolog√≠a de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas inform√°ticos".  Nikolai Zeldovich, James Mickens.  A√±o 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementaci√≥n de sistemas inform√°ticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y t√©cnicas de seguridad basadas en trabajos cient√≠ficos recientes.  Los temas incluyen seguridad del sistema operativo (SO), caracter√≠sticas, gesti√≥n del flujo de informaci√≥n, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lecci√≥n 1: "Introducci√≥n: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Entonces, tenemos un buffer sobre el cual colocamos el "canario".  Por encima de eso est√° el puntero del punto de interrupci√≥n <b>guardado, el</b> valor <b>EBP guardado</b> y la direcci√≥n de retorno se coloca encima de √©l.  Si recuerdas, el desbordamiento va de abajo hacia arriba, as√≠ que antes de llegar a la direcci√≥n del remitente, primero destruir√° el "canario". <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Audiencia:</b> ¬øpor qu√© afectar√° al "canario"? <br><br>  <b>Profesor:</b> porque se supone que el atacante no sabe "saltar" arbitrariamente en la memoria.  Los ataques tradicionales de desbordamiento de memoria comienzan con un pirata inform√°tico que examina el l√≠mite de tama√±o del b√∫fer, despu√©s de lo cual el desbordamiento comienza desde el fondo.  Pero tiene raz√≥n: si un atacante puede entrar directamente en la barra de direcci√≥n de retorno, ning√∫n "canario" nos ayudar√°.  Sin embargo, con un ataque tradicional de desbordamiento del b√∫fer, todo deber√≠a suceder exactamente de esa manera, de abajo hacia arriba. <br><br>  Por lo tanto, la idea principal de usar un "canario" es que permitimos que un exploit malicioso desborde el b√∫fer de memoria.  Tenemos un c√≥digo de tiempo de ejecuci√≥n que, al regresar de una funci√≥n, verifica el "canario" para asegurarse de que tenga el valor correcto. <br><br>  <b>Audiencia:</b> ¬øPuede un atacante reescribir la direcci√≥n del remitente y cambiar el "canario"?  ¬øC√≥mo puede verificar que ha sido modificado, pero que contin√∫a cumpliendo su funci√≥n? <br><br>  <b>Profesor:</b> s√≠, tal vez.  Por lo tanto, debe tener alg√∫n c√≥digo que realmente verifique esto antes de que la funci√≥n regrese.  Es decir, en este caso, es necesario contar con el apoyo de un compilador, que en realidad ampliar√° la <b>convenci√≥n de llamadas</b> .  De modo que parte de la secuencia de retorno ocurre antes de considerar la validez de este valor para asegurarnos de que el "canario" no haya sido destruido.  Solo despu√©s de eso podemos pensar en otra cosa. <br><br>  <b>P√∫blico:</b> ¬øNo puede un atacante saber o adivinar qu√© significa "canario"? <br><br>  <b>Profesor: ¬°</b> esto es exactamente de lo que voy a hablar!  ¬øCu√°l es el problema con este circuito?  ¬øQu√© pasa si, por ejemplo, ponemos el valor A en cada programa?  ¬øO toda una rama de 4 valores de A?  Por supuesto, cualquier hacker puede averiguar el tama√±o del b√∫fer, su capacidad y as√≠ determinar la posici√≥n del "canario" en cualquier sistema.  Por lo tanto, podemos usar diferentes tipos de cantidades que ponemos en nuestro "canario" para evitar esto. <br><br>  Hay una cosa que puedes hacer con nuestro "canario".  Ser√° un tipo muy divertido de "canario", que utiliza funciones de programa en C y procesa caracteres especiales, el llamado tipo determinista de "canario". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Imagine que utiliza el car√°cter 0 para el "canario". El valor binario de cero es el byte cero, el car√°cter cero en ASCII.  Un valor de -1 significa un retorno a la posici√≥n anterior y as√≠ sucesivamente.  Muchas funciones detienen o cambian la operaci√≥n cuando encuentran caracteres o valores como 0, CR, LF, -1.  Imagine que usted, como hacker, utiliza alguna funci√≥n de gesti√≥n de cadenas para subir el b√∫fer, encuentra el car√°cter 0 en el "canario" y el proceso se detiene.  Si utiliza la funci√≥n "retorno de carro" -1, que a menudo se utiliza como un terminador de l√≠nea, el proceso tambi√©n se detendr√°.  Entonces -1 es otro signo m√°gico. <br><br>  Hay una cosa m√°s que se puede usar en el "canario": estos son valores aleatorios que son dif√≠ciles de adivinar para el atacante.  El poder del valor aleatorio se basa en lo dif√≠cil que es para un atacante adivinarlo.  Por ejemplo, si un atacante se da cuenta de que solo hay 3 bits de entrop√≠a en su sistema, podr√° usar un ataque de fuerza bruta.  Por lo tanto, las posibilidades de usar n√∫meros aleatorios para protegerse contra los ataques son bastante limitadas. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>P√∫blico:</b> generalmente sucede que leo de otro b√∫fer y escribo lo que leo en este b√∫fer de esta pila.  En esta situaci√≥n, parece que el valor aleatorio del "canario" es in√∫til, porque leo los datos de otro b√∫fer y s√© d√≥nde est√° el "canario".  Tengo otro b√∫fer que controlo y que nunca verifico.  Y en este b√∫fer puedo poner mucho de lo que quiero poner.  No necesito un "canario" aleatorio, porque puedo reescribirlo de manera segura.  As√≠ que no veo c√≥mo funciona realmente: en el escenario que propusiste, cuando la funci√≥n se detiene al leer datos del b√∫fer. <br><br>  <b>Profesor:</b> Entiendo su pregunta, quiere decir que usamos un "canario" determinista, pero no utilizamos una de las funciones de la biblioteca est√°ndar que puede ser "enga√±ada" por nuestros caracteres 0, CR, LF, -1.  Entonces s√≠, en la situaci√≥n que describi√≥, no se necesita un "canario". <br><br>  La idea es que puede llenar este b√∫fer con bytes desde cualquier lugar, pero cualquier cosa que le permita adivinar estos valores u obtenerlos aleatoriamente provocar√° un error. <br><br>  <b>Audiencia:</b> ¬øEs posible usar algo como el n√∫mero de segundos o milisegundos como n√∫meros aleatorios y usarlos en un "canario"? <br><br>  <b>Profesor:</b> Las llamadas de datos no contienen tantos accidentes como cree.  Porque el programa tiene registros o una funci√≥n a la que puede llamar para averiguar cu√°ndo se descarg√≥ el programa y otras cosas similares.  Pero, en general, tiene raz√≥n: en la pr√°ctica, si puede usar un dispositivo de hardware, generalmente de bajo nivel, con mejores tiempos de sistema, este tipo de enfoque puede funcionar. <br><br>  <b>P√∫blico:</b> incluso si logramos ver los registros sobre el comienzo del desbordamiento del b√∫fer, a√∫n es importante a qu√© hora rechazamos la solicitud.  Y si no podemos obtener el control sobre el tiempo que demora la solicitud de una computadora al servidor, es dudoso que se pueda adivinar de manera determinista el tiempo exacto. <br><br>  <b>Profesor:</b> muy cierto, ya dije que el mal yace en los detalles, este es solo un caso.  En otras palabras, si tiene alguna manera de, por ejemplo, determinar el tipo de canal de tiempo, puede encontrar que la cantidad de entrop√≠a, o el n√∫mero de aleatoriedad, no llena una marca de tiempo completa, sino mucho menos.  Por lo tanto, un atacante puede determinar la hora y los minutos cuando hizo esto, pero no un segundo. <br><br>  <b>P√∫blico:</b> para el registro, ¬øtratar de reducir su propia aleatoriedad es una mala idea? <br><br>  <b>Profesor:</b> absolutamente cierto! <br><br>  <b>P√∫blico:</b> es decir, generalmente solo tenemos que usar todo lo que nuestros sistemas admiten, ¬øverdad? <br><br>  <b>Profesor:</b> s√≠, eso es verdad.  Esto es como la invenci√≥n de nuestro propio criptosistema, que es otra cosa popular que nuestros graduados a veces quieren hacer.  Pero no somos la NSA, no somos matem√°ticos, por lo que esto generalmente falla.  Entonces tienes toda la raz√≥n al respecto. <br><br>  Pero incluso si usa la aleatoriedad del sistema, a√∫n puede obtener menos bits de entrop√≠a de lo esperado.  Perm√≠teme darte un ejemplo de aleatorizaci√≥n de fase de direcciones.  Es sobre este principio que el enfoque de <b>canarios de pila funciona</b> .  Dado que estamos comprometidos con la seguridad inform√°tica, probablemente se est√© preguntando en qu√© casos los "canarios" no pueden hacer frente a su tarea y si hay formas de fallar al "canario". <br><br>  Una de esas formas es un ataque reescribiendo punteros de funci√≥n.  Porque si se golpea el puntero de la funci√≥n, el "canario" no puede hacer nada. <br><br>  Supongamos que tiene un c√≥digo de la forma <b>int * ptr ... ..</b> , el puntero iniciador, no importa c√≥mo, entonces tiene el buffer <b>char buf [128]</b> , la funci√≥n <b>gets (buf)</b> , y en la parte inferior un puntero al que se le asigna alg√∫n valor : <b>* ptr = 5</b> . <br><br>  Observo que no intentamos atacar la direcci√≥n de retorno de la funci√≥n que contiene este c√≥digo.  Como puede ver, cuando el b√∫fer se desborda, la direcci√≥n del puntero ubicada arriba se da√±ar√°.  Si un atacante puede da√±ar este puntero, puede asignar 5 a una de las direcciones que controla.  ¬øPueden ver todos que el "canario" no ayudar√° aqu√≠?  Porque no atacamos el camino por el que regresa la funci√≥n. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>P√∫blico: ¬ø</b> se puede ubicar el puntero debajo del b√∫fer? <br><br>  <b>Profesor:</b> puede, pero el orden de las variables espec√≠ficas depende de muchas cosas diferentes, de la forma en que el compilador organiza el contenido, del tama√±o de la columna de hardware, etc.  Pero tiene raz√≥n, si el desbordamiento del b√∫fer sube y el puntero se encuentra debajo del b√∫fer, entonces el desbordamiento no puede da√±arlo. <br><br>  <b>P√∫blico:</b> ¬øpor qu√© no puede asociar el "canario" con la funci√≥n "canario", como lo hizo con la direcci√≥n del remitente? <br><br>  <b>Profesor:</b> este es un momento interesante!  Puedes hacer tales cosas.  De hecho, puede intentar imaginar un compilador que siempre que tenga un puntero, siempre intente agregar un complemento para algunas cosas.  Sin embargo, verificar todas estas cosas ser√° demasiado costoso.  Debido a que cada vez que desee utilizar cualquier puntero o llamar a cualquier funci√≥n, debe tener un c√≥digo que verifique si este "canario" es correcto.  B√°sicamente, podr√≠as hacer algo similar, pero ¬øtiene sentido?  Vemos que los "canarios" no ayudan en esta situaci√≥n. <br><br>  Y una cosa m√°s que discutimos anteriormente es que si el atacante puede adivinar la aleatoriedad, entonces, en principio, los "canarios" aleatorios no funcionar√°n.  Crear recursos de seguridad basados ‚Äã‚Äãen la aleatoriedad es un tema separado y muy complejo, por lo que no entraremos en ello. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>P√∫blico:</b> ¬øEntonces el canario contiene menos bits que una direcci√≥n de retorno?  Porque de lo contrario, no podr√≠a recordar esta direcci√≥n y verificar si ha cambiado. <br><br>  <b>Profesor:</b> a ver.  Est√° hablando de este esquema cuando el "canario" se encuentra sobre el b√∫fer, y quiere decir que el sistema no puede ser seguro si es imposible mirar la direcci√≥n de retorno y verificar si se ha cambiado. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Si y no  Tenga en cuenta que si se produce un ataque de desbordamiento del b√∫fer, se sobrescribir√° todo lo anterior, por lo que esto puede causar problemas.  Pero b√°sicamente, si estas cosas fueran inmutables de alguna manera, entonces podr√≠as hacer algo como esto.  Pero el problema es que, en muchos casos, manipular la direcci√≥n del remitente es algo bastante complicado.  Porque puedes imaginar que se puede llamar a una funci√≥n especial desde diferentes lugares, y as√≠ sucesivamente.  En este caso, corremos un poco m√°s adelante, y si hay tiempo al final de la conferencia, volveremos a esto. <br><br>  Estas son situaciones en las que un "canario" puede fallar.  Hay otros lugares donde es posible fallar, por ejemplo, al atacar las funciones <b>malloc</b> y <b>free</b> .  La funci√≥n malloc asigna un bloque de memoria de cierto tama√±o en bytes y devuelve un puntero al comienzo del bloque.  El contenido del bloque de memoria asignado no se inicializa, permanece con valores indefinidos.  Y la funci√≥n <b>libre</b> libera memoria previamente asignada din√°micamente. <br><br>  Este es un ataque √∫nico al estilo de C. Veamos qu√© sucede aqu√≠.  Imagine que tiene dos punteros aqu√≠, p y q, para los cuales usamos <b>malloc para</b> asignar 1.024 bytes de memoria a cada uno de estos punteros.  Supongamos que hacemos la funci√≥n <b>strcpy</b> para p de alg√∫n tipo de error de b√∫fer que es controlado por un atacante.  Aqu√≠ es donde ocurre el desbordamiento.  Y luego ejecutamos el comando <b>free q</b> y <b>free p</b> .  Este es un c√≥digo bastante simple, ¬øverdad? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Tenemos 2 punteros para los cuales asignamos memoria, usamos uno de ellos para una determinada funci√≥n, se produce un desbordamiento del b√∫fer y liberamos la memoria de ambos punteros. <br><br>  Suponga que las l√≠neas de memoria de p y q est√°n ubicadas una al lado de la otra en el espacio de memoria.  En este caso, pueden pasar cosas malas, ¬øverdad?  Porque la funci√≥n <b>strcpy</b> se usa para copiar el contenido de <b>str2</b> a <b>str1</b> .  <b>Str2</b> debe ser un puntero a una cadena que termina en cero, y <b>strcpy</b> devuelve un puntero a <b>str1</b> .  Si las l√≠neas <b>str1</b> y <b>str2</b> se superponen, entonces el comportamiento de la funci√≥n <b>strcpy</b> es indefinido. <br><br>  Por lo tanto, la funci√≥n <b>strycpy</b> que procesa la memoria <b>p</b> puede afectar al mismo tiempo la memoria asignada para <b>q</b> .  Y eso puede causar problemas. <br><br>  Es posible que haya hecho algo as√≠ en su propio c√≥digo sin darse cuenta cuando us√≥ alg√∫n tipo de punteros extra√±os.  Y todo parece funcionar, pero cuando necesita llamar a la funci√≥n <b>gratuita</b> , se produce una molestia.  Y un atacante puede aprovecharlo, explicar√© por qu√© sucede esto. <br><br>  Imagine que dentro de la implementaci√≥n de las funciones <b>gratuitas</b> y <b>malloc</b> , el bloque resaltado se ve as√≠. <br><br>  Supongamos que en la parte superior del bloque hay datos visibles de la aplicaci√≥n, y debajo tenemos el tama√±o de la variable.  Este tama√±o no es lo que la aplicaci√≥n ve directamente, sino una especie de "contabilidad" realizada por <b>free</b> o <b>malloc</b> , para que sepa el tama√±o del b√∫fer de memoria asignado.  Un bloque libre se encuentra al lado del bloque resaltado.  Suponga que un bloque libre tiene algunos metadatos que se ven as√≠: tenemos el tama√±o del bloque arriba, hay espacio libre debajo, el puntero posterior y el puntero delantero debajo.  Y en la parte inferior del bloque, el tama√±o se muestra nuevamente. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  ¬øPor qu√© tenemos 2 punteros aqu√≠?  Debido a que el sistema de asignaci√≥n de memoria en este caso usa una lista doblemente vinculada para rastrear c√≥mo los bloques libres est√°n relacionados entre s√≠.  Por lo tanto, cuando selecciona un bloque libre, lo excluye de esta lista doblemente vinculada.  Y luego, cuando lo liberes, har√°s algo de aritm√©tica para el puntero y pondr√°s estas cosas en orden.  Despu√©s de eso, lo agrega a esta lista vinculada, ¬øverdad? <br><br>  Cada vez que escuche sobre la aritm√©tica de punteros, debe pensar que este es su "canario".  Porque habr√° muchos problemas.  Perm√≠tame recordarle que tuvimos desbordamiento de b√∫fer <b>p</b> .  Si suponemos que <b>pyq</b> est√°n uno al lado del otro, o muy cerca en el espacio de la memoria, puede ocurrir que este desbordamiento del b√∫fer pueda sobrescribir algunos datos de tama√±o para el puntero asignado <b>q</b> : esta es la parte inferior de nuestro bloque asignado.  Si contin√∫as siguiendo mi pensamiento desde el principio, entonces tu imaginaci√≥n te dir√° d√≥nde empieza a salir todo mal.  De hecho, en esencia, lo que finalmente sucede con estas operaciones es <b>q libre</b> y <b>p libre</b> : observan estos metadatos en el bloque seleccionado para hacer todas las manipulaciones necesarias con el puntero. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Es decir, en alg√∫n momento de la ejecuci√≥n, las funciones <b>libres</b> obtendr√°n un cierto puntero en funci√≥n del valor de tama√±o: <b>p = get.free.block (tama√±o)</b> , y el tama√±o es lo que controla el atacante, porque realiz√≥ un desbordamiento de b√∫fer, correctamente ? <br><br>  Hizo un mont√≥n de c√°lculos aritm√©ticos, observ√≥ la funci√≥n de <b>retroceso</b> y los punteros de este bloque y ahora va a hacer algo como actualizar los punteros de "retroceso" y "avance": estas son las dos l√≠neas inferiores. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Pero en realidad esto no deber√≠a molestarte.  Este es solo un ejemplo del c√≥digo que tiene lugar en este caso.  Pero el hecho es que, debido al tama√±o reescrito por el hacker, ahora controla este puntero, que pasa a trav√©s de la funci√≥n <b>libre</b> .  Y debido a esto, los dos estados aqu√≠ en la l√≠nea inferior son en realidad actualizaciones de puntero.  Y dado que el atacante pudo controlar este <b>p</b> , en realidad controla estos dos punteros.  Es en este lugar donde puede ocurrir un ataque. <br><br>  Por lo tanto, cuando se ejecuta <b>libremente</b> y trata de hacer algo como combinar estos dos bloques, tiene una lista doblemente vinculada.  Porque si tiene dos bloques que chocan entre s√≠ y ambos son libres, desea combinarlos en un bloque grande. <br><br>  Pero si controlamos el tama√±o, significa que controlamos todo el proceso desde las cuatro l√≠neas anteriores.  Esto significa que si entendemos c√≥mo funciona el desbordamiento, entonces podemos escribir datos en la memoria de la manera que elijamos.  Como dije, tales cosas a menudo suceden con su propio c√≥digo, si no es inteligente con un puntero.  Cuando cometes un error doble gratis como <b>free q</b> y <b>free p</b> o algo m√°s, tu funci√≥n se bloquea.  Porque te equivocaste con los metadatos que viven en cada uno de estos bloques seleccionados, y en alg√∫n momento este c√°lculo indicar√° alg√∫n tipo de valor "basura", despu√©s de lo cual estar√°s "muerto".  Pero si eres un atacante, puedes elegir este valor y usarlo para tu ventaja. <br><br>  Pasemos a otro enfoque para evitar ataques de desbordamiento de b√∫fer.  Este enfoque es verificar los l√≠mites.  El prop√≥sito de la comprobaci√≥n de l√≠mites es asegurarse de que cuando use un puntero espec√≠fico, solo se refiera a lo que es un objeto de memoria.  Y este puntero est√° dentro de los l√≠mites permitidos de este objeto de memoria.  Esta es la idea principal de la verificaci√≥n.       ‚Äî   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        ‚Äì    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Es dificil de decir.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing ‚Äì  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   ¬´¬ª ‚Äî  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page ‚Äì !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> MIT ¬´  ¬ª.  2: ¬´  ¬ª,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La versi√≥n completa del curso est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416047/">https://habr.com/ru/post/es416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416029/index.html">Computadora l√≠quida: captura de iones en grafeno</a></li>
<li><a href="../es416035/index.html">Esc√°ner 3D dental Shining 3D Autoscan DS EX (Unboxing) de 3Dtool</a></li>
<li><a href="../es416037/index.html">Inicio del d√≠a (abril-junio de 2018)</a></li>
<li><a href="../es416043/index.html">Los pa√≠ses en desarrollo est√°n explorando cada vez m√°s el espacio ultraterrestre.</a></li>
<li><a href="../es416045/index.html">UPS en l√≠nea SRC1KI Smart-UPS de APC: confiabilidad sobre todo</a></li>
<li><a href="../es416049/index.html">C√≥dec AV1 de pr√≥xima generaci√≥n: filtro de correcci√≥n direccional CDEF</a></li>
<li><a href="../es416051/index.html">Summer mitap Apache Ignite en Mosc√∫</a></li>
<li><a href="../es416053/index.html">Modulaci√≥n de amplitud de una se√±al arbitraria.</a></li>
<li><a href="../es416055/index.html">Asignaci√≥n y soporte del FQDN del servidor 3QX</a></li>
<li><a href="../es416059/index.html">Mobio habla con Daniil Shuleiko (Yandex.Taxi) sobre fusi√≥n con Uber, mercado de taxis y competencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>