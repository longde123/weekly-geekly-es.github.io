<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐆 🏹 👾 Curso MIT "Seguridad de sistemas informáticos". Lección 2: "Control de ataques de hackers", parte 2 👸🏽 👶🏼 🚣🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 2: "Control de ataques de hackers", parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Entonces, tenemos un buffer sobre el cual colocamos el "canario".  Por encima de eso está el puntero del punto de interrupción <b>guardado, el</b> valor <b>EBP guardado</b> y la dirección de retorno se coloca encima de él.  Si recuerdas, el desbordamiento va de abajo hacia arriba, así que antes de llegar a la dirección del remitente, primero destruirá el "canario". <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Audiencia:</b> ¿por qué afectará al "canario"? <br><br>  <b>Profesor:</b> porque se supone que el atacante no sabe "saltar" arbitrariamente en la memoria.  Los ataques tradicionales de desbordamiento de memoria comienzan con un pirata informático que examina el límite de tamaño del búfer, después de lo cual el desbordamiento comienza desde el fondo.  Pero tiene razón: si un atacante puede entrar directamente en la barra de dirección de retorno, ningún "canario" nos ayudará.  Sin embargo, con un ataque tradicional de desbordamiento del búfer, todo debería suceder exactamente de esa manera, de abajo hacia arriba. <br><br>  Por lo tanto, la idea principal de usar un "canario" es que permitimos que un exploit malicioso desborde el búfer de memoria.  Tenemos un código de tiempo de ejecución que, al regresar de una función, verifica el "canario" para asegurarse de que tenga el valor correcto. <br><br>  <b>Audiencia:</b> ¿Puede un atacante reescribir la dirección del remitente y cambiar el "canario"?  ¿Cómo puede verificar que ha sido modificado, pero que continúa cumpliendo su función? <br><br>  <b>Profesor:</b> sí, tal vez.  Por lo tanto, debe tener algún código que realmente verifique esto antes de que la función regrese.  Es decir, en este caso, es necesario contar con el apoyo de un compilador, que en realidad ampliará la <b>convención de llamadas</b> .  De modo que parte de la secuencia de retorno ocurre antes de considerar la validez de este valor para asegurarnos de que el "canario" no haya sido destruido.  Solo después de eso podemos pensar en otra cosa. <br><br>  <b>Público:</b> ¿No puede un atacante saber o adivinar qué significa "canario"? <br><br>  <b>Profesor: ¡</b> esto es exactamente de lo que voy a hablar!  ¿Cuál es el problema con este circuito?  ¿Qué pasa si, por ejemplo, ponemos el valor A en cada programa?  ¿O toda una rama de 4 valores de A?  Por supuesto, cualquier hacker puede averiguar el tamaño del búfer, su capacidad y así determinar la posición del "canario" en cualquier sistema.  Por lo tanto, podemos usar diferentes tipos de cantidades que ponemos en nuestro "canario" para evitar esto. <br><br>  Hay una cosa que puedes hacer con nuestro "canario".  Será un tipo muy divertido de "canario", que utiliza funciones de programa en C y procesa caracteres especiales, el llamado tipo determinista de "canario". <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Imagine que utiliza el carácter 0 para el "canario". El valor binario de cero es el byte cero, el carácter cero en ASCII.  Un valor de -1 significa un retorno a la posición anterior y así sucesivamente.  Muchas funciones detienen o cambian la operación cuando encuentran caracteres o valores como 0, CR, LF, -1.  Imagine que usted, como hacker, utiliza alguna función de gestión de cadenas para subir el búfer, encuentra el carácter 0 en el "canario" y el proceso se detiene.  Si utiliza la función "retorno de carro" -1, que a menudo se utiliza como un terminador de línea, el proceso también se detendrá.  Entonces -1 es otro signo mágico. <br><br>  Hay una cosa más que se puede usar en el "canario": estos son valores aleatorios que son difíciles de adivinar para el atacante.  El poder del valor aleatorio se basa en lo difícil que es para un atacante adivinarlo.  Por ejemplo, si un atacante se da cuenta de que solo hay 3 bits de entropía en su sistema, podrá usar un ataque de fuerza bruta.  Por lo tanto, las posibilidades de usar números aleatorios para protegerse contra los ataques son bastante limitadas. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Público:</b> generalmente sucede que leo de otro búfer y escribo lo que leo en este búfer de esta pila.  En esta situación, parece que el valor aleatorio del "canario" es inútil, porque leo los datos de otro búfer y sé dónde está el "canario".  Tengo otro búfer que controlo y que nunca verifico.  Y en este búfer puedo poner mucho de lo que quiero poner.  No necesito un "canario" aleatorio, porque puedo reescribirlo de manera segura.  Así que no veo cómo funciona realmente: en el escenario que propusiste, cuando la función se detiene al leer datos del búfer. <br><br>  <b>Profesor:</b> Entiendo su pregunta, quiere decir que usamos un "canario" determinista, pero no utilizamos una de las funciones de la biblioteca estándar que puede ser "engañada" por nuestros caracteres 0, CR, LF, -1.  Entonces sí, en la situación que describió, no se necesita un "canario". <br><br>  La idea es que puede llenar este búfer con bytes desde cualquier lugar, pero cualquier cosa que le permita adivinar estos valores u obtenerlos aleatoriamente provocará un error. <br><br>  <b>Audiencia:</b> ¿Es posible usar algo como el número de segundos o milisegundos como números aleatorios y usarlos en un "canario"? <br><br>  <b>Profesor:</b> Las llamadas de datos no contienen tantos accidentes como cree.  Porque el programa tiene registros o una función a la que puede llamar para averiguar cuándo se descargó el programa y otras cosas similares.  Pero, en general, tiene razón: en la práctica, si puede usar un dispositivo de hardware, generalmente de bajo nivel, con mejores tiempos de sistema, este tipo de enfoque puede funcionar. <br><br>  <b>Público:</b> incluso si logramos ver los registros sobre el comienzo del desbordamiento del búfer, aún es importante a qué hora rechazamos la solicitud.  Y si no podemos obtener el control sobre el tiempo que demora la solicitud de una computadora al servidor, es dudoso que se pueda adivinar de manera determinista el tiempo exacto. <br><br>  <b>Profesor:</b> muy cierto, ya dije que el mal yace en los detalles, este es solo un caso.  En otras palabras, si tiene alguna manera de, por ejemplo, determinar el tipo de canal de tiempo, puede encontrar que la cantidad de entropía, o el número de aleatoriedad, no llena una marca de tiempo completa, sino mucho menos.  Por lo tanto, un atacante puede determinar la hora y los minutos cuando hizo esto, pero no un segundo. <br><br>  <b>Público:</b> para el registro, ¿tratar de reducir su propia aleatoriedad es una mala idea? <br><br>  <b>Profesor:</b> absolutamente cierto! <br><br>  <b>Público:</b> es decir, generalmente solo tenemos que usar todo lo que nuestros sistemas admiten, ¿verdad? <br><br>  <b>Profesor:</b> sí, eso es verdad.  Esto es como la invención de nuestro propio criptosistema, que es otra cosa popular que nuestros graduados a veces quieren hacer.  Pero no somos la NSA, no somos matemáticos, por lo que esto generalmente falla.  Entonces tienes toda la razón al respecto. <br><br>  Pero incluso si usa la aleatoriedad del sistema, aún puede obtener menos bits de entropía de lo esperado.  Permíteme darte un ejemplo de aleatorización de fase de direcciones.  Es sobre este principio que el enfoque de <b>canarios de pila funciona</b> .  Dado que estamos comprometidos con la seguridad informática, probablemente se esté preguntando en qué casos los "canarios" no pueden hacer frente a su tarea y si hay formas de fallar al "canario". <br><br>  Una de esas formas es un ataque reescribiendo punteros de función.  Porque si se golpea el puntero de la función, el "canario" no puede hacer nada. <br><br>  Supongamos que tiene un código de la forma <b>int * ptr ... ..</b> , el puntero iniciador, no importa cómo, entonces tiene el buffer <b>char buf [128]</b> , la función <b>gets (buf)</b> , y en la parte inferior un puntero al que se le asigna algún valor : <b>* ptr = 5</b> . <br><br>  Observo que no intentamos atacar la dirección de retorno de la función que contiene este código.  Como puede ver, cuando el búfer se desborda, la dirección del puntero ubicada arriba se dañará.  Si un atacante puede dañar este puntero, puede asignar 5 a una de las direcciones que controla.  ¿Pueden ver todos que el "canario" no ayudará aquí?  Porque no atacamos el camino por el que regresa la función. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Público: ¿</b> se puede ubicar el puntero debajo del búfer? <br><br>  <b>Profesor:</b> puede, pero el orden de las variables específicas depende de muchas cosas diferentes, de la forma en que el compilador organiza el contenido, del tamaño de la columna de hardware, etc.  Pero tiene razón, si el desbordamiento del búfer sube y el puntero se encuentra debajo del búfer, entonces el desbordamiento no puede dañarlo. <br><br>  <b>Público:</b> ¿por qué no puede asociar el "canario" con la función "canario", como lo hizo con la dirección del remitente? <br><br>  <b>Profesor:</b> este es un momento interesante!  Puedes hacer tales cosas.  De hecho, puede intentar imaginar un compilador que siempre que tenga un puntero, siempre intente agregar un complemento para algunas cosas.  Sin embargo, verificar todas estas cosas será demasiado costoso.  Debido a que cada vez que desee utilizar cualquier puntero o llamar a cualquier función, debe tener un código que verifique si este "canario" es correcto.  Básicamente, podrías hacer algo similar, pero ¿tiene sentido?  Vemos que los "canarios" no ayudan en esta situación. <br><br>  Y una cosa más que discutimos anteriormente es que si el atacante puede adivinar la aleatoriedad, entonces, en principio, los "canarios" aleatorios no funcionarán.  Crear recursos de seguridad basados ​​en la aleatoriedad es un tema separado y muy complejo, por lo que no entraremos en ello. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Público:</b> ¿Entonces el canario contiene menos bits que una dirección de retorno?  Porque de lo contrario, no podría recordar esta dirección y verificar si ha cambiado. <br><br>  <b>Profesor:</b> a ver.  Está hablando de este esquema cuando el "canario" se encuentra sobre el búfer, y quiere decir que el sistema no puede ser seguro si es imposible mirar la dirección de retorno y verificar si se ha cambiado. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Si y no  Tenga en cuenta que si se produce un ataque de desbordamiento del búfer, se sobrescribirá todo lo anterior, por lo que esto puede causar problemas.  Pero básicamente, si estas cosas fueran inmutables de alguna manera, entonces podrías hacer algo como esto.  Pero el problema es que, en muchos casos, manipular la dirección del remitente es algo bastante complicado.  Porque puedes imaginar que se puede llamar a una función especial desde diferentes lugares, y así sucesivamente.  En este caso, corremos un poco más adelante, y si hay tiempo al final de la conferencia, volveremos a esto. <br><br>  Estas son situaciones en las que un "canario" puede fallar.  Hay otros lugares donde es posible fallar, por ejemplo, al atacar las funciones <b>malloc</b> y <b>free</b> .  La función malloc asigna un bloque de memoria de cierto tamaño en bytes y devuelve un puntero al comienzo del bloque.  El contenido del bloque de memoria asignado no se inicializa, permanece con valores indefinidos.  Y la función <b>libre</b> libera memoria previamente asignada dinámicamente. <br><br>  Este es un ataque único al estilo de C. Veamos qué sucede aquí.  Imagine que tiene dos punteros aquí, p y q, para los cuales usamos <b>malloc para</b> asignar 1.024 bytes de memoria a cada uno de estos punteros.  Supongamos que hacemos la función <b>strcpy</b> para p de algún tipo de error de búfer que es controlado por un atacante.  Aquí es donde ocurre el desbordamiento.  Y luego ejecutamos el comando <b>free q</b> y <b>free p</b> .  Este es un código bastante simple, ¿verdad? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Tenemos 2 punteros para los cuales asignamos memoria, usamos uno de ellos para una determinada función, se produce un desbordamiento del búfer y liberamos la memoria de ambos punteros. <br><br>  Suponga que las líneas de memoria de p y q están ubicadas una al lado de la otra en el espacio de memoria.  En este caso, pueden pasar cosas malas, ¿verdad?  Porque la función <b>strcpy</b> se usa para copiar el contenido de <b>str2</b> a <b>str1</b> .  <b>Str2</b> debe ser un puntero a una cadena que termina en cero, y <b>strcpy</b> devuelve un puntero a <b>str1</b> .  Si las líneas <b>str1</b> y <b>str2</b> se superponen, entonces el comportamiento de la función <b>strcpy</b> es indefinido. <br><br>  Por lo tanto, la función <b>strycpy</b> que procesa la memoria <b>p</b> puede afectar al mismo tiempo la memoria asignada para <b>q</b> .  Y eso puede causar problemas. <br><br>  Es posible que haya hecho algo así en su propio código sin darse cuenta cuando usó algún tipo de punteros extraños.  Y todo parece funcionar, pero cuando necesita llamar a la función <b>gratuita</b> , se produce una molestia.  Y un atacante puede aprovecharlo, explicaré por qué sucede esto. <br><br>  Imagine que dentro de la implementación de las funciones <b>gratuitas</b> y <b>malloc</b> , el bloque resaltado se ve así. <br><br>  Supongamos que en la parte superior del bloque hay datos visibles de la aplicación, y debajo tenemos el tamaño de la variable.  Este tamaño no es lo que la aplicación ve directamente, sino una especie de "contabilidad" realizada por <b>free</b> o <b>malloc</b> , para que sepa el tamaño del búfer de memoria asignado.  Un bloque libre se encuentra al lado del bloque resaltado.  Suponga que un bloque libre tiene algunos metadatos que se ven así: tenemos el tamaño del bloque arriba, hay espacio libre debajo, el puntero posterior y el puntero delantero debajo.  Y en la parte inferior del bloque, el tamaño se muestra nuevamente. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  ¿Por qué tenemos 2 punteros aquí?  Debido a que el sistema de asignación de memoria en este caso usa una lista doblemente vinculada para rastrear cómo los bloques libres están relacionados entre sí.  Por lo tanto, cuando selecciona un bloque libre, lo excluye de esta lista doblemente vinculada.  Y luego, cuando lo liberes, harás algo de aritmética para el puntero y pondrás estas cosas en orden.  Después de eso, lo agrega a esta lista vinculada, ¿verdad? <br><br>  Cada vez que escuche sobre la aritmética de punteros, debe pensar que este es su "canario".  Porque habrá muchos problemas.  Permítame recordarle que tuvimos desbordamiento de búfer <b>p</b> .  Si suponemos que <b>pyq</b> están uno al lado del otro, o muy cerca en el espacio de la memoria, puede ocurrir que este desbordamiento del búfer pueda sobrescribir algunos datos de tamaño para el puntero asignado <b>q</b> : esta es la parte inferior de nuestro bloque asignado.  Si continúas siguiendo mi pensamiento desde el principio, entonces tu imaginación te dirá dónde empieza a salir todo mal.  De hecho, en esencia, lo que finalmente sucede con estas operaciones es <b>q libre</b> y <b>p libre</b> : observan estos metadatos en el bloque seleccionado para hacer todas las manipulaciones necesarias con el puntero. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Es decir, en algún momento de la ejecución, las funciones <b>libres</b> obtendrán un cierto puntero en función del valor de tamaño: <b>p = get.free.block (tamaño)</b> , y el tamaño es lo que controla el atacante, porque realizó un desbordamiento de búfer, correctamente ? <br><br>  Hizo un montón de cálculos aritméticos, observó la función de <b>retroceso</b> y los punteros de este bloque y ahora va a hacer algo como actualizar los punteros de "retroceso" y "avance": estas son las dos líneas inferiores. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Pero en realidad esto no debería molestarte.  Este es solo un ejemplo del código que tiene lugar en este caso.  Pero el hecho es que, debido al tamaño reescrito por el hacker, ahora controla este puntero, que pasa a través de la función <b>libre</b> .  Y debido a esto, los dos estados aquí en la línea inferior son en realidad actualizaciones de puntero.  Y dado que el atacante pudo controlar este <b>p</b> , en realidad controla estos dos punteros.  Es en este lugar donde puede ocurrir un ataque. <br><br>  Por lo tanto, cuando se ejecuta <b>libremente</b> y trata de hacer algo como combinar estos dos bloques, tiene una lista doblemente vinculada.  Porque si tiene dos bloques que chocan entre sí y ambos son libres, desea combinarlos en un bloque grande. <br><br>  Pero si controlamos el tamaño, significa que controlamos todo el proceso desde las cuatro líneas anteriores.  Esto significa que si entendemos cómo funciona el desbordamiento, entonces podemos escribir datos en la memoria de la manera que elijamos.  Como dije, tales cosas a menudo suceden con su propio código, si no es inteligente con un puntero.  Cuando cometes un error doble gratis como <b>free q</b> y <b>free p</b> o algo más, tu función se bloquea.  Porque te equivocaste con los metadatos que viven en cada uno de estos bloques seleccionados, y en algún momento este cálculo indicará algún tipo de valor "basura", después de lo cual estarás "muerto".  Pero si eres un atacante, puedes elegir este valor y usarlo para tu ventaja. <br><br>  Pasemos a otro enfoque para evitar ataques de desbordamiento de búfer.  Este enfoque es verificar los límites.  El propósito de la comprobación de límites es asegurarse de que cuando use un puntero específico, solo se refiera a lo que es un objeto de memoria.  Y este puntero está dentro de los límites permitidos de este objeto de memoria.  Esta es la idea principal de la verificación.       —   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        –    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  Es dificil de decir.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing –  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   «» —  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page – !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> MIT «  ».  2: «  »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La versión completa del curso está disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416047/">https://habr.com/ru/post/es416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416029/index.html">Computadora líquida: captura de iones en grafeno</a></li>
<li><a href="../es416035/index.html">Escáner 3D dental Shining 3D Autoscan DS EX (Unboxing) de 3Dtool</a></li>
<li><a href="../es416037/index.html">Inicio del día (abril-junio de 2018)</a></li>
<li><a href="../es416043/index.html">Los países en desarrollo están explorando cada vez más el espacio ultraterrestre.</a></li>
<li><a href="../es416045/index.html">UPS en línea SRC1KI Smart-UPS de APC: confiabilidad sobre todo</a></li>
<li><a href="../es416049/index.html">Códec AV1 de próxima generación: filtro de corrección direccional CDEF</a></li>
<li><a href="../es416051/index.html">Summer mitap Apache Ignite en Moscú</a></li>
<li><a href="../es416053/index.html">Modulación de amplitud de una señal arbitraria.</a></li>
<li><a href="../es416055/index.html">Asignación y soporte del FQDN del servidor 3QX</a></li>
<li><a href="../es416059/index.html">Mobio habla con Daniil Shuleiko (Yandex.Taxi) sobre fusión con Uber, mercado de taxis y competencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>