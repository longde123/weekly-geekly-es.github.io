<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèæ üóìÔ∏è üë©üèª‚Äçüé® Machine de Turing, comme mod√®le de programmes d'automates üòÜ üçø üçå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Machine de Turing, comme mod√®le de programmes d'automates 
 1. Introduction 
 La programmation n√©cessite de nouveaux mod√®les algorithmiques universels...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machine de Turing, comme mod√®le de programmes d'automates</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481998/"><h2>  Machine de Turing, comme mod√®le de programmes d'automates </h2><br><h3>  1. Introduction </h3><br>  La programmation n√©cessite de nouveaux mod√®les algorithmiques universels et le mat√©riel impl√©mente des algorithmes non seulement sous une forme diff√©rente, mais √©galement sur la base d'un autre mod√®le algorithmique - automatique.  L'adoption de la technologie dans le domaine du d√©veloppement mat√©riel est une id√©e cl√© de la programmation automatis√©e.  Cependant, la synth√®se des appareils num√©riques est diff√©rente de la programmation.  Mais, en empruntant un mod√®le, d'une part, il n'est pas conseill√© de le modifier substantiellement, mais, d'autre part, on ne peut ignorer la th√©orie et la pratique existantes de la programmation. <br><br>  Ensuite, nous consid√©rerons la technologie SWITCH pour concevoir des programmes automatis√©s, dans lesquels vous rencontrez de tels processus tout le temps.  D'une part, il a tellement chang√© le mod√®le de machine √† √©tats qu'il l'a en fait d√©pass√© le cadre de la th√©orie des automates.  Et, d'autre part, il introduit dans la programmation des concepts qui sont difficiles √† percevoir par les programmeurs et, parfois, sont simplement superflus, car  il existe des homologues plus familiers de la th√©orie des programmes et de la pratique de la programmation. <br><br>  Comme base de discussion des probl√®mes de programmation automatique, nous prenons la r√©cente conf√©rence de A. Shalyto  [1] et ses articles ¬´programmatiques¬ª sur la d√©finition du paradigme de la programmation automatique [2, 3]. <br><a name="habracut"></a><br>  <b>1. Objets automatis√©s, sch√©mas de programme</b> <br><br>  Dans la conf√©rence, la r√©alisation de la programmation automatique est l'introduction du concept d'objets de contr√¥le automatis√©, emprunt√© √† la th√©orie du contr√¥le automatique (TAU).  Mais, rappelons que dans TAU ils ne consid√®rent pas tant les objets, mais les syst√®mes, parmi lesquels se distinguent les suivants [4]: <br><br><img src="https://habrastorage.org/webt/zx/3w/k7/zx3wk7apg6vumkx6wkrhhorjrpg.jpeg" alt="image"><br><br>  Sur cette base, il serait plus correct de parler de syst√®mes de contr√¥le automatique (ACS).  Examinons maintenant le sch√©ma fonctionnel typique des canons automoteurs illustr√©s √† la Fig.  1. Si le ruban de la machine de Turing est consid√©r√© comme l'objet de contr√¥le, alors les dispositifs d'actionnement (IS) seront des √©l√©ments MT qui impl√©menteront la modification du contenu du ruban et le d√©placement de la t√™te, et les dispositifs de mesure (IS) seront les √©l√©ments qui liront les informations du ruban. <br><br><img src="https://habrastorage.org/webt/mt/ns/y5/mtnsy5l-h2msdra8jmld6l_mn5i.jpeg" alt="image"><br>  <i>Fig.1.</i>  <i>Sch√©ma fonctionnel des canons automoteurs</i> <br><br>  Mais pourquoi se tourner vers TAU, s'il existe une pratique plus proche de la programmation de la conception de syst√®mes informatiques, dans laquelle les dispositifs d'exploitation (OS), qui, bien s√ªr, incluent MT, sont consid√©r√©s comme une combinaison de machines d'exploitation (OA) et de contr√¥le (UA).  Et cela est plus proche de ce que nous visons en fin de compte - justifier la puissance de la programmation automatique.  Dans la fig.  2 montre un √©cran de texte d'une monographie de Mayorov S.A., Novikov G.I.  La structure des ordinateurs √©lectroniques [5], dans laquelle les probl√®mes de conception des amplificateurs op√©rationnels sont examin√©s en d√©tail. <br><br><img src="https://habrastorage.org/webt/fv/14/en/fv14ens27xhjytujiwia279csxq.jpeg" alt="image"><br>  <i>Fig.2.</i>  <i>Le concept de gestionnaire et d'exploitation des machines</i> <br><br>  Mais, si nous comparons la th√©orie de la conception informatique et la th√©orie des programmes, une analogie structurelle √©vidente peut √™tre trac√©e entre eux.  En th√©orie de la programmation, le mod√®le de tout programme au niveau structurel peut √™tre repr√©sent√© comme un sch√©ma de programme S = (M, A, C), o√π M est l'ensemble des √©l√©ments de m√©moire, A est l'ensemble des op√©rateurs, C est le contr√¥le [10].  Suivant cette approche, tout programme de machine de Turing peut √©galement √™tre d√©fini comme un sch√©ma de programme dans lequel l'ensemble M est repr√©sent√© par des cellules de bande, l'ensemble d'op√©rateurs par des actions MT associ√©es √† 1) l'analyse des cellules, 2) le changement de caract√®res dans les cellules de bande et 3) le d√©placement de la t√™te. <br><br>  Ainsi, le concept de sch√©ma de programme est compl√®tement analogue au concept consid√©r√© d'automates op√©rationnels et de contr√¥le, o√π le mod√®le d'UA est le mod√®le de la machine √† √©tats finis structurels (SKA) examin√©e ci-dessous, et OA est une structure pour effectuer des actions sur les informations.  Dans ce cas, OA comprend des √©l√©ments de stockage de donn√©es (ci-dessus est la m√©moire) et des blocs pour le traitement des informations qui impl√©mentent le calcul des conditions logiques et la mise en ≈ìuvre de certaines actions (ci-dessus - beaucoup d'op√©rateurs). <br><br>  D'apr√®s ce qui pr√©c√®de, on peut comprendre que la bande ne peut √™tre consid√©r√©e que conditionnellement comme l'objet de contr√¥le pour MT.  Ne serait-ce que parce que le dispositif de commande de la machine de Turing n'y a pas d'acc√®s direct, car  toutes les op√©rations avec des cellules sont r√©alis√©es indirectement par des blocs OA.  De plus, il semble qu'il ne soit pas tr√®s familier ou, pour ne pas dire, il est √©trange de consid√©rer comme le but de la gestion de programme, comme syst√®me de contr√¥le, un objet repr√©sentant une m√©moire (bande). <br>  Ainsi, pour une d√©finition formelle d'une machine de Turing, et dans son contexte une place pour un mod√®le de machine √† √©tats finis, les concepts de la th√©orie des programmes sont suffisants.  Maintenant, contrairement √† la d√©finition tr√®s vague des programmes d'automates donn√©e dans le cadre de la technologie SWITCH, nous pouvons dire qu'un programme d'automates est un programme qui a le contr√¥le sous la forme d'un mod√®le de machine √† √©tats finis. <br><br>  Quel sera le programme lui-m√™me - avec un comportement simple ou complexe, quelle est sa ¬´vari√©t√©¬ª - avec un contr√¥le logique, ¬´avec une allocation d'√©tat explicite¬ª, etc.  etc.  n'a pas vraiment d'importance.  L'essentiel est le type de gestion.  Les √©l√©ments restants du programme peuvent √™tre d√©termin√©s dans une large gamme - du plus simple, comme, par exemple, avec une machine de Turing, au plus complexe - toute forme d'op√©rateurs, de fonctions et de structures de donn√©es des langages de programmation - assembleur, langage de haut niveau, etc. <br><br>  On peut √©galement rappeler qu'une machine de Turing a longtemps √©t√© consid√©r√©e comme un tapis automatique [6] ou, dans les cas extr√™mes, sa simple extension [7].  Mais vous devez comprendre de quel type d'automate il s'agit, de quel type d'extension il s'agit et si elles sont √©quivalentes aux mod√®les de machines √† √©tats finis classiques.  Essayons de clarifier cela. <br><br>  <b>2. Programmation de Turing dans un environnement de programmation automatis√©</b> <br><br>  Dans la fig.  La figure 3 montre l'automate pour la fonction d'incr√©mentation MT de la monographie [8].  Dans la forme, ce n'est clairement pas un programme MT, mais d√©j√† pas une machine √† √©tats finis classique.  Dans la fig.  La figure 4 montre le graphique de la machine √† √©tats finis structurels classique (SKA) et son impl√©mentation dans l'environnement VKPa (l'environnement de programmation automatis√©e des composants visuels en C ++ dans le cadre de la biblioth√®que Qt et de l'environnement Qt Creator), qui impl√©mente le m√™me algorithme d'unit√© de contr√¥le MT. <br><br><img src="https://habrastorage.org/webt/6n/xv/rn/6nxvrne_9pugaykk9zhfxekzvju.jpeg" alt="image"><br>  <i>Fig.3.</i>  <i>Augmentez le nombre par unit√© en utilisant une machine de Turing</i> <br><br><img src="https://habrastorage.org/webt/iq/fx/d2/iqfxd2lsiammfthsrdqcl3bkneo.jpeg" alt="image"><br>  <i>Fig.4 Mod√®le de programme d'incr√©mentation pour MT sous forme de SKA</i> <br><br>  Vous pouvez voir que la machine structurelle a quatre canaux d'entr√©e et cinq canaux de sortie.  Chacun de ces canaux est associ√© √† une fonction de programme du m√™me nom - un pr√©dicat ou une action.  Ici, les pr√©dicats sont des fonctions sans param√®tres qui renvoient une valeur bool√©enne en fonction de la valeur de la cellule de bande qu'ils consultent, et les actions sont des fonctions sans param√®tres qui effectuent l'une ou l'autre action pour changer la cellule de bande et d√©placer la t√™te de la machine de Turing. <br><br>  Ce SKA a le m√™me ensemble d'√©tats que l'automate de la figure 3.  De plus, en plus du mappage d'automate lui-m√™me, pr√©sent√© par SKA, il impl√©mente deux autres mappages: mappage de l'ensemble des pr√©dicats (x1, ..., xM) sur l'ensemble des canaux d'entr√©e de la m√™me machine, et l'ensemble des canaux de sortie de la machine sur l'ensemble des m√™mes actions - y1, ..., yN.  Par exemple, le pr√©dicat x3 retournera vrai (valeur 1 pour le signal d'entr√©e du m√™me nom), s'il y a un 1 dans la cellule courante, et l'action y4, qui sera d√©clench√©e lorsque le m√™me signal de sortie de la machine prendra la valeur 1, correspondra √† d√©placer la t√™te vers la gauche (L) et etc.  etc. <br><br>  Notez que le SKA ne contr√¥le pas directement la bande, mais impl√©mente des mappages [suppl√©mentaires], reliant les signaux de l'automate aux fonctions qui d√©terminent les nombreuses op√©rations de la machine de Turing.  Cela nous convainc encore une fois qu'il n'est pas n√©cessaire d'introduire le concept d'un objet de contr√¥le automatis√© dans une situation o√π le concept de cartographie ¬´√† l'ancienne¬ª, mais math√©matiquement rigoureux est suffisant. <br><br>  Comparaison des automates de la Fig.  3 et fig.  4, on peut voir que SKA n'utilise pas la commande ¬´*¬ª (voir Fig. 1).  Dans une situation similaire, il lui suffit de ne pas √©mettre de signal li√© √† cette commande.  De plus, deux signaux ou plus (entr√©e et sortie) √† la m√™me transition sont parall√®les.  Par cons√©quent, en cas de conflit d'acc√®s aux objets partag√©s (par exemple, vous devez changer la cellule et d√©placer la t√™te), un accord est utilis√©: les actions sur une transition sont ex√©cut√©es s√©quentiellement dans l'ordre de leur nombre, c'est-√†-dire  une action avec un nombre sup√©rieur est ex√©cut√©e apr√®s une action avec un nombre inf√©rieur.  Cet accord ne s'applique pas aux pr√©dicats, car  ils ne changent pas la bande.  Nous rendons donc la machine plus compacte et intuitive (pas besoin d'introduire des √©tats interm√©diaires). <br><br>  Au cours du test du programme d'incr√©mentation, des situations ont √©t√© identifi√©es o√π des probl√®mes peuvent survenir pendant le fonctionnement du MT.  Premi√®rement, la vraie bande n'est pas infinie et aller au-del√† peut entra√Æner le plantage d'un programme.  Deuxi√®mement, il est n√©cessaire d'indiquer la position initiale de la t√™te.  Sans cela, si, par exemple, le nombre est √† un endroit arbitraire de la bande et que l'√©tat initial de la t√™te est √† gauche du nombre et en face de l'espace, alors la t√™te commencera imm√©diatement √† se d√©placer vers la gauche.  Ensuite, il peut aller au-del√† des limites de la bande, provoquant le "plantage" du programme, ou, apr√®s avoir fait un pas vers la gauche, il √©crit dans la cellule 1 et, suspendu, termine l'op√©ration "r√©ussie".  Ou, si le num√©ro contient 1 dans tous les chiffres et est √©crit depuis le d√©but de la bande, la derni√®re tentative de transfert de 1 vers le chiffre principal entra√Ænera le m√™me ¬´crash¬ª. <br><br>  <b>2.1.</b>  <b>Impl√©mentation d'objet de MT en C ++</b> <br><br>  Consid√©rez l'impl√©mentation du logiciel objet d'une machine Turing en C ++ dans l'environnement VKPa, qui impl√©mente n'importe quel programme pour MT, y compris le programme de calcul d'incr√©ment. <br><br>  √Ä cet effet, une classe de base a √©t√© cr√©√©e qui repr√©sente n'importe quelle machine Turing, h√©rit√©e par des objets logiciels qui impl√©mentent l'un ou l'autre programme MT.  Celui-ci est illustr√© dans le listing 1, et le programme qui impl√©mente la t√¢che d'incr√©mentation est indiqu√© dans le listing 2. <br><br>  Listing 1. Impl√©mentation logicielle de la classe de base MT <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> class FTuringMashine : public LFsaAppl { public: FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL); protected: int x15(); int x16(); void y14(); void y15(); void y16(); void y17(); QString strSrc; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    QString strTape; //  QString strHead; //  int nIndexHead{0}; //   bool bRestart{false}; //   int nHeadPosition{0}; //    }; #include "stdafx.h" #include "FTuringMashine.h" FTuringMashine::FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL): LFsaAppl(pTBL, strNam, nullptr, pCVFL) { nHeadPosition = 0; strHead = "________________________________________"; nIndexHead = nHeadPosition; } //============================================================== //  //  ? int FTuringMashine::x15() { return strTape[nIndexHead] == '#'; } // ? int FTuringMashine::x16() { return bRestart; } //============================================================== //  //      void FTuringMashine::y14() { strTape[nIndexHead] = '#'; } //    ( ) void FTuringMashine::y15() { nIndexHead++; } //    ( ) void FTuringMashine::y16() { nIndexHead--; } //     void FTuringMashine::y17() { strTape = strSrc; nIndexHead = 0; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre> <br>  Listing 2. Programme d'incr√©mentation pour une machine de Turing <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTIncrement : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTIncrement(nameFsa, pCVarFsaLibrary); } FTIncrement(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); void y1(); void y2(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTIncrement.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TIncrement[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . . , .   , 2- , 2011 ., // .17-18 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= LArc(" ", " ", "^x1", "y15"), LArc(" ", " ", "x1", "y16"), LArc(" ", " ", "x2", "y2y16"), LArc(" ", "", "x1", "y1"), LArc(" ", "", "x3", "y1"), LArc("", " ", "x16", "y17"), LArc() }; FTIncrement::FTIncrement(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TIncrement) { strSrc = "11011110011111 "; strTape = strSrc; } //  int FTIncrement::x1() { return strTape[nIndexHead] == ' '; } int FTIncrement::x2() { return strTape[nIndexHead] == '1'; } int FTIncrement::x3() { return strTape[nIndexHead] == '0'; } //  void FTIncrement::y1() { strTape[nIndexHead] = '1'; } void FTIncrement::y2() { strTape[nIndexHead] = '0'; }</span></span></span></span></code> </pre><br>  <b>2.2.</b>  <b>Exemples de programmes pour MT avec impl√©mentation en C ++</b> <br><br>  Prenons un exemple de programme pour MT qui "agit comme un accepteur de langage, c'est-√†-dire  il peut reconna√Ætre la langue ¬ªde [9].  Sa fonction de transition est repr√©sent√©e sur la Fig.  5, et l'automate √©quivalent sous forme de SKA sur la Fig.  6. <br><br><pre> <code class="plaintext hljs">Œ¥(1, a) = (2, x, R) Œ¥(1, y) = (4, y, R) Œ¥(2, a) = (2, a, R) Œ¥(2, y) = (2, y, R) Œ¥(2, b) = (3, y, L) Œ¥(3, y) = (3, y, L) Œ¥(3, a) = (3, a, R) Œ¥(3, x) = (1, x, R) Œ¥(4, y) = (4, a, R) Œ¥(4, #) = (F, #, L)</code> </pre> <br>  <i>Fig.</i>  <i>5. La fonction de transition de la machine de Turing, reconnaissant le langage {anbn: n‚â•1}</i> <br><br><img src="https://habrastorage.org/webt/z9/ab/hl/z9abhlvacupxhkbuzbfbupsmikq.jpeg" alt="image"><br>  <i>Fig.</i>  <i>6. Graphique SKA d'une machine de Turing qui reconna√Æt le langage {anbn: n‚â•1}</i> <br><br>  L'unit√© de contr√¥le MT sous forme de SKA a 6 canaux d'entr√©e et 7 canaux de sortie.  Le programme accepteur comprend √©galement le nombre correspondant de pr√©dicats et d'actions, qui sont pr√©sent√©s dans la figure √† droite du graphique de l'automate.  L'impl√©mentation du programme C ++ dans l'environnement VKPA est illustr√©e dans le Listing 3. <br><br>  Listing 3. Programme pour une machine Turing qui reconna√Æt la langue {anbn: n‚â•1} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> extern LArc TBL_TAcceptor[]; class FTAcceptor : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTAcceptor(nameFsa, pCVarFsaLibrary); } FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB = TBL_TAcceptor); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y18(); int nState{1}; friend class CDlgTAcceptor; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTAcceptor.h"</span></span></span><span class="hljs-meta"> LArc TBL_TAcceptor[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . .Ma  .   . 2013 ., //     , .304 //=====    ============== // f(1,a) = (2,x,R) f(1,y) = (4,y,R) // f(2,a) = (2,x,R) f(2,y) = (2,y,R) // f(2,b) = (2,x,R) f(3,y) = (3,y,L) // f(3,a) = (3,a,R) f(3,x) = (1,x,R) // f(4,y) = (4,a,R) f(4,#) = (F,#,L) //========================================= LArc("1", "2","x1", "y1y15"), // 1,a,2,x,R LArc("1", "4","x3", "y15"), // 1,y,4,R LArc("2", "2","x1", "y15"), // 2,a,2,R LArc("2", "3","x2", "y2y16"), // 2,b,3,y,L LArc("2", "2","x3", "y15"), // 2,y,2,R LArc("3", "3","x1", "y16"), // 3,a,3,L LArc("3", "3","x3", "y16"), // 3,y,3,L LArc("3", "1","x4", "y15"), // 3,x,1,R LArc("4", "4","x3", "y2y15"), // 4,y,4,a,R LArc("4", "F","x15", "-"), // 4,#,F,-,- LArc("F", "1","x16", "y17"), // LArc("1", "1","x16", "y17"), // LArc("2", "1","x16", "y17"), // LArc("3", "1","x16", "y17"), // LArc("4", "1","x16", "y17"), // // LArc("1", "1","--", "y18"), // LArc() }; FTAcceptor::FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB): FTuringMashine(strNam, pCVFL, pTB) { strSrc = "aaaaaaaaaabbbbbbbbbb#"; strTape = strSrc; } int FTAcceptor::x1() { return strTape[nIndexHead] == 'a'; } int FTAcceptor::x2() { return strTape[nIndexHead] == 'b'; } int FTAcceptor::x3() { return strTape[nIndexHead] == 'y'; } int FTAcceptor::x4() { return strTape[nIndexHead] == 'x'; } void FTAcceptor::y1() { strTape[nIndexHead] = 'x'; } void FTAcceptor::y2() { strTape[nIndexHead] = 'y'; } void FTAcceptor::y3() { strTape[nIndexHead] = 'a'; } void FTAcceptor::y18() { switch(nState) { case 1: if (x1()) { nState = 2; y1(); y5(); break; } if (x3()) { nState = 4; y5(); break; } break; case 2: if (x1()) { nState = 2; y5(); break; } if (x2()) { nState = 3; y2();y6(); break; } if (x3()) { nState = 2; y5(); break; } break; case 3: if (x1()) { nState = 3; y6(); break; } if (x3()) { nState = 3; y6(); break; } if (x4()) { nState = 1; y5(); break; } break; case 4: if (x3()) { nState = 4; y2(); y5(); break; } if (x5()) { nState = 5; break; } break; case 5: if (x6()) { y7(); nState = 1; break; } break; } }</span></span></span></span></code> </pre><br>  Dans le Listing 3, l'action y18 repr√©sente une variante du programme MT conform√©ment √† l'approche technologique SWITCH.  Dans le cadre de la mise en ≈ìuvre de la programmation automatique de l'environnement VKPA, dans ce cas, au lieu de l'automate de la Fig.  6, il sera n√©cessaire de mettre en ≈ìuvre un automate √† un √©tat, qui √©met un signal y18 dans le cycle.  Il correspond √† la ligne comment√©e de la table de conversion du listing 3. Pour que la machine automatique fonctionne comme SWICH, vous devez supprimer le commentaire de cette ligne et commenter les lignes restantes. <br><br>  Prenons un autre exemple de programme pour une machine de Turing de [7], o√π MT est d√©fini comme ¬´une extension tr√®s simple d'un mod√®le de machine √† √©tats finis¬ª.  Dans ce cas, le programme de la machine de Turing est une liste finie de cinq fonctions partiellement d√©finies des transitions et des sorties Œ¥: S √ó XÔÇÆS √ó X √ó G. <br><br>  Le programme MT, qui trouve le plus grand diviseur commun (GCD) de deux nombres, est illustr√© √† la Fig.  7. Le graphique SKA √©quivalent √† celui-ci est pr√©sent√© √† la Fig.  8. Notez que la commande de r√©√©criture n'est pas utilis√©e ici non plus.  L'impl√©mentation C ++ est pr√©sent√©e dans le Listing 4. <br><br><img src="https://habrastorage.org/webt/ce/zf/s_/cezfs_layjwqcyzmvo0vhqupkwk.jpeg" alt="image"><br>  <i>Fig.</i>  <i>7. Le graphique de transition d'une machine de Turing qui calcule le GCD de deux nombres et plusieurs de ses configurations lors du traitement d'une paire de nombres &lt;4, 6&gt;</i> <i><br></i> <br><img src="https://habrastorage.org/webt/_p/ai/vl/_paivlzhwtehlewnthhkcrpndba.jpeg" alt="image"><br>  <i>Fig.</i>  <i>8. Le graphique SKA, √©quivalent au graphique de la Fig.</i>  <i>7</i> <br><br>  Listing 4. Programme pour une machine de Turing pour trouver le GCD de deux nombres <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTGrCmDiv: public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTGrCmDiv(nameFsa, pCVarFsaLibrary); } FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y17(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTGrCmDiv.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TGrCmDiv[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//=====     (Greatest Common Divider) ============== // . ..   , - .: , 2003. - 208 . // .194 // .  ..    . .:  , 1974, - 200. // .76, 84-87 LArc("s","s","x1", "y16"), // LArc("s","s","x2", "y16"), // LArc("s","p","x3", "y1"), // LArc("s","r","x15", "y15"), // LArc("p","p","x1", "y15"), // LArc("p","p","x2", "y15"), // LArc("p","s","x3", "y2"), // LArc("p","q","x15", "y16"), // LArc("q","q","x1", "y3y16"), // LArc("q","q","x2", "y14y16"), // LArc("q","s","x3", "y15"), // LArc("q","s","x15", "y15"), // LArc("r","r","x1", "y14y15"), // LArc("r","r","x2", "y3y15"), // LArc("r","s","x3", "y16"), // LArc("r","!","x15", "--"), // LArc("!","s","x16", "y17"), // LArc() }; FTGrCmDiv::FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TGrCmDiv) { nHeadPosition = 4; strSrc = "#1111111111## "; strTape = strSrc; nIndexHead = nHeadPosition; } int FTGrCmDiv::x1() { return strTape[nIndexHead] == 'a'; } int FTGrCmDiv::x2() { return strTape[nIndexHead] == 'b'; } int FTGrCmDiv::x3() { return strTape[nIndexHead] == '1'; } int FTGrCmDiv::x4() { return strTape[nIndexHead] == '#'; } void FTGrCmDiv::y1() { strTape[nIndexHead] = 'a'; } void FTGrCmDiv::y2() { strTape[nIndexHead] = 'b'; } void FTGrCmDiv::y3() { strTape[nIndexHead] = '1'; } void FTGrCmDiv::y17() { strTape = strSrc; nIndexHead = 4; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre><br>  En conclusion, un autre programme MT des d√©veloppeurs de la technologie SWITH, consid√©r√© dans l'article [11], qui pr√©sente la t√¢che de reconna√Ætre les crochets en deux versions.  L'un est sous la forme d'une machine Miley, le second est une machine mixte (respectivement sur la figure 9 et la figure 11).  Les automates structurels qui leur correspondent sont repr√©sent√©s sur la Fig.  10 et fig.  12. L'impl√©mentation du programme C ++ est pr√©sent√©e dans le Listing 5. <br><br><img src="https://habrastorage.org/webt/z4/uk/_t/z4uk_t3un74er2osfmikfgmrhni.jpeg" alt="image"><br>  <i>Fig.</i>  <i>9. Reconnaissance de crochets d'une profondeur arbitraire.</i>  <i>Graphique de conversion de miles</i> <br><br><img src="https://habrastorage.org/webt/is/s6/mg/iss6mgjxclciek9s1az1t70oomg.jpeg" alt="image"><br>  <i>Fig.</i>  <i>10. Reconnaissance de crochets d'une profondeur arbitraire.</i>  <i>Earl SKA Miles</i> <br><br><img src="https://habrastorage.org/webt/dp/xy/_k/dpxy_kpzxw59qwy2tu0_c_fhpz8.jpeg" alt="image"><br>  <i>Fig.</i>  <i>11. Reconnaissance de crochets d'une profondeur arbitraire.</i>  <i>Graphique de transition d'un automate mixte</i> <br><br><img src="https://habrastorage.org/webt/un/ju/2h/unju2hogmmbwqr1zs4rnaxolbj4.jpeg" alt="image"><br>  <i>Fig.</i>  <i>12. Reconnaissance de crochets d'une profondeur arbitraire.</i>  <i>Graphique SCA des transitions d'un automate mixte</i> <br><br>  Listing 5. Programme pour une machine de Turing pour reconna√Ætre les parenth√®ses <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTListing2 : public FTuringMashine { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTListing2(nameFsa, pCVarFsaLibrary); } FTListing2(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y4(); void y5(); int i{0}; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTListing2.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TListing2[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// .  ..,  ..     , , ‚Ññ2, .144-149 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= /* //  LArc("0", "1", "x2", "y2"), // '(';  LArc("0", "3", "x3", "--"), // '('; LArc("1", "1", "x2", "y2"), // '(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "3", "^x1x4", "--"), // i!=0;' ';  LArc("1", "3", "x1x3", "--"), // i==0;')';  LArc("1", "2", "x1x4", "--"), // i==0;' ';  LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  */ //* //   - LArc("0", "1", "x2", "y2"), // '(' LArc("0", "3", "x3", "--"), // ')' LArc("1", "1", "x2", "y2"), //'(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "2", "x1x4", "--"), // i==0;' '; LArc("1", "3", "^x1x4", "--"), // i!=0;' '; LArc("1", "3", "x1x3", "--"), // i==0;')'; LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  //*/ LArc() }; FTListing2::FTListing2(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TListing2) { strSrc = "(()()) "; strTape = strSrc; } //  int FTListing2::x1() { return i == 0; } int FTListing2::x2() { return strTape[nIndexHead] == '('; } // int FTListing2::x3() { return strTape[nIndexHead] == ')'; } // int FTListing2::x4() { return strTape[nIndexHead] == ' '; } // //  void FTListing2::y1() { i = 0; } // z1_0 void FTListing2::y2() { i++; } // z1_1 void FTListing2::y3() { i--; } // z1_2 void FTListing2::y4() { strTape = ""; } // z2_0 void FTListing2::y5() { strTape = ""; } // z2_1 void FTListing2::MooreAction() { string strState = FGetState(); if (strState=="0") { y1(); } //   else if (strState=="1") { y15(); } //    else if (strState=="2") { y4(); } //  else if (strState=="3") { y5(); } //  }</span></span></span></span></code> </pre><br>  Depuis l'automate de la Fig.  12 a refus√© de travailler, il a √©t√© d√©cid√© d'aller √† la machine de la Fig.  9. Une machine automatique √©quivalente √† celle-ci sous la forme d'un SKA est illustr√©e √† la Fig.  10. Certes, formellement, il s'agit √©galement d'un automate mixte, √† partir duquel le signal √† l'√©tat "0" et le signal y15 √† l'√©tat "1" ont √©t√© laiss√©s par la premi√®re impl√©mentation (Fig. 12).  Le premier est n√©cessaire lors de l'installation initiale, et le signal y15 impl√©mente un d√©calage de t√™te vers la droite afin de lire le caract√®re de bande suivant.  Le reste du SKA correspond √† la machine Miles de la Fig.  9. <br><br>  Apr√®s l'automate de la fig.  10 a √©t√© test√© avec succ√®s, retourn√© √† la machine de la Fig.  11. Et il est devenu clair que le signal z1_1 avec l'√©tat "1" lui est superflu (pour l'automate de la figure 12 c'est le signal y2).  Le probl√®me est que lorsqu'il trouve le "crochet gauche", il incr√©mente le compteur de deux unit√©s, et quand il trouve le "crochet gauche" il ne le change pas du tout.  Ainsi, lorsque le ¬´crochet gauche¬ª est d√©tect√©, il est appel√© deux fois - une fois sur la boucle marqu√©e x2 / y2, et la deuxi√®me fois en entrant dans l'√©tat.  Et quand un ¬´crochet droit¬ª est d√©tect√©, le compteur diminue d'abord sur la boucle, puis augmente en entrant dans l'√©tat. <br><br>  La raison de ce travail du contr√¥le MT est dans l'interpr√©tation incorrecte par les auteurs du fonctionnement d'un automate de type Moore.  Apparemment, ils croient qu'un signal avec un √©tat sur l'automate Moore n'est ex√©cut√© que lorsqu'il entre dans cet √©tat (voir la transition de l'√©tat ¬´0¬ª √† ¬´1¬ª), mais en fait, il est √©mis chaque fois que vous entrez dans cet √©tat.  Y compris lors du passage en boucle.  Il ne s'agit donc pas d'une erreur (qui ne s'est pas tromp√©?), Mais d'un probl√®me plus grave - une interpr√©tation incorrecte dans le cadre de la technologie SWITH de fonctionnement des automates de type Moore.  Le test du mod√®le √©quivalent l'a montr√©. <br><br>  <b>3. Conclusion</b> <br><br>  Pour r√©sumer, nous pouvons dire qu'il n'y a pas de diff√©rences formelles entre Turing et la programmation automatique, comme  La machine de Turing est un mod√®le abstrait de programmes d'automates.  Dans ce dernier cas, un ensemble plus large d'op√©rateurs et de structures de donn√©es (m√©moire) sont utilis√©s.  Nous pouvons maintenant r√©pondre en toute confiance √† la question de savoir comment la machine Post, en tant que mod√®le de programmes ordinaires, diff√®re de la machine Turing, le mod√®le des programmes automatiques.  Mod√®le de gestion et seulement cela, car  le reste - la m√©moire et les op√©rateurs peuvent √™tre les m√™mes. <br>  Par cons√©quent, la programmation ordinaire ne diff√®re de la programmation automatique que par une chose: le mod√®le de contr√¥le.  Ainsi, alors que pour la mise en ≈ìuvre d'automates, des op√©rateurs de commande ordinaires du type commutateur sont utilis√©s et similaires ne peuvent pas √™tre utilis√©s, √† proprement parler, une telle programmation est consid√©r√©e comme automatique.  Cela peut √™tre une imitation d'automates avec la perte de leurs propri√©t√©s sp√©cifiques et rien de plus. <br><br>  Ainsi, en donnant une d√©finition des concepts de programme d'automate et de programmation d'automate, il ne faut pas parler d '¬´objets de contr√¥le automatis√©s¬ª, mais de programmes et uniquement de programmes qui ont le contr√¥le sous la forme d'une machine √† √©tats finis classique. <br>  Et un autre fait int√©ressant sur lequel je voudrais attirer l'attention.  Au d√©but des ann√©es 2000, les auteurs ont exprim√© leur compr√©hension de la programmation automatique pour un large public.  Leurs articles sur les machines abstraites ont √©t√© publi√©s dans le magazine PC World n ¬∞ 2 de 2002 [11, 12, 13].  On peut affirmer qu'au fil des ans, les condamnations des parties n'ont pas √©t√© affect√©es.  Bien que cela ne refl√®te peut-√™tre que le degr√© de leur confiance dans les d√©cisions choisies. <br><br>  Par exemple, dans ¬´une nouvelle conf√©rence sur la programmation automatique¬ª A. Shalyto  Par rapport √† la pr√©c√©dente ¬´conf√©rence avec diapositives¬ª (il y a dix ans), seule une vid√©o de l'exemple bas√© sur le ¬´package de pointe¬ª Stateflow a √©t√© ajout√©e.  Il semblerait que cela confirme l'exactitude des id√©es d'A. Shalyto, car  ce qui n'a pas pu √™tre impl√©ment√© au sein d'UniMod (le projet semble ¬´gel√©¬ª), incarnent les d√©veloppeurs de Stateflow.  Et, probablement, ce n'est pas si important qui l'a fait ... <br><br>  Cependant, au moment de la publication des articles mentionn√©s, les auteurs de la technologie SWITCH en connaissaient d√©j√† les critiques.  Ce n'√©tait pas un secret puisque  il √©tait disponible sur le site Web de SoftCraft [14].  Il a √©galement cr√©√© des sections consacr√©es √† la programmation automatique en g√©n√©ral et √† la technologie SWITH et √† la technologie KA en particulier.  Les positions des auteurs ont √©t√© discut√©es sur le forum du site (il √©tait ouvert √† l'√©poque).  Mais tous ne sont pas convaincus. <br><br>  Les r√©sultats pour le moment sont les suivants.  La critique exprim√©e √† propos de la technologie SWITH √©tait une fois pertinente et actuelle.  Il s'applique √©galement au package Stateflow.  Dans la technologie SWITH, il n'y en avait pas, et il n'y a pas de d√©finition claire de la programmation automatique, l'approche de la mise en ≈ìuvre des automates n'a pas chang√©, le mod√®le lui-m√™me n'est pas classique, il n'y a pas de mod√®le de calcul parall√®le, etc.  etc.  Sans √©liminer ces probl√®mes, une telle programmation automatis√©e revendique au mieux un r√¥le assez limit√©. <br><br>  Les raisons des probl√®mes mentionn√©s ci-dessus sont assez claires: la th√©orie des programmes est ignor√©e, la th√©orie des automates est oubli√©e, bien que beaucoup de bons et corrects mots soient dits sur les automates eux-m√™mes et leurs merveilleuses propri√©t√©s.  Mais en fait, ce sont d'autres machines.  L'auteur est convaincu de la doutes des tentatives mal con√ßues de cr√©er des mod√®les originaux.  Il s'agit de mod√®les synchrones, r√©actifs et autres.  Ils peuvent √™tre pratiques pour r√©soudre une classe √©troite de probl√®mes et rien de plus.  Mais ce qui est plus grave, c'est qu'ils sortent de la th√©orie des automates sans avoir leur propre th√©orie.  Mais le mod√®le en dehors de la th√©orie est impuissant, et donc pratiquement d√©nu√© de sens. <br><br><div class="spoiler">  <b class="spoiler_title">Les r√©f√©rences</b> <div class="spoiler_text">  1. Shalyto A. A. Une nouvelle conf√©rence sur la programmation automatique.  2019, [Ressource √©lectronique], Mode d'acc√®s: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratuit.  Yaz.  Russe  (date du traitement 5 d√©cembre 2019). <br>  2. Shalyto A.A.  Le paradigme de la programmation automatique.  Bulletin scientifique et technique de l'Universit√© d'√âtat des technologies de l'information, de la m√©canique et de l'optique de Saint-P√©tersbourg.  Vol.  53. Programmation automatis√©e.  2008, p.  3-23. <br>  3. Shalyto A.A.  Le paradigme de la programmation automatique.  Actes de la XIe Conf√©rence panrusse sur la science et l'enseignement sup√©rieur "Recherche fondamentale et innovation dans les universit√©s techniques".  SPbSPU.  2007, p.  202‚Äì205., [Ressource √©lectronique], Mode d'acc√®s: <a href="http://is.ifmo.ru/works/_2007_09_27_shalyto.pdf" rel="nofollow">is.ifmo.ru/works/_2007_09_27_shalyto.pdf</a> , gratuit.  Yaz.  Russe  (date du traitement 5 d√©cembre 2019). <br>  4. Miroshnik I.V.  Th√©orie du contr√¥le automatique.  Syst√®mes lin√©aires.  - Saint-P√©tersbourg: Peter, 2005 .-- 336 p. <br>  5. Mayorov S.A., Novikov G.I.  La structure des ordinateurs √©lectroniques.  - L.: Ing√©nierie, 1979. - 384 p. <br>  6. Minsky M. Calculs et automates.  M .: Mir, 1971. - 364 p. <br>  7. Karpov Yu.G.  Th√©orie des automates.  - Saint-P√©tersbourg: Peter, 2003 .-- 208 p. <br>  8. Polikarpova N., A. Shalyto A. Programmation des automates.  2e √©d., Saint-P√©tersbourg.: Peter, 2011 .-- 176 p. <br>  9. J. MacConell Analyse des algorithmes.  Approche d'apprentissage actif.  3e √©dition.  - M.: Technosph√®re, 2013 .-- 415 p. <br>  10. Algorithmes, logiciels et architecture des syst√®mes informatiques multiprocesseurs.  M.: Nauka, 1982, - 336s. <br>  11. Shalyto A.A., Tukkel N.I.  De la programmation Turing √† // MirPK automatique.  N ¬∞ 2.  <a href="http://is.ifmo.ru/%3Fi0%3Dworks%26i1%3Dturing" rel="nofollow">is.ifmo.ru/?i0=works&amp;i1=turing</a> <br>  12. Lyubchenko V.S.  Exp√©riences sur des machines abstraites.  "PC World", n ¬∞ 2,3 / 02.  <a href="https://www.osp.ru/pcworld/2002/02/162923/" rel="nofollow">www.osp.ru/pcworld/2002/02/162923</a> , <a href="https://www.osp.ru/pcworld/2002/03/163137/" rel="nofollow">www.osp.ru/pcworld/2002/03/163137</a> <br>  13. Lyubchenko V.S.  D'une machine Turing √† une voiture Miley.  ¬´PC World¬ª, n ¬∞ 8/02.  <a href="http://www.osp.ru/pcworld/2002/08/163856/" rel="nofollow">www.osp.ru/pcworld/2002/08/163856</a> <br>  14. Site Web de SoftCraft.  Utilisation de la th√©orie des automates dans la programmation.  [Ressource √©lectronique], Mode d'acc√®s: <a href="http://www.softcraft.ru/auto/" rel="nofollow">www.softcraft.ru/auto</a> , gratuit.  Yaz.  Russe  (date du traitement 5 d√©cembre 2019). <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481998/">https://habr.com/ru/post/fr481998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481978/index.html">Comment organiser le travail efficace d'une √©quipe de mise en page distribu√©e</a></li>
<li><a href="../fr481980/index.html">Comment nous avons optimis√© les scripts dans Unity</a></li>
<li><a href="../fr481988/index.html">Pourquoi Koji est la ressource parfaite pour les cr√©ateurs d'applications KaiOS novices</a></li>
<li><a href="../fr481990/index.html">Dix ans de malware: les plus gros botnets de 2010</a></li>
<li><a href="../fr481992/index.html">Tekton Pipeline - Pipelines natifs de Kubernetes</a></li>
<li><a href="../fr482000/index.html">Aimez-vous votre entreprise?</a></li>
<li><a href="../fr482002/index.html">R√©daction d'un blog sur les microservices - Partie 3 ¬´Utilisateur¬ª</a></li>
<li><a href="../fr482004/index.html">Nous testons 1C sur le serveur VPS</a></li>
<li><a href="../fr482008/index.html">Constructeur LEGO et z√©ro absolu</a></li>
<li><a href="../fr482010/index.html">"Nouvelles √©pop√©es". Pour les d√©veloppeurs, les ops et les curieux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>