<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 😵 🕜 Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 2 👩🏾‍⚖️ ◀️ ⌚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, kami menerbitkan bagian kedua dari terjemahan ekstensi sintaksis JavaScript menggunakan Babel. 

  

 → Dizzy bagian pertama 

 Cara kerja p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470878/">  Hari ini, kami menerbitkan bagian kedua dari terjemahan ekstensi sintaksis JavaScript menggunakan Babel. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/i-/ll/wz/i-llwz7io9q0spj7eijn8hokkqe.jpeg"></a> <br><br>  → Dizzy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian pertama</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Cara kerja parsing</font> </h2><br>  Parser menerima daftar token dari sistem tokenization kode dan, mempertimbangkan token satu per satu, membangun AST.  Untuk membuat keputusan tentang bagaimana menggunakan token dan memahami token yang dapat diharapkan selanjutnya, parser merujuk pada spesifikasi tata bahasa bahasa. <br><br>  Spesifikasi tata bahasa terlihat seperti ini: <br><br><pre><code class="javascript hljs">... ExponentiationExpression -&gt; UnaryExpression                             UpdateExpression ** ExponentiationExpression MultiplicativeExpression -&gt; ExponentiationExpression                             MultiplicativeExpression (<span class="hljs-string"><span class="hljs-string">"*"</span></span> or <span class="hljs-string"><span class="hljs-string">"/"</span></span> or <span class="hljs-string"><span class="hljs-string">"%"</span></span>) ExponentiationExpression AdditiveExpression    -&gt; MultiplicativeExpression                             AdditiveExpression + MultiplicativeExpression                             AdditiveExpression - MultiplicativeExpression ...</code> </pre> <br>  Ini menggambarkan prioritas mengeksekusi ekspresi atau pernyataan.  Misalnya, ekspresi <code>AdditiveExpression</code> dapat mewakili salah satu konstruksi berikut: <br><br><ul><li>  Expression <code>MultiplicativeExpression</code> . </li><li>  Ekspresi <code>AdditiveExpression</code> , diikuti oleh operator <code>+</code> token, diikuti oleh ekspresi <code>MultiplicativeExpression</code> . </li><li>  Ekspresi <code>AdditiveExpression</code> , diikuti oleh token “ <code>-</code> ”, diikuti oleh ekspresi <code>MultiplicativeExpression</code> . </li></ul><br>  Akibatnya, jika kita memiliki ekspresi <code>1 + 2 * 3</code> , maka akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">(AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  Tetapi tidak akan demikian: <br><br><pre> <code class="javascript hljs">(MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> (AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Program, menggunakan aturan-aturan ini, dikonversi menjadi kode yang dikeluarkan oleh parser: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// ...  parseAdditiveExpression() {    const left = this.parseMultiplicativeExpression();    //    -  `+`  `-`    if (this.match(tt.plus) || this.match(tt.minus)) {      const operator = this.state.type;      //          this.nextToken();      const right = this.parseMultiplicativeExpression();      //        this.finishNode(        {          operator,          left,          right,        },        'BinaryExpression'      );    } else {      //  MultiplicativeExpression      return left;    }  } }</span></span></code> </pre> <br>  Harap dicatat bahwa di sini adalah versi yang sangat disederhanakan dari apa yang sebenarnya ada di Babel.  Tetapi saya berharap bahwa potongan kode ini memungkinkan kita untuk menggambarkan esensi dari apa yang terjadi. <br><br>  Seperti yang Anda lihat, pengurai pada dasarnya bersifat rekursif.  Ini bergerak dari desain prioritas terendah ke desain prioritas tertinggi.  Misalnya, <code>parseAdditiveExpression</code> memanggil <code>parseMultiplicativeExpression</code> , dan konstruk ini memanggil <code>parseExponentiationExpression</code> dan seterusnya.  Proses rekursif ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parsing Keturunan Rekursif</a> . <br><br><h2>  <font color="#3AC1EF">Fungsi this.eat, this.match, this.next</font> </h2><br>  Anda mungkin telah memperhatikan bahwa dalam contoh sebelumnya beberapa fungsi tambahan digunakan, seperti <code>this.eat</code> , <code>this.match</code> , <code>this.next</code> dan lainnya.  Ini adalah fungsi internal parser Babel.  Fungsi-fungsi ini, bagaimanapun, tidak unik untuk Babel, mereka biasanya hadir di parser lain. <br><br><ul><li>  Fungsi <code>this.match</code> mengembalikan nilai boolean yang menunjukkan apakah token saat ini memenuhi kondisi yang ditentukan. </li><li>  Fungsi <code>this.next</code> maju dalam daftar token ke token berikutnya. </li><li>  Fungsi <code>this.eat</code> mengembalikan sama dengan fungsi <code>this.match</code> , dan jika <code>this.match</code> mengembalikan <code>true</code> , maka <code>this.eat</code> melakukan, sebelum mengembalikan <code>true</code> , panggilan ke <code>this.next</code> . </li><li>  Fungsi <code>this.lookahead</code> memungkinkan Anda untuk mendapatkan token berikutnya tanpa bergerak maju, yang membantu untuk membuat keputusan pada node saat ini. </li></ul><br>  Jika Anda melihat kembali kode parser yang kami ubah, Anda akan menemukan bahwa membacanya menjadi lebih mudah: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/statement.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatementParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span></span>{  parseStatementContent(<span class="hljs-comment"><span class="hljs-comment">/* ...*/</span></span>) {    <span class="hljs-comment"><span class="hljs-comment">// ...    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   match        if (this.match(tt._function)) {      this.next();      // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">     ,          this.parseFunction();    }  }  // ...  parseFunction(/* ... */) {    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   eat         node.generator = this.eat(tt.star);    node.curry = this.eat(tt.atat);    node.id = this.parseFunctionId();  } }</span></span></code> </pre> <br>  Saya tahu bahwa saya tidak masuk jauh ke dalam menjelaskan fitur parser.  Oleh karena itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - beberapa sumber daya yang berguna tentang topik ini.  Saya belajar banyak dari mereka dan saya dapat merekomendasikan mereka kepada Anda. <br><br>  Anda mungkin tertarik mempelajari tentang bagaimana saya dapat memvisualisasikan sintaks yang saya buat di Babel AST Explorer ketika saya menunjukkan atribut " <code>curry</code> " baru yang muncul di AST. <br><br>  Ini menjadi mungkin karena fakta bahwa saya menambahkan fitur baru di Babel AST Explorer yang memungkinkan Anda memuat parser Anda sendiri ke alat penelitian AST ini. <br><br>  Jika Anda mengikuti <code>packages/babel-parser/lib</code> path <code>packages/babel-parser/lib</code> , Anda dapat menemukan versi kompilasi dari parser dan peta kode.  Di panel <code>Babel AST Explorer</code> , Anda dapat melihat tombol untuk memuat parser Anda sendiri.  Dengan mengunduh <code>packages/babel-parser/lib/index.js</code> Anda dapat memvisualisasikan AST yang dihasilkan menggunakan parser Anda sendiri. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/965/5bf/2b7/9655bf2b7ba72e0c61e31a63a29e3f22.gif"></div><br>  <i><font color="#999999">Visualisasi AST</font></i> <br><br><h2>  <font color="#3AC1EF">Plugin kami untuk Babel</font> </h2><br>  Sekarang setelah pengurai selesai, mari kita menulis sebuah plugin untuk Babel. <br><br>  Tapi, mungkin sekarang Anda memiliki keraguan tentang bagaimana tepatnya kita akan menggunakan parser Babel kita sendiri, terutama mengingat tumpukan teknologi yang kita gunakan untuk membangun proyek. <br><br>  Benar, tidak ada yang perlu ditakutkan.  Plugin Babel dapat memberikan kemampuan parser.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi</a> terkait dapat ditemukan di situs web Babel. <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customParser</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> './</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    parserOverride(code, opts) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> customParser.parse(code, opts);    },  }; }</code> </pre> <br>  Karena kami membuat garpu parser Babel, ini berarti bahwa semua fitur parser yang ada, serta plugin bawaan, akan terus berfungsi dengan baik. <br><br>  Setelah kita menghilangkan keraguan ini, mari kita lihat bagaimana membuat fungsi sedemikian rupa sehingga mendukung currying. <br><br>  Jika Anda tidak tahan dengan harapan dan sudah mencoba menambahkan plug-in kami ke sistem build proyek Anda, Anda mungkin memperhatikan bahwa fungsi yang mendukung currying dikompilasi menjadi fungsi biasa. <br><br>  Ini terjadi karena, setelah parsing dan mengubah kode, Babel menggunakan <code>@babel/generator</code> untuk menghasilkan kode dari AST yang diubah.  Karena <code>@babel/generator</code> tidak tahu apa-apa tentang atribut <code>curry</code> baru, itu hanya mengabaikannya. <br><br>  Jika suatu hari nanti fungsi yang mendukung currying masuk ke standar JavaScript, maka Anda mungkin ingin melakukan PR untuk menambahkan kode baru di <a href="">sini</a> . <br><br>  Untuk membuat fungsi mendukung kari, Anda bisa membungkusnya dengan <code>currying</code> fungsi urutan lebih tinggi: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currying</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numParamsRequired = fn.length;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newParams = params.concat(args);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newParams.length &gt;= numParamsRequired) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...newParams);      }      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory(newParams);    }  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory([]); }</code> </pre> <br>  Jika Anda tertarik pada fitur implementasi mekanisme fungsi currying di JS - lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Akibatnya, kami, mentransformasikan fungsi yang mendukung currying, dapat melakukan ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function @@ foo(a, b, c) {  return a + b + c; } //    const foo = currying(function foo(a, b, c) {  return a + b + c; })</span></span></code> </pre> <br>  Untuk saat ini, kami tidak akan memperhatikan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meningkatkan fungsi</a> dalam JavaScript, yang memungkinkan Anda untuk memanggil fungsi <code>foo</code> sebelum didefinisikan. <br><br>  Seperti apa bentuk kode transformasi: <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    <span class="hljs-comment"><span class="hljs-comment">// ... &lt;i&gt;    visitor: {      FunctionDeclaration(path) {        if (path.get('curry').node) {          // const foo = curry(function () { ... });          path.node.curry = false;          path.replaceWith(            t.variableDeclaration('const', [              t.variableDeclarator(                t.identifier(path.get('id.name').node),                t.callExpression(t.identifier('currying'), [                  t.toExpression(path.node),                ])              ),            ])          );        }      },    },&lt;/i&gt;  }; }</span></span></code> </pre> <br>  Akan lebih mudah bagi Anda untuk mengetahuinya jika Anda membaca materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> tentang transformasi dalam Babel. <br><br>  Sekarang kita dihadapkan dengan pertanyaan tentang bagaimana menyediakan mekanisme ini dengan akses ke fungsi <code>currying</code> .  Di sini Anda dapat menggunakan salah satu dari dua pendekatan. <br><br><h3>  <font color="#3AC1EF">▍ Pendekatan No. 1: dapat diasumsikan bahwa fungsi currying dinyatakan dalam lingkup global</font> </h3><br>  Jika demikian, maka pekerjaan sudah selesai. <br><br>  Jika, ketika mengeksekusi kode yang dikompilasi, ternyata fungsi <code>currying</code> tidak didefinisikan, maka kita akan menjumpai pesan kesalahan yang terlihat seperti " <code>currying is not defined</code> ".  Ini sangat mirip dengan pesan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regeneratorRuntime tidak didefinisikan</a> ". <br><br>  Oleh karena itu, jika seseorang menggunakan <code>babel-plugin-transformation-curry-function</code> Anda, Anda mungkin perlu memberi tahu dia bahwa dia perlu menginstal polyfill curry untuk memastikan plugin ini berfungsi dengan baik. <br><br><h3>  <font color="#3AC1EF">▍ Pendekatan # 2: Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">babel</a> / helper</font> </h3><br>  Anda dapat menambahkan fungsi pembantu baru ke <code>@babel/helpers</code> .  Perkembangan ini tidak mungkin digabungkan dengan <code>@babel/helpers</code> resmi <code>@babel/helpers</code> .  Akibatnya, Anda harus menemukan cara untuk menunjukkan <code>@babel/core</code> lokasi <code>@babel/helpers</code> : <br><br><pre> <code class="javascript hljs">package.json {  <span class="hljs-string"><span class="hljs-string">"resolutions"</span></span>: {    <span class="hljs-string"><span class="hljs-string">"@babel/helpers"</span></span>: <span class="hljs-string"><span class="hljs-string">"7.6.0--your-custom-forked-version"</span></span>,  }</code> </pre> <br>  Saya belum mencoba ini sendiri, tetapi saya percaya bahwa mekanisme ini akan berhasil.  Jika Anda mencobanya dan mengalami masalah, saya akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membahasnya</a> dengan senang hati. <br><br>  <code>@babel/helpers</code> fungsi pembantu baru ke <code>@babel/helpers</code> sangat sederhana. <br><br>  Pertama, buka file <a href="">paket / babel-helpers / src / helpers.js</a> dan tambahkan entri baru: <br><br><pre> <code class="javascript hljs">helpers.currying = helper(<span class="hljs-string"><span class="hljs-string">"7.6.0"</span></span>)<span class="hljs-string"><span class="hljs-string">`  export default function currying(fn) {    const numParamsRequired = fn.length;    function curryFactory(params) {      return function (...args) {        const newParams = params.concat(args);        if (newParams.length &gt;= numParamsRequired) {          return fn(...newParams);        }        return curryFactory(newParams);      }    }    return curryFactory([]);  } `</span></span>;</code> </pre> <br>  Saat mendeskripsikan fungsi tambahan, versi yang diperlukan <code>@babel/core</code> diindikasikan.  Beberapa kesulitan di sini mungkin disebabkan oleh <code>export default</code> fungsi <code>currying</code> . <br><br>  Untuk menggunakan fungsi pembantu, cukup panggil <code>this.addHelper()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... path.replaceWith(  t.variableDeclaration('const', [    t.variableDeclarator(      t.identifier(path.get('id.name').node),      t.callExpression(this.addHelper("currying"), [        t.toExpression(path.node),      ])    ),  ]) );</span></span></code> </pre> <br>  Perintah <code>this.addHelper</code> , jika perlu, akan menyematkan fungsi helper di bagian atas file dan mengembalikan <code>Identifier</code> menunjukkan fungsi yang diimplementasikan. <br><br><h2>  <font color="#3AC1EF">Catatan</font> </h2><br>  Saya telah terlibat dalam mengerjakan Babel selama beberapa waktu, tetapi saya belum harus menambahkan fitur untuk mendukung sintaks JavaScript baru ke parser.  Saya terutama bekerja memperbaiki bug dan meningkatkan apa yang relevan dengan fitur bahasa resmi. <br><br>  Namun, untuk beberapa waktu sekarang saya sibuk dengan gagasan untuk menambahkan konstruksi sintaks baru ke bahasa.  Akibatnya, saya memutuskan untuk menulis materi tentang itu dan mencobanya.  Sangat menyenangkan melihat bahwa semuanya bekerja persis seperti yang diharapkan. <br><br>  Kemampuan untuk mengendalikan sintaksis bahasa yang Anda gunakan adalah sumber inspirasi yang kuat.  Ini memungkinkan, dengan mengimplementasikan beberapa konstruksi kompleks, untuk menulis lebih sedikit kode, atau untuk menulis kode yang lebih sederhana daripada sebelumnya.  Mekanisme untuk mengubah kode sederhana menjadi konstruksi kompleks diotomatisasi dan dipindahkan ke tahap kompilasi.  Ini mengingatkan bagaimana <code>async/await</code> menyelesaikan masalah panggilan balik neraka dan rantai panjang janji. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Di sini kita berbicara tentang bagaimana memodifikasi kemampuan parser Babel, kami menulis plugin transformasi kode kami sendiri, berbicara secara singkat tentang <code>@babel/generator</code> dan tentang membuat fungsi pembantu menggunakan <code>@babel/helpers</code> .  Informasi mengenai transformasi kode hanya diberikan secara skematis.  Baca lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Dalam prosesnya, kami menyentuh beberapa fitur parser.  Jika Anda tertarik dengan topik ini - lalu, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> - sumber daya yang berguna bagi Anda. <br><br>  Urutan tindakan yang kami lakukan sangat mirip dengan bagian dari proses yang dilakukan ketika fitur JavaScript baru dikirimkan ke TC39.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> halaman repositori TC39 tempat Anda dapat menemukan informasi tentang penawaran terkini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan informasi lebih rinci tentang cara bekerja dengan penawaran serupa.  Saat mengajukan fitur JavaScript baru, orang yang menawarkannya biasanya menulis polyfill atau, dengan mengarang Babel, menyiapkan demonstrasi yang membuktikan bahwa kalimat itu berfungsi.  Seperti yang Anda lihat, membuat garpu pengurai atau menulis polyfill bukan bagian yang paling sulit dari proses pengajuan fitur JS baru.  Sulit untuk menentukan bidang subjek inovasi, untuk merencanakan dan memikirkan opsi untuk penggunaannya dan kasus batas;  Sulit untuk mengumpulkan pendapat dan saran dari anggota komunitas programmer JavaScript.  Oleh karena itu, saya ingin mengucapkan terima kasih kepada semua orang yang menemukan kekuatan untuk menawarkan fitur JavaScript baru TC39, sehingga mengembangkan bahasa ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> halaman di GitHub yang memungkinkan Anda melihat gambaran besar dari apa yang kami lakukan di sini. <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda ingin memperluas sintaksis JavaScript? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470878/">https://habr.com/ru/post/id470878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470868/index.html">Waktu untuk byte pertama: apa itu dan mengapa itu penting</a></li>
<li><a href="../id470870/index.html">Prapemuat Font</a></li>
<li><a href="../id470872/index.html">Metrik kinerja untuk meneliti aplikasi web yang sangat cepat</a></li>
<li><a href="../id470874/index.html">Mengoptimalkan pemuatan JavaScript di Wikipedia</a></li>
<li><a href="../id470876/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 1</a></li>
<li><a href="../id470880/index.html">Mekanik game. Petualangan, konsep terapi bicara nol dan menarik</a></li>
<li><a href="../id470882/index.html">Mengapa Anda menangkap mouse saya, atau permainan papan sebagai model interaksi sosial</a></li>
<li><a href="../id470884/index.html">Menulis dan membaca data dalam blockchain Bitcoin</a></li>
<li><a href="../id470888/index.html">Undang-undang Rusia dan internasional di bidang perlindungan data pribadi</a></li>
<li><a href="../id470892/index.html">Implementasi sederhana dari CAM kecil pada FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>