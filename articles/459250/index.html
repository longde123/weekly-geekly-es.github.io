<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïäÔ∏è üñ®Ô∏è ‚ö∞Ô∏è WAL en PostgreSQL: 2. Registro previo üî≥ üî® ü¶Ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La √∫ltima vez, nos encontramos con el dispositivo de uno de los objetos importantes de la memoria compartida, el cach√© del b√∫fer. La posibilidad de pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL en PostgreSQL: 2. Registro previo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La √∫ltima vez,</a> nos encontramos con el dispositivo de uno de los objetos importantes de la memoria compartida, el cach√© del b√∫fer.  La posibilidad de perder informaci√≥n de la RAM es la raz√≥n principal de la necesidad de recuperaci√≥n de una falla.  Hoy hablaremos sobre estas herramientas. <br><br><h1>  Revista </h1><br>  Por desgracia, los milagros no ocurren: para sobrevivir a la p√©rdida de informaci√≥n en la RAM, todo lo necesario debe escribirse en un disco (u otro dispositivo no vol√°til) de manera oportuna. <br><br>  Por lo tanto, esto es lo que se hizo.  Junto con los cambios de datos, tambi√©n se mantiene un <em>diario de</em> estos cambios.  Cuando cambiamos algo en una p√°gina en el cach√© del b√∫fer, creamos un registro en el registro sobre este cambio.  El registro contiene la informaci√≥n m√≠nima suficiente para que, si es necesario, el cambio pueda repetirse. <br><br>  Para que esto funcione, la entrada del diario debe ir necesariamente al disco <em>antes de que</em> llegue la p√°gina modificada.  De ah√≠ el nombre: registro de escritura anticipada. <br><br>  Si ocurre una falla, los datos en el disco est√°n en un estado inconsistente: algunas p√°ginas se escribieron antes, otras m√°s tarde.  Pero queda un diario que puede leer y volver a realizar las operaciones que ya se completaron antes de la falla, pero cuyo resultado no lleg√≥ al disco. <br><a name="habracut"></a><br><blockquote>  ¬øPor qu√© no obligar a las p√°ginas de datos a escribirse en el disco? ¬øPor qu√© hacer doble trabajo?  Resulta muy efectivo. <br>  En primer lugar, un registro es una secuencia secuencial de datos para escribir.  Incluso los discos duros funcionan bastante bien con la grabaci√≥n secuencial.  Pero el registro de los datos en s√≠ es aleatorio, porque las p√°ginas est√°n dispersas en el disco de manera m√°s o menos aleatoria. <br>  En segundo lugar, una entrada de diario puede ser mucho m√°s peque√±a que una p√°gina. <br>  En tercer lugar, al grabar, no tiene que preocuparse por garantizar que los datos en el disco permanezcan consistentes en cualquier momento arbitrario (este requisito complica enormemente la vida). <br>  Y en cuarto lugar, como veremos m√°s adelante, el diario (ya que existe) puede usarse no solo para la recuperaci√≥n, sino tambi√©n para la copia de seguridad y la replicaci√≥n. <br></blockquote><br>  Debe registrar todas las operaciones, durante las cuales existe un riesgo de inconsistencia en el disco en caso de falla.  En particular, se registran las siguientes acciones: <br><br><ul><li>  cambio de p√°ginas en la memoria cach√© del b√∫fer (como regla, estas son tablas y p√°ginas de √≠ndice), ya que la p√°gina cambiada no va inmediatamente al disco; </li><li>  confirmaci√≥n y cancelaci√≥n de transacciones: el cambio de estado se produce en las memorias intermedias XACT y tampoco llega de inmediato al disco; </li><li>  operaciones de archivo (creaci√≥n y eliminaci√≥n de archivos y directorios, por ejemplo, creaci√≥n de archivos al crear una tabla), ya que estas operaciones deben ocurrir simult√°neamente con los cambios de datos. </li></ul><br>  No registrado: <br><br><ul><li>  operaciones con tablas no registradas (no registradas): su nombre habla por s√≠ mismo; </li><li>  operaciones con tablas temporales: no tiene sentido, ya que la duraci√≥n de dichas tablas no excede la duraci√≥n de la sesi√≥n que las cre√≥. </li></ul><br>  Antes de PostgreSQL 10, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndices hash</a> no se registraban (solo serv√≠an para asignar funciones hash a diferentes tipos de datos), pero ahora esto se ha solucionado. <br><br><h1>  Dispositivo l√≥gico </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  L√≥gicamente, un diario puede considerarse como una secuencia de registros de varias longitudes.  Cada registro contiene <em>datos</em> sobre una determinada operaci√≥n, precedidos por un <em>encabezado</em> est√°ndar.  El t√≠tulo, entre otras cosas, indica: <br><br><ul><li>  El n√∫mero de transacci√≥n al que pertenece el registro. </li><li>  administrador de recursos: el componente del sistema responsable de la grabaci√≥n; </li><li>  suma de comprobaci√≥n (CRC): le permite determinar la corrupci√≥n de datos; </li><li>  longitud de registro y enlace al registro anterior. </li></ul><br>  Los datos en s√≠ tienen un formato y significado diferentes.  Por ejemplo, pueden representar alg√∫n fragmento de una p√°gina que debe escribirse sobre su contenido con un cierto desplazamiento.  El administrador de recursos especificado "comprende" c√≥mo interpretar los datos en su registro.  Hay administradores separados para las tablas, para cada tipo de √≠ndice, para el estado de la transacci√≥n, etc. Se puede obtener una lista completa de ellos si lo desea el comando <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Dispositivo f√≠sico </h1><br>  En el disco, el registro se almacena como archivos en el directorio $ PGDATA / pg_wal.  Cada archivo tiene por defecto 16 MB.  El tama√±o se puede aumentar para evitar una gran cantidad de archivos en un directorio.  Antes de PostgreSQL 11, esto solo se pod√≠a hacer al compilar el c√≥digo fuente, pero ahora puede especificar el tama√±o al inicializar el cl√∫ster (la <code>--wal-segsize</code> ). <br><br>  Las entradas de registro se incluyen en el archivo actual en uso;  cuando termina, el siguiente comienza a usarse. <br><br>  Se asignan buffers especiales para el registro en la memoria compartida del servidor.  El tama√±o de la memoria cach√© del diario se establece mediante el par√°metro <em>wal_buffers</em> (el valor predeterminado implica la configuraci√≥n autom√°tica: se asigna 1/32 de la memoria cach√© del b√∫fer). <br><br>  El cach√© de diario est√° organizado como un cach√© de memoria intermedia, pero funciona principalmente en el modo de memoria intermedia de anillo: las entradas se agregan al "encabezado" y se escriben en el disco desde la "cola". <br><br>  Las posiciones de grabaci√≥n ("cola") e inserci√≥n ("cabeza") muestran las funciones pg_current_wal_lsn y pg_current_wal_insert lsn respectivamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Para referirse a un registro espec√≠fico, se usa el tipo de datos pg_lsn (LSN = n√∫mero de secuencia de registro); este es un n√∫mero de 64 bits que representa el desplazamiento de bytes antes del registro en relaci√≥n con el comienzo del registro.  LSN se emite como dos n√∫meros de 32 bits en notaci√≥n hexadecimal. <br><br>  Puede averiguar en qu√© archivo encontraremos la posici√≥n deseada y con qu√© desplazamiento desde el principio del archivo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  El nombre del archivo consta de dos partes.  Los 8 d√≠gitos hexadecimales superiores muestran el n√∫mero de la rama de tiempo (se usa al restaurar desde la copia de seguridad), el resto corresponde a los d√≠gitos LSN m√°s altos (y los d√≠gitos LSN inferiores restantes indican el desplazamiento). <br><br>  Los archivos de registro se pueden ver en el sistema de archivos en el directorio $ PGDATA / pg_wal /, pero a partir de PostgreSQL 10 tambi√©n se pueden ver con una funci√≥n especial: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Escribir hacia adelante </h1><br>  Veamos c√≥mo se registra el diario y c√≥mo se proporciona la grabaci√≥n proactiva.  Crea una tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Veremos el encabezado de la p√°gina de la tabla.  Para hacer esto, necesitamos una extensi√≥n ya familiar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Comencemos la transacci√≥n y recordemos la posici√≥n de inserci√≥n en el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Ahora hagamos alguna operaci√≥n, por ejemplo, actualice la l√≠nea: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Este cambio se registr√≥ en el registro, la posici√≥n de inserci√≥n ha cambiado: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Para garantizar que la p√°gina de datos modificados no se env√≠e al disco antes de la entrada de diario, el LSN de la √∫ltima entrada de diario relacionada con esta p√°gina se almacena en el encabezado de p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Tenga en cuenta que el diario es com√∫n a todo el cl√∫ster y que las nuevas entradas entran en √©l todo el tiempo.  Por lo tanto, el LSN en la p√°gina puede ser menor que el valor que la funci√≥n pg_current_wal_insert_lsn acaba de devolver.  Pero no pasa nada en nuestro sistema, por lo que los n√∫meros son los mismos. <br><br>  Ahora completa la transacci√≥n. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  El registro de confirmaci√≥n tambi√©n va al registro y la posici√≥n cambia nuevamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Commit cambia el estado de una transacci√≥n en una estructura llamada XACT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya hablamos de ello</a> ).  Los estados se almacenan en archivos, pero tambi√©n usan su propio cach√©, que ocupa 128 p√°ginas en la memoria compartida.  Por lo tanto, para las p√°ginas XACT, se debe realizar un seguimiento del LSN de la √∫ltima entrada del diario.  Pero esta informaci√≥n no se almacena en la p√°gina en s√≠, sino en la RAM. <br><br>  En alg√∫n momento, las entradas de diario creadas se escribir√°n en el disco.  En cu√°l: hablaremos en otra ocasi√≥n, pero en nuestro caso esto ya ha sucedido: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Despu√©s de este punto, los datos y las p√°ginas XACT se pueden sacar del cach√©.  Pero si fuera necesario forzarlos antes, se detectar√≠a y las entradas del diario se ver√≠an obligadas a registrarse primero. <br><br>  Conociendo las dos posiciones LSN, puede obtener el tama√±o de las entradas de diario entre ellas (en bytes) simplemente restando una posici√≥n de la otra.  Solo necesita convertir las posiciones al tipo pg_lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  En este caso, la actualizaci√≥n de l√≠nea y la confirmaci√≥n requirieron 108 bytes en el registro. <br><br>  Del mismo modo, puede estimar cu√°ntas entradas de diario genera el servidor por unidad de tiempo en una carga determinada.  Esta es informaci√≥n importante que se requerir√° durante la configuraci√≥n (de la que hablaremos la pr√≥xima vez). <br><br>  Ahora usaremos la utilidad pg_waldump para ver las entradas de registro creadas. <br><br>  La utilidad puede funcionar con el rango LSN (como en este ejemplo) y seleccionar registros para la transacci√≥n especificada.  Debe ejecutarse en nombre del usuario del sistema operativo postgres, ya que necesita acceso a los archivos de registro en el disco. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Aqu√≠ vemos los encabezados de las dos entradas. <br><br>  La primera es la operaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HOT_UPDATE</a> , relacionada con el administrador de recursos del mont√≥n.  El nombre del archivo y el n√∫mero de p√°gina se indican en el campo blkref y coinciden con la p√°gina de la tabla actualizada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  La segunda entrada es COMMIT, relacionada con el Administrador de recursos de transacciones. <br><br>  No es el formato m√°s legible, pero puede resolverlo si es necesario. <br><br><h1>  Recuperaci√≥n </h1><br>  Cuando iniciamos el servidor, el proceso de postmaster comienza primero y, a su vez, inicia el proceso de inicio, cuya tarea es garantizar la recuperaci√≥n si ocurre una falla. <br><br>  Para determinar si se requiere recuperaci√≥n, el inicio busca en el archivo de control especial $ PGDATA / global / pg_control y observa el estado del cl√∫ster.  Podemos verificar el estado nosotros mismos usando la utilidad pg_controldata: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Un servidor cuidadosamente detenido tendr√° el estado "apagado".  Si el servidor no funciona y el estado permanece "en producci√≥n", esto significa que el DBMS ha ca√≠do y luego la recuperaci√≥n se realizar√° autom√°ticamente. <br><br>  Para la recuperaci√≥n, el proceso de inicio leer√° secuencialmente el registro y aplicar√° entradas a las p√°ginas, si es necesario.  Puede verificar la necesidad comparando el LSN de la p√°gina en el disco con el LSN de la entrada del diario.  Si el LSN de la p√°gina es mayor, entonces el registro no es necesario.  Pero, de hecho, ni siquiera es posible, porque los registros est√°n dise√±ados para una aplicaci√≥n estrictamente coherente. <br><br><blockquote>  Hay excepciones  Algunos registros se forman como una imagen de p√°gina completa (FPI, imagen de p√°gina completa), y est√° claro que dicha imagen se puede aplicar a una p√°gina en cualquier estado; todav√≠a borrar√° todo lo que estaba all√≠.  Se puede aplicar otro cambio en el estado de una transacci√≥n a cualquier versi√≥n de la p√°gina XACT; por lo tanto, dentro de dichas p√°ginas no es necesario almacenar LSN. <br></blockquote><br>  El cambio de p√°ginas durante la recuperaci√≥n ocurre en la memoria cach√© del b√∫fer, como durante el trabajo normal, para este administrador de correo comienza los procesos de fondo necesarios. <br><br>  Del mismo modo, las entradas de diario se aplican a los archivos: por ejemplo, si un registro dice que el archivo debe existir, pero no existe, se crea el archivo. <br><br>  Bueno, al final del proceso de recuperaci√≥n, todas las tablas no registradas se sobrescriben con "dummies" de sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capas de inicio</a> . <br><br>  Esta es una presentaci√≥n muy simplificada del algoritmo.  En particular, no hemos dicho nada sobre d√≥nde comenzar a leer las entradas del diario (esta conversaci√≥n tendr√° que posponerse hasta que se considere el punto de control). <br><br>  Y la √∫ltima aclaraci√≥n.  El proceso de recuperaci√≥n "cl√°sico" consta de dos fases.  En la primera fase (avance), las entradas del diario se acumulan y el servidor repite todo el trabajo perdido durante la falla.  En el segundo (revertir), las transacciones que no se comprometieron en el momento de la falla se revierten.  Pero PostgreSQL no necesita una segunda fase.  Como hemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">considerado anteriormente</a> , debido a las peculiaridades de la implementaci√≥n de transacciones de versiones m√∫ltiples, no es necesario revertirlas f√≠sicamente;  es suficiente que el bit de reparaci√≥n no se establezca en XACT. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459250/">https://habr.com/ru/post/459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459240/index.html">10 a√±os en TI diagnosticados con esquizofrenia, consejos de supervivencia</a></li>
<li><a href="../459242/index.html">Despu√©s de la conferencia T + Conf 2019</a></li>
<li><a href="../459244/index.html">Administrador de productos de Notes: comportamiento del usuario en las p√°ginas del juego en la tienda de aplicaciones. ¬øCu√°nto tiempo lleva descargar un juego?</a></li>
<li><a href="../459246/index.html">¬øPor qu√© est√° disminuyendo la conversi√≥n del sitio? Ejemplos de 60 errores de dise√±o y usabilidad</a></li>
<li><a href="../459248/index.html">Eventos digitales en Mosc√∫ del 9 al 14 de julio.</a></li>
<li><a href="../459252/index.html">Semana de la seguridad 28: hackear una casa inteligente</a></li>
<li><a href="../459254/index.html">Bomba Zip a√∫n mejor</a></li>
<li><a href="../459256/index.html">C√≥mo optimizamos nuestro hospital tem√°tico para diferentes plataformas</a></li>
<li><a href="../459258/index.html">14,000 millas no enganchadas</a></li>
<li><a href="../459262/index.html">Retirado a los 22</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>