<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèΩ üï∫üèº üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø OpenSceneGraph: Syst√®me de plugins ü§∞üèΩ üïô üè¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Quelque part dans les le√ßons pr√©c√©dentes, il a d√©j√† √©t√© dit que l'OSG prend en charge le chargement de divers types de ressources telle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Syst√®me de plugins</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438296/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  Quelque part dans les le√ßons pr√©c√©dentes, il a d√©j√† √©t√© dit que l'OSG prend en charge le chargement de divers types de ressources telles que les images raster, les mod√®les 3D de diff√©rents formats ou, par exemple, les polices via son propre syst√®me de plug-in.  Le plugin OSG est un composant distinct qui √©tend les fonctionnalit√©s du moteur et poss√®de une interface normalis√©e au sein de l'OSG.  Le plugin est impl√©ment√© comme une biblioth√®que partag√©e dynamique (DLL sur Windows, donc sur Linux, etc.).  Les noms des biblioth√®ques de plugins correspondent √† une convention sp√©cifique <br><br><pre><code class="plaintext hljs">osgdb_&lt; &gt;.dll</code> </pre> <br>  c'est-√†-dire que le nom du plugin contient toujours le pr√©fixe osgdb_.  Une extension de fichier indique au moteur quel plug-in doit √™tre utilis√© pour t√©l√©charger un fichier avec cette extension.  Par exemple, lorsque nous √©crivons une fonction dans le code <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>);</code> </pre><br>  le moteur voit l'extension osg et charge un plugin nomm√© osgdb_osg.dll (ou osgdb_osg.so dans le cas de Linux).  Le code du plugin fait tout le sale boulot en nous renvoyant un pointeur vers un n≈ìud qui d√©crit le mod√®le cessna.  De m√™me, essayer de charger une image PNG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg:Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.png"</span></span>);</code> </pre><br>  entra√Ænera le chargement du plugin osgdb_png.dll, qui impl√©mente un algorithme pour lire les donn√©es d'une image PNG et placer ces donn√©es dans un objet de type osg :: Image. <br><a name="habracut"></a><br>  Toutes les op√©rations de travail avec des ressources externes sont impl√©ment√©es par les fonctions de la biblioth√®que osgDB, avec lesquelles nous lions invariablement les programmes d'exemple en exemple.  Cette biblioth√®que repose sur le syst√®me de plugins OSG.  √Ä ce jour, le package OSG comprend de nombreux plug-ins qui fonctionnent avec la plupart des formats d'image, des mod√®les 3D et des polices utilis√©es dans la pratique.  Les plugins fournissent √† la fois la lecture de donn√©es (importation) d'un format sp√©cifique et, dans la plupart des cas, l'√©criture de donn√©es dans un fichier du format requis (exportation).  L'utilitaire osgconv, en particulier, vous permet de convertir des donn√©es d'un format √† un autre, par exemple, le syst√®me de plug-in. <br><br><pre> <code class="plaintext hljs">$ osgconv cessna.osg cessna.3ds</code> </pre><br>  il convertit facilement et naturellement le mod√®le osg cessna au format 3DS, qui peut ensuite √™tre import√© dans un √©diteur 3D, par exemple, dans Blender (au fait, il existe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension pour travailler directement avec osg</a> pour Blender) <br><br><img src="https://habrastorage.org/webt/vy/dm/qm/vydmqm2a3evtdqxu2vtf_kknmrw.png"><br><br>  Il existe une liste officielle des plugins OSG standard avec une description de leur objectif, mais elle est longue et je suis trop paresseux pour la pr√©senter ici.  Il est plus facile de regarder le chemin d'installation de la biblioth√®que dans le dossier bin / ospPlugins-xyz, o√π x, y, z est le num√©ro de version OSG.  √Ä partir du nom du fichier du plugin, il est facile de comprendre quel format il traite. <br><br>  Si l'OSG est compil√© par le compilateur MinGW, un pr√©fixe suppl√©mentaire mingw_ est ajout√© au nom standard du plugin, c'est-√†-dire que le nom ressemblera √† ceci <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;.dll</code> </pre><br>  La version du plugin compil√©e dans la configuration DEBUG est en outre √©quip√©e du suffixe d √† la fin du nom, c'est-√†-dire que le format sera <br><br><pre> <code class="plaintext hljs">osgdb_&lt; &gt;d.dll</code> </pre><br>  ou <br><br><pre> <code class="plaintext hljs">mingw_osgdb_&lt; &gt;d.dll</code> </pre><br>  lors de l'assemblage de MinGW. <br><br><h1>  1. Plugins pseudo-chargeurs </h1><br>  Certains plugins OSG remplissent les fonctions de pseudo-chargeurs - cela signifie qu'ils ne sont pas li√©s √† une extension de fichier sp√©cifique, mais en ajoutant un suffixe √† la fin du nom de fichier, vous pouvez sp√©cifier quel plug-in doit √™tre utilis√© pour t√©l√©charger ce fichier, par exemple <br><br><pre> <code class="plaintext hljs">$ osgviewer worldmap.shp.ogr</code> </pre><br>  Dans ce cas, le vrai nom du fichier sur le disque est worldmap.shp - ce fichier stocke une carte du monde au format de fichier de formes ESRI.  Le suffixe .ogr indique √† la biblioth√®que osgDB d'utiliser le plugin osgdb_ogr pour charger ce fichier;  sinon, le plugin osgdb_shp sera utilis√©. <br><br>  Un autre bon exemple est le plugin osgdb_ffmpeg.  La biblioth√®que FFmpeg prend en charge plus de 100 codecs diff√©rents.  Pour lire l'un d'entre eux, nous pouvons simplement ajouter le suffixe .ffmpeg apr√®s le nom du fichier multim√©dia. <br><br>  En plus de cela, certains pseudo-chargeurs nous permettent de passer par un suffixe un certain nombre de param√®tres qui affectent l'√©tat de l'objet charg√©, et nous l'avons d√©j√† rencontr√© dans un exemple d'animation <br><br><pre> <code class="cpp hljs">node = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  La ligne 0.90 indique au plugin osgdb_osg les param√®tres de l'orientation initiale du mod√®le charg√©.  Certains pseudo-chargeurs n√©cessitent des param√®tres compl√®tement sp√©cifiques pour fonctionner. <br><br><h1>  2. API pour d√©velopper des plugins tiers </h1><br>  Il est tout √† fait logique que, apr√®s toute la lecture, vous ayez eu l'id√©e qu'il ne serait probablement pas difficile d'√©crire votre propre plug-in pour OSG, ce qui vous permettrait d'importer un format non standard de mod√®les ou d'images 3D.  Et c'est une vraie pens√©e!  Le m√©canisme du plugin est juste con√ßu pour √©tendre les fonctionnalit√©s du moteur sans changer l'OSG lui-m√™me.  Pour comprendre les principes de base de l'√©criture d'un plugin, essayons d'impl√©menter un exemple simple. <br><br>  Le d√©veloppement du plugin consiste √† √©tendre l'interface de lecture / √©criture virtuelle fournie par OSG.  Cette fonctionnalit√© est fournie par la classe virtuelle osgDB :: ReaderWriter.  Cette classe fournit un certain nombre de m√©thodes virtuelles red√©finies par le d√©veloppeur du plugin. <br><table><thead><tr><th>  La m√©thode </th><th>  La description </th></tr></thead><tbody><tr><td>  supportsExtensions () </td><td>  Il accepte deux param√®tres de cha√Æne: l'extension de fichier et la description.  La m√©thode est toujours appel√©e dans le constructeur de la sous-classe. </td></tr><tr><td>  accepteExtension () </td><td>  Renvoie true si l'extension pass√©e en argument est prise en charge par le plugin </td></tr><tr><td>  fileExists () </td><td>  Vous permet de d√©terminer si un fichier donn√© existe (le chemin est pass√© en param√®tre) sur le disque (retourne vrai en cas de succ√®s) </td></tr><tr><td>  readNode () </td><td>  Accepte le nom de fichier et les options en tant qu'objet osgDB :: Option.  Les fonctions de lecture des donn√©es d'un fichier sont impl√©ment√©es par le d√©veloppeur </td></tr><tr><td>  writeNode () </td><td>  Accepte le nom du n≈ìud, le nom de fichier souhait√© et les options.  Les fonctions d'√©criture des donn√©es sur disque sont impl√©ment√©es par le d√©veloppeur </td></tr><tr><td>  readImage () </td><td>  Lecture des donn√©es bitmap du disque </td></tr><tr><td>  writeImage () </td><td>  √âcriture d'une image bitmap sur le disque </td></tr></tbody></table><br>  L'impl√©mentation de la m√©thode readNode () peut √™tre d√©crite par le code suivant <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         bool recognizableExtension = ...; bool fileExists = ...; if (!recognizableExtension) return ReadResult::FILE_NOT_HANDLED; if (!fileExists) return ReadResult::FILE_NOT_FOUND; //          osg::Node *root = ...; //       -     . //    -      bool errorInParsing = ...; if (errorInParsing) return ReadResult::ERROR_IN_READING_FILE; return root; }</span></span></code> </pre><br>  Il est un peu surprenant qu'au lieu d'un pointeur sur le n≈ìud du graphe de sc√®ne, la m√©thode renvoie le type osgDB :: ReaderWriter :: ReadResult.  Ce type est un objet de r√©sultat de lecture et il peut √™tre utilis√© comme conteneur de noeud, image, √©num√©rateur d'√©tat (par exemple, FILE_NOT_FOUND), un autre objet sp√©cial ou m√™me comme cha√Æne de message d'erreur.  Il a de nombreux constructeurs implicites pour impl√©menter les fonctions d√©crites. <br><br>  Une autre classe utile est osgDB :: Options.  Il peut vous permettre de d√©finir ou d'obtenir une cha√Æne d'options de chargement √† l'aide des m√©thodes setOptionString () et getOptionString ().  La transmission de cette cha√Æne au constructeur de cette classe comme argument est √©galement autoris√©e. <br><br>  Le d√©veloppeur peut contr√¥ler le comportement du plugin en d√©finissant les param√®tres dans la cha√Æne de param√®tres pass√©e lors du chargement de l'objet, par exemple, de cette mani√®re <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    osg::Node* node1 = osgDB::readNodeFile("cow.osg"); //     string osg::Node* node2 = osgDB::readNodeFile("cow.osg", new osgDB::Options(string));</span></span></code> </pre><br><h1>  3. Traitement du flux de donn√©es dans le plugin OSG </h1><br>  La classe de base osgDB :: ReaderWriter comprend un ensemble de m√©thodes qui traitent les donn√©es des flux d'entr√©e / sortie fournies par la biblioth√®que C ++ standard.  La seule diff√©rence entre ces m√©thodes de lecture / √©criture et celles d√©crites ci-dessus est qu'au lieu du nom de fichier, elles acceptent std :: istream &amp; input streams ou std :: ostream &amp; output stream.  L'utilisation d'un flux d'E / S de fichiers est toujours pr√©f√©rable √† l'utilisation d'un nom de fichier.  Pour effectuer des op√©rations de lecture de fichiers, nous pouvons utiliser la conception d'interface suivante: <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... osgDB::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file.c_str(), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadResult::ERROR_IN_READING_FILE; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readNode(stream, options); } ... osgDB::ReaderWriter::<span class="hljs-function"><span class="hljs-function">ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         osg::Node *root = ...; return root; }</span></span></code> </pre><br>  Apr√®s avoir impl√©ment√© le plugin, nous pouvons utiliser les fonctions standard osgDB :: readNodeFile () et osgDB :: readImageFile () pour charger des mod√®les et des images, simplement en sp√©cifiant le chemin du fichier.  OSG trouvera et t√©l√©chargera le plugin que nous avons √©crit. <br><br><h1>  4. Nous √©crivons notre propre plugin </h1><br><br>  Donc, personne ne nous d√©range pour trouver notre propre format de stockage des donn√©es sur la g√©om√©trie tridimensionnelle, et nous le proposerons <br><br>  <strong>piramide.pmd</strong> <br><br><pre> <code class="plaintext hljs">vertex: 1.0 1.0 0.0 vertex: 1.0 -1.0 0.0 vertex: -1.0 -1.0 0.0 vertex: -1.0 1.0 0.0 vertex: 0.0 0.0 2.0 face: 0 1 2 3 face: 0 3 4 face: 1 0 4 face: 2 1 4 face: 3 2 4</code> </pre><br>  Voici au d√©but du fichier une liste de sommets avec leurs coordonn√©es.  Les indices de sommet vont dans l'ordre, √† partir de z√©ro.  Apr√®s la liste des sommets vient une liste de visages.  Chaque face est d√©finie par une liste d'indices de sommets √† partir desquels elle est form√©e.  Apparemment rien de compliqu√©.  La t√¢che consiste √† lire ce fichier √† partir du disque et √† former une g√©om√©trie tridimensionnelle sur sa base. <br><br><h1>  5. Configuration du projet de plugin: construire des fonctionnalit√©s de script </h1><br>  Si avant de cr√©er des applications, nous devons maintenant √©crire une biblioth√®que dynamique, et pas seulement une biblioth√®que, mais un plug-in OSG qui satisfait certaines exigences.  Nous allons commencer √† remplir ces conditions avec un script de construction de projet qui ressemblera √† ceci <br><br>  <strong>plugin.pro</strong> <br><br><pre> <code class="cmake hljs">TEMPLATE = lib CONFIG += plugin CONFIG += no_plugin_name_prefix <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,) win32 { OSG_LIB_DIRECTORY = $$(OSG_BIN_PATH) OSG_INCLUDE_DIRECTORY = $$(OSG_INCLUDE_PATH) DESTDIR = $$(OSG_PLUGINS_PATH) CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -L$$OSG_LIB_DIRECTORY -losgd LIBS += -L$$OSG_LIB_DIRECTORY -losgViewerd LIBS += -L$$OSG_LIB_DIRECTORY -losgDBd LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreadsd LIBS += -L$$OSG_LIB_DIRECTORY -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -L$$OSG_LIB_DIRECTORY -losg LIBS += -L$$OSG_LIB_DIRECTORY -losgViewer LIBS += -L$$OSG_LIB_DIRECTORY -losgDB LIBS += -L$$OSG_LIB_DIRECTORY -lOpenThreads LIBS += -L$$OSG_LIB_DIRECTORY -losgUtil } INCLUDEPATH += $$OSG_INCLUDE_DIRECTORY } unix { DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> CONFIG(debug, debug|release) { <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,,d) LIBS += -losgd LIBS += -losgViewerd LIBS += -losgDBd LIBS += -lOpenThreadsd LIBS += -losgUtild } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LIBS += -losg LIBS += -losgViewer LIBS += -losgDB LIBS += -lOpenThreads LIBS += -losgUtil } } INCLUDEPATH += ./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> HEADERS += $$files(./<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/*.h) SOURCES += $$files(./src/*.cpp)</code> </pre><br>  Nous analyserons plus en d√©tail les nuances individuelles <br><br><pre> <code class="cmake hljs">TEMPLATE = lib</code> </pre><br>  signifie que nous allons construire la biblioth√®que.  Pour √©viter la g√©n√©ration de liens symboliques √† l'aide desquels les probl√®mes de conflits de version de biblioth√®que sont r√©solus dans les syst√®mes * nix, nous indiquons au syst√®me de construction que cette biblioth√®que sera un plug-in, c'est-√†-dire qu'elle sera charg√©e en m√©moire "√† la vol√©e" <br><br><pre> <code class="cmake hljs">CONFIG += plugin</code> </pre><br>  Ensuite, nous excluons la g√©n√©ration du pr√©fixe lib, qui est ajout√© lors de l'utilisation des compilateurs de la famille gcc et est pris en compte par l'environnement d'ex√©cution lors du chargement de la biblioth√®que <br><br><pre> <code class="cmake hljs">CONFIG += no_plugin_name_prefix</code> </pre><br>  D√©finissez le nom du fichier de biblioth√®que <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = osgdb_pmd</code> </pre><br>  o√π pmd est l'extension de fichier du format de mod√®le 3D que nous avons invent√©.  De plus, nous devons indiquer que dans le cas d'un assemblage MinGW, le pr√©fixe mingw_ <br><br><pre> <code class="cmake hljs">win32-g++: <span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = $$join(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>,,mingw_,)</code> </pre><br>  Sp√©cifiez le chemin de cr√©ation de la biblioth√®que: pour Windows <br><br><pre> <code class="cmake hljs">DESTDIR = $$(OSG_PLUGINS_PATH)</code> </pre><br>  pour linux <br><br><pre> <code class="cmake hljs">DESTDIR = /usr/lib/osgPlugins-<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Pour Linux, avec une telle indication du chemin (qui est sans aucun doute une b√©quille, mais je n'ai pas encore trouv√© une autre solution), nous donnons le droit d'√©crire dans le dossier sp√©cifi√© avec les plugins OSG d'un utilisateur ordinaire <br><br><pre> <code class="plaintext hljs"># chmod 666 /usr/lib/osgPlugins-3.7.0</code> </pre><br>  Tous les autres param√®tres de g√©n√©ration sont similaires √† ceux utilis√©s dans l'assemblage d'exemples d'applications pr√©c√©demment. <br><br><h1>  6. Configuration du projet de plugin: fonctionnalit√©s du mode d√©bogage </h1><br>  Puisque ce projet est une biblioth√®que dynamique, il doit y avoir un programme qui charge cette biblioth√®que dans le processus de son ex√©cution.  Il peut s'agir de n'importe quelle application utilisant OSG et dans laquelle la fonction sera appel√©e <br><br><pre> <code class="cpp hljs">node = osdDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"piramide.pmd"</span></span>);</code> </pre><br>  Dans ce cas, notre plugin se chargera.  Afin de ne pas √©crire un tel programme par nous-m√™mes, nous utiliserons une solution pr√™te √† l'emploi - la visionneuse osgviewer standard incluse dans le package de livraison du moteur.  Si dans la console ex√©cutez <br><br><pre> <code class="plaintext hljs">$ osgviewer piramide.pmd</code> </pre><br>  alors il d√©clenchera √©galement le plugin.  Dans les param√®tres de lancement du projet, sp√©cifiez le chemin d'acc√®s √† osgviewerd, en tant que r√©pertoire de travail, sp√©cifiez le r√©pertoire o√π se trouve le fichier piramide.pmd et sp√©cifiez le m√™me fichier dans les options de ligne de commande osgviewer <br><br><img src="https://habrastorage.org/webt/v8/9y/xa/v89yxafvygysowtw7aeihf9mgcs.png"><br><br>  Nous pouvons maintenant ex√©cuter le plugin et le d√©boguer directement √† partir de l'IDE QtCreator. <br><br><h1>  6. Nous impl√©mentons le framework de plugins </h1><br>  Cet exemple g√©n√©ralise dans une certaine mesure les connaissances que nous avons d√©j√† re√ßues sur l'OSG des le√ßons pr√©c√©dentes.  Lors de l'√©criture d'un plugin, nous devons <br><br><ol><li>  S√©lectionnez une structure de donn√©es pour stocker les informations de g√©om√©trie du mod√®le lues dans un fichier de mod√®le <br></li><li>  Lire et analyser (analyser) le fichier de donn√©es du mod√®le <br></li><li>  Configurer correctement l'objet g√©om√©trique osg :: Drawable en fonction des donn√©es lues dans le fichier <br></li><li>  Cr√©er un sous-graphique de sc√®ne pour un mod√®le charg√© <br></li></ol><br>  Donc, par tradition, je donnerai tout le code source du plugin <br><br><div class="spoiler">  <b class="spoiler_title">Plugin Osgdb_pmd</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgDB/FileNameUtils&gt; #include &lt;osgDB/FileUtils&gt; #include &lt;osgDB/Registry&gt; #include &lt;osgUtil/SmoothingVisitor&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct face_t { std::vector&lt;unsigned int&gt; indices; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ struct pmd_mesh_t { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; std::vector&lt;face_t&gt; faces; pmd_mesh_t() : vertices(new osg::Vec3Array) , normals(new osg::Vec3Array) { } osg::Vec3 calcFaceNormal(const face_t &amp;face) const { osg::Vec3 v0 = (*vertices)[face.indices[0]]; osg::Vec3 v1 = (*vertices)[face.indices[1]]; osg::Vec3 v2 = (*vertices)[face.indices[2]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); return n * (1 / n.length()); } }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class ReaderWriterPMD : public osgDB::ReaderWriter { public: ReaderWriterPMD(); virtual ReadResult readNode(const std::string &amp;filename, const osgDB::Options *options) const; virtual ReadResult readNode(std::istream &amp;stream, const osgDB::Options *options) const; private: pmd_mesh_t parsePMD(std::istream &amp;stream) const; std::vector&lt;std::string&gt; parseLine(const std::string &amp;line) const; }; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ ReaderWriterPMD::ReaderWriterPMD() { supportsExtension("pmd", "PMD model file"); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( const std::string &amp;filename, const osgDB::Options *options) const { std::string ext = osgDB::getLowerCaseFileExtension(filename); if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; return readNode(stream, options); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( std::istream &amp;stream, const osgDB::Options *options) const { (void) options; pmd_mesh_t mesh = parsePMD(stream); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(mesh.vertices.get()); for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); geom-&gt;addPrimitiveSet(polygon.get()); } geom-&gt;setNormalArray(mesh.normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); return geode.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ pmd_mesh_t ReaderWriterPMD::parsePMD(std::istream &amp;stream) const { pmd_mesh_t mesh; while (!stream.eof()) { std::string line; std::getline(stream, line); std::vector&lt;std::string&gt; tokens = parseLine(line); if (tokens[0] == "vertex") { osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); mesh.vertices-&gt;push_back(point); } if (tokens[0] == "face") { unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } mesh.faces.push_back(face); mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::string delete_symbol(const std::string &amp;str, char symbol) { std::string tmp = str; tmp.erase(std::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); return tmp; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ std::vector&lt;std::string&gt; ReaderWriterPMD::parseLine(const std::string &amp;line) const { std::vector&lt;std::string&gt; tokens; std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; while ( (pos = tmp.find(':')) != std::string::npos ) { token = tmp.substr(0, pos); tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } tokens.push_back(tmp); return tokens; } REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</span></span></span></span></code> </pre><br></div></div><br>  Tout d'abord, prenons soin des structures de stockage des donn√©es de g√©om√©trie. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">face_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; };</code> </pre><br>  - d√©crit la face d√©finie par la liste des indices des sommets appartenant √† cette face.  Le mod√®le dans son ensemble sera d√©crit par une telle structure <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pmd_mesh_t</span></span></span><span class="hljs-class"> {</span></span> osg::ref_ptr&lt;osg::Vec3Array&gt; vertices; osg::ref_ptr&lt;osg::Vec3Array&gt; normals; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">face_t</span></span>&gt; faces; <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { } osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcFaceNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">face_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;face)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ osg::Vec3 v0 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; osg::Vec3 v1 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; osg::Vec3 v2 = (*vertices)[face.indices[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; osg::Vec3 n = (v1 - v0) ^ (v2 - v0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * (<span class="hljs-number"><span class="hljs-number">1</span></span> / n.length()); } };</code> </pre><br>  La structure se compose de variables membres pour stocker des donn√©es: sommets - pour stocker un tableau de sommets d'un objet g√©om√©trique;  normales - un tableau de normales aux faces de l'objet;  faces - une liste des visages de l'objet.  Le constructeur de la structure initialise imm√©diatement les pointeurs intelligents <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span>() : vertices(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) , normals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array) { }</code> </pre><br>  De plus, la structure contient une m√©thode qui vous permet de calculer le vecteur normal de la face calcFaceNormal () comme param√®tre, qui prend la structure qui d√©crit la face.  Nous n'entrerons pas encore dans les d√©tails de l'impl√©mentation de cette m√©thode, nous les analyserons un peu plus tard. <br><br>  Ainsi, nous avons d√©cid√© des structures dans lesquelles nous allons stocker les donn√©es de g√©om√©trie.  √âcrivons maintenant le framework de notre plugin, √† savoir, nous impl√©mentons la classe h√©riti√®re osgDB :: ReaderWriter <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReaderWriterPMD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgDB::ReaderWriter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReaderWriterPMD(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReadResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgDB::Options *options)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; };</code> </pre><br>  Comme recommand√© dans la description de l'API pour d√©velopper des plugins, dans cette classe, nous red√©finissons les m√©thodes de lecture des donn√©es d'un fichier et de les convertir en un sous-graphique de la sc√®ne.  La m√©thode readNode () effectue deux surcharges - l'une accepte le nom de fichier en entr√©e, l'autre re√ßoit un flux d'entr√©e standard.  Le constructeur de classe d√©finit les extensions de fichiers prises en charge par le plugin <br><br><pre> <code class="cpp hljs">ReaderWriterPMD::ReaderWriterPMD() { supportsExtension(<span class="hljs-string"><span class="hljs-string">"pmd"</span></span>, <span class="hljs-string"><span class="hljs-string">"PMD model file"</span></span>); }</code> </pre><br>  La premi√®re surcharge de la m√©thode readNode () analyse l'exactitude du nom de fichier et du chemin d'acc√®s, associe un flux d'entr√©e standard au fichier et appelle la deuxi√®me surcharge, qui effectue le travail principal <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;filename, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       std::string ext = osgDB::getLowerCaseFileExtension(filename); // ,      if (!acceptsExtension(ext)) return ReadResult::FILE_NOT_HANDLED; // ,       std::string fileName = osgDB::findDataFile(filename, options); if (fileName.empty()) return ReadResult::FILE_NOT_FOUND; //      std::ifstream stream(fileName.c_str(), std::ios::in); if (!stream) return ReadResult::ERROR_IN_READING_FILE; //      readNode() return readNode(stream, options); }</span></span></code> </pre><br>  Dans la deuxi√®me surcharge, nous impl√©mentons l'algorithme de g√©n√©ration d'objet pour OSG <br><br><pre> <code class="cpp hljs">osgDB::ReaderWriter::ReadResult ReaderWriterPMD::readNode( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osgDB::Options *options) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) options; <span class="hljs-comment"><span class="hljs-comment">//   *.pmd       pmd_mesh_t mesh = parsePMD(stream); //    osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; //    geom-&gt;setVertexArray(mesh.vertices.get()); //    for (size_t i = 0; i &lt; mesh.faces.size(); ++i) { //    GL_POLYGON      (  - 0) osg::ref_ptr&lt;osg::DrawElementsUInt&gt; polygon = new osg::DrawElementsUInt(osg::PrimitiveSet::POLYGON, 0); //       for (size_t j = 0; j &lt; mesh.faces[i].indices.size(); ++j) polygon-&gt;push_back(mesh.faces[i].indices[j]); //     geom-&gt;addPrimitiveSet(polygon.get()); } //    geom-&gt;setNormalArray(mesh.normals.get()); //  OpenGL,       geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); //             osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(geom.get()); //     return geode.release(); }</span></span></code> </pre><br>  √Ä la fin du fichier main.cpp, appelez la macro REGISTER_OSGPLUGIN (). <br><br><pre> <code class="cpp hljs">REGISTER_OSGPLUGIN( pmd, ReaderWriterPMD )</code> </pre><br>  Cette macro g√©n√®re du code suppl√©mentaire qui permet √† OSG, sous la forme de la biblioth√®que osgDB, de construire un objet de type ReaderWriterPMD et d'appeler ses m√©thodes pour charger des fichiers de type pmd.  Ainsi, le framework de plugin est pr√™t, la chose reste pour les petits - pour impl√©menter le chargement et l'analyse du fichier pmd. <br><br><h1>  7. Fichier de mod√®le Parsim 3D </h1><br>  Maintenant, toutes les fonctionnalit√©s du plugin reposent sur l'impl√©mentation de parsePMD () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> ReaderWriterPMD::parsePMD(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp;stream) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pmd_mesh_t</span></span> mesh; <span class="hljs-comment"><span class="hljs-comment">//    while (!stream.eof()) { //      std::string line; std::getline(stream, line); //     -     std::vector&lt;std::string&gt; tokens = parseLine(line); //    -  if (tokens[0] == "vertex") { //       osg::Vec3 point; std::istringstream iss(tokens[1]); iss &gt;&gt; point.x() &gt;&gt; point.y() &gt;&gt; point.z(); //      mesh.vertices-&gt;push_back(point); } //    -  if (tokens[0] == "face") { //         unsigned int idx = 0; std::istringstream iss(tokens[1]); face_t face; while (!iss.eof()) { iss &gt;&gt; idx; face.indices.push_back(idx); } //      mesh.faces.push_back(face); //     mesh.normals-&gt;push_back(mesh.calcFaceNormal(face)); } } return mesh; }</span></span></code> </pre><br>  parseLine()    pmd- <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ReaderWriterPMD::parseLine(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;line) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tokens; <span class="hljs-comment"><span class="hljs-comment">//   ,        ( Windows) std::string tmp = delete_symbol(line, '\r'); size_t pos = 0; std::string token; //      ,     : //      while ( (pos = tmp.find(':')) != std::string::npos ) { //     (vertex  face   ) token = tmp.substr(0, pos); //         tmp.erase(0, pos + 1); if (!token.empty()) tokens.push_back(token); } //        tokens.push_back(tmp); return tokens; }</span></span></code> </pre><br>     "vertex: 1.0 -1.0 0.0"     "vertex"  " 1.0 -1.0 0.0".        ‚Äî   ,       .         delete_symbol(),             <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp = str; tmp.erase(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove(tmp.begin(), tmp.end(), symbol), tmp.end()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre><br>             . <br><br><h1> 8.   </h1><br>      (F5).       osgviewerd,      piramide.pmd,        readNode().     ,      <br><br><img src="https://habrastorage.org/webt/s3/5g/-y/s35g-ykmmlet5z8jisj7efkz7je.png"><br><br>           3D-   . <br><br>     ?             <br><br><pre> <code class="cpp hljs">osgUtil::SmoothingVisitor::smooth(*geom);</code> </pre><br>      ,     <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//geom-&gt;setNormalArray(mesh.normals.get()); //geom-&gt;setNormalBinding(osg::Geometry::BIND_PER_PRIMITIVE_SET); osgUtil::SmoothingVisitor::smooth(*geom);</span></span></code> </pre><br>      <br><br><img src="https://habrastorage.org/webt/eb/gd/kt/ebgdktxsplxyqatprxunnwd8r2o.png"><br><br>      ,                .           . ,          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438296/">https://habr.com/ru/post/fr438296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438286/index.html">Utilisation des fuseaux horaires en JavaScript</a></li>
<li><a href="../fr438288/index.html">Protection sans peur. S√©curit√© de la m√©moire dans Rust</a></li>
<li><a href="../fr438290/index.html">Post-mortem avec GGJ-2019: comment obtenir des bosses, mais toujours faire le jeu</a></li>
<li><a href="../fr438292/index.html">Automatisation d'appartement avec HomePod, Raspberry Pi et Node.js</a></li>
<li><a href="../fr438294/index.html">Recherche de streamers Twitch dans une correspondance PUBG</a></li>
<li><a href="../fr438298/index.html">Pourquoi enseigner si le d√©veloppement est plus rentable. Conversation avec GeekBrains</a></li>
<li><a href="../fr438302/index.html">L'incroyable cr√©ativit√© de l'√©volution num√©rique</a></li>
<li><a href="../fr438304/index.html">Sous-traitance? Cool tu frappes</a></li>
<li><a href="../fr438306/index.html">Rayonnement: Laboratoire radiochimique en semaine</a></li>
<li><a href="../fr438310/index.html">Instagram utilise l'apprentissage automatique pour supprimer les faux abonn√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>