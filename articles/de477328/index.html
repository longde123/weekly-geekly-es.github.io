<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõèÔ∏è ‚úçüèø üòΩ Gr√ºnde f√ºr die Einf√ºhrung des statischen Code-Analysators PVS-Studio in den Entwicklungsprozess üë©üèæ‚Äç‚úàÔ∏è üéÖüèΩ üïé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PVS-Studio ist ein Tool zum Auffinden von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # oder Java geschrieb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gr√ºnde f√ºr die Einf√ºhrung des statischen Code-Analysators PVS-Studio in den Entwicklungsprozess</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477328/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d7/969/247/6d7969247b0d23414e5620995aa71f6f.png" alt="Gr√ºnde f√ºr die Einf√ºhrung des statischen Code-Analysators PVS-Studio in den Entwicklungsprozess"></div><br>  PVS-Studio ist ein Tool zum Auffinden von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # oder Java geschrieben wurden.  PVS-Studio geh√∂rt zur Klasse der Tools zum Testen der Sicherheit statischer Anwendungen (Static Application Security Testing, SAST).  Der Analyzer konzentriert sich auf die Praxis der kontinuierlichen Integration (Continuous Integration, CI) und erm√∂glicht es Ihnen, Fehler fr√ºhzeitig zu erkennen, wenn sie behoben werden. <br><a name="habracut"></a><br><h2>  Statische Code-Analyse </h2><br>  Softwareprojekte in ihrem Entwicklungsprozess werden immer mehr.  Beispiele: <br><br><ul><li>  Linux-Kernel 1.0.0: 176.000 Codezeilen </li><li>  Linux-Kernel 5.0: 26.000.000 Codezeilen </li><li>  Photoshop 1.0: 128.000 Codezeilen </li><li>  Photoshop CS 6: 10.000.000 Codezeilen </li></ul><br>  Mit zunehmender Gr√∂√üe eines Projekts w√§chst seine Komplexit√§t schneller als linear.  Aus diesem Grund nimmt mit zunehmender Gr√∂√üe der Codebasis auch die Fehlerdichte zu.  Eine M√∂glichkeit, die zunehmende Komplexit√§t zu kompensieren, besteht in der Verwendung statischer Code-Analysetools. <br><br>  Ein statischer Analysator ist ein Hilfsprogramm f√ºr Programmierer, das eine vorl√§ufige √úberpr√ºfung des Codes durchf√ºhrt und Codefragmente anzeigt, die mit gr√∂√üerer Wahrscheinlichkeit einen Fehler enthalten.  Dadurch k√∂nnen viele Fehler fr√ºhzeitig behoben werden, wenn die Kosten f√ºr deren Behebung minimal sind. <br><br>  <a href="https://www.viva64.com/ru/t/0046/">Die statische Analyse ersetzt</a> nicht andere Methoden zur Fehlererkennung, sondern erg√§nzt sie, z. B. Code√ºberpr√ºfungen, Komponententests, dynamische Codeanalysen, Regressionstests, manuelle Tests usw. <br><br>  Wenn es sich beispielsweise um <a href="https://www.viva64.com/ru/t/0073/">Code√ºberpr√ºfungen handelt</a> , ist es viel besser, wenn das Programm einfache Fehler erkennt.  Dann k√∂nnen sich die Programmierer, die den Code √ºberpr√ºfen, auf n√ºtzlichere √úberpr√ºfungen des Algorithmus konzentrieren und sind nicht gezwungen, <a href="https://www.viva64.com/ru/b/0509/">die Vergleichsfunktionen</a> einzulesen.  Dar√ºber hinaus ist es, wie die <a href="https://www.viva64.com/ru/b/0587/">Praxis</a> zeigt, sehr schwierig, viele Fehler ‚Äûmit den Augen‚Äú zu suchen, und es ist sehr wahrscheinlich, dass sie die Code√ºberpr√ºfungsphase unbemerkt durchlaufen. <br><br>  Ein weiterer Vorteil der statischen Analysetools ist das Vorhandensein einer umfangreichen Datenbank mit Fehlermustern.  Sie k√∂nnen Probleme finden, deren Existenz der Programmierer m√∂glicherweise nicht einmal bemerkt.  Einige Beispiele: <a href="https://www.viva64.com/ru/w/v698/">V698</a> , <a href="https://www.viva64.com/ru/w/v718/">V718</a> , <a href="https://www.viva64.com/ru/w/v1023/">V1023</a> . <br><br><h2>  PVS-Studio </h2><br>  Wir empfehlen die Implementierung des statischen Code-Analysators PVS-Studio, den wir im Entwicklungsprozess entwickelt haben.  Das Produkt l√§uft auf 64-Bit-Systemen unter Windows, Linux und macOS und kann Code analysieren, der f√ºr 32-Bit-, 64-Bit- und eingebettete ARM-Plattformen entwickelt wurde. <br><br>  Zum Zeitpunkt der Ver√∂ffentlichung dieses Artikels unterst√ºtzt das Analyseprogramm die folgenden Sprachen und Compiler: <br><br><ul><li>  Windows  Visual Studio 2010-2019 C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Windows  IAR Embedded Workbench, C / C ++ - Compiler f√ºr ARM C, C ++ </li><li>  Windows  QNX Momentics, QCC C, C ++ </li><li>  Windows / Linux  Keil ¬µVision, DS-MDK, ARM Compiler 5/6 C, C ++ </li><li>  Windows / Linux  Texas Instruments Code Composer Studio, Tools zur ARM-Codegenerierung C, C ++ </li><li>  Windows / Linux / MacOS.  GNU Arm Embedded Toolchain, GCC-Compiler f√ºr Arm Embedded, C, C ++ </li><li>  Windows / Linux / MacOS.  Clang C, C ++ </li><li>  Linux / macOS.  GCC C, C ++ </li><li>  Windows  MinGW C, C ++ </li><li>  Windows / Linux / MacOS.  Java </li></ul><br>  Der Analysator verf√ºgt √ºber eine detaillierte <a href="https://www.viva64.com/ru/m/">Dokumentation</a> in Englisch und Russisch.  Beschreibungen der Diagnoseregeln enthalten Beispiele f√ºr korrekten und falschen Code sowie Links zu Beispielen f√ºr echte Fehler in Open Source-Projekten. <br><br>  Zur Vereinfachung f√ºr Spezialisten, die PVS-Studio als <a href="https://www.viva64.com/ru/sast/">SAST-Tool verwenden</a> , zeigt der Analysator seine Warnungen zu Common Weakness Enumeration, SEI CERT Coding Standards und dem MISRA-Standard an.  Konformit√§tstabellen der PVS-Studio-Diagnose nach verschiedenen Standards: <br><br><ul><li> <a href="https://www.viva64.com/ru/cwe/">CWE-Konformit√§t</a> </li><li>  <a href="https://www.viva64.com/ru/cwe/">Einhaltung von SEI CERT</a> </li><li>  <a href="https://www.viva64.com/ru/cwe/">MISRA-Konformit√§t</a> </li></ul><br>  Der Analysator kann unabh√§ngig voneinander verwendet und in Visual Studio und IntelliJ IDEA integriert werden.  Dar√ºber hinaus haben k√ºrzlich einige unserer Kunden PVS-Studio als Teil von SonarQube verwendet.  PVS-Studio, das als <a href="https://www.viva64.com/ru/m/0037/">Plug-in</a> mit SonarQube verbunden ist, ist eine zus√§tzliche Quelle f√ºr Diagnosemeldungen. <br><br>  Verschiedene Integrationsszenarien in CI wurden ausgearbeitet.  Die Ber√ºcksichtigung aller Szenarien w√ºrde den Rahmen dieses Artikels sprengen, und es ist besser, die Dokumentation zu Rate zu ziehen.  Hier nur ein paar Links, damit sich der Leser einen allgemeinen Eindruck machen kann: <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0670/">PVS-Studio geht in die Cloud: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/ru/b/0636/">PVS-Studio geht in die Cloud: Travis CI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0676/">PVS-Studio geht in die Cloud: CircleCI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0686/">PVS-Studio geht in die Cloud: GitLab CI / CD</a> </li><li>  <a href="https://www.viva64.com/ru/m/0048/">Starten Sie PVS-Studio in Jenkins</a> </li><li>  <a href="https://www.viva64.com/ru/b/0567/">Funktionen zum Einrichten und Ausf√ºhren von PVS-Studio in Docker anhand des Azure Service Fabric-Codebeispiels</a> </li></ul><br>  Der PVS-Studio-Analysator erkennt eine Vielzahl von Fehlern, von <a href="https://www.viva64.com/ru/b/0260/">Tippfehlern</a> bis hin zu <a href="https://www.viva64.com/ru/b/0543/">Speicherlecks</a> .  Dies ist dank Datenflussanalyse, symbolischer Ausf√ºhrung, Musterabgleich und Methodenanmerkung (einschlie√ülich automatisch) m√∂glich.  Weitere Informationen zu Funktionsprinzipien finden Sie im Artikel " <a href="https://www.viva64.com/ru/b/0592/">Im PVS-Studio Code Analyzer verwendete Technologien zum Auffinden von Fehlern und potenziellen Schwachstellen</a> ". <br><br><h2>  Warum sollten Sie PVS-Studio verwenden? </h2><br>  Durch die Einf√ºhrung des statischen Code-Analysators PVS-Studio in den Entwicklungsprozess reduzieren Sie die Kosten f√ºr die Behebung vieler Fehler.  Dies spart Zeit f√ºr die Implementierung neuer Funktionen oder f√ºr gr√ºndlichere Tests auf hoher Ebene. <br><br>  Bei regelm√§√üiger Verwendung des Analyseger√§ts wird der Code allm√§hlich besser, was die Wartung erleichtert.  Eine systematische Fehlerkorrektur und das Schreiben von qualitativ hochwertigem Code verringern die Wahrscheinlichkeit, Zero-Day-Schwachstellen im Projekt zu erkennen.  Dieses Thema wird im Artikel " <a href="https://www.viva64.com/ru/b/0514/">Wie kann PVS-Studio bei der Suche nach Sicherheitsl√ºcken helfen?</a> " <a href="https://www.viva64.com/ru/b/0514/">N√§her</a> erl√§utert. <br><br>  Die Verwendung des PVS-Studio-Tools ist f√ºr Teams mit f√ºnf oder mehr Personen von Vorteil.  Die Methode zur Berechnung der Nutzungseffizienz des Analysators finden Sie im Artikel " <a href="https://www.viva64.com/ru/b/0606/">PVS-Studio ROI</a> ". <br><br>  Bei Projekten, die von einem oder zwei Enthusiasten entwickelt wurden, ist der PVS-Studio-Analysator h√∂chstwahrscheinlich √ºberfl√ºssig.  Es kann jedoch auch in solchen kleinen Projekten verwendet werden, zumal wir verschiedene <a href="https://www.viva64.com/ru/b/0614/">kostenlose</a> Lizenzierungsoptionen f√ºr Studenten, Open Source-Projekte usw. anbieten. <br><br>  Am h√§ufigsten erwerben <a href="https://www.viva64.com/ru/customers/">unsere Kunden zu</a> Beginn eine Lizenz f√ºr ein Jahr.  Nach einem Jahr, wenn sie √ºberzeugt sind, dass die F√§higkeiten des Analyseger√§ts und ihre Unterst√ºtzung voll und ganz zufrieden sind, verl√§ngern sie die Lizenz um zwei oder drei Jahre auf einmal.  Dies erm√∂glicht es ihnen, einen erheblichen Rabatt zu erhalten.  Hier k√∂nnen Sie Preise anfordern und sich zu Lizenzfragen beraten lassen. <br><br>  Werden Sie unser Kunde.  Mit PVS-Studio k√∂nnen Sie den Entwicklungsprozess beschleunigen, im Kampf gegen Fehler Geld sparen und bessere Software erstellen. <br><br>  Wir werden Sie schnell und kompetent unterst√ºtzen.  Die Fragen werden direkt von den Programmierern beantwortet, die die Module entwickeln, auf denen die Frage entstand.  Dies hilft, auch in schwierigen Situationen Antworten zu erhalten.  Ein Beispiel f√ºr eine solche Kommunikation ist " <a href="https://www.viva64.com/ru/b/0612/">False Positives in PVS-Studio: Wie tief ist das Kaninchenloch?</a> ". <br><br><h2>  Einspruch beantwortet </h2><br>  Manchmal nehmen Programmierer die Idee der Einf√ºhrung der statischen Code-Analyse in den Entwicklungsprozess negativ wahr und kritisieren die Methodik der statischen Analyse als Ganzes oder speziell das PVS-Studio-Tool.  Wenn die Diskussion beginnt, stellt sich heraus, dass die Kritik nicht begr√ºndet ist und einfach auf die mangelnde Bereitschaft zur√ºckzuf√ºhren ist, im etablierten Entwicklungsprozess etwas zu √§ndern.  Betrachten Sie die typischen Argumente, um nichts zu √§ndern, und deren Schw√§che. <br><br><h3>  "Statische Analyse wird Teil der Arbeitszeit sein" </h3><br>  Die Aussage "Die statische Analyse nimmt einen Teil der Arbeitszeit in Anspruch" ist unabh√§ngig vom Kontext richtig.  Das regelm√§√üige √úberpr√ºfen der Warnungen des statischen Analysators, die f√ºr neuen oder ge√§nderten Code ausgegeben wurden, nimmt viel Zeit in Anspruch.  Der Gedanke sollte jedoch fortgesetzt werden: Die daf√ºr aufgewendete Zeit ist viel geringer als die Kosten f√ºr die Identifizierung von Fehlern mit anderen Methoden. <br><br>  Woher kommt die Meinung √ºber die Notwendigkeit, Zeit damit zu verbringen, statische Code-Analysatoren zu warnen? <br><br>  Programmierer, die mit der Code-Analyse-Methodik noch nicht vertraut sind, verwechseln Testl√§ufe und die regelm√§√üige Verwendung.  Bei den ersten Starts geben alle Analyseger√§te eine gro√üe Liste von Warnungen aus, von denen viele falsch sind.  Der Grund ist, dass der Analysator noch nicht konfiguriert ist.  Ein abgestimmtes Analyseger√§t erzeugt beim regul√§ren Start eine kleine Anzahl von Fehlalarmen.  Mit anderen Worten, bei regelm√§√üiger Verwendung erkennen die meisten Warnungen echte M√§ngel oder einen Geruchscode.  Es ist nur wichtig, diese Einstellung vorzunehmen. <br><br>  Dieses Thema wird im Artikel ‚Äû <a href="https://www.viva64.com/ru/b/0669/">Arbeiten mit Einw√§nden: Die statische Analyse nimmt einen Teil der Arbeitszeit in Anspruch</a> ‚Äú ausf√ºhrlicher beschrieben. <br><br><h3>  "Der statische Analysator ist sehr laut (es werden viele falsche Positive erzeugt)" </h3><br>  Wie oben erw√§hnt, wird diese Schlussfolgerung unter Verwendung eines nicht konfigurierten Codeanalysators gezogen.  Nach dem Einrichten von PVS-Studio k√∂nnen Sie damit rechnen, dass der Prozentsatz der Fehlalarme 10-20% betr√§gt.  Das hei√üt, mit f√ºnf ausgegebenen Warnungen weisen vier auf echte Fehler oder einen Code hin, der in Zukunft wahrscheinlich zu Fehlern f√ºhren wird.  Ein Beispiel f√ºr eine solche Einstellung finden Sie im Artikel " <a href="https://www.viva64.com/ru/b/0523/">Spezifikationen des PVS-Studio-Analysators anhand des Beispiels f√ºr EFL-Kernbibliotheken, 10-15% der falsch-positiven Ergebnisse</a> ". <br><br>  Ein weiterer Grund, der die Idee des Analysators verf√§lscht, ist der Wunsch, so viele Warnungen wie m√∂glich einzubeziehen, ohne deren Zweck zu verstehen.  Wenn Sie beispielsweise den MISRA-Regelsatz f√ºr eingebettete Systeme f√ºr eine klassische Windows-Anwendung aktivieren, generiert der Analyzer Hunderttausende von Warnungen.  Es wird keine praktische Bedeutung in ihnen geben.  Insbesondere unn√∂tige Diagnosen st√∂ren bereits beim Kennenlernen des Werkzeugs und bilden ein Missverst√§ndnis √ºber dessen Diagnosem√∂glichkeiten.  Der Artikel ‚Äû <a href="https://www.viva64.com/ru/b/0633/">Wie kann man schnell interessante Warnungen sehen, die der PVS-Studio Analyzer f√ºr C- und C ++ - Code</a> ausgibt <a href="https://www.viva64.com/ru/b/0633/">?</a> ‚Äú Hilft, dies zu vermeiden. <br><br><h3>  ‚ÄûDie Einf√ºhrung der statischen Analyse in den Entwicklungsprozess ist sehr schwierig, langwierig und teuer.‚Äú </h3><br>  Sehr gut, diese Bedenken spiegeln sich in diesem Kommentar wider: <br><br>  <i>Leider sind die statischen Analysatoren selbst nichts anderes als Spielzeug.</i>  <i>Ihre Einf√ºhrung in den Workflow ist eine verdammt schwierige Aufgabe. Sie m√ºssen Personen ausw√§hlen, um die Ergebnisse zu verarbeiten und zu filtern.</i>  <i>Versuche, diese Aufgaben auf die Schultern gew√∂hnlicher Entwickler zu verlagern, f√ºhren normalerweise zu nichts.</i> <br><br>  Es ist nicht so be√§ngstigend.  Es gibt mindestens drei Ans√§tze, mit denen Sie statische Analysen auch in gro√üen alten Projekten m√ºhsam implementieren k√∂nnen. <br><br>  <b>Erster Ansatz.</b>  "Ratchet Method", die Ivan Ponomarev in seinem Bericht " <a href="https://youtu.be/_Wv-PvZeRlI">Continuous Static Code Analysis</a> " gut <a href="https://youtu.be/_Wv-PvZeRlI">ausdr√ºckt</a> . <br><br>  <b>Zweiter Ansatz.</b>  Um schnell mit der statischen Analyse beginnen zu k√∂nnen, bieten wir PVS-Studio-Kunden die Verwendung der " <a href="https://www.viva64.com/ru/m/0032/">Markup-Basis</a> " an.  Die allgemeine Idee ist wie folgt.  Der Benutzer hat den Analysator gestartet und viele Warnungen erhalten.  Da ein seit vielen Jahren entwickeltes Projekt lebt, sich entwickelt und Geld einbringt, wird der Bericht h√∂chstwahrscheinlich nicht viele Warnungen enthalten, die auf kritische M√§ngel hinweisen.  Mit anderen Worten, kritische Fehler wurden bereits auf die eine oder andere teurere Weise oder dank des Feedbacks von Kunden behoben.  Dementsprechend kann alles, was der Analysator jetzt findet, als technische Verschuldung angesehen werden, deren sofortige Beseitigung nicht praktikabel ist. <br><br>  Sie k√∂nnen PVS-Studio anweisen, diese Warnungen als irrelevant zu betrachten (technische Schulden f√ºr sp√§ter zu verschieben) und sie nicht erneut anzuzeigen.  Der Analysator erstellt eine spezielle Datei, in der Informationen zu bisher uninteressanten Fehlern gespeichert werden.  Und jetzt gibt PVS-Studio Warnungen nur f√ºr neuen oder ge√§nderten Code aus.  Dar√ºber hinaus ist dies alles intelligent umgesetzt.  Wenn beispielsweise am Anfang einer bestimmten CPP-Datei eine leere Zeile eingef√ºgt wird, hat der Analysator verstanden, dass sich nichts ge√§ndert hat, und bleibt stumm.  Diese Markup-Datei kann in das Versionskontrollsystem eingebettet werden.  Die Datei ist gro√ü, aber nicht unheimlich, da es oft keinen Sinn macht, sie zu legen. <br><br>  Jetzt sehen alle Programmierer Warnungen, die sich nur auf neuen oder ge√§nderten Code beziehen.  Somit kann der Analysator beginnen, das zu verwenden, was am n√§chsten Tag aufgerufen wird.  Und es wird m√∂glich sein, sp√§ter zu den technischen Schulden zur√ºckzukehren, Fehler schrittweise zu korrigieren und den Analysator zu konfigurieren. <br><br>  <b>Der dritte Ansatz.</b>  Sie k√∂nnen mit uns einen Vertrag abschlie√üen und die Arbeit zum Aufbau und zur Integration der statischen Analyse an unser Team delegieren.  Ein Beispiel f√ºr diese Praxis: " <a href="https://www.viva64.com/ru/b/0330/">Wie das PVS-Studio-Team den Code der Unreal Engine verbessert hat</a> ." <br><br><h3>  ‚ÄûWir haben den Analysator gestartet und nichts Interessantes gefunden‚Äú </h3><br>  Dies ist durchaus m√∂glich, bedeutet jedoch nicht, dass der Analysator nicht n√ºtzlich ist.  Die Sache ist, dass die Fehler durch teurere Methoden behoben wurden.  So nehmen Sie den Text eines Buches, das bereits von mehreren Korrektoren gelesen wurde, und sehen, was die in Microsoft Word integrierte Rechtschreibpr√ºfung finden kann.  Es werden kleine Fehler gefunden, aber daraus folgt nicht, dass die Pr√ºffunktion in Word beim Schreiben neuer Texte nicht hilfreich ist. <br><br>  Dieses Thema wird im Artikel " <a href="https://www.viva64.com/ru/b/0534/">Philosophie der statischen Code-Analyse: Wir haben 100 Programmierer, der Analysator hat nur wenige Fehler gefunden, ist es nutzlos?</a> " Ausf√ºhrlicher besprochen. <br><br><h3>  "Ein statischer Analysator ist teuer. Es ist besser, einen anderen Programmierer / Tester zu beauftragen." </h3><br>  In der Tat bedeutet dies, dass Sie nichts √§ndern m√∂chten.  In der Tat, bevor das Team wuchs und mit neuen Programmierern und Testern aufgestockt wurde.  Dies f√ºhrte jedoch nicht zu einer signifikanten Erh√∂hung der Reife des Entwicklungsprozesses.  Lassen Sie uns diesen Einwand dennoch genauer untersuchen. <br><br>  Erstens ist die Suche nach Fehlern durch eine zus√§tzliche Person viel teurer als die Verwendung eines Code-Analysators.  Berechnen Sie die Gehaltskasse einer Person f√ºr das Jahr.  F√ºgen Sie Steuern und Organisation des Arbeitsplatzes hinzu.  Das Argument, dass eine Lizenz teuer ist, ist kein Argument mehr.  Und dennoch f√§hrt der statische Analysator im Gegensatz zu der Person nicht in den Urlaub, ist nicht krank und geht nicht.  Wenn es sich um gro√üe Teams handelt, zum Beispiel 100 Personen, m√ºssen Sie mehrere Personen einstellen, um eine gewisse Wirkung zu erzielen.  Der Abstand zu Gunsten des statischen Analysators vergr√∂√üert sich. <br><br>  Zweitens wird der gr√∂√üte Effekt aufgrund der Synergie der Verwendung verschiedener Fehlersuchtechniken erzielt.  Einige Fehler werden durch Komponententests, andere durch manuelle Tests usw. gut erkannt.  Stellen Sie sich die Situation vor.  Das Projekt hat 10 Programmierer, viele Unit-Tests sind geschrieben, aber es gibt keine Tester.  Die Qualit√§t des Projekts passt nicht zu den Nutzern und die Idee ist, einen Job als Tester zu er√∂ffnen.  Dies geschieht jedoch nicht unter dem Vorwand ‚Äûes ist besser, einen anderen Programmierer einzustellen‚Äú, sondern es wird noch mehr Unit-Tests geben!  Stimmen Sie zu, das ist die falsche Entscheidung.  Offensichtlich ist der Qualit√§tssicherungsprozess einseitig und die Hinzuf√ºgung manueller Tests wird viel gr√∂√üere Vorteile bringen.  Gleiches gilt f√ºr die statische Analyse. <br><br><h3>  "Dynamische Analyse ist effizienter als statische." </h3><br>  Statische Analysatoren finden einige Fehler gut.  Einige sind dynamische Analysatoren.  Diese Tools <a href="https://www.viva64.com/ru/b/0643/">erg√§nzen</a> sich und es macht keinen Sinn, eine Sache auszuw√§hlen. <br><br>  Beispielsweise k√∂nnen dynamische Analyseger√§te nicht viele Tippfehler finden oder nicht erreichbaren Code erkennen.  Im Artikel " <a href="https://www.viva64.com/ru/b/0504/">Validieren von Valgrind Dynamic Analyzer-Code mithilfe eines statischen Analysators</a> " k√∂nnen einige dieser Fehler auftreten. <br><br><h3>  "Unit-Tests sind effizienter als statische Code-Analyse" </h3><br>  Wenn Sie zwischen dem Schreiben von Einheitentests und statischen Analysen w√§hlen, sind die Tests m√∂glicherweise wichtiger und n√ºtzlicher.  Aber es muss keine Wahl getroffen werden.  Es ist erforderlich, sowohl Unit-Tests als auch statische Code-Analysen durchzuf√ºhren.  Diese Fehlersuchmethoden erg√§nzen sich perfekt. <br><br>  Die statische Analyse wird Unit-Tests aus folgenden Gr√ºnden erg√§nzen: <br><br><ol><li>  Niemand testet die Tests selbst und sie enthalten oft Fehler.  In unseren Artikeln haben wir wiederholt Beispiele f√ºr Fehler im Unit-Test-Code angef√ºhrt.  Dementsprechend kann eine statische Analyse Fehler in Tests finden, die wiederum Fehler im Hauptanwendungscode finden k√∂nnen. </li><li>  Tests sind sehr schwierig, den gesamten Code abzudecken.  Besonders wenn es um Code f√ºr den Umgang mit Notfallsituationen geht.  Statische Analysatoren √ºberpr√ºfen den gesamten Code. </li><li>  Einige Fehler sind bei Unit-Tests nicht oder nur sehr schwer zu erkennen.  Beispiel: <a href="https://www.viva64.com/ru/w/v597/">V597 (CWE-14)</a> . </li><li>  Einige Fehler treten nur bei der Verarbeitung gro√üer Datenmengen auf, und Komponententests sind f√ºr die Modellierung solcher Situationen unpraktisch.  Ein Beispiel ist der √úberlauf einer 32-Bit-Variablen in einem 64-Bit-Programm ( <a href="https://www.viva64.com/ru/w/v108/">V108</a> , <a href="https://www.viva64.com/ru/w/v127/">V127</a> ). </li><li>  Es ist einfacher und schneller, einen Fehler durch Ausf√ºhren einer statischen Analyse zu finden, als den Code zu debuggen, wenn sich herausstellt, dass der Komponententest nicht funktioniert.  Nat√ºrlich finden Unit-Tests mehr Fehler, aber wenn einige davon billiger gefunden werden k√∂nnen (statische Analyse), warum nicht? </li><li>  Wir finden eine <a href="https://www.viva64.com/ru/examples/">Vielzahl von Fehlern</a> in verschiedenen Projekten.  Viele dieser Projekte sind durch Tests gut abgedeckt, aber wie Sie sehen, hilft dies nicht.  Es gibt also keinen Grund, nicht zus√§tzlich zu Komponententests auch eine statische Code-Analyse durchzuf√ºhren, um die Qualit√§t und Sicherheit zu verbessern. </li></ol><br><h3>  ‚ÄûModerne kostenlose Compiler k√∂nnen dasselbe wie PVS-Studio‚Äú </h3><br>  Ja, in der Tat entwickeln sich Compiler weiter und es werden neue Warnungen implementiert, um Fehler im Code zu finden.  Sie sollten jedoch im Vergleich zu professionellen kostenpflichtigen L√∂sungen wie PVS-Studio nicht zu viel von Compilern erwarten. <br><br>  Vorteile von PVS-Studio: <br><br><ol><li>  Benutzerunterst√ºtzung. </li><li>  Umfangreiche Infrastruktur (Integration mit anderen Produkten). </li><li>  Entwickelte Diagnosefunktionen. </li></ol><br>  Die ersten beiden Punkte reichen bereits aus, um die Waage zugunsten von PVS-Studio zu √ºberwiegen.  Sprechen wir jedoch √ºber die Diagnose.  Wir entwickeln den Analysator st√§ndig weiter, um anderen Tools einen Schritt voraus zu sein.  Zum Beispiel k√∂nnen wir hier einen so interessanten Fehler " <a href="https://www.viva64.com/ru/b/0550/">31. Februar</a> " finden. <br><br>  Das reicht nicht aus, um skeptische Leser zu √ºberzeugen.  Daher √ºberpr√ºfen wir von Zeit zu Zeit andere Compiler und zeigen, dass PVS-Studio darin Fehler finden kann: <br><br><ul><li>  <a href="http://www.viva64.com/ru/b/0108/">LLVM-Validierung im Jahr 2011</a> </li><li>  <a href="http://www.viva64.com/ru/b/0155/">√úberpr√ºfung der LLVM im Jahr 2012</a> </li><li>  <a href="http://www.viva64.com/ru/b/0425/">GCC Check in 2016</a> </li><li>  <a href="http://www.viva64.com/ru/b/0446/">LLVM-Validierung im Jahr 2016</a> </li><li>  <a href="https://www.viva64.com/ru/b/0622/">√úberpr√ºfung von Roslyn (.NET Compiler Platform) im Jahr 2019</a> </li><li>  <a href="https://www.viva64.com/ru/b/0629/">√úberpr√ºfung der LLVM im Jahr 2019</a> </li></ul><br><h2>  PS </h2><br>  Wenn Sie immer noch nicht sicher sind, ob Sie PVS-Studio verwenden sollen, schauen Sie sich an, <a href="https://www.viva64.com/ru/examples/">welche Fehler und in welchen Projekten wir festgestellt haben</a> . <br><br><h2>  N√ºtzliche Links </h2><br><ol><li>  PVS-Studio: <a href="https://www.viva64.com/ru/pvs-studio/">Hauptseite</a> , <a href="https://www.viva64.com/ru/m/">Dokumentation</a> , <a href="https://www.viva64.com/ru/pvs-studio-download/">Download</a> , <a href="https://www.viva64.com/ru/order/">Kauf</a> . </li><li>  Begr√ºndung des Nutzens: <a href="https://www.viva64.com/ru/inspections/">Beispiele f√ºr Projekt√ºberpr√ºfung</a> , <a href="https://www.viva64.com/ru/customers/">Kunden</a> , <a href="https://www.viva64.com/ru/b/0606/">Kapitalrendite</a> . </li><li>  <a href="https://www.viva64.com/ru/b/0633/">Wie k√∂nnen interessante Warnungen, die vom PVS-Studio Analyzer f√ºr C- und C ++ - Code generiert wurden, schnell angezeigt werden?</a> </li><li>  <a href="https://www.viva64.com/ru/b/0625/">Kurz √ºber PVS-Studio als SAST-L√∂sung</a> </li><li>  <a href="https://www.viva64.com/ru/b/0659/">PVS-Studio - Motor des Fortschritts</a> </li><li>  <a href="https://www.viva64.com/ru/b/0675/">Hinweis f√ºr Lehrer: PVS-Studio f√ºr die Einf√ºhrung von Sch√ºlern in Codeanalyse-Tools</a> </li><li>  <a href="https://www.viva64.com/ru/b/0637/">Warum schreiben wir nicht √ºber den Vergleich von PVS-Studio mit anderen statischen Code-Analysatoren</a> </li><li>  <a href="https://www.viva64.com/ru/b/0514/">Wie kann PVS-Studio bei der Suche nach Sicherheitsl√ºcken helfen?</a> </li><li>  <a href="https://www.viva64.com/ru/l/full/">PVS-Studio und Entwicklung von 64-Bit-Anwendungen in C und C ++</a> </li><li>  <a href="https://www.viva64.com/ru/b/0592/">Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen</a> </li><li>  <a href="https://www.viva64.com/ru/b/0603/">PVS-Studio f√ºr Java</a> </li></ol><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477324/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel mit einem englischsprachigen Publikum teilen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov.  <a href="https://habr.com/en/company/pvs-studio/blog/477324/">Warum Sie sich f√ºr den PVS-Studio Static Analyzer entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477328/">https://habr.com/ru/post/de477328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477314/index.html">Senden von Ereignissen von ViewModel an Activity / Fragment in MVVM</a></li>
<li><a href="../de477318/index.html">PHP Digest Nr. 168 (5. - 25. November 2019)</a></li>
<li><a href="../de477320/index.html">Umwelt: Wie das Internet der Dinge zum Schutz der Umwelt beitr√§gt</a></li>
<li><a href="../de477324/index.html">Warum Sie sich f√ºr den PVS-Studio Static Analyzer entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren</a></li>
<li><a href="../de477326/index.html">Einfachheit Hickey</a></li>
<li><a href="../de477332/index.html">Hackney Pipeline: Hackathon zum Markieren von Daten von Ozon, Yandex.Tolki und Netologiya</a></li>
<li><a href="../de477336/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 1</a></li>
<li><a href="../de477338/index.html">OWASP Treffen Moskau (Russland) 12/19 CFP</a></li>
<li><a href="../de477342/index.html">Rust f√ºr Webentwickler - schneller Start und schneller Flug</a></li>
<li><a href="../de477344/index.html">JIRA: Regeln f√ºr die zeitnahe Erstellung leckerer Software. TLDR 1: Grenzen der M√∂glichkeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>