<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📐 💃 🎢 Masa depan injeksi ketergantungan di Android 🚀 🎿 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya membawa perhatian Anda pada terjemahan dari artikel asli oleh Jamie Sanson 

 Membuat Aktivitas sebelum Android 9 Pie 


 Dependency injection (D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masa depan injeksi ketergantungan di Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444530/"><p>  <sup><em>Saya membawa perhatian Anda pada terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel asli</a> oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jamie Sanson</a></em></sup> <br><img src="https://habrastorage.org/getpro/habr/post_images/392/ae0/ac2/392ae0ac22d5b2d9b82a01e41d975278.jpg" alt="gambar"></p><br><h3 id="sozdanie-activity-do-android-9-pie">  Membuat Aktivitas sebelum Android 9 Pie </h3><br><p> <em>Dependency injection (DI)</em> adalah model umum yang digunakan dalam semua bentuk pengembangan karena sejumlah alasan.  Berkat proyek Dagger, ini diambil sebagai templat yang digunakan dalam pengembangan untuk Android.  Perubahan terbaru dalam Android 9 Pie telah membuat kami sekarang memiliki lebih banyak opsi ketika datang ke DI, terutama dengan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>AppComponentFactory</code></a> baru. </p><br><hr><br><p>  DI sangat penting dalam pengembangan Android modern.  Ini memungkinkan Anda untuk mengurangi jumlah total kode ketika mendapatkan tautan ke layanan yang digunakan antar kelas, dan umumnya membagi aplikasi menjadi komponen.  Pada artikel ini, kita akan fokus pada Dagger 2, perpustakaan DI paling umum yang digunakan dalam pengembangan Android.  Diasumsikan bahwa Anda sudah memiliki pengetahuan dasar tentang cara kerjanya, tetapi tidak perlu memahami semua seluk-beluknya.  Perlu dicatat bahwa artikel ini sedikit petualangan.  Ini menarik dan semuanya, tetapi pada saat penulisan, Android 9 Pie bahkan tidak muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panel versi platform</a> , jadi topik ini mungkin tidak akan relevan dengan pengembangan sehari-hari setidaknya selama beberapa tahun. </p><a name="habracut"></a><br><h3 id="vnedrenie-zavisimostey-v-android-segodnya">  Ketergantungan injeksi di Android hari ini </h3><br><p>  Sederhananya, kami menggunakan DI untuk memberikan contoh kelas "ketergantungan" untuk kelas dependen kami, yaitu mereka yang melakukan pekerjaan.  Katakanlah kita menggunakan <a href="">pola Repositori</a> untuk memproses logika terkait data kami, dan ingin menggunakan repositori kami di Aktivitas untuk menampilkan beberapa data kepada pengguna.  Kami mungkin ingin menggunakan repositori yang sama di beberapa tempat, jadi kami menggunakan injeksi dependensi untuk membuatnya lebih mudah untuk berbagi contoh yang sama antara sekelompok kelas yang berbeda. </p><br><p>  Pertama, kami akan menyediakan repositori.  Kami akan mendefinisikan fungsi <code>Provides</code> dalam modul, memungkinkan Dagger tahu bahwa ini adalah contoh yang ingin kami terapkan.  Harap dicatat bahwa repositori kami memerlukan instance konteks untuk bekerja dengan file dan jaringan.  Kami akan menyediakannya dengan konteks aplikasi. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appContext: Context) { <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Context = appContext <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context) }</code> </pre> <br><p>  Sekarang kita perlu mendefinisikan <code>Component</code> untuk menangani implementasi kelas-kelas di mana kita ingin menggunakan <code>Repository</code> kita. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component(modules = [AppModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Akhirnya, kita dapat mengonfigurasi <code>Activity</code> kami untuk menggunakan repositori kami.  Misalkan kita membuat instance <code>ApplicationComponent</code> kita di tempat lain. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository: Repository <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//    application.applicationComponent.inject(this) //       } }</span></span></code> </pre> <br><p>  Itu saja!  Kami baru saja menyiapkan injeksi ketergantungan dalam aplikasi menggunakan Dagger.  Ada beberapa cara untuk melakukan ini, tetapi ini sepertinya pendekatan yang paling mudah. </p><br><h3 id="chto-ne-tak-s-tekuschim-podhodom">  Apa yang salah dengan pendekatan saat ini? </h3><br><p>  Dalam contoh di atas, kami melihat dua jenis suntikan, satu lebih jelas daripada yang lain. </p><br><p>  Yang pertama yang Anda lewatkan dikenal sebagai <strong>menanamkan dalam konstruktor</strong> .  Ini adalah metode menyediakan dependensi melalui konstruktor suatu kelas, yang berarti bahwa kelas yang menggunakan dependensi tidak memiliki gagasan tentang asal-usul instance.  Ini dianggap sebagai bentuk injeksi ketergantungan yang paling murni, karena ini merangkum logika injeksi kami ke dalam kelas <code>Module</code> kami dengan sempurna.  Dalam contoh kami, kami menggunakan pendekatan ini untuk menyediakan repositori: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context)</code> </pre> <br><p>  Untuk ini kami membutuhkan <code>Context</code> , yang kami sediakan di fungsi <code>provideApplicationContext()</code> . </p><br><p>  Hal kedua, yang lebih jelas, yang kami lihat adalah <strong>implementasi kelas di lapangan</strong> .  Metode ini digunakan di <code>MainActivity</code> kami untuk menyediakan toko kami.  Di sini kita mendefinisikan bidang sebagai penerima injeksi menggunakan anotasi <code>Inject</code> .  Kemudian, dalam fungsi <code>onCreate</code> kami <code>onCreate</code> kami memberi tahu <code>ApplicationComponent</code> bahwa dependensi harus disuntikkan ke bidang kami.  Itu tidak terlihat sebersih menanamkan dalam konstruktor, karena kami memiliki referensi eksplisit untuk komponen kami, yang berarti bahwa konsep embedding merembes ke dalam kelas dependen kami.  Kelemahan lain dalam kelas Kerangka Android, karena kita perlu memastikan bahwa hal pertama yang kita lakukan adalah menyediakan dependensi.  Jika ini terjadi pada titik yang salah dalam siklus hidup, kita mungkin secara tidak sengaja mencoba menggunakan objek yang belum diinisialisasi. </p><br><p>  Idealnya, Anda harus benar-benar menyingkirkan implementasi di bidang kelas.  Pendekatan ini melewatkan informasi implementasi untuk kelas yang tidak perlu mengetahuinya, dan berpotensi menyebabkan masalah siklus hidup.  Kami melihat upaya untuk melakukannya dengan lebih baik, dan <em>Belati</em> di Android adalah cara yang cukup andal, tetapi pada akhirnya akan lebih baik jika kita bisa menggunakan penyematan pada konstruktor.  Saat ini, kami tidak dapat menggunakan pendekatan ini untuk sejumlah kelas kerangka kerja, seperti "Aktivitas", "Layanan", "Aplikasi", dll., Karena dibuat untuk kita oleh sistem.  Tampaknya saat ini kami terjebak dalam memperkenalkan kelas ke bidang.  Namun demikian, Android 9 Pie sedang mempersiapkan sesuatu yang menarik, yang, mungkin, secara fundamental akan mengubah segalanya. </p><br><h3 id="vnedrenie-zavisimostey-v-android-9-pie">  Ketergantungan injeksi di Android 9 Pie </h3><br><p>  Seperti yang disebutkan di awal artikel, Android 9 Pie memiliki kelas AppComponentFactory.  Dokumentasi untuk itu agak langka, dan hanya diposting di situs web pengembang seperti: </p><br><blockquote>  <em>Antarmuka yang digunakan untuk mengontrol penciptaan elemen manifes.</em> </blockquote><p>  Ini menarik.  “Elemen manifes” di sini merujuk pada kelas yang kami daftarkan dalam file <code>AndroidManifest</code> kami - seperti Activity, Layanan, dan kelas Aplikasi kami.  Ini memungkinkan kita untuk "mengontrol penciptaan" elemen-elemen ini ... jadi, hei, dapatkah kita sekarang menetapkan aturan untuk membuat Kegiatan kita?  Sungguh menyenangkan! </p><br><p>  Mari menggali lebih dalam.  Kami akan mulai dengan memperluas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>AppComponentFactory</code></a> dan mengganti metode <code>instantiateActivity</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository = NonContextRepository() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { className == MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span></span>(repository) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } } }</code> </pre> <br><p>  Sekarang kita perlu mendeklarasikan pabrik komponen kita di manifes di dalam tag <strong>aplikasi</strong> . </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".InjectionApp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:appComponentFactory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mypackage.injectiontest.component.InjectionComponentFactory"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:replace</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:appComponentFactory"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Akhirnya, kita dapat meluncurkan aplikasi kita ... dan berfungsi!  <code>NonContextRepository</code> kami disediakan melalui konstruktor MainActivity.  Dengan anggun! </p><br><p>  Harap dicatat bahwa ada beberapa pemesanan.  Kami tidak dapat menggunakan <code>Context</code> sini, karena bahkan sebelum keberadaannya, panggilan ke fungsi kami terjadi - ini membingungkan!  Kita dapat melangkah lebih jauh sehingga konstruktor mengimplementasikan kelas Aplikasi kita, tetapi mari kita lihat bagaimana Belati dapat membuat ini lebih mudah. </p><br><h3 id="vstrechayte--dagger-multi-binds">  Bertemu - Belati Multi-Bind </h3><br><p>  Saya tidak akan membahas detail operasi penjilidan belati Dagger di bawah kap, karena ini berada di luar cakupan artikel ini.  Yang perlu Anda ketahui adalah bahwa ia menyediakan cara yang baik untuk menyuntikkan ke konstruktor kelas tanpa harus memanggil konstruktor secara manual.  Kita bisa menggunakan ini untuk dengan mudah mengimplementasikan kelas kerangka kerja dengan cara yang dapat diskalakan.  Mari kita lihat bagaimana semuanya bertambah. </p><br><p>  Mari kita atur Aktivitas kita terlebih dahulu untuk mencari tahu ke mana harus pergi berikutnya. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: NonContextRepository ): Activity() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//       } }</span></span></code> </pre> <br><p>  Ini segera menunjukkan bahwa hampir <em>tidak ada</em> penyebutan ketergantungan.  Satu-satunya hal yang kita lihat adalah anotasi <code>Inject</code> sebelum konstruktor. </p><br><p>  Sekarang Anda perlu mengubah komponen dan modul Belati: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component(modules = [ApplicationModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">InjectionComponentFactory</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module(includes = [ComponentModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: NonContextRepository = NonContextRepository() }</code> </pre> <br><p>  Tidak banyak yang berubah.  Sekarang kita hanya perlu menerapkan pabrik komponen kita, tetapi bagaimana kita membuat elemen manifes kita?  Di sini kita membutuhkan <code>ComponentModule</code> .  Mari kita lihat: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentKey(MainActivity::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindMainActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindComponentHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(componentHelper: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ComponentHelper</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ComponentInstanceHelper } <span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span></span> <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentKey</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clazz: KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;)</code> </pre> <br><p>  Ya, hanya beberapa penjelasan.  Di sini kita menghubungkan <code>Activity</code> kita dengan peta, mengimplementasikan peta ini di kelas <code>ComponentHelper</code> kita dan menyediakan <code>ComponentHelper</code> ini - semuanya dalam dua instruksi <code>Binds</code> .  Belati tahu cara membuat Instansiasi <code>MainActivity</code> kami berkat anotasi <code>MainActivity</code> <code>Inject</code> sehingga dapat "mengikat" penyedia ke kelas ini, secara otomatis menyediakan dependensi yang kami butuhkan untuk konstruktor.  <code>ComponentHelper</code> kami <code>ComponentHelper</code> sebagai berikut. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> creators: Map&lt;Class&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;, <span class="hljs-meta"><span class="hljs-meta">@JvmSuppressWildcards</span></span> Provider&lt;Any&gt;&gt; ): ComponentInstanceHelper { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? = creators .filter { it.key.name == className } .values .firstOrNull() ?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceComponentHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? }</code> </pre> <br><p>  Sederhananya, kami sekarang memiliki peta kelas untuk pemasok untuk kelas-kelas ini.  Ketika kami mencoba menyelesaikan suatu kelas dengan nama, kami cukup menemukan penyedia untuk kelas ini (jika kami memilikinya), memanggilnya untuk mendapatkan instance baru dari kelas ini, dan mengembalikannya. </p><br><p>  Akhirnya, kita perlu membuat perubahan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>AppComponentFactory</code></a> untuk menggunakan kelas pembantu baru kita. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> componentHelper: ComponentInstanceHelper <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { DaggerApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentHelper .resolve&lt;Activity&gt;(className) ?.apply { setIntent(intent) } ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } }</code> </pre> <br><p>  Jalankan kode lagi.  Semuanya bekerja!  Menyenangkan sekali. </p><br><h3 id="problemy-vnedreniya-v-konstruktor">  Masalah Implementasi Konstruktor </h3><br><p>  Judul seperti itu mungkin tidak terlihat sangat mengesankan.  Meskipun kami dapat menanamkan sebagian besar contoh dalam mode normal dengan menyuntikkannya ke konstruktor, kami tidak memiliki cara yang jelas untuk menyediakan konteks untuk dependensi kami dengan cara standar.  Tapi <code>Context</code> di Android adalah segalanya.  Diperlukan untuk akses ke pengaturan, jaringan, konfigurasi aplikasi dan banyak lagi.  Ketergantungan kami sering kali adalah hal-hal yang menggunakan layanan terkait data, seperti jaringan dan pengaturan.  Kita dapat menyiasatinya dengan menulis ulang dependensi kita menjadi fungsi murni, atau dengan menginisialisasi segala sesuatu dengan instance konteks dalam kelas <code>Application</code> kita, tetapi dibutuhkan lebih banyak pekerjaan untuk menentukan cara terbaik untuk melakukan ini. </p><br><p>  Kerugian lain dari pendekatan ini adalah definisi ruang lingkup.  Dalam Dagger, salah satu konsep kunci untuk mengimplementasikan injeksi dependensi berkinerja tinggi dengan pemisahan hubungan kelas yang baik adalah modularitas objek grafik dan penggunaan ruang lingkup.  Meskipun pendekatan ini tidak melarang penggunaan modul, itu membatasi penggunaan ruang lingkup.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>AppComponentFactory</code></a> ada pada tingkat abstraksi yang sama sekali berbeda relatif terhadap kelas kerangka kerja standar kami - kami tidak dapat memperoleh tautan ke sana secara terprogram, jadi kami tidak memiliki cara untuk menginstruksinya untuk menyediakan dependensi untuk <code>Activity</code> dalam lingkup yang berbeda. </p><br><p>  Ada banyak cara untuk menyelesaikan masalah kami dengan lingkup dalam praktik, salah satunya adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>FragmentFactory</code></a> untuk menanamkan fragmen kami dalam konstruktor dengan cakupan.  Saya tidak akan merinci, tetapi ternyata sekarang kita memiliki metode untuk mengontrol pembuatan fragmen, yang tidak hanya memberi kita kebebasan yang jauh lebih besar dalam hal ruang lingkup, tetapi juga memiliki kompatibilitas ke belakang. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Android 9 Pie memperkenalkan cara untuk menggunakan penyematan dalam konstruktor untuk menyediakan dependensi di kelas kerangka kerja kami, seperti "Aktivitas" dan "Aplikasi".  Kami melihat bahwa dengan <em>Dagger Multi-binding,</em> kami dapat dengan mudah memberikan dependensi pada level aplikasi. </p><br><p>  Konstruktor yang mengimplementasikan semua komponen kami sangat menarik, dan kami bahkan dapat melakukan sesuatu untuk membuatnya berfungsi dengan baik dengan instance konteks.  Ini adalah masa depan yang menjanjikan, tetapi hanya tersedia mulai dengan API 28. Jika Anda ingin menjangkau kurang dari 0,5% pengguna, Anda dapat mencobanya.  Jika tidak, Anda harus menunggu dan melihat apakah metode seperti itu tetap relevan dalam beberapa tahun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444530/">https://habr.com/ru/post/id444530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444520/index.html">2. Periksa Titik Memulai R80.20. Arsitektur Solusi</a></li>
<li><a href="../id444522/index.html">Kiamat dibatalkan</a></li>
<li><a href="../id444524/index.html">Lambdas: dari C ++ 11 ke C ++ 20. Bagian 1</a></li>
<li><a href="../id444526/index.html">Stack DOTS: C ++ & C #</a></li>
<li><a href="../id444528/index.html">Situasi: Jepang dapat membatasi pengunduhan konten dari jaringan - kami memahami dan mendiskusikan</a></li>
<li><a href="../id444534/index.html">Pemindaian kerentanan dan pengembangan yang aman. Bagian 1</a></li>
<li><a href="../id444536/index.html">MVCC-2. Lapisan, File, Halaman</a></li>
<li><a href="../id444540/index.html">Intel siap memulai produksi memori MRAM</a></li>
<li><a href="../id444542/index.html">Siaran Langsung dan Jadwal Konferensi untuk SmartMail Conf: Pembelajaran Mesin</a></li>
<li><a href="../id444544/index.html">Sesuatu tentang pusat data terdistribusi untuk bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>