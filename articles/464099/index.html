<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏼 👊🏽 🙍🏾 Análisis del lenguaje VKScript: JavaScript, ¿y tú? 🏴 🧕🏽 ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 



 VKScript no es JavaScript. La semántica de este lenguaje es fundamentalmente diferente de la semántica de JavaScript. Ver la conclusión . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Análisis del lenguaje VKScript: JavaScript, ¿y tú?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464099/"><h1>  TL; DR </h1><br><hr><br><p>  VKScript <b>no</b> es JavaScript.  La semántica de este lenguaje es fundamentalmente diferente de la semántica de JavaScript.  Ver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conclusión</a> . </p><br><a name="habracut"></a><h1>  ¿Qué es VKScript? </h1><br><hr><br><p> <b>VKScript</b> es un lenguaje de programación de secuencias de comandos similar a JavaScript que se utiliza en el método de <code>execute</code> API VKontakte, que permite a los clientes descargar exactamente la información que necesitan.  En esencia, VKScript es un análogo de GraphQL utilizado por Facebook con el mismo propósito. </p><br><p>  Compare GraphQL y VKScript: </p><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  GraphQL </th><th>  VKScript </th></tr><tr><td>  Implementaciones </td><td>  Muchas implementaciones de código abierto en diferentes lenguajes de programación. </td><td>  La única implementación dentro de la API de VK </td></tr><tr><td>  Basado en </td><td>  Nuevo lenguaje </td><td>  Javascript </td></tr><tr><td>  Las posibilidades </td><td>  Solicitud de datos, filtrado limitado;  los argumentos de consulta no pueden usar los resultados de consultas anteriores </td><td>  Cualquier procesamiento posterior de datos a discreción del cliente;  Las solicitudes de API se presentan en forma de métodos y pueden usar cualquier dato de solicitudes anteriores </td></tr></tbody></table></div><br><p>  Descripción de VKScript desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">página</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">método en la documentación de la API de VK</a> (la única documentación oficial del idioma): </p><br><blockquote><div class="scrollable-table"><table><tbody><tr><th>  codigo </th><td>  código de algoritmo en <b>VKScript</b> : un formato similar a <b>JavaScript</b> o <b>ActionScript</b> <i>( <b>se</b> supone compatibilidad con <b>ECMAScript</b> )</i> .  El algoritmo debe terminar con el comando <b>return% expression%</b> .  Los operadores deben estar separados por punto y coma. <br>  cuerda </td></tr></tbody></table></div><br><p>  Los siguientes son compatibles: </p><br><ul><li>  operaciones aritméticas </li><li>  operaciones lógicas </li><li>  creación de matrices y listas ([X, Y]) </li><li>  <b>parseInt</b> y <b>parseDouble</b> </li><li>  concatenación (+) </li><li>  <b>si</b> construye </li><li>  filtro de matriz por parámetro (@.) </li><li>  Llamadas al método <b>API</b> , parámetro de <b>longitud</b> </li><li>  bucles utilizando la instrucción <b>while</b> </li><li>  Métodos Javascript: <b>corte</b> , <b>inserción</b> , <b>pop</b> , <b>shift</b> , <b>unshift</b> , <b>empalme</b> , <b>substr</b> , <b>división</b> </li><li>  <b>eliminar</b> operador </li><li>  asignación a elementos de matriz, por ejemplo: row.user.action = "prueba"; </li><li>  la búsqueda en la matriz o cadena es <b>indexOf</b> , por ejemplo: "123" .indexOf (2) = 1, [1, 2, 3] .indexOf (3) = 2. Devuelve -1 si no se encuentra el elemento. </li></ul><br><p>  La creación de funciones no es compatible actualmente. </p><br></blockquote><br><p>  La documentación citada establece que "la compatibilidad con ECMAScript está planificada".  ¿Pero es así?  Tratemos de descubrir cómo funciona este lenguaje desde adentro. </p><br><br><h1>  Contenido </h1><br><hr><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Máquina virtual VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Semántica de objetos VKScript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión</a> </li></ol><br><a name="vm"></a><h1>  Máquina virtual VKScript </h1><br><hr><br><p>  ¿Cómo se puede analizar un programa en ausencia de una copia local?  Así es: envíe solicitudes al punto final público y analice las respuestas.  Intentemos, por ejemplo, ejecutar el siguiente código: </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Recibimos un <code>Runtime error occurred during code invocation: Too many operations</code> .  Esto sugiere que en la implementación del lenguaje hay un límite en el número de acciones realizadas.  Intentemos establecer el valor límite exacto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>Runtime error occurred during code invocation: Too many operations</code> . </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><ul><li>  <code>{"response": null}</code> : el código se ejecutó correctamente. </li></ul><br><p>  Por lo tanto, el límite en el número de operaciones es de aproximadamente 1000 ciclos "inactivos".  Pero, al mismo tiempo, está claro que ese ciclo probablemente no sea una operación "unitaria".  Intentemos encontrar una operación que no esté dividida por el compilador en varias más pequeñas. </p><br><p>  El candidato más obvio para el papel de tal operación es la llamada declaración vacía ( <code>;</code> ).  Sin embargo, después de agregar al código con <code>i &lt; 999</code> 50 caracteres <code>;</code>  , el límite no se supera.  Esto significa que el compilador arroja la declaración vacía y no desperdicia operaciones, o una iteración del bucle requiere más de 50 operaciones (lo cual, muy probablemente, no es así). </p><br><p>  Lo siguiente que viene a la mente después <code>;</code>  - cálculo de alguna expresión simple (por ejemplo, así: <code>1;</code> ).  Intentemos agregar algunas de estas expresiones a nuestro código: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1; //       "Too many operations"</span></span></code> </pre> <br><p>  Por lo tanto, 2 operaciones <code>1;</code>  gastar más operaciones que 50 operaciones <code>;</code>  .  Esto confirma la hipótesis de que la declaración vacía no desperdicia instrucciones. </p><br><p>  Intentemos reducir el número de iteraciones del ciclo y agreguemos <code>1;</code> adicional <code>1;</code>  .  Es fácil notar que para cada iteración hay 5 <code>1;</code> adicionales <code>1;</code>  por lo tanto, una iteración del ciclo gasta 5 veces más operaciones que una operación <code>1;</code>  . </p><br><p>  ¿Pero hay una operación aún más simple?  Por ejemplo, agregar el operador unario <code>~</code> no requiere el cálculo de expresiones adicionales, y la operación misma se realiza en el procesador.  Es lógico suponer que agregar esta operación a la expresión aumenta el número total de operaciones en 1. </p><br><p>  Agregue este operador a nuestro código: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Y sí, podemos agregar uno de esos operadores y una expresión más <code>1;</code>  Ya no.  Por lo tanto, <code>1;</code>  Realmente no es un operador unitario. </p><br><p>  Similar al operador <code>1;</code>  , reduciremos el número de iteraciones del bucle y agregaremos los operadores <code>~</code> .  Una iteración resultó ser equivalente a 10 operaciones unitarias <code>~</code> , por lo tanto, expresión <code>1;</code>  Gasta 2 operaciones. </p><br><p>  Tenga en cuenta que el límite es de aproximadamente 1000 iteraciones, es decir, aproximadamente 10,000 operaciones individuales.  Suponemos que el límite es exactamente 10.000 operaciones. </p><br><br><h2>  Medir el número de operaciones en código </h2><br><hr><br><p>  Tenga en cuenta que ahora podemos medir el número de operaciones en cualquier código.  Para hacer esto, agregue este código después del ciclo y agregue / elimine iteraciones, operadores <code>~</code> o toda la última línea, hasta que desaparezca el error <code>Too many operations</code> . </p><br><p>  Algunos resultados de medición: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Código </th><th>  Número de operaciones </th></tr><tr><td> <code>1;</code> </td> <td>  2 </td></tr><tr><td> <code>~1;</code> </td> <td>  3 </td></tr><tr><td> <code>1+1;</code> </td> <td>  4 4 </td></tr><tr><td> <code>1+1+1;</code> </td> <td>  6 6 </td></tr><tr><td> <code>(true?1:1);</code> </td> <td>  5 5 </td></tr><tr><td> <code>(false?1:1);</code> </td> <td>  4 4 </td></tr><tr><td> <code>if(0)1;</code> </td> <td>  2 </td></tr><tr><td> <code>if(1)1;</code> </td> <td>  4 4 </td></tr><tr><td> <code>if(0)1;else 1;</code> </td> <td>  4 4 </td></tr><tr><td> <code>if(1)1;else 1;</code> </td> <td>  5 5 </td></tr><tr><td> <code>while(0);</code> </td> <td>  2 </td></tr><tr><td> <code>i=1;</code> </td> <td>  3 </td></tr><tr><td> <code>i=i+1;</code> </td> <td>  5 5 </td></tr><tr><td> <code>var j = 1;</code> </td> <td>  1 </td></tr><tr><td> <code>var j = 0;while(j &lt; 1)j=j+1;</code> </td> <td>  15 </td></tr></tbody></table></div><br><br><h2>  Determinar el tipo de máquina virtual </h2><br><hr><br><p>  Primero debe comprender cómo funciona el intérprete de VKScript.  Hay dos opciones más o menos plausibles: </p><br><ul><li>  El intérprete atraviesa recursivamente el árbol de sintaxis y realiza una operación en cada nodo. </li><li>  El compilador traduce el árbol de sintaxis en una secuencia de instrucciones que ejecuta el intérprete. </li></ul><br><p>  Es fácil entender que VKScript usa la segunda opción.  Considere la expresión <code>(true?1:1);</code>  (5 operaciones) y <code>(false?1:1);</code>  (4 operaciones).  En el caso de la ejecución secuencial de instrucciones, una operación adicional se explica por una transición que "omite" la opción incorrecta, y en el caso de una omisión AST recursiva, ambas opciones son equivalentes para el intérprete.  Se observa un efecto similar en if / else con una condición diferente. </p><br><p>  También vale la pena prestar atención al par <code>i = 1;</code>  (3 operaciones) y <code>var j = 1;</code>  (1 operación).  ¿Crear una nueva variable cuesta solo 1 operación y asignarla a una existente cuesta 3?  El hecho de que crear una operación de costo variable 1 (y, muy probablemente, es una operación de carga constante), dice dos cosas: </p><br><ul><li>  Al crear una nueva variable, no hay asignación de memoria explícita para la variable. </li><li>  Al crear una nueva variable, el valor no se carga en la celda de memoria.  Esto significa que el espacio para la nueva variable se asigna donde se calculó el valor de la expresión, y después de eso, esta memoria se considera asignada.  Esto sugiere el uso de una máquina apiladora. </li></ul><br><p>  El uso de la pila también explica que la expresión <code>var j = 1;</code>  corre más rápido que la expresión <code>1;</code>  : la última expresión gasta instrucciones adicionales para eliminar el valor calculado de la pila. </p><br><br><h2>  Determinar el valor límite exacto </h2><br><p>  Tenga en cuenta que el ciclo <code>var j=0;while(j &lt; 1)j=j+1;</code>  (15 operaciones) es una copia pequeña del ciclo que se utilizó para las mediciones: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Código </th><th>  Número de operaciones </th></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </td><td>  15 + 998 * 10 = 9995 </td></tr><tr><td><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">999</span></span>) i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; ~<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  (límite) </td><td>  9998 </td></tr></tbody></table></div><br><p>  ¿Detener qué?  ¿Hay un límite de 9998 instrucciones?  Claramente nos falta algo ... </p><br><p>  Tenga en cuenta que el código de <code>return 1;</code> es <code>return 1;</code>  realizado según mediciones para 0 instrucciones.  Esto se explica fácilmente: el compilador agrega un <code>return null;</code> implícito <code>return null;</code> al final del código <code>return null;</code>  , y al agregar su retorno falla.  Suponiendo que el límite es 10000, concluimos que la operación <code>return null;</code>  toma 2 instrucciones (probablemente esto es algo así como <code>push null; return;</code> ). </p><br><br><h2>  Bloques de código anidados </h2><br><hr><br><p>  Tomemos algunas medidas más: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Código </th><th>  Número de operaciones </th></tr><tr><td> <code>{};</code> </td> <td>  0 0 </td></tr><tr><td> <code>{var j = 1;};</code> </td> <td>  2 </td></tr><tr><td> <code>{var j = 1, k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>{var j = 1; var k = 2;};</code> </td> <td>  3 </td></tr><tr><td> <code>var j = 1; var j = 1;</code> </td> <td>  4 4 </td></tr><tr><td> <code>{var j = 1;}; var j = 1;</code> </td> <td>  3 </td></tr></tbody></table></div><br><p>  Prestemos atención a los siguientes hechos: </p><br><ul><li>  Agregar una variable a un bloque requiere una operación adicional. </li><li>  Cuando se "declara una variable nuevamente", la segunda declaración se cumple como una asignación normal. </li><li>  Pero al mismo tiempo, la variable dentro del bloque no es visible desde el exterior (ver el último ejemplo). </li></ul><br><p>  Es fácil entender que se gasta una operación adicional para eliminar de la pila las variables locales declaradas en el bloque.  En consecuencia, cuando no hay variables locales, no es necesario eliminar nada. </p><br><br><h1>  Objetos, Métodos, Llamadas API </h1><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  Código </th><th>  Número de operaciones </th></tr><tr><td> <code>"";</code> </td> <td>  2 </td></tr><tr><td> <code>"abcdef";</code> </td> <td>  2 </td></tr><tr><td> <code>{};</code> </td> <td>  2 </td></tr><tr><td> <code>[];</code> </td> <td>  2 </td></tr><tr><td> <code>[1, 2, 3];</code> </td> <td>  5 5 </td></tr><tr><td> <code>{a: 1, b: 2, c: 3};</code> </td> <td>  5 5 </td></tr><tr><td> <code>API.users.isAppUser(1);</code> </td> <td>  3 </td></tr><tr><td> <code>"".substr(0, 0);</code> </td> <td>  6 6 </td></tr><tr><td> <code>var j={};jx=1;</code> </td> <td>  6 6 </td></tr><tr><td> <code>var j={x:1};delete jx;</code> </td> <td>  6 6 </td></tr></tbody></table></div><br><p>  Analicemos los resultados.  Puede notar que crear una cadena y una matriz / objeto vacío requiere 2 operaciones, al igual que cargar un número.  Al crear una matriz u objeto no vacío, se agregan las operaciones dedicadas a cargar elementos de la matriz / objeto.  Esto sugiere que la creación directa de un objeto ocurre en una operación.  Al mismo tiempo, no se pierde tiempo descargando nombres de propiedades; por lo tanto, descargarlos es parte de la operación de creación del objeto. </p><br><p>  Con la llamada al método API, todo también es bastante común: cargar una unidad, realmente llamar al método, <code>pop</code> resultado (puede notar que el nombre del método se procesa como un todo y no como propiedades de toma).  Pero los últimos tres ejemplos parecen interesantes. </p><br><ul><li> <code>"".substr(0, 0);</code>  - cargando una cadena, cargando cero, cargando cero, resultado <code>pop</code> .  Por una razón, hay 2 instrucciones para llamar a un método (por alguna razón, ver más abajo). </li><li> <code>var j={};jx=1;</code>  - crear un objeto, cargar un objeto, cargar una unidad, <code>pop</code> unit después de la asignación.  Nuevamente, hay 2 instrucciones para la asignación. </li><li> <code>var j={x:1};delete jx;</code>  - cargar una unidad, crear un objeto, cargar un objeto, eliminar.  Hay 3 instrucciones por operación de eliminación. </li></ul><br><br><a name="semantics"></a><br><h1>  Semántica de objetos VKScript </h1><br><h2>  Los numeros </h2><br><hr><br><p>  Volviendo a la pregunta original: ¿VKScript es un subconjunto de JavaScript u otro idioma?  Hagamos una prueba simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> + <span class="hljs-number"><span class="hljs-number">2000000000</span></span>;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-number"><span class="hljs-number">-1294967296</span></span>};</code> </pre> <br><p>  Como podemos ver, la suma de enteros conduce al desbordamiento, a pesar de que JavaScript no tiene enteros como tales.  También es fácil verificar que dividir por 0 conduce a un error y no devuelve <code>Infinity</code> . </p><br><br><h2>  Los objetos </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {};</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  ¿Detener qué?  ¿Devolvemos <i>un objeto</i> y obtenemos una <i>matriz</i> ?  Si lo es.  En VKScript, las matrices y los objetos están representados por el mismo tipo, en particular, un objeto vacío y una matriz vacía son uno y lo mismo.  En este caso, la propiedad de <code>length</code> del objeto funciona y devuelve el número de propiedades. </p><br><p>  ¿Es interesante ver cómo se comportan los métodos de lista si los llama a un objeto? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  El método <code>pop</code> devuelve la última propiedad declarada, que, sin embargo, es lógica.  Cambiar el orden de las propiedades: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">b</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Aparentemente, los objetos en VKScript recuerdan el orden en que se asignan las propiedades.  Intentemos usar propiedades numéricas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">'0'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>}.pop();</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Ahora veamos cómo funciona push: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(<span class="hljs-string"><span class="hljs-string">'d'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Como puede ver, el método de inserción ordena las teclas numéricas y agrega un nuevo valor después de la última tecla numérica.  Los "agujeros" no se rellenan en este caso. </p><br><p>  Ahora intente combinar estos dos métodos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-string"><span class="hljs-string">'2'</span></span>:<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'1'</span></span>:<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>:<span class="hljs-string"><span class="hljs-string">'c'</span></span>}; a.push(a.pop()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"1"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"2"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"3"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"x"</span></span>: <span class="hljs-string"><span class="hljs-string">"c"</span></span>};</code> </pre> <br><p>  Como vemos, el elemento no se ha eliminado de la matriz.  Sin embargo, si ponemos <code>push</code> y <code>pop</code> en diferentes líneas, el error desaparecerá.  ¡Necesitamos ir más profundo! </p><br><br><h2>  Almacenamiento de objetos </h2><br><hr><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = x; xy = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y;</code> </pre> <br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: []}</code> </pre> <br><p>  Al final resultó que, los objetos en VKScript se almacenan por valor, a diferencia de JavaScript.  Ahora vemos el extraño comportamiento de la cadena <code>a.push(a.pop());</code>  - aparentemente, el valor anterior de la matriz se guardó en la pila, desde donde se tomó más tarde. </p><br><p>  Sin embargo, ¿cómo se almacenan los datos en el objeto si el método lo modifica?  Aparentemente, la instrucción "extra" cuando se llama al método está diseñada específicamente para escribir cambios en el objeto. </p><br><br><h2>  Métodos de matriz </h2><br><hr><br><div class="scrollable-table"><table><tbody><tr><th>  Método </th><th>  Acción </th></tr><tr><td> <code>push</code> </td> <td><ul><li>  ordenar claves numéricas por valor </li><li>  tome la clave numérica máxima, agregue una </li><li>  escribir argumento para la matriz </li><li>  agregar claves no numéricas al final de la matriz </li></ul></td></tr><tr><td> <code>pop</code> </td> <td>  Elimine el último elemento de la matriz (no necesariamente con una clave numérica) y regrese. </td></tr><tr><td>  el resto </td><td><ul><li>  ordenar claves numéricas por valor, eliminar "agujeros" en la matriz </li><li>  realizar la operación javascript adecuada </li><li>  agregar claves no numéricas al final de la matriz </li></ul><br><p>  Cuando se usa el método de división, los cambios no se guardan </p><br></td></tr></tbody></table></div><br><a name="summary"></a><h1>  Conclusión </h1><br><hr><br><p>  VKScript no es JavaScript.  A diferencia de JavaScript, los objetos que contiene se almacenan por valor, no por referencia, y tienen una semántica completamente diferente.  Sin embargo, cuando se utiliza VKScript para el propósito para el que está destinado, la diferencia no se nota. </p><br><br><h1>  PS Semántica de operadores </h1><br><hr><br><p>  Los comentarios mencionaron la combinación de objetos a través de <code>+</code> .  En este sentido, decidí agregar información sobre el trabajo de los operadores. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Operador </th><th>  Acciones </th></tr><tr><td>  + </td><td><ul><li>  Si ambos argumentos son objetos, cree una copia del primer objeto y agregue las claves del segundo (con reemplazo). </li><li>  Si ambos argumentos son números, agregue como números. </li><li>  De lo contrario, ambos operandos se convierten en una cadena y se agregan como cadenas. </li></ul></td></tr><tr><td>  Otros operadores aritméticos </td><td>  Ambos operandos se emiten a un número y se realiza la operación correspondiente.  Para operaciones de bit, los operandos se convierten adicionalmente en <code>int</code> . </td></tr><tr><td>  Operadores de comparación </td><td>  Si se comparan dos cadenas o dos números, se comparan directamente.  Si se comparan una cadena y un número, y la cadena es una notación correcta para el número, la cadena se convierte en un número.  De lo contrario, se devuelve un error de <code>Comparing values of different or unsupported types</code> . </td></tr><tr><td>  Cast to string </td><td>  Los números y las cadenas se dan como en JavaScript.  Los objetos se enumeran como una lista de valores separados por comas en el orden de las claves.  <code>false</code> y <code>null</code> se lanzan como <code>""</code> , <code>true</code> lanza como <code>"1"</code> . </td></tr><tr><td>  Fundido a </td><td>  Si el argumento es una cadena que es una notación de número válida, se devuelve el número.  De lo contrario, se devuelve un error <code>Numeric arguments expected</code> . </td></tr></tbody></table></div><br><p>  Para operaciones con números (excepto bit), si los operandos son <code>int</code> y <code>double</code> , <code>int</code> se <code>double</code> en <code>double</code> .  Si ambos operandos son <code>int</code> , se realiza una operación en enteros de 32 bits con signo (con desbordamiento). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464099/">https://habr.com/ru/post/464099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464089/index.html">Automatizar solicitudes HTTP en el contexto de Spring</a></li>
<li><a href="../464091/index.html">El resumen de materiales interesantes para el desarrollador móvil # 311 (del 12 al 18 de agosto)</a></li>
<li><a href="../464093/index.html">Productos digitales: ¿qué hacer si un cliente viene a recoger una compra en un año?</a></li>
<li><a href="../464095/index.html">Getters y Setters en Dart and Flutter</a></li>
<li><a href="../464097/index.html">La evolución de la inteligencia: por qué los robots necesitan emociones</a></li>
<li><a href="../464103/index.html">OpenUNB borrador del estándar nacional de IoT: revisión crítica</a></li>
<li><a href="../464105/index.html">Servidor Commento nativo con Docker Compose</a></li>
<li><a href="../464107/index.html">Eventos digitales en Moscú del 19 al 25 de agosto.</a></li>
<li><a href="../464109/index.html">Paracaídas supersónicos espaciales</a></li>
<li><a href="../464111/index.html">Natas Web. Paso de la plataforma CTF destinada a explotar vulnerabilidades web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>