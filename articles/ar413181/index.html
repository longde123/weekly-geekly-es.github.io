<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚕️ 🤠 🍗 عندما تكون مكالمات الوظيفة الخارجية أسرع من مكالمات C الأصلية 🏣 🏂🏽 ♠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أضيف بواسطة: مناقشة جيدة على أخبار هاكر 

 قام David Yu على GitHub بتطوير اختبار أداء مثير للاهتمام لاستدعاءات الوظائف من خلال واجهات خارجية مختلفة (و...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>عندما تكون مكالمات الوظيفة الخارجية أسرع من مكالمات C الأصلية</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413181/" style=";text-align:right;direction:rtl"> <font color="gray"><i>أضيف بواسطة: مناقشة جيدة على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أخبار هاكر</a></i></font> <br><br>  قام David Yu على GitHub بتطوير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اختبار أداء مثير للاهتمام</a> لاستدعاءات الوظائف من خلال واجهات خارجية مختلفة (واجهات الوظائف الأجنبية ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">FFI</a> ). <br><br>  قام بإنشاء ملف كائن مشترك ( <code>.so</code> ) بوظيفة واحدة بسيطة C. ثم قام بكتابة التعليمات البرمجية لاستدعاء هذه الوظيفة بشكل متكرر من خلال كل مؤسسة مالية أجنبية ذات بعد زمني. <br><br>  بالنسبة إلى C "FFI" ، استخدم الارتباط الديناميكي القياسي ، وليس <code>dlopen()</code> .  هذا الاختلاف مهم للغاية ، لأنه يؤثر حقًا على نتائج الاختبار.  يمكنك أن تجادل في مدى صدق هذه المقارنة مع FFI الفعلي ، ولكن لا يزال من المثير للاهتمام القياس. <br><br>  النتيجة الأكثر إثارة للدهشة هي أن FFI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الخاص بـ LuaJIT</a> <b>أسرع بكثير من C.</b>  إنه أسرع بحوالي 25٪ من استدعاء C أصلي لوظيفة كائن مشترك.  كيف يمكن أن تتجاوز لغة البرمجة النصية المكتوبة بشكل ضعيف وديناميكي في المعيار C؟  هل النتيجة دقيقة؟ <br><a name="habracut"></a><br>  في الواقع ، هذا منطقي تمامًا.  يتم تشغيل الاختبار على Linux ، لذلك يأتي التأخير من جدول ربط الإجراءات (PLT).  لقد أعددت تجربة بسيطة حقًا لتوضيح التأثير في C العادي القديم: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/skeeto/dynamic-function-benchmark</a> <br><br>  فيما يلي نتائج Intel i7-6700 (Skylake): <br><br> <code>plt: 1.759799 ns/call <br> ind: 1.257125 ns/call <br> jit: 1.008108 ns/call</code> <br> <br>  هناك ثلاثة أنواع مختلفة من استدعاءات الوظائف: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عبر PLT. </li><li style=";text-align:right;direction:rtl">  استدعاء دالة غير مباشر (عبر <code>dlsym(3)</code> ) </li><li style=";text-align:right;direction:rtl">  استدعاء وظيفة مباشرة (عبر وظيفة JIT المترجمة) </li></ol><br>  كما ترون ، هذا الأخير هو الأسرع.  عادة لا يتم استخدامه في برامج C ، ولكنه خيار طبيعي في وجود مترجم JIT ، بما في ذلك ، LuaJIT. <br><br>  في مقياس الأداء الخاص بي ، تسمى الوظيفة <code>empty()</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  ترجمة لكائن مشترك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">$ cc -shared -fPIC -Os -o empty.so empty.c</code> </pre> <br>  كما هو الحال في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقارنة PRNG</a> السابقة ، فإن المؤشر المرجعي يستدعي أكبر عدد ممكن من هذه الوظيفة قبل انطلاق التنبيه. <br><br><h1 style=";text-align:right;direction:rtl">  جداول تخطيط الإجراءات </h1><br>  عندما يستدعي برنامج أو مكتبة وظيفة في كائن مشترك آخر ، لا يستطيع المترجم معرفة مكان وجود هذه الوظيفة في الذاكرة.  يتم العثور على المعلومات فقط في وقت التشغيل عندما يتم تحميل البرنامج وتبعياته في الذاكرة.  عادة ما تكون الوظيفة موجودة في أماكن عشوائية ، على سبيل المثال ، وفقًا للعشوائية لمساحة العنوان (العنوان العشوائي لتخطيط مساحة العنوان ، ASLR). <br><br>  كيف تحل مثل هذه المشكلة؟  حسنًا ، هناك العديد من الخيارات. <br><br>  أحدها هو وضع علامة على كل مكالمة في البيانات الوصفية الثنائية.  ثم يقوم منشئ وقت التشغيل الديناميكي <i>بإدراج</i> العنوان الصحيح في كل مكالمة.  تعتمد الآلية المحددة على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نموذج الكود</a> الذي تم استخدامه أثناء التحويل البرمجي. <br><br>  عيب هذا النهج هو أنه يبطئ التحميل ، يزيد من حجم الملفات الثنائية ويقلل من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تبادل صفحات الرموز</a> بين العمليات المختلفة.  تم إبطاء التنزيل نظرًا لأن جميع أقران الاتصال الديناميكي يحتاجون إلى التصحيح بالعنوان الصحيح قبل بدء البرنامج.  يتم تضخيم الثنائي لأن كل إدخال يحتاج إلى مكان في الجدول.  ويرتبط نقص المشاركة بتغيير في صفحات الرموز. <br><br>  من ناحية أخرى ، يمكن التخلص من الحمل الزائد للوظائف الديناميكية ، مما يعطي أداءًا يشبه JIT ، كما هو موضح في المعيار. <br><br>  الخيار الثاني هو توجيه جميع المكالمات الديناميكية من خلال طاولة.  يشير نظير القرص الأصلي إلى كعب في هذا الجدول ، ومن هناك إلى الوظيفة الديناميكية الفعلية.  مع هذا النهج ، لا يحتاج الرمز إلى تصحيح ، مما يؤدي إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تبادل تافه</a> بين العمليات.  لكل وظيفة ديناميكية ، تحتاج إلى تصحيح سجل واحد فقط في الجدول.  علاوة على ذلك ، يمكن إجراء هذه التصحيحات <i>بتكاسل</i> ، في أول استدعاء للوظيفة ، مما يسرع من التحميل أكثر. <br><br>  في الأنظمة الثنائية ELF ، يُسمى هذا الجدول جدول ربط الإجراءات (PLT).  لا يتم تصحيح PLT نفسه - يتم عرضه للقراءة فقط لبقية التعليمات البرمجية.  بدلاً من ذلك ، يتم تصحيح جدول الإزاحة العمومية (GOT).  يسترجع كعب PLT عنوان وظيفة ديناميكية من GOT وينتقل <i>بشكل غير مباشر</i> إلى هذا العنوان.  لتحميل عناوين الوظائف بشكل بطيء ، تتم تهيئة إدخالات GOT بعنوان الوظيفة التي تعثر على الحرف الهدف ، وتقوم بتحديث GOT بهذا العنوان ، ثم تنتقل إلى الوظيفة.  تستخدم المكالمات اللاحقة عنوانًا تم الكشف عنه بتكاسل. <br><br><img src="https://habrastorage.org/webt/47/2r/yh/472ryhlyogynkwwrxyopa1rg7l0.png"><br><br>  عيب PLT هو الحمل الإضافي لاستدعاء وظيفة ديناميكية ، وهو ما ظهر في المعيار.  نظرًا لأن المقياس يقيس الاستدعاءات الوظيفية <i>فقط</i> ، يبدو الفرق كبيرًا جدًا ، ولكنه عمليًا يكون قريبًا من الصفر. <br><br>  هنا هو المعيار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Cleared by an alarm signal. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  بما أن <code>empty()</code> في كائن مشترك ، فإن المكالمة تمر عبر PLT. <br><br><h1 style=";text-align:right;direction:rtl">  مكالمات ديناميكية غير مباشرة </h1><br>  هناك طريقة أخرى لاستدعاء الوظائف بشكل ديناميكي وهي التنقل حول PLT والحصول على عنوان الوظيفة المستهدفة في البرنامج ، على سبيل المثال ، عبر <code>dlsym(3)</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *h = dlopen(<span class="hljs-string"><span class="hljs-string">"path/to/lib.so"</span></span>, RTLD_NOW); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*f)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); f();</code> </pre> <br>  إذا تم استلام عنوان الوظيفة ، فستكون التكلفة أقل من استدعاء الوظيفة من خلال PLT.  لا توجد وظيفة وسيطة للكعب والوصول إلى GOT.  (تنبيه: إذا كان البرنامج يحتوي على سجل PLT لهذه الوظيفة ، فعندئذٍ يمكن لـ <code>dlsym(3)</code> إرجاع عنوان كعب). <br><br>  لكن هذا لا يزال تحديا <i>غير مباشر</i> .  في البنيات التقليدية ، تتلقى مكالمات الوظائف المباشرة عنوانها النسبي المباشر.  أي أن الغرض من المكالمة هو بعض الإزاحة المشفرة من نقطة الاستدعاء.  يمكن لوحدة المعالجة المركزية معرفة إلى أين ستذهب المكالمة قبل ذلك بكثير. <br><br>  المكالمات غير المباشرة لها المزيد من النفقات العامة.  أولاً ، يجب تخزين العنوان في مكان ما.  حتى لو كان مجرد سجل ، فإن استخدامه يزيد من عجز السجلات.  ثانيًا ، تثير المكالمات غير المباشرة مؤشرًا فرعيًا في وحدة المعالجة المركزية ، مما يفرض حملًا إضافيًا على المعالج.  في أسوأ الحالات ، يمكن أن تتسبب المكالمة في توقف خط الأنابيب. <br><br>  هنا هو المعيار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) f(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  يتم استخراج الوظيفة التي تم تمريرها إلى هذا المعيار باستخدام <code>dlsym(3)</code> ، لذلك لا يمكن للمترجم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">القيام بشيء صعب</a> ، مثل تحويل هذه المكالمة غير المباشرة مرة أخرى إلى مباشرة. <br><br>  إذا كان جسم الحلقة معقدًا بما يكفي للتسبب في عجز في التسجيلات وبالتالي إعطاء العنوان إلى المكدس ، فلا يمكن أيضًا مقارنة هذا المعيار بصدق مع معيار PLT. <br><br><h1 style=";text-align:right;direction:rtl">  مكالمات الوظيفة المباشرة </h1><br>  النوعان الأولان من استدعاءات الوظائف الديناميكية بسيطة وسهلة الاستخدام.  من الصعب تنظيم المكالمات <i>المباشرة</i> للوظائف الديناميكية ، لأنها تتطلب تغييرات في التعليمات البرمجية أثناء التنفيذ.  في مقياس الأداء الخاص بي ، قمت بتجميع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مترجم JIT صغير</a> لإنشاء مكالمة مباشرة. <br><br>  الحيلة هي أنه في x86-64 الانتقالات الواضحة تقتصر على نطاق 2 غيغابايت بسبب المعامل الموقّع 32 بت (موقّع فوري).  هذا يعني أنه يجب وضع كود JIT تقريبًا بجوار الوظيفة المستهدفة <code>empty()</code> .  إذا كان رمز JIT يجب أن يستدعي وظيفتين ديناميكيتين مختلفتين مقسومتين على أكثر من 2 جيجابايت ، فمن المستحيل إجراء مكالمتين مباشرتين. <br><br>  لتبسيط الموقف ، لا تقلق معياري بشأن الاختيار الدقيق أو الدقيق للغاية لعنوان كود JIT.  بعد تلقي عنوان الوظيفة المستهدفة ، تقوم ببساطة بطرح 4 ميجابايت ، وتقريبها إلى أقرب صفحة ، وتخصيص جزء من الذاكرة وكتابة التعليمات البرمجية لها.  إذا تم القيام بكل شيء كما ينبغي ، فابحث عن مكان تحتاج إليه للتحقق من تمثيلاتك الخاصة للبرنامج في الذاكرة ، ولا يمكن القيام بذلك بطريقة نظيفة ومحمولة.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">يتطلب</a> Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تحليل الملفات الافتراضية تحت / proc</a> . <br><br>  هذه هي الطريقة التي يبدو بها تخصيص ذاكرة JIT.  يفترض <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سلوك معقول لصب uintptr_t</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jit_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct jit_func *f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*empty)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> addr = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)empty; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *desired = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((addr - SAFETY_MARGIN) &amp; PAGEMASK); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = mmap(desired, len, prot, flags, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  تبرز صفحتان هنا: إحداهما للكتابة والأخرى برمز غير قابل للكتابة.  كما هو الحال في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مكتبتي للإغلاق</a> ، هنا الصفحة السفلى قابلة للكتابة وتحتوي على متغير <code>running</code> يعيد تعيينه إلى التنبيه.  يجب أن تكون هذه الصفحة بجوار رمز JIT من أجل توفير وصول فعال بخصوص RIP ، كدالة في المعيارين الآخرين.  تحتوي الصفحة العلوية على رمز التجميع هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs vbscript">jit_benchmark: push rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebx, ebx .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: mov eax, [rel running] test eax, eax je .done <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> inc ebx jmp .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> .done: mov eax, ebx pop rbx ret</code> </pre> <br>  <code>call empty</code> هي التعليمات الوحيدة التي يتم إنشاؤها ديناميكيًا ، فمن الضروري ملء العنوان النسبي بشكل صحيح (ناقص 5 موضح بالنسبة إلى <i>نهاية</i> التعليمات): <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs lisp"> // call empty uintptr_t rel = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)empty - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)p - <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; *p++ = 0xe8; *p++ = rel &gt;&gt; 0; *p++ = rel &gt;&gt; 8; *p++ = rel &gt;&gt; 16; *p++ = rel &gt;&gt; 24;</span></span></code> </pre> <br>  إذا لم تكن الوظيفة <code>empty()</code> في الكائن العام ، ولكن في نفس الملف الثنائي ، فهذا في الأساس عبارة عن استدعاء مباشر <code>plt_benchmark()</code> المحول البرمجي لـ <code>plt_benchmark()</code> ، بافتراض أنه لسبب ما لم يتم إنشاؤه <code>empty()</code> . <br><br>  ومن المفارقات ، استدعاء رمز JIT المترجمة يتطلب مكالمة غير مباشرة (على سبيل المثال ، من خلال مؤشر دالة) ، ولا توجد طريقة لذلك.  ماذا يمكنني أن أفعل هنا ، JIT-compile وظيفة أخرى لإجراء مكالمة مباشرة؟  لحسن الحظ ، هذا لا يهم لأنه يتم قياس المكالمة المباشرة فقط في حلقة. <br><br><h1 style=";text-align:right;direction:rtl">  ليس سرا </h1><br>  بالنظر إلى هذه النتائج ، يصبح من الواضح لماذا تقوم LuaJIT بإجراء مكالمات أكثر كفاءة للوظائف الديناميكية من PLT ، <i>حتى إذا ظلت مكالمات غير مباشرة</i> .  في مقياس الأداء الخاص بي ، كانت المكالمات غير المباشرة بدون PLT أسرع بنسبة 28٪ من مكالمات PLT ، وكانت المكالمات المباشرة بدون PLT أسرع بنسبة 43٪ من مكالمات PLT.  يتم تحقيق هذه الميزة الصغيرة لبرامج JIT على البرامج الأصلية القديمة البسيطة بسبب الرفض المطلق لتبادل التعليمات البرمجية بين العمليات. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar413181/">https://habr.com/ru/post/ar413181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar413169/index.html">الصفيف المفيد وطرق الكائن في جافا سكريبت</a></li>
<li><a href="../ar413171/index.html">تطلق Tokamak JET حملة جديدة Deuterium Tritium</a></li>
<li><a href="../ar413173/index.html">مراقبة أخطاء جافا سكريبت باستخدام windows.onerror</a></li>
<li><a href="../ar413175/index.html">تحليل ثابت في Go: كيف نوفر الوقت عند التحقق من التعليمات البرمجية</a></li>
<li><a href="../ar413177/index.html">الأحداث الرقمية في موسكو من 4 إلى 10 يونيو</a></li>
<li><a href="../ar413187/index.html">مقابلة مع ريان دال ، مبتكر موقع Node.js</a></li>
<li><a href="../ar413189/index.html">مجموعة من ظلال العيون css Box-shadows.css</a></li>
<li><a href="../ar413193/index.html">شراء الحديد مقابل السحابة: كيف نحسب</a></li>
<li><a href="../ar413195/index.html">التفكير الوظيفي. الجزء 6</a></li>
<li><a href="../ar413199/index.html">فشل علماء المستقبل. أفكار من أفلام لم تتحقق</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>