<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👦 ↖️ 🍭 Kubernetes 1.16：亮点概述 😖 💽 📻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在星期三， 将举行下一版本的Kubernetes-1.16。 根据博客发展的传统，在十周年之际，我们正在谈论新版本中最重大的变化。 

 用于准备此材料的信息来自Kubernetes增强跟踪表 CHANGELOG-1.16和相关问题，请求，以及Kubernetes增强提案（KEP）。 所以走吧...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.16：亮点概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/467477/"><img src="https://habrastorage.org/webt/6b/oi/xq/6boixq7wqypazw43aysbw8y9xty.png"><br><br> 今天，在星期三， <a href="">将举行</a>下一版本的Kubernetes-1.16。 根据博客发展的传统，在十周年之际，我们正在谈论新版本中最重大的变化。 <br><br> 用于准备此材料的信息来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes增强跟踪表</a> <a href="">CHANGELOG-1.16</a>和相关问题，请求，以及Kubernetes增强提案（KEP）。 所以走吧！.. <a name="habracut"></a><br><br><h2> 结 </h2><br> 在K8s-clusters（Kubelet）节点的侧面展示了数量众多的显着创新（处于alpha版本状态）。 <br><br> 首先，介绍了所谓的<b>“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">临时容器</a> ” <i>（Ephemeral Containers）</i> ，旨在简化Pod中的调试过程</b> 。 新机制使您可以运行特殊容器，这些容器从现有容器的命名空间中开始，并且存在很短时间。 它们的目的是与其他容器和容器进行交互，以解决任何问题并进行调试。 为此功能，实现了一个新的<code>kubectl debug</code>命令，本质上与<code>kubectl exec</code>相似：仅在容器中启动容器，而不是在容器中启动进程（如<code>exec</code>的情况）。 例如，这样的命令会将新容器连接到Pod： <br><br><pre> <code class="bash hljs">kubectl debug -c debug-shell --image=debian target-pod -- bash</code> </pre> <br> 临时容器的详细信息（及其使用示例）可以在<a href="">相应的KEP中</a>找到。 当前的实现（在K8s 1.16中）是Alpha版本，并且要转移到Beta版本的标准之一是“测试Ephemeral Containers API的至少2个发行版[Kubernetes]”。 <br><br>  <i><b>注意</b> ：本质上，甚至功能的名称都类似于我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已经写过</a>的已经存在的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubectl-debug</a>插件。</i>  <i>假定随着临时容器的出现，将停止开发单独的外部插件。</i> <br><br> 另一项创新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PodOverhead</code></a>旨在提供一种<b>计算Pod开销成本的机制，</b>该<b>机制</b>可能会因所使用的运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PodOverhead</code></a>有很大差异。 例如， <a href="">该KEP</a>的作者引用了Kata容器，它要求启动来宾内核，kata代理，init系统等。 当开销太大时，就不能忽略它，这意味着需要一种方法来考虑进一步的配额，计划等。 为了实现<code>PodSpec</code> ，将<code>Overhead *ResourceList</code>字段添加到<code>PodSpec</code> （与<code>RuntimeClass</code>数据（如果使用的话）相比）。 <br><br> 另一个值得注意的创新是<i>Node Topology Manager</i> ，它旨在统一微调Kubernetes中各种组件的硬件资源分配的方法。 这项举措是由于各种现代系统（来自电信，机器学习，金融服务等）对高性能并行计算以及使执行操作的延迟最小化的需求日益增长而引起的，这些系统使用了CPU和硬件加速的高级功能。 到目前为止，得益于不同的组件（CPU管理器，设备管理器，CNI），Kubernetes中的此类优化已经实现，现在它们将添加单个内部接口，以统一该方法并简化Kubelet端上新的类似组件（所谓的拓扑感知）组件的连接。 详细信息在<a href="">相应的KEP中</a> 。 <br><br><img src="https://habrastorage.org/webt/tq/bs/vr/tqbsvryzr9tnxv_9uldn-ofx1es.png"><br>  <i>拓扑管理器组件图</i> <br><br> 下一个功能是<b>在启动过程中检查容器<i>（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动探针</a> ）</i></b> 。 如您所知，对于长时间运行的容器，很难获得当前状态：它们要么在实际开始运行之前就被“杀死”，要么长期处于死锁状态。 一项新的检查（通过称为<code>StartupProbeEnabled</code>的功能门启用）会取消（或<code>StartupProbeEnabled</code>任何其他检查的操作，直到吊舱完成启动为止。 因此，该功能最初称为<a href="">pod-startup liveness-probe holdoff</a> 。 对于启动时间很长的Pod，可以在相对较短的时间间隔内轮询状态。 <br><br> 此外，在beta状态下，立即添加了对RuntimeClass的改进，增加了对“异构集群”的支持。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RuntimeClass Scheduling，</a>现在不需要每个节点都支持每个RuntimeClass：对于Pod，您可以选择RuntimeClass，而无需考虑集群拓扑。 以前，要实现此目的（为了使Pod出现在节点上并支持他们所需的一切），他们必须为NodeSelector和公差分配适当的规则。  <a href="">KEP</a>讨论了用法示例，当然还有实现细节。 <br><br><h2> 联播网 </h2><br> 在Kubernetes 1.16中首次出现的两个重要网络功能（在Alpha版本中）是： <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a>双网络堆栈-IPv4 / IPv6-</b>及其在pod，节点，服务级别的相应“理解”。 它包括从Pod到外部服务的Pod之间的IPv4到IPv4和IPv6到IPv6的交互，参考实现（在Bridge CNI，PTP CNI和Host-Local IPAM插件的框架内）以及反向操作。与仅在IPv4或IPv6上工作的Kubernetes集群兼容。 实施细节在<a href="">KEP中</a> 。 <br><br>  Pod列表中的两种IP地址（IPv4和IPv6）输出示例： <br><br><pre> <code class="bash hljs">kube-master<span class="hljs-comment"><span class="hljs-comment"># kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-controller 1/1 Running 0 20m fd00:db8:1::2,192.168.1.3 kube-minion-1 kube-master#</span></span></code> </pre> <br></li><li>  <b>Endpoint的新API</b>是<a href="">EndpointSlice API</a> 。 它以性能/可伸缩性解决了现有Endpoint API的问题，这些问题会影响控制平面中的各个组件（apiserver，etcd，endpoints-controller，kube-proxy）。 新的API将被添加到Discovery API组中，并将能够在由一千个节点组成的集群中为每个服务提供数万个后端端点。 为此，每个服务都映射到N个<code>EndpointSlice</code>对象，每个对象默认情况下最多不超过100个端点（该值是可配置的）。  EndpointSlice API也将为其未来的发展提供机会：支持每个Pod的多个IP地址，端点的新状态（不仅为<code>Ready</code>和<code>NotReady</code> ），端点的动态子集。 </li></ul><br>  <a href="">最后</a>一个版本中提供的<a href="">终结器</a> ，称为<code>service.kubernetes.io/load-balancer-cleanup</code>并已附加到具有<code>LoadBalancer</code>类型的每个服务， <code>LoadBalancer</code>升级到beta版。 在删除此类服务时，它会阻止资源的实际删除，直到平衡器所有相应资源的“清理”完成为止。 <br><br><h2>  API机械 </h2><br> 真正的“稳定里程碑”固定在Kubernetes API服务器的区域中并与之交互。 从很多方面<b>来看</b> ，发生这种情况是由于<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CustomResourceDefinitions</a> （CRD）转移到了稳定状态，不需要特殊的表示形式</b> ，而自遥远的Kubernetes 1.7以来它一直处于beta状态（这是2017年6月！）。 与它们相关的功能也具有相同的稳定性： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“子资源”，</a>带有<code>/status</code>和<code>/scale</code>用于CustomResources的<code>/scale</code> ； </li><li> 基于外部Webhook的CRD版本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转换</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最近引入</a> （在K8s 1.15中）CustomResources的默认值<i>（默认）</i>和自动字段删除<i>（修剪）</i> ； </li><li> 使用OpenAPI v3方案创建和发布用于验证服务器端CRD资源的OpenAPI文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的可能性</a> 。 </li></ul><br>  Kubernetes管理员很早就熟悉的另一种机制： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>准入</b></a> webhook-也很长时间处于beta状态（自K8s 1.9起），现已声明为稳定。 <br><br> 测试版还提供了其他两个功能： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务器端应用</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">观看书签</a> 。 <br><br>  Alpha版本中唯一的重大创新就是<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拒绝</a>了<code>SelfLink</code></b>一种表示指定对象的特殊URI，它是<code>ObjectMeta</code>和<code>ListMeta</code>一部分（即<code>ListMeta</code>中任何对象的一部分）。 为什么拒绝呢？  “简单”的动机<a href="">听起来</a>像是缺少该领域继续存在的真正（不可逾越）原因的动机。 更为正式的原因是为了优化性能（删除不必要的字段）并简化通用API服务器的工作，这被迫以特殊方式处理此类字段（这是在序列化对象之前唯一设置的字段）。  <code>SelfLink</code>的真正“过时”（在beta版中）将发生在Kubernetes 1.20版中，最后一个是1.21版。 <br><br><h2> 资料储存 </h2><br> 与以前的版本一样，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSI</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a>领域中也可以看到存储领域的主要工作。 这里的主要变化是： <br><br><ul><li> 第一次（在Alpha版本中） <b>出现</b>了<b>对Windows工作节点的CSI插件的支持</b> ：当前使用存储库的方式将替换Kubernetes核心中的树内插件和Microsoft的基于Powershell的FlexVolume插件； <br><br><img src="https://habrastorage.org/webt/4_/6o/h2/4_6oh2zuutje1tcvwqwzhi385m0.png"><br>  <i>Kubernetes Windows CSI插件实施方案</i> <br></li><li>  K8s 1.12中引入的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调整CSI卷大小</a>的功能已发展为beta版； </li><li> 使用CSI创建本地临时卷（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSI内联卷支持</a> ）的可能性达到了类似的“增加”（从alpha到beta）。 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">克隆</a>在以前版本的Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中</a>出现的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a> （使用现有的PVC作为<code>DataSource</code>来创建新的PVC）现在也处于beta状态。 <br><br><h2> 策划人 </h2><br> 计划中的两个显着更改（均为alpha版本）： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>EvenPodsSpreading</code></a>是<b>使用</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>EvenPodsSpreading</code></a> <b>来“公平地分配”负载而不是应用程序逻辑单元</b> （例如Deployment和ReplicaSet）并调整此分配（作为严格要求或作为温和条件，即优先级）的能力。 此功能将扩展计划的Pod的现有分发功能，现在受<code>PodAffinity</code>和<code>PodAntiAffinity</code> ，使管理员可以更好地控制此问题，这意味着更好的可访问性和优化的资源消耗。 详细信息在<a href="">KEP中</a> 。 </li><li> 在Pod调度期间使用<i>RequestedToCapacityRatio优先级函数</i>中的<i>BestFit策略</i> ，可以将<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bin打包</a></b> （“容器打包”）用于核心资源（处理器，内存）和扩展资源（如GPU）。 有关更多详细信息，请参见<a href="">KEP</a> 。 <br><br><img src="https://habrastorage.org/webt/4z/gx/zm/4zgxzmdtmhyg-mmjnw-cccyw8wq.gif"><br>  <i>Pod计划：使用最适合的策略（直接通过默认计划程序）并使用它（通过计划程序扩展程序）之前</i> </li></ul><br> 此外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还提供</a>了在Kubernetes（树外）主要开发树之外为调度程序创建自己的插件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>机会。 <br><br><h2> 其他变化 </h2><br> 同样在Kubernetes 1.16版本中，您可以注意到<b>主动<a href="">将</a>现有指标完整</b>地或更准确地按照K8s仪表的<a href="">官方要求</a> 。 他们基本上依赖于相关的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Prometheus文档</a> 。 造成不一致的原因多种多样（例如，一些度量标准只是在当前说明出现之前创建的），并且开发人员认为是时候将所有内容统一到一个标准，“与Prometheus生态系统的其余部分保持一致”。 该计划的当前实施处于alpha版本的状态，它将在Kubernetes的未来版本中逐渐增加到beta（1.17）和稳定版（1.18）。 <br><br> 此外，还应注意以下更改： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随着</a>此操作系统的Kubeadm实用程序（alpha版本）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现</a> <b>，Windows支持的开发，</b>用于Windows容器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <code>RunAsUserName</code>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可能性</a> （alpha版本），对组托管服务帐户（gMSA）的beta版<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持的改进，</a>对vSphere卷的安装/附加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重新设计</a> <b>了API响应中的数据压缩机制</b> 。 以前，HTTP筛选器用于这些目的，它施加了许多限制，默认情况下阻止其被包含。 现在，“请求的透明压缩”起作用了：如果邮件头的大小超过128 Kb，则在标头中发送<code>Accept-Encoding: gzip</code>客户端将收到GZIP中的压缩响应。  Go上的客户端会自动支持压缩（发送所需的标头），因此他们会立即注意到流量减少。  （对于其他语言，可能需要稍作修改。） </li><li>  <b>基于外部指标，</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以将</a> <b>HPA从零扩展到零扩展</b> 。 如果扩展基于对象/外部指标，则当工作负载空闲时，您可以自动扩展到0个副本以节省资源。 对于工作人员请求GPU资源且不同类型的空闲工作人员的数量超过可用GPU的情况，此功能特别有用。 </li><li> 一个新的客户端<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>k8s.io/client-go/metadata.Client</code></a>用于“通用”访问对象。 它旨在轻松地从群集资源中获取元数据（即， <code>metadata</code>子节），并从垃圾回收和配额类别中对其执行操作。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现在可以在</a>没有过时（“内置”树内）云提供程序（alpha版本）的情况下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建</a> Kubernetes。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a> kubeadm实用程序中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">添加了</a>在<code>init</code> ， <code>join</code>和<code>upgrade</code>操作过程中应用kustomize补丁的实验性（Alpha版）功能。 有关如何使用<code>--experimental-kustomize</code>详细信息，请参见<a href="">KEP</a> 。 </li><li>  apiserver的新端点为readyz，它允许您导出准备信息。  API服务器还具有<code>--maximum-startup-sequence-duration</code>标志，可用于调整其重新启动。 </li><li> 声明<b>Azure的</b>两个<b>功能</b>稳定：支持可用区和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">跨资源组</a> （RG）。 此外，Azure添加了： <br><ul><li>  AAD和ADFS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">身份验证支持</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">注释</a> <code>service.beta.kubernetes.io/azure-pip-name</code>指定负载均衡器的公共IP； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">能够</a>配置<code>LoadBalancerName</code>和<code>LoadBalancerResourceGroup</code> 。 </li></ul></li><li>  AWS在Windows上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a> EBS，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优化了</a> EC2 API调用<code>DescribeInstances</code> 。 </li><li>  Kubeadm现在在升级到CoreDNS时自行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移其</a> CoreDNS配置。 </li><li> 相应的Docker映像中的二进制文件<b>etcd使其可以全局</b>执行，从而使您无需root特权即可运行该映像。 此外，etcd迁移映像已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">放弃</a>了对etcd2版本的支持。 </li><li>  <a href="">Cluster Autoscaler 1.16.0</a>切换为使用distroless作为基本映像，提高了性能，并添加了新的云提供程序（DigitalOcean，Magnum，Packet）。 </li><li> 使用过的/相关软件的更新：Go 1.12.9，etcd 3.3.15，CoreDNS 1.6.2。 </li></ul><br><h2> 聚苯乙烯 </h2><br> 另请参阅我们的博客： <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes 1.15：关键创新概述</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes 1.14：关键创新概述</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes 1.13：关键创新概述</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes 1.12：关键创新概述</a> 。” </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467477/">https://habr.com/ru/post/zh-CN467477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467463/index.html">仅仅进行除法运算，或如何创建数学理论并从中获得40万美元。 系列三，决赛</a></li>
<li><a href="../zh-CN467465/index.html">云将节省超预算的智能手机吗</a></li>
<li><a href="../zh-CN467471/index.html">针对无灵魂的ILV和同一个提供者的灵魂Mikrotik</a></li>
<li><a href="../zh-CN467473/index.html">关于排序的更多信息</a></li>
<li><a href="../zh-CN467475/index.html">将Thread.Abort（）返回.NET Core。 带有其版本的CoreCLR和CoreFX的应用程序交付</a></li>
<li><a href="../zh-CN467479/index.html">Kir Shatrov：Shopify从Rails开始，在这里他们真诚地喜欢这个框架。</a></li>
<li><a href="../zh-CN467485/index.html">使用pwnable.kr 23-MD5计算器解决问题。 我们处理Stack Canary。 在python中连接C库</a></li>
<li><a href="../zh-CN467487/index.html">关于区块链和加密货币支付的未来</a></li>
<li><a href="../zh-CN467489/index.html">它们是PHP中的奇怪静态变量</a></li>
<li><a href="../zh-CN467493/index.html">如何减少潜在的Internet攻击者的访问。 个人经验和观察</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>