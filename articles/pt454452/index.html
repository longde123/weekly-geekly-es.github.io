<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùáÔ∏è üö¢ üèõÔ∏è Exibimos conte√∫do na imagem reconhecida de acordo com certas regras ‚ôéÔ∏è üöô üßë‚Äçü§ù‚Äçüßë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Äs vezes, quando voc√™ l√™ uma tarefa t√©cnica e define prazos para implementa√ß√£o, subestime a quantidade de tempo e esfor√ßo gastos na solu√ß√£o de um prob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exibimos conte√∫do na imagem reconhecida de acordo com certas regras</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  √Äs vezes, quando voc√™ l√™ uma tarefa t√©cnica e define prazos para implementa√ß√£o, subestime a quantidade de tempo e esfor√ßo gastos na solu√ß√£o de um problema espec√≠fico.  Acontece que um ponto, calculado pelo tempo por semana, √© realizado em uma hora e, √†s vezes, vice-versa.  Mas este artigo n√£o √© sobre isso.  Esta √© uma demonstra√ß√£o da evolu√ß√£o de uma solu√ß√£o para um problema.  Desde o seu in√≠cio at√© a implementa√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br><h1 id="ispolzuemye-terminy">  Termos Utilizados </h1><br><ul><li><p>  Marca ou marcador - uma imagem carregada no mecanismo AR, reconhecida pela c√¢mera do dispositivo (tablet ou smartphone) e pode ser identificada exclusivamente </p><br></li><li><p>  Encontrado - estado do marcador quando foi detectado no campo de vis√£o da c√¢mera </p><br></li><li><p>  Perdido - estado do marcador quando foi perdido da visualiza√ß√£o da c√¢mera </p><br></li><li><p>  Ele pode ser exibido - quando o marcador √© encontrado, exibimos o conte√∫do anexado ao marcador </p><br></li><li><p>  N√£o pode ser exibido - quando encontramos o marcador, n√£o exibimos o conte√∫do - Conte√∫do anexado ao marcador - qualquer objeto (modelo 3D, sprite, sistema de part√≠culas etc.) que pode ser anexado ao marcador e que, consequentemente, ser√° exibido na tela se um marcador for encontrado </p><br></li><li><p>  Marca, marcador, encontrado, perdido - os estados b√°sicos inerentes a todos os mecanismos, oferecendo funcionalidade de reconhecimento </p><br></li><li><p>  Pode ser exibido e n√£o pode ser exibido - o estado usado para resolver este problema </p><br><p>  <strong>Um exemplo:</strong> </p><br><ul><li>  Fa√ßa o download do aplicativo =&gt; todas as marcas baixadas s√£o reconhec√≠veis </li><li>  Estamos tentando reconhecer =&gt; o estado do marcador muda para "encontrado" </li><li>  Se o marcador puder ser exibido =&gt; indique que o marcador foi ‚Äúencontrado‚Äù e exibimos o modelo anexado ao marcador </li><li>  Se o marcador n√£o puder ser exibido =&gt; o estado do marcador √© ‚Äúencontrado‚Äù, mas o modelo anexado n√£o √© exibido </li><li>  A marca desapareceu do campo de vis√£o da c√¢mera =&gt; mudamos o estado para "perdido" </li></ul><br></li></ul><br><h1 id="vvedenie">  1. Introdu√ß√£o </h1><br><p>  H√° um grande cart√£o postal do tamanho de uma folha A4.  √â dividido em 4 partes iguais (formato de uma parte A5), em cada uma dessas partes existe: </p><br><ul><li>  Uma marca de canto completa (1) </li><li>  Metade da marca do lado inferior (5) </li><li>  Metade da marca do lado superior (8) </li><li>  Marca de um quarto de centro (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="imagem"></p><br><p> Se voc√™ trabalhou com algum mecanismo de reconhecimento, por exemplo, o Vuforia, provavelmente sabe que n√£o existe "qualidade de reconhecimento".  A marca √© reconhecida ou n√£o.  Portanto, se o mecanismo "v√™" a marca, ele altera o estado para <code>Find</code> e o m√©todo <code>OnSuccess()</code> √© <code>OnSuccess()</code> ; se "o perdeu", o estado muda para <code>Lost</code> e o m√©todo <code>OnLost()</code> √© <code>OnLost()</code> .  Dessa forma, a partir das condi√ß√µes existentes e dos dados de entrada, surgiu uma situa√ß√£o ao ter uma parte do cart√£o (metade ou um quarto) poss√≠vel reconhecer a marca. </p><br><p>  O fato √© que, de acordo com a tarefa t√©cnica, um desbloqueio gradual dos personagens foi planejado.  Nessa situa√ß√£o, √© poss√≠vel um desbloqueio gradual, mas, como n√£o h√° pessoas que tentam reconhecer um quarto ou metade da marca. </p><br><h1 id="formulirovka-zadachi">  Declara√ß√£o de tarefa </h1><br><p>  √â necess√°rio implementar a l√≥gica na forma de c√≥digo do programa, o que garante o desbloqueio gradual do conte√∫do anexado aos marcadores.  A partir da localiza√ß√£o dos elementos no cart√£o, √© sabido que os marcadores 1, 2, 3, 4 est√£o dispon√≠veis para exibi√ß√£o inicialmente. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="imagem"></p><br><p>  Se o conte√∫do foi lido e exibido em 2 marcadores, por exemplo, 2 e 3, permitimos exibir o conte√∫do no marcador 6. Se o marcador 1 ainda n√£o foi lido, o acesso ao marcador 5 √© fechado.  Mais por analogia.  N√≥s meio que permitimos exibir o conte√∫do em marcadores laterais somente quando lemos marcadores de canto adjacentes. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="imagem"></p><br><p>  Se marcadores de 1 a 8 estiverem dispon√≠veis e forem encontrados, abra o conte√∫do no marcador 9. Para exibi√ß√£o, cada marcador possui 2 estados - o conte√∫do est√° dispon√≠vel e n√£o est√° dispon√≠vel para a exibi√ß√£o, pelo qual o campo <code>public bool IsActive;</code> √© respons√°vel <code>public bool IsActive;</code> </p><br><p>  Fica imediatamente claro que essa deve ser uma m√°quina de estados com uma transi√ß√£o entre estados ou uma implementa√ß√£o do padr√£o "Estado". </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  O resultado n√£o foi um, nem outro.  N√£o posso dizer que isso √© uma muleta porque a solu√ß√£o atendeu totalmente aos requisitos no come√ßo do artigo.  Mas voc√™ pode discutir comigo. </p></div></div><br><p>  Com isso, dou a oportunidade de pensar um pouco sobre poss√≠veis solu√ß√µes e implementa√ß√µes dessa tarefa.  Levei cerca de 5 horas para perceber e fixar na minha cabe√ßa a imagem da decis√£o. </p><br><p>  Para maior clareza, gravei um v√≠deo no qual o resultado final do algoritmo (se √© que voc√™ pode chamar assim) j√° est√° capturado. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Abordagens de solu√ß√£o </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Dos marcadores de canto ao centro </h2><br><p>  A primeira coisa que veio √† mente foi apresentar as intera√ß√µes entre os marcadores do canto ao centro.  Em forma gr√°fica, fica assim: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="imagem"></p><br><p>  Os problemas: </p><br><ol><li>  Como determinar qual r√≥tulo lateral deve mudar de estado?  O da esquerda ou da direita?  Tamb√©m for√ßamos cada marcador a "saber" sobre a exist√™ncia de um marcador central. </li><li>  √â necess√°rio adicionar depend√™ncias n√£o √≥bvias da categoria: o marcador lateral assina o evento de marcador de canto IsChangedEventCallback (), a√ß√µes semelhantes devem ser executadas para o marcador central. </li><li>  Se considerarmos cada tipo de marcador como uma entidade, na hierarquia dessas entidades encaminharemos o comando de mudan√ßa de estado de baixo para cima.  Isso n√£o √© muito bom, porque nos vinculamos firmemente ao n√∫mero, neste caso, marcadores angulares, perdendo a capacidade de escalar. </li></ol><br><p>  Incapaz de colocar a solu√ß√£o acima em minha mente por causa dos muitos casos extremos e da complexidade da percep√ß√£o, mudei a abordagem para escolher o marcador no qual as depend√™ncias come√ßam a se espalhar. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. As laterais sabem sobre central e canto </h2><br><p>  Pensando na solu√ß√£o do par√°grafo 3 da abordagem anterior, surgiu a id√©ia de mudar o tipo de marcador, a partir do qual os estados de outros marcadores come√ßam a mudar.  Como os principais marcadores laterais foram tomados.  Nesse cen√°rio, as comunica√ß√µes (depend√™ncias) ficam assim: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="imagem"></p><br><p>  A partir daqui, fica imediatamente claro que as conex√µes da lateral para a central s√£o sup√©rfluas, porque o marcador lateral n√£o precisa saber nada sobre o marcador central, portanto essa abordagem foi imediatamente transformada na final. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. O central sabe de todos, os laterais sabem da esquina </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="imagem"></p><br><p>  A solu√ß√£o final √© quando o marcador lateral conhece os cantos, os cantos ‚Äúvivem a vida‚Äù e o central sabe o estado de todos os marcadores. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="imagem"></p><br><p>  Trabalhar com a exibi√ß√£o de cart√£o postal n√£o √© muito conveniente.  Os relacionamentos entre entidades n√£o parecem claros o suficiente para converter isso facilmente em c√≥digo.  Uma tentativa de interpretar na forma de uma √°rvore bin√°ria pode introduzir alguma ambiguidade.  Mas aqui uma das propriedades da √°rvore bin√°ria √© violada, portanto a ambiguidade desaparece imediatamente.  A partir do qual podemos concluir que essa representa√ß√£o pode ser inequivocamente interpretada e usada para representar graficamente a solu√ß√£o para o problema.  Com base nessas conclus√µes, usaremos nota√ß√£o gr√°fica, a saber: </p><br><ul><li>  Marcador de √¢ngulo - N√≥ de √¢ngulo (n√≠vel 3) </li><li>  Marcador lateral - N√≥ lateral (n√≠vel 2) </li><li>  Marcador central - N√≥ central (n√≠vel 1) </li></ul><br><p>  Vantagens: </p><br><ol><li>  As depend√™ncias entre os marcadores s√£o √≥bvias e √≥bvias. </li><li>  Cada um dos n√≠veis pode ser representado na forma de 3 entidades, cada uma das quais consiste em partes b√°sicas, mas com suas adi√ß√µes inerentes a cada um dos n√≠veis. </li><li>  Para expandir, voc√™ s√≥ precisar√° adicionar um novo tipo de n√≥ com suas pr√≥prias caracter√≠sticas </li><li>  √â f√°cil imaginar esta solu√ß√£o em um estilo OO (orientado a objetos) </li></ol><br><h1 id="realizaciya">  Implementa√ß√£o </h1><br><h2 id="bazovye-suschnosti">  Entidades base </h2><br><p>  Vamos criar uma interface que contenha os elementos inerentes a cada entidade (nome, estado): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  A seguir, descrevemos a ess√™ncia de cada n√≥: </p><br><ul><li>  <strong>CornerNode</strong> - um n√≥ angular.  Basta implementar a interface <code>INode</code> : </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Por que <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text"><p>  A partir das condi√ß√µes do problema, o conte√∫do dos marcadores de canto est√° inicialmente dispon√≠vel para reconhecimento. </p></div></div><br><ul><li>  <strong>SideNode</strong> - um n√≥ lateral.  Implementamos a interface <code>LeftCornerNode</code> , mas adicionamos os <code>RightCornerNode</code> e <code>RightCornerNode</code> .  Assim, o n√≥ lateral mant√©m seu estado em si e sabe apenas sobre a exist√™ncia de n√≥s laterais. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> √© o n√≥ central.  Como nos anteriores, implementamos o <code>INode</code> .  Adicione um campo do tipo <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Classe Opencard </h2><br><h3 id="privatnye-metody-i-polya">  M√©todos e campos privados </h3><br><p>  Agora que criamos todos os elementos do cart√£o que criamos (todos os tipos de marcadores), podemos come√ßar a descrever a ess√™ncia do pr√≥prio cart√£o.  N√£o estou acostumado a iniciar uma classe com um construtor.  Eu sempre come√ßo com os m√©todos b√°sicos que s√£o inerentes a uma entidade espec√≠fica.  Vamos come√ßar com campos particulares e m√©todos particulares. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Com campos, tudo √© bem simples.  2 listas com n√≥s laterais angulares e um campo do n√≥ central. </p><br><p>  Em seguida, voc√™ precisa esclarecer um pouco.  O fato √© que o pr√≥prio marcador √© do tipo <code>Trackable</code> e n√£o tem id√©ia (e n√£o deveria ter) de que faz parte de outra l√≥gica l√°.  Portanto, tudo o que podemos usar para controlar a exibi√ß√£o √© o nome dele.  Portanto, se o marcador em si n√£o armazena o tipo de n√≥ ao qual ele pertence, devemos transferir essa responsabilidade para a nossa classe <code>OpenCard</code> .  Com base nisso, primeiro descrevemos tr√™s m√©todos particulares respons√°veis ‚Äã‚Äãpor determinar o tipo de n√≥. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Mas esses m√©todos n√£o fazem sentido para usar diretamente.  N√£o √© conveniente operar com valores booleanos quando voc√™ trabalha com objetos de outro n√≠vel de abstra√ß√£o.  Portanto, criaremos um <code>enum NodeType</code> simples <code>enum NodeType</code> e um m√©todo privado <code>GetNodeType()</code> , que encapsula em si toda a l√≥gica associada √† determina√ß√£o do tipo de n√≥. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  M√©todos p√∫blicos </h3><br><ul><li>  <code>IsExist</code> √© um m√©todo que retorna um valor booleano indicando se nossa marca pertence a um cart√£o postal.  Este √© um m√©todo auxiliar, feito para que, se o marcador n√£o pertencer a nenhum cart√£o, possamos exibir o conte√∫do nele. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - um m√©todo (como o nome indica) no qual verificamos o estado atual do n√≥ e alteramos seu estado. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Construtor </h3><br><p>  Quando todas as cartas estiverem sobre a mesa, podemos finalmente ir ao construtor.  Pode haver v√°rias abordagens para inicializa√ß√£o.  Mas eu decidi livrar a classe <code>OpenCard</code> de gestos desnecess√°rios, tanto quanto poss√≠vel.  Deve responder conosco se o conte√∫do est√° dispon√≠vel para exibi√ß√£o ou n√£o.  Portanto, simplesmente pedimos listas de entrada de n√≥s de 2 tipos e um n√≥ central. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Observe que, como o n√≥ central precisa apenas verificar a condi√ß√£o de todos os outros n√≥s <code>true</code> , basta <code>INode</code> implicitamente <code>INode</code> n√≥s central e angular que entraram no construtor no tipo <code>INode</code> . </p><br><h3 id="inicializaciya">  Inicializa√ß√£o </h3><br><p>  Qual √© a maneira mais conveniente de criar objetos que n√£o precisam ser anexados (como componentes <code>MonoBehaviour</code> ) a um GameObject?  - Certo, <code>ScriptableObject</code> .  Al√©m disso, por conveni√™ncia, adicione o atributo <code>MenuItem</code> , que simplificar√° a cria√ß√£o de novos cart√µes. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  O acorde final em nossa composi√ß√£o ser√° uma passagem pela matriz de <code>ScriptableObject</code> adicionados (se houver) e a cria√ß√£o de cart√µes postais a partir deles.  Depois disso, resta a n√≥s, no m√©todo <code>Update</code> , verificar simplesmente se podemos exibir o conte√∫do ou n√£o. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Conclus√µes </h1><br><p>  Para mim, pessoalmente, as conclus√µes foram as seguintes: </p><br><ol><li>  Ao tentar resolver um problema, voc√™ precisa quebrar seus elementos em partes at√¥micas.  Al√©m disso, considerando todas as op√ß√µes poss√≠veis para a intera√ß√£o entre essas partes at√¥micas, voc√™ precisa come√ßar com o objeto, do qual mais conex√µes potencialmente vir√£o.  De outra maneira, ele pode ser formulado da seguinte forma: esforce-se para come√ßar a resolver problemas com elementos que, potencialmente, ser√£o menos confi√°veis </li><li>  Se poss√≠vel, voc√™ deve tentar apresentar os dados de origem em um formato diferente.  No meu caso, a representa√ß√£o gr√°fica me ajudou muito. </li><li>  Cada entidade √© separada da outra pelo n√∫mero de conex√µes que poderiam vir dela. </li><li>  Muitas tarefas aplicadas que s√£o mais habituais de resolver escrevendo um algoritmo podem ser representadas no estilo OO </li><li>  Uma solu√ß√£o que possui depend√™ncias em anel √© uma solu√ß√£o ruim </li><li>  Se √© dif√≠cil manter todas as conex√µes entre objetos em sua cabe√ßa, esta √© uma m√° decis√£o </li><li>  Se voc√™ n√£o consegue ter em mente a l√≥gica da intera√ß√£o dos objetos - esta √© uma m√° decis√£o </li><li>  Suas muletas nem sempre s√£o uma m√° decis√£o </li></ol><br><p>  Voc√™ conhece outra solu√ß√£o?  - Escreva nos coment√°rios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454452/">https://habr.com/ru/post/pt454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454440/index.html">Petty Little Fun # 2: Estrelinha</a></li>
<li><a href="../pt454442/index.html">Como escolher uma rede proxy para o seu neg√≥cio: 3 dicas pr√°ticas</a></li>
<li><a href="../pt454444/index.html">N√≥s perfilamos o carregamento do Habr ou como 189 solicita√ß√µes na p√°gina tornam a influ√™ncia</a></li>
<li><a href="../pt454446/index.html">O que h√° de novo no C # 8?</a></li>
<li><a href="../pt454450/index.html">Como Edison inventou o wireless e n√£o entendeu nada</a></li>
<li><a href="../pt454456/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 7. FAQ</a></li>
<li><a href="../pt454458/index.html">Teste metam√≥rfico: por que quase ningu√©m sabe sobre essa t√©cnica promissora</a></li>
<li><a href="../pt454460/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 300 (27 de maio a 2 de junho)</a></li>
<li><a href="../pt454462/index.html">Fotograma sem papel fotogr√°fico</a></li>
<li><a href="../pt454464/index.html">Desenvolvimento de testes visuais baseados em Gemini e Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>