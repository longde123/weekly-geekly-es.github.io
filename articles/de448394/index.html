<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌁 👩🏽‍🏫 🛋️ Version 12 startet heute! (Und es ist ein großer Sprung für Wolfram Language und Mathematica) ♍️ 🚶🏾 🏎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quicklinks 
 - Der Weg zu Version 12 
 - Zuerst etwas Mathe 
 - Der Kalkül der Unsicherheit 
 - Klassische Mathematik, Grundstufe und Fortgeschrittene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Version 12 startet heute! (Und es ist ein großer Sprung für Wolfram Language und Mathematica)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/448394/"><hr><br><h2>  Quicklinks </h2><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Weg zu Version 12</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuerst etwas Mathe</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Kalkül der Unsicherheit</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassische Mathematik, Grundstufe und Fortgeschrittene</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr mit Polygonen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rechnen mit Polyedern</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euklidische Geometrie berechenbar gemacht</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit axiomatischen Theorien supersymbolisch werden</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das n-Körper-Problem</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spracherweiterungen und Annehmlichkeiten</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Superfunktionen für maschinelles Lernen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Neueste in Neuronalen Netzen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rechnen mit Bildern</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spracherkennung &amp; mehr mit Audio</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verarbeitung natürlicher Sprache</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computerchemie</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geografisches Rechnen erweitert</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Viele kleine Visualisierungsverbesserungen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbesserung der Integration der Wissensdatenbank</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration von Big Data aus externen Datenbanken</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RDF, SPARQL und all das</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Numerische Optimierung</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nichtlineare Finite-Elemente-Analyse</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuer, hoch entwickelter Compiler</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf von Python und anderen Sprachen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr für die Wolfram "Super Shell"</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marionetten eines Webbrowsers</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standalone-Mikrocontroller</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufrufen der Wolfram-Sprache von Python und anderen Orten aus</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbindung zum Einheitsuniversum</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simulierte Umgebungen für maschinelles Lernen</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blockchain- (und CryptoKitty-) Berechnung</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Und gewöhnliche Krypto auch</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herstellen einer Verbindung zu Finanzdaten-Feeds</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software Engineering &amp; Plattform-Updates</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Und noch viel mehr ...</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><a name="habracut"></a><br><h5>  16. April 2019 - Stephen Wolfram </h5><br><hr><a name="1"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Weg zu Version 12</a> </h2><br><br>  Heute veröffentlichen wir Version 12 von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Language</a> (und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathematica</a> ) auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Desktop-Plattformen</a> und in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Cloud</a> .  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 11.0 im August 2016</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11.1 im März 2017</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11.2 im September 2017</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11.3 im März 2018 veröffentlicht</a> .  Es ist ein großer Sprung von Version 11.3 auf Version 12.0.  Insgesamt gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">278 völlig neue Funktionen</a> in vielleicht 103 Bereichen sowie Tausende verschiedener Updates im gesamten System: <cut></cut><br><img src="https://habrastorage.org/getpro/habr/post_images/2e8/c69/e66/2e8c69e66869f0498b9c3681066e5f79.png" alt="Bild"><br><br>  In einer „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integer-Version</a> “ wie 12 ist es unser Ziel, vollständig ausgefüllte neue Funktionsbereiche bereitzustellen.  In jeder Veröffentlichung möchten wir aber auch die neuesten Ergebnisse unserer Forschungs- und Entwicklungsbemühungen liefern.  In 12.0 kann vielleicht die Hälfte unserer neuen Funktionen als Finishing-Bereiche betrachtet werden, die in früheren „.1“ -Versionen gestartet wurden - während die Hälfte neue Bereiche beginnt.  Ich werde beide Arten von Funktionen in diesem Artikel diskutieren, aber ich werde besonders die Besonderheiten der Neuerungen von 11.3 auf 12.0 hervorheben. <cut></cut><br><br>  Ich muss sagen, dass ich jetzt, da 12.0 fertig ist, erstaunt bin, wie viel darin enthalten ist und wie viel wir seit 11.3 hinzugefügt haben.  In meiner Keynote auf unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram-Technologiekonferenz im</a> vergangenen Oktober habe ich zusammengefasst, was wir bis zu diesem Zeitpunkt hatten - und selbst das dauerte fast 4 Stunden.  Jetzt gibt es noch mehr. <cut></cut><br><br>  Was wir konnten, ist ein Beweis sowohl für die Stärke unserer Forschungs- und Entwicklungsanstrengungen als auch für die Effektivität der Wolfram-Sprache als Entwicklungsumgebung.  Beide Dinge bauen sich natürlich seit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei Jahrzehnten auf</a> .  Neu bei 12.0 ist jedoch, dass wir die Leute unseren Designprozess hinter den Kulissen beobachten lassen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr als 300 Stunden meiner internen Design-Meetings</a> live übertragen.  Zusätzlich zu allem anderen vermute ich, dass dies Version 12.0 zum allerersten großen Software-Release in der Geschichte macht, das auf diese Weise geöffnet wurde. <cut></cut><br><br>  OK, was ist neu in 12.0?  Es gibt einige große und überraschende Dinge - insbesondere in Bezug auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chemie</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrie</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">numerische Unsicherheit</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbankintegration</a> .  Insgesamt gibt es jedoch viele Dinge in vielen Bereichen - und tatsächlich umfasst sogar die grundlegende Zusammenfassung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentationszentrum</a> bereits 19 Seiten: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/2fe/a90/6262fea90d53cb50464973cdf2ca553e.png" alt="Bild"><br><br><a name="2"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuerst etwas Mathe</a> </h2><br><br>  Obwohl heutzutage die überwiegende Mehrheit dessen, was die Wolfram-Sprache (und Mathematica) tut, nicht das ist, was normalerweise als Mathematik angesehen wird, setzen wir immer noch enorme Forschungs- und Entwicklungsanstrengungen ein, um die Grenzen dessen zu erweitern, was in Mathematik getan werden kann.  Und als erstes Beispiel für das, was wir in 12.0 hinzugefügt haben, ist hier der ziemlich farbenfrohe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ComplexPlot3D</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a9/c8a/ea6/1a9c8aea648bdff97ff36c2e9a1b85f0.png" alt="Bild"><br><br>  Es war immer möglich, Wolfram-Sprachcode zu schreiben, um Diagramme in der komplexen Ebene zu erstellen.  Aber erst jetzt haben wir die mathematischen und algorithmischen Probleme gelöst, die erforderlich sind, um den Prozess der robusten Darstellung selbst recht pathologischer Funktionen in der komplexen Ebene zu automatisieren. <br><br>  Ich erinnere mich, dass ich vor Jahren die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dilogarithmusfunktion</a> mit ihren Real- und Imaginärteilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sorgfältig aufgezeichnet habe</a> .  Jetzt macht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReImPlot es</a> einfach: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/a7e/839/99ea7e839bec41403001a3df0d9791c4.png" alt="Bild"><br><br>  Die Visualisierung komplexer Funktionen ist (Wortspiel beiseite) eine komplexe Geschichte, wobei Details einen großen Unterschied darin machen, was man über eine Funktion bemerkt.  Eines der Dinge, die wir in 12.0 getan haben, ist die Einführung sorgfältig ausgewählter standardisierter Methoden (z. B. benannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbfunktionen</a> ), um verschiedene Funktionen hervorzuheben: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a58/60e/f9fa5860e97af38616e4fd560e50e133.png" alt="Bild"><br><br><a name="3"></a><h2>  Der Kalkül der Unsicherheit </h2><br><br>  Messungen in der realen Welt weisen häufig Unsicherheiten auf, die als Werte mit ± Fehlern dargestellt werden.  Wir haben seit Ewigkeiten Add-On-Pakete für den Umgang mit „Zahlen mit Fehlern“.  Aber in Version 12.0 bauen wir Berechnungen mit Unsicherheit ein und machen es richtig. <br><br>  Der Schlüssel ist das symbolische Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> [ <b><i>x, δ</i></b> ], das einen Wert "um <i>x</i> " mit der Unsicherheit <i>δ darstellt</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/987/e57/9be/987e579be95c8038385caeb3c766faa9.png" alt="Bild"><br><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> können Sie rechnen, und es gibt eine ganze Rechnung darüber, wie sich die Unsicherheiten verbinden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ea/87b/023/5ea87b0239a365da00d1ff3619587bf6.png" alt="Bild"><br><br>  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> Zahlen zeichnen, werden diese mit Fehlerbalken angezeigt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c72/127/5fe/c721275fe91ac720eb52f69806471d18.png" alt="Bild"><br><br>  Es gibt viele Optionen - wie hier ist eine Möglichkeit, Unsicherheit sowohl in <i>x</i> als auch in <i>y</i> zu zeigen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b4/740/804/6b4740804b0137742c2b40b9b83f36d5.png" alt="Bild"><br><br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> Mengen haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87d/3ac/b72/87d3acb72e026dfe5fc87f2758bc18eb.png" alt="Bild"><br><br>  Und Sie können auch symbolische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around-</a> Objekte haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/658/d68/252/658d682523ad51f7825b9471ac275df3.png" alt="Bild"><br><br>  Aber was ist eigentlich ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around-</a> Objekt?  Hier gibt es bestimmte Regeln zum Kombinieren von Unsicherheiten, die auf unkorrelierten Normalverteilungen basieren.  Es wird jedoch keine Aussage getroffen, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> [ <b><i>x, δ</i></b> ] etwas darstellt, das tatsächlich im Detail einer Normalverteilung folgt - ebenso wenig wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> [ <b><i>x, δ</i></b> ] eine Zahl darstellt, die spezifisch in dem durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervall</a> [{ <b><i>x - δ, x + δ</i></b> }].  Es ist nur so, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around-</a> Objekte ihre Fehler oder Unsicherheiten nach einheitlichen allgemeinen Regeln verbreiten, die erfolgreich erfassen, was in der experimentellen Wissenschaft normalerweise getan wird. <cut></cut><br><br>  OK, nehmen wir an, Sie führen eine Reihe von Messungen mit einem bestimmten Wert durch.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MeanAround</a> können Sie eine Schätzung des Werts - zusammen mit seiner Unsicherheit - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erhalten</a> (und wenn die Messungen selbst Unsicherheiten aufweisen, werden diese bei der Gewichtung ihrer Beiträge berücksichtigt): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/57a/a6e/8f457aa6e06da5b6493c5dec5d68f0ba.png" alt="Bild"><br><br>  Funktionen im gesamten System - insbesondere beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">maschinellen Lernen</a> - haben ab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sofort</a> die Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ComputeUncertainty</a> -&gt; <b>True</b> , wodurch sie eher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around-</a> Objekte als reine Zahlen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeben</a> . <cut></cut><br><br>  Herum mag wie ein einfaches Konzept erscheinen, aber es ist voller Feinheiten - was der Hauptgrund ist, warum es bisher gebraucht wurde, um in das System zu gelangen.  Viele der Feinheiten drehen sich um Korrelationen zwischen Unsicherheiten.  Die Grundidee ist, dass die Unsicherheit jedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around-</a> Objekts als unabhängig angenommen wird.  Aber manchmal hat man Werte mit korrelierten Unsicherheiten - und so gibt es neben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VectorAround</a> , das einen Vektor potenziell korrelierter Werte mit einer bestimmten Kovarianzmatrix darstellt. <cut></cut><br><br>  Es ist noch subtiler, wenn man sich mit Dingen wie algebraischen Formeln befasst.  Wenn man hier x durch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around ersetzt</a> , wird nach den Regeln von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around angenommen</a> , dass jede Instanz nicht korreliert ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26f/11b/524/26f11b52481b9a43894a6e6139f721ae.png" alt="Bild"><br><br>  Aber wahrscheinlich möchte man hier annehmen, dass der Wert von x zwar ungewiss ist, aber für jede Instanz gleich ist, und man kann dies mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AroundReplace tun</a> (beachten Sie, dass das Ergebnis anders ist): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0d/d52/079/b0dd52079c1f882bd07bd4c2548d6f88.png" alt="Bild"><br><br>  Es ist sehr subtil, unsichere Zahlen anzuzeigen.  Wie viele nachgestellte Nullen sollten Sie eingeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f58/4b5/e58/f584b5e58b4425310eaf74001d22e666.png" alt="Bild"><br><br>  Oder wie genau die Unsicherheit der Unsicherheit sein sollte (es gibt einen herkömmlichen Haltepunkt, wenn die nachfolgenden Ziffern 35 sind): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ae/ba1/ab3/5aeba1ab3a1cb82aecef0916e914f8dc.png" alt="Bild"><br><br>  In seltenen Fällen, in denen viele Ziffern bekannt sind (z. B. einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">physikalische Konstanten</a> ), möchte man einen anderen Weg gehen, um die Unsicherheit zu spezifizieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/db5/9da/472db59da0302ecc2431e7c8763f856c.png" alt="Bild"><br><br>  Und es geht weiter und weiter.  Aber allmählich wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> im ganzen System auftauchen.  Übrigens gibt es viele andere Möglichkeiten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um</a> Zahlen anzugeben.  Dies ist eine Zahl mit einem relativen Fehler von 10%: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/20e/20e/25920e20e4b3e7d2d94c5c6217a0dc05.png" alt="Bild"><cut></cut><br><br>  Dies ist das Beste, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> tun kann, um ein Intervall darzustellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/594/b54/43b/594b5443bf4a687dce3bb7f97f8886fe.png" alt="Bild"><br><br>  Für eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verteilung</a> berechnet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Around</a> die Varianz: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25e/416/4b5/25e4164b5a291048ea53a6c0a4455f0f.png" alt="Bild"><br><br>  Es kann auch Asymmetrie berücksichtigen, indem asymmetrische Unsicherheiten angegeben werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de3/ee9/ffd/de3ee9ffd8924bce1da15f0c51382114.png" alt="Bild"><cut></cut><br><br><a name="4"></a><h2>  Klassische Mathematik, Grundstufe und Fortgeschrittene </h2><br><br>  Bei der Berechnung von Mathematik ist es immer eine Herausforderung, sowohl „alles richtig zu machen“ als auch elementare Benutzer nicht zu verwirren oder einzuschüchtern.  In Version 12.0 werden verschiedene Hilfestellungen vorgestellt.  Versuchen Sie zunächst, eine irreduzible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quintgleichung zu lösen</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3f/cf1/d97/b3fcf1d9770b4e9f02f2c7e46c5b7273.png" alt="Bild"><br><br>  In der Vergangenheit hätte dies eine Reihe expliziter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Root-</a> Objekte gezeigt.  Jetzt werden die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Root-</a> Objekte als Kästchen formatiert, in denen ihre ungefähren numerischen Werte angezeigt werden.  Berechnungen funktionieren genauso, aber das Display konfrontiert die Leute nicht sofort damit, über algebraische Zahlen Bescheid zu wissen. <br><br>  Wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integrieren</a> sagen, meinen wir „ein Integral finden“ im Sinne eines Antiderivativs.  Aber in der Elementarrechnung wollen die Leute explizite Integrationskonstanten sehen (wie immer in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram | Alpha</a> ), deshalb haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Option</a> dafür hinzugefügt (und C [ <i>n</i> ] hat auch eine schöne, neue Ausgabeform): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fef/c4b/9a9/fefc4b9a9329ed8fb3f1563e4fd6d689.png" alt="Bild"><cut></cut><br><br>  Wenn wir unsere symbolischen Integrationsfähigkeiten vergleichen, machen wir das wirklich gut.  Es kann jedoch immer mehr getan werden, insbesondere um die einfachsten Formen von Integralen zu finden (und auf theoretischer Ebene ist dies eine unvermeidliche Folge der Unentscheidbarkeit der Äquivalenz symbolischer Ausdrücke).  In Version 12.0 haben wir weiterhin an der Grenze gearbeitet und Fälle hinzugefügt wie: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/191/243/ecc/191243ecc750f0ecc26245903400708d.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/294/2ea/521/2942ea5212b75bd96ad2f87d96900713.png" alt="Bild"><br><br>  In Version 11.3 haben wir die asymptotische Analyse eingeführt, um asymptotische Werte von Integralen usw. zu finden.  Version 12.0 fügt asymptotische Summen, asymptotische Rezidive und asymptotische Lösungen zu Gleichungen hinzu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4e/067/eac/f4e067eaca0282bded7ee459a43ac671.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/a40/ae7/374/a40ae73749aa34e9e5592b81349424c9.png" alt="Bild"><br><br>  Eines der großartigen Dinge bei der Berechnung von Mathematik ist, dass es uns neue Möglichkeiten gibt, Mathematik selbst zu erklären.  Wir haben unsere Dokumentation so erweitert, dass sie sowohl die Mathematik als auch die Funktionen erklärt.  Hier ist zum Beispiel der Beginn der Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Limit</a> - mit Diagrammen und Beispielen der wichtigsten mathematischen Ideen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dca/3f8/553/dca3f8553b7e125ccd1652e0db7b42ea.png" alt="Bild"><br><br><a name="5"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr mit Polygonen</a> </h2><br><br>  Polygone sind seit Version 1 Teil der Wolfram-Sprache. In Version 12.0 werden sie jedoch verallgemeinert: Jetzt gibt es eine systematische Möglichkeit, Löcher in ihnen anzugeben.  Ein klassischer geografischer Anwendungsfall ist das Polygon für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Südafrika</a> - mit seinem Loch für das Land <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesotho</a> . <cut></cut><br><br>  In Version 12.0 erhält <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polygon</a> ähnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Root</a> ein praktisches neues Anzeigeformular: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25a/661/229/25a661229630a18e6774e8392256e80d.png" alt="Bild"><br><br>  Sie können damit wie zuvor rechnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/459/421/0e645942121e3640d6e94aee8d81c7da.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RandomPolygon</a> ist ebenfalls neu.  Sie können beispielsweise nach 5 zufälligen konvexen Polygonen mit jeweils 10 Eckpunkten in 3D fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/b13/97a/4afb1397ae458cbe6f65b4e60b4d0457.png" alt="Bild"><br><br>  Es gibt viele neue Operationen für Polygone.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PolygonDecomposition</a> , mit der beispielsweise ein Polygon in konvexe Teile zerlegt werden kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/355/6d6/d40/3556d6d4001a062fc7e69abcc9608ebc.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/b8c/45c/dc9b8c45c761c47a3f63c13e350a9308.png" alt="Bild"><br><br>  Polygone mit Löchern erfordern auch andere Arten von Operationen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">z.</a> B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OuterPolygon</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SimplePolygonQ</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CanonicalizePolygon</a> . <br><br><a name="6"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rechnen mit Polyedern</a> </h2><br><br>  Polygone sind ziemlich einfach anzugeben: Sie geben nur ihre Scheitelpunkte in der richtigen Reihenfolge an (und wenn sie Löcher haben, geben Sie auch die Scheitelpunkte für die Löcher an).  Polyeder sind etwas komplizierter: Zusätzlich zu den Scheitelpunkten müssen Sie angeben, wie diese Scheitelpunkte Flächen bilden.  In Version 12.0 können Sie dies mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyhedron</a> jedoch allgemein tun, einschließlich Hohlräumen (dem 3D-Analogon von Löchern) usw. <cut></cut><br><br>  In Version 12.0 werden jedoch Funktionen für die fünf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">platonischen Körper</a> eingeführt, die ihre über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2000-jährige Geschichte</a> erkennen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd4/2c7/46d/cd42c746d283d84f51475a5c4ce61056.png" alt="Bild"><br><br>  Und angesichts der platonischen Körper kann man sofort mit dem Rechnen beginnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f61/adf/030/f61adf030665d1250c1d6a6c1af50c99.png" alt="Bild"><br><br>  Hier ist der Raumwinkel am Scheitelpunkt 1 (da er platonisch ist, geben alle Scheitelpunkte den gleichen Winkel an): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00a/ecb/210/00aecb210b0a43e43f2cee1b7d931d72.png" alt="Bild"><br><br>  Hier ist eine Operation am Polyeder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5de/334/178/5de3341783cb1a1fa22f6b7dec19e38a.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/cf8/610/2db/cf86102db986e4b546033bb33143ad97.png" alt="Bild"><br><br>  Über die platonischen Körper hinaus baut Version 12 auch alle „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einheitlichen Polyeder</a> “ ein ( <i>n</i> Kanten und <i>m</i> Flächen treffen sich an jedem Scheitelpunkt) - und Sie können auch symbolische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyederversionen</a> benannter Polyeder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PolyhedronData erhalten</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/58a/d66/4e1/58ad664e151bd438534ef46fb8edad57.png" alt="Bild"><br><br>  Sie können jedes beliebige Polyeder (einschließlich eines „zufälligen“ mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RandomPolyhedron</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> und dann die gewünschten Berechnungen durchführen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/d03/c94/feed03c9478d56949ad87fb186bab070.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/7b2/e7a/ce6/7b2e7ace667a89b9073fc5ef2f2a0461.png" alt="Bild"><br><br><a name="7"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euklidische Geometrie berechenbar gemacht</a> </h2><br><br>  Mathematica und die Wolfram-Sprache sind sehr mächtig darin, sowohl explizite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rechengeometrie</a> als auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Bezug auf Algebra dargestellte Geometrie zu erstellen</a> .  Aber was ist mit der Geometrie, wie sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Euklids Elementen gemacht wird</a> - in der man geometrische Aussagen macht und dann sieht, was ihre Konsequenzen sind? <cut></cut><br><br>  Nun, in Version 12 können wir mit dem gesamten Turm der Technologie, den wir gebaut haben, endlich einen neuen Stil der mathematischen Berechnung liefern - der tatsächlich automatisiert, was Euclid vor über 2000 Jahren tat.  Eine Schlüsselidee besteht darin, symbolische „geometrische Szenen“ einzuführen, deren Symbole Konstrukte wie Punkte darstellen, und dann geometrische Objekte und Beziehungen in Bezug auf diese zu definieren. <br><br>  Hier ist zum Beispiel eine geometrische Szene, die ein Dreieck <i>a, b, c</i> und einen Kreis durch <i>a, b</i> und <i>c</i> mit dem Mittelpunkt <i>o darstellt</i> , mit der Einschränkung, dass <i>o</i> am Mittelpunkt der Linie von <i>a</i> nach <i>c liegt</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/445/016/c4c44501624329454f84cc8fb1ec777b.png" alt="Bild"><cut></cut><br><br>  Für sich genommen ist dies nur eine symbolische Sache.  Aber wir können Operationen daran durchführen.  Zum Beispiel können wir nach einer zufälligen Instanz fragen, in der <i>a, b, c</i> und <i>o</i> spezifisch gemacht werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e5/6ea/d91/5e56ead91bfa6c293c242bfd705e94c7.png" alt="Bild"><br><br>  Sie können so viele zufällige Instanzen generieren, wie Sie möchten.  Wir versuchen, die Instanzen so allgemein wie möglich zu gestalten, ohne Zufälle, die nicht durch die Einschränkungen erzwungen werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49b/b67/f03/49bb67f03b0b1092fea069b53e66dd4c.png" alt="Bild"><br><br>  OK, aber jetzt lass uns "Euklid spielen" und geometrische Vermutungen finden, die mit unserem Setup übereinstimmen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/8f6/9e8/b908f69e82fa1ab97a30fa1e84505996.png" alt="Bild"><br><br>  Für eine gegebene geometrische Szene kann es viele mögliche Vermutungen geben.  Wir versuchen die interessanten herauszusuchen.  In diesem Fall kommen wir auf zwei - und was dargestellt ist, ist die erste: dass die Linie ba senkrecht zur Linie cb ist.  Zufällig erscheint dieses Ergebnis tatsächlich in Euklid (es ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch 3 als Teil von Satz 31</a> ) - obwohl es normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thales 'Theorem genannt wird</a> . <br><br>  In 12.0 haben wir jetzt eine ganze symbolische Sprache zur Darstellung typischer Dinge, die in der Euklid-Geometrie vorkommen.  Hier ist eine komplexere Situation - entsprechend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Satz von Napoleon</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f05/c8c/104/f05c8c104fcdf99ea328c7560527b2d3.png" alt="Bild"><br><br>  In 12.0 gibt es viele neue und nützliche geometrische Funktionen, die mit expliziten Koordinaten arbeiten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e1/00e/54c/5e100e54c164ea8ebe779cdbc141a9b6.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/0d0/a6f/783/0d0a6f783c9ec6a93d1a923d57749b4b.png" alt="Bild"><br><br>  Für Dreiecke werden 12 Arten von "Zentren" unterstützt, und ja, es kann symbolische Koordinaten geben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1c/601/ccb/d1c601ccbaa16a760752448b7ba2ed62.png" alt="Bild"><br><br>  Und um das Einrichten geometrischer Aussagen zu unterstützen, benötigen wir auch „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geometrische Aussagen</a> “.  In 12.0 gibt es 29 verschiedene Arten - wie <b>"Parallel"</b> , <b>"Kongruent"</b> , <b>"Tangens"</b> , <b>"Konvex"</b> usw.  Hier sind drei Kreise, von denen behauptet wird, dass sie paarweise tangential sind: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/985/d70/c88985d70f115c1421ac8cc68263f4ae.png" alt="Bild"><cut></cut><br><br><a name="8"></a><h2>  Mit axiomatischen Theorien supersymbolisch werden </h2><br><br>  In Version 11.3 wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindEquationalProof</a> zum Generieren symbolischer Darstellungen von Beweisen eingeführt.  Aber welche Axiome sollten für diese Beweise verwendet werden?  In Version 12.0 wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AxiomaticTheory</a> eingeführt, die Axiome für verschiedene gängige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">axiomatische Theorien enthält</a> . <cut></cut><br><br>  Hier ist mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">persönliches Lieblingsaxiomensystem</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3ec/601/6b23ec60112b0cd0f9f0fc747502e2a3.png" alt="Bild"><br><br>  Was bedeutet das?  In gewisser Hinsicht ist es ein symbolischerer symbolischer Ausdruck als wir es gewohnt sind.  In so etwas wie 1 + <b>x</b> sagen wir nicht, was der Wert von <b>x</b> ist, aber wir stellen uns vor, dass es einen Wert haben kann.  Im obigen Ausdruck sind a, b und c reine „formale Symbole“, die eine im Wesentlichen strukturelle Rolle spielen und niemals als konkrete Werte angesehen werden können. <br><br>  Was ist mit dem · (Mittelpunkt)?  In 1 + <b>x</b> wissen wir, was + bedeutet.  Das · soll aber ein rein abstrakter Operator sein.  Der Punkt des Axioms besteht darin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, eine Einschränkung</a> für das zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">definieren,</a> was · darstellen kann.  In diesem speziellen Fall stellt sich heraus, dass das Axiom ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Axiom für die Boolesche Algebra ist</a> , so dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nand</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nor dargestellt werden können</a> .  Aber wir können die Konsequenzen des Axioms vollständig formal ableiten, zum Beispiel mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindEquationalProof</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/613/d7a/c1a613d7ab9276a8a8808d5ab66d5782.png" alt="Bild"><br><br>  In all dem steckt einiges an Subtilität.  Im obigen Beispiel ist es nützlich, · als Operator zu haben, nicht zuletzt, weil es gut angezeigt wird.  Aber es gibt keine eingebaute Bedeutung, und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AxiomaticTheory</a> können Sie als Operator etwas anderes (hier <b>f</b> ) angeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d9/719/69d/0d971969d2ea806acd7731a1cd05de0b.png" alt="Bild"><br><br>  Was macht der <b>"Nand"</b> dort?  Es ist ein Name für den Operator (aber er sollte nicht als etwas interpretiert werden, das mit dem Wert des Operators zu tun hat).  In den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Axiomen für die Gruppentheorie</a> erscheinen beispielsweise mehrere Operatoren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/730/14e/58e/73014e58e9294ca346a33100ff11029a.png" alt="Bild"><br><br>  Dies gibt die Standarddarstellungen der verschiedenen Operatoren hier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/a3d/13f/fdba3d13fdc809aec140f6d009636d73.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AxiomaticTheory</a> kennt bemerkenswerte Theoreme für bestimmte axiomatische Systeme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d85/307/a1cd85307f96a829e361eddba42b8b1f.png" alt="Bild"><br><br>  Die Grundidee formaler Symbole wurde in Version 7 eingeführt, um beispielsweise Dummy-Variablen in generierten Konstrukten wie diesen darzustellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcf/776/9be/dcf7769be4d3dbd84d6ffeeb2cefd47e.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/6bd/b1e/dd56bdb1e5f8b7228d7771fc330e3bbb.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/4ed/39e/d874ed39e82a38e789faad6f2707e09b.png" alt="Bild"><cut></cut><br><br>  Sie können ein formales Symbol mit <b>\ [FormalA]</b> oder Esc, a, Esc usw. <b>eingeben</b> .  Aber zurück in Version 7, <br>  <b>\ [FormalA]</b> wurde als gerendert.  Und das bedeutete, dass der obige Ausdruck so aussah: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/10f/c98/72f10fc989b21cccb6449320c1af21b4.png" alt="Bild"><br><br>  Ich fand das immer unglaublich kompliziert.  Und für Version 12 wollten wir es vereinfachen.  Wir haben viele Möglichkeiten ausprobiert, uns aber schließlich für einzelne graue Unterpunkte entschieden - was meiner Meinung nach viel besser aussieht. <br><br>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AxiomaticTheory</a> sind sowohl die Variablen als auch die Operatoren „rein symbolisch“.  Aber eine Sache, die definitiv ist, ist die Arität jedes Operators, die man <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AxiomaticTheory</a> fragen kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/288/2d5/2672882d54d51de715ffe6c0d624dfb7.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/760/11a/606/76011a6066fc20d5d24f4efd1a162643.png" alt="Bild"><br><br>  Praktischerweise kann die Darstellung von Operatoren und Aritäten sofort in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gruppierungen</a> eingespeist werden, um mögliche Ausdrücke mit bestimmten Variablen zu erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/920/134/0b5/9201340b5bcde61ed67e6992301850b1.png" alt="Bild"><cut></cut><br><br><a name="9"></a><h2>  Das <i>n-</i> Körper-Problem </h2><br><br>  Axiomatische Theorien stellen einen klassischen historischen Bereich für die Mathematik dar.  Ein weiteres klassisches historisches Gebiet - viel mehr auf der angewandten Seite - ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>n-</i> Körper-Problem</a> .  In Version 12.0 wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NBodySimulation</a> eingeführt, mit dem das n-Körper-Problem simuliert werden kann.  Hier ist ein Drei-Körper-Problem (denken Sie an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erde-Mond-Sonne</a> ) mit bestimmten Anfangsbedingungen (und dem Gesetz der inversen quadratischen Kraft): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/362/3da/d9f3623dafa645ab3bed5091d21d8cae.png" alt="Bild"><br><br>  Sie können nach verschiedenen Aspekten der Lösung fragen.  Dies zeigt die Positionen als Funktion der Zeit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/c04/d39/54bc04d39ddca678811b75f0b3914271.png" alt="Bild"><br><br>  Darunter werden nur Differentialgleichungen gelöst, aber - ähnlich wie bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemModel</a> - bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NBodySimulation</a> eine bequeme Möglichkeit, die Gleichungen einzurichten und ihre Lösungen zu handhaben.  Und ja, Standard-Kraftgesetze sind eingebaut, aber Sie können Ihre eigenen definieren. <br><br><a name="10"></a><h2>  Spracherweiterungen und Annehmlichkeiten </h2><br><br>  Wir polieren seit mehr als 30 Jahren den Kern der Wolfram-Sprache und führen in jeder nachfolgenden Version einige neue Erweiterungen und Annehmlichkeiten ein. <br><br>  Wir haben die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Information</a> seit Version 1.0, aber in 12.0 haben wir sie stark erweitert.  Früher gab es nur Informationen zu Symbolen (obwohl diese ebenfalls modernisiert wurden): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34f/bbc/fd3/34fbbcfd359d9ade3c08c1ca3a0e10df.png" alt="Bild"><br><br>  Jetzt gibt es aber auch Informationen über viele Arten von Objekten.  Hier sind Informationen zu einem Klassifikator: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/461/475/cf7/461475cf72622b2c8420ff7892cb3d5a.png" alt="Bild"><br><br>  Hier sind Informationen zu einem Cloud-Objekt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/467/983/f34/467983f34a490152baf5694191fa8521.png" alt="Bild"><br><br>  Bewegen Sie den Mauszeiger über die Beschriftungen im „Informationsfeld“ und Sie können die Namen der entsprechenden Eigenschaften herausfinden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75c/6b4/5ae/75c6b45ae4e6df0e30acd246ba3a54bc.png" alt="Bild"><br><br>  Für Entitäten gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Information</a> eine Zusammenfassung bekannter Eigenschaftswerte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/635/cbb/4a5/635cbb4a55316f1cfa16f17ee5e38317.png" alt="Bild"><br><br>  In den letzten Versionen haben wir viele neue Formulare für die Anzeige von Zusammenfassungen eingeführt.  In Version 11.3 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iconize</a> eingeführt, mit dem im Wesentlichen ein zusammenfassendes Anzeigeformular für alles erstellt werden kann.  Iconize hat sich als noch nützlicher erwiesen, als wir ursprünglich erwartet hatten.  Es ist großartig, um unnötige Komplexität sowohl in Notizbüchern als auch in Teilen des Wolfram-Sprachcodes zu verbergen.  In 12.0 haben wir die Anzeige von Iconize neu gestaltet, insbesondere, damit sie in Ausdrücken und Code „gut gelesen“ werden kann. <br><br>  Sie können etwas explizit symbolisieren: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/725/95b/5b072595b693946d4892dae18e39bdc8.png" alt="Bild"><br><br>  Drücken Sie das + und Sie sehen einige Details: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/c08/a0a/6c9c08a0a6c58f5ccf381fa7c0dd62ee.png" alt="Bild"><br><br>  Drücken Sie <img src="https://habrastorage.org/getpro/habr/post_images/e2d/fae/9c2/e2dfae9c2087bb311e8de301b1b3bf2b.png" alt="Bild">  und Sie erhalten wieder den ursprünglichen Ausdruck: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/53b/fba/74353bfbaa9cd3e488e2ba06ec844c3d.png" alt="Bild"><br><br>  Wenn Sie viele Daten haben, auf die Sie in einer Berechnung verweisen möchten, können Sie diese jederzeit in einer Datei oder in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud</a> (oder sogar in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenrepository</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichern</a> .  In der Regel ist es jedoch bequemer, es einfach in Ihr Notizbuch zu legen, damit Sie alles am selben Ort haben.  Eine Möglichkeit, die Daten zu vermeiden, die Ihr Notebook übernehmen, besteht darin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie in geschlossene Zellen</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">legen</a> .  Iconize bietet jedoch eine viel flexiblere und elegantere Möglichkeit, dies zu tun. <cut></cut><br><br>  Wenn Sie Code schreiben, ist es oft praktisch, „an Ort und Stelle zu symbolisieren“.  Mit dem Kontextmenü können Sie jetzt Folgendes tun: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc3/6d1/419/bc36d14196f62400be648f39102d4c0e.png" alt="Bild"><br><br>  Apropos Anzeige, hier ist etwas Kleines, aber Praktisches, das wir in 12.0 hinzugefügt haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d4e/0fb/f93/d4e0fbf930c62473e9e65acfbf7613c6.png" alt="Bild"><br><br>  Und hier sind ein paar andere "Zahlen-Annehmlichkeiten", die wir hinzugefügt haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca1/cdd/83d/ca1cdd83d14c1bc395ad30ae4c0c272b.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/12d/516/d6012d516a4e0c77ea4bccce3ff65572.png" alt="Bild"><br><br>  Funktionale Programmierung war schon immer ein zentraler Bestandteil der Wolfram-Sprache.  Wir sind jedoch ständig bemüht, es zu erweitern und neue, allgemein nützliche Grundelemente einzuführen.  Ein Beispiel in Version 12.0 ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SubsetMap</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dbf/b62/579/dbfb62579374722db514bb08da3a7df3.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/c62/cba/0ad/c62cba0ad9c5b4a96f09a8478c2bb1ff.png" alt="Bild"><br><br>  Funktionen sind normalerweise Dinge, die mehrere Eingaben annehmen können, aber immer eine einzige Ausgabe liefern.  In Bereichen wie dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quantencomputer</a> ist man jedoch daran interessiert, <b><i>n</i></b> Ein- und <b><i>n</i></b> Ausgänge zu haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SubsetMap</a> implementiert effektiv <b><i>n-&gt; n</i></b> Funktionen, nimmt Eingaben von <b><i>n</i></b> angegebenen Positionen in einer Liste auf, wendet eine Operation auf diese an und setzt die Ergebnisse an denselben <b><i>n</i></b> Positionen zurück. <cut></cut><br><br>  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe vor</a> ungefähr einem Jahr angefangen zu formulieren, was jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SubsetMap</a> ist.  Und mir wurde schnell klar, dass ich diese Funktion im Laufe der Jahre tatsächlich an allen möglichen Orten hätte nutzen können.  Aber wie soll dieser besondere „Klumpen Rechenarbeit“ genannt werden?  Mein ursprünglicher Arbeitsname war <b>ArrayReplaceFunction</b> (den ich in meinen Notizen auf <b>ARF</b> abgekürzt habe).  In einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folge von (Livestream-) Meetings</a> gingen wir hin und her.  Es gab Ideen wie <b>ApplyAt</b> (aber es ist nicht wirklich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apply</a> ) und <b>MutateAt</b> (aber es macht keine Mutation im lvalue-Sinne) sowie <b>RewriteAt</b> , <b>ReplaceAt</b> , <b>MultipartApply</b> und <b>ConstructInPlace</b> .  Es gab Ideen zu Curry-Formularen für „Funktionsdekorateure“ wie <b>PartAppliedFunction</b> , <b>PartwiseFunction</b> , <b>AppliedOnto</b> , <b>AppliedAcross</b> und <b>MultipartCurry</b> . <cut></cut><br><br>  Aber irgendwie, als wir die Funktion erklärten, kamen wir immer wieder darauf zurück, darüber zu sprechen, wie sie auf einer Teilmenge einer Liste funktioniert und wie sie wirklich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Map ist</a> , außer dass sie auf mehreren Elementen gleichzeitig funktioniert.  Also haben wir uns endlich für den Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SubsetMap entschieden</a> .  Und - in einer weiteren Bestätigung der Bedeutung des Sprachdesigns - ist es bemerkenswert, wie man, sobald man einen Namen für so etwas hat, sofort in der Lage ist, darüber nachzudenken und zu sehen, wo es verwendet werden kann. <cut></cut><br><br><a name="11"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Superfunktionen für maschinelles Lernen</a> </h2><br><br>  Seit vielen Jahren arbeiten wir hart daran, die Wolfram-Sprache zum höchsten und automatisiertesten System für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">maschinelles Lernen</a> auf dem neuesten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stand der Technik zu machen</a> .  Schon früh haben wir die „Superfunktionen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassifizieren</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorhersagen eingeführt</a> , die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassifizierungs-</a> und Vorhersageaufgaben vollständig automatisiert ausführen und automatisch den besten Ansatz für die jeweilige Eingabe auswählen.  Auf dem Weg haben wir andere Superfunktionen eingeführt - wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SequencePredict</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ActiveClassification</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FeatureExtract</a> . <cut></cut><br><br>  In Version 12.0 haben wir einige wichtige neue Superfunktionen für maschinelles Lernen.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindAnomalies</a> , die "anomale Elemente" in Daten finden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e9/842/0f8/4e98420f8f21287739edd2c50a40780b.png" alt="Bild"><br><br>  Zusammen mit diesem gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DeleteAnomalies</a> , das Elemente löscht, die es für anomal hält: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/113/d75/659113d751f1ba6aa282932934798d34.png" alt="Bild"><br><br>  Es gibt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SynthesizeMissingValues</a> , die versuchen, plausible Werte für fehlende Daten zu generieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c7/63a/706/9c763a7063ed27d225a26691ba2c5b03.png" alt="Bild"><br><br>  Wie funktionieren diese Funktionen?  Sie basieren alle auf einer neuen Funktion namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LearnDistribution</a> , die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anhand</a> einer Reihe von Beispielen versucht, die zugrunde liegende Verteilung von Daten zu lernen.  Wenn die Beispiele nur Zahlen wären, wäre dies im Wesentlichen ein Standardstatistikproblem, für das wir so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EstimatedDistribution verwenden</a> könnten.  Der Punkt bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LearnDistribution</a> ist jedoch, dass es mit Daten jeglicher Art funktioniert, nicht nur mit Zahlen.  Hier lernt es eine zugrunde liegende Verteilung für eine Sammlung von Farben: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/27d/b6b/c7327db6baf384bbd60138052aebf9c4.png" alt="Bild"><br><br>  Sobald wir diese „gelernte Verteilung“ haben, können wir alle möglichen Dinge damit machen.  Dies generiert beispielsweise 20 Zufallsstichproben daraus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/d6f/d52/9f3d6fd526a5e04950ad9967d2be2ed4.png" alt="Bild"><br><br>  Aber denken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> jetzt an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindAnomalies</a> .  Es muss herausgefunden werden, welche Datenpunkte im Verhältnis zu den erwarteten Daten anomal sind.  Mit anderen Worten, angesichts der zugrunde liegenden Verteilung der Daten wird ermittelt, welche Datenpunkte Ausreißer sind, in dem Sinne, dass sie gemäß der Verteilung nur mit sehr geringer Wahrscheinlichkeit auftreten sollten. <br><br>  Und genau wie bei einer normalen numerischen Verteilung können wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF</a> für ein bestimmtes Datenelement berechnen.  Lila ist angesichts der Verteilung der Farben, die wir aus unseren Beispielen gelernt haben, ziemlich wahrscheinlich: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/dd2/7ba/5cedd27ba152fe7ca464496a4d0e337f.png" alt="Bild"><br><br>  Aber Rot ist wirklich sehr, sehr unwahrscheinlich: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/661/1cf/b1d/6611cfb1d1904561634aa0e2c6c2fb3c.png" alt="Bild"><br><br>  Für gewöhnliche numerische Verteilungen gibt es Konzepte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CDF</a> , die uns kumulative Wahrscheinlichkeiten mitteilen, dass wir Ergebnisse erhalten, die „weiter entfernt“ als ein bestimmter Wert sind.  Für Räume willkürlicher Dinge gibt es nicht wirklich den Begriff „weiter draußen“.  Wir haben uns jedoch eine Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgedacht</a> , die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RarerProbability</a> nennen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie gibt an</a> , wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hoch</a> die Gesamtwahrscheinlichkeit ist, ein Beispiel mit einer kleineren PDF-Datei als der von uns angegebenen zu generieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cea/1c9/f85/cea1c9f851a749bc7ab94ac98564a880.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/553/936/867/5539368677118fe2a426e54ea90fe15b.png" alt="Bild"><br><br>  Jetzt haben wir eine Möglichkeit, Anomalien zu beschreiben: Es handelt sich nur um Datenpunkte mit einer sehr geringen Wahrscheinlichkeit.  Tatsächlich verfügt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindAnomalies</a> über eine Option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AcceptanceThreshold</a> (mit dem Standardwert 0,001), die angibt, was als "sehr klein" gelten soll. <br><br>  OK, aber sehen wir uns diese Arbeit an etwas Komplizierterem als Farben an.  Lassen Sie uns einen Anomaliedetektor anhand von 1000 Beispielen handgeschriebener Ziffern trainieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/be6/4ab/932be64abd36ee01f8e3ee3d0d6b8221.png" alt="Bild"><cut></cut><br><br>  Jetzt können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindAnomalies</a> uns sagen, welche Beispiele anomal sind: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/70f/82c/1a870f82c6f931dafe8fc0e2b8b927f8.png" alt="Bild"><br><br><a name="12"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Neueste in Neuronalen Netzen</a> </h2><br><br>  Wir haben bereits 2016 als Teil von Version 11 unser symbolisches Framework für den Aufbau, die Erforschung und Verwendung neuronaler Netze eingeführt. Seitdem haben wir in jeder Version alle möglichen Funktionen auf dem neuesten Stand der Technik hinzugefügt.  Im Juni 2018 haben wir unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuronales Netz-Repository eingeführt</a> , um den Zugriff auf die neuesten neuronalen Netzmodelle aus der Wolfram-Sprache zu vereinfachen. Es befinden sich bereits fast 100 kuratierte Modelle verschiedener Typen im Repository, wobei ständig neue hinzugefügt werden. <cut></cut><br><br>  Wenn Sie also das neueste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuronale BERT-Transformator-Netzwerk</a> benötigen (das heute hinzugefügt wurde!), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Können</a> Sie es von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetModel beziehen</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/5be/7c9/4445be7c9d0067b2a1361107e73bcfcb.png" alt="Bild"><br><br>  Sie können dies öffnen und das betroffene Netzwerk anzeigen (und ja, wir haben die Anzeige der Netzdiagramme für Version 12.0 aktualisiert): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04a/661/15c/04a66115c8f1e1cb2b77e16c49456f19.png" alt="Bild"><br><br>  Und Sie können das Netzwerk sofort verwenden, um eine Art "Bedeutungsmerkmale" -Array zu erstellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f56/ac7/57a/f56ac757a4a507a3400a7e0c501a3ba0.png" alt="Bild"><br><br>  In Version 12.0 haben wir mehrere neue Layertypen eingeführt - insbesondere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AttentionLayer</a> , mit dem die neuesten "Transformator" -Architekturen eingerichtet werden können - und wir haben unsere Funktionen zur "funktionalen Programmierung neuronaler Netze" mit Dingen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetMapThreadOperator</a> und mehreren Sequenzen erweitert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetFoldOperator</a> .  Zusätzlich zu diesen Verbesserungen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internet</a> werden in Version 12.0 alle möglichen neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetEncoder-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetDecoder-</a> Fälle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> , z. B. die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BPE-Tokenisierung</a> für Text in Hunderten von Sprachen und die Möglichkeit, benutzerdefinierte Funktionen zum Ein- und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auslesen</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzuschließen</a> neuronale Netze. <cut></cut><br><br>  Einige der wichtigsten Verbesserungen in Version 12.0 sind jedoch infrastruktureller.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetTrain</a> unterstützt jetzt das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Training mit mehreren GPUs</a> sowie den Umgang mit Arithmetik mit gemischter Genauigkeit und flexiblen Kriterien für das frühzeitige Stoppen.  Wir verwenden weiterhin das beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MXNet-</a> Low-Level-Framework für neuronale Netze (zu dem wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">maßgeblich beigetragen haben</a> ), damit wir die neuesten Hardwareoptimierungen nutzen können.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Optionen,</a> um zu sehen, was während des Trainings passiert, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetMeasurements</a> , mit denen Sie 33 verschiedene Arten von Messungen zur Leistung eines Netzwerks durchführen können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/293/411/6fe/2934116fefa0ced9f0d4eb2809b61db1.png" alt="Bild"><br><br>  Neuronale Netze sind nicht die einzige oder sogar immer die beste Möglichkeit, maschinelles Lernen zu betreiben.  Neu in Version 12.0 ist jedoch, dass wir jetzt in der Lage sind, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">selbst normalisierende Netzwerke</a> automatisch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Classify</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Predict zu verwenden</a> , sodass sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuronale Netze</a> problemlos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nutzen können,</a> wenn dies sinnvoll ist. <cut></cut><br><br><a name="13"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rechnen mit Bildern</a> </h2><br><br>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageIdentify</a> bereits in Version 10.1 eingeführt, um festzustellen, woraus ein Bild besteht.  In Version 12.0 ist es uns gelungen, dies zu verallgemeinern, um nicht nur herauszufinden, woraus ein Bild besteht, sondern auch, was in einem Bild enthalten ist.  So zeigt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageCases</a> beispielsweise Fälle bekannter Arten von Objekten in einem Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/699/38b/07d/69938b07d4f5d23796dd282807e3de8b.png" alt="Bild"><br><br>  Für weitere Details gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageContents</a> einen Datensatz darüber an, was in einem Bild enthalten ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce0/7ac/df7/ce07acdf74f8aa8eee69228e739f0aea.png" alt="Bild"><br><br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageCases anweisen</a> , nach einer bestimmten Art von Dingen zu suchen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e84/271/b83/e84271b83fa44fd7bf939f549276e256.png" alt="Bild"><br><br>  Sie können auch einfach testen, ob ein Bild eine bestimmte Art von Dingen enthält: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/546/558/90e54655834a9b06ad1812f4ae7f39a5.png" alt="Bild"><br><br>  In gewisser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weise</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageCases</a> wie eine verallgemeinerte Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindFaces</a> , um menschliche Gesichter in einem Bild zu finden.  Neu in Version 12.0 ist, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindFaces</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FacialFeatures</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">effizienter und robuster geworden sind.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindFaces</a> basieren jetzt eher auf neuronalen Netzen als auf klassischer Bildverarbeitung, und das Netzwerk für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FacialFeatures ist</a> jetzt 10 MB statt 500 MB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">groß</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/3a4/9ca/0b83a49caa8ac1adaeb5dfcf21b44168.png" alt="Bild"><br><br>  Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageCases</a> stellen eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildverarbeitung im</a> „neuen Stil“ dar, wie sie vor einigen Jahren noch nicht denkbar schien.  Während solche Funktionen alle möglichen neuen Dinge ermöglichen, sind klassische Techniken immer noch von großem Wert.  Wir haben lange Zeit eine ziemlich vollständige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klassische Bildverarbeitung</a> in der Wolfram-Sprache, aber wir nehmen weiterhin inkrementelle Verbesserungen vor. <br><br>  Ein Beispiel in Version 12.0 ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImagePyramid-</a> Framework für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrskalige</a> Bildverarbeitung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/111/d22/e88/111d22e88f581c029ffb99a0e5834fba.png" alt="Bild"><br><br>  In Version 12.0 gibt es mehrere neue Funktionen, die sich mit der Farbberechnung befassen.  Eine Schlüsselidee ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ColorsNear</a> , das eine Nachbarschaft im wahrnehmbaren Farbraum darstellt, hier um die Farbe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pink</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45d/58e/576/45d58e57625e51287bb250e08bf3b5b0.png" alt="Bild"><br><br>  Der Begriff der Farbnachbarschaften kann beispielsweise in der neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageRecolor-</a> Funktion verwendet werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/f79/bd4/940f79bd4758f23e1ad64ea2ee4ecfa1.png" alt="Bild"><br><br><a name="14"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spracherkennung &amp; mehr mit Audio</a> </h2><cut></cut><br><br>  Während ich an meinem Computer sitze und dies schreibe, sage ich etwas zu meinem Computer und nehme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es auf</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5a/3ef/aa1/d5a3efaa106b59e92e75535d1d62485f.png" alt="Bild"><br><br>  Hier ist ein Spektrogramm des von mir aufgenommenen Audios: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/f1f/98f/b78f1f98fc9eaeccd42d6ec659f932e4.png" alt="Bild"><br><br>  Bisher konnten wir dies in Version 11.3 tun (obwohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spectrogram</a> in 12.0 zehnmal schneller wurde).  Aber jetzt ist hier etwas Neues: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c08/f75/d85/c08f75d85e312beab3df8faac86fb0a6.png" alt="Bild"><br><br>  Wir machen Rede-zu-Text!  Wir verwenden modernste neuronale Netztechnologie, aber ich bin erstaunt, wie gut sie funktioniert.  Es ist ziemlich rationalisiert und wir sind perfekt in der Lage, auch sehr lange Audiostücke zu verarbeiten, die beispielsweise in Dateien gespeichert sind.  Und auf einem typischen Computer läuft die Transkription ungefähr in Echtzeit, so dass eine Stunde Redezeit ungefähr eine Stunde dauert, um sie zu transkribieren. <br><br>  Im Moment betrachten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speech Recognize als</a> experimentell und werden es weiter verbessern.  Es ist jedoch interessant zu sehen, dass eine weitere wichtige Rechenaufgabe in der Wolfram-Sprache zu einer einzigen Funktion wird. <br><br>  In Version 12.0 gibt es noch weitere Verbesserungen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpeechSynthesize</a> unterstützt neue Sprachen und neue Stimmen (wie von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VoiceStyleData</a> [] aufgeführt). <br><br>  Es gibt jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAudioSearch -</a> analog zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebImageSearch</a> -, mit dem Sie im Web nach Audio suchen können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/42a/f34/be542af34f29ede4b252d3e1b6ed53f1.png" alt="Bild"><br><br>  Sie können aktuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Audioobjekte</a> abrufen: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/93b/ace/d35/93baced35a76090293277dcbd1db4380.png" alt="Bild"><br><br>  Dann können Sie Spektrogramme oder andere Messungen durchführen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/b8b/fe1/b70b8bfe1a81411f3bcc5575e2877844.png" alt="Bild"><br><br>  Und dann - neu in Version 12.0 - können Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AudioIdentify</a> versuchen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klangkategorie</a> zu identifizieren (ist das ein sprechender Hahn?): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/411/906/a52/411906a5253e31363c191f7c8724b02b.png" alt="Bild"><br><br>  Wir betrachten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AudioIdentify</a> weiterhin als experimentell.  Es ist ein interessanter Start, aber er funktioniert zum Beispiel definitiv nicht so gut wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageIdentify</a> . <br><br>  Eine erfolgreichere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Audiofunktion</a> ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PitchRecognize</a> , die versucht, die dominante Frequenz in einem Audiosignal zu erkennen (es werden sowohl „klassische“ als auch neuronale Netzmethoden verwendet).  Es kann noch nicht mit "Akkorden" umgehen, aber es funktioniert ziemlich perfekt für "einzelne Noten". <br><br>  Wenn man sich mit Audio befasst, möchte man oft nicht nur identifizieren, was im Audio enthalten ist, sondern es auch kommentieren.  Mit Version 12.0 wird der Beginn eines umfangreichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Audio-Frameworks eingeführt</a> .  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moment</a> kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AudioAnnotate</a> markieren, wo Stille herrscht oder wo etwas Lautes ist.  In Zukunft werden wir Sprecheridentifikation, Wortgrenzen und vieles mehr hinzufügen.  Dazu haben wir auch Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AudioAnnotationLookup</a> , mit denen Sie Teile eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Audioobjekts auswählen können</a> , die auf bestimmte Weise mit Anmerkungen versehen wurden. <br><br>  Unter all diesen High-Level-Audiofunktionen befindet sich eine ganze Infrastruktur für die Low-Level-Audioverarbeitung.  Version 12.0 verbessert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AudioBlockMap erheblich</a> (zum Anwenden von Filtern auf Audiosignale) und führt Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ShortTimeFourier ein</a> . <cut></cut><br><br>  Ein Spektrogramm kann ein bisschen wie ein kontinuierliches Analogon einer Partitur betrachtet werden, in der Tonhöhen als Funktion der Zeit aufgetragen sind.  In Version 12.0 gibt es jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InverseSpectrogram -</a> das geht von einem Array von Spektrogrammdaten zu Audio.  Seit Version 2 im Jahr 1991 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Play</a> , um Sound aus einer Funktion (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sin</a> [100 t]) zu erzeugen.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inverse Spectrogram haben</a> wir jetzt die Möglichkeit, von einer „Frequenz-Zeit-Bitmap“ zu einem Sound zu gelangen.  (Und ja, es gibt knifflige Probleme mit den besten Vermutungen für Phasen, in denen nur Größeninformationen vorliegen.) <cut></cut><br><br><a name="15"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verarbeitung natürlicher Sprache</a> </h2><cut></cut><br><br>  Beginnend mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram | Alpha</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfügen</a> wir seit langem über außergewöhnlich starke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NLU-Fähigkeiten (Natural Language Understanding)</a> .  Und das bedeutet, dass wir bei einem Stück natürlicher Sprache gut darin sind, es als Wolfram-Sprache zu verstehen - aus der wir dann rechnen können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/aa2/d3a/22faa2d3a207aaf6fdd5cd47a8408640.png" alt="Bild"><br><br>  Aber was ist mit der Verarbeitung natürlicher Sprache (NLP)? Wo nehmen wir möglicherweise lange Passagen natürlicher Sprache und versuchen nicht, sie vollständig zu verstehen, sondern nur bestimmte Merkmale zu finden oder zu verarbeiten?  Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextSentences</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextStructure</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextCases</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WordCounts</a> bieten uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seit</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einiger Zeit</a> grundlegende Funktionen in diesem Bereich.  In Version 12.0 haben wir uns jedoch durch die Nutzung des neuesten maschinellen Lernens sowie unserer langjährigen NLU- und Knowledgebase-Funktionen zu sehr starken NLP-Funktionen entwickelt. <br><br>  Das Herzstück ist die dramatisch verbesserte Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextCases</a> .  Das grundlegende Ziel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextCases</a> ist es, Fälle verschiedener Arten von Inhalten in einem Textstück zu finden.  Ein Beispiel hierfür ist die klassische NLP-Aufgabe der „Entitätserkennung“, bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextCases</a> hier herausfinden, welche Ländernamen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia-Artikel über Ozelots erscheinen</a> : <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/e70/de1/16fe70de1d0a16db3941c075a71ba6ef.png" alt="Bild"><br><br>  Wir könnten auch fragen, welche Inseln erwähnt werden, aber jetzt werden wir nicht nach einer Interpretation der Wolfram-Sprache fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/068/852/db4/068852db45ddb0d8cfe071bb93206131.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TextCases</a> ist nicht perfekt, aber es funktioniert ziemlich gut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/7d5/2ee/b457d52ee71f23cbae86e1fda3230241.png" alt="Bild"><br><br>  Es werden auch viele verschiedene Inhaltstypen unterstützt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/127/634/7aa1276342f4271c4575980535e966aa.png" alt="Bild"><br><br>  Sie können ihn bitten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pronomen oder reduzierte Relativsätze</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mengen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">E-Mail-Adressen</a> oder Vorkommen von 150 Arten von Entitäten (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unternehmen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pflanzen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Filmen</a> ) zu finden.  Sie können ihn auch bitten, Textteile auszuwählen, die in bestimmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">menschlichen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computersprachen</a> verfasst sind oder sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf bestimmte Themen</a> (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reisen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesundheit</a> ) beziehen oder die eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">positive oder negative Stimmung haben</a> .  Und Sie können Konstrukte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Containing verwenden</a> , um nach Kombinationen dieser Dinge zu fragen (wie Nominalphrasen, die den Namen eines Flusses enthalten): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/f16/dff/c24f16dffd2f160822ef44d45733d946.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit TextContents</a> können Sie beispielsweise Details aller Entitäten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzeigen</a> , die in einem bestimmten Textstück erkannt wurden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c09/d94/ed6/c09d94ed63c55e9761600051bbf45025.png" alt="Bild"><br><br>  Und ja, man kann diese Funktionen im Prinzip über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindTextualAnswer nutzen</a> , um Fragen aus dem Text zu beantworten - aber in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solchen</a> Fall können die Ergebnisse ziemlich verrückt sein: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/bda/47c/dd2bda47c4bffa6d8e0fcfaeb257cc3e.png" alt="Bild"><br><br>  Natürlich können Sie eine echte Antwort aus unserer tatsächlich integrierten kuratierten Wissensdatenbank erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/8b1/037/5a58b1037a1d329f6682310bbe1432db.png" alt="Bild"><br><br>  Übrigens haben wir in Version 12.0 eine Reihe kleiner „Funktionen zur Bequemlichkeit natürlicher Sprache“ hinzugefügt, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synonyme</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Antonyme</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d03/6eb/33e/d036eb33e224c13fe5142b9fcdd6e0f9.png" alt="Bild"><cut></cut><br><br><a name="16"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computerchemie</a> </h2><cut></cut><br><br>  Einer der „überraschenden“ neuen Bereiche in Version 12.0 ist die Computerchemie.  Wir haben seit langer Zeit Daten zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">explizit bekannten Chemikalien</a> in unserer Wissensdatenbank.  In Version 12.0 können wir jedoch mit Molekülen rechnen, die einfach als reine symbolische Objekte angegeben werden.  So können wir spezifizieren, was sich als Wassermolekül herausstellt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe5/f2f/8a3/fe5f2f8a3b35defcd268f3cb29dac95b.png" alt="Bild"><br><br>  Und so können wir ein 3D-Rendering erstellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/389/9f6/5fb/3899f65fb0c9925debf42fdcb706b265.png" alt="Bild"><br><br>  Wir können mit „bekannten Chemikalien“ umgehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/12f/519/51d12f519a629dc2569824a94276cefd.png" alt="Bild"><br><br>  Wir können beliebige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IUPAC-</a> Namen verwenden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f7/616/2eb/3f76162eb9b84381c315f3079f3ff781.png" alt="Bild"><br><br>  Oder wir „erfinden“ Chemikalien, indem wir sie beispielsweise durch ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMILES-</a> Zeichenfolgen spezifizieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e69/d4f/9a7/e69d4f9a7483fec38f34ddb95a4ddf81.png" alt="Bild"><br><br>  Wir erzeugen hier aber nicht nur Bilder.  Wir können auch Dinge aus der Struktur berechnen - wie Symmetrien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff5/e48/752/ff5e487522c4ff085124985e35b2d48c.png" alt="Bild"><br><br>  Wenn ein Molekül gegeben ist, können wir beispielsweise Kohlenstoff-Sauerstoff-Bindungen hervorheben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58f/52d/2be/58f52d2be24dfb02f7b3f0b8d8a1ea01.png" alt="Bild"><br><br>  Oder markieren Sie Strukturen, beispielsweise angegeben durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMARTS-</a> Zeichenfolgen (hier ein beliebiger 5- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gliedriger</a> Ring): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cc/101/286/0cc10128672716f58dd1244e6fd9e5bc.png" alt="Bild"><br><br>  Sie können auch nach „Molekülmustern“ suchen.  Die Ergebnisse werden in Form von Atomzahlen angegeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ee/d62/f89/0eed62f8900cd8abb5102d85f3643f2b.png" alt="Bild"><br><br>  Die Funktionen für Computerchemie, die wir in Version 12.0 hinzugefügt haben, sind ziemlich allgemein und ziemlich leistungsfähig (mit der Einschränkung, dass sie sich bisher nur mit organischen Molekülen befassen).  Auf der untersten Ebene betrachten sie Moleküle als markierte Graphen mit Kanten, die Bindungen entsprechen.  Sie kennen sich aber auch mit Physik aus und berücksichtigen atomare Valenzen und Bindungskonfigurationen korrekt.  Es ist unnötig zu erwähnen, dass es viele Details gibt (über Stereochemie, Symmetrie, Aromatizität, Isotope usw.).  Das Endergebnis ist jedoch, dass die molekulare Struktur und die molekulare Berechnung nun erfolgreich in die Liste der Bereiche aufgenommen wurden, die in die Wolfram-Sprache integriert sind. <cut></cut><br><br><a name="17"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geographic Computing erweitert</a> </h2><cut></cut><br><br>  Die Wolfram-Sprache verfügt bereits über starke Funktionen für das geografische Rechnen, aber Version 12.0 fügt weitere Funktionen hinzu und erweitert einige der bereits vorhandenen. <br><br>  Zum Beispiel gibt es jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RandomGeoPosition</a> , die eine zufällige lat-lange Position generiert.  Man könnte denken, dass dies trivial wäre, aber natürlich muss man sich um Koordinatentransformationen sorgen - und was es viel trivialer macht, ist, dass man ihm sagen kann, dass er nur innerhalb einer bestimmten Region, hier des Landes Frankreich, Punkte auswählen soll: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ca/0e0/b8c/4ca0e0b8c6ea3d558b1135c9faad4f92.png" alt="Bild"><br><br>  Ein Thema der neuen geografischen Funktionen in Version 12.0 ist die Behandlung nicht nur geografischer Punkte und Regionen, sondern auch geografischer Vektoren.  Hier ist der aktuelle Windvektor zum Beispiel an der Position des Eiffelturms, dargestellt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoVector</a> , mit Geschwindigkeit und Richtung (es gibt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoVectorENU</a> , das Ost-, Nord- und Aufwärtskomponenten sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoGridVector</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoVectorXYZ enthält</a> ): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd8/ecc/292/dd8ecc292eca49b7d615bf97383f0b69.png" alt="Bild"><br><br>  Mit Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoGraphics können</a> Sie diskrete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geovektoren</a> visualisieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoStreamPlot</a> ist das Geo-Analogon von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamPlot</a> (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ListStreamPlot</a> ) und zeigt Stromlinien, die aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geovektoren</a> (hier aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WindDirectionData</a> ) gebildet wurden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/574/bc5/2ec574bc5058ebe3a6683a1fc37ddfde.png" alt="Bild"><br><br>  Geodäsie ist ein mathematisch anspruchsvolles Gebiet, und wir sind stolz darauf, es in der Wolfram-Sprache gut zu machen.  In Version 12.0 haben wir einige neue Funktionen hinzugefügt, um einige Details zu ergänzen.  Zum Beispiel haben wir jetzt Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoGridUnitDistance</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GeoGridUnitArea,</a> die die Verzerrung (im Grunde Eigenwerte des Jacobi) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeben</a> , die mit verschiedenen Geoprojektionen an jeder Position auf der Erde (oder Mond, Mars usw.) verbunden ist. <cut></cut><br><br><a name="18"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Viele kleine Visualisierungsverbesserungen</a> </h2><cut></cut><br><br>  Eine Richtung der Visualisierung, die wir ständig weiterentwickelt haben, ist das, was man als „Metagrafiken“ bezeichnen könnte: das Beschriften und Kommentieren grafischer Dinge.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Callout</a> in Version 11.0 eingeführt.  In Version 12.0 wurde es auf Dinge wie 3D-Grafiken erweitert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4a/3ed/f61/a4a3edf6114585c46f0d2ee21e26bc27.png" alt="Bild"><br><br>  Es ist ziemlich gut herauszufinden, wo Dinge zu beschriften sind, auch wenn sie etwas komplex werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/2f8/e88/2ec2f8e886cb6b03de54e7bd6656136d.png" alt="Bild"><br><br>  Es gibt viele Details, die wichtig sind, damit Grafiken wirklich gut aussehen.  In Version 12.0 wurde verbessert, dass Grafikspalten unabhängig von der Länge der Tick-Beschriftungen in ihren Frames ausgerichtet sind.  Wir haben auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LabelVisibility</a> hinzugefügt, mit dem Sie die relativen Prioritäten festlegen können, mit denen verschiedene Beschriftungen sichtbar gemacht werden sollen. <br><br>  Eine weitere neue Funktion von Version 12.0 ist das Multipanel-Plot-Layout, bei dem verschiedene Datensätze in verschiedenen Bedienfeldern angezeigt werden. Die Bedienfelder teilen sich jedoch Achsen, wann immer sie können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b3/e39/327/8b3e3932775f9af0311ed9ed60dbe99b.png" alt="Bild"><br><br><a name="19"></a><h2>  Verbesserung der Integration der Wissensdatenbank </h2><cut></cut><br><br>  Unsere kuratierte Wissensdatenbank, die beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram | Alpha</a> antreibt, ist riesig und wächst kontinuierlich.  Und mit jeder Version der Wolfram-Sprache verstärken wir schrittweise ihre Integration in den Kern der Sprache. <br><br>  In Version 12.0 besteht eine Sache darin, Hunderte von Entitätstypen direkt in der Sprache verfügbar zu machen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/734/28c/54c73428c169ffdfcd343779d7626b23.png" alt="Bild"><br><br>  Vor Version 12.0 dienten die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram | Alpha-Beispielseiten</a> als Proxy für die Dokumentation vieler Arten von Entitäten.  Aber jetzt gibt es für alle eine Wolfram Language-Dokumentation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d4a/dd2/3cad4add27d7ccff27dd59e3447c2622.png" alt="Bild"><br><br>  Es gibt immer noch Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SatelliteData</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WeatherData</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FinancialData</a> , die Entitätstypen verarbeiten, die routinemäßig eine komplexe Auswahl oder Berechnung erfordern.  In Version 12.0 kann jedoch auf jeden Entitätstyp auf dieselbe Weise zugegriffen werden, mit Eingaben in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">natürlicher Sprache</a> („Steuerelement + =“) und Entitäten und Eigenschaften mit gelbem Kästchen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8be/f48/d21/8bef48d211fff1a08d21345e7d254005.png" alt="Bild"><br><br>  Übrigens kann man auch implizit Entitäten verwenden, wie hier nach den 5 Elementen mit den höchsten bekannten Schmelzpunkten fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3e/ef0/efa/d3eef0efa20040b8399756699d9b4347.png" alt="Bild"><br><br>  Und man kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dated verwenden</a> , um eine Zeitreihe von Werten zu erhalten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/126/ff8/c91126ff895cfeb581bfca5122ec5307.png" alt="Bild"><br><br><a name="20"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration von Big Data aus externen Datenbanken</a> </h2><cut></cut><br><br>  Wir haben es sehr bequem gemacht, mit Daten zu arbeiten, die in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Knowledgebase integriert sind</a> .  Sie haben Entitäten, und es ist sehr einfach, nach Eigenschaften usw. zu fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/d3d/e20/3dfd3de207b039a6967c85ad2c521258.png" alt="Bild"><br><br>  Aber was ist, wenn Sie Ihre eigenen Daten haben?  Können Sie es so einrichten, dass Sie es so einfach verwenden können?  Eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wichtige Neuerung in Version 11</a> war das Hinzufügen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityStore</a> , in dem man <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigene Entitätstypen definieren</a> und dann Entitäten, Eigenschaften und Werte angeben kann. <cut></cut><br><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Data Repository</a> enthält eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Beispielen für Entitätsspeicher</a> .  Hier ist einer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/405/694/99540569492a7cfffdbbaeb369350a16.png" alt="Bild"><br><br>  Es beschreibt einen einzelnen Entitätstyp: ein <b>"SWLibraryBook"</b> .  Um Entitäten dieses Typs genau wie integrierte Entitäten verwenden zu können, "registrieren" wir den Entitätsspeicher: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adb/4b4/484/adb4b44849ef8a9bd812f3ba4fcaf02b.png" alt="Bild"><br><br>  Jetzt können wir beispielsweise nach 10 zufälligen Entitäten vom Typ <b>"SWLibraryBook" fragen</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87f/450/569/87f450569780bd52dbdeb4232a53a3fa.png" alt="Bild"><br><br>  Jede Entität im Entitätsspeicher verfügt über verschiedene Eigenschaften.  Hier ist ein Datensatz mit den Werten von Eigenschaften für eine bestimmte Entität: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bd/75a/678/0bd75a678383e5a960cf54cc9fb082ba.png" alt="Bild"><br><br>  OK, aber mit diesem Setup lesen wir im Grunde den gesamten Inhalt eines Entitätsspeichers in den Speicher.  Dies macht es sehr effizient, alle gewünschten Wolfram-Sprachoperationen durchzuführen.  Es ist jedoch keine gute skalierbare Lösung für große Datenmengen - zum Beispiel Daten, die zu groß sind, um in den Speicher zu passen. <br><br>  Aber was ist eine typische Quelle für große Datenmengen?  Sehr oft handelt es sich um eine Datenbank und normalerweise um eine relationale Datenbank, auf die über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL</a> zugegriffen werden kann.  Wir haben unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DatabaseLink-Paket</a> für Lese- und Schreibzugriff auf SQL-Datenbanken auf niedriger Ebene seit mehr als einem Jahrzehnt.  In Version 12.0 fügen wir jedoch einige wichtige integrierte Funktionen hinzu, mit denen externe relationale Datenbanken in der Wolfram-Sprache genauso behandelt werden können wie Entity Stores oder integrierte Teile der Wolfram Knowledgebase. <cut></cut><br><br>  Beginnen wir mit einem Spielzeugbeispiel.  Hier ist eine symbolische Darstellung einer kleinen relationalen Datenbank, die zufällig in einer Datei gespeichert ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/019/ffa/52e019ffa9d662ab70188bf0405301e5.png" alt="Bild"><br><br>  Sofort erhalten wir eine Box, die zusammenfasst, was sich in der Datenbank befindet, und uns mitteilt, dass diese Datenbank 8 Tabellen enthält.  Wenn wir die Box öffnen, können wir mit der Überprüfung der Struktur dieser Tabellen beginnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/122/56e/06312256e8f9bc1176607d93cf25cc85.png" alt="Bild"><br><br>  Wir können diese relationale Datenbank dann als Entitätsspeicher in der Wolfram-Sprache einrichten.  Es sieht sehr ähnlich aus wie der oben genannte Bibliotheksbuch-Entitätsspeicher, aber jetzt werden die tatsächlichen Daten nicht in den Speicher gezogen.  Stattdessen befindet es sich immer noch in der externen relationalen Datenbank, und wir definieren lediglich eine ("ORM-ähnliche") Zuordnung zu Entitäten in der Wolfram-Sprache: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/e63/4e2/8b1e634e224e6a4934be1587c7717e0f.png" alt="Bild"><br><br>  Jetzt können wir diesen Entitätsspeicher registrieren, der eine Reihe von Entitätstypen einrichtet, die (zumindest standardmäßig) nach den Namen der Tabellen in der Datenbank benannt sind: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/edd/866/084/edd866084fe3db87ec50356b8939bdba.png" alt="Bild"><br><br>  Und jetzt können wir "Entitätsberechnungen" für diese durchführen, genau wie für integrierte Entitäten in der Wolfram Knowledgebase.  Jede Entität entspricht hier einer Zeile in der Tabelle "Mitarbeiter" in der Datenbank: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/36c/44e/c7536c44e7a0dcf9d6a836284ecaa295.png" alt="Bild"><br><br>  Für einen bestimmten Entitätstyp können wir fragen, welche Eigenschaften er hat.  Diese "Eigenschaften" entsprechen Spalten in der Tabelle in der zugrunde liegenden Datenbank: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/425/18a/9ba/42518a9ba7ce936ddeb9b0fec02b8956.png" alt="Bild"><br><br>  Jetzt können wir nach dem Wert einer bestimmten Eigenschaft einer bestimmten Entität fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/675/28e/30c/67528e30c68a14d89c4d3c37a55d8c26.png" alt="Bild"><br><br>  Wir können Entitäten auch anhand von Kriterien auswählen.  Hier fragen wir nach "Zahlungs" -Entitäten mit den 4 größten Werten der "Betrag" -Eigenschaft: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/abd/283/0a3abd28351670f7e077e8f9be802971.png" alt="Bild"><br><br>  Wir können gleichermaßen nach den Werten dieser größten Beträge fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/000/14e/080/00014e080a7f3b00cad21997ae4e0ed0.png" alt="Bild"><br><br>  OK, aber hier wird es interessanter: Bisher haben wir uns eine kleine dateibasierte Datenbank angesehen.  Mit einer riesigen Datenbank, die auf einem externen Server gehostet wird, können wir genau das Gleiche tun. <br><br>  Stellen Sie als Beispiel eine Verbindung zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenStreetMap PostgreSQL-Datenbank</a> in Terabyte-Größe her, die im Grunde die Straßenkarte der Welt enthält: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/f93/cf1/e98f93cf15f73f6dc8b6ef4ba1fefaa5.png" alt="Bild"><br><br>  Registrieren wir nach wie vor die Tabellen in dieser Datenbank als Entitätstypen.  Wie bei den meisten In-the-Wild-Datenbanken gibt es kleine Störungen in der Struktur, die umgangen werden, aber Warnungen generieren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76a/e5b/d1a/76ae5bd1a8f15d5e82c197edcd165758.png" alt="Bild"><br><br>  Aber jetzt können wir Fragen zur Datenbank stellen - wie viele Geopunkte oder „Knoten“ es auf allen Straßen der Welt gibt (und ja, es ist eine große Zahl, weshalb die Datenbank groß ist): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f0/ab8/d84/7f0ab8d842816bf203f34902d776ef31.png" alt="Bild"><br><br>  Hier fragen wir nach den Namen der Objekte mit den 10 größten (projizierten) Bereichen in der Tabelle (101 GB) planet_osm_polygon (und ja, es dauert weniger als eine Sekunde): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa8/64c/9a8/aa864c9a824695d9103d343179e7055b.png" alt="Bild"><br><br>  Wie funktioniert das alles?  Grundsätzlich geschieht, dass unsere Wolfram Language-Darstellung in SQL-Abfragen auf niedriger Ebene kompiliert wird, die dann gesendet werden, um direkt auf dem Datenbankserver ausgeführt zu werden. <br><br>  Manchmal werden Sie nach Ergebnissen fragen, die nur Endwerte sind (wie zum Beispiel die oben genannten „Beträge“).  In anderen Fällen möchten Sie jedoch etwas Zwischenprodukt - wie eine Sammlung von Entitäten, die auf eine bestimmte Weise ausgewählt wurden.  Und natürlich könnte diese Sammlung eine Milliarde Einträge haben.  Ein sehr wichtiges Merkmal der Einführung in Version 12.0 ist daher, dass wir solche Dinge rein symbolisch darstellen und manipulieren können und sie erst am Ende in etwas Bestimmtes auflösen können. <cut></cut><br><br>  Zurück zu unserer Spielzeugdatenbank: Hier ein Beispiel, wie wir eine Klasse von Entitäten angeben, die durch Aggregation des gesamten <b>creditLimit</b> für alle <b>Kunden</b> mit einem bestimmten Wert des <b>Landes erhalten werden</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80c/be6/df1/80cbe6df161ed110a92ad09404f8f8cd.png" alt="Bild"><br><br>  Das ist zunächst nur etwas Symbolisches.  Wenn wir jedoch nach bestimmten Werten fragen, werden die tatsächlichen Datenbankabfragen durchgeführt und wir erhalten bestimmte Ergebnisse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5c5/b20/74b5c5b20962af159309c5283f5efc32.png" alt="Bild"><br><br>  Es gibt eine Reihe neuer Funktionen zum Einrichten verschiedener Arten von Abfragen.  Die Funktionen funktionieren nicht nur für relationale Datenbanken, sondern auch für Entitätsspeicher und für die integrierte Wolfram Knowledgebase.  So können wir beispielsweise im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Periodensystem der Elemente</a> nach der durchschnittlichen Atommasse für einen bestimmten Zeitraum fragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/311/f49/7c0311f49157522cb68a2216c59445d4.png" alt="Bild"><br><br>  Ein wichtiges neues Konstrukt ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityFunction</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityFunction</a> ähnelt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function</a> , mit der Ausnahme, dass seine Variablen Entitäten (oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entitätsklassen</a> ) darstellen und Vorgänge beschreiben, die direkt in externen Datenbanken ausgeführt werden können.  Hier ist ein Beispiel mit integrierten Daten, in dem wir eine "gefilterte" Entitätsklasse definieren, in der das Filterkriterium eine Funktion ist, die Populationswerte testet.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FilteredEntityClass</a> selbst wird nur symbolisch dargestellt, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityList</a> führt die Abfrage tatsächlich aus und löst eine explizite Liste von (hier unsortierten) Entitäten auf: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/2f9/1d7/d322f91d70935e233936a6259b290c82.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/254/5e7/d9d/2545e7d9d2fbae039e939b399afa29d1.png" alt="Bild"><br><br>  Zusätzlich zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityFunction</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AggregatedEntityClass</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SortedEntityClass enthält</a> Version 12.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SampledEntityClass</a> (um einige Entitäten aus einer Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abzurufen</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExtendedEntityClass</a> (um berechnete Eigenschaften hinzuzufügen) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CombinedEntityClass</a> (um Eigenschaften aus verschiedenen Klassen zu kombinieren).  Mit diesen Grundelementen kann man alle Standardoperationen der „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">relationalen Algebra</a> “ aufbauen. <br><br>  Bei der Standard-Datenbankprogrammierung endet man normalerweise mit einem ganzen Dschungel von "Joins" und "Fremdschlüsseln" und so weiter.  Mit unserer Wolfram Language-Darstellung können Sie auf einer höheren Ebene arbeiten - wobei Verknüpfungen im Grunde genommen zur Funktionszusammensetzung werden und Fremdschlüssel nur unterschiedliche Entitätstypen sind.  (Wenn Sie jedoch explizite Verknüpfungen durchführen möchten, können Sie dies beispielsweise mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CombinedEntityClass</a> tun.) <cut></cut><br><br>  Unter der Haube geht es darum, dass all diese Wolfram Language-Konstrukte in SQL kompiliert werden, genauer gesagt in den spezifischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL-</a> Dialekt, der für die von Ihnen verwendete Datenbank geeignet ist (wir unterstützen derzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQLite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MySQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostgreSQL</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MS) -SQL</a> , mit Unterstützung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OracleSQL in</a> Kürze).  Wenn wir die Kompilierung durchführen, überprüfen wir automatisch die Typen, um sicherzustellen, dass Sie eine aussagekräftige Abfrage erhalten.  Selbst relativ einfache Wolfram-Sprachspezifikationen können sich in viele SQL-Zeilen verwandeln.  Zum Beispiel <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12b/9eb/a16/12b9eba16ea5e3901b91f4c8c415eaca.png" alt="Bild"><br><br>  würde das folgende Zwischen-SQL erzeugen (hier zum Abfragen der SQLite-Datenbank): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad4/1c0/54c/ad41c054c0fcb315cbeb189e6cd37595.png" alt="Bild"><br><br>  Das Datenbankintegrationssystem in Version 12.0 ist ziemlich ausgefeilt - und wir arbeiten seit einigen Jahren daran.  Dies ist ein wichtiger Schritt vorwärts, damit die Wolfram-Sprache direkt mit einem neuen Grad an „Größe“ in Big Data umgehen kann - und die Wolfram-Sprache direkt Datenwissenschaft für Datensätze mit Terabyte-Größe und darüber hinaus durchführen kann.  Als würde man herausfinden, welche straßenähnlichen Wesen auf der Welt „Wolfram“ in ihrem Namen haben: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ad/6d7/772/0ad6d77728e8b4ea3b50aa2d19755533.png" alt="Bild"><br><br><a name="21"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RDF, SPARQL und all das</a> </h2><cut></cut><br><br>  Was ist der beste Weg, um Wissen über die Welt darzustellen?  Es ist ein Thema, das seit der Antike von Philosophen (und anderen) diskutiert wurde.  Manchmal sagten die Leute, Logik sei der Schlüssel.  Manchmal Mathematik.  Manchmal relationale Datenbanken.  Aber jetzt kennen wir mindestens eine solide Grundlage (oder zumindest bin ich mir ziemlich sicher): Alles kann durch Berechnung dargestellt werden.  Dies ist eine überzeugende Idee - und in gewissem Sinne macht dies alles möglich, was wir mit Wolfram Language tun. <br><br>  Aber gibt es Teilmengen allgemeiner Berechnungen, die nützlich sind, um zumindest bestimmte Arten von Wissen darzustellen?  Eine, die wir in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Knowledgebase häufig verwenden,</a> ist der Begriff der Entitäten ("New York City"), Immobilien ("Bevölkerung") und ihrer Werte ("8,6 Millionen Menschen").  Natürlich repräsentieren solche Tripel nicht alles Wissen in der Welt („Wie wird die Position des Mars morgen sein?“).  Aber sie sind ein guter Anfang, wenn es um bestimmte Arten von „statischem“ Wissen über bestimmte Dinge geht. <cut></cut><br><br>  Wie kann man diese Art der Wissensrepräsentation formalisieren?  Eine Antwort sind Graphendatenbanken.  Und in Version 12.0 unterstützen wir - in Übereinstimmung mit vielen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Semantic Web“</a> -Projekten - Graphendatenbanken mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RDF</a> und Abfragen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPARQL</a> .  In RDF ist das zentrale Objekt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IRI</a> („Internationalized Resource Identifier“), die eine Entität oder eine Eigenschaft darstellen kann.  Ein " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Triplestore</a> " besteht dann aus einer Sammlung von Tripeln ("Subjekt", "Prädikat", "Objekt"), wobei jedes Element in jedem Tripel ein IRI (oder ein Literal wie eine Zahl) ist.  Das gesamte Objekt kann dann als Graphendatenbank oder Graphspeicher oder mathematisch als Hypergraph betrachtet werden.  (Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hypergraph,</a> da das Prädikat "Kanten" auch an anderer Stelle Scheitelpunkte sein kann.) <br><br>  Sie können Ihren eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RDFStore</a> ähnlich wie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityStore erstellen</a> - und tatsächlich können Sie jeden Wolfram Language <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityStore</a> mit SPARQL abfragen, genau wie Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RDFStore</a> abfragen.  Und da der Entity-Property-Teil der Wolfram Knowledgebase als Entity-Store behandelt werden kann, können Sie dies auch abfragen.  Hier ist also endlich ein Beispiel.  Die Länder-Stadt-Liste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entität</a> [" <b>Land</b> "], <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entität</a> [" <b>Stadt</b> "]} repräsentiert tatsächlich einen RDF-Speicher.  Dann ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPARQLSelect</a> ein Operator, der auf diesen Speicher einwirkt.  Es wird versucht, ein Tripel zu finden, das Ihren Anforderungen entspricht, mit einem bestimmten Wert für die „SPARQL-Variable“ x: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/555/3c2/76b5553c2aff9438334527e35f90d7ea.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/01e/9f8/bd1/01e9f8bd168dee384d98c73ef0ba546f.png" alt="Bild"><br><br>  Natürlich gibt es auch einen viel einfacheren Weg, dies in der Wolfram-Sprache zu tun: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/681/ba6/b32/681ba6b329a9b03af93c6f9e80f5f602.png" alt="Bild"><br><br>  Aber mit SPARQL können Sie viel exotischere Dinge tun - wie fragen, welche Eigenschaften die USA mit Mexiko in Verbindung bringen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f8e/ba3/5d9f8eba3cb3a6a6af53790ea0b0f9ad.png" alt="Bild"><br><br>  Oder ob es einen Weg gibt, der auf der Beziehung der angrenzenden Länder von Portugal nach Deutschland basiert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/e1d/c2e/4a0e1dc2ee25e9f86d75d4370ef6b84c.png" alt="Bild"><br><br>  Im Prinzip können Sie eine SPARQL-Abfrage einfach als Zeichenfolge schreiben (ähnlich wie Sie eine SQL-Zeichenfolge schreiben können).  In Version 12.0 haben wir jedoch eine symbolische Darstellung von SPARQL eingeführt, die die Berechnung der Darstellung selbst ermöglicht und es beispielsweise einfach macht, komplexe SPARQL-Abfragen automatisch zu generieren.  (Und dies ist besonders wichtig, da praktische SPARQL-Abfragen für sich genommen die Gewohnheit haben, extrem lang und schwerfällig zu werden.) <cut></cut><br><br>  OK, aber gibt es RDF-Läden in freier Wildbahn?  Es war eine langjährige Hoffnung, dass ein großer Teil des Webs irgendwie genug markiert wird, um „semantisch“ zu werden und tatsächlich ein riesiger RDF-Laden zu sein.  Es wäre großartig, wenn dies passieren würde, aber bisher definitiv nicht.  Trotzdem gibt es einige öffentliche RDF-Stores und auch einige RDF-Stores innerhalb von Organisationen. Mit unseren neuen Funktionen in Version 12.0 sind wir in der einzigartigen Position, interessante Dinge mit ihnen zu tun. <br><br><a name="22"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Numerische Optimierung</a> </h2><cut></cut><br><br>  Eine unglaublich häufige Form von Problemen in industriellen Anwendungen der Mathematik ist: „Welche Konfiguration minimiert die Kosten (oder maximiert die Auszahlung), wenn bestimmte Einschränkungen erfüllt werden müssen?“  Vor mehr als einem halben Jahrhundert wurde der sogenannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simplex-Algorithmus</a> zur Lösung linearer Versionen dieser Art von Problem erfunden, bei denen sowohl die Zielfunktion (Kosten, Auszahlung) als auch die Einschränkungen lineare Funktionen der Variablen im Problem sind.  In den 1980er Jahren wurden viel effizientere Methoden („innere Punkte“) erfunden - und diese hatten wir schon lange für die „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lineare Programmierung</a> “ in der Wolfram-Sprache. <br><br>  Aber was ist mit nichtlinearen Problemen?  Nun, im allgemeinen Fall kann man Funktionen wie NMinimize verwenden.  Und sie machen einen hochmodernen Job.  Aber es ist ein schweres Problem.  Vor einigen Jahren wurde jedoch klar, dass es selbst unter nichtlinearen Optimierungsproblemen eine Klasse von sogenannten konvexen Optimierungsproblemen gibt, die tatsächlich fast so effizient gelöst werden können wie lineare.  ("Konvex" bedeutet, dass sowohl das Ziel als auch die Einschränkungen nur konvexe Funktionen beinhalten - so dass nichts "wackeln" kann, wenn man sich einem Extrem nähert, und es kann keine lokalen Minima geben, die keine globalen Minima sind.) <br><br>  In Version 12.0 haben wir jetzt starke Implementierungen für alle verschiedenen Standardklassen der konvexen Optimierung.  Hier ist ein einfacher Fall, bei dem eine quadratische Form mit einigen linearen Einschränkungen minimiert wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e67/47d/6dc/e6747d6dcb1ab95e6d38ab59e9581ece.png" alt="Bild"><br><br>  <b>NMinimize</b> konnte dieses spezielle Problem bereits in Version 11.3 lösen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/935/47d/9d893547d303b6a8d13ef7997f178254.png" alt="Bild"><br><br>  Aber wenn man mehr Variablen hätte, würde die alte <b>NMinimize</b> schnell ins <b>Stocken geraten</b> .  In Version 12.0 funktioniert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">quadratische Optimierung</a> jedoch weiterhin einwandfrei, bis zu mehr als 100.000 Variablen mit mehr als 100.000 Einschränkungen (sofern sie recht spärlich sind). <br><br>  In Version 12.0 haben wir Funktionen zur „rohen konvexen Optimierung“ wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SemidefiniteOptimization</a> (die lineare Matrixungleichungen behandelt) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConicOptimization</a> (die lineare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vektorungleichungen</a> behandelt).  Funktionen wie <b>NMinimize</b> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindMinimum erkennen</a> jedoch auch automatisch, wann ein Problem effizient gelöst werden kann, indem sie in eine konvexe Optimierungsform umgewandelt werden. <br><br>  Wie richtet man konvexe Optimierungsprobleme ein?  Größere beinhalten Einschränkungen für ganze Vektoren oder Matrizen von Variablen.  Und in Version 12.0 haben wir jetzt Funktionen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VectorGreaterEqual</a> (Eingabe als ≥), die diese sofort darstellen können. <cut></cut><br><br><a name="23"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nichtlineare Finite-Elemente-Analyse</a> </h2><cut></cut><br><br>  Partielle Differentialgleichungen sind schwierig, und wir arbeiten seit 30 Jahren an immer ausgefeilteren und allgemeineren Methoden, um damit umzugehen.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NDSolve</a> (für ODEs) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits 1991</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 2 eingeführt</a> .  Mitte der neunziger Jahre hatten wir unsere ersten (1 + 1-dimensionalen) numerischen PDEs.  2003 haben wir unser leistungsstarkes, modulares Framework für den Umgang mit numerischen Differentialgleichungen eingeführt.  In Bezug auf PDEs handelte es sich jedoch im Grunde immer noch nur um einfache rechteckige Regionen.  Um darüber hinauszugehen, musste unser gesamtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rechnergestütztes Geometriesystem erstellt werden</a> , das wir in Version 10 eingeführt haben. Damit haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere ersten Finite-Elemente-PDE-Löser veröffentlicht</a> .  In Version 11 haben wir dann auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenprobleme</a> verallgemeinert. <cut></cut><br><br>  In Version 12 führen wir nun eine weitere wichtige Verallgemeinerung ein: die nichtlineare Finite-Elemente-Analyse.  Bei der Finite-Elemente-Analyse werden Bereiche in kleine diskrete Dreiecke, Tetraeder usw. zerlegt, auf denen die ursprüngliche PDE durch eine große Anzahl gekoppelter Gleichungen angenähert werden kann.  Wenn die ursprüngliche PDE linear ist, sind diese Gleichungen auch linear - und das ist der typische Fall, den Menschen berücksichtigen, wenn sie über „Finite-Elemente-Analyse“ sprechen. <br><br>  Es gibt jedoch viele PDEs von praktischer Bedeutung, die nicht linear sind - und um diese zu lösen, ist eine nichtlineare Finite-Elemente-Analyse erforderlich, wie wir sie jetzt in Version 12.0 haben. <br><br>  Als Beispiel ist hier das, was nötig ist, um die böse nichtlineare PDE zu lösen, die die Höhe einer minimalen 2D-Oberfläche (z. B. eines idealisierten Seifenfilms) hier über einem Ring mit (Dirichlet-) Randbedingungen beschreibt, die dazu führen, dass sie sinusförmig an der wackelt Kanten (als ob der Seifenfilm an Drähten aufgehängt wäre): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d58/4c9/085/d584c9085402fbf95a17ae1c3e6f62a6.png" alt="Bild"><br><br>  Auf meinem Computer dauert es nur eine Viertelsekunde, um diese Gleichung zu lösen und eine Interpolationsfunktion zu erhalten.  Hier ist eine grafische Darstellung der Interpolationsfunktion, die die Lösung darstellt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/dae/1d4/b70dae1d4342878a4a8709a52f189c51.png" alt="Bild"><br><br><a name="24"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuer, hoch entwickelter Compiler</a> </h2><cut></cut><br><br>  Wir haben im Laufe der Jahre viel Technik in die Optimierung der Ausführung von Wolfram Language-Programmen gesteckt.  Bereits 1989 haben wir begonnen, einfache numerische Berechnungen mit Maschinengenauigkeit automatisch zu Anweisungen für eine effiziente virtuelle Maschine zu kompilieren (und zufällig habe ich den Originalcode dafür geschrieben).  Im Laufe der Jahre haben wir die Funktionen dieses Compilers erweitert, aber es war immer auf ziemlich einfache Programme beschränkt. <br><br>  In Version 12.0 machen wir einen großen Schritt nach vorne und veröffentlichen die erste Version eines neuen, viel leistungsfähigeren Compilers, an dem wir seit mehreren Jahren arbeiten.  Dieser Compiler kann sowohl eine viel breitere Palette von Programmen (einschließlich komplexer Funktionskonstrukte und aufwändiger Kontrollabläufe) verarbeiten als auch nicht auf einer virtuellen Maschine kompilieren, sondern direkt auf optimierten nativen Maschinencode. <br><br>  In Version 12.0 betrachten wir den neuen Compiler immer noch als experimentell.  Aber es schreitet schnell voran und wird sich dramatisch auf die Effizienz vieler Dinge in der Wolfram-Sprache auswirken.  In Version 12.0 stellen wir lediglich eine „Kit-Form“ des neuen Compilers mit spezifischen Kompilierungsfunktionen zur Verfügung.  Aber wir werden den Compiler nach und nach immer automatischer arbeiten lassen - mit maschinellem Lernen und anderen Methoden herausfinden, wann es sich lohnt, sich die Zeit zu nehmen, um welche Kompilierungsstufe zu erreichen. <cut></cut><br><br>  Auf technischer Ebene basiert der neue Compiler der Version 12.0 auf LLVM und generiert LLVM-Code. Er verknüpft dieselbe Laufzeitbibliothek auf niedriger Ebene, die der Wolfram Language-Kernel selbst verwendet, und ruft für die Funktionalität den vollständigen Wolfram Language-Kernel auf das ist nicht in der Laufzeitbibliothek. <br><br>  Hier ist die grundlegende Art und Weise, wie eine reine Funktion in der aktuellen Version des neuen Compilers kompiliert wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/7b3/226/ba77b32262e365742d3ced0ec799df3d.png" alt="Bild"><br><br>  Die resultierende kompilierte Codefunktion funktioniert genauso wie die ursprüngliche Funktion, ist jedoch schneller: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f0/3d1/97c/4f03d197cd7a530a506c79397ccfc257.png" alt="Bild"><br><br>  Ein großer Teil dessen, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FunctionCompile zu</a> einer schnelleren Funktion macht, besteht darin, dass Sie ihm sagen, dass er Annahmen über die Art des Arguments treffen soll, das er erhalten wird.  Wir unterstützen viele Grundtypen (wie " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integer32</a> " und " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Real64</a> ").  Wenn Sie jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FunctionCompile verwenden</a> , legen Sie bestimmte Argumenttypen fest, sodass viel optimierterer Code erstellt werden kann. <br><br>  Ein Großteil der Raffinesse des neuen Compilers hängt damit zusammen, welche Datentypen bei der Ausführung eines Programms generiert werden.  (Es gibt viele graphentheoretische und andere Algorithmen, und natürlich erfolgt die gesamte Metaprogrammierung für den Compiler mit der Wolfram-Sprache.) <br><br>  Hier ist ein Beispiel, das ein bisschen Typinferenz beinhaltet (der Typ von <b>fib</b> wird abgeleitet als <b>"Integer64" -&gt; "Integer64"</b> : eine Ganzzahlfunktion, die eine Ganzzahl <b>zurückgibt</b> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/330/cec/c5a/330cecc5a2bad1f5969fdb779c605f37.png" alt="Bild"><cut></cut><br><br>  Auf meinem Computer läuft <b>cf</b> [25] ungefähr 300-mal schneller als die nicht kompilierte Funktion.  (Natürlich schlägt die kompilierte Version fehl, wenn ihre Ausgabe nicht mehr vom Typ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integer64</a> " ist, aber die Standardversion von Wolfram Language funktioniert weiterhin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einwandfrei</a> .) <br><br>  Der Compiler kann bereits Hunderte von Wolfram Language-Programmierprimitiven verarbeiten, die erzeugten Typen entsprechend verfolgen und Code generieren, der diese Primitive direkt implementiert.  Manchmal möchte man jedoch ausgefeilte Funktionen in der Wolfram-Sprache verwenden, für die es keinen Sinn macht, eigenen kompilierten Code zu generieren - und wo man wirklich nur den Wolfram-Language-Kernel für diese Funktionen aufrufen möchte .  In Version 12.0 können Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KernelFunction Folgendes</a> tun: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/eef/a82/001eefa824b0e7e8faa353ed8bc9ae9b.png" alt="Bild"><br><br>  OK, aber sagen wir, man hat eine kompilierte Codefunktion.  Was kann man damit machen?  Zunächst einmal kann man es einfach in der Wolfram-Sprache ausführen.  Man kann es auch speichern und später ausführen.  Eine bestimmte Kompilierung wird für eine bestimmte Prozessorarchitektur (z. B. 64-Bit x86) durchgeführt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompiledCodeFunction speichert jedoch</a> automatisch genügend Informationen, um bei Bedarf eine zusätzliche Kompilierung für eine andere Architektur durchzuführen. <br><br>  Bei einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompiledCodeFunction</a> besteht eine der interessanten neuen Möglichkeiten darin, dass direkt Code generiert werden kann, der auch außerhalb der Wolfram Language-Umgebung ausgeführt werden kann.  (Unser alter Compiler hatte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CCodeGenerate-</a> Paket, das in einfachen Fällen etwas ähnliche Funktionen bot - obwohl es selbst dann auf einer ausgeklügelten Toolchain von C-Compilern usw. beruht.) <br><br>  So kann man rohen LLVM-Code exportieren (beachten Sie, dass Dinge wie die Optimierung der Schwanzrekursion automatisch ausgeführt werden - und beachten Sie am Ende auch die symbolische Funktion und die Compileroptionen): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0b/334/d15/b0b334d15588277d73fe30ebd8d00181.png" alt="Bild"><br><br>  Wenn man <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FunctionCompileExportLibrary verwendet</a> , erhält man eine Bibliotheksdatei - .dylib unter Mac, .dll unter Windows und .so unter Linux.  Sie können dies in der Wolfram-Sprache verwenden, indem Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibraryFunctionLoad ausführen</a> .  Man kann es aber auch in einem externen Programm verwenden. <br><br>  Eines der wichtigsten Dinge, die die Allgemeinheit des neuen Compilers bestimmen, ist der Reichtum seines Typsystems.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Derzeit</a> unterstützt der Compiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Atomtypen</a> (wie " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boolean</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integer8</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Complex64</a> " usw.).  Es werden auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typkonstruktoren</a> wie " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PackedArray</a> " unterstützt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sodass</a> beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TypeSpecifier</a> [" <b>PackedArray</b> "] [ <b>"Real64", 2</b> ] einem gepackten Array von 64-Bit-Reals mit Rang 2 entspricht. <br><br>  Bei der internen Implementierung der Wolfram-Sprache (die übrigens selbst hauptsächlich in Wolfram-Sprache vorliegt) hatten wir lange Zeit eine optimierte Möglichkeit, Arrays zu speichern.  In Version 12.0 wird es als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumericArray verfügbar gemacht</a> .  Im Gegensatz zu normalen Wolfram Language-Konstrukten müssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumericArray</a> detailliert mitteilen, wie Daten gespeichert werden sollen.  Aber dann funktioniert es auf eine schöne, optimierte Weise: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/2df/d9a/ae82dfd9a6d516d1f8038605806203fc.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/329/9b2/11b/3299b211b774d6d2591c286e553bb7c2.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/4e4/b3a/90b/4e4b3a90bce8a219f635daea28e90507.png" alt="Bild"><br><br><a name="25"></a><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python und andere Sprachen aufrufen</a> </h2><cut></cut><br><br>  In Version 11.2 haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExternalEvaluate</a> eingeführt, mit dem Sie Berechnungen in Sprachen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript</a> aus der Wolfram-Sprache heraus durchführen können (in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> bedeutet „^“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BitXor</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/99c/95e/c2599c95e39a197fbb2872e7763d55c8.png" alt="Bild"><cut></cut><br><br>  In Version 11.3 haben wir externe Sprachzellen eingeführt, um die Eingabe von externen Sprachprogrammen oder anderen Eingaben direkt in ein Notizbuch zu vereinfachen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/80c/9b6/5b780c9b6a375c6f5a245f0320968bb5.png" alt="Bild"><br><br>  In Version 12.0 verschärfen wir die Integration.  In einer externen Sprachzeichenfolge können Sie beispielsweise &lt;* ... *&gt; verwenden, um Wolfram Language-Code zur Auswertung zu geben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/058/d7d/dd5058d7dcabc3d023583639c178d07d.png" alt="Bild"><br><br>  Dies funktioniert auch in externen Sprachzellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/7ae/b35/4657aeb351918b197eaa587fdc93686c.png" alt="Bild"><br><br>  Natürlich ist Python keine Wolfram-Sprache, so viele Dinge funktionieren nicht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78e/fa6/5cb/78efa65cb9c4a980fbfef0271562fd35.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExternalEvaluate</a> kann jedoch zumindest viele Datentypen aus Python zurückgeben, einschließlich Listen (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste</a> ), Wörterbücher (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuordnung</a> ), Bilder (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bild</a> ), Datumsangaben (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DateObject</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumPy-Arrays</a> (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NumericArray</a> ) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pandas-Datasets</a> (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TimeSeries)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DataSet</a> usw.).  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExternalEvaluate</a> kann auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExternalObject zurückgeben</a> , das im Grunde ein Handle für ein Objekt ist, das Sie an Python zurücksenden können.) <cut></cut><br><br>  Sie können auch externe Funktionen direkt verwenden (das leicht bizarr benannte Ord ist im Grunde das Python-Analogon von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ToCharacterCode</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/740/baa/4c6740baad353bfe1951c06480598677.png" alt="Bild"><br><br>  Und hier ist eine reine Python-Funktion, die symbolisch in der Wolfram-Sprache dargestellt wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e01/c54/9cd/e01c549cdec28029ba753c6d8aaaadbe.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/5a3/44c/33d/5a344c33d789c5f380f06c77a7f5cc66.png" alt="Bild"><br><br><a name="26"></a><h2>  Aufrufen der Wolfram-Sprache von Python und anderen Orten aus </h2><cut></cut><br><br>  Wie soll man auf die Wolfram-Sprache zugreifen?  Es gibt viele Möglichkeiten.  Man kann es direkt in einem Notebook verwenden.  Man kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APIs aufrufen</a> , die es in der Cloud ausführen.  Oder man kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WolframScript</a> in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehlszeilen-Shell verwenden</a> .  WolframScript kann entweder gegen eine lokale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Engine</a> oder gegen eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Engine in der Cloud ausgeführt werden</a> .  Sie können direkt Code zur Ausführung angeben: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e94/d3e/29e/e94d3e29e3a03923dd85c4da9f60f724.png" alt="Bild"><br><br>  Und damit können Sie beispielsweise Funktionen definieren, beispielsweise mit Code in einer Datei: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b1/f6e/f12/6b1f6ef12064eeb1b6a57b8e98b8aa57.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/c58/ba6/d3d/c58ba6d3de02fd8cefdda1d86c7d66d5.png" alt="Bild"><br><br>  Zusammen mit der Veröffentlichung von Version 12.0 veröffentlichen wir auch unsere erste neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Language Client Library</a> - für Python.  Die Grundidee dieser Bibliothek besteht darin, Python-Programmen das Aufrufen der Wolfram-Sprache zu erleichtern.  (Es ist erwähnenswert, dass wir seit nicht weniger als 30 Jahren effektiv eine C-Sprach-Client-Bibliothek haben - durch das, was jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WSTP</a> heißt.) <br><br>  Die Funktionsweise einer Sprachclientbibliothek ist für verschiedene Sprachen unterschiedlich. For Python—as an interpreted language (that was actually historically informed by early Wolfram Language)—it's particularly simple. After you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">set up the library</a> , and start a session (locally or in the cloud), you can then just evaluate Wolfram Language code and get the results back in Python: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/f6a/f1a/638f6af1a998246c352f06c7872093ef.png" alt="Bild"><br><br> You can also directly access Wolfram Language functions (as a kind of inverse of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExternalFunction</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/374/3b0/4203743b04153aa9946d9212b8f3d9c3.png" alt="Bild"><br><br> And you can directly interact with things like pandas structures, NumPy arrays, etc. In fact, you can in effect just treat the whole of the Wolfram Language like a giant library that can be accessed from Python. Or, of course, you can just use the nice, integrated Wolfram Language directly, perhaps creating external APIs if you need them. <br><br><a name="27"></a><h2> More for the Wolfram “Super Shell” </h2><cut></cut><br><br> One feature of using the Wolfram Language is that it lets you get away from having to think about the details of your computer system, and about things like files and processes. But sometimes one wants to work at a systems level. And for fairly simple operations, one can just use an operating system GUI. But what about for more complicated things? In the past I usually found myself using the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unix shell</a> . But for a long time now, I've instead used Wolfram Language. <br><br> It's certainly very convenient to have everything in a notebook, and it's been great to be able to programmatically use functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FileNames</a> (ls), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindList</a> (grep), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemProcessData</a> (ps), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RemoteRunProcess</a> (ssh) and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FileSystemScan</a> . But in Version 12.0 we're adding a bunch of additional functions to support using the Wolfram Language as a “super shell”. <br><br> There's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RemoteFile</a> for symbolically representing a remote file (with authentication if needed)— that you can immediately use in functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CopyFile</a> . There's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FileConvert</a> for directly converting files between different formats. <cut></cut><br><br> And if you really want to dive deep, here's how you'd trace all the packets on ports 80 and 443 used in reading from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wolfram.com</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/589/07d/c0f/58907dc0f140b552d76390afe36a509b.png" alt="Bild"><br><br><a name="28"></a><h2> Puppeting a Web Browser </h2><cut></cut><br><br> Within the Wolfram Language, it's been easy for a long time to interact with web servers, using functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URLExecute</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTPRequest</a> , as well as $ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cookies</a> , etc. But in Version 12.0 we're adding something new: the ability of the Wolfram Language to <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">control a web browser</a> , and programmatically make it do what we want. The most immediate thing we can do is just to get an image of what a website looks like to a web browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/334/338/96a/33433896a1f7bd04f15791dfd2dd3bf5.png" alt="Bild"><br><br> The result is an image that we can compute with: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/3b8/f2d/e513b8f2d3c5e4261bb90a4a7815064e.png" alt="Bild"><br><br> To do something more detailed, we have to start a browser session (we currently support Firefox and Chrome): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="Bild"><br><br> Immediately a blank browser window appears on our screen. Now we can use WebExecute to open a webpage: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b7/d5e/313/3b7d5e313a576e8ef19c8608b9697af5.png" alt="Bild"><br><br> Now that we've opened the page, there are lots of commands we can run. This clicks the first hyperlink containing the text “Programming Lab”: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55b/5d1/5f8/55b5d15f81d2abe5cccf61152aa9046d.png" alt="Bild"><br><br> This returns the title of the page we've reached: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/55c/77c/0ad/55c77c0ad16c59574509a4288e117d91.png" alt="Bild"><br><br> You can type into fields, run JavaScript, and basically do programmatically anything you could do by hand with a web browser. Needless to say, we've been using a version of this technology for years inside our company to test all our various websites and web services. But now, in Version 12.0, we're making a streamlined version generally available. <br><br><a name="29"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standalone Microcontrollers</a> </h2><cut></cut><br><br> For every general-purpose computer in the world today, there are probably 10 times as many <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">microcontrollers</a> —running specific computations without any general operating system. A microcontroller might cost a few cents to a few dollars, and in something like a mid-range car, there might be 30 of them. <br><br> In Version 12.0 we're introducing a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microcontroller Kit</a> for the Wolfram Language, that lets you give symbolic specifications from which it automatically generates and deploys code to run autonomously in microcontrollers. In the typical setup, a microcontroller is continuously doing computations on data coming in from sensors, and in real time putting out signals to actuators. The most common types of computations are effectively ones in control theory and signal processing. <br><br> We've had extensive support for doing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">control theory</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">signal processing</a> directly in the Wolfram Language for a long time. But now what's possible with the Microcontroller Kit is to take what's specified in the language and download it as embedded code in a standalone microcontroller that can be <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deployed anywhere</a> (in devices, IoT, appliances, etc.). <br><br> As an example, here's how one can generate a symbolic representation of an analog signal-processing filter: <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/255/6c6/67e/2556c667eb6b487b0657419d5bd1e480.png" alt="Bild"><br><br> We can use this filter directly in the Wolfram Language—say using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RecurrenceFilter</a> to apply it to an audio signal. We can also do things like plot its frequency response: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a85/22b/8d9/a8522b8d961d04d6d967139e82f52978.png" alt="Bild"><br><br> To deploy the filter in a microcontroller, we first have to derive from this continuous-time representation a discrete-time approximation that can be run in a tight loop (here, every 0.1 seconds) in the microcontroller: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecc/e6d/c76/ecce6dc76f8dbfc9e74b556d7a9b96c2.png" alt="Bild"><br><br> Now we're ready to use the Microcontroller Kit to actually deploy this to a microcontroller. The kit supports more than a hundred different types of microcontrollers. Here's how we could deploy the filter to an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino Uno</a> that we have connected to a serial port on our computer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95f/f0e/781/95ff0e781b43e3f53e708f8929f666a9.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/7bb/a8f/2a17bba8f0708021de792c4b86dd7b41.png" alt="Bild"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicrocontrollerEmbedCode</a> works by generating appropriate C-like source code, compiling it for the microcontroller architecture you want, then actually deploying it to the microcontroller through its so-called programmer. Here's the actual source code that was generated in this particular case: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ef/30c/52a/6ef30c52a232105557cb984db655cc1f.png" alt="Bild"><br><br> So now we have a thing like this that runs our <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Butterworth filter</a> , that we can use anywhere: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfd/ab3/e39/bfdab3e39ead3e8cf85251bf28d5d277.png" alt="Bild"><br><br> If we want to check what it's doing, we can always connect it back into the Wolfram Language using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DeviceOpen</a> to open its <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">serial port</a> , and read and write from it. <br><br><a name="30"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linking to the Unity Universe</a> </h2><cut></cut><br><br> What's the relation between the Wolfram Language and video games? Over the years, the Wolfram Language has been used behind the scenes in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">many aspects of game development</a> (simulating strategies, creating geometries, analyzing outcomes, etc.). But for some time now we've been working on a closer link between Wolfram Language and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unity game environment</a> , and in Version 12.0 we're releasing a first version of this link. <br><br> The basic scheme is to have Unity running alongside the Wolfram Language, then to set up two-way communication, allowing both objects and commands to be exchanged. The under-the-hood plumbing is quite complex, but the result is a nice merger of the strengths of Wolfram Language and Unity. <br><br> This sets up the link, then starts a new project in Unity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/270/93a/4af27093ade48a6ef031b2d618d99c5a.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/92a/378/da492a378b2669aa287728aeb27b13a1.png" alt="Bild"><br><br> Now create some complex shape: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/214/e3e/bb3214e3e4669b136d966ab856d78ce0.png" alt="Bild"><br><br> Then it takes just one command to put this into the Unity game as an object called " <b>thingoid</b> ": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df4/edb/5aa/df4edb5aa6f976cd757e21476f505de5.png" alt="Bild"><br><br> Within the Wolfram Language there's a symbolic representation of the object, and UnityLink now provides hundreds of functions for manipulating such objects, always maintaining versions both in Unity and in the Wolfram Language. <cut></cut><br><br> It's very powerful that one can take things from the Wolfram Language and immediately put them into Unity—whether they're <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geometry</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">images</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">audio</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geo terrain</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">molecular structures</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D anatomy</a> , or whatever. It's also very powerful that such things can then be manipulated within the Unity game, either through things like game physics, or by user action. (Eventually, one can expect to have <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Manipulate</a> -like functionality, in which the controls aren't just sliders and things, but complex pieces of gameplay.) <br><br> We've done experiments with putting Wolfram Language–generated content into virtual reality since the early 1990s. But in modern times Unity has become something of a de facto standard for setting up VR/AR environments—and with UnityLink it's now straightforward to routinely put things from Wolfram Language into any modern XR environment. <cut></cut><br><br> One can use the Wolfram Language to prepare material for Unity games, but within a Unity game UnityLink also basically lets one just insert Wolfram Language code that can be executed during a game either on a local machine or through an API in the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Cloud</a> . And, among other things, this makes it straightforward to put hooks into a game so the game can send “telemetry” (say to the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Data Drop</a> ) for analysis in the Wolfram Language. (It's also possible to script the playing of the game—which is, for example, very useful for game testing.) <br><br> Writing games is a complex matter. But UnityLink provides an interesting new approach that should make it easier to prototype all sorts of games, and to learn the ideas of game development. One reason for this is that it effectively lets one script a game at a higher level by using symbolic constructs in the Wolfram Language. But another reason is that it lets the development process be done incrementally in a notebook, and explained and documented every step of the way. For example, here's what amounts to a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">computational essay</a> describing the development of a “ <a href="">piano game</a> ”: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/ef8/2b4/a42ef82b4e18bc1c47fc84bc60128dd0.png" alt="Bild"><br><br> UnityLink isn't a simple thing: it contains more than 600 functions. But with those functions it's possible to access pretty much all the capabilities of Unity, and to set up pretty much any imaginable game. <br><br><a name="31"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Simulated Environments for Machine Learning</a> </h2><cut></cut><br><br> For something like reinforcement learning it's essential to have a manipulable external environment in the loop when one's doing machine learning. Well, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ServiceExecute</a> lets you call APIs (what's the effect of posting that tweet, or making that trade?), and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DeviceExecute</a> lets you actuate actual devices (turn the robot left) and get data from sensors (did the robot fall over?). <br><br> But for many purposes what one instead wants is to have a simulated external environment. And in a way, just the pure Wolfram Language already to some extent does that, for example providing access to a rich “computational universe” full of modifiable programs and equations ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cellular automata</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">differential equations</a> , …). And, yes, the things in that computational universe can be informed by the real world—say with the realistic properties of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oceans</a> , or <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chemicals</a> or <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mountains</a> . <br><br> But what about environments that are more like the ones we modern humans typically learn in—full of built engineering structures and so on? Conveniently enough, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemModel</a> gives access to lots of realistic engineering systems. And through UnityLink we can expect to have access to rich game-based simulations of the world. <br><br> But as a first step, in Version 12.0 we're setting up connections to some simple games—in particular from the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAI “gym”</a> . The interface is much as it would be for interacting with the real world, with the game accessed like a “device” (after appropriate sometimes-“open-source-painful” installation): <cut></cut><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec9/83a/b2d/ec983ab2d7c63efc693c939acda7dbf9.png" alt="Bild"><br><br> We can read the state of the game: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/872/c7a/884872c7a130bbfecc2f09bf679b2299.png" alt="Bild"><br><br> And we can show it as an image: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6c/fcd/9ac/d6cfcd9ac48ffe0b14508449c745c2f0.png" alt="Bild"><br><br> With a bit more effort, we can take 100 random actions in the game (always checking that we didn't “die”), then show a feature space plot of the observed states of the game: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cf/a32/6d4/1cfa326d4dedba01361ae861654470df.png" alt="Bild"><br><br><a name="32"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blockchain (and CryptoKitty) Computation</a> </h2><cut></cut><br><br> In Version 11.3 we began <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">our first connection to the blockchain</a> . Version 12.0 adds a lot of new features and capabilities, perhaps most notably the ability to write to public blockchains, as well as read from them. (We also have our own <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Blockchain</a> for Wolfram Cloud users.) We're currently supporting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ARK</a> blockchains, both their mainnets and testnets (and, yes, we have our own nodes connecting directly to these blockchains). <br><br> In Version 11.3 we allowed <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">raw reading of transactions</a> from blockchains. In Version 12.0 we've added a layer of analysis, so that, for example, you can ask for a summary of “CK” tokens (AKA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CryptoKitties</a> ) on the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum</a> blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/764/9d7/9fd/7649d79fd08e80c7b49e0b4ed01601c2.png" alt="Bild"><br><br> It's quick to look at all token transactions in history, and make a word cloud of how active different tokens have been: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b34/e2a/ed1/b34e2aed1642c72e2adc852c646652d0.png" alt="Bild"><br><br> But what about doing our own transaction? Let's say we want to use a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin ATM</a> (like the one that, bizarrely, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exists at a bagel store near me</a> ) to transfer cash to a Bitcoin address. Well, first we create our crypto keys (and we need to make sure we remember our private key!): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/808/40a/27a/80840a27a3055248b226d25587a73509.png" alt="Bild"><br><br> Next, we have to take our public key and generate a Bitcoin address from it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caf/e3d/947/cafe3d947d2d41234d0f7586f2915e4f.png" alt="Bild"><br><br> Make a QR code from that and you're ready to go to the ATM: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a74/929/50e/a7492950e7d0a95d38186315c1ddd001.png" alt="Bild"><br><br> But what if we want to write to the blockchain ourselves? Here we'll use the Bitcoin testnet (so we're not spending real money). This shows an output from a transaction we did before—that includes 0.0002 bitcoin (ie 20,000 satoshi): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/321/cd7/fd4321cd77d95b3ed9efd7c0de0895ed.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/364/802/556/3648025569fe0af443c62393e883beee.png" alt="Bild"><br><br> Now we can set up a transaction which takes this output, and, for example, sends 8000 satoshi to each of two addresses (that we defined just like for the ATM transaction): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/040/6c6/137/0406c61375496148813593fadd4ee74b.png" alt="Bild"><br><br> OK, so now we've got a blockchain transaction object—that would offer a fee (shown in red because it's “actual money” you'll spend) of all the leftover cryptocurrency (here 4000 satoshi) to a miner willing to put the transaction in the blockchain. But before we can submit this transaction (and “spend the money”) we have to sign it with our private key: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d50/f79/eda/d50f79eda8d9794ebc5c806981154bc4.png" alt="Bild"><br><br> Finally, we just apply <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BlockchainTransactionSubmit</a> and we've submitted our transaction to be put on the blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23e/a41/90b/23ea4190b20e3551659e93dad7b69e91.png" alt="Bild"><br><br> Here's its transaction ID: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/823/fa5/39a823fa520d89549e8e1e2168740057.png" alt="Bild"><br><br> If we immediately ask about this transaction, we'll get a message saying it isn't in the blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/060/f7f/642/060f7f642cb825d2622240997bc0eafe.png" alt="Bild"><br><br> But after we wait a few minutes, there it is—and it'll soon spread to every copy of the Bitcoin testnet blockchain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/b84/8a2/bd2b848a27bee449da4f33e59b81c6e5.png" alt="Bild"><br><br> If you're prepared to spend real money, you can use exactly the same functions to do a transaction on a main net. You can also do things like buy CryptoKitties. Functions like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BlockchainContractValue</a> can be used for any (for now, only Ethereum) smart contract, and are set up to immediately understand things like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ERC-20</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ERC-721</a> tokens. <br><br><a name="33"></a><h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">And Ordinary Crypto as Well</a> </h2><cut></cut><br><br> Dealing with blockchains involves lots of cryptography, some of which is new in Version 12.0 (notably, handling elliptic curves). But in Version 12.0 we're also extending our non-blockchain cryptographic functions. For example, we've now got functions for directly dealing with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">digital signatures</a> . This creates a digital signature using the private key from above: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/992/aea/095/992aea095dda73b7c235697083f415b0.png" alt="Bild"><br><img src="https://habrastorage.org/getpro/habr/post_images/e63/6a4/1fa/e636a41faad25da5ad4ec9b608c84263.png" alt="Bild"><br><br> Now anyone can verify the message using the corresponding public key: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/856/188/068/856188068028388c87e44b766c116697.png" alt="Bild"><br><br> In Version 12.0, we added several new types of hashes for the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash</a> function, particularly to support various cryptocurrencies. We also added ways to generate and verify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">derived keys</a> . Start from any password, and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GenerateDerivedKey</a> will “puff it out” to something longer (to be more secure you should add “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">salt</a> ”): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/913/885/a62/913885a629ef74ed691138b7466691a4.png" alt="Bild"><br><br> Here's a version of the derived key, suitable for use in various authentication schemes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b7/538/8ea/9b75388ea82f526769bf51a88a911989.png" alt="Bild"><br><br><a name="34"></a><h2> Connecting to Financial Data Feeds </h2><cut></cut><br><br> The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Knowledgebase</a> contains all sorts of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">financial data</a> . Typically there's a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">financial entity</a> (like a stock), then there's a property (like price). Here's the complete daily history of Apple's stock price (it's very impressive that it looks best on a log scale): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/710/812/cab710812fa2da43a0b71dc75152b7c6.png" alt="Bild"><br><br> But while the financial data in the Wolfram Knowledgebase, and standardly available in the Wolfram Language, is continuously updated, it's not real time (mostly it's 15-minute delayed), and it doesn't have all the detail that many financial traders use. For serious finance use, however, we've developed <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Finance Platform</a> . And now, in Version 12.0, it's got direct access to Bloomberg and Reuters financial data feeds. <br><br> The way we architect the Wolfram Language, the framework for the connections to Bloomberg and Reuters is always available in the language—but it's only activated if you have Wolfram Finance Platform, as well as the appropriate Bloomberg or Reuters subscriptions. But assuming you have these, here's what it looks like to connect to the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg Terminal</a> service: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd5/ff6/97f/dd5ff697ffebdb5c00d653d50438672a.png" alt="Bild"><br><br> All the financial instruments handled by the Bloomberg Terminal now become available as entities in the Wolfram Language: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c9/4b0/c6e/0c94b0c6e8d86d6311981528c4dd2931.png" alt="Bild"><br><br> Now we can ask for properties of this entity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffd/290/bb2/ffd290bb25269f2331d0f913de0ff61e.png" alt="Bild"><br><br> Altogether there are more than 60,000 properties accessible from the Bloomberg Terminal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5dd/de8/940/5ddde8940cb5f533179581155afbae90.png" alt="Bild"><br><br> Here are 5 random examples (yes, they're pretty detailed; those are Bloomberg names, not ours): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/638/6f0/8ab/6386f08ab9fc2877748ce7d93567d2ce.png" alt="Bild"><br><br> We support the Bloomberg Terminal service, the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bloomberg Data License</a> service, and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reuters Elektron</a> service. One sophisticated thing one can now do is to set up a continuous task to asynchronously receive data, and call a “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">handler function</a> ” every time a new piece of data comes in: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/0a4/833/ab40a48336f338db8a6b232fd2215d03.png" alt="Bild"><br><br><a name="35"></a><h2> Software Engineering &amp; Platform Updates </h2><cut></cut><br><br> I've talked about lots of new functions and new functionality in the Wolfram Language. But what about the underlying infrastructure of the Wolfram Language? Well, we've been working hard on that too. For example, between Version 11.3 and Version 12.0 we've managed to fix nearly 8000 reported bugs. We've also made lots of things faster and more robust. And in general we've been tightening the software engineering of the system, for example reducing the initial download size by nearly 10% (despite all the functionality that's been added). (We've also done things like improve the predictive <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prefetching of knowledgebase elements</a> from the cloud—so when you need similar data it's more likely to be already cached on your computer.) <br><br> It's a longstanding feature of the computing landscape that operating systems are continually getting updated—and to take advantage of their latest features, applications have to get updated too. We've been working for several years on a major update to our Mac notebook interface—which is finally ready in Version 12.0. As part of the update, we've rewritten and restructured large amounts of code that have been developed and polished over more than 20 years, but the result is that in Version 12.0, everything about our system on the Mac is fully 64-bit, and makes use of the latest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cocoa APIs</a> . This means that the notebook front end is significantly faster—and can also go beyond the previous 2 GB memory limit. <br><br> There's also a platform update on Linux, where now the notebook interface fully supports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt 5</a> , which allows all rendering operations to take place “headlessly”, without any X server—greatly streamlining deployment of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Engine</a> in the cloud. (Version 12.0 doesn't yet have high-dpi support for Windows, but that's coming very soon.) <br><br> The development of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Cloud</a> is in some ways separate from the development of the Wolfram Language, and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wolfram Desktop</a> applications (though for internal compatibility we're releasing Version 12.0 at the same time in both environments). But in the past year since Version 11.3 was released, there's been dramatic progress in the Wolfram Cloud. <cut></cut><br><br> Especially notable are the advances in cloud notebooks—supporting more interface elements (including some, like embedded websites and videos, that aren't even yet available in desktop notebooks), as well as greatly increased robustness and speed. (Making our whole notebook interface work in a web browser is no small feat of software engineering, and in Version 12.0 there are some pretty sophisticated strategies for things like maintaining consistent fast-to-load caches, along with full symbolic DOM representations.) <br><br> In Version 12.0 there's now just a simple menu item (File &gt; Publish to Cloud …) to publish any notebook to the cloud. And once the notebook is published, anyone in the world can interact with it—as well as make their own copy so they can edit it. <br><br> It's interesting to see <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">how broadly the cloud has entered what can be done</a> in the Wolfram Language. In addition to all the seamless integration of the cloud knowledgebase, and the ability to reach out to things like blockchains, there are also conveniences like <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Send To</a> … sending any notebook through email, using the cloud if there's no direct email server connection available. <br><br><a name="36"></a><h2> And a Lot Else… </h2><cut></cut><br><br> Even though this has been a long piece, it's not even close to telling the whole story of what's new in Version 12.0. Along with the rest of our team, I've been working very hard on Version 12.0 for a long time now—but it's still exciting to see just how much is actually in it. <br><br> But what's critical (and a lot of work to achieve!) is that everything we've added is carefully designed to fit coherently with what's already there. From the very first version more than 30 years ago of what's now the Wolfram Language, we've been following the same core principles—and this is part of what's allowed us to so dramatically grow the system while maintaining long-term compatibility. <br><br> It's always difficult to decide exactly what to prioritize developing for each new version, but I'm very pleased with the choices we made for Version 12.0. I've given many talks over the past year, and I've been very struck with how often I've been able to say about things that come up: “Well, it so happens that that's going to be part of Version 12.0!” <br><br> I've personally been using internal preliminary builds of Version 12.0 for nearly a year, and I've come to take for granted many of its new capabilities—and to use and enjoy them a lot. So it's a great pleasure that today we have the final Version 12.0—with all these new capabilities officially in it, ready to be used by anyone and everyone… </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448394/">https://habr.com/ru/post/de448394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448382/index.html">Wie wir die Qualität der Dokumentation bewertet haben</a></li>
<li><a href="../de448386/index.html">9 erstaunlich einfache Möglichkeiten, Menschen dazu zu bringen, auf Ihre Nachrichten zu antworten</a></li>
<li><a href="../de448388/index.html">In Russland das erste digitale Diktat</a></li>
<li><a href="../de448390/index.html">Wie man eine Uhr für Ilona Mask macht</a></li>
<li><a href="../de448392/index.html">Zwei Ansätze zur Strukturierung eines Aktivitätsdiagramms</a></li>
<li><a href="../de448396/index.html">Machen Sie sich bereit für den Hardened Runtime and Notary Service auf macOS Mojave</a></li>
<li><a href="../de448400/index.html">Netplan und wie man es richtig kocht</a></li>
<li><a href="../de448402/index.html">Fehler beim Migrieren der Zertifizierungsstelle (CA) von Windows 2008R zu Windows 2012 R2</a></li>
<li><a href="../de448404/index.html">So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Beispiels der Yandex.Direct-API (Teil 2)</a></li>
<li><a href="../de448408/index.html">DCIM - Der Schlüssel zur Verwaltung von Rechenzentren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>