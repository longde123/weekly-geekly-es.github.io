<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏼 🎌 ⤴️ Memperkenalkan Python untuk Kamerad yang Mengalahkan “A vs. V Language” bahasa B "dan prasangka lainnya 💫 📦 🧚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk semua penghuni yang memiliki rasa deja vu: Saya diminta untuk menulis posting ini dengan artikel "Pengantar Python" dan mengomentarinya. Sayangn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan Python untuk Kamerad yang Mengalahkan “A vs. V Language” bahasa B "dan prasangka lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450724/"><p>  Untuk semua penghuni yang memiliki rasa deja vu: Saya diminta untuk menulis posting ini dengan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengantar Python"</a> dan mengomentarinya.  Sayangnya, kualitas "pengantar" ini ahem ... jangan bicara tentang hal-hal yang menyedihkan.  Tapi itu lebih menyedihkan untuk mengamati pertengkaran dalam komentar dari kategori "C ++ lebih cepat dari Python", "Karat bahkan lebih cepat dari C ++", "Python tidak diperlukan", dll.  Sungguh menakjubkan bahwa mereka tidak ingat Ruby! </p><br><p>  Seperti yang dikatakan Bjarn Stroustrup, </p><br><blockquote>  "Hanya ada dua jenis bahasa pemrograman: yang orang bersumpah sepanjang waktu, dan yang tidak ada yang menggunakan." </blockquote><p>  Selamat datang di semua orang yang ingin berkenalan dengan Python tanpa jatuh dalam kutukan kotor! </p><a name="habracut"></a><br><p> Pagi di pegunungan Kaukasus Timur ditandai dengan tangisan.  Dua pria muda duduk di atas batu besar dan dengan penuh semangat membahas sesuatu, dengan aktif menggerakkan tangan.  Semenit kemudian, mereka mulai saling mendorong, dan kemudian bergulat dan jatuh dari batu ke (ternyata) semak jelatang.  Rupanya semak ini tumbuh di sana karena suatu alasan, - ia segera menenangkan para petarung dan membawa gencatan senjata ke perselisihan mereka yang tak terpadamkan.  Seperti yang mungkin Anda tebak, saya adalah salah satu pendebat, yang lain adalah teman baik saya (halo, Quaker_t!), Tapi topik pembicaraan kecil kami adalah <strong>Visual Basic vs.</strong>  <strong>Delphi</strong> ! </p><br><p>  Apakah Anda mengenali diri sendiri?  Terkadang kita mengubah bahasa pemrograman favorit kita menjadi sekte dan siap untuk mempertahankannya sampai akhir!  Tetapi tahun demi tahun berlalu dan saatnya datang ketika "A vs B" dari subjek pertengkaran berkembang menjadi "Saya lebih nyaman bekerja dengan A, tetapi jika perlu saya akan belajar cara bekerja dengan B, C, D, E <em>dan secara umum, dengan apa pun</em> ."  Itu hanya ketika kita menemukan bahasa pemrograman baru, kebiasaan lama dan budaya mungkin tidak membiarkan kita pergi untuk waktu yang lama. </p><br><p>  Saya ingin memperkenalkan Anda ke Python dan membantu mentransfer pengalaman Anda ke arah yang baru.  Seperti halnya teknologi apa pun, ia memiliki kekuatan dan kelemahannya sendiri.  Python, seperti C ++, Rust, Ruby, JS, dan yang lainnya, adalah alat.  Instruksi terlampir pada instrumen apa pun dan Anda harus belajar menggunakan instrumen apa pun <em>dengan benar</em> . </p><br><p>  "Penulis, tidak punya otak, apakah Anda akan memperkenalkan kami ke Python?"  Mari berkenalan! </p><br><p>  Python adalah bahasa pemrograman tujuan umum tingkat tinggi yang dinamis.  Python adalah bahasa pemrograman yang <strong>matang</strong> dengan ekosistem dan tradisi yang kaya.  Meskipun bahasa ini dirilis pada tahun 1991, penampilannya yang modern mulai terbentuk pada awal tahun 2000-an.  Python adalah bahasa yang <strong>dibebankan</strong> , di perpustakaan standarnya ada solusi untuk banyak kesempatan.  Python adalah bahasa pemrograman yang <strong>populer</strong> : Dropbox, Reddit, Instagram, Disqus, YouTube, Netflix, sial, bahkan Eve Online dan banyak lainnya aktif menggunakan Python. </p><br><p>  Apa alasan popularitas ini?  Dengan izin Anda, saya akan menyajikan versi saya sendiri. </p><br><p>  Python adalah bahasa pemrograman yang <strong>sederhana</strong> .  Pengetikan dinamis.  Pengumpul sampah.  Fungsi urutan lebih tinggi.  Sintaks sederhana untuk bekerja dengan kamus, set, tupel dan daftar (termasuk untuk mendapatkan irisan).  Python sangat bagus untuk pemula: memungkinkan untuk memulai dengan pemrograman prosedural, secara perlahan beralih ke OOP dan merasakan pemrograman fungsional.  Tapi kesederhanaan ini seperti ujung gunung es.  Layak menyelam ke kedalaman ketika Anda menemukan filosofi Python - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zen Of Python</a> .  Menyelam lebih jauh - dan Anda menemukan diri Anda dalam serangkaian aturan yang jelas untuk desain kode - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Gaya untuk Kode Python</a> .  Menyelam, programmer secara bertahap menggali ke dalam konsep "cara Python" atau "Pythonic".  Pada tahap pembelajaran bahasa yang menakjubkan ini, Anda mulai memahami mengapa program Python yang baik ditulis dengan cara ini dan bukan sebaliknya.  Mengapa bahasa telah berevolusi ke arah ini, dan tidak ke yang lain.  Python tidak berhasil dalam kecepatan.  Tetapi ia berhasil dalam aspek terpenting dari pekerjaan kami - keterbacaan.  "Tulis kode untuk orang, bukan untuk mobil" - ini adalah dasar dari dasar-dasar Python. </p><br><p>  Kode Python yang bagus terlihat indah.  Dan untuk menulis kode yang indah - pekerjaan apa yang tidak menyenangkan? </p><br><p>  <strong>Kiat 0:</strong> <em>Sebelum membaca lebih lanjut, silakan melihat sudut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zen Python</a> .</em>  <em>Bahasa ini didasarkan pada postulat-postulat ini dan komunikasi kami akan jauh lebih menyenangkan jika Anda akan terbiasa dengannya.</em> </p><br><h3 id="kakoy-umnik-dodumalsya-do-otstupov">  Pria pintar apa yang muncul dengan lekukan? </h3><br><p>  Kejutan pertama bagi mereka yang belum pernah melihat kode dengan Python adalah lekukan tubuh instruksi: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ins = input(<span class="hljs-string"><span class="hljs-string">'Please say something'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ins.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w == <span class="hljs-string"><span class="hljs-string">'hello'</span></span>: print(<span class="hljs-string"><span class="hljs-string">'world!'</span></span>)</code> </pre> <br><p>  Saya ingat malam hari di asrama Politeknik St. Petersburg ketika tetangga saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">VlK</a> , dengan mata yang terbakar mengatakan kepada saya bahwa ia telah menggali sesuatu yang baru dengan Python.  "Badan lekukan? Serius?"  - adalah reaksi saya.  Memang, bagi seseorang yang beralih dari Visual Basic ( <code>if ... end if</code> ) ke C # (kurung kurawal) melalui C, C ++ dan Java, pendekatan ini tampaknya, secara halus, aneh.  "Apakah Anda memformat kode dengan lekukan?" Tanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">VlK</a> .  Tentu saja saya memformatnya.  Lebih tepatnya, spiral Studio Visual melakukannya untuk saya.  Dia melakukannya dengan sangat baik.  Saya tidak pernah berpikir tentang pemformatan dan indentasi - mereka muncul dalam kode sendiri dan tampaknya menjadi sesuatu yang biasa dan akrab.  Tapi tidak ada yang disembunyikan - kode selalu diformat dengan lekukan.  "Lalu mengapa kamu perlu kawat gigi keriting jika tubuh instruksi dalam hal apapun bergeser ke kanan?" </p><br><p>  Malam itu saya duduk dengan Python.  Melihat ke belakang, saya dapat mengatakan dengan pasti apa yang sebenarnya membantu untuk dengan cepat menyerap materi baru.  Itu adalah editor kode.  Di bawah pengaruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">VlK yang</a> sama, tak lama sebelum peristiwa yang dijelaskan di atas, saya beralih dari Windows ke Ubuntu dan Emacs sebagai editor (di halaman 2007, ke PyCharm, Atom, VS Code, dan lainnya - bertahun-tahun lagi).  "Yah, sekarang Emacs akan PR ..." - katamu.  Hanya sedikit :) Secara tradisional, tombol <code>&lt;tab&gt;</code> di Emacs tidak menambahkan tab, tetapi berfungsi untuk menyelaraskan baris sesuai dengan aturan mode ini.  Ditekan <code>&lt;tab&gt;</code> - dan baris kode digeser ke posisi yang sesuai berikutnya: </p><br><p><img src="https://habrastorage.org/webt/p_/8g/jm/p_8gjmuqid2ffw7ixile3wkjz74.gif"></p><br><p>  Dengan cara ini Anda tidak perlu memikirkan apakah Anda menyelaraskan kode dengan benar. </p><br><p>  <strong>Kiat 1:</strong> <em>Saat Anda mengenal Python, gunakan editor yang menangani lekukan.</em> </p><br><p>  Apakah Anda tahu apa efek samping dari semua aib ini?  Programmer mencoba menghindari konstruksi yang panjang.  Begitu ukuran fungsi melampaui batas vertikal layar, menjadi lebih sulit untuk membedakan mana desain blok kode yang diberikan milik.  Dan semakin banyak investasi, semakin sulit.  Akibatnya, Anda mencoba menulis sesingkat mungkin, memecah tubuh panjang fungsi, loop, transisi kondisional, dll. </p><br><h3 id="da-nu-vashu-dinamicheskuyu-tipizaciyu">  Oh well, mengetik dinamis Anda </h3><br><p>  O, diskusi ini ada hampir selama konsep "pemrograman" ada!  Pengetikan dinamis tidak buruk atau baik.  Pengetikan dinamis juga merupakan alat kami.  Dalam Python, pengetikan dinamis memberikan kebebasan tindakan yang luar biasa.  Dan di mana ada kebebasan yang lebih besar untuk bertindak - lebih mungkin untuk menembak diri sendiri di kaki. </p><br><p>  Perlu diklarifikasi bahwa mengetikkan Python <strong>ketat</strong> dan menambahkan angka ke string tidak berfungsi: </p><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt;&gt;&gt; TypeError: unsupported operand type(s) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> +: <span class="hljs-string"><span class="hljs-string">'int'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'str'</span></span></code> </pre> <br><p>  Python juga memeriksa tanda tangan dari fungsi ketika dipanggil dan akan melempar pengecualian jika tanda tangan panggilan tidak benar: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) &gt;&gt;&gt; TypeError: sum() takes <span class="hljs-number"><span class="hljs-number">2</span></span> positional arguments but <span class="hljs-number"><span class="hljs-number">3</span></span> were given</code> </pre> <br><p>  Tetapi ketika memuat skrip, Python tidak akan memberi tahu Anda bahwa fungsi tersebut mengharapkan angka dan bukan string yang Anda masukkan ke dalamnya.  Dan Anda hanya mempelajarinya saat runtime: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y sum(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'10'</span></span>) &gt;&gt;&gt; TypeError: can only concatenate str (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>) to str</code> </pre> <br><p>  Semakin kuat tantangan untuk programmer, <em>terutama saat menulis proyek besar</em> .  Python modern telah menjawab tantangan ini dengan mesin annotation dan tipe library, dan komunitas telah mengembangkan program yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan pengecekan tipe statis</a> .  Akibatnya, pemrogram mempelajari tentang kesalahan seperti itu sebelum menjalankan program: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># main.py: def sum(x: int, y: int) -&gt; int: return x + y sum(10, '10') $ mypy main.py tmp.py:5: error: Argument 2 to "sum" has incompatible type "str"; expected "int"</span></span></code> </pre> <br><p>  Python tidak mementingkan anotasi, meskipun menyimpannya dalam atribut <code>__annotations__</code> .  Satu-satunya syarat adalah bahwa anotasi harus merupakan nilai yang valid dalam hal bahasa.  Sejak kemunculan mereka di versi 3.0 (yang lebih dari sepuluh tahun lalu!), Upaya komunitaslah yang mulai menggunakan anotasi untuk menandai variabel dan argumen yang diketik. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh lain, lebih rumit.</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      , :   :) from typing import TypeVar, Iterable Num = TypeVar('Num', int, float) def sum(items: Iterable[Num]) -&gt; Num: accum = 0 for item in items: accum += item return accum sum([1, 2, 3]) &gt;&gt;&gt; 6</span></span></code> </pre> </div></div><br><p>  <strong>Tip 2:</strong> <em>Dalam praktiknya, kebanyakan pengetikan dinamis menyebabkan masalah saat membaca dan men-debug kode.</em>  <em>Terutama jika kode ini ditulis tanpa anotasi dan Anda harus menghabiskan banyak waktu mencari tahu jenis-jenis variabel.</em>  <em>Anda tidak harus menunjukkan dan mendokumentasikan jenis segala sesuatu dan segalanya, tetapi waktu yang dihabiskan untuk deskripsi rinci antarmuka publik dan bagian kode yang paling kritis akan dihargai seratus kali lipat!</em> </p><br><h3 id="krya-utinaya-tipizaciya">  Dukun!  Mengetik bebek </h3><br><p>  Kadang-kadang, penggemar Python berpura-pura menjadi misterius dan berbicara tentang "mengetik Bebek." <br>  Mengetik bebek adalah penggunaan uji bebek dalam pemrograman: </p><br><blockquote>  Jika suatu benda dukun seperti bebek, terbang seperti bebek dan berjalan seperti bebek, maka kemungkinan besar bebek. </blockquote><p>  Pertimbangkan sebuah contoh: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RpgCharacter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, weapon)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weapon</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">battle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.weapon.attack()</code> </pre> <br><p>  Ini adalah injeksi ketergantungan klasik.  Kelas <code>RpgCharacter</code> menerima objek <code>weapon</code> di konstruktor dan kemudian, dalam metode <code>battle()</code> , memanggil <code>weapon.attack()</code> .  Tetapi <code>RpgCharacter</code> tidak tergantung pada implementasi spesifik <code>weapon</code> .  Itu bisa berupa pedang, BFG 9000, atau ikan paus dengan pot bunga, siap mendarat di kepala musuh kapan saja.  Penting bahwa objek memiliki metode <code>attack()</code> , Python tidak tertarik pada yang lainnya. </p><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="400" src="https://habrastorage.org/webt/l8/ld/yz/l8ldyzcgtvlj3ifvbpnswr2k7ws.png"></a> </div><p></p><br><p>  Sebenarnya, mengetik bebek tidak unik.  Itu hadir dalam semua (akrab dengan saya) bahasa dinamis yang menerapkan OOP. </p><br><p>  Ini adalah contoh lain tentang cara memprogram dengan cermat dalam dunia pengetikan dinamis.  Metode yang tidak disebutkan namanya?  Ambigu bernama variabel?  Kolega Anda, atau Anda sendiri, setelah sekitar setengah tahun, akan dengan senang hati membuat kode seperti itu :) </p><br><div class="spoiler">  <b class="spoiler_title">Apa yang akan terjadi jika kita menggunakan Java kondisional?</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sword</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWeapon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } } public class RpgCharacter { IWeapon weapon; public RpgCharacter(IWeapon weapon) { this.weapon = weapon; } public void battle() { weapon.attack(); } }</span></span></code> </pre> <br><p>  Dan akan ada pengetikan statis klasik, dengan pengecekan tipe pada tahap kompilasi.  Harga - ketidakmampuan untuk menggunakan objek yang memiliki metode <code>attack()</code> , tetapi tidak secara eksplisit mengimplementasikan antarmuka <code>IWeapon</code> . </p></div></div><br><p>  <strong>Tip 3</strong> : <em>Jika mau, Anda bisa mendeskripsikan antarmuka dengan membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas abstrak</a> Anda sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan metode dan properti</a> .</em>  <em>Lebih baik lagi, habiskan waktu untuk menguji dan menulis dokumentasi untuk diri sendiri dan pengguna kode Anda.</em> </p><br><h3 id="procedurnyy-podhod-i-__specialnye_metody__">  Pendekatan prosedural dan __ special_ metode __ () </h3><br><p>  Python adalah bahasa berorientasi <code>object</code> kelas <code>object</code> adalah akar dari hierarki warisan: </p><br><pre> <code class="python hljs">isinstance(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> isinstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, object) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  Tetapi di mana <code>obj.ToString()</code> digunakan dalam Java dan C #, akan ada panggilan ke <code>str(obj)</code> dengan Python.  Atau misalnya, alih-alih <code>myList.length</code> , Python akan memiliki <code>len(my_list)</code> .  Pencipta bahasa, Guido van Rossum, menjelaskan ini sebagai berikut: </p><br><blockquote>  Ketika saya membaca kode yang mengatakan <code>len(x)</code> , saya tahu bahwa panjang sesuatu yang diminta.  Ini segera memberi tahu saya bahwa hasilnya akan berupa bilangan bulat, dan argumennya adalah semacam wadah.  Sebaliknya, ketika membaca <code>x.len()</code> , saya perlu tahu bahwa <code>x</code> adalah semacam wadah yang mengimplementasikan antarmuka tertentu atau mewarisi dari kelas yang memiliki metode <code>len()</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[Sumber]</a> . </blockquote><p>  Namun demikian, di dalam dirinya sendiri, fungsi <code>len()</code> , <code>str()</code> dan beberapa lainnya akan memanggil metode objek tertentu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, last_name)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.last_name = last_name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">f"Honourable </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{self.last_name}</span></span></span><span class="hljs-string">"</span></span> u = User(<span class="hljs-string"><span class="hljs-string">'Alex'</span></span>, <span class="hljs-string"><span class="hljs-string">'Black'</span></span>) label = str(u) print(label) &gt;&gt;&gt; Honourable Alex Black</code> </pre> <br><p>  Metode khusus juga digunakan oleh operator bahasa, baik matematika dan Boolean, serta <code>for ... in ...</code> operator loop, <code>with</code> operator konteks, operator indeks <code>[]</code> , dll. <br>  Misalnya, protokol iterator terdiri dari dua metode: <code>__iter__()</code> dan <code>__next__()</code> : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  Iterable, IEnumerable, std::iterator  .. class InfinitePositiveIntegers: def __init__(self): self.counter = 0 def __iter__(self): """      .    iter(). """ return self def __next__(self): """  .    next(). """ self.counter += 1 return self.counter for i in InfinitePositiveIntegers(): print(i) &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; ... #  ,  Ctrl + C</span></span></code> </pre> <br><p>  Baiklah, katakanlah metode khusus.  Tapi mengapa mereka terlihat begitu bengkok?  Guido menjelaskan hal ini dengan fakta bahwa mereka memiliki nama-nama yang biasa tanpa menggarisbawahi, programmer sendiri tidak akan setidaknya, cepat atau lambat mendefinisikan kembali mereka.  Yaitu  <code>____()</code> adalah semacam perlindungan terhadap si bodoh.  Seperti yang ditunjukkan waktu - perlindungan efektif :) </p><br><p>  <strong>Kiat 4:</strong> <em>Perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi bawaan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode objek khusus</a> .</em>  <em>Mereka adalah bagian integral dari bahasa, yang tanpanya tidak mungkin untuk sepenuhnya berbicara itu.</em> </p><br><h3 id="gde-inkapsulyaciya-gde-moy-private-gde-moya-skazochka">  Di mana enkapsulasi?  Di mana pribadi saya?!  Di mana dongeng saya? !! </h3><br><p>  Python tidak memiliki pengubah akses untuk atribut kelas.  Interior objek terbuka untuk akses tanpa batasan.  Namun, ada konvensi yang menyatakan atribut dengan awalan <code>_</code> dianggap pribadi, misalnya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    _os_handle = None def __init__(self, path: str): self._open(path) #    def _open(self, path): # os.open() - **    . #      open(). #   os.open()    . self._os_handle = os.open(path, os.O_RDWR | os.O_CREAT) #      def close(self): if self._os_handle is not None: os.close(self._os_handle) f = MyFile('/tmp/file.txt') print(f._os_handle) #    ""    ! f.close()</span></span></code> </pre> <br><p>  Mengapa </p><br><blockquote>  Tidak ada yang pribadi di Python.  Baik kelas maupun instansinya tidak akan menyembunyikan dari Anda apa yang ada di dalam (berkat introspeksi terdalam yang dimungkinkan).  Python mempercayai Anda.  Dia semacam berkata, "Sobat, jika Anda ingin mencari-cari di sudut-sudut gelap - tidak masalah. Saya percaya bahwa ada alasan bagus untuk ini dan saya harap Anda tidak akan merusak apa pun. <br><br>  Pada akhirnya, kita semua adalah orang dewasa di sini. <br><br>  - Karl Fast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[Sumber]</a> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Tetapi bagaimana cara menghindari tabrakan nama selama pewarisan?</b> <div class="spoiler_text"><p>  Python memiliki mekanisme khusus untuk mengatur nama atribut yang dimulai dengan garis bawah ganda dan tidak berakhir dengan garis bawah ganda ( <code>__my_attr</code> )!  Ini dilakukan untuk menghindari tabrakan nama selama pewarisan.  Untuk memanggil metode kelas di luar tubuh, Python menambahkan <code>___</code> awalan.  Tetapi untuk akses internal, tidak ada yang berubah: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.__x = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__x c = C() c.__x &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">'C'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'__x'</span></span> print(c.get_x()) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> print(c._C__x) &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  Mari kita lihat aplikasi praktis.  Misalnya, ke kelas <code>File</code> , yang membaca file dari sistem file lokal, kami ingin menambahkan kemampuan caching.  Kolega kami berhasil menulis kelas mixin untuk keperluan ini.  Tetapi untuk mengisolasi metode dan atribut dari <strong>potensi</strong> konflik, seorang rekan menambahkan awalan <code>__</code> ke nama mereka: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseFile</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path)</span></span></span><span class="hljs-function">:</span></span> self.path = path <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_from_local</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(self.path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachedMixin</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMissError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Tepe,         #   __cache,   __from_cache(), # ,     ! self.__cache = {} def __from_cache(self): return self.__cache[self.path] def read_from_cache(self): try: return self.__from_cache() except KeyError as e: raise self.CacheMissError() from e def store_to_cache(self, data): self.__cache[self.path] = data class File(CachedMixin, LocalMixin, BaseFile): def __init__(self, path): CachedMixin.__init__(self) BaseFile.__init__(self, path) def read(self): try: return self.read_from_cache() except CachedMixin.CacheMissError: data = self.read_from_local() self.store_to_cache(data) return data</span></span></code> </pre> <br><p>  Jika Anda tertarik untuk melihat implementasi mekanisme ini di CPython, silakan di <a href="">Python / compile.c</a> </p></div></div><br><p>  Akhirnya, karena keberadaan properti dalam bahasa, tidak masuk akal untuk menulis getter dan setter dalam gaya Java: <code>getX(), setX()</code> .  Misalnya, dalam <code>Coordinates</code> kelas yang awalnya ditulis, </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y c = Coordinates(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) print(cx, cy) &gt;&gt;&gt; (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Saya perlu mengontrol akses ke atribut <code>x</code> .  Pendekatan yang benar adalah menggantinya dengan <code>property</code> , sehingga mempertahankan kontrak dengan dunia luar. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinates</span></span></span><span class="hljs-class">:</span></span> _x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x = x self.y = y @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._x @x.setter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> val &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>: self._x = val <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">'x should be greater than 10'</span></span>) c = Coordinates(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) cx = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; ValueError: x should be greater than <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><p>  <strong>Tip 5:</strong> <em>Seperti Python, konsep bidang privat dan metode kelas didasarkan pada konvensi yang sudah mapan.</em>  <em>Jangan tersinggung oleh penulis perpustakaan jika "semuanya telah berhenti berfungsi" karena Anda telah secara aktif menggunakan bidang pribadi kelas mereka.</em>  <em>Pada akhirnya, kita semua adalah orang dewasa di sini :)</em> . </p><br><h3 id="nemnogo-ob-isklyucheniyah">  Sedikit tentang pengecualian </h3><br><p>  Budaya python memiliki pendekatan unik untuk pengecualian.  Selain intersepsi biasa dan pemrosesan ala C ++ / Java, Anda akan menemukan penggunaan pengecualian dalam konteks </p><br><blockquote>  "Lebih mudah meminta pengampunan, daripada izin - EAFP." </blockquote><p>  Mengutip - jangan menulis terlalu banyak <code>if</code> , dalam kebanyakan kasus, eksekusi akan dilakukan pada cabang ini.  Alih-alih, bungkus logika di <code>try..except</code> . </p><br><p>  Contoh: bayangkan penangan permintaan POST yang membuat pengguna dalam database bersyarat.  Di input fungsi adalah kamus tipe kunci-nilai: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Dict[str, str])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> <br><p>  Kami tidak mencemari kode dengan cek "apakah <code>username</code> atau <code>password</code> terkandung dalam <code>data</code> ".  Kami berharap mereka kemungkinan besar akan ada di sana.  Kami tidak meminta "izin" untuk menggunakan bidang ini, tetapi "minta maaf" ketika kulhacker berikutnya memposting formulir dengan data yang hilang. </p><br><div class="spoiler">  <b class="spoiler_title">Hanya saja, jangan membawanya ke titik absurditas!</b> <div class="spoiler_text"><p>  Misalnya, Anda ingin memeriksa apakah nama belakang pengguna ada dalam data dan jika tidak disetel ke nilai kosong.  <code>if</code> sini akan jauh lebih tepat: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_user_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'last_name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: database.user.persist( username=data[<span class="hljs-string"><span class="hljs-string">'username'</span></span>], password=data[<span class="hljs-string"><span class="hljs-string">'password'</span></span>], last_name=data[<span class="hljs-string"><span class="hljs-string">'last_name'</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: print(<span class="hljs-string"><span class="hljs-string">'There was a missing field in data passed for user creation'</span></span>)</code> </pre> </div></div><br><p>  <strong>Kesalahan tidak boleh terjadi secara diam-diam.</strong>  - jangan abaikan pengecualian!  Python modern memiliki peningkatan yang luar biasa <code>raise from</code> konstruk yang memungkinkan Anda untuk mempertahankan konteks rantai pengecualian.  Sebagai contoh: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProductError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(<span class="hljs-string"><span class="hljs-string">'There has been a terrible product error'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / x <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> MyProductError() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> e</code> </pre> <br><p>  Tanpa <code>raise from e</code> rantai pengecualian terputus pada <code>MyProductError</code> , dan kami tidak dapat menemukan apa sebenarnya penyebab kesalahan ini.  Dengan <code>raise from X</code> , alasan (mis. <code>X</code> ) dari pengecualian yang dilemparkan disimpan dalam atribut <code>__cause__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: calculate(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> MyProductError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(e.__cause__) &gt;&gt;&gt; division by zero</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tetapi ada sedikit nuansa dalam hal iterasi: StopIteration</b> <div class="spoiler_text"><p>  Dalam kasus iterasi, melemparkan pengecualian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StopIteration</a> adalah cara resmi untuk memberi sinyal bahwa iterator telah selesai. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositiveIntegers</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, limit)</span></span></span><span class="hljs-function">:</span></span> self.counter = <span class="hljs-number"><span class="hljs-number">0</span></span> self.limit = limit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__next__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.counter += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.counter == self.limit: <span class="hljs-comment"><span class="hljs-comment">#  hasNext()  moveNext(), #  ,   raise StopIteration() return self.counter for i in PositiveIntegers(5): print(i) &gt; 1 &gt; 2 &gt; 3 &gt; 4</span></span></code> </pre> </div></div><br><p>  <strong>Kiat 6:</strong> <em>Kami membayar untuk penanganan pengecualian hanya dalam situasi luar biasa.</em>  <em>Jangan abaikan mereka!</em> </p><br><h3 id="there-should-be-one---and-preferably-only-one---obvious-way-to-do-it">  Harus ada satu - dan lebih disukai hanya satu - cara sebelumnya untuk melakukannya. </h3><br><p>  <code>switch</code> atau pencocokan pola?  - gunakan <code>if</code> dan kamus.  <code>do-</code> ?  - untuk ini ada <code>while</code> dan <code>for</code> .  <code>goto</code>  Saya pikir Anda sendiri yang menebaknya.  Hal yang sama berlaku untuk beberapa teknik desain dan pola yang tampaknya diterima begitu saja dalam bahasa lain.  Yang paling menakjubkan adalah tidak ada batasan teknis dalam implementasinya, hanya saja "kami tidak memiliki cara seperti itu". </p><br><p>  Misalnya, dalam Python Anda tidak sering melihat pola "Builder".  Sebagai gantinya, ia menggunakan kemampuan untuk lulus dan secara eksplisit meminta argumen nama ke fungsi.  Sebaliknya </p><br><pre> <code class="python hljs">human = HumanBuilder.withName(<span class="hljs-string"><span class="hljs-string">"Alex"</span></span>).withLastName(<span class="hljs-string"><span class="hljs-string">"Black"</span></span>).ofAge(<span class="hljs-number"><span class="hljs-number">20</span></span>).withHobbies([<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>]).build()</code> </pre> <br><p>  akan </p><br><pre> <code class="python hljs">human = Human( name=<span class="hljs-string"><span class="hljs-string">"Alex"</span></span> last_name=<span class="hljs-string"><span class="hljs-string">"Black"</span></span> age=<span class="hljs-number"><span class="hljs-number">20</span></span> hobbies=[<span class="hljs-string"><span class="hljs-string">'tennis'</span></span>, <span class="hljs-string"><span class="hljs-string">'programming'</span></span>] )</code> </pre> <br><p>  Perpustakaan standar tidak menggunakan rantai metode untuk bekerja dengan <em>koleksi</em> .  Saya ingat bagaimana seorang kolega yang datang dari dunia Kotlin menunjukkan kode pengertian berikut kepada saya (diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> untuk Kotlin): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shortGreetings = people .filter { it.name.length &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> } .map { <span class="hljs-string"><span class="hljs-string">"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it.name}</span></span></span><span class="hljs-string">!"</span></span> }</code> </pre> <br><p>  Dalam Python, <code>map()</code> , <code>filter()</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak lainnya,</a> adalah fungsi, bukan metode pengumpulan.  Menulis ulang kode ini satu per satu, kita dapatkan: </p><br><pre> <code class="python hljs">short_greetings = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: <span class="hljs-string"><span class="hljs-string">f"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span>, filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> h: len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>, people))</code> </pre> <br><p>  Menurut saya itu terlihat mengerikan.  Oleh karena itu, untuk bundel panjang seperti <code>.takewhile().filter().map().reduce()</code> lebih baik menggunakan apa yang disebut  <em>inklusi</em> (pemahaman), atau siklus lama yang baik.  Ngomong-ngomong, contoh yang sama tentang Kotlin diberikan dalam bentuk pemahaman daftar yang sesuai.  Dan pada Python terlihat seperti ini: </p><br><pre> <code class="python hljs">short_greetings = [ <span class="hljs-string"><span class="hljs-string">f"Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{h.name}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> h <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> people <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(h.name) &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagi mereka yang merindukan rantai</b> <div class="spoiler_text"><p>  Ada perpustakaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pipe</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">py_linq</a> ! </p></div></div><br><p>  Rantai metode digunakan di mana mereka lebih efisien daripada alat standar.  Misalnya, dalam kerangka kerja Django web, rantai digunakan untuk membangun objek permintaan basis data: </p><br><pre> <code class="python hljs">query = User.objects \ .filter(last_visited__gte=<span class="hljs-string"><span class="hljs-string">'2019-05-01'</span></span>) \ .order_by(<span class="hljs-string"><span class="hljs-string">'username'</span></span>) \ .values(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, <span class="hljs-string"><span class="hljs-string">'last_visited'</span></span>) \ [:<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre> <br><p>  <strong>Tip 7:</strong> <em>Sebelum Anda melakukan sesuatu yang sangat akrab dari pengalaman masa lalu, tetapi tidak terbiasa dengan Python, tanyakan pada diri sendiri keputusan apa yang akan dilakukan oleh pythonist berpengalaman?</em> </p><br><h3 id="piton-medlennyy">  Python lambat </h3><br><p>  Ya </p><br><p>  Ya, ketika menyangkut kecepatan eksekusi dibandingkan dengan bahasa yang diketik dan dikompilasi secara statis. </p><br><p>  Tetapi apakah Anda sepertinya menginginkan jawaban yang terperinci? </p><br><p>  Implementasi referensi python (CPython) jauh dari implementasi yang paling efektif.  Salah satu alasan penting adalah keinginan pengembang untuk tidak menyulitkannya.  Dan logikanya dapat dimengerti - kode yang tidak terlalu muskil berarti lebih sedikit kesalahan, kesempatan yang lebih baik untuk melakukan perubahan, dan pada akhirnya, lebih banyak orang yang ingin membaca, memahami dan menambah kode ini. </p><br><p>  Jake VanderPlas di blognya mem-parsing <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa yang terjadi di CPython di bawah tenda</a> ketika menambahkan dua variabel yang mengandung nilai integer: </p><br><pre> <code class="python hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> c = a + b</code> </pre> <br><p>  Bahkan jika kita tidak pergi jauh ke dalam hutan CPython, kita dapat mengatakan bahwa untuk menyimpan variabel <code>a</code> , <code>b</code> dan <code>c</code> , penerjemah harus membuat tiga objek di heap, di mana tipe dan (pointer ke) nilai akan disimpan;  <code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code> kembali tipe dan nilai selama operasi penambahan untuk memanggil sesuatu seperti <code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code> ;  tulis hasilnya ke <code>c</code> . <br>  Ini sangat tidak efisien dibandingkan dengan program C serupa. </p><br><p>  Masalah lain dengan CPython adalah apa yang disebut  Global Interpreter Lock (GIL).  Mekanisme ini, pada dasarnya nilai boolean yang dilampirkan oleh mutex, digunakan untuk menyinkronkan eksekusi bytecode.  GIL menyederhanakan pengembangan kode yang berjalan di lingkungan multi-threaded: CPython tidak perlu berpikir tentang sinkronisasi akses ke variabel atau deadlock.  Anda harus membayar untuk ini karena hanya satu utas yang mendapatkan akses dan <em>mengeksekusi bytecode</em> pada waktu tertentu: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/od/if/rwodifh_niof7jaf5bvmagg4ypy.gif"></div><br><p>  <strong>UPD:</strong> Tetapi ini tidak berarti bahwa program pada Python secara ajaib akan bekerja di lingkungan multi-utas!  Kode pada Python tidak ditransfer ke bytecode satu per satu dan tidak ada jaminan tentang kompatibilitas bytecode antara versi!  Karena itu, Anda masih harus menyinkronkan utas dalam kode.  Untungnya, di sini Python memiliki seperangkat alat yang kaya, misalnya, memungkinkan Anda untuk beralih antara model eksekusi multi-threaded dan multi-proses. </p><br><div class="spoiler">  <b class="spoiler_title">Jika Anda ingin tahu tentang upaya apa yang sedang dilakukan untuk membasmi GIL</b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sarankan membaca artikel Anthony Shaw " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Python GIL telah disembelih?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font></p></div></div><br><p>    ? </p><br><ol><li>      .    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CFFI</a> )              .           API    (extensions)  C/C++.    ,      Rust, Go   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin Native</a> ! </li><li>    , : <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyPy</a> ,   JIT-.    ,     ,          ? </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cython</a> —      Python    C. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IronPython</a> — ,   .NET framework. </li></ul></li></ol><br><p> <strong> 8:</strong> <em>     ,              .      ,   IO (, ,  )   ,    ,      ,    ,     :)</em> </p><br><h3 id="osnovnye-instrumenty">   </h3><br><p>      ?      Linux  MacOS,   95%      .      ,      3.,       2.7.    Windows   .   :  Docker, Windows Subsystem for Linux, Cygwin, ,     . </p><br><p> <strong> 9:</strong> <em>     .  ,   —       -   .</em> </p><br><p>    "Hello world"   ?  Hebat!      machine learning-    -    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python Package Index</a> (PyPI). </p><br><p>        (packages),    ..   (virtual environments).        ,      .     -    .   <code>pip</code>    .     <code>pip</code>      .      ,  <code>pipenv</code>  <code>poetry</code> —  npm, bundler, cargo  .. </p><br><p> <strong> 0xA:</strong> <em>      —  <code>pip</code>  <code>virtualenv</code> .   —  , ,  .  ,      —   <code>sys.path</code> —  ,        .</em> </p><br><h3 id="chto-zhe-dalshe">   ? </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ?       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> .     : </p><br><blockquote>      Dive into python... </blockquote><p> ,               .              , ,     :) </p><br><p> , ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450724/">https://habr.com/ru/post/id450724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450710/index.html">Rekonstruksi Midi dari video Synthesia (dan sejenisnya)</a></li>
<li><a href="../id450712/index.html">DotNetRu at DotNext 2019 Piter</a></li>
<li><a href="../id450716/index.html">Mengumumkan Keterampilan Visi Windows (Pratinjau)</a></li>
<li><a href="../id450718/index.html">Apa yang Baru di RxJS v6.5</a></li>
<li><a href="../id450720/index.html">Cara Mengembangkan Aplikasi yang Ramah Pengguna</a></li>
<li><a href="../id450726/index.html">Membuat alat untuk menulis autotests dengan cepat dan efisien di Selenium</a></li>
<li><a href="../id450728/index.html">NLog: aturan dan filter</a></li>
<li><a href="../id450730/index.html">ok.tech: pertemuan frontend</a></li>
<li><a href="../id450732/index.html">Begitu ya, artinya saya ada: ulasan Deep Learning in Computer Vision (bagian 1)</a></li>
<li><a href="../id450734/index.html">Fuzzing adalah langkah penting dalam pengembangan yang aman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>