<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 🖤 🐼 Gatsby.js详细 🥠 ✋🏿 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如您所知，您不能仅在某些样板上走得太远，因此您必须深入研究任何技术来学习如何编写有价值的东西。 本文讨论了Gatsby.js的详细信息，该知识将使您能够创建和维护复杂的网站和博客。 
 上一篇有关如何使用JAM-stack创建和发布个人博客的文章 

 下面讨论的主题： 


- 页面结构和路由 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gatsby.js详细</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442298/"><p><img src="https://habrastorage.org/webt/05/2c/ll/052cllvfmcuw_rru5rhjwhxxqem.jpeg"></p><br><p> 如您所知，您不能仅在某些样板上走得太远，因此您必须深入研究任何技术来学习如何编写有价值的东西。 本文讨论了<strong>Gatsby.js</strong>的详细信息，该知识将使您能够创建和维护复杂的网站和博客。 </p><a name="habracut"></a><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇</a>有关如何使用JAM-stack创建和发布个人博客的文章 </blockquote><p> 下面讨论的主题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面结构和路由</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组件，模板及其交互</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">处理数据</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">外挂程式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用程式样式</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用React-Helmet进行SEO优化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PWA设置</a> </li></ul><br><h2 id="podgotovka"> 准备工作 </h2><br><div class="spoiler">  <b class="spoiler_title">在PC上安装Gatsby</b> <div class="spoiler_text"><pre><code class="bash hljs">yarn global add gatsby-cli</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">克隆最小项目</b> <div class="spoiler_text"><pre> <code class="bash hljs"> npx gatsby new gatsby-tutorial https://github.com/gatsbyjs/gatsby-starter-hello-world <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gatsby-tutorial</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">储存库初始化</b> <div class="spoiler_text"><pre> <code class="bash hljs"> git init git add . git commit -m <span class="hljs-string"><span class="hljs-string">"init commit"</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">健康检查</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> yarn start</code> </pre> <br><p> 如果控制台中以及浏览器中路径<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：8000</a>都没有错误， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您将</a>看到“ Hello world！”。 这意味着一切正常。 您可以尝试更改<em>/src/pages/index.js</em>文件的内容以检查是否有热重载。 </p></div></div><br><h2 id="struktura-stranic-i-routing"> 页面结构和路由 </h2><br><p> 要在Gatsby中创建页面，只需将新文件放在<em>/ src / pages</em>文件夹中，它将被编译成单独的HTML页面。  <strong>请务必注意，此页面的路径将与名称为的实际路径相对应</strong> 。 例如，再添加几页： </p><br><pre> <code class="plaintext hljs">src └── pages ├── about.js ├── index.js └── tutorial ├── part-four.js ├── part-one.js ├── part-three.js ├── part-two.js └── part-zero.js</code> </pre><br><p> 内容还不重要，因此可以使用任何文本来区分页面。 </p><br><pre> <code class="plaintext hljs">import React from "react"; export default () =&gt; &lt;div&gt;Welcome to tutorial/part-one&lt;/div&gt;;</code> </pre> <br><p> 签入浏览器： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTTP：//本地主机：8000 /教程/第一部分</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：//本地主机：8000 /关于</a> </li></ul><br><p> 这样，在构建文件时，您可以立即解决路由问题。 </p><br><blockquote> 还有一个特殊的<strong>createPage API</strong> ，您可以使用它来更灵活地控制页面的路径和名称，但是要使用它，我们需要了解Gatsby中数据的操作，因此在本文中我们将对其进行进一步的考虑。 </blockquote><p> 使用链接合并创建的页面，为此，我们使用了Gatsby包中的<code>&lt;Link /&gt;</code>组件，该组件是专门为内部导航而创建的。 对于所有外部链接，请使用常规的<code>&lt;a&gt;</code>标记。 </p><br><p>  <em>/src/pages/index.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { Link } from "gatsby"; export default () =&gt; ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/about"&gt;about&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-zero"&gt;Part #0&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-one"&gt;Part #1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-two"&gt;Part #2&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-three"&gt;Part #3&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-four"&gt;Part #4&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );</code> </pre> <br><blockquote> 引擎盖下的<code>&lt;Link&gt;</code>具有用于优化页面加载的非常棘手的机制，因此可以代替<code>&lt;a&gt;</code>来导航站点。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到更多详细信息。 </blockquote><p><img src="https://habrastorage.org/webt/no/ev/fj/noevfjkjdbel6tonxughcn6mkfq.gif" alt="导航"></p><br><p> 创建页面，添加链接，事实证明导航已完成。 </p><br><h2 id="komponenty-shablony-i-ih-vzaimodeystvie"> 组件，模板及其交互 </h2><br><p> 如您所知，在任何项目中总是有重复元素，对于网站来说，它是页眉，页脚，导航栏。 同样，页面（无论内容如何）都是根据某种结构构建的，并且由于<strong>Gatsby</strong>是<strong>React</strong>的编译器，因此使用相同的组件方法来解决这些问题。 </p><br><p> 创建标题和导航面板的组件： </p><br><p>  <em>/src/components/header.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { Link } from "gatsby"; /** *         *  ,     React-. *      ,    *  " ".     *    ""  GraphQL  gatsby- */ import logoSrc from "../images/logo.png"; export default () =&gt; ( &lt;header&gt; &lt;Link to="/"&gt; &lt;img src={logoSrc} alt="logo" width="60px" height="60px" /&gt; &lt;/Link&gt; That is header &lt;/header&gt; );</code> </pre> <br><p>  <em>/src/components/sidebar.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { Link } from "gatsby"; export default () =&gt; ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to="/about"&gt;about&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-zero"&gt;Part #0&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-one"&gt;Part #1&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-two"&gt;Part #2&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-three"&gt;Part #3&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to="/tutorial/part-four"&gt;Part #4&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );</code> </pre> <br><p> 并将它们添加到<em>/src/pages/index.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import Header from "../components/header"; import Sidebar from "../components/sidebar"; export default () =&gt; ( &lt;div&gt; &lt;Header /&gt; &lt;Sidebar /&gt; &lt;h1&gt;Index page&lt;/h1&gt; &lt;/div&gt; );</code> </pre> <br><p> 我们检查： </p><br><p><img src="https://habrastorage.org/webt/bg/l6/jn/bgl6jndogi4j0qzvm9q0jvsiglk.jpeg" alt="index_page"></p><br><p> 一切正常，但是我们需要分别在每个页面上导入Header和Sidebar，这不是很方便，要解决此问题，创建一个布局组件并用它包装每个页面就足够了。 </p><br><blockquote> 盖茨比布局==反应容器 <br>  <em>是的，这不是严格的平等，因为这几乎是同一件事</em> </blockquote><p>  <em>/src/components/layout.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import Header from "./header"; import Sidebar from "./sidebar"; export default ({ children }) =&gt; ( &lt;&gt; &lt;Header /&gt; &lt;div style={{ margin: `0 auto`, maxWidth: 650, backgroundColor: `#eeeeee` }} &gt; &lt;Sidebar /&gt; {children} &lt;/div&gt; &lt;/&gt; );</code> </pre> <br><p>  <em>/src/pages/index.js</em> （以及所有其他页面） </p><br><pre> <code class="plaintext hljs">import React from "react"; import Layout from "../components/layout"; export default () =&gt; ( &lt;Layout&gt; &lt;h1&gt;Index page&lt;/h1&gt; &lt;/Layout&gt; );</code> </pre> <br><p> 完成，看一下浏览器： </p><br><p><img src="https://habrastorage.org/webt/9p/9v/wo/9p9vwogkf2px--00mtzbgz2ke64.gif" alt="布局图"></p><br><blockquote> 为什么项目的所有文件名都带有小写字母？ 首先，让我们确定<strong>React的</strong>命名空间来自以下事实：“每个文件都是一个类，并且该类总是大写。” 在<strong>Gatsby中，</strong>文件仍然包含类，但是有一个“但是”-“每个文件是潜在页面，其名称是该页面的URL”。 社区得出的结论是，像<code>http://domain.com/User/Settings</code>这样的链接不是<em>comme-il-faut</em> ，也不是<em>kebab</em> -case的文件名。 </blockquote><br><div class="spoiler">  <b class="spoiler_title">档案结构</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> src ├── components │ ├── header.js │ ├── layout.js │ └── sidebar.js ├── images │ └── logo.png └── pages ├── about.js ├── index.js └── tutorial ├── part-eight.js ├── part-five.js ├── part-four.js ├── part-one.js ├── part-seven.js ├── part-six.js ├── part-three.js ├── part-two.js └── part-zero.js</code> </pre> </div></div><br><h2 id="rabota-s-dannymi"> 处理数据 </h2><br><p> 现在站点结构已准备就绪，您可以继续进行内容填充。 经典的“硬代码”方法不适合JAM堆栈的创建者，也不适合“从AJAX请求中呈现内容”，因此，他们建议在编译时用内容填充站点。 对于<strong>Gatsby而言</strong> ， <strong>GraphQL</strong>对此负责，这使您可以方便地使用任何来源的数据流。 </p><br><blockquote> 简而言之谈论GraphQL是不可能的，因此建议您自己研究它或等待我的下一篇文章。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关使用GraphQL的更多信息。 </blockquote><p> 为了与<strong>GraphQL</strong>一起<strong>使用</strong> ，从第二个版本开始， <code>gatsby</code>软件包具有一个<code>gatsby</code>组件，该组件既可以在页面上使用，也可以在简单组件中使用，这是它与先前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面查询的</a>主要区别。 到目前为止，我们的网站尚未连接任何数据源，因此，让我们尝试显示页面的元数据，例如，然后继续进行更复杂的事情。 </p><br><p> 要生成<code>query</code>您需要打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：//本地主机：8000 / ___ graphql</a> ，并在文档中使用侧边栏来查找有关该站点的可用数据，并且不要忘记自动完成。 </p><br><p><img src="https://habrastorage.org/webt/qw/im/yd/qwimydi9eummj2mlkdpuzxdlg_0.gif" alt="图"></p><br><p>  <em>/src/components/sidebar.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { Link, StaticQuery, graphql } from "gatsby"; export default () =&gt; ( &lt;StaticQuery query={graphql` { allSitePage { edges { node { id path } } } } `} render={({ allSitePage: { edges } }) =&gt; ( &lt;ul&gt; {edges.map(({ node: { id, path } }) =&gt; ( &lt;li key={id}&gt; &lt;Link to={path}&gt;{id}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; )} /&gt; );</code> </pre> <br><p> 现在，使用<code>query</code>我们可以获取有关在导航面板中呈现的页面的数据，而不必担心链接不匹配名称这一事实，因为所有数据都是自动收集的。 </p><br><p><img src="https://habrastorage.org/webt/nc/pk/6l/ncpk6l8hirx9guim5am6ikgpfvo.jpeg" alt="queried_navigation_panel"></p><br><p> 实际上，所有这些数据都可以在我们的网站上使用，而无需使用第三方插件，也无需使用良好的旧“硬编码”，因此，我们顺利地进行了本文的下一个主题-插件。 </p><br><h2 id="plaginy"> 外挂程式 </h2><br><p>  Gatsby的核心是带有许多插件的编译器。 使用它们，您可以自定义某些文件，数据类型和各种格式的处理。 </p><br><p> 在应用程序的根目录级别创建文件<em>/gatsby-config.js</em> 。 它负责整个编译器的配置，并尝试配置第一个用于处理文件的插件： </p><br><p> 插件安装： </p><br><pre> <code class="bash hljs">yarn add gatsby-source-filesystem</code> </pre> <br><p> 在<em>/gatsby-config.js</em>文件中进行配置<em>：</em> </p><br><pre> <code class="plaintext hljs">module.exports = { plugins: [ { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/`, } } ], }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">有关上述文件的更多详细信息</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /** * gatsby-config.js     *     JS *     */ module.exports = { /** *  'plugins'  pipeline  * ,      */ plugins: [ /** *        , *         */ `gatsby-example-plugin`, { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/`, } } ], }</code> </pre> </div></div><br><p> 还记得我们谈论过将正确的图像导入<strong>Gatsby</strong>吗？ </p><br><p>  <em>/src/components/header.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { Link, StaticQuery, graphql } from "gatsby"; export default () =&gt; ( &lt;StaticQuery query={graphql` { allFile(filter: { name: { eq: "logo" } }) { edges { node { publicURL } } } } `} render={({ allFile: { edges: [ { node: { publicURL } } ] } }) =&gt; ( &lt;header&gt; &lt;Link to="/"&gt; &lt;img src={publicURL} alt="logo" width="60px" height="60px" /&gt; &lt;/Link&gt; That is header &lt;/header&gt; )} /&gt; );</code> </pre> <br><p> 该站点上没有任何更改，但是现在使用GraphQL代替了图片，而不是简单的Webpack导入。 乍一看，设计似乎太复杂了，是不必要的手势，但是我们不要急于下结论，因为事情是在同一个插件中。 例如，如果我们决定在网站上发布数千张照片，那么无论如何我们都必须考虑优化所有内容的加载，并且为了不从头开始构建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟加载过程</a> ，我们只需添加一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gatsby-image</a>插件即可优化所有内容的加载使用<code>query</code>导入的图片。 </p><br><p> 安装样式插件： </p><br><pre> <code class="bash hljs">yarn add gatsby-plugin-typography react-typography typography typography-theme-noriega node-sass gatsby-plugin-sass gatsby-plugin-styled-components styled-components babel-plugin-styled-components</code> </pre> <br><p>  <em>gatsby-config.js</em> </p><br><pre> <code class="plaintext hljs">module.exports = { plugins: [ { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/` } }, // add style plugins below `gatsby-plugin-typography`, `gatsby-plugin-sass`, `gatsby-plugin-styled-components` ] };</code> </pre> <br><blockquote> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站上，</a>您可以找到适合各种口味的插件。 </blockquote><br><h2 id="stilizaciya-prilozheniya"> 应用程式样式 </h2><br><p> 让我们开始使用各种方法来设计应用程序的样式。 在上一步中，我们已经安装了用于处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SASS的</a>插件， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样式化组件</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">typography.js</a>库，但需要注意的是，现成的css.modules支持。 </p><br><p> 让我们从全局样式开始，与其他与整个网站相关的样式一样，全局样式必须在<em>/gatsby-browser.js</em>文件中进行配置： </p><br><pre> <code class="plaintext hljs">import "./src/styles/global.scss";</code> </pre> <br><blockquote> 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gatsby-browser.js的</a>更多信息 </blockquote><p>  <em>/src/styles/global.scss</em> </p><br><pre> <code class="plaintext hljs">body { background-color: lavenderblush; }</code> </pre> <br><p> 由于各种原因，近年来的趋势倾向于“ CSS in JS”方法，因此您不应滥用全局样式，最好将自己限制在指示字体和重用的类上。 该特定项目计划将<strong>Typography.js</strong>用于这些目的，因此全局样式将保持空白。 </p><br><p> 在将<code>gatsby-plugin-typography</code>添加到配置后，您可能已经注意到站点外观的变化-这是因为已应用其默认预设，现在我们将为自己配置它。 </p><br><p>  <em>/src/utils/typography.js</em> </p><br><pre> <code class="plaintext hljs">import Typography from "typography"; import theme from "typography-theme-noriega"; const typography = new Typography(theme); export default typography;</code> </pre> <br><blockquote> 您可以从<a href="">列表中</a>选择其他任何预设，也可以使用软件包API创建自己的预设（Gatsby官方网站<a href="">的</a>配置<a href="">示例</a> ） </blockquote><p>  <em>/gatsby-config.js</em> </p><br><pre> <code class="plaintext hljs">module.exports = { plugins: [ { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/` } }, { resolve: `gatsby-plugin-typography`, options: { pathToConfigModule: `src/utils/typography` } }, `gatsby-plugin-sass`, `gatsby-plugin-styled-components` ] };</code> </pre> <br><p> 并且根据所选的预设，站点的全局样式将被更改。 确定哪种方法可以为自己设置全局样式，这是技术上的个人喜好和差异的问题，但是我们将继续使用<strong>styled-components</strong>对组件进行<strong>样式设置</strong> ： </p><br><p> 添加具有全局变量<em>/src/utils/vars.js</em>的文件 </p><br><pre> <code class="plaintext hljs">export const colors = { main: `#663399`, second: `#fbfafc`, main50: `rgba(102, 51, 153, 0.5)`, second50: `rgba(251, 250, 252, 0.5)`, textMain: `#000000`, textSecond: `#ffffff`, textBody: `#222222` };</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">/src/components/header.js</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> import React from "react"; import { Link, StaticQuery, graphql } from "gatsby"; import styled from "styled-components"; import { colors } from "../utils/vars"; const Header = styled.header` width: 100%; height: 3em; display: flex; justify-content: space-between; align-items: center; background-color: ${colors.main}; color: ${colors.textSecond}; padding: 0.5em; `; const Logo = styled.img` border-radius: 50%; height: 100%; `; const logoLink = `height: 100%;`; export default () =&gt; ( &lt;StaticQuery query={graphql` { allFile(filter: { name: { eq: "logo" } }) { edges { node { publicURL } } } } `} render={({ allFile: { edges: [ { node: { publicURL } } ] } }) =&gt; ( &lt;Header&gt; That is header &lt;Link to="/" css={logoLink}&gt; &lt;Logo src={publicURL} alt="logo" /&gt; &lt;/Link&gt; &lt;/Header&gt; )} /&gt; );</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">/src/components/sidebar.js</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> import React from "react" import { Link, StaticQuery, graphql } from "gatsby" import styled from "styled-components" import { colors } from "../utils/vars" const Sidebar = styled.section` position: fixed; left: 0; width: 20%; height: 100%; display: flex; flex-direction: column; justify-content: center; background-color: ${colors.second}; color: ${colors.textMain}; ` const navItem = ` display: flex; align-items: center; margin: 0 1em 0 2em; padding: 0.5em 0; border-bottom: 0.05em solid ${colors.mainHalf}; postion: relative; color: ${colors.textBody}; text-decoration: none; &amp;:before { content: ''; transition: 0.5s; width: 0.5em; height: 0.5em; position: absolute; left: 0.8em; border-radius: 50%; display: block; background-color: ${colors.main}; transform: scale(0); } &amp;:last-child { border-bottom: none; } &amp;:hover { &amp;:before { transform: scale(1); } } ` export default () =&gt; ( &lt;StaticQuery query={graphql` { allSitePage { edges { node { id, path } } } } `} render={({ allSitePage: { edges } }) =&gt; ( &lt;Sidebar&gt; { edges.map(({ node: { id, path } }) =&gt; ( &lt;Link to={path} key={id} css={navItem} &gt;{id}&lt;/Link&gt; )) } &lt;/Sidebar&gt; )} /&gt; )</code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/qf/1w/i6/qf1wi6f95fjjjx794g8qvujbksw.gif" alt="风格的"></p><br><p> 已经对现有元素进行了样式化，是时候将内容与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Contentful</a>关联，连接margin插件并使用<strong>createPages API</strong>生成页面了。 </p><br><blockquote> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中</a>阅读有关如何链接Gatsby和Contentful的更多信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </blockquote><br><div class="spoiler">  <b class="spoiler_title">内容丰富的数据结构</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> [ { "id": "title", "type": "Symbol" }, { "id": "content", "type": "Text", }, { "id": "link", "type": "Symbol", }, { "id": "orderNumber", "type": "Integer", } ]</code> </pre> </div></div><br><p> 软件包安装： </p><br><pre> <code class="bash hljs">yarn add dotenv gatsby-source-contentful gatsby-transformer-remark</code> </pre> <br><p>  <em>/gatsby-config.js</em> </p><br><pre> <code class="plaintext hljs">if (process.env.NODE_ENV === "development") { require("dotenv").config(); } module.exports = { plugins: [ `gatsby-transformer-remark`, { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/`, } }, { resolve: `gatsby-plugin-typography`, options: { pathToConfigModule: `src/utils/typography`, }, }, { resolve: `gatsby-source-contentful`, options: { spaceId: process.env.CONTENTFUL_SPACE_ID, accessToken: process.env.CONTENTFUL_ACCESS_TOKEN, }, }, `gatsby-plugin-sass`, `gatsby-plugin-styled-components`, ], }</code> </pre> <br><p> 删除包含所有文件的<em>/ src / pages</em>文件夹，并创建一个新文件来管理Gatsby中的节点： </p><br><p>  <em>/gatsby-node.js</em> </p><br><pre> <code class="plaintext hljs">const path = require(`path`); /** *  ,      *       */ exports.createPages = ({ graphql, actions }) =&gt; { /** *        *        *    */ const { createPage } = actions; return graphql(` { allContentfulArticle { edges { node { title link content { childMarkdownRemark { html } } } } } } `).then(({ data: { allContentfulArticle: { edges } } }) =&gt; { /** *       *  createPage()    *      */ edges.forEach(({ node }) =&gt; { createPage({ path: node.link, component: path.resolve(`./src/templates/index.js`), context: { slug: node.link } }); }); }); };</code> </pre> <br><blockquote> 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gatsby-node.js的</a>更多信息 </blockquote><p> 创建一个模板文件，它将作为生成页面的基础 <br>  <em>/src/templates/index.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { graphql } from "gatsby"; import Layout from "../components/layout"; export default ({ data: { allContentfulArticle: { edges: [ { node: { content: { childMarkdownRemark: { html } } } } ] } } }) =&gt; { return ( &lt;Layout&gt; &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt; &lt;/Layout&gt; ); }; export const query = graphql` query($slug: String!) { allContentfulArticle(filter: { link: { eq: $slug } }) { edges { node { title link content { childMarkdownRemark { html } } } } } } `;</code> </pre> <br><blockquote> 为什么在这里不使用<code>&lt;StaticQuery /&gt;</code>组件？ 事实是，它不支持用于构造请求的变量，但是我们需要使用页面上下文中的<code>$slug</code>变量。 </blockquote><br><div class="spoiler">  <b class="spoiler_title">更新导航栏中的逻辑</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> import React from "react"; import { Link, StaticQuery, graphql } from "gatsby"; import styled from "styled-components"; import { colors } from "../utils/vars"; const Sidebar = styled.section` position: fixed; left: 0; width: 20%; height: 100%; display: flex; flex-direction: column; justify-content: center; background-color: ${colors.second}; color: ${colors.textMain}; `; const navItem = ` display: flex; align-items: center; margin: 0 1em 0 2em; padding: 0.5em 0; border-bottom: 0.05em solid ${colors.main50}; postion: relative; color: ${colors.textBody}; text-decoration: none; &amp;:before { content: ''; transition: 0.5s; width: 0.5em; height: 0.5em; position: absolute; left: 0.8em; border-radius: 50%; display: block; background-color: ${colors.main}; transform: scale(0); } &amp;:last-child { border-bottom: none; } &amp;:hover { &amp;:before { transform: scale(1); } } `; export default () =&gt; ( &lt;StaticQuery query={graphql` { allContentfulArticle(sort: { order: ASC, fields: orderNumber }) { edges { node { title link orderNumber } } } } `} render={({ allContentfulArticle: { edges } }) =&gt; ( &lt;Sidebar&gt; {edges.map(({ node: { title, link, orderNumber } }) =&gt; ( &lt;Link to={link} key={link} css={navItem}&gt; {orderNumber}. {title} &lt;/Link&gt; ))} &lt;/Sidebar&gt; )} /&gt; );</code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/fn/bc/fs/fnbcfsl-qbdzkh1murfclmr7itk.gif" alt="资料"></p><br><h2 id="seo-optimizaciya">  SEO优化 </h2><br><p> 在技​​术方面，可以认为该站点已经准备就绪，因此让我们处理其元数据。 为此，我们需要以下插件： </p><br><pre> <code class="bash hljs">yarn add gatsby-plugin-react-helmet react-helmet</code> </pre> <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-helmet</a>为HTML页面生成<code>&lt;head&gt;...&lt;/head&gt;</code> ，并与Gatsby渲染结合使用，是使用SEO的强大而便捷的工具。 </blockquote><p>  <em>/src/templates/index.js</em> </p><br><pre> <code class="plaintext hljs">import React from "react"; import { graphql } from "gatsby"; import { Helmet } from "react-helmet"; import Layout from "../components/layout"; export default ({ data: { allContentfulArticle: { edges: [ { node: { title, content: { childMarkdownRemark: { html } } } } ] } } }) =&gt; { return ( &lt;Layout&gt; &lt;Helmet&gt; &lt;meta charSet="utf-8" /&gt; &lt;title&gt;{title}&lt;/title&gt; &lt;/Helmet&gt; &lt;div dangerouslySetInnerHTML={{ __html: html }} /&gt; &lt;/Layout&gt; ); }; export const query = graphql` query($slug: String!) { allContentfulArticle(filter: { link: { eq: $slug } }) { edges { node { title link content { childMarkdownRemark { html } } } } } } `;</code> </pre> <br><p> 现在<code>title</code>网站的<code>title</code>将始终与该文章的标题匹配，这将显着影响专门针对此问题的搜索结果中网站的发行。 在这里，您可以轻松地添加<code>&lt;meta name="description" content=" "&gt;</code>的描述<code>&lt;meta name="description" content=" "&gt;</code> ，并分别为每篇文章提供描述，从而使用户能够在搜索页面上了解文章的含义，通常来说，所有SEO功能现在都可以使用并且易于管理一个地方。 </p><br><p><img src="https://habrastorage.org/webt/_7/l2/ht/_7l2hthmllnqdgycorxhaz2v_mw.png" alt="eo"></p><br><h2 id="nastroyka-pwa">  PWA设置 </h2><br><p>  <strong>Gatsby</strong>旨在提供开箱即用的一流性能。 它解决了代码分离和最小化的问题，以及在后台进行预加载，图像处理等形式的优化，从而使您创建的站点无需任何手动配置即可具有高性能。 这些性能功能是支持渐进式Web应用程序方法的重要组成部分。 </p><br><p> 但是，除了上述所有条件外，对于将其定义为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PWA</a>的网站，还有三个基本标准： </p><br><ul><li>  https协议 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">manifest.json的</a>存在 </li><li> 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务人员</a>而导致离线访问该站点 </li></ul><br><p> 盖茨比无法解决第一点，因为<em>域</em> ， <em>托管</em>和<em>协议</em>是部署问题，根本不是开发问题，但是我建议您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Netlify</a> ，它默认情况下解决了https问题。 </p><br><p> 我们继续进行其余的项目，为此，我们将安装两个插件： </p><br><pre> <code class="bash hljs">yarn add gatsby-plugin-manifest gatsby-plugin-offline</code> </pre> <br><p> 并配置它们<em>/src/gatsby-config.js</em> </p><br><pre> <code class="plaintext hljs">if (process.env.NODE_ENV === "development") { require("dotenv").config(); } module.exports = { plugins: [ { resolve: `gatsby-plugin-manifest`, options: { name: `GatsbyJS translated tutorial`, short_name: `GatsbyJS tutorial`, start_url: `/`, background_color: `#f7f0eb`, theme_color: `#a2466c`, display: `standalone`, icon: `public/favicon.ico`, include_favicon: true } }, `gatsby-plugin-offline`, `gatsby-transformer-remark`, { resolve: `gatsby-source-filesystem`, options: { name: `images`, path: `${__dirname}/src/images/` } }, { resolve: `gatsby-plugin-typography`, options: { pathToConfigModule: `src/utils/typography` } }, { resolve: `gatsby-source-contentful`, options: { spaceId: process.env.CONTENTFUL_SPACE_ID, accessToken: process.env.CONTENTFUL_ACCESS_TOKEN } }, `gatsby-plugin-sass`, `gatsby-plugin-styled-components`, `gatsby-plugin-react-helmet` ] };</code> </pre> <br><p> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档来自</a>定义清单，也可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖插件设置</a>来自定义服务人员策略。 </p><br><p> 您不会注意到开发模式的任何变化，但是该站点已经满足了Web世界的最新要求，并且在https：//域上托管时，它将不相等。 </p><br><h2 id="vyvod"> 结论 </h2><br><p> 几年前，当我第一次遇到将React应用程序带到互联网，支持它和更新内容的问题时，我无法想象市场上已经存在可以简化所有这些流程的JAM堆栈方法，现在我不会对此感到惊讶简单。 盖茨比（Gatsby）解决了大多数影响网站性能的问题，即开箱即用。如果您对自定义它的复杂性有所了解，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lighthouse中</a>获得所有项目的100％指标，这将大大影响网站在搜索引擎中的投放（至少在Google上）。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带项目的存储库</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442298/">https://habr.com/ru/post/zh-CN442298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442286/index.html">俄罗斯眼科医生谈到了仿生视觉。 新的移动应用程序演示了网络的工作</a></li>
<li><a href="../zh-CN442288/index.html">辐射：来源</a></li>
<li><a href="../zh-CN442290/index.html">用中文ST-Link V2制作ST-Link V2.1</a></li>
<li><a href="../zh-CN442292/index.html">Sberseasons实习：Python，UX / UI，数据以及更多学生</a></li>
<li><a href="../zh-CN442294/index.html">奥列格·阿塔莫诺夫（Oleg Artamonov）有什么错误</a></li>
<li><a href="../zh-CN442300/index.html">我看着我想要的地方听。 将Chromecast集成到Android应用中</a></li>
<li><a href="../zh-CN442304/index.html">折叠式智能手机：应用程序如何？</a></li>
<li><a href="../zh-CN442306/index.html">如何将一个git供应到另一个git</a></li>
<li><a href="../zh-CN442310/index.html">通过Raspberry Pi的Sonoff Basic固件</a></li>
<li><a href="../zh-CN442312/index.html">RPZ分发的DoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>