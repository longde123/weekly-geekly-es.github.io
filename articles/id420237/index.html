<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔢 🧛🏿 🤮 Qt wrapper di sekitar kerangka gRPC di C ++ 👩🏿‍🤝‍👩🏾 🧦 👩🏽‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Hari ini kita akan melihat bagaimana Anda dapat menautkan kerangka kerja gRPC di C ++ dan perpustakaan Qt. Artikel ini menyediakan kode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt wrapper di sekitar kerangka gRPC di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p>  Halo semuanya.  Hari ini kita akan melihat bagaimana Anda dapat menautkan kerangka kerja gRPC di C ++ dan perpustakaan Qt.  Artikel ini menyediakan kode yang merangkum penggunaan keempat mode interaksi di gRPC.  Selain itu, disediakan kode yang memungkinkan penggunaan gRPC melalui sinyal dan slot Qt.  Artikel ini mungkin menarik terutama untuk pengembang Qt yang tertarik menggunakan gRPC.  Namun demikian, generalisasi dari empat mode operasi gRPC ditulis dalam C ++ tanpa menggunakan Qt, yang akan memungkinkan pengembang yang tidak terkait dengan Qt untuk mengadaptasi kode.  Saya meminta semua orang tertarik pada kucing. </p><a name="habracut"></a><br><h2>  Latar belakang </h2><br><p>  Sekitar enam bulan yang lalu, dua proyek tergantung pada saya, menggunakan bagian klien dan server gRPC.  Kedua proyek jatuh dalam produksi.  Proyek-proyek ini ditulis oleh pengembang yang sudah berhenti.  Satu-satunya kabar baik adalah saya mengambil bagian aktif dalam menulis server gRPC dan kode klien.  Tapi itu sekitar setahun yang lalu.  Karena itu, seperti biasa, saya harus berurusan dengan semuanya dari awal. </p><br><p>  Kode server gRPC ditulis dengan harapan akan dibuat lebih lanjut oleh file .proto.  Kode itu ditulis dengan baik.  Namun, server memiliki satu kelemahan besar: hanya satu klien yang dapat terhubung. </p><br><p>  Klien gRPC ditulis sangat buruk. </p><br><p>  Saya menemukan kode klien dan server gRPC hanya beberapa hari kemudian.  Dan saya menyadari bahwa jika saya mengambil proyek selama beberapa minggu, saya harus berurusan dengan server dan klien gRPC lagi. </p><br><p>  Saat itulah saya memutuskan bahwa sudah waktunya untuk menulis dan men-debug klien dan server gRPC sehingga: </p><br><ul><li><p>  Anda bisa tidur nyenyak di malam hari; </p></li><li><p>  Tidak perlu mengingat cara kerjanya setiap kali Anda perlu menulis klien atau server gRPC; </p></li><li><p>  Anda dapat menggunakan klien dan server gRPC tertulis di proyek lain. </p></li></ul><br><p>  Saat menulis kode, saya dipandu oleh persyaratan berikut: </p><br><ul><li><p>  Baik klien dan server gRPC dapat beroperasi menggunakan sinyal dan slot pustaka Qt secara alami; </p></li><li><p>  Kode klien dan server gRPC tidak perlu diperbaiki ketika mengubah file .proto; </p></li><li><p>  Klien gRPC harus dapat memberi tahu kode klien status koneksi ke server. </p></li></ul><br><p>  Struktur artikel adalah sebagai berikut.  Pertama, akan ada ikhtisar singkat tentang hasil bekerja dengan kode klien dan penjelasan kecil untuk itu.  Di akhir ulasan, tautan ke repositori.  Selanjutnya akan ada hal-hal umum pada arsitektur.  Kemudian deskripsi kode server dan klien (apa yang ada di balik tenda) dan sebuah kesimpulan. </p><br><h2>  Ulasan singkat </h2><br><p>  File pingproto.proto paling sederhana digunakan sebagai file .proto, di mana RPC dari semua jenis interaksi didefinisikan: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  File pingpong.proto mengulangi file helloworld.proto dari artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode gRPC asinkron di C ++</a> dengan nama yang tepat. </p><br><p>  Akibatnya, server tertulis dapat digunakan seperti ini: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  Ketika klien memanggil RPC, server gRPC memberitahukan kode klien (dalam hal ini, kelas A) dengan sinyal yang sesuai. </p><br><p>  Klien gRPC dapat digunakan seperti ini: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  Klien gRPC memungkinkan Anda untuk memanggil RPC secara langsung, dan berlangganan respons server menggunakan sinyal yang sesuai. </p><br><p>  Klien gRPC juga memiliki sinyal: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  yang melaporkan status koneksi server masa lalu dan saat ini.  Semua kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampel</a> ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam repositori qgrpc</a> . <br><br><h2>  Bagaimana cara kerjanya </h2><br><p>  Prinsip menyertakan klien dan server gRPC dalam proyek ditunjukkan pada gambar. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  Dalam file proyek .pro, file .proto ditentukan, berdasarkan gRPC mana yang akan bekerja.  File grpc.pri berisi perintah untuk membuat file gRPC dan QgRPC.  Kompilator protoc menghasilkan file gRPC [protofile] .grpc.pb.h dan [protofile] .grpc.pb.cc.  [protofile] adalah nama file .proto yang diteruskan ke input kompiler. </p><br><p>  Pembuatan file QgRPC [protofile] .qgrpc. [Config] .h ditangani oleh skrip genQGrpc.py.  [config] adalah "server" atau "klien". <br><br>  File QgRPC yang dihasilkan berisi pembungkus Qt di sekitar kelas dan panggilan gRPC dengan sinyal yang sesuai.  Dalam contoh sebelumnya, kelas QpingServerService dan QpingClientService dideklarasikan dalam file yang dihasilkan pingpong.qgrpc.server.h dan pingpong.qgrpc.client.h masing-masing.  File QgRPC yang dihasilkan ditambahkan ke pemrosesan moc. </p><br><p>  Dalam file QgRPC yang dihasilkan, file [config] .h QGrpc disertakan, di mana semua pekerjaan utama dilakukan.  Baca lebih lanjut tentang ini di bawah ini. </p><br><p>  Untuk menghubungkan semua konstruksi ini ke proyek, Anda perlu memasukkan file grpc.pri dalam file propro proyek dan menentukan tiga variabel.  Variabel GRPC mendefinisikan file .proto yang akan ditransfer ke input dari kompiler protoc dan skrip genQGrpc.py.  Variabel QGRPC_CONFIG mendefinisikan nilai konfigurasi dari file QgRPC yang dihasilkan dan mungkin berisi nilai "server" atau "klien".  Anda juga dapat menentukan variabel GRPC_VERSION opsional untuk menunjukkan versi gRPC. </p><br><p>  Untuk informasi lebih lanjut tentang semua yang dikatakan, baca file grpc.pri dan file .pro contoh. </p><br><h2>  Arsitektur server </h2><br><p>  Diagram kelas server ditunjukkan pada gambar. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  Panah tebal menunjukkan hierarki warisan kelas, dan panah tipis menunjukkan keanggotaan anggota dan metode di kelas.  Secara umum, kelas Q [servicename] ServerService dihasilkan untuk layanan, di mana servicename adalah nama layanan yang dinyatakan dalam file .proto.  RPCCallData adalah struktur kontrol yang dihasilkan untuk setiap RPC dalam layanan.  Dalam konstruktor kelas QpingServerService, kelas dasar QGrpcServerService diinisialisasi dengan layanan pingRong gpPC :: ping :: AsyncService.  Untuk memulai layanan, Anda perlu memanggil metode Mulai () dengan alamat dan port tempat layanan akan dijalankan.  Fungsi Start () mengimplementasikan prosedur standar untuk memulai layanan. </p><br><p>  Pada akhir fungsi Start (), fungsi virtual murni makeRequests () dipanggil, yang diimplementasikan dalam kelas QpingServerService yang dihasilkan: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  Parameter templat kedua dari fungsi needAnotherCallData adalah struktur RPCCallData yang dihasilkan.  Struktur yang sama adalah parameter sinyal dalam kelas Qt yang dihasilkan dari layanan. </p><br><p>  Struktur RPCCallData yang dihasilkan mewarisi dari kelas ServerCallData.  Pada gilirannya, kelas ServerCallData diwarisi dari responden ServerResponder.  Dengan demikian, penciptaan objek struktur yang koheren mengarah pada penciptaan objek responden. </p><br><p>  Konstruktor untuk kelas ServerCallData mengambil dua parameter: signal_func dan request_func.  signal_func adalah sinyal yang dihasilkan yang dipanggil setelah menerima tag dari antrian.  request_func adalah fungsi yang harus dipanggil saat membuat responder baru.  Misalnya, dalam hal ini mungkin fungsi RequestSayHello ().  Panggilan request_func terjadi dalam fungsi needAnotherCallData ().  Hal ini dilakukan agar manajemen responden (penciptaan dan penghapusan) terjadi dalam layanan. </p><br><p>  Kode fungsi needAnotherCallData () terdiri dari membuat objek responden dan memanggil fungsi yang menghubungkan responden ke panggilan RPC: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  Fungsi RequestRPC () adalah fungsi template untuk empat jenis interaksi.  Akibatnya, panggilan RequestRPC () bermuara pada panggilan: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  di mana service_ adalah layanan gRPC.  Dalam hal ini, ini adalah pingpong :: ping :: AsyncService. </p><br><p>  Untuk memeriksa antrian acara secara sinkron atau asinkron, Anda harus memanggil fungsi CheckCQ () atau AsyncCheckCQ ().  Kode fungsi CheckCQ () diturunkan untuk panggilan ke tag sinkron dari antrian dan pemrosesan tag ini: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  Setelah menerima tag dari antrian, validitas tag dan server mulai diperiksa.  Jika server dimatikan, maka tag tidak lagi diperlukan - itu dapat dihapus.  Setelah itu, fungsi cqReaction () yang didefinisikan dalam kelas ServerCallData disebut: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  Bendera first_time_reaction_ menunjukkan bahwa Anda perlu membuat responden baru untuk RPC yang disebut.  Fungsi CouldBeDeleted () dan ProcessEvent () diwarisi dari kelas responden ServerResponder yang sesuai.  Fungsi CouldBeDeleted () mengembalikan tanda bahwa objek responder dapat dihapus.  Fungsi processEvent () memproses tag dan flag ok.  Jadi, misalnya, untuk responden tipe Streaming Klien, fungsinya terlihat seperti ini: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Fungsi ProcessEvent (), terlepas dari jenis responden, selalu mengembalikan true.  Nilai pengembalian fungsi ini dibiarkan untuk kemungkinan perluasan fungsi dan, secara teoritis, untuk menghilangkan kesalahan. </p><br><p>  Setelah memproses acara, panggilan berikut: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  Service_ variabel adalah turunan dari layanan yang dihasilkan, dalam kasus kami QpingServerService.  Signal_func_ variabel adalah sinyal layanan yang sesuai dengan RPC tertentu.  Misalnya, SayHelloRequest ().  GenRpcCallData variabel adalah objek responden dari tipe yang sesuai.  Dari sudut pandang kode panggilan, variabel genRpcCallData adalah objek dari salah satu struktur RPCCallData yang dihasilkan. <br></p><br><h2>  Arsitektur pelanggan </h2><br><p>  Kapanpun memungkinkan, nama kelas dan fungsi klien cocok dengan nama kelas dan fungsi server.  Diagram kelas klien ditunjukkan pada gambar. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  Panah tebal menunjukkan hierarki warisan kelas, dan panah tipis menunjukkan keanggotaan anggota dan metode di kelas.  Secara umum, untuk layanan, kelas Q [servicename] ClientService dihasilkan, di mana servicename adalah nama layanan yang dinyatakan dalam file .proto.  RPCCallData adalah struktur kontrol yang dihasilkan untuk setiap RPC dalam layanan.  Untuk memanggil RPC, kelas yang dihasilkan menyediakan fungsi yang namanya sama persis dengan RPC yang dinyatakan dalam file .proto.  Dalam contoh kami, dalam file .proto RPC, SayHello () dinyatakan sebagai: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  Di kelas QpingClientService yang dihasilkan, fungsi RPC yang sesuai terlihat seperti ini: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  Struktur RPCCallData yang dihasilkan, seperti dalam kasus server, pada akhirnya diwarisi dari kelas ClientResponder.  Oleh karena itu, penciptaan objek dari struktur yang dihasilkan mengarah ke penciptaan responden.  Setelah membuat responder, RPC dipanggil dan responder dikaitkan dengan kejadian menerima respons dari server.  Dalam hal kode klien, panggilan RPC terlihat seperti ini: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  Tidak seperti kelas server QpingServerService yang dihasilkan, kelas QpingClientService mewarisi dari dua kelas templat: ConnectivityFeatures dan MonitorFeatures. </p><br><p>  Kelas ConnectivityFeatures bertanggung jawab untuk keadaan koneksi klien-server dan menyediakan tiga fungsi untuk digunakan: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  Fungsi grpc_disconnect () hanya menghapus semua struktur data yang bertanggung jawab untuk berinteraksi dengan server.  Panggilan ke grpc_connect dikurangi menjadi panggilan ke fungsi grpc_connect_ (), yang membuat struktur data kontrol: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  Kelas ChannelFeatures memonitor status komunikasi <em>channel_</em> channel dengan server.  Kelas ConnectivityFeatures merangkum objek kelas ChannelFeatures dan mengimplementasikan fungsi abstrak channelState (), checkChannelState (), dan terhubung () menggunakan objek ini.  Fungsi channelState () mengembalikan keadaan teramati terakhir dari saluran komunikasi dengan server.  Fungsi checkChannelState (), pada kenyataannya, mengembalikan kondisi saluran saat ini.  Fungsi terhubung () mengembalikan tanda klien terhubung ke server. <br></p><br><p>  Kelas MonitorFeatures bertanggung jawab untuk menerima dan memproses acara dari server dan menyediakan fungsi CheckCQ () untuk digunakan: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Struktur kode sama dengan server.  Tidak seperti server, blok kode yang bertanggung jawab untuk memproses keadaan saat ini ditambahkan ke klien.  Jika keadaan saluran komunikasi telah berubah, sinyal channelStateChangedSignal_ () dipanggil.  Di semua layanan yang dihasilkan, ini adalah sinyal: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Selain itu, tidak seperti server, fungsi AsyncNext () digunakan di sini daripada Next ().  Ini telah dilakukan karena beberapa alasan.  Pertama, saat menggunakan AsyncNext (), kode klien memiliki kemampuan untuk mempelajari tentang perubahan status saluran komunikasi.  Kedua, ketika menggunakan AsyncNext (), dimungkinkan untuk memanggil berbagai RPC dalam kode klien beberapa kali.  Menggunakan fungsi Next () dalam kasus ini akan memblokir utas sampai suatu peristiwa diterima dari antrian dan, sebagai akibatnya, akan kehilangan dua fitur yang dijelaskan. <br><br><p>  Setelah menerima acara dari antrian, seperti dalam kasus server, fungsi cqReaction (), didefinisikan dalam kelas ClientCallData, dipanggil: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  Seperti halnya server, fungsi processEvent () memproses tag dan flag ok dan selalu mengembalikan true.  Seperti dalam kasus server, setelah memproses acara, sinyal dari layanan yang dihasilkan harus dipanggil.  Namun, ada dua perbedaan signifikan dari fungsi server dengan nama yang sama.  Perbedaan pertama adalah bahwa responden tidak dibuat dalam fungsi ini.  Pembuatan responden, seperti yang ditunjukkan di atas, terjadi ketika RPC dipanggil.  Perbedaan kedua adalah bahwa responden tidak dihapus dalam fungsi ini.  Tidak adanya penghapusan responden dilakukan karena dua alasan.  Pertama, kode klien dapat menggunakan pointer untuk menghasilkan struktur RPCCallData untuk keperluan mereka sendiri.  Menghapus konten oleh pointer ini, disembunyikan dari kode klien, dapat menyebabkan konsekuensi yang tidak menyenangkan.  Kedua, penghapusan responden akan mengarah pada fakta bahwa sinyal dengan data tidak akan dihasilkan.  Oleh karena itu, kode klien tidak akan menerima pesan server terakhir.  Di antara beberapa alternatif untuk memecahkan masalah yang ditunjukkan, keputusan dibuat untuk menggeser pemindahan responden (struktur yang dihasilkan) ke kode klien.  Dengan demikian, fungsi pengendali sinyal (slot) harus berisi kode berikut: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  Tidak adanya penghapusan responden dalam kode klien tidak hanya akan menyebabkan kebocoran memori, tetapi juga kemungkinan masalah dengan saluran komunikasi.  Penangan sinyal dari semua jenis interaksi RPC diimplementasikan dalam kode sampel. </p><br><h2>  Kesimpulan </h2><br><p>  Sebagai kesimpulan, kami menarik dua poin.  Poin pertama terkait dengan memanggil fungsi-fungsi CheckCQ () dari klien dan server.  Mereka bekerja, seperti yang ditunjukkan di atas, sesuai dengan satu prinsip: jika ada suatu kejadian dalam antrian, sinyal dengan struktur RPCCallData yang dihasilkan adalah “dipancarkan”.  Anda dapat memanggil fungsi ini secara manual dan memeriksa (dalam kasus klien) untuk suatu acara.  Tetapi awalnya ada ide untuk mentransfer seluruh bagian jaringan yang terkait dengan gRPC ke utas lain.  Untuk tujuan ini, kelas tambahan QGrpcSrvMonitor untuk server gRPC dan QGrpcCliServer untuk klien gRPC ditulis.  Kedua kelas bekerja pada prinsip yang sama: mereka membuat aliran terpisah, menempatkan layanan yang dihasilkan dalam aliran ini dan secara berkala memanggil fungsi CheckCQ () dari layanan ini.  Jadi, ketika menggunakan kedua kelas tambahan, tidak perlu memanggil fungsi CheckCQ () dalam kode klien.  Sinyal layanan yang dihasilkan, dalam hal ini, "datang" dari aliran lain.  Contoh klien dan server diimplementasikan menggunakan kelas pembantu ini. </p><br><p>  Poin kedua menyangkut mayoritas pengembang yang tidak menggunakan perpustakaan Qt dalam pekerjaan mereka.  Kelas dan makro Qt di QgRPC hanya digunakan di dua tempat: dalam file layanan yang dihasilkan, dan dalam file yang berisi kelas tambahan: QGrpcServerMonitor.h dan QGrpcClientMonitor.h.  File yang tersisa dengan perpustakaan Qt sama sekali tidak terkait.  Direncanakan untuk menambah perakitan menggunakan cmake, dan untuk mematikan beberapa arahan Qt.  Secara khusus, kelas QObject dan makro Q_OBJECT.  Tapi tangan tidak bisa melakukan ini.  Karena itu, setiap saran dipersilahkan. </p><br><p>  Itu saja.  Terima kasih semuanya! </p><br><h2>  Referensi </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori dengan Kode QgRPC</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GRPC asinkron di C ++</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420237/">https://habr.com/ru/post/id420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420225/index.html">Melodi Algoritmik Tak Terbatas Berdasarkan Bilangan Prima</a></li>
<li><a href="../id420227/index.html">Presiden Turki Mengumumkan Larangan Impor Elektronik AS</a></li>
<li><a href="../id420229/index.html">Dapatkah anak-anak di desa menjadi pemrogram jika di dekat mereka hanya mengajar pekerja kereta api. Percakapan dengan "Lingkaran"</a></li>
<li><a href="../id420233/index.html">UE4 | Peralatan untuk Multiplayer # 5 | Transfer informasi antara Server dan Klien</a></li>
<li><a href="../id420235/index.html">Zenject: Bagaimana Kontainer IoC Dapat Membunuh Injeksi Ketergantungan pada Proyek Anda</a></li>
<li><a href="../id420239/index.html">Pengembangan ponsel. Swift: misteri protokol</a></li>
<li><a href="../id420243/index.html">Filantropi Terobosan: Proyek Terobosan Kemanusiaan</a></li>
<li><a href="../id420245/index.html">Bagaimana mencegah overrun memori saat menggunakan koleksi Java</a></li>
<li><a href="../id420251/index.html">Apple mengklaim kompleks kantor pusat perusahaan harganya hanya $ 200</a></li>
<li><a href="../id420253/index.html">Bagaimana API perbankan terbuka mengubah dunia keuangan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>