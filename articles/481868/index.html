<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèø üåö ü•ì Dagaz: un nuevo comienzo üë©üèº‚Äçüîß ‚èèÔ∏è üë®üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Corre hacia el sur y gira hacia el norte, gira, gira para correr con su viento 
 Y seg√∫n sus circuitos vuelve el viento; 
 Todos los r√≠os desembocan e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: un nuevo comienzo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Corre hacia el sur y gira hacia el norte, gira, gira para correr con su viento</i></b> <b><i><br></i></b>  <b><i>Y seg√∫n sus circuitos vuelve el viento;</i></b> <b><i><br></i></b>  <b><i>Todos los r√≠os desembocan en el mar, y el mar no se desborda,</i></b> <b><i><br></i></b>  <b><i>Al lugar donde corren los r√≠os, - all√≠ contin√∫an corriendo;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">El libro de los eclesiast√©s.</a></i></b> <br><br>  En 1998, se desarroll√≥ una aplicaci√≥n completamente √∫nica para su √©poca que le permite reducir el proceso de desarrollo de un juego de tablero abstracto (o rompecabezas) a un lenguaje de descripci√≥n de texto peque√±o, que recuerda vagamente a <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> .  Este proyecto se llam√≥ <a href="http://www.zillions-of-games.com/" rel="nofollow">Zillions of Games</a> .  Cre√≥ furor entre los fan√°ticos de los juegos de mesa.  Actualmente, se han creado m√°s de 2,000 aplicaciones utilizando esta tecnolog√≠a. <br><a name="habracut"></a><br>  R√°pidamente se hizo evidente que ZoG tiene muchos inconvenientes.  Ya <a href="https://habr.com/ru/post/221779/">escrib√≠</a> sobre esto en Habr y no me repetir√©.  Perm√≠tanme decir que los desarrolladores no tuvieron en cuenta las caracter√≠sticas de una gran cantidad de juegos existentes y algunas opciones importantes fueron codificadas, por lo que su cambio se volvi√≥ extremadamente problem√°tico.  Greg Schmidt, en 2007, trat√≥ de rectificar la situaci√≥n al lanzar el <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">kit de desarrollo Axiom</a> , pero su estrecha integraci√≥n con ZoG no permite resolver todos los problemas. <br><br>  El Proyecto <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi</a> se√±al√≥ nuevas fronteras, utilizando el "motor" del juego universal y <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">los algoritmos gen√©ticos</a> para automatizar el proceso de desarrollo de nuevos juegos de mesa.  Desafortunadamente, este enfoque se concibi√≥ inicialmente como una simplificaci√≥n deliberada de la mec√°nica del juego y del nivel de la IA empleada.  La discusi√≥n de los objetivos de este proyecto est√° m√°s all√° del alcance de este art√≠culo, pero algunas de sus soluciones t√©cnicas, sin duda, sirvieron como punto de partida para mi propio desarrollo. <br><br>  Mi objetivo es el desarrollo de un "motor" m√°s vers√°til y f√°cil de usar para la creaci√≥n de juegos de mesa abstractos.  Durante casi un a√±o he estado estudiando la posibilidad de ZoG y Axiom y aprend√≠ mucho sobre sus limitaciones.  Creo que puedo resolver sus problemas creando una soluci√≥n m√°s universal y multiplataforma.  Sobre el progreso del trabajo en este proyecto, informar√©. <br><br><h2>  Apertura y modularidad. </h2><br>  Quiz√°s el principal inconveniente de ZoG es su cierre.  El producto se ensambl√≥ "una vez y para siempre" en una sola plataforma: Windows.  Si se tratara de c√≥digo de fuente abierta, uno podr√≠a intentar portarlo bajo Linux, Android, iOS ... Otro problema es su monolitismo. <br><br>  En ZoG existen los inicios de la modularidad, lo que permite la conexi√≥n a la DLL de juegos, incluidas las implementaciones personalizadas de la IA.  Axiom va un poco m√°s all√°, permiti√©ndole ejecutar aplicaciones en el modo de reproducci√≥n autom√°tica, sin usar el n√∫cleo ZoG.  A pesar de la seria limitaci√≥n de esta soluci√≥n (solo admite aplicaciones para dos jugadores), este ejemplo demuestra c√≥mo ser√≠a √∫til la modularidad.  No se puede sobrestimar la oportunidad de organizar un juego con dos bots (usando diferentes configuraciones de IA) y recopilar estad√≠sticas sobre una gran cantidad de juegos.  ¬°Pero cu√°nto mejor ser√≠a si el producto hubiera sido completamente modular! <br><br><ul><li>  Mover m√≥dulo de generaci√≥n </li><li>  Mover m√≥dulo de ejecuci√≥n </li><li>  M√≥dulo de control </li><li>  M√≥dulo AI </li><li>  M√≥dulo de visualizaci√≥n </li></ul><br>  Todo el trabajo que describe los juegos debe ser realizado por el m√≥dulo de generaci√≥n de movimientos.  Este es el "coraz√≥n" del proyecto.  La transferencia de todas las tareas que no est√©n conectadas con esta funci√≥n a otros m√≥dulos lo har√° lo m√°s simple posible.  Puede mejorar este m√≥dulo, sin mirar los problemas de IA y la interacci√≥n del usuario.  Puede cambiar completamente el formato de la descripci√≥n de los juegos o agregar soporte para las descripciones en el formato de ZoG, Axiom y Ludi.  ¬°La modularidad es la base de la flexibilidad de la soluci√≥n! <br><br>  El m√≥dulo de ejecuci√≥n de movimiento es el custodio del estado del juego.  La informaci√≥n sobre el estado actual del juego se transfiere a todos los dem√°s m√≥dulos a pedido.  Por las razones que dar√© a continuaci√≥n, el progreso de la ejecuci√≥n debe pasar por el m√≥dulo de generaci√≥n, cuya tarea es la formaci√≥n de un comando en t√©rminos de ejecuci√≥n del m√≥dulo.  Adem√°s, la tarea del m√≥dulo de generaci√≥n de movimientos es la configuraci√≥n principal del espacio del juego, basada en la descripci√≥n del juego. <br><br>  El m√≥dulo de control es, de hecho, la aplicaci√≥n misma.  Pide al m√≥dulo de generaci√≥n de movimientos una lista de posibles movimientos y cambia el estado del juego, pasando el movimiento seleccionado al m√≥dulo de ejecuci√≥n de movimientos.  El m√≥dulo de control se puede conectar para reproducir uno o m√°s bots AI.  ¬°Todos los que necesite (y posiblemente diferentes)!  El tipo de unidad de control est√° determinado por la divisi√≥n de tareas.  Esto puede ser reproducci√≥n autom√°tica para recopilar estad√≠sticas del juego, servidor de juegos (puede controlar varias tiendas estatales, liderando una gran cantidad de sesiones de juego) o aplicaciones individuales para jugar sin conexi√≥n. <br><br>  La capacidad de conectar diferentes implementaciones de IA mejorar√° la calidad del juego.  Se entiende que los m√≥dulos para el juego de ajedrez y Go deber√≠an usar diferentes enfoques.  Los juegos con informaci√≥n incompleta y los juegos que usan datos aleatorios tambi√©n requieren un enfoque individual.  ¬°La implementaci√≥n universal de IA ser√° igualmente mala para todos los juegos!  La conexi√≥n modular AI permitir√° comparar la "fuerza" de los algoritmos, incluido un modo de juego "entre s√≠". Dado que la arquitectura AI est√° separada del estado de almacenamiento del juego, una instancia del robot de juego puede admitir un n√∫mero ilimitado de sesiones de juego simult√°neamente. <br><br>  La visualizaci√≥n del proceso del juego tambi√©n puede ser variada.  Lo primero que viene a la mente son las implementaciones en 2D y 3D.  La plataforma para la que se desarrolla la aplicaci√≥n tambi√©n es importante.  ¬°Menos obvio es que la visualizaci√≥n puede ser una parte importante del juego!  Por ejemplo, en el juego <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> , tomar piezas ser√° completamente no obvio en ausencia de una animaci√≥n adecuada de los movimientos. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  En general, la modularidad parece una buena idea para tal proyecto, y el c√≥digo fuente abierto permitir√° a todos los que deseen participar en el proyecto.  En la actualidad, no me propongo prop√≥sitos comerciales, pero creo que, si lo deseo, encontrar√© la manera de ganar dinero sin cerrar el c√≥digo fuente. <br><br><h2>  El espacio del juego </h2><br>  Antes de comenzar el espect√°culo, debes preparar el escenario.  El tablero no es solo un lugar donde se colocan las piezas.  Adem√°s de eso, se puede determinar la direcci√≥n del movimiento de las piezas (de hecho, las conexiones entre las posiciones del tablero) √°reas de juego (por ejemplo, √°reas para la conversi√≥n de piezas) campos prohibidos, etc.  As√≠ es como se ve la definici√≥n del tablero de ajedrez en la implementaci√≥n de ZoG: <br><br><div class="spoiler">  <b class="spoiler_title">Definiendo el tablero en ZoG</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  Puede notar que adem√°s de la configuraci√≥n del juego, aqu√≠ est√°n las configuraciones asociadas con la visualizaci√≥n.  Estoy firmemente convencido de que esta configuraci√≥n no pertenece aqu√≠.  Al implementar un m√≥dulo de visualizaci√≥n, se pueden usar m√∫ltiples configuraciones y se pueden requerir diferentes configuraciones.  Adem√°s, los juegos de simulaci√≥n pueden funcionar sin ning√∫n m√≥dulo de visualizaci√≥n (como la reproducci√≥n autom√°tica en Axiom).  De hecho, dado que Axiom se usa para visualizar ZoG, la definici√≥n no contiene nada superfluo: <br><br><div class="spoiler">  <b class="spoiler_title">Definiendo el tablero en Axiom</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Desafortunadamente, Axiom tampoco tiene una forma de determinar las zonas de juego (la ubicaci√≥n de las zonas de juego debe determinarse manualmente en el c√≥digo).  Esta no es la √∫nica simplificaci√≥n de Axiom.  La definici√≥n del tablero en este proyecto no puede contener m√°s de una cuadr√≠cula y esta cuadr√≠cula debe ser bidimensional.  El tablero, as√≠ definido, es una matriz unidimensional, pero para la conveniencia del programador, los sin√≥nimos se definen para cada uno de los espacios de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  En comparaci√≥n con el esquema m√°s flexible de definici√≥n de cuadr√≠cula en ZoG, estas restricciones son bastante inc√≥modas (especialmente dado el hecho de que el esquema de nomenclatura impuesto us√≥ estos campos con el mismo prop√≥sito de visualizaci√≥n).  Afortunadamente, es posible definir un tablero de forma arbitraria.  Tanto Axiom como ZoG brindan la oportunidad de identificar cada posici√≥n del elemento en el tablero junto con la capacidad de determinar los v√≠nculos entre pares de posiciones arbitrarias.  Con este enfoque, podemos definir un tablero de cualquier topolog√≠a.  Su √∫nico inconveniente es la extrema verbosidad y complejidad de la descripci√≥n. <br><br>  Adem√°s de la ubicaci√≥n de las piezas en el tablero y en la reserva, el sistema debe tener la capacidad de almacenar atributos para piezas individuales y para los espacios en el tablero.  Un buen ejemplo de la necesidad de utilizar los atributos de una regla de " <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">enroque</a> " en el <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">ajedrez</a> .  Este es un movimiento dif√≠cil, que incluye el movimiento simult√°neo del rey y una torre, permitido, siempre que ninguna de estas piezas se haya movido antes de realizar este movimiento.  Se podr√≠a usar un atributo para almacenar una etiqueta booleana que muestre si la pieza se movi√≥ alguna vez.  Los atributos de campo tambi√©n pueden encontrar algunas aplicaciones interesantes. <br><br>  Cabe se√±alar que los atributos no son solo variables sino parte del estado del juego.  El valor de un atributo puede cambiarse mediante la ejecuci√≥n de un turno (incluido el m√≥dulo AI) y debe estar disponible para todos los turnos posteriores, pero no para los turnos realizados en otra rama del juego.  Actualmente, ZoG admite el almacenamiento de atributos booleanos de piezas.  Los atributos de almacenamiento de Axiom no son compatibles, pero puede agregar a la definici√≥n de la placa una descripci√≥n de variables y matrices.  Se pueden usar estas variables, como los contadores de la cantidad de piezas capturadas: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Otra limitaci√≥n de ZoG y de Axiom es la regla de que cada posici√≥n del tablero no puede contener m√°s de una pieza.  Si alguna pieza completa un movimiento a una posici√≥n ocupada por otra pieza, la pieza que anteriormente ocupaba la posici√≥n se considera autom√°ticamente "comida".  Esta regla va bien con el principio de "ajedrez" de tomar piezas y sirve para simplificar la descripci√≥n de este juego, pero complica la implementaci√≥n de juegos como " <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">damas bashni</a> " y " <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  En estos juegos, las piezas se pueden organizar en "columnas".  Tal "columna" se puede mover todo junto, como una sola pieza.  Despu√©s de reflexionar un poco, decid√≠ que era mejor no abandonar la implementaci√≥n autom√°tica de la captura de "Ajedrez", sino mejorar los mecanismos para mover grupos de piezas.  De hecho, para la implementaci√≥n de los "pilares", siempre puede agregar al tablero otra dimensi√≥n (esto es especialmente f√°cil, siempre que el m√≥dulo de visualizaci√≥n est√© separado del m√≥dulo generador de movimiento y de la IA, entonces puede usar cualquier l√≥gica que sea para representar el tablero tridimensional en su visualizaci√≥n bidimensional).  Un argumento adicional a favor de esta decisi√≥n fue que el movimiento de piezas "apiladas" no es el √∫nico tipo de viaje grupal.  Por ejemplo, en el " <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> " se pueden rotar los fragmentos del tablero junto con las piezas montadas sobre el mismo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  Resumiendo, puedo decir que, para mi marco de juego, decid√≠ tomar todo lo mejor que se ha pensado en ZoG, Axiom y Ludi, y agregar lo que, en mi opini√≥n, les falta. <br><br><h2>  Mover generaci√≥n </h2><br>  La generaci√≥n de movimientos es similar a la programaci√≥n <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">no determinista</a> .  La tarea del generador de movimientos es proporcionar, previa solicitud, una lista de todos los movimientos posibles desde la posici√≥n actual.  Qu√© movimiento de esta lista ser√° seleccionado por un jugador o la IA no es su funci√≥n.  Veamos c√≥mo se realiza la generaci√≥n de movimientos en ZoG.  Como ejemplo, tomamos la macro de generaci√≥n de movimiento para una pieza de largo alcance (una reina u obispo).  As√≠ es como se usa para determinar los movimientos de estas piezas: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  Como par√°metro, a una macro se le pasa la direcci√≥n del movimiento en el tablero.  Si no considera la posibilidad de instalar nuevas piezas en el tablero, la generaci√≥n de un movimiento parece simple.  Para cada una de las piezas en el tablero, se calculan todos los movimientos posibles de acuerdo con las reglas.  Entonces comienza la magia ... <br><br>  ¬°Cada una de las definiciones puede agregar a la lista una serie de movimientos posibles!  La adici√≥n de un movimiento a la lista se realiza con el comando agregar (al mismo tiempo, coloca cada pieza en movimiento en el tablero).  Ya <a href="https://habr.com/ru/post/221779/">escrib√≠</a> sobre c√≥mo esta soluci√≥n arquitect√≥nica es extremadamente pobre.  El comando para la formaci√≥n del movimiento debe estar separado de los comandos que manipulan piezas (como se hizo en Axiom).  Veamos c√≥mo funciona la macro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Primero, el desplazamiento es realizado por una celda, en la direcci√≥n dada, luego, en un ciclo, el espacio alcanzado se verifica por la ausencia de las piezas en √©l, se forma un movimiento y la disposici√≥n avanza a otra celda en la misma direcci√≥n.  Si te detienes aqu√≠, la pieza puede "deslizarse" a trav√©s de celdas vac√≠as, pero ¬øc√≥mo puedes tomar piezas enemigas? <br><br>  Muy simple!  Despu√©s de ejecutar el comando verificar, la verificaci√≥n de que el campo no est√° ocupado por una pieza amiga, formamos otro comando de agregar, completando el movimiento.  Si en esta celda se ubic√≥ una pieza enemiga, se tomar√° autom√°ticamente (como en un espacio del tablero, al mismo tiempo, no puede tener m√°s de una pieza).  Si la pieza era amigable, el c√°lculo del movimiento se cancelar√° con la verificaci√≥n del comando (la violaci√≥n de las condiciones especificadas en este comando termina inmediatamente el c√°lculo del movimiento actual). <br><br>  Tanto en ZoG como en Axiom uno puede mover solo las propias piezas (o m√°s bien, es posible mover las piezas del oponente, pero solo si se especifica en el modo de c√°lculo de un movimiento de una de las propias piezas).  Me parece una restricci√≥n extremadamente inconveniente, porque hay muchos juegos en los que puedes mover directamente la pieza del oponente (en " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> ", por ejemplo).  Ser√≠a m√°s consistente realizar el c√°lculo del movimiento para todas las piezas, independientemente de su afiliaci√≥n.  En la macro que determina el movimiento, uno solo necesitar√≠a agregar un cheque para permitir mover solo las propias piezas: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Importante es la capacidad de realizar un movimiento que consta de varios movimientos "parciales".  En implementaciones de borradores, esta capacidad se utiliza para realizar capturas de "cadena": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  El comando de movimiento parcial se forma con add-partial (para este comando, as√≠ como para el comando add, hay una variaci√≥n del movimiento, con "transformaci√≥n" de las piezas).  Tal movimiento es siempre parte de un movimiento m√°s grande, "compuesto".  Como regla general, para movimientos posteriores, se establece un "modo", que la continuaci√≥n debe implementar.  Por lo tanto, en las fichas, una captura puede continuar solo con las siguientes capturas, pero no con un movimiento "suave" (sin captura). <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  En ZoG, la implementaci√≥n de movimientos parciales es deficiente.  Intentar ejecutar el comando add-partial en un ciclo provoca un error.  Como resultado, la captura realizada por un rey corrector solo se puede realizar de la siguiente manera muy inc√≥moda: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  ¬°Y as√≠ sucesivamente, hasta king-jump-7!  Perm√≠tame recordarle que en la mayor√≠a de las variedades de damas con un rey de "largo alcance", el rey, despu√©s de cada captura, puede detenerse en cualquier espacio de una cadena continua de espacios vac√≠os que siguen a la pieza capturada.  Por cierto, hay una variante de este juego en la que la regla de captura de "cadena" se formula de manera diferente.  Eso es justo lo que me gusta de las damas: todos pueden encontrar una variante a su gusto. <br></div></div><br>  Tal sistema de descripci√≥n de las reglas es muy flexible, pero a veces se requiere una l√≥gica m√°s compleja.  Por ejemplo, si la pieza, durante el progreso "parcial" no debe volver a pasar a trav√©s de un campo atravesado previamente, es l√≥gico utilizar las banderas asociadas con las posiciones en el tablero.  Despu√©s de visitar un espacio, configuramos una bandera, por lo que posteriormente no debemos volver a este espacio: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  Adem√°s de las banderas "posicionales", en ZoG puede usar banderas globales.  Estas capacidades no deben confundirse con los atributos de las piezas.  A diferencia de este √∫ltimo, estos no son parte del estado del juego.  Desafortunadamente, ambos atributos de piezas y banderas en ZoG solo pueden ser booleanos (en Axiom los atributos ni siquiera son compatibles).  Esta limitaci√≥n dificulta la realizaci√≥n de operaciones asociadas con los diversos tipos de conteo.  Por ejemplo, en <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">este</a> peque√±o rompecabezas, tuve que usar para "contar" piezas, atrapadas en un "tenedor", un par de banderas booleanas (el n√∫mero exacto que no necesitaba, siempre que las piezas fueran m√°s de una). <br><br>  Otra cosa que solucionar es la falta de un claro "ciclo de vida" en la ejecuci√≥n del movimiento.  Todas las banderas se reinician autom√°ticamente antes de comenzar el movimiento, pero ser√≠a m√°s f√°cil identificar claramente la fase de inicializaci√≥n.  En mi opini√≥n, en el c√°lculo del movimiento, deber√≠an ocurrir las siguientes fases: <br><br><ol><li>  Inicializaci√≥n de variables y comprobaci√≥n de condiciones previas para el movimiento compuesto. </li><li>  Inicializaci√≥n de variables y verificaci√≥n de precondiciones para el movimiento parcial. </li><li>  Generaci√≥n del movimiento parcial. </li><li>  Comprobaci√≥n de las condiciones posteriores del movimiento parcial </li><li>  Generando, completando y verificando las condiciones posteriores del movimiento compuesto </li><li>  Verificando las condiciones de terminaci√≥n del juego </li></ol><br>  El grupo de pasos del segundo al cuarto, en el movimiento compuesto completo, puede repetirse muchas veces.  La idea de las condiciones previas y posteriores, que llamo invariantes, la tom√© del proyecto Ludi.  Te cuento m√°s sobre el uso de invariantes m√°s adelante. <br><br><h2>  Sobre la importancia de la notaci√≥n </h2><br>  La generaci√≥n de todos los movimientos posibles desde la posici√≥n es solo la mitad de la historia.  Para controlar el estado del juego se requiere una presentaci√≥n compacta de los movimientos generados.  En ZoG, para este prop√≥sito, se usa la notaci√≥n ZSG.  Aqu√≠ hay una descripci√≥n de un posible comienzo de un juego de ajedrez de esta forma: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Este script est√° cerca de la <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">notaci√≥n de ajedrez</a> habitual y generalmente es f√°cil de usar.  Solo el cuarto movimiento de las blancas puede causar cierta confusi√≥n.  Entonces en ZSG parece un <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">enroque</a> .  La parte de la descripci√≥n del movimiento antes del personaje '@' es bastante clara;  es el movimiento simult√°neo de la torre y el rey, pero ¬øqu√© sigue?  Por lo tanto, en ZSG, parece que se requiere un restablecimiento de los atributos de las piezas para evitar la posibilidad de enroque repetido. <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  ZoG usa su notaci√≥n ZSG particularmente para mostrar el curso del juego en una forma comprensible para el jugador.  A la derecha del tablero, puede abrir una subventana "Lista de movimientos".  Esta lista se puede usar para navegar por el juego grabado.  Esta lista no es muy conveniente, porque no se admite una vista de √°rbol ramificado de juegos alternativos.  La parte de los giros registrados asociados con cambios en los atributos de las piezas, no se muestra al usuario. <br></div></div><br>  La grabaci√≥n de un movimiento en notaci√≥n ZSG debe contener informaci√≥n completa suficiente para cambiar correctamente el estado del juego.  Si se pierde informaci√≥n sobre un cambio de atributos, en un juego de acuerdo con dicho registro, un movimiento podr√≠a repetirse incorrectamente (por ejemplo, el jugador tendr√≠a la oportunidad de volver a ejecutar el enroque).  Desafortunadamente, en las extensiones DLL (como Axiom), la informaci√≥n extendida no se puede transmitir. <br><br>  Al trabajar con extensiones DLL, ZoG se ve obligado a hacer una manipulaci√≥n bastante astuta cuando se posiciona en un movimiento seleccionado (por ejemplo, cuando retrocede un movimiento).  Desde [cada] posici√≥n anterior [trabajando desde el comienzo del juego], se generan todos los movimientos posibles, y luego, dentro de esa lista, uno debe buscar un movimiento con la representaci√≥n ZSG [correspondiente].  Los [efectos secundarios de cada] movimiento generado se aplican a [cada uno de los sucesivos] estados del juego, ya que es posible realizar efectos secundarios no reflejados en la representaci√≥n ZSG del movimiento. <br><br>  La situaci√≥n se ve agravada por el hecho de que la √∫nica forma de llegar al estado del juego en el momento de un movimiento en el pasado, es la aplicaci√≥n consistente de todos los movimientos desde el comienzo del juego, hasta el estado inicial del tablero.  En <a href="https://habr.com/ru/post/234587/">casos</a> realmente <a href="https://habr.com/ru/post/234587/">complejos</a> , este tipo de navegaci√≥n no se produce r√°pidamente.  Otra desventaja de la notaci√≥n ZSG puede ilustrarse mediante la grabaci√≥n del siguiente movimiento en el juego de <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go</a> : <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Aqu√≠, en la posici√≥n G19, se coloca una piedra blanca que captura un grupo de piedras negras.  Dado que todas las piezas involucradas en el rendimiento de la colocaci√≥n deben mencionarse en el rendimiento ZSG, el registro del turno puede parecer muy largo (en Go, una gota puede capturar hasta 360 piedras).  A lo que esto puede conducir, escrib√≠ <a href="https://habr.com/ru/post/235483/">antes</a> .  El tama√±o del b√∫fer asignado para grabar el movimiento ZoG puede no ser suficiente.  Adem√°s, si por alguna raz√≥n el orden de eliminaci√≥n de piedras cambia (en el proceso de desarrollo del juego sucede), un intento de aplicar un movimiento, desde un antiguo orden de capturas, fracasar√°. <br><br>  Afortunadamente, hay una manera simple de lidiar con todos estos problemas.  Veamos c√≥mo definir movimientos de piezas en ZRF: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  Los nombres de movimientos, definidos en las macros de ZoG, son inaccesibles como generadores de movimientos.  Pero, ¬øqu√© nos impide renunciar a las macros y hacer descripciones de los movimientos con sus nombres?  As√≠ es como se ver√≠a el registro para un juego de ajedrez: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  Los lectores astutos pueden notar que en los movimientos para "negro" us√© direcciones que no son apropiadas para las direcciones reales en el tablero de ajedrez.  Esto est√° relacionado con el hecho de que las "simetr√≠as" se definen para el negro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  En t√©rminos generales, entonces, lo que para el blanco es "norte", para el negro es "sur", y viceversa. <br></div></div><br>  Los beneficios de tal registro no son obvios, pero tiene una ventaja importante.  Todos los movimientos se describen de manera uniforme y estas descripciones no contienen nada adicional (los nombres de las descripciones de los movimientos, por supuesto, podr√≠an hacerse m√°s "descriptivos").  En la descripci√≥n del enroque se logr√≥ deshacerse tanto de los cambios de atributos como de la descripci√≥n del movimiento de torre (esta descripci√≥n ya no depende de los detalles de implementaci√≥n del movimiento).  Existe una utilidad a√∫n m√°s clara de dichos registros en el caso del juego Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  Y eso es todo!  Si las piedras del oponente se toman de acuerdo con las reglas del juego, no hay necesidad de enumerarlas todas en la descripci√≥n del movimiento.  Es suficiente indicar el espacio de desplazamiento inicial y final (posiblemente con una se√±al para tomar), el nombre del movimiento en ejecuci√≥n y la l√≠nea de par√°metros que se le pas√≥.  Por supuesto, para realizar un movimiento de acuerdo con esta descripci√≥n, para la decodificaci√≥n, es necesario acceder al m√≥dulo de generaci√≥n de movimientos, ¬°pero ZoG lo hace! <br><br>  Otra posibilidad, que deber√≠a admitirse, aparece en la funcionalidad de los movimientos "parciales".  Aqu√≠ hay un ejemplo de " <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">damas rusas</a> ": <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Aqu√≠ los negros, en su segundo movimiento, toman dos piezas en d4 y f4.  Una "transformaci√≥n" preliminar de estas piezas a XChecker es una caracter√≠stica de esta implementaci√≥n y sirve para evitar la recuperaci√≥n de piezas "derrotadas" en el mismo movimiento.  La frase "parcial 2" describe el comienzo del curso "compuesto", que consiste en dos movimientos "parciales".  Esta forma de descripci√≥n es inconveniente, porque en el momento de la generaci√≥n del primer movimiento, la longitud de la secuencia de movimientos "parciales" puede no ser conocida.  As√≠ es como se ver√° esta descripci√≥n en un nuevo formato: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Los detalles de implementaci√≥n relacionados con la "transformaci√≥n" de piezas son irrelevantes.  La captura de piezas tampoco se especifica, ya que en las fichas, la captura se produce como un "efecto secundario" del movimiento de la pieza y no de acuerdo con el "principio del ajedrez". El progreso parcial se codificar√° con el s√≠mbolo "+" al principio de la linea.  Un "+" solitario indica la finalizaci√≥n de un "movimiento compuesto" (de hecho, este es el movimiento "parcial" habitual, que contiene un movimiento faltante, una cadena vac√≠a). <br><br>  Por lo tanto, utilizando reglas con nombre para la implementaci√≥n de movimientos, uno ha logrado crear una notaci√≥n universal, satisfaciendo completamente nuestros requisitos.  Por supuesto, no tiene nada que ver ni con el ajedrez est√°ndar ni con ninguna otra notaci√≥n, pero da la casualidad de que la notaci√≥n convencional para ajedrez, damas y otros juegos tampoco tienen nada que ver entre s√≠.  El m√≥dulo de visualizaci√≥n siempre puede convertir el registro de movimiento en una forma m√°s familiar aceptada para un juego en particular.  La conversi√≥n tambi√©n puede ser de alguna forma universal, como <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  El ciclo de vida del juego. </h2><br>  Adem√°s de la informaci√≥n sobre la colocaci√≥n de piezas en el tablero, la secuencia de turnos es una parte del estado del juego, una variable en el proceso del juego.  En el caso m√°s simple (y m√°s com√∫n), para almacenar esta informaci√≥n un bit ser√° suficiente, pero ZoG brinda algunas oportunidades m√°s para implementar casos m√°s complejos.  ¬°As√≠ es como podr√≠a verse una descripci√≥n de una secuencia de movimientos para el juego <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  En este juego, cada jugador hace tres movimientos a la vez, pero si tuvieras la oportunidad de hacer tres movimientos desde la posici√≥n inicial, √©l podr√≠a destruir una de las piezas del oponente, lo que le dar√≠a un Ventaja significativa.  Por esta raz√≥n, el primer jugador debe hacer un solo movimiento (le da la oportunidad de prepararse para atacar a un jugador contrario, pero no atacarlo), el segundo: dos movimientos (esto tampoco es suficiente para atacar a un jugador contrario), despu√©s de que cada jugador siempre hace tres movimientos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  La repetici√≥n de la etiqueta indica el comienzo de una secuencia de movimientos que se repite c√≠clicamente.  Si no aparece, la descripci√≥n completa se repite c√≠clicamente.  ZoG no permite que el uso de la etiqueta se repita m√°s de una vez.  Otra caracter√≠stica importante es la especificaci√≥n del orden de giro.  As√≠ es como puede verse una descripci√≥n de la secuencia de turnos para un juego en el que cada jugador realiza dos turnos (el primer movimiento: mover piezas, el segundo: capturar piezas del oponente): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  Hay una capacidad m√°s asociada con la descripci√≥n de mover las piezas de otra persona, pero es muy inc√≥modo de usar.  El problema es que tal descripci√≥n no tiene alternativa.  Si la descripci√≥n indica que el movimiento debe ser realizado por una pieza enemiga, ¬°el jugador debe realizar este movimiento!  En ZoG es imposible describir la elecci√≥n de mover la pieza de √©l o de otra persona.  Si se necesita dicha capacidad en un juego (como en " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> "), es necesario que todas las piezas sean neutrales (creando para este prop√≥sito un jugador que no participe en el juego) y determinar para todos los jugadores la oportunidad para mover una pieza neutral.  He dicho anteriormente que, por defecto, es mucho m√°s f√°cil permitir a todos los jugadores la posibilidad de mover cualquier pieza (tanto la suya como la de su oponente) agregando las comprobaciones necesarias en los algoritmos de generaci√≥n de movimiento. <br><br>  Como puede ver, el rango de opciones proporcionadas por ZoG para la descripci√≥n de la secuencia de giros es extremadamente limitado.  Axiom tampoco logra agregar nuevas funciones, ya que (generalmente) se ejecuta sobre ZoG.  Ludi, a este respecto, es a√∫n m√°s pobre.  Para maximizar la unificaci√≥n de las reglas del juego (requerido para la posibilidad de usar algoritmos gen√©ricos), en este proyecto, todas las capacidades descriptivas se han simplificado deliberadamente, lo que ha provocado la eliminaci√≥n de capas enteras de juegos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " es un buen ejemplo de un juego con un ciclo de vida complejo. En este juego, hay dos fases con reglas para la ejecuci√≥n del movimiento que difieren significativamente. Al comienzo del juego, parte de las piedras est√° "en la mano "De cada jugador. Si bien todav√≠a hay piedras" en la mano ", las piedras se colocan en pozos, una piedra a la vez. Cuando las piedras" en la mano "se agotan, comienza la segunda fase del juego, con la distribuci√≥n de insertos No se puede decir que este juego no se pueda describir en ZRF (el lenguaje de descripci√≥n de ZoG), pero debido a las limitaciones de ZoG, esta implementaci√≥n ser√≠a extremadamente confusa (lo que ciertamente no es lo mejor para la calidad del trabajo de IA). Veamos c√≥mo se ver√≠a la descripci√≥n de tal juego en un "mundo ideal": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Aqu√≠, cada lista de orden de turno determina su secuencia repetitiva de movimientos (distingui√©ndose por el modo de ejecuci√≥n del movimiento).  La etiqueta de palabra clave define una etiqueta a la que se puede hacer una transici√≥n durante la generaci√≥n del √∫ltimo movimiento.  Puede notar que aqu√≠ procedemos de la suposici√≥n impl√≠cita de que dicha transici√≥n siempre ocurre despu√©s del movimiento del segundo jugador (de lo contrario, violar√≠a la secuencia de movimientos).  ¬øC√≥mo hacer la transici√≥n a la siguiente fase en un momento arbitrario? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Aqu√≠, las etiquetas se llevan en el cuerpo del bucle y comprenden dos nombres.  Los nombres de las etiquetas en las listas de etiquetas aparecen en el orden de transferencia de jugadores en la lista de jugadores.  El nombre utilizado para la transici√≥n est√° determinado por el jugador que realiz√≥ el √∫ltimo movimiento.  Si este fuera el Norte, pasar√° a la primera etiqueta, de lo contrario, a la segunda.  Si no se utiliza alguno de los nombres en las etiquetas, la posici√≥n correspondiente se puede llenar con un gui√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Un aspecto importante en el manejo de movimientos alternos, es la capacidad de realizar un turno repetido.  En juegos de la <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">familia de Tablas</a> , como <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Backgammon</a> o <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , por ejemplo, la capacidad de realizar turnos repetidos es un elemento importante de las t√°cticas de juego.  En ZoG se puede usar pasar un turno para emular esta caracter√≠stica, pero este enfoque complica significativamente la descripci√≥n del juego (especialmente con m√°s jugadores).  Ser√≠a mucho m√°s l√≥gico usar una etiqueta para repetir un turno: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Una vez que el juego salt√≥ a la repetici√≥n de la etiqueta, el jugador volver√° a jugar su turno (la etiqueta m√°s cercana a la posici√≥n actual en la lista de turnos tendr√° efecto).  Me gusta el enfoque de <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> en sus definiciones impl√≠citas.  La generaci√≥n impl√≠cita de estructuras de control puede simplificar significativamente la descripci√≥n del juego.  En la medida en que los movimientos repetidos se pueden usar en muchos juegos, las etiquetas se repiten, anticipando la posible repetici√≥n de cualquier turno puede estar impl√≠cito: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  Adem√°s, dado que la secuencia de turnos es totalmente consistente con el orden escrito de los jugadores en la construcci√≥n de jugadores, puedes generar autom√°ticamente la frase completa del orden de turno: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Cuanto m√°s f√°cil sea escribir la descripci√≥n, mejor. <br><br><h2>  Invariable rompible </h2><br>  Lo principal que no me gusta en ZoG se puede expresar con una palabra: checkmated.  A primera vista, es solo una condici√≥n (muy com√∫n en los juegos de la <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">familia</a> del <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">ajedrez</a> ) que vincula el final del juego con la formaci√≥n de una situaci√≥n de compa√±ero.  Por desgracia, en un examen m√°s detallado, la simplicidad se muestra enga√±osa.  El uso de esta palabra clave significa no solo el rendimiento, despu√©s de cada movimiento, de una verificaci√≥n para la finalizaci√≥n del juego, sino que tambi√©n impone al jugador cierto "comportamiento". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Desde el <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi</a> habitual, este juego difiere solo en el n√∫mero de jugadores.  Desafortunadamente, esta diferencia es suficiente para hacer que el trabajo de determinar el jaque mate (y todo lo relacionado con esta palabra "m√°gica") sea incorrecto.  La verificaci√≥n de estar bajo control se realiza solo con relaci√≥n a uno de los jugadores.  ¬°Como resultado, el rey puede ser atacado y ser comido [por una combinaci√≥n de turnos de oponentes incluso cuando no se deja en "cheque"]!  Que esto no sea √≥ptimo se reflejar√° en el trabajo de la IA. <br><br>  Si este problema parece insignificante, vale la pena recordar que las coaliciones generalmente se forman en juegos de cuatro jugadores "par contra par".  ¬°En el caso de la formaci√≥n de coaliciones, debemos considerar que las piezas amigas del rey no lo amenazan!  Entonces, por ejemplo, dos reyes amigos pueden residir en espacios vecinos del tablero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Se vuelve m√°s complicado que nunca si un jugador puede tener varios reyes.  En " <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">Ajedrez Tamerl√°n</a> ", el pe√≥n real se convierte en un pr√≠ncipe (en realidad, un segundo rey).  Si esto sucede, solo puedes ganar capturando al primer rey (cualquiera de los dos) y emparejando al segundo.  ¬°En este juego, puedes obtener incluso un tercer rey, doble gasto en la transformaci√≥n del "pe√≥n de peones"!  Las capacidades expresivas de "checkmated" no son suficientes para describir adecuadamente esta situaci√≥n. <br><br>  Otra dificultad puede ser el proceso mismo de dar mate.  Entonces, en el ajedrez mongol ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ), el resultado del intento de mate depende del orden en que las piezas ejecutan el "chequeo" secuencial.  El resultado puede ser una victoria o un empate (como un compa√±ero por un pe√≥n), o incluso una derrota (el compa√±ero de caballo est√° prohibido, pero puedes dar el cheque).  Un poco menos ex√≥tico, a este respecto, es el Shogi japon√©s.  En este juego, est√° prohibido dar mate con un pe√≥n ca√≠do, pero puedes dar el cheque con un pe√≥n ca√≠do y dar mate con un pe√≥n movido. <br><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  Hay un punto m√°s importante que vale la pena mencionar.  En algunos juegos, como Rhythmomagic, puede haber varias formas diferentes de finalizar el juego.  La forma m√°s obvia de ganar, que implica la destrucci√≥n de las piezas del oponente, es tambi√©n la menos preferida.  Para una victoria m√°s significativa, uno debe organizar las piezas en el territorio enemigo en un cierto patr√≥n. <br><br>  Uno debe distinguir entre los tipos de victorias (y derrotas y empates) en el nivel de descripci√≥n del juego, ya que el tipo de final del juego puede ser importante para el jugador.  Adem√°s, deber√≠a ser posible asignar prioridades num√©ricas a los diversos finales del juego.  Tras el cumplimiento simult√°neo de varias condiciones de finalizaci√≥n, la que tiene la mayor prioridad debe contar. <br></div></div><br>  Obviamente, uno debe separar la l√≥gica de verificaci√≥n del final del juego de la prueba de que el rey haya ca√≠do en jaque, que es una <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">regla invariable</a> que se verifica despu√©s de cada turno.  La violaci√≥n de la regla hace que sea imposible realizar el movimiento (el movimiento se elimina de la lista de movimientos disponibles).  Entonces, una prueba (simplificada) para que un Rey est√© bajo control podr√≠a verse as√≠ para el "ajedrez Tamerl√°n": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Es importante entender que esta prueba debe llevarse a cabo solo para los propios reyes (utilic√© el predicado mi, porque el predicado amigo, con apoyo para las coaliciones, se satisfar√° no solo para las propias piezas, sino tambi√©n para el piezas de todos los jugadores amigos).  Aceptable (y deseable, [si hay m√∫ltiples reyes amigos]) es la situaci√≥n en la que el rey enemigo cae bajo control, despu√©s de un movimiento, pero por el propio rey.  ¬°Esta situaci√≥n deber√≠a ser imposible [a menos que haya m√∫ltiples reyes amigos]!  Habiendo brindado apoyo para verificar tales reglas, verificar la finalizaci√≥n del juego por jaque mate se vuelve trivial.  Si no hay movimientos posibles y el [√∫nico] rey est√° bajo control, el juego termina [si ese rey pertenece al √∫ltimo jugador superviviente de la segunda √∫ltima coalici√≥n superviviente]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  La capacidad de determinar invariantes ser√° √∫til en otros juegos, como en las <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">damas</a> .  La mayor dificultad en la implementaci√≥n de juegos de esta familia, est√° vinculada a la implementaci√≥n de la "regla de la mayor√≠a".  En casi todos los juegos de draft, la captura es obligatoria.  Adem√°s, en la mayor√≠a de los juegos de esta familia, hay una finalizaci√≥n caracter√≠stica de "capturas en cadena" en un solo turno.  El verificador, habiendo capturado, contin√∫a tomando otras piezas, si es posible.  En la mayor√≠a de los juegos, el jugador debe realizar capturas en cadena hasta el final, pero hay excepciones a esta regla, por ejemplo, <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  Usando el mecanismo de movimientos parciales, implementar una "captura en cadena" es bastante simple.  Las dificultades surgen cuando, adem√°s, uno impone una condici√≥n bajo la cual, de todas las opciones posibles, uno debe elegir una cadena en la que se capture un n√∫mero m√°ximo de piezas.  En ZoG, esta l√≥gica debe implementarse desde cero al nivel de "hardcoding": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Esta configuraci√≥n es adecuada para " <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">damas internacionales</a> ", pero en las " <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">damas italianas</a> " la regla de la mayor√≠a se formula de manera diferente.  En esta versi√≥n del juego, si hay varias opciones para la misma cantidad de capturas, debes seleccionar una opci√≥n que capture la mayor cantidad de fichas transformadas (reyes).  Los desarrolladores de ZoG han proporcionado esto.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ingresa la siguiente configuraci√≥n: </font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta configuraci√≥n, se cuenta no solo el n√∫mero de piezas capturadas, sino tambi√©n su tipo. </font><font style="vertical-align: inherit;">Lamentablemente, no todo puede preverse. </font><font style="vertical-align: inherit;">As√≠ es como se formula la "regla de la mayor√≠a" en las "antiguas fichas francesas":</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si mediante una serie de capturas es posible capturar la misma cantidad de fichas con un hombre simple o con un rey, el jugador debe usar el rey. </font><font style="vertical-align: inherit;">Sin embargo, si el n√∫mero de fichas es el mismo en ambos casos, pero en uno hay un rey enemigo (o hay m√°s), el jugador debe elegir esta opci√≥n, incluso si la captura se realiza utilizando el simple comprobador, y no usando al rey</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, en la actualidad, casi nadie juega esta versi√≥n de las damas, pero su existencia demuestra claramente las deficiencias de la implementaci√≥n "codificada". </font><font style="vertical-align: inherit;">El uso del mecanismo de invariantes permite todas las opciones posibles para la "regla de la mayor√≠a" de manera universal. </font><font style="vertical-align: inherit;">Para la </font><font style="vertical-align: inherit;">implementaci√≥n de </font><font style="vertical-align: inherit;">los " </font></font><a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antiguos corredores franceses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " ser√≠a la siguiente:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠, asumimos que las reglas para la generaci√≥n de captura llenan correctamente [las siguientes] variables locales: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recuento de captura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - total de piezas capturadas</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suma de captura</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - n√∫mero de reyes capturados</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor de ataque</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - valor de captura de pieza</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asociado con cada una de estas variables hay un acumulador de valores, almacenado en una variable con el prefijo max. Las tres verificaciones se ejecutan en serie. La violaci√≥n de cualquiera de las condiciones de verificaci√≥n interrumpe inmediatamente la generaci√≥n de la siguiente opci√≥n de turno (la captura no se almacena en la lista de turnos posibles). Como las comprobaciones realizadas est√°n asociadas a valores variables, no es suficiente [para probar solo la nueva opci√≥n de captura actual]. Cada prueba genera una "regla flexible" asociada con la captura generada [que puede revisar el valor m√°ximo acumulado]. Despu√©s de cada cambio en cualquier acumulador, todas las reglas asociadas deben verificarse nuevamente [para cada opci√≥n en la lista]. Si se infringe alguna de las condiciones para una opci√≥n generada previamente, esa opci√≥n debe eliminarse de la lista de posibles opciones de giro.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es la traducci√≥n de mi art√≠culo del a√±o 2014. </font><font style="vertical-align: inherit;">Desde entonces, he repensado mucho y el </font></font><a href="https://glukkazan.github.io/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto Dagaz se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ha convertido en una realidad, pero no cambi√© casi nada en el texto. </font><font style="vertical-align: inherit;">Este art√≠culo fue traducido por mi amigo </font></font><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Howard McCay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y le estoy agradecido por el trabajo realizado.</font></font><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481868/">https://habr.com/ru/post/481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481854/index.html">Probar ideas a trav√©s de la creaci√≥n de prototipos del tablero</a></li>
<li><a href="../481858/index.html">Cumplea√±os en Google Calendar con edad</a></li>
<li><a href="../481860/index.html">¬øQu√© debe hacer TI en 2020?</a></li>
<li><a href="../481862/index.html">Sistemas de aprendizaje autom√°tico integrados Nvidia Jetson</a></li>
<li><a href="../481866/index.html">DBA: cuando pasa VACUUM, limpiamos la mesa manualmente</a></li>
<li><a href="../481874/index.html">M√©tricas - indicadores de salud del proyecto</a></li>
<li><a href="../481880/index.html">F√≠sica para un tirador PvP m√≥vil y c√≥mo nos hicimos amigos de ECS</a></li>
<li><a href="../481882/index.html">4. Fortinet Getting Started v6.0. Pol√≠ticas de firewall</a></li>
<li><a href="../481884/index.html">Encrucijada de mayores: ¬øa d√≥nde ir despu√©s?</a></li>
<li><a href="../481886/index.html">C√≥mo crear r√°pidamente un diario de asistencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>