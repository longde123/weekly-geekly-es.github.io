<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🍳 🐈 🐅 一次严格的实时异构竞争数据处理 🈁 🗳️ ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注解 


 仅一次（ 精确一次 ）实时处理数据是一项极其艰巨的任务，并且需要在整个计算链中采取认真周到的方法。 甚至有人认为这样的任务是不可能的 。 实际上，我希望有一种方法可以提供容错处理而没有任何延迟，并且可以使用各种数据存储，这对系统提出了新的甚至更严格的要求： 并发一次和持久层的异构性。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>一次严格的实时异构竞争数据处理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="竞争香肠"></p><br><h2 id="annotaciya"> 注解 </h2><br><p> 仅一次（ <em>精确一次</em> ）实时处理数据是一项极其艰巨的任务，并且需要在整个计算链中采取认真周到的方法。 甚至有人认为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这样的任务是不可能的</a> 。 实际上，我希望有一种方法可以提供容错处理而没有任何延迟，并且可以使用各种数据存储，这对系统提出了新的甚至更严格的要求： <em>并发一次</em>和持久层的异构性。 迄今为止，这样的要求不支持任何现有系统。 </p><br><p> 所提出的方法将一致地揭示秘密成分和必要的概念，这些概念使从字面上从两个组件实现异构<em>并发一次精确</em>处理相对容易。 </p><br><h2 id="vvedenie"> 引言 </h2><br><p> 分布式系统的开发人员经历了以下几个阶段： </p><br><p>  <em>阶段1：算法</em> 。 这是对基本算法，数据结构和编程方法（如OOP等）的研究。 该代码仅是单线程的。 进入专业的初始阶段。 但是，它非常复杂并且可以持续数年。 </p><br><p>  <em>阶段2：多线程</em> 。 接下来，出现了从铁中获取最大效率的问题，多线程，异步，赛车，调试，跟踪，不眠之夜……许多人陷于这一阶段，甚至在某个时候开始感到莫名的兴奋。 但是只有少数几个了解虚拟内存和内存模型，无锁/无等待算法以及各种异步模型的体系结构。 几乎没有人使用过-多线程代码验证。 </p><br><p>  <em>第三阶段：发行</em> 。 这里发生了这样的垃圾，童话和笔都无法描述。 </p><a name="habracut"></a><br><p> 似乎有些复杂。 我们进行转换：许多线程-&gt;许多进程-&gt;许多服务器。 但是转换的每个步骤都会带来质的变化，它们都落在系统上，将其压碎并变成灰尘。 </p><br><p> 这里的重点是更改错误处理域和共享内存的可用性。 如果以前在每个线程中始终有一块内存可用，并且如果需要，则在每个进程中现在都没有，现在也没有。 每个人都为自己，独立而自豪。 </p><br><p> 如果较早的时候流中的故障同时淹没了流和进程，那么这很好，因为 并不会导致部分失败，现在部分失败已成为常态，并且每次您认为每项行动之前都会：“如果？”。 实际上，这很烦人，而且从动作本身上分散了注意力，以至于因此而使代码不时增长，而是按数量级增长。 一切都变成了错误处理，状态切换和上下文保存，由于一个组件，另一个组件的故障以及某些服务的不可访问性等导致的恢复的问题。 等 加强了对所有这些东西的监视，您可以在自己喜欢的笔记本电脑上睡个好觉。 </p><br><p> 无论是多线程问题：我都使用了互斥锁，并切碎了共享内存，以取乐。 美女！ </p><br><p> 结果，我们不得不删除了关键的和经过战斗考验的模式，由于某种原因，新模式取代了它们，但由于某种原因而未能交付，结果就像是在开玩笑说仙子如何挥动魔杖，而塔从坦克上掉下来了。 </p><br><p> 但是，分布式系统具有一组经过验证的实践和经过验证的算法。 但是，尽管有积累的经验，许多科学文章和学术研究，每个自重的程序员都认为有责任拒绝著名的成就并发挥自己的才能。 毕竟，如果您可以使用算法和多线程技术，那么如何使它陷入混乱呢？ 这里不可能有两种意见！ </p><br><p> 结果，系统出现故障，数据分散和恶化，服务定期变得无法写入，甚至完全不可用，因为节点突然崩溃，网络瘫痪，Java消耗了大量内存和GC钝化，还有许多其他原因可能会延迟其终止给当局。 </p><br><p> 但是，即使采用众所周知且经过验证的方法，生活也不会变得更加轻松，因为 分布式可靠原语是重量级的，对可执行代码的逻辑有严格的要求。 因此，尽可能地切掉角落。 而且，通常情况下，匆忙偷工减料，会出现简单性和相对可伸缩性，但是分布式系统的可靠性，可用性和一致性却消失了。 </p><br><p> 理想情况下，我完全不希望我们的系统是分布式和多线程的，即 在第一阶段（算法）工作，而无需考虑第二阶段（多线程+异步）和第三阶段（分布式）。 这种隔离抽象的方式将显着提高编写代码的简便性，可靠性和速度。 不幸的是，目前只有在梦中才有可能。 </p><br><p> 但是，单个抽象允许相对隔离。 典型示例之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">协程</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> ，其中我们获得了同步而不是异步代码，即 我们从第二阶段过渡到第一阶段，这使我们可以大大简化代码的编写和维护。 </p><br><p> 文章逐步揭示了使用无锁算法来构建可靠的一致的分布式可扩展实时系统，即 第二阶段的无锁成就如何帮助实现第三阶段，从而将任务减少到第一阶段的单线程算法。 </p><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p> 此任务仅说明一些重要方法，并作为将问题引入上下文的示例进行介绍。 可以很容易地将其推广到更复杂的情况，这将在将来完成。 </p><br><p>  <strong>任务：实时流数据处理</strong> 。 </p><br><p> 有两个数字流。 处理程序读取这些输入流的数据，并选择特定时间段内的最后一个数字。 这些数字是在此时间间隔内得出的平均值，即 给定时间在滑动数据窗口中显示。 必须将获得的平均值写入输出队列以进行后续处理。 另外，如果窗口中的数字数量超过某个阈值，则将外部事务数据库中的计数器增加一。 </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="最初的"></p><br><p> 我们注意到此问题的某些功能。 </p><br><ol><li>  <em>非确定性</em> 。 有两种不确定性行为的来源：这是从两个流中读取的内容以及一个时间窗口。 显然，可以以不同的方式进行读取，并且最终结果将取决于将以何种顺序提取数据。 时间窗口也会从开始到开始更改结果，因为 窗口中的数据量将取决于工作速度。 </li><li>  <em>处理程序的状态</em> 。 窗口中存在一组数字形式的处理程序状态，工作的当前结果和后续结果取决于该状态。 即 我们有一个有状态的处理程序。 </li><li>  <em>与外部存储的交互</em> 。 有必要更新外部数据库中的计数器值。 关键点是外部存储的类型不同于处理器和线程状态的存储。 </li></ol><br><p> 如下所示，所有这些都会严重影响所使用的工具和可能的实现方法。 </p><br><p> 仍然需要在任务上添加一点点内容，立即将任务从复杂性超出的领域转移到不可能的事情：需要<em>并发一次准确的</em>保证。 </p><br><h2 id="exactly-once"> 一次 </h2><br><p>  <em>精确一次</em>通常被解释得过于宽泛，这模糊了该术语本身，并且不再满足该任务的原始要求。 如果我们要讨论的是在一台计算机上本地运行的系统，那么一切都很简单：多花一点钱，走得更远。 但是在这种情况下，我们谈论的是一种分布式系统，其中： </p><br><ol><li> 处理程序的数量可能很大：每个处理程序都使用自己的数据。 而且，可以将结果添加到各个位置，例如，甚至可能改组的外部数据库。 </li><li> 每个处理程序都可能突然停止处理。 容错系统意味着即使在系统各个部分发生故障的情况下也可以继续运行。 </li></ol><br><p> 因此，我们必须为处理程序可能跌倒这一事实做好准备，而另一个处理程序应该接管已经完成的工作并继续进行处理。 </p><br><p> 问题立即浮出水面：如果不确定的处理程序正常工作， <em>一次将</em>意味着什么？ 毕竟，一般而言，每次重新启动时，我们都会收到不同的结果状态。 答案很简单： <em>一次</em>执行<em>一次，</em>这样的系统执行中，每个输入值都会被精确处理一次，从而给出相应的输出结果。 此外，此执行不必在物理上在同一节点上。 但是结果应该好像一切都在单个逻辑节点上进行处理<em>而没有崩溃一样</em> 。 </p><br><h2 id="concurrent-exactly-once"> 一次并发 </h2><br><p> 为了加重要求，我们引入了一个新概念： <em>并发精确一次</em> 。 与简单<em>一次</em>的根本区别是，在处理过程中没有暂停，就好像所有内容都在同一节点上处理一样， <strong>没有丢弃</strong>也<strong>没有暂停</strong> 。 在我们的任务中，为了演示的简单起见，我们将要求完全<em>并发一次</em> ，以便不考虑与当前不可用的现有系统进行比较。 </p><br><p> 具有这种要求的后果将在下面讨论。 </p><br><h2 id="tranzakcionnost"> 交易性 </h2><br><p> 为了使读者对已出现的复杂性更加了解，让我们看看开发这样的系统时必须考虑的各种不良情况。 我们还将尝试使用一种通用方法，该方法将允许我们考虑到我们的要求来解决上述问题。 </p><br><p> 首先想到的是需要记录处理程序以及输入和输出流的状态。 输出流的状态由一个简单的数字队列描述，输入流的状态由它们中的位置描述。 本质上，流是无限队列，并且队列中的位置唯一地设置位置。 </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="主意"></p><br><p> 以下处理程序的简单实现是使用某种数据仓库而产生的。 在此阶段，存储库的特定属性对我们而言并不重要。 我们将使用Pseco语言进行说明（Pseco：=伪代码）： </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p> 这是一种简单的单线程算法，可以根据上述任务从输入流中读取数据并写入所需的值。 </p><br><p> 让我们看看在任意时间点节点掉落以及恢复工作之后会发生什么。 显然，如果在<code>(A)</code>和<code>(E)</code>点跌倒了，一切都会好起来的：要么数据尚未记录在任何地方，我们只是恢复状态并在另一个节点上继续进行，或者所有必要的数据已被记录下来，然后继续下一步。 </p><br><p> 但是，如果其他所有地方都跌倒了，那么意外的麻烦正在等待着我们。 如果在<code>(B)</code>点发生下降，则在重新启动处理程序时，我们将恢复状态并在近似相同的数字范围内重新记录平均值。 在<code>(C)</code>点下降的情况下<code>(C)</code>除了平均重复次数外，还会以值的增量重复一次。 并且如果<code>(D)</code>下降<code>(D)</code>我们将获得处理程序的不一致状态：该状态对应于新的时间点，并且我们将从旧的输入流中读取值。 </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="惊喜"></p><br><p> 同时，重新安排录制操作时，根本不会发生根本变化：不一致和重复将保持不变。 因此，我们得出的结论是，所有更改存储库，输出队列和数据库中处理程序状态的操作都应以事务方式执行，即 一切都是原子的。 </p><br><p> 因此，有必要开发一种机制，以使不同的存储可以事务性地更改其状态，而不是独立于每个内部，而是同时在所有存储之间进行事务性更改。 当然，您可以将我们的存储放入外部数据库中，但是，该任务假定数据库引擎和流数据处理框架的引擎是分开的，并且彼此独立地工作。 在这里我想考虑最困难的情况，因为 简单的案例没有什么好考虑的。 </p><br><h2 id="konkurentnaya-otzyvchivost"> 竞争响应能力 </h2><br><p> 仔细考虑一次竞争性执行。 在容错系统的情况下，我们需要从某个角度继续工作。 显然，这是过去的观点，因为 为了保持性能，不可能存储当前和将来的所有状态变化时刻：要么保存最后的操作结果，要么保存一组用于增加吞吐量的值。 这种行为立即导致我们这样一个事实，即在恢复处理器状态之后，结果会有一些延迟，它将随着值组的大小和状态大小的增加而增加。 </p><br><p> 除了此延迟之外，系统中还存在与将状态加载到另一个节点相关的延迟。 除此之外，问题节点的检测还需要一些时间，并且通常需要很多时间。 首先，这是由于以下事实：如果我们设置了较短的检测时间，则可能会出现频繁的误报，这将导致各种不愉快的特殊效果。 </p><br><p> 此外，随着并行处理器数量的增加，突然发现，即使没有故障，并不是所有处理器都能很好地工作。 有时会发生钝器，这也会导致处理延迟。 此类钝器的原因可能多种多样： </p><br><ol><li>  <em>软件</em> ：GC暂停，内存碎片，分配器暂停，内核中断和任务调度，设备驱动程序问题导致速度降低。 </li><li>  <em>硬件</em> ：磁盘或网络负载高，由于散热问题，过载等导致CPU节流，由于技术问题而导致磁盘变慢。 </li></ol><br><p> 这绝不是详尽的问题列表，这些问题可能会使处理程序变慢。 </p><br><p> 因此，放慢速度是人们赖以生存的前提。 有时这不是一个严重的问题，有时，即使出现故障或减速，保持高处理速度也非常重要。 </p><br><p> 立即出现系统重复的想法：让我们为一个相同的数据流运行，而不是一个，而是两个，甚至三个。 这里的问题在于，在这种情况下，很容易发生重复和不一致的系统行为。 通常，框架不是针对这种行为而设计的，并且建议在任何给定时间处理程序的数量不超过一个。 允许描述的执行重复的系统称为<em>并发精确一次</em> 。 </p><br><p> 这种体系结构使您可以立即解决几个问题： </p><br><ol><li> 故障安全行为：如果其中一个节点发生故障，则另一个节点继续工作，就好像什么都没发生一样。 不需要额外的协调，因为 无论第一个处理程序的状态如何，都将执行第二个处理程序。 </li><li> 去除钝器：首先提供结果的人对他有好处。 对方将仅需选择一个新状态并从此刻开始继续。 </li></ol><br><p> 尤其是，这种方法使您可以在更可预测的时间内完成困难且困难的长时间计算，因为 两者都变得愚蠢和跌倒的可能性大大降低。 </p><br><h3 id="veroyatnostnaya-ocenka"> 概率评估 </h3><br><p> 让我们尝试评估重复性能的好处。 假设处理程序平均每天都会发生一些事情：GC变钝了，或者节点在说谎，或者容器变得癌了。 还假设我们在10秒内准备好数据包。 </p><br><p> 那么，在创建包期间发生某些事情的概率为<code>10 / (24 · 3600) ≃ 1e-4</code> 。 </p><br><p> 如果并行运行两个处理程序，则两次飞行的概率为<code>≃ 1e-8</code> 。 因此，这项活动将在23年后到来！ 是的，系统寿命不长，这将永远不会发生！ </p><br><p> 而且，如果包装的准备时间更短和/或发钝的次数更少，那么这个数字只会增加。 </p><br><p> 因此，我们得出结论，正在考虑的方法大大提高了整个系统的可靠性。 剩下的只是解决这样一个小问题：在哪里阅读如何制作<em>并发一次精确</em>系统。 答案很简单：您必须在这里阅读。 </p><br><h2 id="polutranzakcii"> 半交易 </h2><br><p> 为了进一步讨论，我们需要<em>半事务</em>的概念。 解释它的最简单方法是举一个例子。 </p><br><p> 考虑将资金从一个银行帐户转移到另一个银行帐户。 使用Pseco语言进行交易的传统方法可以描述如下： </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p> 但是，如果无法进行这些交易怎么办？ 使用锁，可以按照以下步骤进行操作： </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p> 这种方法可能导致死锁，因为 可以并行执行不同顺序的锁定。 要纠正此行为，只需引入一个以确定性顺序（例如，按键排序）同时获取多个锁的函数，即可完全消除可能的死锁。 </p><br><p> 但是，可以稍微简化实现： </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p> 这种方法还可以使最终状态保持一致，并通过防止过度支出资金的类型来保存不变性。 与以前的方法的主要区别在于，在这种实施方式中，我们有一定的时间段内帐户处于不一致状态。 即，这种操作意味着账户中资金的总状态不会改变。 在这种情况下， <code>lock_from.release()</code>和<code>db.lock(to)</code>之间存在一个时间间隔，在此时间间隔内，数据库可能给出不一致的值：总数可能与正确的向下数值不同。 </p><br><p> 实际上，我们将一笔用于汇款的交易分为两个半交易： </p><br><ol><li> 前半笔交易会进行检查，并从帐户中扣除必要的金额。 </li><li> 第二半事务将提取的金额写入另一个帐户。 </li></ol><br><p> 显然，将交易拆分为较小的交易通常会违反交易行为。 上面的例子也不例外。 但是，如果完全完成了链中的所有半事务，那么结果将与保留的所有不变量保持一致。 这正是半交易链的重要属性。 </p><br><p> 暂时失去一些一致性，我们仍然获得了另一个有用的功能：操作的独立性，因此具有更好的可伸缩性。 独立性体现在以下事实上：每次半事务仅处理一行，读取，检查和更改其数据，而不与其他数据通信。 因此，您可以改组其事务仅使用一个分片的数据库。 而且，这种方法可用于异构存储库的情况。 半事务可以从一种类型的存储开始，而在另一种类型上结束。 这种有用的属性将在将来使用。 </p><br><p> 一个合理的问题出现了：如何在分布式系统中实现半-而不是耙？ 要解决此问题，您需要考虑无锁方法。 </p><br><h2 id="lock-free"> 无锁 </h2><br><p> 如您所知，无锁方法有时会提高多线程系统的性能，尤其是在竞争性访问资源的情况下。 但是，完全不清楚这种方法是否可以用于分布式系统中。 让我们深入研究一下什么是无锁，以及为什么此属性对解决我们的问题很有用。 </p><br><p> 有些开发人员有时不太了解什么是无锁。 狭narrow的眼光表明这与原子处理器指令有关。 在这里重要的是要理解，无锁意味着使用“原子”，反之则不成立，也就是说， 并非所有“原子”都提供无锁行为。 </p><br><p> 无锁算法的一个重要属性是至少一个线程在系统中取得了进展。 但是由于某些原因，许多人将此属性归为定义（例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Wikipedia上</a>找到的这样的钝性定义）。 这里有必要添加一个重要的细微差别：即使在一个或多个线程变钝的情况下也取得了进展。 这是一个非常关键的点，经常被忽略，并且对分布式系统有严重的影响。 </p><br><p> 为什么没有至少一个线程的进度条件会否定无锁算法的概念？ 事实是，在这种情况下，通常的自旋锁也将是无锁的。 确实，锁定者将取得进步。 有没有进度=&gt;无锁的线程？ </p><br><p> 显然，无锁意味着没有锁，而自旋锁的名称表明这是一个真正的锁。 这就是为什么即使在直率的情况下，也要为进度添加条件很重要。 毕竟，这些延迟可以无限期地持续下去，因为 该定义并未说明上限时间线。 如果是这样，那么这种延迟在某种意义上将等同于流量的关闭。 在这种情况下，无锁算法将在这种情况下取​​得进展。 </p><br><p> 但是谁说无锁方法专门适用于多线程系统？ 将同一节点上同一进程中的线程替换为不同节点上的进程，并使用共享的分布式存储来替换线程的共享内存，我们得到了一种无锁的分布式算法。 </p><br><p> 在这样的系统中，节点掉落等效于线程执行一段时间的延迟，因为 现在该恢复工作了。 同时，无锁方法允许分布式系统中的其他参与者继续工作。 此外，特殊的无锁算法可以彼此并行运行，从而检测出竞争性变化并减少重复项。 </p><br><p>  <em>一次精确的</em>方法意味着存在一致的分布式存储。 通常，此类存储表示巨大的持久键值表。 可能的操作： <code>set</code> ， <code>get</code> ， <code>del</code> 。 但是，无锁方法需要更复杂的操作：CAS或比较和交换。 让我们更详细地考虑该操作，其使用的可能性以及其产生的结果。 </p><br><h3 id="cas"> 卡斯 </h3><br><p>  CAS或比较交换是无锁和无等待算法的主要且重要的同步原语。 以下Pseco可以说明其实质： </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p> 有时，为了进行优化，它们返回的不是<code>true</code>或<code>false</code> ，而是前一个值，因为 通常，此类操作是在循环中执行的，为了获得<code>expected</code> ，您必须首先阅读它： </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p> 这种方法可以节省一个读数。 作为审查的一部分，我们将使用<code>CAS</code>的简单形式，因为 如果需要，这样的优化可以独立完成。 </p><br><p> 如果是分布式系统，则对每个更改进行版本控制。 即 首先，我们从存储中读取值，以获取数据的当前版本。 然后，我们尝试写入，期望数据的版本没有更改。 在这种情况下，每次更新数据时都会增加版本： </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p> 这种方法使您可以更准确地控制值的更新，从而避免<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ABA问题</a> 。 特别是，Etcd和Zookeeper支持版本控制。 </p><br><p> 注意<code>CAS_versioned</code>操作的使用赋予的重要属性。 事实是，可以在不影响高级逻辑的情况下重复执行此类操作。 在多线程编程中，此属性没有特殊值，因为 在那里，如果操作失败，那么我们肯定知道它不适用。 在分布式系统的情况下，违反了该不变式，因为 该请求可能到达收件人，但是成功的响应不再存在。 因此，能够重新发送请求而不必担心破坏高级逻辑的不变性很重要。 </p><br><p>  <code>CAS_versioned</code>操作<code>CAS_versioned</code>正是此属性。 实际上，可以无休止地重复此操作，直到返回接收者的真实响应为止。 而这又引发了与网络交互有关的一整类错误。 </p><br><h3 id="primer"> 例子 </h3><br><p> 让我们看看如何基于<code>CAS_versioned</code>和半交易将帐户从一个帐户转移到另一个帐户，例如，该帐户属于Etcd的不同副本。 在此，我假设已经基于提供的API相应地实现了<code>CAS_versioned</code>函数。 </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p> 在这里，我们将操作分为半事务，然后通过<code>CAS_versioned</code>操作执行每个半事务。 这种方法使您可以独立地使用每个帐户，从而允许使用彼此不连接的异构存储。 在这里等待我们的唯一问题是在半交易之间的时间间隔内当前流程下降的情况下资金损失。 </p><br><h2 id="ochered"> 列 </h2><br><p> 为了继续，您需要实现一个事件队列。 其思想是，为了使处理程序彼此通信，您需要具有一个有序的消息队列，在该队列中数据不会丢失或重复。 因此，处理程序链中的所有交互都将基于此原语构建。 它也是分析和审核传入和传出数据流的有用工具。 除此之外，还可以通过队列完成处理程序状态的更改。 </p><br><p> 该队列将包含一对操作： </p><br><ol><li> 将消息添加到队列的末尾。 </li><li> 从队列中指定索引处接收消息。 </li></ol><br><p> 在这种情况下，出于以下几个原因，我不考虑从队列中删除消息： </p><br><ol><li> 多个处理器可以从同一队列读取。 删除同步将是一项艰巨的任务，尽管并非不可能。 </li><li> 将队列保持相对较长的时间间隔（一天或一周）以进行调试和审核非常有用。 此属性的有用性很难高估。 </li><li> 您可以按计划删除旧项目，也可以通过在队列项目上设置TTL来删除。 重要的是要确保处理器在扫帚到达并清理所有东西之前设法处理数据。 如果处理时间大约是几秒钟，而TTL大约是几天，那么这种情况就不会发生。 </li></ol><br><p> 为了存储元素并有效地实现添加，我们需要： </p><br><ol><li> 具有当前索引的值。 该索引指向添加项目的队列的末尾。 </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     — !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     — ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          . ..    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     — . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    —      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="简单的"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="最后的"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="最后的"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    . 因为       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   —            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     . 因为        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        —   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        . ..          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       . 因为     ,       ,        .      ,        :     ,     —  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     —    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   —       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> —       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> —     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> — NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        . 但这是另一个故事。 </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="轻便"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维基百科：ABA问题。</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">博客：您无法立即交付</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈伯：可实现分布式故障安全事务的提交执行时间下限的可实现性。</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈伯：异步3：主观模型。</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维基百科：非阻塞同步。</font></font></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413817/">https://habr.com/ru/post/zh-CN413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413807/index.html">确定从飞机着陆的伞兵质心运动的弹道-时间特性</a></li>
<li><a href="../zh-CN413809/index.html">机顶盒并在LXC容器中使用Android进行实验</a></li>
<li><a href="../zh-CN413811/index.html">上周第318天来自前端世界的新鲜材料摘要（2018年6月4日至10日）</a></li>
<li><a href="../zh-CN413813/index.html">PHP摘要132号（2018年5月27日至6月10日）</a></li>
<li><a href="../zh-CN413815/index.html">在俄罗斯参加捐款工作坊</a></li>
<li><a href="../zh-CN413819/index.html">诚实地对待俄罗斯的IT市场</a></li>
<li><a href="../zh-CN413823/index.html">无意义的就业热潮</a></li>
<li><a href="../zh-CN413827/index.html">Kubernetes项目已满4岁</a></li>
<li><a href="../zh-CN413831/index.html">特斯拉自动驾驶仪的新版本将于8月发布，首次具有“全自动驾驶功能”</a></li>
<li><a href="../zh-CN413837/index.html">使塔防成为统一游戏-第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>