<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé° üëß üë®üèº‚Äç‚öñÔ∏è Mapas de sombras reflectantes: Parte 2 - Implementaci√≥n ü¶Ö üöµüèª ü¶á</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Este art√≠culo presenta una implementaci√≥n simple de mapas de sombras reflectantes (el algoritmo se describe en un art√≠culo anterior ). A co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas de sombras reflectantes: Parte 2 - Implementaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440570/">  Hola Habr!  Este art√≠culo presenta una implementaci√≥n simple de <b>mapas de sombras reflectantes</b> (el algoritmo se describe en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> ).  A continuaci√≥n, explicar√© c√≥mo lo hice y cu√°les fueron las dificultades.  Algunas posibles optimizaciones tambi√©n ser√°n consideradas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80f/588/6da/80f5886da498099f2e9716d4c0a53e3d.png" alt="imagen"><br>  <i>Figura 1: De izquierda a derecha: sin RSM, con RSM, diferencia</i> <br><a name="habracut"></a><br><h2>  Resultado </h2><br>  En la <i>Figura 1,</i> puede ver el resultado obtenido con <b>RSM</b> .  Para crear estas im√°genes, se utilizaron el "Conejo de Stanford" y tres cuadr√°ngulos multicolores.  En la imagen de la izquierda puede ver el resultado de la renderizaci√≥n sin <b>RSM</b> , utilizando solo <b>luz puntual</b> .  Todo a la sombra es completamente negro.  La imagen en el centro muestra el resultado con <b>RSM</b> .  Las siguientes diferencias son notables: en todas partes hay colores m√°s brillantes, rosa, inundando el piso y el conejo, el sombreado no es completamente negro.  La √∫ltima imagen muestra la diferencia entre el primero y el segundo, y por lo tanto, la contribuci√≥n de <b>RSM</b> .  Los bordes m√°s estrechos y los artefactos son visibles en la imagen central, pero esto se puede resolver ajustando el tama√±o del n√∫cleo, la intensidad de la iluminaci√≥n indirecta y el n√∫mero de muestras. <br><br><h2>  Implementaci√≥n </h2><br>  El algoritmo se implement√≥ en su propio motor.  Los sombreadores est√°n escritos en HLSL, y el renderizado est√° en DirectX 11. Ya configur√© <b>sombreado diferido</b> y <b>mapeo de sombras</b> para luz direccional (fuente de luz direccional) antes de escribir este art√≠culo.  Primero, implement√© <b>RSM</b> para luz direccional y solo despu√©s de agregar soporte para el <b>mapa de sombras</b> y <b>RSM</b> para luz puntual. <br><br><h3>  Extensi√≥n del mapa de sombras </h3><br>  Tradicionalmente, <b>Shadow Maps</b> (SM) no es m√°s que un mapa de profundidad.  Esto significa que ni siquiera necesita un sombreador de p√≠xeles / fragmentos para llenar SM.  Sin embargo, para <b>RSM</b> necesitar√° algunos buffers adicionales.  Necesita almacenar la <b>posici√≥n del</b> espacio mundial, el espacio mundial <b>normal</b> y el <b>flujo</b> (salida de luz).  Esto significa que necesita un sombreador de p√≠xeles / fragmentos con m√∫ltiples objetivos de representaci√≥n.  Tenga en cuenta que para esta t√©cnica debe cortar el <b>sacrificio de</b> la <b>cara</b> , no el frente. <br><br>  El uso de los bordes frontales de <b>eliminaci√≥n de caras</b> es una forma muy utilizada de evitar artefactos de sombra, pero esto no funciona con <b>RSM</b> . <br><br>  Pasa las posiciones y normales del espacio mundial al sombreador de p√≠xeles y las escribe en los b√∫feres apropiados.  Si usa <b>el mapeo normal</b> , calcule tambi√©n en el sombreador de p√≠xeles.  <b>El flujo se</b> calcula all√≠, multiplicando el material albedo por el color de la fuente de luz.  Para la <b>luz puntual</b> , debe multiplicar el valor resultante por el √°ngulo de incidencia.  Para <b>luz direccional,</b> se obtiene <b>una</b> imagen sin sombrear. <br><br><h3>  Preparaci√≥n para el c√°lculo de la iluminaci√≥n. </h3><br>  Hay algunas cosas que debes hacer para el pasaje principal.  Debe vincular todos los b√∫feres utilizados en el pase de sombra como texturas.  Tambi√©n necesitas n√∫meros aleatorios.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo oficial</a> dice que necesita calcular previamente estos n√∫meros y guardarlos en un b√∫fer para reducir el n√∫mero de operaciones en el pase de muestreo <b>RSM</b> .  Dado que el algoritmo es pesado en t√©rminos de rendimiento, estoy completamente de acuerdo con el art√≠culo oficial.  Tambi√©n se recomienda adherirse a la coherencia temporal (use el mismo patr√≥n de muestreo para todos los c√°lculos de iluminaci√≥n indirecta).  Esto evitar√° el parpadeo cuando cada cuadro use una sombra diferente. <br><br>  Necesita dos n√∫meros aleatorios de coma flotante en el rango [0, 1] para cada muestra.  Estos n√∫meros aleatorios se usar√°n para determinar las coordenadas de la muestra.  Tambi√©n necesitar√° la misma matriz que usa para convertir las posiciones del espacio mundial (espacio mundial) en el espacio de sombra (espacio fuente de luz).  Tambi√©n necesitar√° dichos par√°metros para el muestreo, que le dar√° un color negro si muestra m√°s all√° de los bordes de la textura. <br><br><h3>  Pasando la iluminaci√≥n </h3><br>  Ahora la parte dif√≠cil de entender.  Le recomiendo que calcule la iluminaci√≥n indirecta despu√©s de calcular la iluminaci√≥n directa para una fuente de luz particular.  Esto se debe a que necesita un quad de pantalla completa para la <b>luz direccional</b> .  Sin embargo, para la <b>luz puntual</b> y <b>puntual, por</b> lo general, desea utilizar mallas de una determinada forma con <b>selecci√≥n</b> para llenar menos p√≠xeles. <br><br>  En el siguiente c√≥digo, la iluminaci√≥n indirecta se calcula para el p√≠xel.  A continuaci√≥n, explicar√© lo que est√° sucediendo all√≠. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReflectiveShadowMapping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divideByW, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz; float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity); }</code> </pre> <br>  El primer argumento para la funci√≥n es <b>P</b> , que es la posici√≥n del espacio mundial (en el espacio mundial) para un p√≠xel espec√≠fico.  <b>DivideByW se</b> utiliza para la divisi√≥n prospectiva necesaria para obtener el valor <b>Z</b> correcto.  <b>N</b> es el espacio-mundo normal. <br><br><pre> <code class="cpp hljs">float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax;</code> </pre><br>  En esta parte del c√≥digo, se calcula la posici√≥n del espacio de luz (en relaci√≥n con la fuente de luz), se inicializa la variable de iluminaci√≥n indirecta, en la que se <b>sumar√°n</b> los valores calculados a partir de cada muestra, y la variable <b>rMax</b> se <b>establece a</b> partir de la ecuaci√≥n de iluminaci√≥n en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo oficial</a> , cuyo valor explicar√© en la siguiente secci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz;</code> </pre><br>  Aqu√≠ comenzamos el ciclo y preparamos nuestras variables para la ecuaci√≥n.  Para fines de optimizaci√≥n, las muestras aleatorias que calcul√© ya contienen desplazamientos de coordenadas, es decir, para obtener las coordenadas UV, solo necesito agregar <b>rMax * rnd</b> a las coordenadas del espacio de luz.  Si los UV resultantes est√°n fuera del rango [0.1], las muestras deben ser negras.  Lo cual es l√≥gico, ya que van m√°s all√° del rango de iluminaci√≥n. <br><br><pre> <code class="cpp hljs"> float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P ‚Äì vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS ‚Äì P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P ‚Äì vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity);</code> </pre><br>  Esta es la parte donde se calcula la ecuaci√≥n de iluminaci√≥n indirecta ( <i>Figura 2</i> ), y tambi√©n se pesa de acuerdo con la distancia desde la coordenada del espacio de luz hasta la muestra.  La ecuaci√≥n parece intimidante y el c√≥digo no ayuda a comprenderlo todo, por lo que explicar√© con m√°s detalle. <br><br>  La variable <b>Œ¶</b> (phi) es el <b>flujo de</b> luz, que es la intensidad de la radiaci√≥n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art√≠culo anterior</a> describe el <b>flujo con</b> m√°s detalle. <br><br>  Escalas de <b>flujo</b> con dos ilustraciones escalares.  El primero es entre la normalidad de la fuente de luz (texel) y la direcci√≥n de la fuente de luz a la posici√≥n actual.  El segundo es entre el vector actual normal y el de direcci√≥n desde la posici√≥n actual hasta la posici√≥n de la fuente de luz (texel).  Para no hacer una contribuci√≥n negativa a la iluminaci√≥n (resulta que si el p√≠xel no est√° iluminado), los productos escalares se limitan al rango [0, ‚àû].  En esta ecuaci√≥n, la normalizaci√≥n se realiza al final, supongo, por razones de rendimiento.  Es igualmente aceptable normalizar los vectores de direcci√≥n antes de realizar productos escalares. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dd3/258/ab4dd3258620fc3bae4a044df4072cf5.png" alt="imagen"><br>  <i>Figura 2: Ecuaci√≥n de iluminancia de un punto con posici√≥n <b>xy</b> fuente de luz de <b>n</b> direccional normal de p√≠xeles <b>p</b></i> <br><br>  El resultado de este pase se puede mezclar con un backbuffer (iluminaci√≥n directa), y el resultado ser√° como en la <i>Figura 1</i> . <br><br><h2>  Trampas </h2><br>  Al implementar este algoritmo, me encontr√© con algunos problemas.  Hablar√© sobre estos problemas para que no pisen el mismo rastrillo. <br><br><h3>  Muestra incorrecta </h3><br>  Pas√© una cantidad considerable de tiempo descubriendo por qu√© mi iluminaci√≥n indirecta parec√≠a repetitiva.  Las texturas de Crytek Sponza est√°n ocultas, por lo que necesita una muestra envuelta para ello.  Pero para <b>RSM</b> no es muy adecuado. <br><br><div class="spoiler">  <b class="spoiler_title">Opengl</b> <div class="spoiler_text">  OpenGL establece texturas <b>RSM</b> en GL_CLAMP_TO_BORDER <br></div></div><br><h3>  Valores personalizados </h3><br>  Para mejorar el flujo de trabajo, es importante poder cambiar algunas variables con solo presionar un bot√≥n.  Por ejemplo, la intensidad de la iluminaci√≥n indirecta y el rango de muestreo ( <b>rMax</b> ).  Estos par√°metros deben ajustarse para cada fuente de luz.  Si tiene un rango de muestreo grande, obtiene iluminaci√≥n indirecta de todas partes, lo que es √∫til para escenas grandes.  Para obtener m√°s iluminaci√≥n indirecta local, necesitar√° un rango m√°s peque√±o.  <i>La Figura 3</i> muestra la iluminaci√≥n indirecta global y local. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/c98/7f7/a08c987f7a9bf46344a623bafebfc903.png" alt="imagen"><br>  <i>Figura 3: Demostraci√≥n de la dependencia de <b>rMax</b> .</i> <br><br><h3>  Pasaje separado </h3><br>  Al principio, pens√© que pod√≠a hacer iluminaci√≥n indirecta en un sombreador, en el que considero la iluminaci√≥n directa.  Para la <b>luz direccional,</b> esto funciona porque todav√≠a dibujas un quad de pantalla completa.  Sin embargo, para la <b>luz puntual</b> y <b>puntual,</b> debe optimizar el c√°lculo de la iluminaci√≥n indirecta.  Por lo tanto, consider√© la iluminaci√≥n indirecta como un pasaje separado, que es necesario si tambi√©n quieres hacer <b>una interpolaci√≥n de espacio de pantalla</b> . <br><br><h3>  Cach√© </h3><br>  Este algoritmo no es compatible con el cach√© en absoluto.  Realiza muestreo en puntos aleatorios en varias texturas.  El n√∫mero de muestras sin optimizaciones tambi√©n es inaceptablemente grande.  Con una resoluci√≥n de 1280 * 720 y el n√∫mero de muestras <b>RSM</b> 400, obtendr√° 1.105.920.000 muestras para cada fuente de luz. <br><br><h3>  Los pros y contras </h3><br>  Voy a enumerar los pros y los contras de este algoritmo de c√°lculo de iluminaci√≥n indirecta. <br><table><tbody><tr><td>  Para </td><td>  <b>Contra</b> </td></tr><tr><td>  Algoritmo f√°cil de entender. </td><td>  No son amigos con cach√© en absoluto </td></tr><tr><td>  Se integra bien con el renderizador diferido </td><td>  Se requiere configuraci√≥n variable </td></tr><tr><td>  Se puede usar en otros algoritmos ( <b>LPV</b> ) </td><td>  Elecci√≥n forzada entre iluminaci√≥n indirecta local y global </td></tr></tbody></table><h2>  Optimizaciones </h2><br>  Hice varios intentos para aumentar la velocidad de este algoritmo.  Como se describe en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo oficial</a> , puede implementar <b>la interpolaci√≥n de espacio de pantalla</b> .  Hice esto y renderic√© un poco m√°s r√°pido.  A continuaci√≥n, describir√© algunas optimizaciones y har√© una comparaci√≥n (en cuadros por segundo) entre las siguientes implementaciones, usando una escena con 3 paredes y un conejo: sin <b>RSM</b> , implementaci√≥n ingenua de <b>RSM</b> , interpolada por <b>RSM</b> . <br><br><h3>  Z-check </h3><br>  Una de las razones por las que mi <b>RSM</b> funcion√≥ de manera ineficiente fue porque tambi√©n calcul√© la iluminaci√≥n indirecta para los p√≠xeles que formaban parte del skybox.  Skybox definitivamente no lo necesita. <br><br><h3>  Muestreo aleatorio de la CPU </h3><br>  El c√°lculo preliminar de las muestras no solo le dar√° una mayor coherencia temporal, sino que tambi√©n le ahorrar√° tener que volver a calcular estas muestras en el sombreador. <br><br><h3>  Interpolaci√≥n espacio-pantalla </h3><br>  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo oficial</a> sugiere usar un objetivo de renderizado de baja resoluci√≥n para calcular la iluminaci√≥n indirecta.  Para escenas con muchas normales suaves y paredes rectas, la informaci√≥n de iluminaci√≥n se puede interpolar f√°cilmente entre puntos con menor resoluci√≥n.  No describir√© la interpolaci√≥n en detalle para que este art√≠culo sea un poco m√°s corto. <br><br><h2>  Conclusi√≥n </h2><br>  A continuaci√≥n se muestran los resultados para un n√∫mero diferente de muestras.  Tengo algunos comentarios sobre estos resultados: <br><br><ul><li>  L√≥gicamente, el FPS permanece alrededor de 700 para un n√∫mero diferente de muestras cuando no se realiza el c√°lculo de <b>RSM</b> . </li><li>  La interpolaci√≥n genera cierta sobrecarga y no es muy √∫til con un peque√±o n√∫mero de muestras. </li><li>  Incluso con 100 muestras, la imagen final se ve√≠a bastante bien.  Esto puede deberse a la interpolaci√≥n, que "difumina" la iluminaci√≥n indirecta. </li></ul><br><table><tbody><tr><td>  Recuento de muestras </td><td>  FPS para no RSM </td><td>  FPS para ingenuo RSM </td><td>  FPS para RSM interpolado </td></tr><tr><td>  100 </td><td>  ~ 700 </td><td>  152 </td><td>  264 </td></tr><tr><td>  200 </td><td>  ~ 700 </td><td>  89 </td><td>  179 </td></tr><tr><td>  300 </td><td>  ~ 700 </td><td>  62 </td><td>  138 </td></tr><tr><td>  400 </td><td>  ~ 700 </td><td>  44 </td><td>  116 </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440570/">https://habr.com/ru/post/440570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440560/index.html">Alexander Belokrylov y Dmitry Chuyko sobre Liberica JDK en jug.msk.ru</a></li>
<li><a href="../440562/index.html">Windows Phone - TODO, es una o otra vez</a></li>
<li><a href="../440564/index.html">Red neuronal GPT-2 de OpenAI. Inicio r√°pido</a></li>
<li><a href="../440566/index.html">Acelerar sin obst√°culos o conocer SIMD</a></li>
<li><a href="../440568/index.html">Estamos escribiendo una aplicaci√≥n de aprendizaje en Go y Javascript para evaluar el rendimiento real de las acciones. Parte 2 - Prueba del backend</a></li>
<li><a href="../440574/index.html">Russian AI Cup 2018, historia 9 lugares</a></li>
<li><a href="../440576/index.html">Cambios importantes en CTE en PostgreSQL 12</a></li>
<li><a href="../440582/index.html">¬øSe arrastran los autos el√©ctricos al fondo de la corporaci√≥n automotriz?</a></li>
<li><a href="../440584/index.html">¬øQu√© le pasa a la Raspberry Pi?</a></li>
<li><a href="../440586/index.html">Consenso de Exonum: c√≥mo funciona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>