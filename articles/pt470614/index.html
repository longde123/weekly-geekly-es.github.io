<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüéì ‚öñÔ∏è üí≠ Como os gr√°ficos do NES foram organizados? üë®üèæ‚Äçüíª üñêÔ∏è üë©üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lan√ßado em 1983, o console dom√©stico do Nintendo Entertainment System (NES) era uma m√°quina barata, por√©m poderosa, que alcan√ßou um sucesso fenomenal....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os gr√°ficos do NES foram organizados?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470614/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="imagem"></div><br>  Lan√ßado em 1983, o console dom√©stico do Nintendo Entertainment System (NES) era uma m√°quina barata, por√©m poderosa, que alcan√ßou um sucesso fenomenal.  Usando a Unidade de processamento de imagens (PPU), o sistema pode criar gr√°ficos bastante impressionantes para aqueles tempos, que at√© hoje parecem muito bons no contexto certo.  O aspecto mais importante foi a efici√™ncia da mem√≥ria - ao criar gr√°ficos, tivemos que gerenciar com o m√≠nimo de bytes poss√≠vel.  No entanto, junto com isso, o NES forneceu aos desenvolvedores recursos poderosos e f√°ceis de usar que permitiram destacar-se dos consoles dom√©sticos mais antigos.  Tendo entendido os princ√≠pios da cria√ß√£o de gr√°ficos NES, voc√™ pode sentir a perfei√ß√£o t√©cnica do sistema e perceber o quanto √© mais f√°cil para os desenvolvedores de jogos modernos trabalharem. <br><br>  Os gr√°ficos de fundo do NES foram montados a partir de quatro componentes separados, cuja combina√ß√£o formou a imagem que vemos na tela.  Cada componente foi respons√°vel por um aspecto separado;  cores, layout, gr√°ficos em pixels brutos, etc.  Esse sistema pode parecer desnecessariamente complicado e complicado, mas no final ele usou a mem√≥ria com muito mais efici√™ncia e permitiu a cria√ß√£o de efeitos simples em uma pequena quantidade de c√≥digo.  Se voc√™ deseja entender os gr√°ficos do NES, esses quatro componentes ser√£o as principais informa√ß√µes. <br><br>  Este artigo pressup√µe que voc√™ esteja familiarizado com a matem√°tica do computador e, em particular, com o fato de que 8 bits = 1 byte e 8 bits podem representar 256 valores.  Tamb√©m √© necess√°rio entender como a nota√ß√£o hexadecimal funciona.  Mas mesmo sem esse conhecimento t√©cnico, o artigo pode parecer interessante. <br><a name="habracut"></a><br><h1>  Breve revis√£o </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/6f8/9a7/ca16f89a75e658d68c28f81e9794ff86.png" width="512" height="480"></div><br>  Acima est√° uma imagem da primeira cena de Castlevania (1986): o port√£o que leva ao castelo, onde o jogo ocorrer√°.  Esta imagem tem 256 √ó 240 pixels e usa 10 cores diferentes.  Para descrever essa imagem na mem√≥ria, precisamos aproveitar a paleta de cores limitada e economizar espa√ßo armazenando apenas uma quantidade m√≠nima de informa√ß√µes.  Uma das abordagens ing√™nuas √© usar uma paleta indexada na qual cada pixel tem um volume de 4 bits, ou seja, 2 pixels s√£o colocados em um byte.  Isso exigir√° 256 * 240/2 = 30720 bytes, mas como veremos em breve, o NES pode lidar com essa tarefa com muito mais efici√™ncia. <br><br>  Os principais conceitos do tema gr√°fico do NES s√£o blocos e blocos [1].  Um bloco √© uma √°rea de 8 √ó 8 pixels e um bloco √© uma √°rea de 16 √ó 16 pixels, e cada um deles √© vinculado a uma grade com o mesmo tamanho de c√©lula.  Depois de adicionar essas grades, podemos ver a estrutura dos gr√°ficos.  Aqui est√° a entrada do castelo com uma grade em dupla amplia√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uz/de/sk/uzdeskry1wkruscxe8xsyephbnc.png"></div><br>  Nesta grade, os blocos s√£o mostrados em verde claro e os azulejos em verde escuro.  As r√©guas ao longo dos eixos t√™m valores hexadecimais que podem ser adicionados para encontrar uma posi√ß√£o;  por exemplo, o cora√ß√£o na barra de status √© de $ 15 + $ 60 = $ 75, que √© decimal em 117. Cada tela cont√©m 16 √ó 15 blocos (240) e 32 √ó 30 blocos (960).  Agora vamos ver como esta imagem √© descrita e come√ßar com os gr√°ficos de pixel n√£o processados. <br><br><h1>  CHR </h1><br>  A estrutura CHR descreve gr√°ficos de pixel "brutos" sem sua cor e posi√ß√£o e √© definida em blocos.  A p√°gina inteira da mem√≥ria cont√©m 256 blocos CHR e cada bloco possui uma profundidade de 2 bits.  Aqui est√£o os gr√°ficos do cora√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/d14/fb3/ad9d14fb3cc4321c5ae65e1e7f61dd52.png" width="128" height="128"></div><br>  E aqui est√° como √© descrito em CHR [2]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/162/974/e0f/162974e0fe800447c8edecf9157d1763.png" alt="pixel-heart-chr" width="128" height="128"></div><br>  Essa descri√ß√£o leva 2 bits por pixel, ou seja, com um tamanho de 8 √ó 8, verifica-se 8 * 8 * 2 = 128 bits = 16 bytes.  Em seguida, a p√°gina inteira ocupa 16 * 256 = 4096 bytes.  Aqui est√£o todos os CHRs usados ‚Äã‚Äãna imagem de Castlevania. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/3ef/83d/5da3ef83d0e339ca2d91d799745157e9.png" width="271" height="101"></div><br>  Lembre-se de que o preenchimento de uma imagem requer 960 blocos, mas o CHR permite que voc√™ use apenas 256. Isso significa que a maioria dos blocos √© repetida, em m√©dia, 3,75 vezes, mas mais frequentemente apenas um pequeno n√∫mero deles √© usado (por exemplo, fundo vazio, blocos monocrom√°ticos ou padr√µes repetidos).  A imagem do Castlevania usa muitos ladrilhos vazios, al√©m de azul s√≥lido.  Para ver como os blocos s√£o atribu√≠dos, usamos tabelas de nomes. <br><br><h1>  NAMETABLE </h1><br>  A tabela de nomes atribui um arquivo CHR a cada posi√ß√£o na tela e h√° 960. Cada posi√ß√£o √© especificada em um byte, ou seja, a tabela de nomes inteira ocupa at√© 960 bytes.  As pe√ßas s√£o atribu√≠das na ordem da esquerda para a direita, de cima para baixo e correspondem √† posi√ß√£o calculada encontrada, adicionando os valores das r√©guas mostradas acima.  Ou seja, a posi√ß√£o no canto superior esquerdo √© $ 0, √† direita √© $ 1 e, abaixo, $ 20. <br><br>  Os valores na tabela nomeada dependem da ordem em que o CHR √© preenchido.  Aqui est√° uma das op√ß√µes [3]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h_/vs/qc/h_vsqc5mxdu8ydb1o8cu4mflf9e.png"></div><br>  <i>Nesse caso, o cora√ß√£o (na posi√ß√£o $ 75) tem um valor de $ 13.</i> <br><br>  Em seguida, para adicionar cor, precisamos selecionar uma paleta. <br><br><h1>  Paleta </h1><br>  O NES possui uma paleta de sistema de 64 cores [4] e, a partir dele, selecionamos as paletas que ser√£o usadas na renderiza√ß√£o.  Cada paleta cont√©m 3 cores exclusivas mais a cor geral do plano de fundo.  A imagem possui no m√°ximo 4 paletas, que ocupam no total 16 bytes.  Aqui est√£o as paletas para a imagem do Castlevania: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f03/59a/259/f0359a259c032b5f6c9048c0231ffb85.png" alt="castlevania-pal" width="168" height="24"></div><br>  Paletas n√£o podem ser usadas arbitrariamente.  Apenas uma paleta √© aplicada por bloco.  √â por causa dessa necessidade de separar cada √°rea 16 √ó 16 de acordo com a paleta de cores do jogo para que o NES tenha uma apar√™ncia de "bloqueio".  Gr√°ficos executados com maestria, por exemplo, na tela inicial do Castlevania, podem ser evitados misturando cores nas bordas dos blocos, o que oculta a presen√ßa de uma grade. <br><br>  A sele√ß√£o de uma paleta para cada bloco √© realizada usando o √∫ltimo componente - atributos. <br><br><h1>  Atributos </h1><br>  Os atributos ocupam 2 bits por bloco.  Eles determinam qual das 4 paletas usar.  Esta imagem mostra quais paletas definidas pelos atributos usam blocos diferentes [5]: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/kj/3i/k4kj3imqlxxbwnasjcz3t60abym.png"></div><br>  Como voc√™ pode ver, as paletas s√£o divididas em se√ß√µes, mas isso √© complicado devido ao uso das mesmas cores em diferentes √°reas.  Vermelho no meio do port√£o se funde com as paredes ao redor, e um fundo preto desfoca a linha entre o castelo <br>  e port√µes. <br><br>  Com 2 bits por bloco ou 4 blocos por byte, os atributos da imagem ocupam apenas 240/4 = 60 bytes, mas devido √† maneira como s√£o codificados, outros 4 bytes s√£o desperdi√ßados, ou seja, s√£o obtidos no total 64 bytes.  Isso significa que a imagem inteira, incluindo CHR, tabela nomeada, paletas e atributos, ocupa 4096 + 960 + 16 + 64 = 5136 bytes - muito melhor que os 30720 mencionados acima. <br><br><h1>  MAKECHR </h1><br>  Criar esses quatro componentes para gr√°ficos NES √© mais dif√≠cil do que usar as APIs regulares de bitmap, mas as ferramentas s√£o √∫teis.  Os desenvolvedores do NES provavelmente tinham algum tipo de cadeia de ferramentas, mas o que quer que fosse, a hist√≥ria n√£o a salvou.  Hoje, os desenvolvedores costumam escrever programas para converter gr√°ficos no formato NES desejado. <br><br>  Todas as imagens neste post foram criadas usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">makechr</a> , uma ferramenta reescrita usada pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Star Versus</a> .  Esta √© uma ferramenta de linha de comando projetada para compila√ß√µes automatizadas e destinada a velocidade, mensagens de erro de qualidade, portabilidade e compreensibilidade.  Ele tamb√©m cria visualiza√ß√µes interessantes, como as usadas no post. <br><br><h1>  Refer√™ncias </h1><br>  Principalmente conhecimento sobre programa√ß√£o para NES, e especialmente sobre cria√ß√£o de gr√°ficos, obtive das seguintes fontes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nintendo Age: Nerdy Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wiki de NesDev</a> </li></ul><br><h1>  Anota√ß√µes </h1><br>  [1] Terminologia - em alguns documentos, os blocos s√£o chamados de "meta-tiles", o que pessoalmente me parece menos √∫til. <br><br>  [2] Codifica√ß√£o CHR - 2 bits por pixel n√£o s√£o armazenados pr√≥ximos um do outro.  A imagem completa √© salva primeiro apenas com os bits baixos e, em seguida, novamente salva apenas com os bits altos. <br><br>  Ou seja, o cora√ß√£o ser√° armazenado assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc5/68c/f95/cc568cf959b148d1d11a408876806ae8.png" alt="pixel-cora√ß√£o-baixo" width="128" height="128"><img src="https://habrastorage.org/getpro/habr/post_images/f87/947/070/f879470703605322e98a2582241b071e.png" alt="pixel-cora√ß√£o-alto" width="128" height="128"><br><br>  Cada linha √© um byte.  Ou seja, 01100110 √© $ 66, 01111111 √© $ 7f.  No total, os bytes do cora√ß√£o s√£o assim: <br><br>  $ 66 $ 7f $ ff $ ff $ ff $ 7e $ 3c $ 18 $ 66 $ 5f $ bf $ bf $ ff $ 7e $ 3c $ 18 <br><br>  [3] Tabela de nomes - neste gr√°fico do jogo, a tabela de nomes √© usada de maneira diferente.  Normalmente, as letras do alfabeto s√£o mantidas na mem√≥ria na vizinhan√ßa, incluindo Castlevania. <br><br>  [4] System Palette - O NES n√£o usa uma paleta RGB, e as cores reais renderizadas dependem da TV em particular.  Emuladores geralmente usam paletas RGB completamente diferentes.  As cores neste artigo correspondem √† paleta expressa em makechr. <br><br>  [5] Codifica√ß√£o de Atributos - Os atributos s√£o armazenados em uma ordem estranha.  Eles n√£o v√£o da esquerda para a direita, de cima para baixo - a √°rea do bloco 2 √ó 2 √© codificada com um byte, na forma da letra Z. √â por isso que 4 bytes s√£o desperdi√ßados;  a linha inferior √© um total de 8 bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/951/0db/71a9510db28128bca1841689ce909c27.png" alt="pal-block-group" width="64" height="64"></div><br>  Por exemplo, um bloco de $ 308 √© armazenado com $ 30a, $ 348 e $ 34a.  Seus valores da paleta s√£o 1, 2, 3 e 3 e s√£o armazenados na ordem da posi√ß√£o mais baixa para a posi√ß√£o mais alta, ou 11 :: 11 :: 10 :: 01 = 11111001. Portanto, o valor de byte desses atributos √© $ f9. <br><br><h2>  Parte 2 </h2><br>  Na primeira parte, falamos sobre os componentes dos gr√°ficos de plano de fundo do NES - CHR, tabela de nomes, paletas e atributos.  Mas isso √© apenas metade da hist√≥ria. <br><br>  Para come√ßar, na verdade existem duas tabelas de nomes [6].  Cada um deles tem seus pr√≥prios atributos para definir a cor, mas eles t√™m o mesmo CHR.  O equipamento do cartucho determina sua posi√ß√£o: um ao lado do outro ou um acima do outro.  A seguir, exemplos de dois tipos diferentes de locais - Lode Runner (1984) e Bubble Bobble (1988). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/7ef/7c9/7597ef7c97f3e31ed3bb4198727dee37.png" width="512" height="500"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/035/72a/0e703572ad771478c13bffa254a86579.png" alt="bolha-bobble-rolagem" width="532" height="480"></div><br><h1>  Rolagem </h1><br>  Para aproveitar a presen√ßa de duas tabelas de nomes, a PPU suporta a capacidade de rolar por pixel ao mesmo tempo nos eixos X e Y. √â controlada por um registro com exibi√ß√£o de mem√≥ria em US $ 2005: escrever apenas dois bytes neste endere√ßo move a tela inteira para o n√∫mero desejado de pixels [7] .  No momento do lan√ßamento do NES, essa era a principal vantagem sobre outros consoles dom√©sticos, nos quais a rolagem geralmente tinha que reescrever toda a mem√≥ria de v√≠deo.  Um esquema t√£o f√°cil de usar levou ao surgimento de um grande n√∫mero de plataformas e atiradores e tornou-se a principal raz√£o para um sucesso t√£o grande do sistema. <br><br>  Para um jogo simples, cujo campo tem apenas duas telas, por exemplo, Load Runner, bastava preencher as duas tabelas de nomes e alterar a rolagem de acordo.  Mas na maioria dos jogos de rolagem, os n√≠veis tinham uma largura arbitr√°ria.  Para implement√°-los, o jogo deve atualizar a parte fora da tela das tabelas de nomes antes que elas apare√ßam na tela.  O valor da rolagem √© repetido, mas, como a tabela de nomes √© atualizada constantemente, isso cria a ilus√£o de tamanho infinito. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/936/ab4/829936ab4b2855cd7f824ebd01941bb3.gif" width="512" height="500"></div><br><h1>  Sprites </h1><br>  Al√©m de rolar pelas tabelas de nomes, o NES tamb√©m tinha um aspecto completamente diferente dos gr√°ficos: sprites.  Ao contr√°rio de tabelas de nomes que precisam ser alinhadas em grades, os sprites podem ser posicionados arbitrariamente, para que possam ser usados ‚Äã‚Äãpara exibir os personagens dos jogadores, obst√°culos, proj√©teis e quaisquer objetos com movimentos complexos.  Por exemplo, na cena acima de Mega Man (1987) para exibir o personagem de um jogador.  pontos e faixas de energia s√£o sprites usados, o que lhes permite sair da grade das tabelas de nomes ao rolar a tela. <br><br>  Sprites t√™m sua pr√≥pria p√°gina CHR [8] e um conjunto de 4 paletas.  Al√©m disso, eles ocupam uma p√°gina de 256 bytes de mem√≥ria.  que lista a posi√ß√£o e a apar√™ncia de cada sprite (como se v√™, a mem√≥ria de v√≠deo do NES √© duas vezes e meia maior do que a mencionada na primeira parte do artigo).  O formato desses registros √© bastante incomum - eles cont√™m primeiro uma posi√ß√£o em Y, depois um n√∫mero de bloco, depois um atributo, depois uma posi√ß√£o em X [9].  Como cada registro ocupa 4 bytes, h√° uma restri√ß√£o estrita: na tela n√£o pode haver mais do que 256/4 = 64 sprites por vez. <br><br>  Os bytes Y e X especificam o pixel superior esquerdo do sprite desenhado.  Portanto, no lado direito da tela, o sprite pode ser cortado, mas no lado esquerdo ele deixa espa√ßo vazio.  O byte do bloco √© semelhante ao valor na tabela de nomes, somente para esses blocos os sprites usam seu pr√≥prio CHR.  Um byte de atributo √© um pacote de bits que executa tr√™s tarefas: dois bits s√£o alocados √† paleta, dois bits s√£o usados ‚Äã‚Äãpara espelhar o sprite horizontal ou verticalmente e um bit determina se o sprite deve ser renderizado sob as tabelas de nomes [10]. <br><br><h1>  Limita√ß√µes </h1><br>  Os sistemas modernos permitem trabalhar com sprites de qualquer tamanho arbitr√°rio, mas no NES, o sprite devido √†s limita√ß√µes do CHR tinha que ter um tamanho de 8 √ó 8 [11].  Objetos maiores s√£o compostos de v√°rios sprites, e o programa deve garantir que todas as partes individuais sejam renderizadas uma ao lado da outra.  Por exemplo, o tamanho de um personagem Megaman pode chegar a 10 sprites, o que tamb√©m permite que voc√™ use mais cores, principalmente para os olhos brancos e o tom de pele. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/fea/3dc/dd8fea3dc4880761b52885c8ff83acdd.png"></div><br>  A principal limita√ß√£o associada ao uso de sprites √© que n√£o deve haver mais de 8 sprites por linha raster.  Se mais de 8 sprites aparecerem em qualquer linha horizontal da tela, os que aparecerem mais tarde simplesmente n√£o ser√£o renderizados.  Esta √© a raz√£o da cintila√ß√£o em jogos com muitos sprites;  o programa troca os endere√ßos dos sprites na mem√≥ria para que cada um deles seja renderizado pelo menos ocasionalmente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/b67/13c/5f0b6713c1be1837d0da2d8213253932.gif" alt="megaman-flicker" width="332" height="128"></div><br>  Por fim, a rolagem n√£o afeta os sprites: a posi√ß√£o do sprite na tela √© determinada por seus valores Y e X, independentemente da posi√ß√£o da rolagem.  √Äs vezes, isso √© uma vantagem, por exemplo, quando o n√≠vel se move em rela√ß√£o ao jogador ou a interface permanece em uma posi√ß√£o fixa.  No entanto, em outros casos, isso √© um sinal de menos - voc√™ precisa mover o objeto em movimento e, em seguida, mudar sua posi√ß√£o pela quantidade de altera√ß√µes na rolagem. <br><br><h1>  Anota√ß√µes </h1><br>  [6] Em teoria, existem quatro tabelas de nomes, mas elas s√£o espelhadas de forma que apenas duas delas cont√™m gr√°ficos √∫nicos.  Quando colocados lado a lado, isso √© chamado de espelhamento vertical e, quando as tabelas de nomes est√£o localizadas uma acima da outra, espelhamento horizontal. <br><br>  [7] H√° tamb√©m um registro que seleciona com qual tabela de nomes come√ßar a renderizar, ou seja, a rolagem √© na verdade um valor de 10 bits ou 9 bits, se voc√™ considerar o espelhamento. <br><br>  [8] Nem sempre √© esse o caso.  A PPU pode ser configurada para usar a mesma p√°gina CHR para tabelas de nomes e para sprites. <br><br>  [9] Talvez essa ordem tenha sido usada porque corresponde aos dados que a PPU precisa processar para obter uma renderiza√ß√£o eficiente. <br><br>  [10] Este bit √© usado para v√°rios efeitos, por exemplo, para mover Mario sob os blocos brancos em Super Mario Bros 3, ou para tornar neblina sobre sprites em Castlevania 3. <br><br>  [11] O PPU tamb√©m tem uma op√ß√£o para ativar sprites 8 √ó 16, que √© usado em jogos como Contra, onde existem personagens altos.  No entanto, todas as outras restri√ß√µes se aplicam. <br><br><h2>  Parte 3 </h2><br>  Nas partes anteriores, falamos sobre dados do CHR, planos de fundo baseados em tabelas de nomes, sprites e rolagem.  E isso √© praticamente tudo o que um simples cartucho NES pode fazer sem hardware adicional.  Mas, para ir al√©m, precisamos explicar em detalhes como a renderiza√ß√£o funciona. <br><br><h1>  Renderiza√ß√£o </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/0d4/0ad/12b0d40ad74d27ce6d8ff2499c6df163.gif" width="200" height="200"></div><br>  <i>Renderiza√ß√£o de varredura com uma pausa para vblank</i> <br><br>  Como outros computadores antigos, o NES foi projetado para funcionar com televis√µes CRT.  Eles desenham linhas de digitaliza√ß√£o na tela, uma de cada vez, da esquerda para a direita, de cima para baixo, usando uma pistola de el√©trons que se move fisicamente para o ponto na tela em que essas linhas s√£o desenhadas.  Depois de atingir o canto inferior, ocorre um per√≠odo chamado "espa√ßo em branco vertical" (ou vblank): a pistola de el√©trons retorna ao canto superior esquerdo para se preparar para desenhar o pr√≥ximo quadro.  Dentro do NES, o PPU (Picture Processing Unit) realiza a renderiza√ß√£o de varredura automaticamente, em cada quadro, e o c√≥digo que trabalha na CPU executa todas as tarefas que o jogo deve executar.  O Vblank permite que o programa substitua os dados na mem√≥ria PPU, pois, caso contr√°rio, esses dados ser√£o usados ‚Äã‚Äãpara renderiza√ß√£o.  Na maioria das vezes, s√£o feitas altera√ß√µes na tabela de nomes e paletas de PPU durante essa pequena janela. <br><br>  No entanto, algumas altera√ß√µes no estado da PPU podem ser feitas durante a renderiza√ß√£o da tela.  Eles s√£o chamados de "efeitos raster".  A a√ß√£o mais comum executada durante a renderiza√ß√£o da tela √© definir a posi√ß√£o de rolagem.  Gra√ßas a isso, parte da imagem permanece est√°tica (por exemplo, a interface do jogo) e todo o resto continua rolando.  Para alcan√ßar esse efeito, √© necess√°rio selecionar com precis√£o o tempo para alterar o valor de rolagem, para que ocorra na linha de varredura desejada.  Existem muitas t√©cnicas para implementar esse tipo de sincroniza√ß√£o entre o c√≥digo do jogo e o PPU. <br><br><h1>  Tela dividida </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/4bf/c1e/36e4bfc1e8e92ae1dbfb83225946dc0f.png" width="512" height="480"></div><br>  <i>O n√≠vel rola e a interface na parte superior da tela permanece estacion√°ria</i> <br><br>  Em primeiro lugar, a PPU possui hardware interno que processa sprite na posi√ß√£o de mem√≥ria zero de uma maneira especial.  Ao renderizar esse sprite, se um de seus pixels se sobrepuser √† parte vis√≠vel do plano de fundo, um bit √© definido como "sprite0 flag".  O c√≥digo do jogo pode primeiro colocar esse sprite no local em que a divis√£o da tela deve ocorrer e, em seguida, aguardar um loop, verificando o valor do sinalizador sprite0.  Portanto, quando o loop for encerrado, o jogo saber√° com certeza qual linha raster est√° sendo renderizada atualmente.  Essa t√©cnica √© usada para implementar o compartilhamento simples de tela em muitos jogos da NES, incluindo Ninja Gaiden (1989), mostrado acima [12] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/acd/f19/66bacdf196bab83b91ea70c2657dd497.png" alt="ninja-hud" width="256" height="240"></div><br>  <i>Sprite0 est√° localizado em Y $ 26, X $ a0.</i>  <i>Quando sua linha inferior de pixels √© renderizada, o sinalizador sprite0 √© definido</i> <br><br>  Em alguns jogos, o sinalizador sprite0 √© combinado com outra t√©cnica - loop previs√≠vel (‚Äúum ciclo com tempo previs√≠vel‚Äù): o programa espera at√© que algumas linhas extras sejam renderizadas para dividir a tela em mais partes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, essa t√©cnica √© usada em muitos protetores de tela Ninja Gaiden para criar efeitos dram√°ticos, por exemplo, um campo movido pelo vento ou uma imagem de um castelo √† dist√¢ncia. O jogo executa tarefas como tocar m√∫sica e aguardar a entrada do jogador, no in√≠cio da renderiza√ß√£o do quadro, depois usa o sprite0 para procurar a primeira divis√£o e, para todas as outras, usa loops cronometrados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/19a/bfd/cf919abfdd1c0d786440e0af2c99bb24.gif" alt="ninjas-em-campo" width="512" height="480"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/fab/d51/f77fabd51c4431db2c98ee1bf64e0eb2.gif" alt="vista para o castelo" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a maioria dos jogos n√£o pode gastar tempo esperando em ciclos, especialmente em cenas ativas em que o tempo da CPU vale seu peso em ouro. Nesses casos, √© usado um equipamento especial instalado nos cartuchos (chamado de mapeador, porque usa seu pr√≥prio mapeamento na mem√≥ria (mapeamento de mem√≥ria)), que pode receber uma notifica√ß√£o sobre o momento de renderizar uma determinada linha raster [13], o que elimina completamente a necessidade de ciclos de espera. O c√≥digo do jogo pode executar qualquer uma de suas tarefas e no momento desejado, para que o processador seja usado da melhor maneira poss√≠vel. A maioria dos jogos mais modernos para o NES, que possuem muitas divis√µes de tela, usa mapeadores dessa maneira.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/9c3/f4f/6189c3f4fa79e5c31b80b2c14df75dcb.gif" alt="n√≠vel de trem" width="512" height="480"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um exemplo de Ninja Gaiden 2, que usa um mapeador para realizar v√°rias divis√µes e simular a rolagem de paralaxe, o que cria uma sensa√ß√£o de grande velocidade, apesar do n√≠vel est√°tico. </font><font style="vertical-align: inherit;">Observe que todas as partes m√≥veis individuais ocupam estritamente faixas horizontais; </font><font style="vertical-align: inherit;">isto √©, nenhuma das camadas de fundo pode se sobrepor a outra. </font><font style="vertical-align: inherit;">Isso ocorre porque as separa√ß√µes s√£o realmente implementadas alterando a rolagem de linhas raster individuais.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troca de banco </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os mapeadores podem executar muitas outras fun√ß√µes, mas a mais comum delas √© a troca de bancos. Esta √© uma opera√ß√£o na qual todo o bloco de espa√ßos de endere√ßo √© reatribu√≠do para apontar para outra parte da mem√≥ria [14]. Os bancos de comuta√ß√£o podem ser executados com o c√≥digo do programa (que permite criar muitos n√≠veis e m√∫sicas nos jogos), bem como com os dados do CHR, gra√ßas aos quais voc√™ pode substituir instantaneamente os blocos referenciados por tabelas de nomes ou sprites. Se voc√™ usar a altern√¢ncia de bancos entre os quadros, poder√° animar todo o fundo de cada vez. Mas quando usado como um efeito raster, isso permite desenhar gr√°ficos completamente diferentes em diferentes partes da tela. Nos jogos da s√©rie Ninja Gaiden, essa abordagem √© usada durante o processo do jogo para renderizar a interface separadamente do n√≠vel, bem como durante os protetores de tela,que permite armazenar cenas visuais e de texto em diferentes bancos CHR.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/896/804/69f8968042bded347183e35af32c16ae.gif" alt="goofall-bg" width="512" height="480"></div><br> <i> ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/882/f90/290882f90bb731af9e98f7ee65b4e64f.png" alt="goofall-nt" width="512" height="480"></div><br> <i>  ,        </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/077/b23/cf7077b23ea5242b4f27d308b7514077.png" width="512" height="480"></div><br> <i>      CHR.     ,     </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/335/28e/7a233528e53b01341d21112b3651310e.png" alt="quem s√£o eles banco inferior" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na parte inferior, outro banco CHR √© usado. Ao trocar de banco, o valor de rolagem tamb√©m √© redefinido.A</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> troca de banco tamb√©m pode ser usada para rolagem de paralaxe, de forma limitada (mas ainda impressionante). Se a cena possui uma parte do plano de fundo composta de um padr√£o de repeti√ß√£o curto, esse mesmo padr√£o pode estar contido em v√°rios bancos com um deslocamento de uma quantidade diferente. Em seguida, esse padr√£o pode ser rolado para um determinado valor alternando para o banco com o deslocamento correspondente. Essa t√©cnica pode ser usada para rolagem de paralaxe, mesmo com sobreposi√ß√£o de fundo devido √† presen√ßa de blocos que n√£o s√£o afetados pela troca de mem√≥ria [15]. A desvantagem desse m√©todo √© que, no total, todos os bancos precisam ocupar muito espa√ßo do CHR.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/6b4/281/5016b4281a88523177dffef3f8de4250.gif" alt="metal-storm-bg" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal Storm (1991) usa comuta√ß√£o de banco para rolagem camada a lado</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/7d4/6cb/c057d46cbf7f4d2cfb3e401d1658692f.png" alt="metal-tempestade-nt" width="512" height="464"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetir a tabela de nomes permite criar esse efeito</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CHR com a troca de bancos - essa √© uma ferramenta muito poderosa, mas tem suas limita√ß√µes. </font><font style="vertical-align: inherit;">Embora seja √∫til para animar a tela inteira, essa t√©cnica n√£o √© muito adequada para substituir apenas uma pequena parte da tela; </font><font style="vertical-align: inherit;">isso tamb√©m requer altera√ß√µes na tabela de nomes. </font><font style="vertical-align: inherit;">Al√©m disso, a quantidade de CHR no cartucho √© limitada e, para mudar para os dados, eles devem primeiro existir. </font><font style="vertical-align: inherit;">Finalmente, com exce√ß√£o dos efeitos raster baseados em rolagem, o jogo sempre possui uma grade rigorosa de tabelas de nomes, o que limita a faixa din√¢mica de efeitos gr√°ficos.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outros exemplos </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/f22/f28/9adf22f2804a300f6f3e9a98fe15c13b.gif" alt="vice fogo" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O jogo Vice: Project Doom (1991) cria esse efeito de chama, definindo repetidamente a posi√ß√£o de rolagem em cada linha raster. </font><font style="vertical-align: inherit;">O caractere em primeiro plano √© criado a partir de sprites que n√£o s√£o afetados pela rolagem.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/25b/9b9/25325b9b935359508dc420aa35ef1748.gif" alt="mestre das espadas" width="512" height="480"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Sword Master (1990) usa a troca de banco para rolar montanhas √† dist√¢ncia, bem como dividir a tela da interface e a grama em primeiro plano.</font></font></i> <br><br><h1>  Agradecimentos </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu n√£o seria capaz de gerar todos esses gr√°ficos para um artigo sem as poderosas fun√ß√µes de depura√ß√£o fornecidas pelo emulador FCEUX. </font><font style="vertical-align: inherit;">Al√©m disso, o wiki do site NesDev se tornou uma fonte √∫til de informa√ß√µes sobre o sprite0:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fceux</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiki NesDev</font></font></a> </li></ul><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anota√ß√µes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] De fato, a situa√ß√£o com Ninja Gaiden √© um pouco mais complicada. O jogo usa sprites de sprites 8 √ó 16 - um modo especial fornecido pela PPU que renderiza sprites como pares sobrepostos verticalmente. Ou seja, o sprite0 √© completamente transparente e o sprite1 tem uma linha de pixels na parte inferior. Ele tamb√©m define a camada z desses sprites para que sejam renderizados por tr√°s da escurid√£o da interface, o que torna tudo invis√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] Isso √© bastante complicado de implementar. O c√≥digo do jogo grava a linha raster desejada no espa√ßo de endere√ßo do mapeador. O mapeador intercepta solicita√ß√µes de acesso √† mem√≥ria PPU, contando quando uma nova linha raster √© renderizada. Ao atingir a linha de varredura desejada, ele gera uma interrup√ß√£o do programa (IRQ) durante a qual o c√≥digo do jogo √© executado, fazendo o que √© necess√°rio durante essa linha de varredura espec√≠fica.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14] A comuta√ß√£o √© realizada mapeando o equipamento na mem√≥ria, interceptando as opera√ß√µes de acesso √† mem√≥ria e redefinindo a localiza√ß√£o f√≠sica da qual os dados s√£o obtidos. </font><font style="vertical-align: inherit;">O resultado √© instant√¢neo, mas possui uma grande fracionalidade, por causa da qual os intervalos de endere√ßos variam em 4 KB ou 8 KB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15] A √∫nica maneira de alternar bancos CHR sem afetar cada bloco √© duplicar os dados do bloco entre os bancos ou ter um mapeador com menos granula√ß√£o. </font><font style="vertical-align: inherit;">Com esse mapeador, voc√™ pode alternar uma parte menor do banco, por exemplo, apenas 1 KB por vez, e todo o resto permanecer√° inalterado.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470614/">https://habr.com/ru/post/pt470614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470602/index.html">Como seria o metr√¥ de Moscou em um mundo tridimensional</a></li>
<li><a href="../pt470604/index.html">Velocidade de carregamento de sites no com√©rcio eletr√¥nico: an√°lise das 48 principais lojas online da R√∫ssia</a></li>
<li><a href="../pt470608/index.html">Otimiza√ß√£o da interface do usu√°rio do Unity</a></li>
<li><a href="../pt470610/index.html">Um dia na vida de um desenvolvedor</a></li>
<li><a href="../pt470612/index.html">O que um volt√≠metro mostra ou soquetes matem√°ticos</a></li>
<li><a href="../pt470616/index.html">Uma nova solu√ß√£o para o paradoxo de Fermi (por que estamos sozinhos no universo)</a></li>
<li><a href="../pt470618/index.html">Modelagem tem√°tica de not√≠cias usando an√°lise fatorial</a></li>
<li><a href="../pt470620/index.html">Infraestrutura como c√≥digo: como superar problemas com o XP</a></li>
<li><a href="../pt470622/index.html">Vis√£o geral dos m√©todos de sele√ß√£o de recursos</a></li>
<li><a href="../pt470628/index.html">Constru√ß√£o naval de simulador de nave espacial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>