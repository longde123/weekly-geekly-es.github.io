<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòû ‚òÉÔ∏è üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø O cliente Steam eliminou uma vulnerabilidade perigosa que estava escondida l√° por dez anos ü•õ üò´ ü§æüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O principal pesquisador Tom Court of Context, uma empresa de seguran√ßa da informa√ß√£o, fala sobre como ele conseguiu detectar um bug potencialmente per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O cliente Steam eliminou uma vulnerabilidade perigosa que estava escondida l√° por dez anos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="imagem"></div><br>  <i>O principal pesquisador Tom Court of Context, uma empresa de seguran√ßa da informa√ß√£o, fala sobre como ele conseguiu detectar um bug potencialmente perigoso no c√≥digo do cliente Steam.</i> <br><br>  Os jogadores de PC preocupados com a seguran√ßa perceberam que a Valve lan√ßou recentemente uma nova atualiza√ß√£o do cliente Steam. <br><br>  Neste post, eu quero dar <s>desculpas para jogar jogos no trabalho para</s> contar a hist√≥ria de um bug relacionado que existia no cliente Steam por pelo menos dez anos, que at√© julho do ano passado poderia levar √† execu√ß√£o remota de c√≥digo (execu√ß√£o remota de c√≥digo, RCE) em todos os 15 milh√µes de clientes ativos. <br><br>  Desde julho, quando a Valve (finalmente) compilou seu c√≥digo com a moderna prote√ß√£o de explora√ß√£o ativada, isso s√≥ poderia levar a uma falha do cliente, e o RCE era poss√≠vel apenas em combina√ß√£o com uma vulnerabilidade separada de vazamento de informa√ß√µes. <br><br>  Declaramos a Valve uma vulnerabilidade em 20 de fevereiro de 2018 e, para cr√©dito da empresa, ela foi corrigida na filial beta menos de 12 horas depois.  A corre√ß√£o foi movida para a filial est√°vel em 22 de mar√ßo de 2018. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="imagem"></div><br><h2>  Breve revis√£o </h2><br>  A base da vulnerabilidade foi o dano ao heap dentro da biblioteca do cliente Steam, que poderia ser chamado remotamente, na parte do c√≥digo envolvida na recupera√ß√£o do datagrama fragmentado de v√°rios pacotes UDP recebidos. <br><br>  O cliente Steam troca dados por meio de seu pr√≥prio protocolo (protocolo Steam), que √© implementado sobre o UDP.  Existem duas √°reas neste protocolo que s√£o particularmente interessantes devido √† vulnerabilidade: <br><br><ul><li>  Comprimento do pacote </li><li>  O comprimento total do datagrama reconstru√≠do </li></ul><br>  O erro foi causado pela falta de uma verifica√ß√£o simples.  O c√≥digo n√£o verificou se o comprimento do primeiro datagrama fragmentado √© menor ou igual ao comprimento total do datagrama.  Parece uma supervis√£o comum, pois para todos os pacotes subsequentes que transmitem fragmentos do datagrama, a verifica√ß√£o √© realizada. <br><br>  Sem erros adicionais de vazamento de dados, √© muito dif√≠cil controlar os danos de pilha nos sistemas operacionais modernos, portanto, a execu√ß√£o remota de c√≥digo √© dif√≠cil de implementar.  No entanto, nesse caso, gra√ßas ao alocador de mem√≥ria do pr√≥prio Steam e ao ASLR que estava ausente no arquivo bin√°rio steamclient.dll (at√© julho do ano passado), esse bug poderia ser usado como base para uma explora√ß√£o muito confi√°vel. <br><br>  Abaixo est√° uma descri√ß√£o t√©cnica da vulnerabilidade e sua explora√ß√£o associada at√© <br>  implementa√ß√µes de execu√ß√£o de c√≥digo. <br><br><h2>  Detalhes da vulnerabilidade </h2><br><h3>  Informa√ß√£o necess√°ria para a compreens√£o </h3><br><h4>  Protocolo </h4><br>  Terceiros (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ), com base na an√°lise do tr√°fego gerado pelo cliente Steam, executaram engenharia reversa e criaram documenta√ß√£o detalhada do protocolo Steam.  Inicialmente, o protocolo foi documentado em 2008 e n√£o mudou muito desde ent√£o. <br><br>  O protocolo √© implementado como um protocolo de transmiss√£o com o estabelecimento de uma conex√£o atrav√©s de um fluxo de datagramas UDP.  Os pacotes, de acordo com a documenta√ß√£o no link acima, t√™m a seguinte estrutura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="imagem"></div><br>  Aspectos importantes: <br><br><ul><li>  Todos os pacotes come√ßam com 4 bytes de " <em>VS01</em> " </li><li>  <em>packet_len</em> descreve o tamanho da informa√ß√£o √∫til (para datagramas n√£o fragmentados, o valor √© igual ao comprimento dos dados) </li><li>  <em>type</em> descreve o tipo de pacote, que pode ter os seguintes valores: <br><ul><li>  Autentica√ß√£o de chamada 0x2 </li><li>  0x4 Aceitar Conex√£o </li><li>  Conex√£o de redefini√ß√£o 0x5 </li><li>  0x6 Um pacote √© um fragmento de um datagrama </li><li>  O pacote 0x7 √© um datagrama separado </li></ul></li><li>  Os campos de <em>origem</em> e <em>destino</em> s√£o identificadores atribu√≠dos para rotear pacotes corretamente em v√°rias conex√µes dentro do cliente Steam </li><li>  Caso o pacote seja um fragmento de um datagrama: <br><ul><li>  <em>split_count</em> indica o n√∫mero de fragmentos nos quais o datagrama √© dividido </li><li>  <em>data_len</em> indica o comprimento total do datagrama recuperado </li></ul></li><li>  O processamento inicial desses pacotes UDP ocorre na fun√ß√£o <em>CUDPConnection :: UDPRecvPkt</em> dentro do steamclient.dll </li></ul><br><h4>  Criptografia </h4><br>  Informa√ß√µes √∫teis do pacote de datagrama s√£o criptografadas pelo AES-256 usando uma chave, que √© negociada entre o cliente e o servidor em cada sess√£o.  A negocia√ß√£o principal √© realizada da seguinte maneira: <br><br><ul><li>  O cliente gera uma chave aleat√≥ria AES de 32 bytes e o RSA a criptografa com a chave p√∫blica Valve antes de envi√°-la ao servidor. </li><li>  O servidor, com uma chave privada, pode descriptografar esse valor e aceit√°-lo como uma chave AES-256, que ser√° usada na sess√£o </li><li>  Depois que a chave √© acordada, todas as informa√ß√µes √∫teis na sess√£o atual s√£o criptografadas com essa chave. </li></ul><br><h3>  Vulnerabilidade </h3><br>  A vulnerabilidade est√° presente dentro do m√©todo <em>RecvFragment da</em> classe <em>CUDPConnection</em> .  N√£o h√° s√≠mbolos na vers√£o de lan√ßamento da biblioteca steamclient, no entanto, ao pesquisar por linhas bin√°rias em uma fun√ß√£o de nosso interesse, um link para " <em>CUDPConnection :: RecvFragment</em> " √© encontrado.  A entrada dessa fun√ß√£o √© realizada quando o cliente recebe um pacote UDP contendo um datagrama Steam do tipo 0x6 (um "fragmento de um datagrama"). <br><br>  1. A fun√ß√£o inicia verificando o status da conex√£o para garantir que esteja no estado ‚Äú <em>Conectado</em> ‚Äù. <br>  2. Em seguida, o campo <em>data_len</em> no datagrama Steam √© verificado para garantir que contenha menos de <em>0x20000060</em> bytes (parece que esse valor foi escolhido arbitrariamente). <br>  3. Se o teste for aprovado, a fun√ß√£o verificar√° se a conex√£o est√° coletando fragmentos de algum datagrama ou se √© o primeiro pacote do fluxo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="imagem"></div><br>  4. Se este for o primeiro pacote no fluxo, o campo <em>split_count</em> ser√° <em>verificado</em> para ver quantos pacotes esse fluxo estender√° <br>  5. Se o fluxo estiver dividido em v√°rios pacotes, o campo <em>seq_no_of_first_pkt</em> ser√° <em>verificado</em> para garantir que ele corresponda ao n√∫mero de s√©rie do pacote atual.  Isso garante que o pacote seja o primeiro no fluxo. <br>  6. O campo <em>data_len</em> √© <em>verificado</em> novamente contra o limite de <em>0x20000060</em> bytes.  Al√©m disso, verifica-se que <em>split_count √©</em> menor que <em>0x709b</em> pacotes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="imagem"></div><br>  7. Se essas condi√ß√µes forem atendidas, um valor booleano √© definido para indicar que agora estamos coletando fragmentos.  Ele tamb√©m verifica se ainda n√£o temos um buffer alocado para armazenar fragmentos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="imagem"></div><br>  8. Se o ponteiro para o buffer de cole√ß√£o de fragmentos n√£o for zero, o buffer de cole√ß√£o de fragmentos atual ser√° liberado e um novo buffer ser√° alocado (consulte o ret√¢ngulo amarelo na figura abaixo).  √â aqui que o erro aparece.  Espera-se que o buffer de cole√ß√£o de fragmentos seja alocado no tamanho de <em>data_len</em> bytes.  Se tudo for bem-sucedido (e o c√≥digo n√£o verificar - um pequeno erro), os dados √∫teis do datagrama ser√£o copiados para esse buffer usando o <em>memmove</em> , confiando que o n√∫mero de bytes para c√≥pia est√° indicado em <em>packet_len</em> . <br><br>  <strong>A supervis√£o mais importante do desenvolvedor foi que a verifica√ß√£o " <em>packet_len √©</em> menor ou igual a <em>data_len</em> " n√£o √© executada.</strong>  <strong>Isso significa que √© poss√≠vel transferir <em>data_len</em> menos que <em>packet_len</em> e ter at√© 64 KB de dados (devido ao fato de o campo <em>packet_len ter</em> 2 bytes de largura) copiado para um buffer muito pequeno, o que possibilita explorar a corrup√ß√£o de heap.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="imagem"></div><br><h2>  Explora√ß√£o de vulnerabilidade </h2><br>  Esta se√ß√£o sup√µe que haja uma solu√ß√£o alternativa para o ASLR.  Isso leva ao fato de que antes de iniciar a opera√ß√£o, o endere√ßo inicial do steamclient.dll √© conhecido. <br><br><h3>  Falsifica√ß√£o de pacotes </h3><br>  Para que os pacotes UDP atacantes sejam recebidos pelo cliente, ele deve examinar o datagrama de sa√≠da (cliente -&gt; servidor), enviado para descobrir os identificadores da conex√£o cliente / servidor, bem como o n√∫mero de s√©rie.  Em seguida, o invasor deve falsificar os endere√ßos IP e as portas de origem / destino junto com os identificadores de cliente / servidor e aumentar o n√∫mero de s√©rie aprendido em um. <br><br><h3>  Gerenciamento de mem√≥ria </h3><br>  Para alocar mem√≥ria com mais de 1024 (0x400) bytes, √© usado um alocador de sistema padr√£o.  Para alocar mem√≥ria menor ou igual a 1024 bytes, o Steam usa seu pr√≥prio alocador que funciona da mesma maneira em todas as plataformas suportadas.  Este artigo n√£o discutir√° em detalhes esse distribuidor, com exce√ß√£o dos seguintes aspectos principais: <br><br><ol><li>  Grandes blocos de mem√≥ria s√£o solicitados ao alocador do sistema, que s√£o ent√£o divididos em fragmentos de tamanho fixo para uso nas solicita√ß√µes de aloca√ß√£o de mem√≥ria do cliente Steam. </li><li>  A sele√ß√£o √© realizada sequencialmente, entre os fragmentos utilizados n√£o h√° metadados que os separam. </li><li>  Cada bloco grande armazena sua pr√≥pria lista de mem√≥ria livre, implementada como uma lista vinculada individualmente. </li><li>  A parte superior da lista de mem√≥ria livre indica o primeiro fragmento livre na mem√≥ria e os primeiros 4 bytes desse fragmento indicam o pr√≥ximo fragmento livre (se houver). </li></ol><br><h4>  Aloca√ß√£o de mem√≥ria </h4><br>  Quando a mem√≥ria √© alocada, o primeiro bloco livre √© desconectado da parte superior da lista de mem√≥ria livre e os primeiros 4 bytes desse bloco correspondentes ao <em>next_free_block</em> s√£o copiados para a <em>vari√°vel de</em> membro <em>freelist_head</em> dentro da classe do <em>alocador</em> . <br><br><h4>  Mem√≥ria livre </h4><br>  Quando um bloco √© liberado, o campo <em>freelist_head √©</em> copiado para os primeiros 4 bytes do bloco liberado ( <em>next_free_block</em> ) e o endere√ßo do bloco liberado √© copiado para a vari√°vel de membro <em>freelist_head</em> da classe do distribuidor. <br><br><h3>  Como obter uma primitiva de grava√ß√£o </h3><br>  Um estouro de buffer ocorre no heap e, dependendo do tamanho dos pacotes que causaram a corrup√ß√£o, a aloca√ß√£o de mem√≥ria pode ser controlada pelo alocador padr√£o do Windows (ao alocar mem√≥ria com mais de 0x400 bytes) ou pelo pr√≥prio alocador do Steam (ao alocar mem√≥ria com menos de 0x400 bytes).  Devido √† falta de medidas de seguran√ßa em meu pr√≥prio distribuidor Steam, decidi que era mais f√°cil us√°-lo para uma explora√ß√£o. <br><br>  Vamos voltar √† se√ß√£o sobre gerenciamento de mem√≥ria: sabe-se que a parte superior da lista de blocos de mem√≥ria livre de um determinado tamanho √© armazenada como uma vari√°vel membro da classe distribuidora e o ponteiro para o pr√≥ximo bloco livre da lista √© armazenado como os primeiros 4 bytes de cada bloco livre da lista. <br><br>  Se houver um bloco livre pr√≥ximo ao bloco em que ocorreu o estouro, os danos no heap nos permitem substituir o ponteiro <em>next_free_block</em> .  Se voc√™ considerar que um monte pode ser preparado para isso, o ponteiro reescrito <em>next_free_block</em> pode ser definido como um endere√ßo para grava√ß√£o, ap√≥s o qual a aloca√ß√£o subsequente de mem√≥ria ser√° gravada nesse local. <br><br><h3>  O que usar: datagramas ou fragmentos </h3><br>  Ocorre um erro com corrup√ß√£o de mem√≥ria no c√≥digo respons√°vel pelo processamento de fragmentos de datagramas (pacotes do tipo 6).  Ap√≥s a ocorr√™ncia de danos, a fun√ß√£o <em>RecvFragment ()</em> est√° no estado em que espera receber mais fragmentos.  No entanto, se eles chegarem, uma verifica√ß√£o √© realizada: <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br>  Mas, obviamente, esse n√£o √© o caso, porque nosso primeiro pacote j√° violou essa regra (√© poss√≠vel ignorar essa verifica√ß√£o) e um erro ocorrer√°.  Para evitar isso, voc√™ precisa evitar o <em>m√©todo CUDPConnection :: RecvFragment ()</em> ap√≥s <em>corrup√ß√£o de</em> mem√≥ria. <br><br>  Felizmente, <em>CUDPConnection :: RecvDatagram ()</em> ainda pode receber e processar pacotes enviados do tipo 7 (datagramas) at√© que <em>RecvFragment ()</em> seja v√°lido, e isso pode ser usado para iniciar a primitiva de grava√ß√£o. <br><br><h3>  Problemas de criptografia </h3><br>  Os pacotes recebidos por <em>RecvDatagram ()</em> e <em>RecvFragment ()</em> devem ser criptografados.  No caso de <em>RecvDatagram (), a</em> descriptografia √© realizada quase imediatamente ap√≥s o recebimento.  No caso de <em>RecvFragment (),</em> ocorre ap√≥s o recebimento do √∫ltimo fragmento na sess√£o. <br><br>  O problema de explorar a vulnerabilidade surge porque n√£o conhecemos a chave de criptografia criada em cada sess√£o.  Isso significa que qualquer c√≥digo OP / c√≥digo de shell que enviarmos ser√° "descriptografado" usando o AES256, que transformar√° nossos dados em lixo.  Portanto, √© necess√°rio encontrar um m√©todo de opera√ß√£o, que √© poss√≠vel quase imediatamente ap√≥s o recebimento do pacote, antes que os procedimentos de descriptografia possam processar as informa√ß√µes √∫teis contidas no buffer de pacotes. <br><br><h3>  Como conseguir a execu√ß√£o de c√≥digo </h3><br>  Dada a restri√ß√£o de descriptografia descrita acima, a opera√ß√£o deve ser executada antes da descriptografia dos dados recebidos.  Isso imp√µe restri√ß√µes adicionais, mas a tarefa ainda √© vi√°vel: voc√™ pode reescrever o ponteiro para que aponte para o objeto <em>CWorkThreadPool</em> armazenado em um local previs√≠vel dentro da se√ß√£o de dados do arquivo bin√°rio.  Embora os detalhes e a funcionalidade interna dessa classe sejam desconhecidos, pode-se assumir pelo nome que ele suporta um pool de threads que voc√™ pode usar quando precisar "trabalhar".  Depois de estudar v√°rias linhas de depura√ß√£o em um arquivo bin√°rio, voc√™ pode entender que, entre esses trabalhos, h√° criptografia e descriptografia ( <em>CWorkItemNetFilterEncrypt</em> , <em>CWorkItemNetFilterDecrypt</em> ), portanto, quando essas tarefas s√£o enfileiradas, a classe <em>CWorkThreadPool</em> √© <em>usada</em> .  Sobrescrevendo esse ponteiro e escrevendo o local desejado, podemos simular o ponteiro da vtable e a vtable associada a ele, o que nos permite executar o c√≥digo, por exemplo, quando <em>CWorkThreadPool :: AddWorkItem () √©</em> chamado, o que deve ocorrer antes de qualquer processo de descriptografia. <br><br>  A figura abaixo mostra a explora√ß√£o bem-sucedida da vulnerabilidade at√© o est√°gio de obten√ß√£o de controle sobre o registro EIP. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="imagem"></div><br>  A partir de agora, voc√™ pode criar uma cadeia ROP que leve √† execu√ß√£o de c√≥digo arbitr√°rio.  O v√≠deo abaixo mostra como um invasor inicia remotamente uma calculadora do Windows em uma vers√£o totalmente corrigida do Windows 10. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Resumir </h2><br>  Se voc√™ chegar a esta parte do artigo, obrigado por sua persist√™ncia!  Espero que voc√™ entenda que esse √© um bug muito simples e f√°cil de explorar devido √† falta de meios modernos de prote√ß√£o contra explora√ß√µes.  O c√≥digo vulner√°vel provavelmente era muito antigo, mas, caso contr√°rio, funcionou bem; portanto, os desenvolvedores n√£o viram a necessidade de examin√°-lo ou atualizar seus scripts de constru√ß√£o.  A li√ß√£o aqui √© que √© importante que os desenvolvedores revisem periodicamente o c√≥digo antigo e construam sistemas para garantir que estejam em conformidade com os padr√µes de seguran√ßa modernos, mesmo que a funcionalidade do pr√≥prio c√≥digo permane√ßa inalterada.  Foi incr√≠vel encontrar em 2018 um bug t√£o simples com consequ√™ncias t√£o s√©rias em uma plataforma de software muito popular.  Isso deve ser um incentivo para procurar essas vulnerabilidades para todos os pesquisadores! <br><br>  Por fim, vale a pena discutir o processo de divulga√ß√£o respons√°vel de informa√ß√µes.  Relatamos esse bug √† Valve em uma carta para sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">equipe de</a> seguran√ßa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">security@valvesoftware.com</a> ) por volta das 16:00 GMT e apenas 8 horas depois, uma corre√ß√£o foi criada e lan√ßada no cliente beta do Steam.  Gra√ßas a isso, a Valve agora est√° em primeiro lugar em nossa tabela (imagin√°ria) do concurso ‚ÄúQuem corrigir√° a vulnerabilidade mais rapidamente‚Äù - uma exce√ß√£o agrad√°vel em compara√ß√£o com a divulga√ß√£o de erros para outras empresas, que geralmente resulta em um longo processo de aprova√ß√£o. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma p√°gina que descreve os detalhes de todas as atualiza√ß√µes do cliente</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413003/">https://habr.com/ru/post/pt413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412993/index.html">Infraestrutura de chave p√∫blica: Utilit√°rio de gera√ß√£o de solicita√ß√£o de certificado qualificado</a></li>
<li><a href="../pt412995/index.html">SAP r√°pido</a></li>
<li><a href="../pt412997/index.html">Esconde-esconde, ou a primeira botnet que n√£o tem medo de reiniciar</a></li>
<li><a href="../pt412999/index.html">Do zumbido das girafas aos sons de p√°ssaros mim√©ticos - ouvindo a natureza juntos</a></li>
<li><a href="../pt413001/index.html">SamsPcbGuide, Parte 5: Rastreando Linhas de Sinal. Distor√ß√£o de linha e correspond√™ncia de imped√¢ncia</a></li>
<li><a href="../pt413005/index.html">Blockchain - uma cura para as principais doen√ßas da educa√ß√£o moderna</a></li>
<li><a href="../pt413007/index.html">S√≠ntese estranha ao trabalhar com FPGA</a></li>
<li><a href="../pt413009/index.html">Gerenciamento de ambiente Python com Pipenv</a></li>
<li><a href="../pt413011/index.html">Por√£o da morte</a></li>
<li><a href="../pt413013/index.html">O desejo de transpar√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>