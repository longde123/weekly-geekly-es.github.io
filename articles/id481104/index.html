<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•¡ ğŸ¦ˆ ğŸ—„ï¸ Memadukan OpenJDK dan NodeJS: Interaksi Lintas Bahasa dan Arsitektur Vertikal ğŸ•• ğŸ„ â™€ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Untuk waktu yang lama saya punya ide untuk mendiskusikan GraalVM dengan Anda, ditunda sampai akhirnya menemukan artikel hari ini, subje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memadukan OpenJDK dan NodeJS: Interaksi Lintas Bahasa dan Arsitektur Vertikal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/481104/">  Halo, Habr! <br><br>  Untuk waktu yang lama saya punya ide untuk mendiskusikan <a href="https://www.graalvm.org/">GraalVM</a> dengan Anda, ditunda sampai akhirnya menemukan artikel hari ini, subjek yang serius melampaui lingkup analisis mesin virtual tertentu.  Penulis Mike Hearn menguraikan seluruh paradigma interaksi multibahasa dan pemrograman multibahasa (pemrograman polyglot).  Berikutnya adalah contoh terkenal tentang penskalaan vertikal dan artikel yang sangat panjang di bawah potongan. <br><br><img src="https://habrastorage.org/webt/w8/rn/pl/w8rnplm8qono1q-owxp4_dcmlxk.jpeg"><br><a name="habracut"></a><br>  Artikel ini adalah tentang cara inovatif menulis perangkat lunak yang mungkin menjadi populer di masa depan, tetapi mungkin tidak sekarang.  Artikel punya kode, jujur! <br><br>  Di zaman kuno, yaitu, pada tahun 2015, saya menulis <a href="https://blog.plan99.net/why-kotlin-is-my-next-programming-language-c25c001e26e3%3F">mengapa Kotlin akan menjadi bahasa pemrograman saya berikutnya</a> , dan pada tahun 2016 saya menulis tentang <a href="https://blog.plan99.net/graal-truffle-134d8f28fb69">Graal dan Truffle</a> : dua proyek penelitian radikal terkait dengan kompiler yang tidak hanya secara signifikan mempercepat pekerjaan bahasa seperti Ruby , tetapi juga mewujudkan interaksi antarbahasa yang mulus.  Dalam proyek-proyek ini, kompiler dinamis (JIT) atau OpenJDK diganti dengan yang baru yang memiliki kemampuan untuk mengubah penerjemah beranotasi menjadi kompiler JIT canggih ... secara otomatis. <br><br>  Kembali ke topik ini pada tahun 2019, saya ingin menunjukkan kepada Anda tiga hal: <br><br><ol><li>  Bagaimana cara menggunakan perpustakaan kecil yang saya tulis untuk hampir secara mulus menggunakan modul NPM dari kode program yang ditulis dalam Java atau Kotlin. </li><li>  Jelaskan semua alasan bagus mengapa Anda mungkin membutuhkannya, bahkan jika Anda menganggap JavaScript / Java adalah hal terburuk di dunia, tidak termasuk minyak ikan. </li><li>  Jelajahi konsep arsitektur vertikal secara singkat yang bersaing dengan desain berorientasi layanan-mikro.  Itu terletak di persimpangan versi terbaru GraalVM dan OpenJDK, dan membutuhkan perangkat keras paling canggih. </li></ol><br><h4>  Menggunakan NPM dari Jawa dan Kotlin </h4><br>  Kami hanya akan mengambil tiga langkah sederhana: <br><br><ol><li> Ambil <a href="https://www.graalvm.org/">GraalVM</a> .  Ini adalah satu set tambalan, dibangun di atas OpenJDK, yang muncul tepat pada waktunya: ia dapat menjalankan semua kode byte JVM yang Anda miliki. </li><li>  Kami mengambil toolkit <a href="https://github.com/mikehearn/nodejvm">NodeJVM</a> saya dari github dan menambahkannya ke jalur kami. </li><li> Ganti <code>java</code> pada baris perintah dengan <code>nodejvm</code> .  Itu saja! </li></ol><br>  Baik, baik.  Saya akui, di sini saya menggambar sedikit dan membesar-besarkan, sampai akhir artikel Anda harus menanggung gaya seperti itu.  Tentu saja, semuanya tidak begitu sederhana sama sekali: Anda masih harus mengambil modul dan menggunakannya. <br><br>  Pertimbangkan seperti apa tampilannya: <br><br><img src="https://habrastorage.org/webt/f3/ov/xv/f3ovxvzch5mpwwmhy8w7tqyyiaw.png"><br><br>  Kode Sampel Menggunakan NodeJVM <br><br>  Perhatikan gambar ini dengan seksama.  Ya, seperti itulah tampilannya: Kotlin dengan string multi-baris bawaan tempat pelengkapan otomatis JavaScript terjadi, setelah itu dilakukan analisis JavaScript statis, dan sintaksinya disorot dengan benar.  Operasi yang sama berfungsi dari Jawa atau bahasa lain untuk JVM yang dipahami IntelliJ.  Untuk mendapatkan peluang seperti itu, Anda perlu mengklik sakelar di pengaturan IDE (baca readme untuk NodeJVM untuk cara melakukannya), tetapi nanti fungsi ini akan bekerja secara otomatis.  Jika IntelliJ berhasil mencari tahu dengan menganalisis aliran data yang pada akhirnya string Anda akan diteruskan ke metode <code>run</code> atau <code>eval</code> , maka itu akan diperlakukan sebagai JS yang disematkan. <br><br>  Di sini saya akan berbicara tentang API untuk Kotlin, karena ini sedikit lebih cantik dan lebih nyaman daripada API di Jawa normal, tetapi semua yang saya jelaskan di bawah ini juga dapat dilakukan dari Jawa. <br><br>  Dalam kode di atas, perhatikan beberapa fitur berikut: <br><br><ul><li>  Untuk mengakses JavaScript, Anda harus menggunakan blok <code>nodejs {}</code> .  Faktanya adalah bahwa JavaScript adalah single-threaded dan, karenanya, untuk menjalankan modul NPM Anda perlu "memasuki aliran Node".  <code>nodejs {}</code> melakukan sinkronisasi seperti itu untuk kami, apa pun <code>nodejs {}</code> .  Jadi, Anda harus selalu ingat: untuk menjalankan kode JS, pada prinsipnya, Anda harus berada di dalam blok tersebut.  Anda dapat memasukkannya kembali sesering yang Anda mau, sehingga akan aman untuk menggunakan blok seperti itu di tempat mana pun kami membutuhkannya.  Setiap panggilan balik JavaScript akan dieksekusi di utas Node, dan dengan demikian, semua utas lainnya akan ditolak aksesnya ke blok <code>nodejs</code> , jadi jika Anda khawatir tentang kinerja atau kelancaran rendering GUI, maka hindari melakukan operasi jangka panjang dalam callback. </li><li>  Sintaks <code>var x by bind(SomeObject())</code> hanya tersedia di blok <code>nodejs</code> dan memungkinkan Anda untuk terhubung ke variabel yang sama dalam lingkup JavaScript global.  Ketika x berubah dari Kotlin, itu akan berubah di JS dan sebaliknya.  Di sini saya melampirkan objek Java <code>File</code> biasa ke dunia JS. </li><li>  Metode <code>eval</code> mengembalikan ... apa yang kita minta untuk dikembalikan, dengan cara mengetik statis.  Ini adalah fungsi generik dan, hanya dengan menentukan jenis entitas yang kami tetapkan untuk itu, kami akan memastikan bahwa eval secara otomatis melemparkan objek JavaScript ke kelas yang diketik secara statis atau antarmuka Java / Kotlin / Scala / etc.  Meskipun ini tidak secara eksplisit dinyatakan di atas, <code>MemoryUsage</code> adalah tipe antarmuka sederhana yang saya definisikan, dan memiliki fungsi <code>rss()</code> dan <code>heapTotal()</code> .  Mereka memetakan ke properti JavaScript dengan nama yang sama, menerapkannya pada apa yang Anda dapatkan dari proses Node <code>process.memoryUsage()</code> .  Sebagian besar tipe JS dengan demikian dapat dikonversi ke tipe Java "normal";  dokumentasi terperinci tentang cara kerjanya tersedia di situs web GraalVM.  Objek yang dihasilkan dapat disimpan di mana saja, tetapi panggilan metode di dalamnya, tentu saja, harus dilakukan di blok <code>nodejs</code> . </li><li>  Objek JavaScript juga dapat dianggap pemetaan sederhana dari string ke objek, yang dalam banyak hal benar-benar cocok dengan sifatnya.  Pada gilirannya, pemetaan string ke suatu objek dapat dibawa kembali ke beberapa hal yang diketik lebih kuat, yang dapat dilihat dengan jelas di callback.  Gunakan presentasi yang Anda sukai. </li><li>  Anda dapat menggunakan <code>node_modules</code> dan itu akan mencari modul di direktori <code>node_modules</code> dengan cara biasa. </li></ul><br>  Cuplikan kode di atas menggunakan protokol <a href="https://dat.foundation/">DAT</a> , yang memungkinkan Anda untuk terhubung ke jaringan peer-to-peer yang mirip BitTorrent, dan kemudian mencari rekan yang memiliki file yang diinginkan.  Saya menggunakan DAT sebagai contoh, karena ini adalah (a) terdesentralisasi dan oleh karena itu sangat unik dan (b) baik atau buruk, implementasi rujukannya ditulis dalam JavaScript.  Ini bukan program yang bisa saya tulis sepenuhnya tanpa menggunakan JS pada waktu yang wajar. <br><br>  Ini juga dapat dilakukan dari Jawa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.plan99.nodejs.NodeJS; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = NodeJS.runJS(() -&gt; NodeJS.eval(<span class="hljs-string"><span class="hljs-string">"return 2 + 3 + 4"</span></span>).asInt() ); System.out.println(result); } }</code> </pre> <br>  Java API tidak memberi Anda pengikatan variabel dan auto-casting yang menyenangkan seperti API Kotlin, tetapi cukup mudah digunakan.  Di sini kami menunjukkan bagaimana kami mengonversi hasilnya menjadi tipe integer Java ( <code>int</code> ) dan mengembalikannya "dari" aliran Node: dalam hal ini, aliran Java utama <b>tidak sama dengan</b> aliran NodeJS, tetapi kami beralih di antara aliran ini sepenuhnya dengan mulus. <br><br>  NodeJVM adalah pembungkus yang sangat, sangat kecil di atas <a href="https://www.graalvm.org/">GraalVM</a> .  Itu menambah jumlah kode yang tidak signifikan, jadi jangan khawatir bahwa kode tersebut akan berhenti didukung atau dihilangkan: 99,99% dari semua kerja keras dalam hal ini dilakukan oleh tim GraalVM. <br><br>  Berikut adalah beberapa ide yang jelas untuk menyarankan peningkatan: <br><br><ul><li>  Izinkan modul JS mengimpor modul Java dengan koordinat Maven. </li><li>  Untuk merumuskan beberapa "praktik terbaik" untuk penyatuan modul NPM.  Misalnya, dapat file JAR berisi direktori node_modules (singkatnya: tidak, karena NodeJS masih mengatur file I / O dengan caranya sendiri dan tidak tahu apa-apa tentang ritsleting, lama: ya, jika Anda berusaha keras). </li><li>  Lebih banyak bahasa: Python dan Ruby tidak memerlukan "lem" untuk sinkronisasi utas yang diperlukan di NodeJS, jadi Anda bisa menggunakan <a href="https://www.graalvm.org/docs/reference-manual/polyglot/">GraalVM Polyglot API biasa</a> .  Tetapi pengguna Kotlin akan menemukan bahwa metode cor / ekstensi dan API untuk variabel pengikatan akan menyenangkan untuk dimiliki dalam bahasa apa pun. </li><li>  Dukungan Windows. </li><li>  Plugin Gradle sehingga program dapat memiliki daftar ketergantungan dalam serangkaian bahasa campuran </li><li>  Integrasi dengan alat <code>native-image</code> , yang disebut  SubstrateVM;  jadi jika Anda tidak memerlukan kinerja penuh HotSpot saat runtime, Anda dapat menyediakan binari kecil yang terhubung secara statis dalam gaya Golang. </li><li>  Mungkin semacam konverter untuk mengubah TypeScript ke Java, sehingga Anda dapat menggunakan <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> dan dengan cepat terjun ke dunia statis. </li></ul><br>  Tambalan dipersilakan. <br><br><h4>  Mengapa Anda membutuhkan ini? </h4><br>  Mungkin Anda sudah berpikir: "Wow, JavaScript, kami, maju, sekarang bisa saling mencintai, saling menghormati, dan harmoni!" <br><br><img src="https://habrastorage.org/webt/pg/hg/_d/pghg_dqd6pgbortse6gaqdks-p8.gif"><br><br>  Reaksi Antusias yang Diidealkan <br><br>  Sangat mungkin bahwa Anda akan lebih dekat ke sudut pandang ini: <br><br><img src="https://habrastorage.org/webt/j9/th/g6/j9thg6dscg5ce13x_vtpajwvjmm.jpeg"><br><br>  JavaScript dan Java bukan hanya bahasa.  Ini adalah budaya, dan tidak ada yang manis bagi pengembang seperti PERANG BUDAYA! <br><br>  Itulah mengapa Anda setidaknya harus membookmark halaman ini untuk referensi di masa mendatang, bahkan jika Anda hanya ingin mengambil senjata dengan pertimbangan $ OTHER_LANG menginvasi ekosistem berharga Anda: <br><br><ul><li>  Jika Anda terutama pengembang <b>Java</b> , sekarang Anda memiliki akses ke modul JavaScript unik yang mungkin tidak memiliki yang setara di JVM (misalnya, protokol DAT).  Anda dapat memujanya atau membencinya, tetapi faktanya tetap ada: banyak orang menulis modul NPM open source, dan beberapa modul ini sangat bagus.  Anda juga dapat menggunakan kembali kode yang berjalan di frontend web Anda tanpa perlu pengangkut bahasa.  Dan jika Anda bekerja dengan basis kode yang diwarisi di NodeJS, yang Anda ingin secara bertahap port ke Jawa, maka tiba-tiba pekerjaan ini sangat disederhanakan. </li><li>  Jika Anda terutama adalah pengembang <b>JavaScript</b> , sekarang Anda memiliki akses mudah ke pustaka JVM unik, yang dalam JavaScript mungkin tidak memiliki padanan langsung (mis. <a href="http://lucene.apache.org/">Lucene</a> , <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle Map</a> ) atau mungkin menawarkan hanya analog yang didokumentasikan dengan buruk, tidak matang atau kurang produktif. .  Jika Anda ingin melakukannya tanpa HTML di proyek berikutnya, maka Anda dapat menjelajahi <a href="https://blog.plan99.net/reacts-tictactoe-tutorial-in-kotlin-javafx-715c75a947d2">kerangka kerja GUI untuk orang kulit putih</a> .  Anda juga mendapatkan akses ke <b>banyak bahasa lain</b> , misalnya, objek Ruby dan R. JVM dapat dibagi antara karyawan NodeJS, mengambil <a href="https://medium.com/graalvm/multi-threaded-java-javascript-language-interoperability-in-graalvm-2f19c1f9c37b">keuntungan dari multithreading dalam memori bersama</a> , jika, menurut profiler Anda, peluang ini dapat digunakan.  Dan jika Anda bekerja dengan basis kode Java yang diwarisi yang Anda ingin secara bertahap port ke NodeJS, maka tiba-tiba pekerjaan ini sangat disederhanakan. </li><li>  Jika Anda <b>mempelajari semua bahasa sekaligus</b> , maka Anda dapat melakukan pemrograman multibahasa.  Pemrogram Polyglot bukan pembenci, sebaliknya, mereka dapat berteman dengan kode terbaik yang tersedia, tidak peduli dari mana budaya itu berasal.  Mereka seperti mahasiswa kebangkitan yang segera belajar bahasa Inggris, Perancis Latin ... semua bahasa ini adalah satu untuk mereka.  Mereka mencampur Java, Kotlin, JavaScript, Scala, Python, Ruby, Lisp, R, Rust, Smalltalk, C / C ++, dan bahkan pustaka FORTRAN, murni menjahit integer yang rapi di atas GraalVM. </li><li>  Akhirnya, jika Anda adalah pengguna NodeJS yang bahagia, dan bahasa lain tidak mengganggu Anda sama sekali, maka Anda mungkin masih ingin bereksperimen dengan GraalVM. </li></ul><br>  NodeJS didasarkan pada V8, mesin virtual yang dirancang untuk menggunakan skrip single-threaded berumur pendek yang berjalan pada PC dan smartphone.  Ini persis seperti apa yang didanai oleh Google, tetapi V8 juga digunakan di server.  OpenJDK telah dioptimalkan selama beberapa dekade di server.  Versi terbaru berisi <a href="https://wiki.openjdk.java.net/display/zgc/Main">ZGC</a> dan <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Shenandoah</a> , dua pengumpul sampah yang memungkinkan latensi minimal, alat yang memungkinkan Anda untuk mengkonsumsi memori terabyte, dengan hanya beberapa milidetik jeda.  Karena itu, Anda bahkan dapat mengurangi biaya dengan menggunakan <a href="https://www.graalvm.org/docs/reference-manual/tools/">infrastruktur dan alat GraalVM yang sangat baik</a> , tanpa meninggalkan monolingualisme. <br><br><img src="https://habrastorage.org/webt/tn/4y/68/tn4y68r7cmq6z9tpheeuwafpncy.png"><br><br>  Lihat tumpukan yang berisi objek Ruby <br><br><img src="https://habrastorage.org/webt/ko/vc/jj/kovcjjmwvhnayjpfix25cs-rx48.png"><br><br>  Metrik CPU Tersedia Melalui HTTP <br><br><img src="https://habrastorage.org/webt/sb/fq/qy/sbfqqy9mzuppcp-vnro8tdscc_o.png"><br><br>  Diagnostik pakar yang sangat mendalam menunjukkan bagaimana kode dioptimalkan <br><br><h4>  Arsitektur vertikal </h4><br>  Kita sampai pada topik terakhir yang ingin saya bahas dalam artikel ini. <br><br>  Kadang-kadang saya memberi tahu seseorang semua hal di atas, tetapi mereka menjawab saya: â€œ <i>Ini bagus, tetapi tidak semua layanan mikro ini memberi kita semua ini?</i>  <i>Untuk apa semua ini?</i>  Sulit untuk menghargai mengapa saya sangat menyukai pemrograman multibahasa, tetapi masalahnya, menurut saya arsitektur layanan-mikro memerlukan persaingan yang sehat. <br><br>  Pertama, ya, kadang-kadang Anda perlu mengarahkan banyak layanan di berbagai server yang perlu berinteraksi.  Saya bekerja selama lebih dari 7 tahun di Google, hampir setiap hari berurusan dengan orkestra kontainer mereka, Borg.  Saya menulis "layanan mikro", meskipun kami bahkan tidak memanggilnya, dan saya mengkonsumsinya.  Kalau tidak, tidak ada cara untuk mengatasinya, karena beban kerja kami membutuhkan partisipasi ribuan mesin! <br><br>  Namun, untuk arsitektur seperti itu Anda harus membayar mahal: <br><br><ol><li>  <b>Serialisasi</b>  Ini segera menghasilkan penurunan kinerja, tetapi, yang lebih penting, mengharuskan Anda untuk terus menyelaraskan setidaknya Anda mengetik sebagian dan struktur data yang dioptimalkan, mengubahnya menjadi pohon sederhana.  Saat beralih ke JSON, Anda kehilangan kemampuan untuk melakukan hal-hal sederhana, misalnya, memiliki banyak objek kecil yang mengarah ke beberapa objek besar (untuk menghindari pengulangan, Anda harus menggunakan indeks Anda sendiri). </li><li>  <b>Versi</b>  Ini rumit.  Universitas sering tidak mengajarkan ini sulit tetapi disiplin sehari-hari di bidang rekayasa perangkat lunak dan bahkan jika Anda berpikir bahwa Anda telah benar-benar memahami perbedaan antara kompatibilitas langsung dan mundur, bahkan jika Anda yakin bahwa Anda memahami apa itu multi-stage rolling, dapatkah Anda menjamin bahwa semua ini akan dipahami oleh orang yang akan menggantikanmu?  Apakah Anda melakukan pengujian integrasi dengan benar untuk berbagai kombinasi versi yang dapat berkembang selama peluncuran non-atom?  Dalam arsitektur terdistribusi, saya melihat beberapa bencana asli yang bermuara pada fakta bahwa versi tersesat. </li><li>  <b>Koherensi</b>  Melakukan operasi atom dalam server yang sama cukup mudah.  Adalah jauh lebih sulit untuk memastikan bahwa pengguna dalam situasi apa pun melihat gambaran yang benar-benar konsisten ketika banyak mesin terlibat dalam sistem, terutama jika terjadi sharding data di antara mereka.  Inilah sebabnya mengapa secara historis, mesin basis data relasional tidak dapat membanggakan skalabilitas yang baik.  Izinkan saya memberi tahu Anda: para <a href="https://www.piter.com/collection/all/product/site-reliability-engineering-nadezhnost-i-bezotkaznost-kak-v-google">insinyur Google terbaik telah menghabiskan waktu puluhan tahun</a> mencoba menyederhanakan pemrograman terdistribusi untuk tim mereka, mencoba membangunnya sehingga lebih mirip dengan yang tradisional. </li><li>  <b>Implementasi ulang</b> .  Karena panggilan prosedur jarak jauh mahal, Anda tidak akan melakukan banyak panggilan seperti itu, dan tidak ada yang tersisa untuk dilakukan untuk menyelesaikan beberapa masalah selain menerapkan kembali kode.  Google telah membuat beberapa perpustakaan untuk bekerja dengan beberapa bahasa sekaligus, yang dirancang untuk melakukan panggilan ke prosedur jarak jauh;  Ada juga situasi di mana kode tersebut harus ditulis ulang dari awal. </li></ol><br>  Jadi apa alternatifnya? <br><br>  Sederhananya, banyak zat besi.  Metode ini mungkin tampak seperti kakek yang tidak masuk akal, tetapi perlu diingat bahwa biaya perangkat keras terus menurun, banyak beban kerja tidak disebut "global global", dan intuisi Anda tentang apa yang harus Anda belanjakan dapat membuat Anda gagal. <br><br>  Berikut adalah <a href="http://www.deltaserverstore.com/dell-r910.html">daftar harga yang</a> relatif baru dari satu pabrikan Kanada: <br><br><img src="https://habrastorage.org/webt/_2/ko/qq/_2koqq_9uanqjed7ebsfcwjzyqy.png"><br><br>  Mesin empat puluh nuklir dengan terabyte RAM dan hampir satu terabyte pada hard drive harganya sekitar $ 6k hari ini.  Bayangkan berapa banyak waktu untuk seluruh masa proyek tim Anda harus menyelesaikan masalah dengan sistem terdistribusi, dan berapa banyak biaya yang harus Anda keluarkan. <br><br>  Ya, tetapi tidak semua perusahaan saat ini berbasis web global? <br><br>  Singkatnya, tidak. <br><br>  Dunia ini penuh dengan perusahaan-perusahaan yang hal-hal berikut ini benar: <br><br><ul><li>  Mereka beroperasi di pasar yang stabil. </li><li>  Mereka menghasilkan dengan menjual barang. </li><li>  Akibatnya, basis pelanggan mereka adalah dari beberapa puluh ribu hingga puluhan juta orang, tetapi tidak dalam miliaran. </li><li>  Kumpulan data mereka biasanya dikaitkan dengan pelanggan dan produk mereka sendiri. </li></ul><br>  Contoh yang baik dari perusahaan semacam itu adalah bank.  Bank tidak mengalami "hiper pertumbuhan", jangan menjadi "viral".  Model pertumbuhan mereka moderat dan dapat diprediksi, jika seseorang berasumsi bahwa mereka memiliki pertumbuhan (bank bersifat regional dan biasanya beroperasi di pasar jenuh).  Basis pelanggan dari bank AS terbesar adalah sekitar 50 juta pengguna dan, tentu saja, tidak berlipat ganda setiap enam bulan.  Dalam hal ini, situasinya sama sekali tidak sama dengan Instagram.  Oleh karena itu, tidak mengherankan bahwa mainframe masih didasarkan pada sistem bank yang khas?  Tentu saja, hal yang sama berlaku untuk perusahaan logistik, perusahaan manufaktur, dll.  Ini adalah roti dan mentega ekonomi kita. <br><br>  Dalam bisnis seperti itu, sangat mungkin bahwa kebutuhan setiap aplikasi spesifik yang terkait dengannya selalu dapat dipenuhi dengan sumber daya hanya dari satu mesin besar.  Ya di sana, bahkan beberapa situs publik saat ini muat pada satu mesin.  Pada 2015, Maciej Tseglovsky memberikan ceramah yang sangat menarik tentang " <a href="https://idlewords.com/talks/website_obesity.htm">Krisis dengan obesitas situs</a> " dan mencatat bahwa situsnya sendiri dengan layanan bookmark menguntungkan, tetapi kompetitornya memposting situs yang sama di AWS - dan hilang, hanya karena biaya yang berbeda peralatan dan berbagai asumsi tentang kompleksitas.  Dalam sebuah studi tentang membandingkan <a href="https://blog.codinghorror.com/scaling-up-vs-scaling-out-hidden-costs/">penskalaan vertikal dan horizontal,</a> ditemukan bahwa PlentyOfFish berjalan sekitar ~ satu megaserver (artikel ini berasal dari 2009, sehingga Anda dapat mengabaikan harga peralatan yang tercantum di sana).  Penulis melakukan beberapa perhitungan dan menunjukkan bahwa satu server tidak sebodoh kelihatannya.  Akhirnya, jika Anda mempertimbangkan Hadoop dan Big Data, bacalah <a href="https://www.researchgate.net/publication/261862149_Scale-up_vs_scale-out_for_Hadoop_time_to_rethink">artikel penelitian Microsoft 2013 ini,</a> yang menunjukkan bahwa banyak beban kerja Hadoop dari Microsoft, Yahoo, dan Facebook benar-benar berjalan jauh lebih cepat dan lebih efisien pada satu mesin besar, daripada pada sebuah cluster.  Dan itu 6 tahun yang lalu!  Sangat mungkin bahwa sejak saat itu penekanan pada penskalaan vertikal menjadi lebih jelas. <br><br>  Namun, penghematan nyata tidak terkait dengan peralatan sama sekali, tetapi dengan optimalisasi waktu kerja para insinyur yang sangat mahal, yang dihabiskan untuk menciptakan sekelompok layanan mikro kecil yang harus ditingkatkan secara horizontal dengan manajemen permintaan yang elastis.  Pendekatan teknik semacam itu berisiko dan menghabiskan waktu, bahkan jika Anda menggunakan mainan terbaru yang tersedia di cloud.  Anda dapat kehilangan SQL, transaksi SOLID, profil terpadu, dan Anda pasti akan kehilangan informasi seperti pelacakan tumpukan sistem silang.  Jenis keamanan akan hilang setiap kali Anda melampaui server.  Anda akan menerima panggilan ke fungsi yang mungkin time out, overhead berlebihan yang terkait dengan kompilasi dinamis, kegagalan tekanan balik yang tidak terduga, mesin orkestra kompleks dengan format konfigurasi mewah, dan ... oh, memori benar-benar membanjiri.  Sangat menarik untuk bekerja dengan semua ini ketika saya memiliki arsitektur Google berpemilik dan anggaran teknik yang tebal yang saya miliki, tetapi hari ini saya berani mengulangi ini hanya jika saya tidak punya pilihan lain. <br><br>  Menurut pengalaman, tidak mungkin untuk bekerja dengan server yang sangat besar yang beroperasi pada pengumpulan sampah - masalahnya adalah pengumpulan sampah itu sendiri adalah teknologi yang kurang berkembang, dan karena itu topik ini telah lama tetap murni bersifat akademis.  Bagaimanapun, Anda harus mengarahkan beberapa server sekaligus. ,   ZGC  Shenandoah,   ,   80          â€“      .    ,     -,       â€“  ,     . <br><br> ,         ?         â€“   ,        ?   â€“    :  ,      ,        â€¦    . <br><br><h4>  Kesimpulan </h4><br> NodeJVM â€“  ,    GraalVM.     NPM    Java/Kotlin,   JS  ,    Kotlin   JavaScript,      JS  ,   V8. <br><br>     ,    JS  Java,    Java  JS         . <br><br>        ,           4 ,     â€“      â€“  ,            .             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481104/">https://habr.com/ru/post/id481104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481086/index.html">Vivaldi 2.10 - Agen Penyamaran</a></li>
<li><a href="../id481092/index.html">Hal paling menarik di PHP 8</a></li>
<li><a href="../id481094/index.html">Tentang headphone nirkabel JBL dengan tenaga surya dan apa yang salah dengannya</a></li>
<li><a href="../id481100/index.html">Sudut 9, apa yang baru?</a></li>
<li><a href="../id481102/index.html">Cross-platform .NET UI toolkit merilis AvaloniaUI 0.9</a></li>
<li><a href="../id481106/index.html">Bagaimana LANIT menembak DIY-sitcom di kantornya</a></li>
<li><a href="../id481110/index.html">Ulasan Playme VEGA: perekam combo dengan layar sentuh dan mirror mount</a></li>
<li><a href="../id481112/index.html">Apa yang akan dikatakan "permen karet" usia 5700 tahun tentang orang yang mengunyahnya?</a></li>
<li><a href="../id481114/index.html">Seccomp di Kubernetes: 7 Hal yang Perlu Anda Ketahui Dari Awal</a></li>
<li><a href="../id481116/index.html">Secara otomatis mempublikasikan posting dari komunitas VKontakte ke Discord</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>