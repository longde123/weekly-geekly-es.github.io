<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üíø üî≤ Como parar de escrever firmware para microcontroladores e come√ßar a viver ‚õΩÔ∏è üÜò üßõüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, meu nome √© Eugene e estou cansado de escrever firmware para microcontroladores. Como isso aconteceu e o que fazer com isso, vamos descobrir. 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como parar de escrever firmware para microcontroladores e come√ßar a viver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Ol√°, meu nome √© Eugene e estou cansado de escrever firmware para microcontroladores.  Como isso aconteceu e o que fazer com isso, vamos descobrir. </p><a name="habracut"></a><br><p>  Depois de trabalhar em grande programa√ß√£o C ++, Java, Python, etc., voc√™ n√£o sente vontade de voltar para microcontroladores pequenos e com barriguinha.  Para suas escassas ferramentas e bibliotecas.  Mas √†s vezes n√£o h√° nada a fazer, as tarefas de tempo real e autonomia n√£o deixam uma escolha.  Mas existem alguns tipos de tarefas que simplesmente ficam loucas nessa √°rea para resolver. </p><br><p>  Por exemplo, equipamentos de teste, algo mais chato e chato em programa√ß√£o incorporada, dificilmente podem ser imaginados.  Em geral, bem como ferramentas convenientes para isso.  Voc√™ escreve ... Voc√™ pisca ... pisca ... um LED (√†s vezes faz logon no UART).  Todas as canetas, sem ferramentas de teste especializadas. </p><br><p>  Tamb√©m √© deprimente que n√£o haja testes instrumentais para nossos pequenos microcontroladores.  Tudo √© apenas atrav√©s do firmware e atrav√©s do depurador para testar. </p><br><p> E o estudo do trabalho com novos dispositivos e perif√©ricos requer muito esfor√ßo e tempo.  Um erro e o programa devem ser recompilados e executados novamente a cada vez. </p><br><p>  Para tais experi√™ncias, algo como REPL √© mais adequado, para que voc√™ possa fazer de maneira simples e indolor, pelo menos trivial: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \ </p><br><p>  Como chegar a isso, esta s√©rie de artigos √© dedicada. </p><br><p>  E desta vez me deparei com um projeto em que era necess√°rio testar um dispositivo bastante complicado, com muitos tipos de sensores e outros chips desconhecidos para mim anteriormente, que usavam muitos perif√©ricos MK e v√°rias interfaces diferentes.  A divers√£o especial foi que eu n√£o tinha os c√≥digos-fonte do firmware para a placa, ent√£o todos os testes precisavam ser escritos do zero, sem usar o tempo de opera√ß√£o do c√≥digo-fonte. </p><br><p>  O projeto prometeu um bom toastmaster e as competi√ß√µes s√£o interessantes por mais ou menos dois meses (e provavelmente mais). </p><br><p>  Ok, aqui n√£o vamos chorar.  √â preciso mergulhar nos confins do C e no firmware sem fim novamente, ou recusar ou criar algo para facilitar esta li√ß√£o.  No final, pregui√ßa e curiosidade s√£o o motor do progresso. </p><br><p>  Na √∫ltima vez, quando entendi o OpenOCD, deparei com um ponto t√£o interessante na documenta√ß√£o como </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb ‚Äî         mww, mwh, mwb ‚Äî       </code> </pre> <br><p>  Interessante ...  E √© poss√≠vel ler e gravar registros perif√©ricos com eles? ... acaba sendo poss√≠vel e, al√©m disso, esses comandos podem ser executados remotamente atrav√©s do servidor TCL, que inicia quando o openOCD √© iniciado. </p><br><p>  Aqui est√° um exemplo de um LED piscando para stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  e uma sequ√™ncia semelhante de comandos openOCD </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  E agora, se voc√™ pensar no eterno e considerar o firmware para o MK ... ent√£o o principal objetivo desses programas √© escrever nos registradores de chips;  O firmware que far√° apenas algo e funcionar√° apenas com o n√∫cleo do processador n√£o tem uso pr√°tico! </p><br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text"><p>  Embora, √© claro, voc√™ possa considerar a cripta (= </p></div></div><br><p>  Muitos v√£o se lembrar mais sobre como trabalhar com interrup√ß√µes.  Mas eles nem sempre s√£o necess√°rios e, no meu caso, voc√™ pode ficar sem eles. </p><br><p>  E assim, a vida est√° melhorando.  No c√≥digo-fonte do openOCD voc√™ pode at√© encontrar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> interessante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de</a> usar essa interface. </p><br><p>  Muito bom espa√ßo em branco em python. </p><br><p>  √â bem poss√≠vel converter endere√ßos de registro de arquivos de cabe√ßalho e come√ßar a escrever em uma linguagem de script kosher.  Voc√™ j√° pode preparar champanhe, mas me pareceu insuficiente, porque quero usar a Biblioteca de Perif√©ricos Padr√£o ou o novo HAL para trabalhar com perif√©ricos em vez de mexer nos registros. </p><br><p>  Portando bibliotecas para python ... em algum pesadelo, faremos isso.  Ent√£o voc√™ precisa usar essas bibliotecas em C ou ... C ++.  E nos profissionais, voc√™ pode substituir quase todos os operadores ... por suas classes. </p><br><p>  E os endere√ßos base nos arquivos de cabe√ßalho, substitua pelos objetos de suas classes. </p><br><p>  Por exemplo, no arquivo stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Substitua por </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Mas jogos com ponteiros na biblioteca cortam essa id√©ia pela raiz ... </p><br><p>  Aqui est√° um exemplo de arquivo stm32f10x_i2c.c: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ‚Ä¶.</code> </pre> <br><p>  Portanto, √© necess√°rio interceptar endere√ßos para endere√ßos de alguma maneira diferente.  Como fazer isso provavelmente vale a pena dar uma olhada em Valgrind, n√£o √† toa que ele tenha um verificador de mem√≥rias.  Bem, ele realmente deve saber como interceptar endere√ßos. </p><br><p>  Olhando para o futuro, direi que √© melhor n√£o olhar para l√° ... quase consegui interceptar chamadas para endere√ßos.  Para quase todos os casos, exceto este </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  √â poss√≠vel interceptar o endere√ßo, mas n√£o foi mais poss√≠vel interceptar os dados gravados.  Somente o nome do registro interno no qual esse valor est√°, mas que n√£o pode ser acessado na verifica√ß√£o de mem√≥rias. </p><br><p>  De fato, Valgrind me surpreendeu, dentro do antigo monstro libVEX √© usado, sobre o qual eu n√£o encontrei nenhuma informa√ß√£o na Internet.  √â bom que tenha sido encontrada alguma documenta√ß√£o nos arquivos de cabe√ßalho. </p><br><p>  Depois, havia outras ferramentas DBI. </p><br><p>  Frida, Dynamic RIO, um pouco mais e finalmente conseguiu o Pintool. </p><br><p>  O PinTool tinha uma boa documenta√ß√£o e exemplos.  Embora eu ainda n√£o tivesse o suficiente, tive que fazer experimentos com algumas coisas.  A ferramenta acabou sendo muito poderosa, apenas altera o c√≥digo fechado e a restri√ß√£o apenas para a plataforma intel (embora no futuro isso possa ser contornado) </p><br><p>  Portanto, precisamos interceptar a grava√ß√£o e a leitura em endere√ßos espec√≠ficos.  Vamos ver quais instru√ß√µes s√£o respons√°veis ‚Äã‚Äãpor este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://godbolt.org/z/nJS9ci</a> . </p><br><p>  Para x64, este ser√° um MOV para ambas as opera√ß√µes. </p><br><p>  E para x86, ser√° MOV para escrita e MOVZ para leitura. </p><br><p>  Nota: √© melhor n√£o ativar a otimiza√ß√£o; caso contr√°rio, outras instru√ß√µes podem surgir. </p><br><div class="spoiler">  <b class="spoiler_title">T√≠tulo de spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  No caso de leitura do endere√ßo, chamamos a fun√ß√£o loadAddr2Reg e exclu√≠mos a instru√ß√£o original.  Com base nisso, loadAddr2Reg deve retornar o valor necess√°rio para n√≥s. </p><br><p>  Com um registro, √© cada vez mais dif√≠cil ... os argumentos podem ser de tipos diferentes e tamb√©m podem ser transmitidos de maneiras diferentes; portanto, √© necess√°rio chamar fun√ß√µes diferentes antes do comando.  Em uma plataforma de 32 bits, multiMemAccessStore e em 64 storeReg2Addr ser√£o chamados.  E aqui n√£o exclu√≠mos as instru√ß√µes da linha de montagem.  N√£o h√° problemas para remov√™-lo, mas em alguns casos n√£o √© poss√≠vel imitar sua a√ß√£o.  O programa, por algum motivo, √†s vezes colide com sigfault.  Isso n√£o √© cr√≠tico para n√≥s, escreva para si mesmo, o principal √© que existe a possibilidade de interceptar argumentos. </p><br><p>  Em seguida, precisamos ver quais endere√ßos precisamos interceptar; veja o mapa de mem√≥ria do chip stm32f103C8T6: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="imagem"><br>  Estamos interessados ‚Äã‚Äãem endere√ßos com SRAM e PERIPH_BASE, ou seja, de 0x20000000 a 0x20000000 + 128 * 1024 e de 0x40000000 a 0x40030000.  Bem, ou melhor, n√£o exatamente, como lembramos as instru√ß√µes de grava√ß√£o, n√£o conseguimos excluir.  Portanto, o registro nesses endere√ßos cair√° em sigfault.  Al√©m disso, √© improv√°vel que esses endere√ßos tenham dados de nosso programa, e n√£o esse chip.  Portanto, definitivamente precisamos corrigi-los em algum lugar.  Digamos em algum tipo de matriz. </p><br><p>  Criamos matrizes do tamanho necess√°rio e, em seguida, substitu√≠mos seus ponteiros no endere√ßo base definido. </p><br><p>  Em nosso programa, nas manchetes </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Fazer </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  e onde pAddrSRAM e pAddrPERIPH s√£o ponteiros para matrizes pr√©-alocadas. </p><br><p>  Agora, nosso cliente PinTool precisa, de alguma forma, transmitir como reparamos os endere√ßos necess√°rios. <br>  A coisa mais simples que me pareceu fazer isso foi interceptar uma fun√ß√£o que retorna uma estrutura de matriz deste formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Por exemplo, para o nosso chip, ele estar√° t√£o cheio </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  N√£o √© dif√≠cil interceptar a fun√ß√£o e obter os valores necess√°rios: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  E fa√ßa com que nossa fun√ß√£o interceptada fique assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Qual √© o trabalho mais n√£o trivial, resta fazer o cliente para o OpenOCD, no cliente PinTool que eu n√£o queria implement√°-lo, ent√£o criei um aplicativo separado com o qual nosso cliente PinTool se comunica atrav√©s do nome fifo. </p><br><p>  Assim, o esquema de interfaces e comunica√ß√µes √© o seguinte: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="imagem"><br>  Um fluxo de trabalho simplificado no exemplo de intercepta√ß√£o do endere√ßo 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="imagem"><br>  Vamos dar uma olhada no que acontece aqui: </p><br><p>  o cliente PinTool √© iniciado, inicializa nossos interceptores, inicia o programa <br>  O programa inicia, ele precisa endere√ßar os endere√ßos dos registradores em alguma matriz de threads, a fun√ß√£o getMemoryMap √© chamada, que nosso PinTool intercepta.  Por exemplo, um dos registradores mudou para o endere√ßo 0x123, n√≥s o rastrearemos <br>  Cliente PinTool salva os valores de endere√ßos n√£o associados <br>  Transfira o controle de volta para o nosso programa <br>  Al√©m disso, em algum lugar h√° uma grava√ß√£o em nosso endere√ßo rastreado 0x123.  A fun√ß√£o StoreReg2Addr controla isso <br>  E envia a solicita√ß√£o de grava√ß√£o para o cliente OpenOCD <br>  O cliente retorna a resposta que √© analisada.  Se tudo estiver bem, o controle do programa retornar√° <br>  Al√©m disso, em algum lugar do programa, a leitura ocorre no endere√ßo rastreado 0x123. <br>  O loadAddr2Reg rastreia isso e envia uma solicita√ß√£o OpenOCD ao cliente. <br>  O cliente OpenOCD processa e retorna uma resposta <br>  Se estiver tudo bem, mas o valor do registro MK for retornado ao programa <br>  O programa continua. <br>  Por enquanto √© tudo, os c√≥digos-fonte e os exemplos completos estar√£o nas seguintes partes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433504/">https://habr.com/ru/post/pt433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433494/index.html">10 idiomas ingleses que voc√™ nunca conhecer√°</a></li>
<li><a href="../pt433496/index.html">Empresas estatais obrigadas a mudar para software dom√©stico at√© 2022</a></li>
<li><a href="../pt433498/index.html">Sberbank - voc√™ tem um "pacote" para mim, mas eu n√£o aceito ...</a></li>
<li><a href="../pt433500/index.html">Rob√¥ de correio de Berkeley queimado devido √† falta de status do sistema de monitoramento</a></li>
<li><a href="../pt433502/index.html">Tecnologia de √°udio sem fio Bluetooth: qual √© o melhor?</a></li>
<li><a href="../pt433506/index.html">A UE procura o direito de reparar grandes aparelhos dom√©sticos</a></li>
<li><a href="../pt433508/index.html">O propriet√°rio da arquitetura MIPS pretende abrir seu conjunto de instru√ß√µes (ISA) em 2019</a></li>
<li><a href="../pt433510/index.html">Diferen√ßa transcultural nos jogos</a></li>
<li><a href="../pt433512/index.html">Teoria da felicidade. V√¥o vertiginoso de um sandu√≠che com manteiga</a></li>
<li><a href="../pt433514/index.html">Fa√ßa voc√™ mesmo o inferno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>