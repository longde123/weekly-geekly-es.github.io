<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛎️ 👲🏼 ☀️ Mengembangkan program Python yang sangat cepat 🚞 🧑🏾‍🤝‍🧑🏼 📂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembenci Python selalu mengatakan bahwa salah satu alasan mereka tidak ingin menggunakan bahasa ini adalah karena Python lambat. Tetapi fakta bahwa su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengembangkan program Python yang sangat cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483678/">  Pembenci Python selalu mengatakan bahwa salah satu alasan mereka tidak ingin menggunakan bahasa ini adalah karena Python lambat.  Tetapi fakta bahwa suatu program tertentu, terlepas dari bahasa pemrograman yang digunakan, dapat dianggap cepat atau lambat, sangat tergantung pada pengembang yang menulisnya, pada pengetahuannya dan pada kemampuan untuk membuat kode yang dioptimalkan dan berkinerja tinggi. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483678/"><img src="https://habrastorage.org/webt/mr/w_/bl/mrw_bl18nmxvnmxgkcrg6nyguoo.jpeg"></a> <br><br>  Penulis artikel, yang kami terbitkan hari ini, menawarkan untuk membuktikan bahwa mereka yang memanggil Python lambat adalah salah.  Dia ingin berbicara tentang cara meningkatkan kinerja program Python dan membuatnya sangat cepat. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pengukuran Waktu dan Pembuatan Profil</font> </h2><br>  Sebelum Anda mulai mengoptimalkan kode apa pun, Anda harus terlebih dahulu mengetahui bagian mana yang memperlambat seluruh program.  Kadang-kadang hambatan program mungkin terlihat jelas, tetapi jika programmer tidak tahu di mana itu, ia dapat memanfaatkan beberapa peluang untuk mengidentifikasinya. <br><br>  Di bawah ini adalah kode program, yang akan saya gunakan untuk keperluan demo.  Ini diambil dari dokumentasi Python.  Kode ini meningkatkan <code>e</code> menjadi kekuatan <code>x</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># slow_program.py from decimal import * def exp(x):    getcontext().prec += 2    i, lasts, s, fact, num = 0, 0, 1, 1, 1    while s != lasts:        lasts = s        i += 1        fact *= i        num *= x        s += num / fact    getcontext().prec -= 2    return +s exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Cara termudah untuk "profil" kode</font> </h2><br>  Untuk memulai, pertimbangkan cara paling sederhana untuk membuat profil kode Anda.  Jadi bisa dikatakan, "membuat profil untuk yang malas."  Itu terdiri dalam menggunakan perintah <code>time</code> Unix: <br><br><pre> <code class="python hljs">~ $ time python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py real <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">058</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">050</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0,<span class="hljs-number"><span class="hljs-number">008</span></span>s</code> </pre> <br>  Pembuatan profil semacam itu mungkin memberi programmer informasi yang berguna - jika ia perlu mengukur waktu pelaksanaan seluruh program.  Tetapi biasanya ini tidak cukup. <br><br><h2>  <font color="#3AC1EF">Metode Pembuatan Profil Yang Paling Akurat</font> </h2><br>  Di ujung lain dari spektrum metode kode profiling terletak alat <code>cProfile</code> , yang memberikan programmer, diakui, terlalu banyak informasi: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> -m cProfile -s time slow_program.py         <span class="hljs-number"><span class="hljs-number">1297</span></span> function calls (<span class="hljs-number"><span class="hljs-number">1272</span></span> primitive calls) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span> seconds   Ordered by: internal time   ncalls tottime percall cumtime percall filename:lineno(function)        <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">4</span></span>(exp)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.002</span></span>  <span class="hljs-number"><span class="hljs-number">0.002</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method _imp.create_dynamic}      <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.<span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method __new__ of type object at <span class="hljs-number"><span class="hljs-number">0x9d12c0</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">132</span></span>(__new__)       <span class="hljs-number"><span class="hljs-number">23</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> _weakrefset.py:<span class="hljs-number"><span class="hljs-number">36</span></span>(__init__)      <span class="hljs-number"><span class="hljs-number">245</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.getattr}        <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method marshal.loads}       <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">1233</span></span>(find_spec)      <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">196</span></span>(__subclasscheck__)       <span class="hljs-number"><span class="hljs-number">15</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method posix.stat}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.__build_class__}        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> __init__.py:<span class="hljs-number"><span class="hljs-number">357</span></span>(namedtuple)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">57</span></span>(_path_join)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">59</span></span>(&lt;listcomp&gt;)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">1</span></span>(&lt;module&gt;)</code> </pre> <br>  Di sini kita menjalankan skrip yang diselidiki menggunakan modul <code>cProfile</code> dan menggunakan argumen <code>time</code> .  Akibatnya, jalur output diurutkan berdasarkan waktu internal ( <code>cumtime</code> ).  Ini memberi kita banyak informasi.  Padahal, yang ditunjukkan di atas hanya sekitar 10% dari output <code>cProfile</code> . <br><br>  Setelah menganalisis data ini, kita dapat melihat bahwa fungsi <code>exp</code> adalah alasan untuk operasi yang lambat dari program (itu mengejutkan!).  Setelah itu, kita dapat melakukan pembuatan kode menggunakan alat yang lebih akurat. <br><br><h2>  <font color="#3AC1EF">Studi tentang indikator kinerja sementara dari fungsi tertentu</font> </h2><br>  Sekarang kita tahu tentang tempat program di mana kita perlu mengarahkan perhatian kita.  Oleh karena itu, kami dapat memutuskan untuk mempelajari fungsi lambat tanpa membuat profil kode program lainnya.  Untuk melakukan ini, Anda dapat menggunakan dekorator sederhana: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeit_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span>    @wraps(func)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        start = time.perf_counter() <span class="hljs-comment"><span class="hljs-comment">#       time.process_time()        func_return_val = func(*args, **kwargs)        end = time.perf_counter()        print('{0:&lt;10}.{1:&lt;8} : {2:&lt;8}'.format(func.__module__, func.__name__, end - start))        return func_return_val    return wrapper</span></span></code> </pre> <br>  Dekorator ini dapat diterapkan pada fungsi yang akan dieksplorasi: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@timeit_wrapper def exp(x):    ... print('{0:&lt;10} {1:&lt;8} {2:^8}'.format('module', 'function', 'time')) exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br>  Sekarang setelah memulai program kami akan menerima informasi berikut: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py module   function time __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.003267502994276583</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.038535295985639095</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">11.728486061969306</span></span></code> </pre> <br>  Di sini perlu diperhatikan kapan tepatnya kita berencana mengukur.  Paket yang sesuai memberi kami indikator seperti <code>time.perf_counter</code> dan <code>time.perf_counter</code> .  Perbedaan di antara mereka adalah <code>perf_counter</code> mengembalikan nilai absolut, yang mencakup waktu selama proses program Python tidak berjalan.  Ini berarti bahwa indikator ini dapat dipengaruhi oleh beban pada komputer yang dibuat oleh program lain.  <code>process_time</code> hanya mengembalikan waktu pengguna.  Itu tidak termasuk waktu sistem.  Ini hanya memberi kami informasi tentang waktu pelaksanaan proses kami. <br><br><h2>  <font color="#3AC1EF">Akselerasi kode</font> </h2><br>  Dan sekarang untuk bagian yang menyenangkan.  Mari kita bekerja mempercepat program.  Saya (sebagian besar) tidak akan menunjukkan semua jenis peretasan, trik, dan potongan kode misterius di sini yang secara ajaib menyelesaikan masalah kinerja.  Saya pada dasarnya ingin berbicara tentang ide dan strategi umum yang, jika digunakan, dapat berdampak besar pada kinerja.  Dalam beberapa kasus, kita berbicara tentang peningkatan 30% dalam kecepatan eksekusi kode. <br><br><h3>  <font color="#3AC1EF">▍Gunakan tipe data bawaan</font> </h3><br>  Menggunakan tipe data bawaan adalah pendekatan yang sangat jelas untuk mempercepat kode.  Tipe data bawaan sangat cepat, terutama jika Anda membandingkannya dengan tipe khusus seperti pohon atau daftar tertaut.  Intinya di sini adalah terutama bahwa mekanisme built-in dari bahasa diimplementasikan menggunakan C. Jika Anda menggambarkan sesuatu menggunakan Python, Anda tidak dapat mencapai tingkat kinerja yang sama. <br><br><h3>  <font color="#3AC1EF">▍Menerapkan caching (memoisasi) dengan lru_cache</font> </h3><br>  Caching adalah pendekatan populer untuk meningkatkan kinerja kode.  Saya sudah <a href="https://martinheinz.dev/blog/4">menulis</a> tentang dia, tetapi saya pikir ada baiknya menceritakan tentang dia di sini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-comment"><span class="hljs-comment">#   12   @functools.lru_cache(maxsize=12) def slow_func(x):    time.sleep(2) #       return x slow_func(1) # ...  2     slow_func(1) #    -   ! slow_func(3) # ...   2    </span></span></code> </pre> <br>  Fungsi di atas mensimulasikan perhitungan kompleks menggunakan <code>time.sleep</code> .  Ketika dipanggil untuk pertama kalinya dengan parameter <code>1</code> , ia menunggu 2 detik dan mengembalikan hasilnya hanya setelah itu.  Ketika dia dipanggil lagi dengan parameter yang sama, ternyata hasil karyanya sudah di-cache.  Tubuh fungsi dalam situasi ini tidak dieksekusi, dan hasilnya dikembalikan segera.  <a href="https://martinheinz.dev/blog/4">Di sini</a> Anda dapat menemukan contoh-contoh caching yang lebih dekat dengan kenyataan. <br><br><h3>  <font color="#3AC1EF">▍Gunakan variabel lokal</font> </h3><br>  Menerapkan variabel lokal, kami memperhitungkan kecepatan pencarian variabel di setiap cakupan.  Saya berbicara secara khusus tentang "setiap bidang visibilitas", karena di sini yang saya pikirkan bukan hanya perbandingan kecepatan kerja dengan variabel lokal dan global.  Bahkan, perbedaan dalam bekerja dengan variabel bahkan diamati, katakanlah, antara variabel lokal dalam suatu fungsi (kecepatan tertinggi), atribut tingkat kelas (misalnya, <code>self.name</code> , ini sudah lebih lambat), dan entitas impor global seperti <code>time.time</code> (paling lambat dari ketiga mekanisme ini). <br><br>  Anda dapat meningkatkan kinerja menggunakan pendekatan berikut untuk menetapkan nilai yang mungkin tampak benar-benar tidak perlu dan tidak berguna untuk orang yang tidak mendapat informasi: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  #1 class FastClass:    def do_stuff(self):        temp = self.value #           for i in range(10000):            ... #      `temp` #  #2 import random def fast_function():    r = random.random    for i in range(10000):        print(r()) #   `r()` ,     random.random()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Bungkus kode dalam fungsi</font> </h3><br>  Saran ini mungkin tampak bertentangan dengan akal sehat, karena ketika suatu fungsi dipanggil, beberapa data didorong ke stack dan sistem berada di bawah beban tambahan yang memproses operasi kembali dari fungsi.  Namun, rekomendasi ini terkait dengan yang sebelumnya.  Jika Anda hanya meletakkan semua kode Anda dalam satu file tanpa menuliskannya sebagai fungsi, itu akan berjalan jauh lebih lambat karena penggunaan variabel global.  Ini berarti bahwa kode dapat dipercepat hanya dengan membungkusnya di fungsi <code>main()</code> dan memanggilnya sekali: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    ... <span class="hljs-comment"><span class="hljs-comment">#  ,     main()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Jangan mengakses atribut</font> </h3><br>  Mekanisme lain yang dapat memperlambat program adalah operator dot ( <code>.</code> ), Yang digunakan untuk mengakses atribut objek.  Pernyataan ini meminta <code>__getattribute__</code> kamus menggunakan <code>__getattribute__</code> , yang <code>__getattribute__</code> tekanan ekstra pada sistem.  Bagaimana cara membatasi dampak kinerja fitur Python ini? <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : import re def slow_func():    for i in range(10000):        re.findall(regex, line) # ! # : from re import findall def fast_func():    for i in range(10000):        findall(regex, line) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Waspadai string</font> </h3><br>  Operasi string dapat sangat memperlambat program jika dijalankan dalam loop.  Secara khusus, kita berbicara tentang memformat string menggunakan <code>%s</code> dan <code>.format()</code> .  Apakah mungkin untuk menggantinya dengan sesuatu?  Jika Anda melihat <a href="https://twitter.com/raymondh/status/1205969258800275456">tweet</a> terbaru <a href="https://twitter.com/raymondh/status/1205969258800275456">dari</a> Raymond Hettinger, Anda dapat melihat bahwa satu-satunya mekanisme yang perlu digunakan dalam situasi seperti itu adalah f-line.  Ini adalah metode pemformatan string yang paling mudah dibaca, ringkas, dan tercepat.  Di sini, sesuai dengan tweet itu, adalah daftar metode yang dapat digunakan untuk bekerja dengan string - dari yang tercepat hingga yang paling lambat: <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{s}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{t}</span></span></span><span class="hljs-string">'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ! s + ' ' + t ' '.join((s, t)) '%s %s' % (s, t) '{} {}'.format(s, t) Template('$s $t').substitute(s=s, t=t) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Ketahui bahwa generator juga dapat bekerja dengan cepat</font> </h3><br>  Generator bukanlah mekanisme yang sifatnya cepat.  Faktanya adalah bahwa mereka diciptakan untuk melakukan perhitungan "malas", yang tidak menghemat waktu, tetapi memori.  Namun, menghemat memori dapat menyebabkan program berjalan lebih cepat.  Bagaimana ini mungkin?  Faktanya adalah bahwa ketika memproses kumpulan data besar tanpa menggunakan generator (iterators), data dapat menyebabkan limpahan cache L1 prosesor, yang secara signifikan akan memperlambat proses pencarian nilai dalam memori. <br><br>  Ketika datang ke kinerja, sangat penting untuk berusaha untuk memastikan bahwa prosesor dapat dengan cepat mengakses data yang diprosesnya, sehingga mereka sedekat mungkin dengannya.  Dan ini berarti bahwa data tersebut harus ditempatkan di cache prosesor.  Masalah ini dibahas dalam presentasi <a href="https://www.youtube.com/watch%3Fv%3DOSGv2VnC0go%26t%3D8m17s">ini</a> oleh Raymond Hettinger. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Aturan optimasi pertama adalah optimasi itu tidak perlu.  Tetapi jika Anda tidak dapat melakukannya tanpa optimasi, maka saya berharap tips yang saya bagikan akan membantu Anda dalam hal ini. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mendekati mengoptimalkan kinerja kode Python Anda? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483678/">https://habr.com/ru/post/id483678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483664/index.html">API Fungsional Keras di TensorFlow</a></li>
<li><a href="../id483666/index.html">Tentang Volodya dan ozonizer</a></li>
<li><a href="../id483670/index.html">Semua yang Anda ingin tahu tentang alamat MAC</a></li>
<li><a href="../id483674/index.html">Bagaimana jaringan syaraf biner bekerja, dan mengapa jaringan itu akan populer pada tahun 2020</a></li>
<li><a href="../id483676/index.html">Penilaian efektivitas dan biaya penerapan sistem analisis pemasaran end-to-end</a></li>
<li><a href="../id483680/index.html">Kelemahan pemrograman umum untuk dihindari</a></li>
<li><a href="../id483684/index.html">PHP Digest No. 171 (1 - 13 Januari 2020)</a></li>
<li><a href="../id483686/index.html">32 tips untuk pengembang web yang ingin tumbuh di atas dirinya pada tahun 2020</a></li>
<li><a href="../id483688/index.html">Tentang 30x Peningkatan Konkurensi di Node.js</a></li>
<li><a href="../id483698/index.html">Cara LoRaWAN Membantu Membangun Internet Modern of Things</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>