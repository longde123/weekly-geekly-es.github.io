<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 👩🏾‍🚒 🎭 Wenn Ihr Projekt "Theater" ist, verwenden Sie Schauspieler 👴🏽 👷 🏴󠁧󠁢󠁷󠁬󠁳󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt eine Geschichte über die Erfahrung mit Actor Model in einem interessanten Projekt zur Entwicklung eines automatischen Steuerungssystems für ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn Ihr Projekt "Theater" ist, verwenden Sie Schauspieler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452464/"><p>  Es gibt eine Geschichte über die Erfahrung mit Actor Model in einem interessanten Projekt zur Entwicklung eines automatischen Steuerungssystems für ein Theater.  Unten erzähle ich meine Eindrücke, nicht mehr als das. </p><a name="habracut"></a><br><p> Vor nicht allzu langer Zeit nahm ich an einer aufregenden Aufgabe teil: der Modernisierung des automatischen Steuerungssystems (ACS) für Lattenzüge, aber tatsächlich war es die Entwicklung eines neuen ACS. </p><br><p>  Ein modernes Theater (besonders wenn es ein großes ist) ist eine sehr komplexe Organisation.  Es gibt viele Menschen, verschiedene Mechanismen und Systeme.  Eines dieser Systeme ist ACS für die Handhabung des Hebens und Abstellens der Landschaft.  Moderne Aufführungen wie Opern und Ballette setzen Jahr für Jahr immer mehr technische Mittel ein.  Die Szenerie wird von den Regisseuren der Show aktiv genutzt und spielt sogar eine wichtige Rolle.  Es war faszinierend zu entdecken, was hinter den Vorhängen passiert, da gewöhnliche Zuschauer nur Aktionen vor Ort sehen können. </p><br><p>  Dies ist jedoch ein technischer Artikel, und ich möchte meine Erfahrungen mit der Verwendung des Akteurmodells zum Schreiben eines Steuerungssystems teilen.  Und teilen Sie meine Eindrücke von der Verwendung eines der Actor Frameworks für C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> . </p><br><p>  Warum haben wir diesen Rahmen gewählt?  Wir haben es uns schon lange angesehen.  Es gibt viele Artikel in russischer Sprache, und es gibt wunderbare Dokumentationen und viele Beispiele.  Das Projekt sieht aus wie ein ausgereiftes.  Ein kurzer Blick auf Beispiele hat gezeigt, dass die Entwickler von SObjectizer dieselben Begriffe verwenden (Status, Timer, Ereignisse usw.), und wir haben keine großen Probleme beim Studieren und Verwenden erwartet.  Und noch ein wichtiger Faktor: Das Team von SObjectizer ist hilfsbereit und immer bereit, uns zu helfen.  Also beschlossen wir es zu versuchen. </p><br><h1 id="what-were-doing">  Was machen wir </h1><br><p>  Lassen Sie uns über das Ziel unseres Projekts sprechen.  Das System der Lattenzüge hat 62 Latten (Metallrohre).  Jede Latte ist so lang wie die gesamte Bühne.  Sie werden parallel zu Abständen von 30-40 cm ausgehend von der Vorderkante der Bühne an Seilen aufgehängt.  Jede Latte kann angehoben oder abgesenkt werden.  Einige von ihnen werden in einer Show für Landschaften verwendet.  Die Szenerie ist auf einer Latte fixiert und wird während der Aufführung nach oben / unten bewegt.  Die Befehle von Bedienern initiieren die Bewegung.  Ein System des "Motor-Seil-Gegengewichts" ähnelt einem System, das in Aufzügen in Wohngebäuden verwendet wird.  Motoren werden außerhalb der Bühne platziert, damit die Zuschauer sie nicht sehen.  Alle Motoren sind in 8 Gruppen unterteilt, und jede Gruppe verfügt über 3 Frequenzumrichter (FC).  Es können höchstens drei Motoren gleichzeitig in einer Gruppe verwendet werden, von denen jeder mit einem separaten FC verbunden ist.  Wir haben also ein System mit 62 Motoren und 24 FCs, und wir müssen dieses System steuern. </p><br><p>  Unsere Aufgabe war es, eine Mensch-Maschine-Schnittstelle (HMI) zur Steuerung dieses Systems zu entwickeln und Steuerungsalgorithmen zu implementieren.  Das System umfasst drei Kontrollstationen.  Zwei davon befinden sich direkt über der Bühne und einer im Maschinenraum (diese Station wird von einem diensthabenden Elektriker benutzt).  Es gibt auch Steuerblöcke mit Steuerungen im Maschinenraum.  Diese Steuerungen führen Steuerbefehle aus, führen eine Pulsweitenmodulation (PWM) durch, schalten Motoren ein oder aus und steuern die Position von Latten.  Zwei Kontrollstationen über der Bühne verfügen über Displays, Systemeinheiten und Trackballs als Zeigegeräte.  Die Kontrollstationen sind über Ethernet verbunden.  Jede Kontrollstation ist über einen RS485-Kanal mit Steuerblöcken verbunden.  Beide Stationen über der Bühne können gleichzeitig zur Steuerung des Systems verwendet werden, es kann jedoch nur eine Station aktiv sein.  Die aktive Station wird von einem Bediener ausgewählt.  Die zweite Station ist passiv.  Bei der passiven Station ist der RS485-Kanal deaktiviert. </p><br><h1 id="why-actors">  Warum Schauspieler? </h1><br><p>  Aus Sicht der Algorithmen baut das System auf Ereignissen auf.  Daten von Sensoren, Aktionen des Bedieners, Ablauf von Timern ... Dies sind alles Beispiele für Ereignisse.  Das Akteurmodell eignet sich gut für solche Algorithmen: Akteure verarbeiten eingehende Ereignisse und bilden abhängig von ihrem aktuellen Status einige ausgehende Aktionen.  Diese Mechanik ist in SObjectizer sofort verfügbar. </p><br><p>  Die Grundprinzipien für solche Systeme sind: Akteure interagieren über asynchrone Nachrichten, Akteure haben Zustände und wechseln von einem Zustand in einen anderen, es werden nur Nachrichten behandelt, die für den aktuellen Zustand von Bedeutung sind. </p><br><p>  Es ist interessant, dass Schauspieler in SObjectizer von Arbeitsthreads entkoppelt sind.  Dies bedeutet, dass Sie Ihre Akteure zuerst implementieren und debuggen können und erst dann entscheiden, welcher Arbeitsthread für jeden Akteur verwendet wird.  Es gibt "Dispatcher", die verschiedene Thread-bezogene Richtlinien implementieren.  Beispielsweise gibt es einen Dispatcher, der für jeden Akteur einen separaten Arbeitsthread bereitstellt.  Es gibt einen Thread-Pool-Dispatcher, der einen Pool von Worker-Threads mit fester Größe bereitstellt.  Es gibt einen Dispatcher, der alle Akteure auf demselben Thread ausführt. </p><br><p>  Die Anwesenheit von Dispatchern bietet eine sehr flexible Möglichkeit, ein Akteursystem auf unsere Bedürfnisse abzustimmen.  Wir können einige Akteure gruppieren, um an demselben Kontext zu arbeiten.  Wir können den Dispatcher-Typ durch nur eine einzige Codezeile ändern.  Die Entwickler von SObjectizer sagen, dass das Schreiben eines benutzerdefinierten Dispatchers keine komplexe Aufgabe ist.  In diesem Projekt musste jedoch kein eigener Dispatcher geschrieben werden.  Alles, was wir brauchten, wurde in SObjectizer gefunden. </p><br><p>  Ein weiteres interessantes Merkmal ist die Zusammenarbeit von Schauspielern.  Eine Kooperation ist eine Gruppe von Akteuren, die nur dann existieren können, wenn alle Akteure erfolgreich gestartet sind.  Eine Zusammenarbeit kann nicht begonnen werden, wenn mindestens einer ihrer Akteure nicht begonnen hat.  Es scheint, dass es eine Analogie zwischen den Kooperationen von SObjectizer und Pods von Kubernetes gibt, aber es scheint auch, dass die Kooperationen von SObjectizer früher aufgetreten sind ... </p><br><p>  Wenn ein Akteur erstellt wird, wird er zur Zusammenarbeit hinzugefügt (die Zusammenarbeit kann nur einen Akteur enthalten) und ist an einen Dispatcher gebunden.  Es ist einfach, Kooperationen und Akteure dynamisch zu erstellen, und die Entwickler von SObjectizer sagen, dass dies eine ziemlich billige Operation ist. </p><br><p>  Alle Akteure interagieren über "Message Boxes" (mbox) miteinander.  Es ist ein weiteres interessantes und leistungsstarkes Konzept von SObjectizer.  Es bietet eine flexible Möglichkeit der Nachrichtenverarbeitung. </p><br><p>  Zunächst kann sich hinter einer mbox mehr als ein Nachrichtenempfänger befinden.  Es ist sehr hilfreich.  Beispielsweise kann es eine mbox geben, die von Sensoren zum Veröffentlichen neuer Daten verwendet wird.  Akteure können Abonnements für diese mbox erstellen, und abonnierte Akteure erhalten die gewünschten Daten.  Dies ermöglicht das Arbeiten auf "Veröffentlichen / Abonnieren" -Methode. </p><br><p>  Zweitens haben die Entwickler des SObjectizers die Möglichkeit einer benutzerdefinierten Mbox-Erstellung ins Auge gefasst.  Es ist relativ einfach, eine benutzerdefinierte Mbox mit spezieller Verarbeitung eingehender Nachrichten zu erstellen (z. B. Filtern oder Verteilen auf mehrere Abonnenten basierend auf dem Inhalt der Nachricht). </p><br><p>  Es gibt auch eine persönliche Mbox für jeden Schauspieler, und Schauspieler können in Nachrichten an andere Akteure einen Verweis auf diese Mbox übergeben (wodurch direkt auf einen bestimmten Schauspieler geantwortet werden kann). </p><br><p>  In unserem Projekt haben wir alle kontrollierten Objekte in acht Gruppen aufgeteilt (eine Gruppe für jede Kontrollbox).  Für jede Gruppe wurden drei Worker-Threads erstellt (da nur drei Engines gleichzeitig arbeiten können).  Dies ermöglichte uns die Unabhängigkeit zwischen Motorgruppen.  Es erlaubte auch, asynchron mit Engines innerhalb jeder Gruppe zu arbeiten. </p><br><p>  Es muss erwähnt werden, dass SObjectizer-5 keine Mechanismen für Interprozess- oder / und Netzwerkinteraktion besitzt.  Dies ist eine bewusste Entscheidung der Entwickler von SObjectizer.  Sie wollten SObjectizer so leicht wie möglich machen.  Darüber hinaus bestand die transparente Unterstützung für das Netzwerk in einigen früheren Versionen von SObjectizer, wurde jedoch entfernt.  Es hat uns nicht gestört, da ein Mechanismus für die Vernetzung stark von einer Aufgabe, den verwendeten Protokollen und anderen Bedingungen abhängt.  Es gibt keine einheitliche universelle Lösung für alle Fälle. </p><br><p>  In unserem Fall haben wir unsere alte Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libuniset2</a> für die Netzwerk- und Interprozesskommunikation verwendet.  Infolgedessen unterstützt libuniset2 die Kommunikation mit Sensoren und Steuerblöcken, und SObjectizer unterstützt Akteure und Interaktionen zwischen Akteuren innerhalb eines einzelnen Prozesses. </p><br><p>  Wie ich bereits sagte, gibt es 62 Motoren.  Jeder Motor kann an einen FC (Frequenzumrichter) angeschlossen werden;  Für die entsprechende Latte kann eine Zielkoordinate angegeben werden.  Die Geschwindigkeit der Bewegung der Latte kann ebenfalls angegeben werden.  Darüber hinaus hat jeder Motor die folgenden Zustände: </p><br><ul><li>  bereit zu arbeiten; </li><li>  verbunden; </li><li>  arbeiten; </li><li>  Fehlfunktion; </li><li>  Verbinden (ein Übergangszustand); </li><li>  Trennen (ein Übergangszustand); </li></ul><br><p> Jede Engine wird im System durch einen Akteur dargestellt, der den Übergang zwischen Zuständen implementiert, Daten von Sensoren verarbeitet und Befehle ausgibt.  Es ist nicht schwer, in SObjectizer einen Akteur zu erstellen: Erben Sie einfach Ihre Klasse vom Typ <code>so_5::agent_t</code> .  Das erste Argument des Konstruktors des Akteurs sollte vom Typ <code>context_t</code> . Alle anderen Argumente können nach Wunsch eines Entwicklers definiert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Ich werde die detaillierte Beschreibung der Klassen und Methoden nicht anzeigen, da es sich nicht um ein Tutorial handelt.  Ich möchte nur zeigen, wie einfach das alles in SObjectizer geht (in wenigen Zeilen buchstäblich).  Ich möchte Sie daran erinnern, dass SObjectizer eine hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> und viele Beispiele enthält. </p><br><h1 id="what-is-the-state-of-an-actor-what-are-we-talking-about">  Was ist der "Zustand" eines Schauspielers?  Worüber reden wir? </h1><br><p>  Die Verwendung von Zuständen und der Übergang zwischen ihnen ist ein "natives Thema" für Steuerungssysteme.  Dieses Konzept ist sehr gut für die Ereignisbehandlung.  Dieses Konzept wird in SObjectizer auf API-Ebene unterstützt.  Zustände werden innerhalb der Klasse des Schauspielers deklariert: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre> <br><p>  und dann werden Event-Handler für jeden Zustand definiert.  Manchmal ist es notwendig, beim Betreten oder Verlassen eines Staates etwas zu tun.  Dies wird auch in SObjectizer über die Handler on_enter / on_exit unterstützt.  Es scheint, dass die Entwickler von SObjectizer Hintergrundwissen in der Entwicklung von Steuerungssystemen haben. </p><br><h1 id="event-handlers">  Ereignishandler </h1><br><p>  Ein Ereignishandler ist ein Ort, an dem Ihre Anwendungslogik implementiert ist.  Wie bereits erwähnt, wird ein Abonnement für eine bestimmte mbox und einen bestimmten Status erstellt.  Wenn ein Akteur keine explizit angegebenen Zustände hat, befindet er sich in einem speziellen "Standardzustand". </p><br><p>  Verschiedene Handler können für dasselbe Ereignis in verschiedenen Zuständen definiert werden.  Wenn Sie für ein Ereignis keinen Handler definieren, wird dieses Ereignis ignoriert (ein Schauspieler weiß nichts davon). </p><br><p>  Es gibt eine einfache Syntax zum Definieren von Ereignishandlern.  Sie geben eine Methode an, und es müssen keine zusätzlichen Typen oder Vorlagenparameter angegeben werden.  Zum Beispiel: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Dies ist ein Beispiel für ein Abonnement von Ereignissen aus einer bestimmten mbox im Status st_base.  Es ist erwähnenswert, dass st_base ein Basiszustand für einige andere Zustände ist und dass das Abonnement von abgeleiteten Zuständen geerbt wird.  Dieser Ansatz ermöglicht das Kopieren und Einfügen für ähnliche Ereignishandler in verschiedenen Zuständen.  Der geerbte Ereignishandler kann jedoch für einen bestimmten Status neu definiert oder ein Ereignis vollständig deaktiviert ("unterdrückt") werden. </p><br><p>  Eine andere Möglichkeit, Ereignishandler zu definieren, ist die Verwendung von Lambda-Funktionen.  Dies ist eine sehr bequeme Methode, da Ereignishandler häufig nur ein oder zwei Codezeilen enthalten: Senden von etwas an einen Ort oder Statusänderung: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Diese Syntax sieht am Anfang komplex aus, wird aber erst nach ein paar Tagen aktiver Codierung bekannt und Sie beginnen sie sogar zu mögen.  Dies liegt daran, dass die gesamte Logik eines Schauspielers präzise und auf einem Bildschirm platziert werden kann.  In dem oben gezeigten Beispiel gibt es Übergänge von st_disconnected zu st_off oder st_protection.  Dieser Code ist leicht zu lesen. </p><br><p>  Übrigens gibt es für einfache Fälle, in denen nur ein Zustandsübergang erforderlich ist, eine spezielle Syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre> <br><h1 id="the-control">  Die Kontrolle </h1><br><p>  Wie ist die Kontrolle organisiert?  Wie oben erwähnt, gibt es zwei Kontrollstationen zur Steuerung der Bewegung von Latten.  Jede Kontrollstation verfügt über ein Display, ein Zeigegerät (Trackball) und einen Geschwindigkeitssetzer (und wir zählen keinen Computer in der Station und kein zusätzliches Zubehör). </p><br><p>  Es gibt zwei Steuermodi: manuell und "Szenariomodus".  "Szenariomodus" wird später erläutert, und jetzt sprechen wir über den manuellen Modus.  In diesem Modus wählt ein Bediener eine Latte aus, bereitet sie für die Bewegung vor (verbindet den Motor mit einem FC), setzt die Zielmarke für die Latte und wenn die Geschwindigkeit über Null eingestellt ist, beginnt sich die Latte zu bewegen. </p><br><p>  Der Geschwindigkeitssetzer ist ein physisches Zubehör in Form eines "Potentiometers mit Griff", aber es wird auch ein virtuelles auf dem Display der Station angezeigt.  Je mehr gedreht wird, desto höher ist die Bewegungsgeschwindigkeit.  Die Höchstgeschwindigkeit ist auf 1,5 Meter pro Sekunde begrenzt.  Der Geschwindigkeitssetzer ist einer für alle Latten.  Dies bedeutet, dass sich alle ausgewählten Latten mit der gleichen Geschwindigkeit bewegen.  Latten können sich in entgegengesetzte Richtungen bewegen (dies hängt von der Auswahl des Bedieners ab).  Es ist offensichtlich, dass es für einen Menschen schwierig ist, mehr als ein paar Latten zu kontrollieren.  Aus diesem Grund werden im manuellen Modus nur kleine Gruppen von Latten behandelt.  Bediener können Latten gleichzeitig von zwei Kontrollstationen aus steuern.  Es gibt also für jede Station einen eigenen Geschwindigkeitsregler. </p><br><p>  Aus Sicht der Implementierung gibt es im manuellen Modus keine spezifische Logik.  Ein "connect engine" -Befehl geht von der grafischen Oberfläche aus, wird in eine entsprechende Nachricht an einen Akteur umgewandelt und dann von diesem Akteur verarbeitet.  Der Akteur wechselt vom Zustand "Aus" in den Zustand "Verbinden" und dann in den Zustand "Verbunden".  Ähnliches passiert mit Befehlen zum Positionieren einer Latte und zum Einstellen der Bewegungsgeschwindigkeit.  Alle diese Befehle werden in Form von Nachrichten an einen Akteur übergeben.  Es ist jedoch erwähnenswert, dass "grafische Oberfläche" und "Steuerungsprozess" separate Prozesse sind und libuniset2 für IPC verwendet wird. </p><br><h1 id="the-scenario-mode-are-there-actors-again">  Der Szenariomodus (gibt es wieder Schauspieler?) </h1><br><p>  In der Praxis wird der manuelle Modus nur für sehr einfache Fälle oder während der Proben verwendet.  Der Hauptsteuermodus ist "Szenariomodus".  In diesem Modus wird jede Latte gemäß den Szenarioeinstellungen mit einer bestimmten Geschwindigkeit an eine bestimmte Position bewegt.  In diesem Modus stehen einem Bediener zwei einfache Befehle zur Verfügung: </p><br><ul><li>  vorbereiten (eine Gruppe von Motoren wird an FC angeschlossen); </li><li>  go (Bewegung der Gruppe beginnt). </li></ul><br><p>  Das gesamte Szenario ist in "Agenden" unterteilt.  Eine "Agenda" beschreibt eine einzelne Bewegung einer Gruppe von Latten.  Dies bedeutet, dass eine "Agenda" einige Latten enthält und Zielziele und Geschwindigkeiten für diese enthält.  In Wirklichkeit besteht ein Szenario aus Handlungen, Handlungen bestehen aus Bildern, Bilder bestehen aus Agenden und die Agenda besteht aus Zielen für Latten.  Aus Sicht der Steuerung spielt dies jedoch keine Rolle, da nur die Tagesordnungen die genauen Parameter der Bewegung der Latte enthalten. </p><br><p>  Das Actor Model passt perfekt zu diesem Fall.  Wir haben einen "Szenario-Spieler" entwickelt, der eine Gruppe spezieller Schauspieler hervorbringt und sie startet.  Wir haben zwei Arten von Akteuren entwickelt: Vollstrecker-Akteure (sie steuern die Bewegung von Latten) und Koordinator-Akteure (sie verteilen Aufgaben zwischen Vollstreckern).  Executoren werden nach Bedarf erstellt: Wenn keine freien Executoren vorhanden sind, wird ein neuer Executor erstellt.  Der Koordinator verwaltet den Pool der verfügbaren Ausführenden.  Infolgedessen sieht das Steuerelement ungefähr so ​​aus: </p><br><ul><li>  ein Bediener lädt ein Szenario; </li><li>  "scrollt" es bis zur erforderlichen Tagesordnung; </li><li>  drückt die Taste "Vorbereiten" zum richtigen Zeitpunkt.  In diesem Moment wird eine Nachricht an einen Koordinator gesendet.  Diese Nachricht enthält Daten für jede Latte von der Tagesordnung. </li><li>  Der Koordinator überprüft seinen Pool von Testamentsvollstreckern und verteilt die Aufgaben auf freie Testamentsvollstrecker (bei Bedarf werden neue Testamentsvollstrecker erstellt). </li><li>  Jeder Executor empfängt eine Aufgabe und führt Vorbereitungsaktionen aus (verbindet eine Engine mit einem FC und wartet dann auf den Befehl "go"). </li><li>  Der Bediener drückt zum richtigen Zeitpunkt die Taste "Los". </li><li>  Der Befehl "go" geht an den Koordinator und verteilt den Befehl auf alle derzeit verwendeten Executoren. </li></ul><br><p>  Es gibt einige zusätzliche Parameter in den Tagesordnungen.  Wie "Bewegung erst nach N Sekunden Verzögerung starten" oder "Bewegung nur nach einem zusätzlichen Befehl eines Bedieners starten".  Aus diesem Grund ist die Liste der Zustände für einen Testamentsvollstrecker ziemlich lang: "Bereit für den nächsten Befehl", "Bereit für die Bewegung", "Verzögerung der Bewegung", "Warten auf den Bedienerbefehl", "Bewegen", "Abgeschlossen", "Misserfolg". </p><br><p>  Wenn eine Latte die Zielmarke erfolgreich erreicht hat (oder ein Fehler vorliegt), meldet der Executor dem Koordinator den Abschluss der Aufgabe.  Der Koordinator antwortet mit einem Befehl zum Ausschalten der Engine (wenn die Latte nicht mehr an der Agenda teilnimmt) oder sendet eine neue Aufgabe an den Executor.  Der Executor schaltet entweder die Engine aus und wechselt in den Wartezustand oder beginnt mit der Verarbeitung des neuen Befehls. </p><br><p>  Da SObjectizer über eine sehr durchdachte und bequeme API für die Arbeit mit Status verfügt, erwies sich der Implementierungscode als recht präzise.  Zum Beispiel wird eine Verzögerung vor der Bewegung nur durch eine Codezeile beschrieben: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre> <br><p>  Die Methode <code>time_limit</code> gibt an, wie lange im Status <code>st_moving</code> soll und welcher Status dann aktiviert werden soll (in diesem Beispiel <code>st_moving</code> ). </p><br><h1 id="protection-actors">  Schutzakteure </h1><br><p>  Natürlich können Fehler auftreten.  Es gibt Anforderungen, um diese Fehler korrekt zu behandeln.  Schauspieler werden auch für solche Aufgaben verwendet.  Schauen wir uns einige Beispiele an: </p><br><ul><li>  Überstromschutz; </li><li>  Schutz vor Fehlfunktionen des Sensors; </li><li>  Schutz vor Bewegung in die entgegengesetzte Richtung (dies kann passieren, wenn mit Sensoren oder Aktoren etwas nicht stimmt); </li><li>  Schutz vor spontanen Bewegungen (ohne Befehl); </li><li>  Befehlsausführungskontrolle (die Bewegung einer Latte sollte überprüft werden). </li></ul><br><p>  Wir können sehen, dass all diese Fälle autark sind, aber sie sollten gleichzeitig gemeinsam kontrolliert werden.  Dies bedeutet, dass ein Fehler auftreten kann.  Aber jede Prüfung hat ihre Logik: Manchmal muss eine Zeitüberschreitung überprüft werden, manchmal müssen einige vorherige Werte eines Sensors analysiert werden.  Aus diesem Grund wird der Schutz in Form kleiner Akteure umgesetzt.  Diese Akteure werden zur Zusammenarbeit mit dem Hauptakteur hinzugefügt, der die Steuerlogik implementiert.  Dieser Ansatz ermöglicht das einfache Hinzufügen neuer Schutzfälle: Fügen Sie der Zusammenarbeit einfach einen weiteren Schutzakteur hinzu.  Der Code eines solchen Akteurs ist normalerweise kurz und leicht zu verstehen, da er nur eine Funktion implementiert. </p><br><p>  Beschützer haben auch mehrere Staaten.  Normalerweise werden sie eingeschaltet, wenn ein Motor eingeschaltet wird oder wenn eine Latte ihre Bewegung beginnt.  Wenn ein Protektor einen Fehler / eine Fehlfunktion feststellt, veröffentlicht er eine Benachrichtigung (mit Schutzcode und einigen zusätzlichen Details).  Der Hauptakteur reagiert auf diese Benachrichtigung und führt die erforderlichen Aktionen aus (z. B. Abstellen des Motors und Umschalten in den geschützten Zustand). </p><br><h1 id="as-the-conclusion">  Als Fazit ... </h1><br><p>  ... dieser Artikel ist natürlich kein Durchbruch.  Das Akteurmodell wird seit geraumer Zeit in mehreren verschiedenen Systemen eingesetzt.  Aber es war meine erste Erfahrung mit dem Actor Model zum Aufbau eines automatischen Steuerungssystems in einem eher kleinen Projekt.  Und diese Erfahrung erwies sich als recht erfolgreich.  Ich hoffe, ich habe gezeigt, dass Schauspieler gut zu Steuerungsalgorithmen passen: Es gibt buchstäblich überall Orte für Schauspieler. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir</a> hatten in früheren Projekten etwas Ähnliches implementiert (ich meine Zustände, Nachrichtenaustausch, Verwaltung von Arbeitsthreads usw.), aber es war kein einheitlicher Ansatz.  Durch die Verwendung von SObjectizer haben wir ein kleines, leichtes Tool erhalten, das viele Probleme löst.  Wir müssen keine Synchronisationsmechanismen auf niedriger Ebene (wie Mutexe) mehr (explizit) verwenden, es gibt keine manuelle Thread-Verwaltung, keine handgeschriebenen Zustandsdiagramme mehr.  All dies wird vom Framework bereitgestellt, logisch verbunden und in Form einer praktischen API ausgedrückt, aber Sie verlieren nicht die Kontrolle über Details.  Es war also eine aufregende Erfahrung.  Wenn Sie immer noch Zweifel haben, empfehle ich Ihnen, sich insbesondere das Actor Model und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer anzusehen</a> .  Es hinterlässt positive Emotionen. </p><br><p>  Das Actor Model funktioniert wirklich!  Besonders im Theater. </p><br><p>  Originalartikel in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischer Sprache</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452464/">https://habr.com/ru/post/de452464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452454/index.html">Anmelden bei Azure DevOps mit Ihren GitHub-Anmeldeinformationen</a></li>
<li><a href="../de452456/index.html">Mit Microsoft Kaizala kann Indian Railways seine drei Millionen Mitarbeiter mit Gesundheitsdiensten verbinden</a></li>
<li><a href="../de452458/index.html">Beobachten Sie Hunde im wirklichen Leben oder schwerwiegende Schwachstellen in ACS</a></li>
<li><a href="../de452460/index.html">Einführung in Windows Terminal</a></li>
<li><a href="../de452462/index.html">Über OOP</a></li>
<li><a href="../de452466/index.html">Braille-Tastatur</a></li>
<li><a href="../de452468/index.html">"Wenn Sie jemanden töten müssen, dann sind Sie an die Adresse gekommen"</a></li>
<li><a href="../de452474/index.html">Wavelet-Analyse. Teil 2</a></li>
<li><a href="../de452478/index.html">Erstellen von Tabellen im Figma-Designsystem und Implementierung im Storybook (React)</a></li>
<li><a href="../de452480/index.html">Phoenix LiveView: Wenn Sie kein JavaScript mehr benötigen *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>