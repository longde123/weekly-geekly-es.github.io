<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüç≥ üë©üèæ‚Äçüöí üé≠ Wenn Ihr Projekt "Theater" ist, verwenden Sie Schauspieler üë¥üèΩ üë∑ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt eine Geschichte √ºber die Erfahrung mit Actor Model in einem interessanten Projekt zur Entwicklung eines automatischen Steuerungssystems f√ºr ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn Ihr Projekt "Theater" ist, verwenden Sie Schauspieler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452464/"><p>  Es gibt eine Geschichte √ºber die Erfahrung mit Actor Model in einem interessanten Projekt zur Entwicklung eines automatischen Steuerungssystems f√ºr ein Theater.  Unten erz√§hle ich meine Eindr√ºcke, nicht mehr als das. </p><a name="habracut"></a><br><p> Vor nicht allzu langer Zeit nahm ich an einer aufregenden Aufgabe teil: der Modernisierung des automatischen Steuerungssystems (ACS) f√ºr Lattenz√ºge, aber tats√§chlich war es die Entwicklung eines neuen ACS. </p><br><p>  Ein modernes Theater (besonders wenn es ein gro√ües ist) ist eine sehr komplexe Organisation.  Es gibt viele Menschen, verschiedene Mechanismen und Systeme.  Eines dieser Systeme ist ACS f√ºr die Handhabung des Hebens und Abstellens der Landschaft.  Moderne Auff√ºhrungen wie Opern und Ballette setzen Jahr f√ºr Jahr immer mehr technische Mittel ein.  Die Szenerie wird von den Regisseuren der Show aktiv genutzt und spielt sogar eine wichtige Rolle.  Es war faszinierend zu entdecken, was hinter den Vorh√§ngen passiert, da gew√∂hnliche Zuschauer nur Aktionen vor Ort sehen k√∂nnen. </p><br><p>  Dies ist jedoch ein technischer Artikel, und ich m√∂chte meine Erfahrungen mit der Verwendung des Akteurmodells zum Schreiben eines Steuerungssystems teilen.  Und teilen Sie meine Eindr√ºcke von der Verwendung eines der Actor Frameworks f√ºr C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer</a> . </p><br><p>  Warum haben wir diesen Rahmen gew√§hlt?  Wir haben es uns schon lange angesehen.  Es gibt viele Artikel in russischer Sprache, und es gibt wunderbare Dokumentationen und viele Beispiele.  Das Projekt sieht aus wie ein ausgereiftes.  Ein kurzer Blick auf Beispiele hat gezeigt, dass die Entwickler von SObjectizer dieselben Begriffe verwenden (Status, Timer, Ereignisse usw.), und wir haben keine gro√üen Probleme beim Studieren und Verwenden erwartet.  Und noch ein wichtiger Faktor: Das Team von SObjectizer ist hilfsbereit und immer bereit, uns zu helfen.  Also beschlossen wir es zu versuchen. </p><br><h1 id="what-were-doing">  Was machen wir </h1><br><p>  Lassen Sie uns √ºber das Ziel unseres Projekts sprechen.  Das System der Lattenz√ºge hat 62 Latten (Metallrohre).  Jede Latte ist so lang wie die gesamte B√ºhne.  Sie werden parallel zu Abst√§nden von 30-40 cm ausgehend von der Vorderkante der B√ºhne an Seilen aufgeh√§ngt.  Jede Latte kann angehoben oder abgesenkt werden.  Einige von ihnen werden in einer Show f√ºr Landschaften verwendet.  Die Szenerie ist auf einer Latte fixiert und wird w√§hrend der Auff√ºhrung nach oben / unten bewegt.  Die Befehle von Bedienern initiieren die Bewegung.  Ein System des "Motor-Seil-Gegengewichts" √§hnelt einem System, das in Aufz√ºgen in Wohngeb√§uden verwendet wird.  Motoren werden au√üerhalb der B√ºhne platziert, damit die Zuschauer sie nicht sehen.  Alle Motoren sind in 8 Gruppen unterteilt, und jede Gruppe verf√ºgt √ºber 3 Frequenzumrichter (FC).  Es k√∂nnen h√∂chstens drei Motoren gleichzeitig in einer Gruppe verwendet werden, von denen jeder mit einem separaten FC verbunden ist.  Wir haben also ein System mit 62 Motoren und 24 FCs, und wir m√ºssen dieses System steuern. </p><br><p>  Unsere Aufgabe war es, eine Mensch-Maschine-Schnittstelle (HMI) zur Steuerung dieses Systems zu entwickeln und Steuerungsalgorithmen zu implementieren.  Das System umfasst drei Kontrollstationen.  Zwei davon befinden sich direkt √ºber der B√ºhne und einer im Maschinenraum (diese Station wird von einem diensthabenden Elektriker benutzt).  Es gibt auch Steuerbl√∂cke mit Steuerungen im Maschinenraum.  Diese Steuerungen f√ºhren Steuerbefehle aus, f√ºhren eine Pulsweitenmodulation (PWM) durch, schalten Motoren ein oder aus und steuern die Position von Latten.  Zwei Kontrollstationen √ºber der B√ºhne verf√ºgen √ºber Displays, Systemeinheiten und Trackballs als Zeigeger√§te.  Die Kontrollstationen sind √ºber Ethernet verbunden.  Jede Kontrollstation ist √ºber einen RS485-Kanal mit Steuerbl√∂cken verbunden.  Beide Stationen √ºber der B√ºhne k√∂nnen gleichzeitig zur Steuerung des Systems verwendet werden, es kann jedoch nur eine Station aktiv sein.  Die aktive Station wird von einem Bediener ausgew√§hlt.  Die zweite Station ist passiv.  Bei der passiven Station ist der RS485-Kanal deaktiviert. </p><br><h1 id="why-actors">  Warum Schauspieler? </h1><br><p>  Aus Sicht der Algorithmen baut das System auf Ereignissen auf.  Daten von Sensoren, Aktionen des Bedieners, Ablauf von Timern ... Dies sind alles Beispiele f√ºr Ereignisse.  Das Akteurmodell eignet sich gut f√ºr solche Algorithmen: Akteure verarbeiten eingehende Ereignisse und bilden abh√§ngig von ihrem aktuellen Status einige ausgehende Aktionen.  Diese Mechanik ist in SObjectizer sofort verf√ºgbar. </p><br><p>  Die Grundprinzipien f√ºr solche Systeme sind: Akteure interagieren √ºber asynchrone Nachrichten, Akteure haben Zust√§nde und wechseln von einem Zustand in einen anderen, es werden nur Nachrichten behandelt, die f√ºr den aktuellen Zustand von Bedeutung sind. </p><br><p>  Es ist interessant, dass Schauspieler in SObjectizer von Arbeitsthreads entkoppelt sind.  Dies bedeutet, dass Sie Ihre Akteure zuerst implementieren und debuggen k√∂nnen und erst dann entscheiden, welcher Arbeitsthread f√ºr jeden Akteur verwendet wird.  Es gibt "Dispatcher", die verschiedene Thread-bezogene Richtlinien implementieren.  Beispielsweise gibt es einen Dispatcher, der f√ºr jeden Akteur einen separaten Arbeitsthread bereitstellt.  Es gibt einen Thread-Pool-Dispatcher, der einen Pool von Worker-Threads mit fester Gr√∂√üe bereitstellt.  Es gibt einen Dispatcher, der alle Akteure auf demselben Thread ausf√ºhrt. </p><br><p>  Die Anwesenheit von Dispatchern bietet eine sehr flexible M√∂glichkeit, ein Akteursystem auf unsere Bed√ºrfnisse abzustimmen.  Wir k√∂nnen einige Akteure gruppieren, um an demselben Kontext zu arbeiten.  Wir k√∂nnen den Dispatcher-Typ durch nur eine einzige Codezeile √§ndern.  Die Entwickler von SObjectizer sagen, dass das Schreiben eines benutzerdefinierten Dispatchers keine komplexe Aufgabe ist.  In diesem Projekt musste jedoch kein eigener Dispatcher geschrieben werden.  Alles, was wir brauchten, wurde in SObjectizer gefunden. </p><br><p>  Ein weiteres interessantes Merkmal ist die Zusammenarbeit von Schauspielern.  Eine Kooperation ist eine Gruppe von Akteuren, die nur dann existieren k√∂nnen, wenn alle Akteure erfolgreich gestartet sind.  Eine Zusammenarbeit kann nicht begonnen werden, wenn mindestens einer ihrer Akteure nicht begonnen hat.  Es scheint, dass es eine Analogie zwischen den Kooperationen von SObjectizer und Pods von Kubernetes gibt, aber es scheint auch, dass die Kooperationen von SObjectizer fr√ºher aufgetreten sind ... </p><br><p>  Wenn ein Akteur erstellt wird, wird er zur Zusammenarbeit hinzugef√ºgt (die Zusammenarbeit kann nur einen Akteur enthalten) und ist an einen Dispatcher gebunden.  Es ist einfach, Kooperationen und Akteure dynamisch zu erstellen, und die Entwickler von SObjectizer sagen, dass dies eine ziemlich billige Operation ist. </p><br><p>  Alle Akteure interagieren √ºber "Message Boxes" (mbox) miteinander.  Es ist ein weiteres interessantes und leistungsstarkes Konzept von SObjectizer.  Es bietet eine flexible M√∂glichkeit der Nachrichtenverarbeitung. </p><br><p>  Zun√§chst kann sich hinter einer mbox mehr als ein Nachrichtenempf√§nger befinden.  Es ist sehr hilfreich.  Beispielsweise kann es eine mbox geben, die von Sensoren zum Ver√∂ffentlichen neuer Daten verwendet wird.  Akteure k√∂nnen Abonnements f√ºr diese mbox erstellen, und abonnierte Akteure erhalten die gew√ºnschten Daten.  Dies erm√∂glicht das Arbeiten auf "Ver√∂ffentlichen / Abonnieren" -Methode. </p><br><p>  Zweitens haben die Entwickler des SObjectizers die M√∂glichkeit einer benutzerdefinierten Mbox-Erstellung ins Auge gefasst.  Es ist relativ einfach, eine benutzerdefinierte Mbox mit spezieller Verarbeitung eingehender Nachrichten zu erstellen (z. B. Filtern oder Verteilen auf mehrere Abonnenten basierend auf dem Inhalt der Nachricht). </p><br><p>  Es gibt auch eine pers√∂nliche Mbox f√ºr jeden Schauspieler, und Schauspieler k√∂nnen in Nachrichten an andere Akteure einen Verweis auf diese Mbox √ºbergeben (wodurch direkt auf einen bestimmten Schauspieler geantwortet werden kann). </p><br><p>  In unserem Projekt haben wir alle kontrollierten Objekte in acht Gruppen aufgeteilt (eine Gruppe f√ºr jede Kontrollbox).  F√ºr jede Gruppe wurden drei Worker-Threads erstellt (da nur drei Engines gleichzeitig arbeiten k√∂nnen).  Dies erm√∂glichte uns die Unabh√§ngigkeit zwischen Motorgruppen.  Es erlaubte auch, asynchron mit Engines innerhalb jeder Gruppe zu arbeiten. </p><br><p>  Es muss erw√§hnt werden, dass SObjectizer-5 keine Mechanismen f√ºr Interprozess- oder / und Netzwerkinteraktion besitzt.  Dies ist eine bewusste Entscheidung der Entwickler von SObjectizer.  Sie wollten SObjectizer so leicht wie m√∂glich machen.  Dar√ºber hinaus bestand die transparente Unterst√ºtzung f√ºr das Netzwerk in einigen fr√ºheren Versionen von SObjectizer, wurde jedoch entfernt.  Es hat uns nicht gest√∂rt, da ein Mechanismus f√ºr die Vernetzung stark von einer Aufgabe, den verwendeten Protokollen und anderen Bedingungen abh√§ngt.  Es gibt keine einheitliche universelle L√∂sung f√ºr alle F√§lle. </p><br><p>  In unserem Fall haben wir unsere alte Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libuniset2</a> f√ºr die Netzwerk- und Interprozesskommunikation verwendet.  Infolgedessen unterst√ºtzt libuniset2 die Kommunikation mit Sensoren und Steuerbl√∂cken, und SObjectizer unterst√ºtzt Akteure und Interaktionen zwischen Akteuren innerhalb eines einzelnen Prozesses. </p><br><p>  Wie ich bereits sagte, gibt es 62 Motoren.  Jeder Motor kann an einen FC (Frequenzumrichter) angeschlossen werden;  F√ºr die entsprechende Latte kann eine Zielkoordinate angegeben werden.  Die Geschwindigkeit der Bewegung der Latte kann ebenfalls angegeben werden.  Dar√ºber hinaus hat jeder Motor die folgenden Zust√§nde: </p><br><ul><li>  bereit zu arbeiten; </li><li>  verbunden; </li><li>  arbeiten; </li><li>  Fehlfunktion; </li><li>  Verbinden (ein √úbergangszustand); </li><li>  Trennen (ein √úbergangszustand); </li></ul><br><p> Jede Engine wird im System durch einen Akteur dargestellt, der den √úbergang zwischen Zust√§nden implementiert, Daten von Sensoren verarbeitet und Befehle ausgibt.  Es ist nicht schwer, in SObjectizer einen Akteur zu erstellen: Erben Sie einfach Ihre Klasse vom Typ <code>so_5::agent_t</code> .  Das erste Argument des Konstruktors des Akteurs sollte vom Typ <code>context_t</code> . Alle anderen Argumente k√∂nnen nach Wunsch eines Entwicklers definiert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Ich werde die detaillierte Beschreibung der Klassen und Methoden nicht anzeigen, da es sich nicht um ein Tutorial handelt.  Ich m√∂chte nur zeigen, wie einfach das alles in SObjectizer geht (in wenigen Zeilen buchst√§blich).  Ich m√∂chte Sie daran erinnern, dass SObjectizer eine hervorragende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> und viele Beispiele enth√§lt. </p><br><h1 id="what-is-the-state-of-an-actor-what-are-we-talking-about">  Was ist der "Zustand" eines Schauspielers?  Wor√ºber reden wir? </h1><br><p>  Die Verwendung von Zust√§nden und der √úbergang zwischen ihnen ist ein "natives Thema" f√ºr Steuerungssysteme.  Dieses Konzept ist sehr gut f√ºr die Ereignisbehandlung.  Dieses Konzept wird in SObjectizer auf API-Ebene unterst√ºtzt.  Zust√§nde werden innerhalb der Klasse des Schauspielers deklariert: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre> <br><p>  und dann werden Event-Handler f√ºr jeden Zustand definiert.  Manchmal ist es notwendig, beim Betreten oder Verlassen eines Staates etwas zu tun.  Dies wird auch in SObjectizer √ºber die Handler on_enter / on_exit unterst√ºtzt.  Es scheint, dass die Entwickler von SObjectizer Hintergrundwissen in der Entwicklung von Steuerungssystemen haben. </p><br><h1 id="event-handlers">  Ereignishandler </h1><br><p>  Ein Ereignishandler ist ein Ort, an dem Ihre Anwendungslogik implementiert ist.  Wie bereits erw√§hnt, wird ein Abonnement f√ºr eine bestimmte mbox und einen bestimmten Status erstellt.  Wenn ein Akteur keine explizit angegebenen Zust√§nde hat, befindet er sich in einem speziellen "Standardzustand". </p><br><p>  Verschiedene Handler k√∂nnen f√ºr dasselbe Ereignis in verschiedenen Zust√§nden definiert werden.  Wenn Sie f√ºr ein Ereignis keinen Handler definieren, wird dieses Ereignis ignoriert (ein Schauspieler wei√ü nichts davon). </p><br><p>  Es gibt eine einfache Syntax zum Definieren von Ereignishandlern.  Sie geben eine Methode an, und es m√ºssen keine zus√§tzlichen Typen oder Vorlagenparameter angegeben werden.  Zum Beispiel: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Dies ist ein Beispiel f√ºr ein Abonnement von Ereignissen aus einer bestimmten mbox im Status st_base.  Es ist erw√§hnenswert, dass st_base ein Basiszustand f√ºr einige andere Zust√§nde ist und dass das Abonnement von abgeleiteten Zust√§nden geerbt wird.  Dieser Ansatz erm√∂glicht das Kopieren und Einf√ºgen f√ºr √§hnliche Ereignishandler in verschiedenen Zust√§nden.  Der geerbte Ereignishandler kann jedoch f√ºr einen bestimmten Status neu definiert oder ein Ereignis vollst√§ndig deaktiviert ("unterdr√ºckt") werden. </p><br><p>  Eine andere M√∂glichkeit, Ereignishandler zu definieren, ist die Verwendung von Lambda-Funktionen.  Dies ist eine sehr bequeme Methode, da Ereignishandler h√§ufig nur ein oder zwei Codezeilen enthalten: Senden von etwas an einen Ort oder Status√§nderung: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Diese Syntax sieht am Anfang komplex aus, wird aber erst nach ein paar Tagen aktiver Codierung bekannt und Sie beginnen sie sogar zu m√∂gen.  Dies liegt daran, dass die gesamte Logik eines Schauspielers pr√§zise und auf einem Bildschirm platziert werden kann.  In dem oben gezeigten Beispiel gibt es √úberg√§nge von st_disconnected zu st_off oder st_protection.  Dieser Code ist leicht zu lesen. </p><br><p>  √úbrigens gibt es f√ºr einfache F√§lle, in denen nur ein Zustands√ºbergang erforderlich ist, eine spezielle Syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre> <br><h1 id="the-control">  Die Kontrolle </h1><br><p>  Wie ist die Kontrolle organisiert?  Wie oben erw√§hnt, gibt es zwei Kontrollstationen zur Steuerung der Bewegung von Latten.  Jede Kontrollstation verf√ºgt √ºber ein Display, ein Zeigeger√§t (Trackball) und einen Geschwindigkeitssetzer (und wir z√§hlen keinen Computer in der Station und kein zus√§tzliches Zubeh√∂r). </p><br><p>  Es gibt zwei Steuermodi: manuell und "Szenariomodus".  "Szenariomodus" wird sp√§ter erl√§utert, und jetzt sprechen wir √ºber den manuellen Modus.  In diesem Modus w√§hlt ein Bediener eine Latte aus, bereitet sie f√ºr die Bewegung vor (verbindet den Motor mit einem FC), setzt die Zielmarke f√ºr die Latte und wenn die Geschwindigkeit √ºber Null eingestellt ist, beginnt sich die Latte zu bewegen. </p><br><p>  Der Geschwindigkeitssetzer ist ein physisches Zubeh√∂r in Form eines "Potentiometers mit Griff", aber es wird auch ein virtuelles auf dem Display der Station angezeigt.  Je mehr gedreht wird, desto h√∂her ist die Bewegungsgeschwindigkeit.  Die H√∂chstgeschwindigkeit ist auf 1,5 Meter pro Sekunde begrenzt.  Der Geschwindigkeitssetzer ist einer f√ºr alle Latten.  Dies bedeutet, dass sich alle ausgew√§hlten Latten mit der gleichen Geschwindigkeit bewegen.  Latten k√∂nnen sich in entgegengesetzte Richtungen bewegen (dies h√§ngt von der Auswahl des Bedieners ab).  Es ist offensichtlich, dass es f√ºr einen Menschen schwierig ist, mehr als ein paar Latten zu kontrollieren.  Aus diesem Grund werden im manuellen Modus nur kleine Gruppen von Latten behandelt.  Bediener k√∂nnen Latten gleichzeitig von zwei Kontrollstationen aus steuern.  Es gibt also f√ºr jede Station einen eigenen Geschwindigkeitsregler. </p><br><p>  Aus Sicht der Implementierung gibt es im manuellen Modus keine spezifische Logik.  Ein "connect engine" -Befehl geht von der grafischen Oberfl√§che aus, wird in eine entsprechende Nachricht an einen Akteur umgewandelt und dann von diesem Akteur verarbeitet.  Der Akteur wechselt vom Zustand "Aus" in den Zustand "Verbinden" und dann in den Zustand "Verbunden".  √Ñhnliches passiert mit Befehlen zum Positionieren einer Latte und zum Einstellen der Bewegungsgeschwindigkeit.  Alle diese Befehle werden in Form von Nachrichten an einen Akteur √ºbergeben.  Es ist jedoch erw√§hnenswert, dass "grafische Oberfl√§che" und "Steuerungsprozess" separate Prozesse sind und libuniset2 f√ºr IPC verwendet wird. </p><br><h1 id="the-scenario-mode-are-there-actors-again">  Der Szenariomodus (gibt es wieder Schauspieler?) </h1><br><p>  In der Praxis wird der manuelle Modus nur f√ºr sehr einfache F√§lle oder w√§hrend der Proben verwendet.  Der Hauptsteuermodus ist "Szenariomodus".  In diesem Modus wird jede Latte gem√§√ü den Szenarioeinstellungen mit einer bestimmten Geschwindigkeit an eine bestimmte Position bewegt.  In diesem Modus stehen einem Bediener zwei einfache Befehle zur Verf√ºgung: </p><br><ul><li>  vorbereiten (eine Gruppe von Motoren wird an FC angeschlossen); </li><li>  go (Bewegung der Gruppe beginnt). </li></ul><br><p>  Das gesamte Szenario ist in "Agenden" unterteilt.  Eine "Agenda" beschreibt eine einzelne Bewegung einer Gruppe von Latten.  Dies bedeutet, dass eine "Agenda" einige Latten enth√§lt und Zielziele und Geschwindigkeiten f√ºr diese enth√§lt.  In Wirklichkeit besteht ein Szenario aus Handlungen, Handlungen bestehen aus Bildern, Bilder bestehen aus Agenden und die Agenda besteht aus Zielen f√ºr Latten.  Aus Sicht der Steuerung spielt dies jedoch keine Rolle, da nur die Tagesordnungen die genauen Parameter der Bewegung der Latte enthalten. </p><br><p>  Das Actor Model passt perfekt zu diesem Fall.  Wir haben einen "Szenario-Spieler" entwickelt, der eine Gruppe spezieller Schauspieler hervorbringt und sie startet.  Wir haben zwei Arten von Akteuren entwickelt: Vollstrecker-Akteure (sie steuern die Bewegung von Latten) und Koordinator-Akteure (sie verteilen Aufgaben zwischen Vollstreckern).  Executoren werden nach Bedarf erstellt: Wenn keine freien Executoren vorhanden sind, wird ein neuer Executor erstellt.  Der Koordinator verwaltet den Pool der verf√ºgbaren Ausf√ºhrenden.  Infolgedessen sieht das Steuerelement ungef√§hr so ‚Äã‚Äãaus: </p><br><ul><li>  ein Bediener l√§dt ein Szenario; </li><li>  "scrollt" es bis zur erforderlichen Tagesordnung; </li><li>  dr√ºckt die Taste "Vorbereiten" zum richtigen Zeitpunkt.  In diesem Moment wird eine Nachricht an einen Koordinator gesendet.  Diese Nachricht enth√§lt Daten f√ºr jede Latte von der Tagesordnung. </li><li>  Der Koordinator √ºberpr√ºft seinen Pool von Testamentsvollstreckern und verteilt die Aufgaben auf freie Testamentsvollstrecker (bei Bedarf werden neue Testamentsvollstrecker erstellt). </li><li>  Jeder Executor empf√§ngt eine Aufgabe und f√ºhrt Vorbereitungsaktionen aus (verbindet eine Engine mit einem FC und wartet dann auf den Befehl "go"). </li><li>  Der Bediener dr√ºckt zum richtigen Zeitpunkt die Taste "Los". </li><li>  Der Befehl "go" geht an den Koordinator und verteilt den Befehl auf alle derzeit verwendeten Executoren. </li></ul><br><p>  Es gibt einige zus√§tzliche Parameter in den Tagesordnungen.  Wie "Bewegung erst nach N Sekunden Verz√∂gerung starten" oder "Bewegung nur nach einem zus√§tzlichen Befehl eines Bedieners starten".  Aus diesem Grund ist die Liste der Zust√§nde f√ºr einen Testamentsvollstrecker ziemlich lang: "Bereit f√ºr den n√§chsten Befehl", "Bereit f√ºr die Bewegung", "Verz√∂gerung der Bewegung", "Warten auf den Bedienerbefehl", "Bewegen", "Abgeschlossen", "Misserfolg". </p><br><p>  Wenn eine Latte die Zielmarke erfolgreich erreicht hat (oder ein Fehler vorliegt), meldet der Executor dem Koordinator den Abschluss der Aufgabe.  Der Koordinator antwortet mit einem Befehl zum Ausschalten der Engine (wenn die Latte nicht mehr an der Agenda teilnimmt) oder sendet eine neue Aufgabe an den Executor.  Der Executor schaltet entweder die Engine aus und wechselt in den Wartezustand oder beginnt mit der Verarbeitung des neuen Befehls. </p><br><p>  Da SObjectizer √ºber eine sehr durchdachte und bequeme API f√ºr die Arbeit mit Status verf√ºgt, erwies sich der Implementierungscode als recht pr√§zise.  Zum Beispiel wird eine Verz√∂gerung vor der Bewegung nur durch eine Codezeile beschrieben: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre> <br><p>  Die Methode <code>time_limit</code> gibt an, wie lange im Status <code>st_moving</code> soll und welcher Status dann aktiviert werden soll (in diesem Beispiel <code>st_moving</code> ). </p><br><h1 id="protection-actors">  Schutzakteure </h1><br><p>  Nat√ºrlich k√∂nnen Fehler auftreten.  Es gibt Anforderungen, um diese Fehler korrekt zu behandeln.  Schauspieler werden auch f√ºr solche Aufgaben verwendet.  Schauen wir uns einige Beispiele an: </p><br><ul><li>  √úberstromschutz; </li><li>  Schutz vor Fehlfunktionen des Sensors; </li><li>  Schutz vor Bewegung in die entgegengesetzte Richtung (dies kann passieren, wenn mit Sensoren oder Aktoren etwas nicht stimmt); </li><li>  Schutz vor spontanen Bewegungen (ohne Befehl); </li><li>  Befehlsausf√ºhrungskontrolle (die Bewegung einer Latte sollte √ºberpr√ºft werden). </li></ul><br><p>  Wir k√∂nnen sehen, dass all diese F√§lle autark sind, aber sie sollten gleichzeitig gemeinsam kontrolliert werden.  Dies bedeutet, dass ein Fehler auftreten kann.  Aber jede Pr√ºfung hat ihre Logik: Manchmal muss eine Zeit√ºberschreitung √ºberpr√ºft werden, manchmal m√ºssen einige vorherige Werte eines Sensors analysiert werden.  Aus diesem Grund wird der Schutz in Form kleiner Akteure umgesetzt.  Diese Akteure werden zur Zusammenarbeit mit dem Hauptakteur hinzugef√ºgt, der die Steuerlogik implementiert.  Dieser Ansatz erm√∂glicht das einfache Hinzuf√ºgen neuer Schutzf√§lle: F√ºgen Sie der Zusammenarbeit einfach einen weiteren Schutzakteur hinzu.  Der Code eines solchen Akteurs ist normalerweise kurz und leicht zu verstehen, da er nur eine Funktion implementiert. </p><br><p>  Besch√ºtzer haben auch mehrere Staaten.  Normalerweise werden sie eingeschaltet, wenn ein Motor eingeschaltet wird oder wenn eine Latte ihre Bewegung beginnt.  Wenn ein Protektor einen Fehler / eine Fehlfunktion feststellt, ver√∂ffentlicht er eine Benachrichtigung (mit Schutzcode und einigen zus√§tzlichen Details).  Der Hauptakteur reagiert auf diese Benachrichtigung und f√ºhrt die erforderlichen Aktionen aus (z. B. Abstellen des Motors und Umschalten in den gesch√ºtzten Zustand). </p><br><h1 id="as-the-conclusion">  Als Fazit ... </h1><br><p>  ... dieser Artikel ist nat√ºrlich kein Durchbruch.  Das Akteurmodell wird seit geraumer Zeit in mehreren verschiedenen Systemen eingesetzt.  Aber es war meine erste Erfahrung mit dem Actor Model zum Aufbau eines automatischen Steuerungssystems in einem eher kleinen Projekt.  Und diese Erfahrung erwies sich als recht erfolgreich.  Ich hoffe, ich habe gezeigt, dass Schauspieler gut zu Steuerungsalgorithmen passen: Es gibt buchst√§blich √ºberall Orte f√ºr Schauspieler. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir</a> hatten in fr√ºheren Projekten etwas √Ñhnliches implementiert (ich meine Zust√§nde, Nachrichtenaustausch, Verwaltung von Arbeitsthreads usw.), aber es war kein einheitlicher Ansatz.  Durch die Verwendung von SObjectizer haben wir ein kleines, leichtes Tool erhalten, das viele Probleme l√∂st.  Wir m√ºssen keine Synchronisationsmechanismen auf niedriger Ebene (wie Mutexe) mehr (explizit) verwenden, es gibt keine manuelle Thread-Verwaltung, keine handgeschriebenen Zustandsdiagramme mehr.  All dies wird vom Framework bereitgestellt, logisch verbunden und in Form einer praktischen API ausgedr√ºckt, aber Sie verlieren nicht die Kontrolle √ºber Details.  Es war also eine aufregende Erfahrung.  Wenn Sie immer noch Zweifel haben, empfehle ich Ihnen, sich insbesondere das Actor Model und den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer anzusehen</a> .  Es hinterl√§sst positive Emotionen. </p><br><p>  Das Actor Model funktioniert wirklich!  Besonders im Theater. </p><br><p>  Originalartikel in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischer Sprache</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452464/">https://habr.com/ru/post/de452464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452454/index.html">Anmelden bei Azure DevOps mit Ihren GitHub-Anmeldeinformationen</a></li>
<li><a href="../de452456/index.html">Mit Microsoft Kaizala kann Indian Railways seine drei Millionen Mitarbeiter mit Gesundheitsdiensten verbinden</a></li>
<li><a href="../de452458/index.html">Beobachten Sie Hunde im wirklichen Leben oder schwerwiegende Schwachstellen in ACS</a></li>
<li><a href="../de452460/index.html">Einf√ºhrung in Windows Terminal</a></li>
<li><a href="../de452462/index.html">√úber OOP</a></li>
<li><a href="../de452466/index.html">Braille-Tastatur</a></li>
<li><a href="../de452468/index.html">"Wenn Sie jemanden t√∂ten m√ºssen, dann sind Sie an die Adresse gekommen"</a></li>
<li><a href="../de452474/index.html">Wavelet-Analyse. Teil 2</a></li>
<li><a href="../de452478/index.html">Erstellen von Tabellen im Figma-Designsystem und Implementierung im Storybook (React)</a></li>
<li><a href="../de452480/index.html">Phoenix LiveView: Wenn Sie kein JavaScript mehr ben√∂tigen *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>