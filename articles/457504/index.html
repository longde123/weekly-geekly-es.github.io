<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏼 👸🏿 🎭 ¿Por qué escribir su cuadrícula de datos de reacción en 2019? 👭 🙎🏼 🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Estoy involucrado en el desarrollo de un sistema ECM. Y en una breve serie de artículos quiero compartir nuestra experiencia y la historia ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Por qué escribir su cuadrícula de datos de reacción en 2019?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457504/"><p>  Hola Habr!  Estoy involucrado en el desarrollo de un sistema ECM.  Y en una breve serie de artículos quiero compartir nuestra experiencia y la historia del desarrollo de mi React Data Grid (en adelante, simplemente una grilla), a saber: </p><br><ul><li>  por qué abandonamos los componentes terminados </li><li>  ¿Qué problemas y tareas encontramos al desarrollar nuestra grilla? </li><li>  ¿Qué beneficio da el desarrollo de su red? </li></ul><br><h3 id="predystoriya">  Antecedentes </h3><br><p>  Nuestro sistema tiene una aplicación web en la que los usuarios trabajan con listas de documentos, resultados de búsqueda, directorios.  Además, las listas pueden ser pequeñas (10 empleados) o muy grandes (50,000 contratistas).  Para mostrar estas listas, desarrollamos nuestra propia cuadrícula: </p><br><p><img src="https://habrastorage.org/webt/1m/v3/py/1mv3pyhnf7emxc6xs2h8lcv8dis.png" alt="imagen"></p><a name="habracut"></a><br><p>  Cuando comenzamos a desarrollar una aplicación web, queríamos encontrar una biblioteca preparada para mostrar una cuadrícula que pueda hacer todo lo que necesitamos: ordenar y agrupar registros, arrastrar y soltar columnas, trabajar con múltiples selecciones, filtrar y calcular totales de columnas, en porciones Descargue datos del servidor y muestre decenas de miles de registros. </p><br><p>  Explicaré el último requisito "mostrar decenas de miles de registros".  En las cuadrículas, este requisito se implementa de varias maneras: paginación, desplazamiento infinito, desplazamiento virtual. </p><br><p>  Los enfoques de paginación y desplazamiento infinito son comunes en los sitios web, los usa todos los días.  Por ejemplo, paginación en Google: </p><br><p><img src="https://habrastorage.org/webt/v5/5q/vz/v55qvz8wjlhqmp-jfzievdnjvxe.png" alt="imagen"></p><br><p>  O desplazarse al infinito en el mismo Google en imágenes, donde se carga la siguiente porción de imágenes cuando se desplaza a través de la primera porción hasta el final: </p><br><p><img src="https://habrastorage.org/webt/bs/r7/qk/bsr7qkhgokj6ezk3qlagzkkgdaq.png" alt="imagen"></p><br><p>  Pero el desplazamiento virtual (en lo sucesivo denominado desplazamiento virtual) rara vez se usa en la web, su principal diferencia con el desplazamiento infinito es la capacidad de desplazarse rápidamente por listas muy grandes en cualquier lugar.  En este caso, solo se descargarán y mostrarán los datos visibles para el usuario. </p><br><p><img src="https://habrastorage.org/webt/wf/j8/ct/wfj8ctaao00cbfi1txsytvpqwae.png" alt="imagen"></p><br><p>  Para nuestra aplicación web, quería usar el desplazamiento virtual.  Estoy de acuerdo en que desplazarse a cualquier lugar en la lista de 10,000 entradas es un caso bastante inventado.  Sin embargo, el desplazamiento aleatorio dentro de 500-1000 registros es un caso en vivo. </p><br><p>  Cuando implementan el desplazamiento virtual, a menudo implementan la API de software para administrar este desplazamiento.  Esta es una característica muy importante.  El desplazamiento de software se utiliza, por ejemplo, para colocar el registro seleccionado en el medio de la pantalla al abrir el directorio: </p><br><p><img src="https://habrastorage.org/webt/ny/up/na/nyupnajuldvlpnb294u203xvy-w.png" alt="imagen"></p><br><p>  De vuelta a los requisitos.  ¿Qué más necesitábamos? </p><br><ul><li>  API de gestión de desplazamiento virtual </li><li>  Personalización de la apariencia de la cuadrícula (filas, columnas, menú contextual) para que la cuadrícula no se vea extraña en nuestra aplicación </li><li>  Soporte para las tecnologías que utilizamos: react, redux y flexbox </li><li>  Que la cuadrícula funcionó en ie11 </li></ul><br><p>  En general, había muchos requisitos. </p><br><h3 id="popytka-pervaya-2016-god-devextreme-javascript-data-grid">  El primer intento (2016).  DevExtreme JavaScript Data Grid </h3><br><p>  Sin explorar mucho las bibliotecas existentes, nos topamos con la cuadrícula de datos de JavaScript DevExtreme.  Por requisitos funcionales, esta red cubría todas nuestras necesidades y tenía una apariencia muy presentable.  Sin embargo, no era adecuado para requisitos tecnológicos (no reaccionar, no redux, no flexbox).  En ese momento, DevExtreme no tenía una grilla de reacción. </p><br><p>  Bueno, dejemos que no reaccione, decidimos, porque la cuadrícula es hermosa y funcional, la usaremos.  Y agregaron la biblioteca a su proyecto.  Resultó que agregamos 3 MB de scripts. </p><br><p>  Durante un par de semanas, integramos la cuadrícula en nuestra aplicación web y aumentamos la funcionalidad básica: </p><br><ul><li>  Envolvió una cuadrícula para hacer amigos con react y redux </li><li>  Desplazamiento virtual elevado y carga de porciones de datos desde nuestro servidor web </li><li>  Implementación de clasificación y selección </li></ul><br><p>  En el proceso de atornillar la red, se aclararon dos problemas serios y un montón de problemas menos serios. </p><br><h3 id="pervaya-sereznaya-problema">  Primer problema grave </h3><br><p>  Hacer que DevExtreme JavaScript Data Grid con redux sea muy difícil.  Logramos controlar la configuración de las columnas y resaltar los registros a través de redux, pero almacenar datos cargados en porciones en redux y realizar operaciones CRUD en ellos a través de redux; esto no es realista.  Tuve que hacer una muleta que, sin pasar por redux, manipulara los datos de la cuadrícula.  La muleta resultó ser compleja y frágil.  Esta fue la primera alarma que la red no nos convenía, pero continuamos atornillándola. </p><br><h3 id="vtoraya-sereznaya-problema">  Segundo problema serio </h3><br><p>  No hay una API de gestión de desplazamiento virtual.  No pudimos rechazar el control de desplazamiento del software, tuvimos que rehacer las fuentes DevExtreme y encontrar la API de control de desplazamiento interno.  Por supuesto, esta API tenía una montaña de limitaciones, porque fue diseñada para uso interno.  Como resultado, logramos hacer que la API interna funcione más o menos en nuestros casos, pero nuevamente, evitando redux, y nuevamente un montón de muletas. </p><br><h3 id="menee-sereznye-problemy">  Problemas menos serios </h3><br><p>  Surgieron problemas menos serios todo el tiempo, porque la funcionalidad estándar de DevExtreme JavaScript Data Grid no era completamente adecuada para nosotros, e intentamos corregirla: </p><br><ol><li>  Estirar la cuadrícula DevExtreme en altura no funciona.  Tuve que escribir un truco para enseñarle a DevExtreme cómo hacer esto (tal vez no haya ningún problema con esto en versiones recientes). </li><li>  Cuando el foco no está en la cuadrícula, es imposible controlar la selección de líneas a través del teclado (y lo necesitábamos).  Tuve que escribir el control de mi teclado. </li><li>  Al cambiar la composición de las columnas y los datos, tuvimos el problema de parpadear los datos (con el desplazamiento virtual habilitado). </li><li>  El problema de una gran cantidad de solicitudes cuando se muestra la cuadrícula por primera vez.  Fue especialmente notable cuando controlamos el desplazamiento a través de la API interna. </li><li>  Es difícil personalizar algunas partes de la cuadrícula de la interfaz de usuario.  Por ejemplo, había un deseo sobre la línea de cuadrícula seleccionada para dibujar acciones de administración de línea (eliminar una línea, copiar, abrir una tarjeta).  Pero cómo atornillar esto en DevExtreme no estaba claro, e incluso usando react: <br><img src="https://habrastorage.org/webt/yo/zv/9b/yozv9boc174n-rxmbdsxoham4g8.png" alt="imagen"></li><li>  Es difícil clasificar ordenadamente (queríamos ordenar por datos que no se muestran en la cuadrícula y no se asignan en columnas). </li><li>  Se requieren muletas para atornillar el componente de reacción en las celdas de la rejilla (después de todo, la rejilla no está en la reacción). </li><li>  No se debe escribir código DevExtreme (flujo / mecanografiado). </li><li>  Problema de velocidad con desplazamiento virtual largo. </li><li>  Problema de velocidad al estirar / reorganizar columnas (después de un desplazamiento virtual prolongado). </li><li>  El tamaño de los scripts de cuadrícula es de 3 Mb. </li></ol><br><p>  Aunque la cuadrícula de funcionalidad DevExtreme contenía todo lo que necesitábamos, quería reescribir casi toda la funcionalidad estándar.  Durante su uso, se agregaron cientos de líneas de código que eran difíciles de entender que intentaban resolver los problemas de interacción con redux y reaccionar, era difícil usar una cuadrícula sin reacción en una aplicación de reacción. </p><br><h3 id="otkaz-ot-devextreme-poisk-alternativ">  Denegación de DevExtreme.  Busca alternativas </h3><br><p>  Después de algún tiempo usando DevExtreme, se decidió abandonarlo.  Deseche todos los hacks, código complejo, así como 3 MB de scripts DevExtreme.  Y busca o escribe una nueva cuadrícula. </p><br><p>  Esta vez, estamos más atentos al estudio de las redes existentes.  MS Fabric DetailsList, ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid, KendoUI Grid fueron estudiados. <br>  Los requisitos seguían siendo los mismos, pero ya se concretaron en una lista que nos quedó clara. </p><br><p>  Requerimientos tecnológicos: </p><br><ul><li>  reaccionar </li><li>  redux </li><li>  flexbox </li></ul><br><p>  Requerimientos Funcionales: </p><br><ul><li>  Desplazamiento virtual (con la capacidad de mostrar decenas de miles de registros) </li><li>  API de gestión de desplazamiento </li><li>  Almacenamiento de datos y configuraciones de cuadrícula en redux </li><li>  Carga de datos por lotes desde un servidor web </li><li>  Gestión de columnas (estiramiento / reorganización / control de visibilidad) </li><li>  Clasificación de columnas + filtrado </li><li>  Selección múltiple </li><li>  Me gusta-búsqueda con luz de fondo </li><li>  Desplazamiento horizontal </li><li>  Teclado </li><li>  Menú contextual (en una línea, en un área vacía, en columnas) </li><li>  Soporte ie11, edge, chrome, ff, safari </li></ul><br><p>  En este punto, la primera versión de DevExtreme React Grid ya había aparecido, pero de inmediato la descartamos por las siguientes razones: </p><br><ul><li>  El desplazamiento virtual no es compatible con ie11 </li><li>  El desplazamiento virtual no funciona junto con la descarga por lotes de datos del servidor (aunque parece haber algunas soluciones). </li><li>  Y lo más importante, no quería pisar el mismo rastrillo cuando quería reescribir la mitad de la funcionalidad estándar de una grilla de terceros. </li></ul><br><p>  El análisis de las soluciones existentes mostró que no existe una "bala de plata".  No existe una cuadrícula que cubra todos nuestros requisitos.  Se decidió escribir nuestra propia cuadrícula, que en términos de funcionalidad desarrollaremos en la dirección que necesitamos, y seremos amigos de las tecnologías que necesita nuestro producto. </p><br><h3 id="razrabotka-svoego-react-data-grid">  Desarrollando su cuadrícula de datos de reacción </h3><br><p>  El desarrollo de la red comenzó con prototipos, donde probaron los temas más difíciles para nosotros: </p><br><ul><li>  desplazamiento virtual </li><li>  almacenamiento de todos los datos de la red en Redux </li></ul><br><h3 id="virtual-scrolling">  Desplazamiento virtual </h3><br><p>  El más difícil resultó ser el desplazamiento virtual.  En su mayor parte, se realiza en una de 3 formas: </p><br><p>  <strong>1. Virtualización de página</strong> <br>  Los datos se dibujan en porciones - páginas.  Al desplazarse, se agregan páginas visibles, se eliminan las invisibles.  La página consta de 20-60 líneas (generalmente el tamaño es personalizable).  Aquí es donde fueron los productos: DevExtreme JavaScript Data Grid, MS Fabric DetailsList. </p><br><p><img src="https://habrastorage.org/webt/h7/tf/5l/h7tf5lynlgmje6wunlcowkeabqa.png" alt="imagen"></p><br><p>  <strong>2. Virtualización línea por línea</strong> <br>  Solo se dibujan líneas visibles.  Tan pronto como una línea sale de la pantalla, se elimina de inmediato.  Los productos fueron así: ReactVirtualized Grid, DevExtreme React Grid, Telerik Grid. </p><br><p><img src="https://habrastorage.org/webt/9j/zs/bh/9jzsbhqw0_up5gnkt2g7cw3uth0.png" alt="imagen"></p><br><p>  <strong>3. Lienzo</strong> <br>  Todas las líneas y sus contenidos se dibujan con Canvas.  Esto es lo que hizo Google Docs. </p><br><p><img src="https://habrastorage.org/webt/12/f_/hd/12f_hdydog5ponrdm9filxne_1u.png" alt="imagen"></p><br><p>  Al desarrollar la cuadrícula, creamos prototipos para las tres opciones de virtualización (incluso para Canvas).  Y eligieron la virtualización página por página. </p><br><h3 id="pochemu-otkazalis-ot-drugih-variantov">  ¿Por qué abandonó otras opciones? </h3><br><p>  La virtualización línea por línea tuvo problemas con la velocidad de representación en el prototipo.  Tan pronto como el contenido de las líneas se volvió más complicado (mucho texto, resaltado, recorte, íconos, una gran cantidad de columnas y flexbox en todas partes), se volvió costoso agregar / quitar líneas varias veces por segundo.  Por supuesto, los resultados también dependen del navegador (hicimos soporte, incluido ie11, edge): </p><br><p><img src="https://habrastorage.org/webt/fe/4v/xh/fe4vxhw7r5zjwqqezc7rmxubmmm.png" alt="imagen"></p><br><p>  La opción de Canvas era muy seductora en la velocidad de renderizado, pero laboriosa.  Se propuso dibujar todo: texto, ajuste de texto, recorte de texto, resaltado, iconos, líneas divisorias, resaltado, sangría.  Haga una reacción al hacer clic en el botón del mouse en el Lienzo, resaltando las líneas cuando pasa el cursor sobre.  Al mismo tiempo, algunos elementos Dom (que muestran sugerencias, "acciones emergentes" en la línea) deben aplicarse sobre Canvas.  Todavía era necesario resolver el problema de difuminar texto e íconos en Canvas.  Todo esto es largo y difícil de hacer.  Aunque dominamos el prototipo.  Al mismo tiempo, cualquier personalización de filas y celdas en el futuro resultaría en una gran laboriosidad para nosotros. </p><br><h4 id="plyusy-postranichnoy-virtualizacii">  Los beneficios de la paginación </h4><br><p>  La virtualización seleccionada página por página tenía ventajas en comparación con línea por línea, lo que determinó su elección: </p><br><ul><li>  Si la página ya está representada, el desplazamiento dentro de la página es barato (el árbol DOM no cambia al desplazarse).  La virtualización línea por línea con cualquier desplazamiento menor requiere cambiar el árbol DOM, y esto es costoso cuando el árbol DOM es complejo y flexbox se usa en todas partes. </li><li>  Para listas pequeñas (&lt;200 entradas) las páginas no se pueden eliminar, solo agregue.  Tarde o temprano, se construirán todas las páginas y el desplazamiento será completamente gratuito (en términos de tiempo de representación). </li></ul><br><h4 id="vybor-razmera-stranicy">  Selección de tamaño de página </h4><br><p>  Un tema aparte es la elección del tamaño de página.  Escribí anteriormente que el tamaño es personalizable y generalmente es de 20-60 líneas.  Se dibuja una página grande durante mucho tiempo, una pequeña lleva a una visualización frecuente de una "pantalla blanca" al desplazarse.  Experimentalmente, se seleccionó un tamaño de página de 25 líneas.  Sin embargo, para ie11 el tamaño se ha reducido a 5 líneas.  Siente que la interfaz en IE responde mejor si dibuja muchas páginas pequeñas con retrasos pequeños que una grande con un retraso grande. </p><br><h4 id="react-i-virtual-scrolling">  Reaccionar y desplazamiento virtual </h4><br><p>  La virtualización de la página tuvo que implementarse usando react.  Para hacer esto, se deben resolver varias tareas: </p><br><p>  <strong>Tarea 1. ¿Cómo agregar / eliminar páginas mediante reaccionar al desplazarse?</strong> </p><br><p>  Para resolver este problema, se introdujeron los siguientes conceptos: </p><br><ul><li>  modelo de página </li><li>  vista de página </li></ul><br><p>  Un modelo es información sobre la cual construir una vista.  Una vista es un componente Reaccionar. </p><br><p><img src="https://habrastorage.org/webt/ud/da/qi/uddaqigdtketfoh6cwk6lnklcpo.png" alt="imagen"></p><br><p>  De hecho, la tarea de virtualización después de esto se redujo a manipular modelos de página: almacenar una lista de modelos de página, agregar y quitar modelos al desplazarse.  Y ya desde la lista de modelos a través de reaccionar construir / reconstruir la pantalla: </p><br><p><img src="https://habrastorage.org/webt/4m/sr/g0/4msrg0gy9qwsv9u-8ljjqhzllwa.png" alt="imagen"></p><br><p>  En el curso de la implementación, se formaron las reglas para trabajar con modelos de página: </p><br><ul><li>  Las páginas deben agregarse una a la vez.  Después de cada adición, dé tiempo para dibujar.  Es aceptable agregar 1 página cada 300-500 ms; esta es una situación de desplazamiento rápido.  Si agrega, por ejemplo, 5 páginas a la vez, la interfaz del usuario se bloquea en su construcción. </li><li>  Las páginas no necesitan estar en docenas.  Un ejemplo de una situación problemática: se muestran 20 páginas, el usuario va a otra lista y las 20 páginas deben eliminarse a la vez.  Eliminar una gran cantidad de páginas es una operación costosa; limpiar el árbol DOM tomará 1 segundo.  Para evitar esto, es mejor no guardar más de 10 páginas a la vez. </li><li>  Para cualquier manipulación de columna (reorganización, adición, eliminación, estiramiento) es mejor eliminar páginas que no son visibles para el usuario de antemano.  Esto evitará la costosa reconstrucción de todas las páginas renderizadas. </li></ul><br><p>  <strong>Tarea 2. ¿Cómo mostrar la barra de desplazamiento?</strong> </p><br><p>  El desplazamiento virtual supone que hay una barra de desplazamiento disponible, que tiene en cuenta el tamaño de la lista y le permite desplazarse a cualquier lugar: </p><br><p><img src="https://habrastorage.org/webt/lo/rc/ut/lorcutgz7bcopbjltcnziudkgks.png" alt="imagen"></p><br><p>  ¿Cómo mostrar esa barra de desplazamiento?  La solución más simple es dibujar un div invisible del tamaño requerido en lugar de datos reales.  Y ya encima de este div mostramos las páginas visibles: </p><br><p><img src="https://habrastorage.org/webt/pp/_x/vg/pp_xvgowd1qtrnyigxnszou0xnw.png" alt="imagen"></p><br><p>  <strong>Tarea 3. ¿Cómo controlar el tamaño de la ventana gráfica?</strong> </p><br><p>  Viewport es el área de datos visible de la cuadrícula.  ¿Por qué vigilar su tamaño?  Para calcular la cantidad de páginas que deben mostrarse al usuario.  Supongamos que tenemos un tamaño de página pequeño (5 líneas) y una resolución de pantalla grande (1920x1080).  ¿Cuántas páginas debe mostrar el usuario para cerrar toda la ventana gráfica? </p><br><p><img src="https://habrastorage.org/webt/tt/g3/sx/ttg3sxfvvuf320ydcwe6esbukp4.png" alt="imagen"></p><br><p>  Puede resolver este problema si conoce la altura de la ventana gráfica y la altura de una página.  Ahora vamos a complicar la tarea, supongamos que el usuario cambia la escala bruscamente en el navegador - establece 50%: </p><br><p><img src="https://habrastorage.org/webt/s8/47/mt/s847mtipiappdqe0qqsli_yvj14.png" alt="imagen"></p><br><p>  La situación con la escala muestra que no es suficiente averiguar el tamaño de la ventana gráfica una vez, debe controlar el tamaño.  Y ahora complicaremos la tarea por completo: los elementos html no tienen un evento de cambio de tamaño, al que puede suscribirse y controlar el tamaño.  Solo el objeto de la ventana ha cambiado de tamaño. </p><br><p>  Lo primero que viene a la mente es usar un temporizador y sondear constantemente la altura del elemento html.  Pero hay una solución aún mejor que vimos en DevExtreme JavaScript Data Grid: cree un iframe invisible, estírelo al tamaño de la cuadrícula y suscríbase al evento de cambio de tamaño de iframe.contentWindow: </p><br><p><img src="https://habrastorage.org/webt/fa/gi/ta/fagitaw870f5ahtworjownk__mk.png" alt="imagen"></p><br><p><img src="https://habrastorage.org/webt/dd/m9/tq/ddm9tqblgsmpwepcc7_gq7g32sm.png" alt="imagen"></p><br><h3 id="rezyume">  Resumen </h3><br><p>  PD: este no es el final.  En el próximo artículo contaré cómo nos hicimos amigos de redux. </p><br><p>  Para obtener un desplazamiento virtual completo, muchas otras tareas tuvieron que ser resueltas.  Pero los descritos anteriormente fueron los más interesantes.  Aquí hay algunas otras tareas que también aparecen: </p><br><ul><li>  Tenga en cuenta la dirección y la velocidad de desplazamiento al agregar / eliminar páginas. </li><li>  Tenga en cuenta los cambios de datos para minimizar la reconstrucción de los modelos de página.  Por ejemplo, eliminó una línea o agregó una línea, ¿qué hacer con las páginas ya renderizadas?  ¿Desechar todo o dejar un poco?  Hay espacio para la optimización. </li><li>  Al cambiar la selección, reorganice el número mínimo requerido de páginas. </li></ul><br><p>  Si tiene preguntas sobre la implementación, puede escribirlas en los comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457504/">https://habr.com/ru/post/457504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457480/index.html">Crear una aplicación de escucha para ver el tráfico MMORPG móvil</a></li>
<li><a href="../457490/index.html">Aisioshechka de Zuckerberg - brevemente y en el caso de Libra</a></li>
<li><a href="../457494/index.html">"Y si no sé matemáticas, ¿estoy desesperado?" - especialistas responden preguntas frecuentes sobre profesiones en ciencia de datos</a></li>
<li><a href="../457496/index.html">"Encuentra las cinco diferencias". Diferencia escalable y generacional: nuevo lote de pruebas</a></li>
<li><a href="../457500/index.html">Cómo hicimos el piloto automático para una estación de servicio</a></li>
<li><a href="../457508/index.html">Parenting vs Machine Learning: compara una madre joven</a></li>
<li><a href="../457510/index.html">Use mcrouter para escalar memcached horizontalmente</a></li>
<li><a href="../457512/index.html">Replicación lógica entre versiones de PostgreSQL</a></li>
<li><a href="../457514/index.html">Nevanger</a></li>
<li><a href="../457516/index.html">Escribir un modelo de amenaza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>