<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåå üå∫ üéõÔ∏è UICollectionViewLayout f√ºr Pizza aus verschiedenen H√§lften ü§π üí® ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um Pizza aus H√§lften zu machen, haben wir zwei UICollectionViewLayout . Ich spreche dar√ºber, wie wir ein solches Layout f√ºr iOS geschrieben haben, was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UICollectionViewLayout f√ºr Pizza aus verschiedenen H√§lften</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/452876/"><p> Um Pizza aus H√§lften zu machen, haben wir zwei <code>UICollectionViewLayout</code> .  Ich spreche dar√ºber, wie wir ein solches Layout f√ºr iOS geschrieben haben, was uns begegnet ist und was wir abgelehnt haben. </p><br><p><img src="https://habrastorage.org/webt/qd/pl/dd/qdplddqepgkdqbzsxy9ca2gpsv8.png"></p><a name="habracut"></a><br><h2 id="prototip">  Prototyp </h2><br><p>  Als wir die Aufgabe hatten, eine Schnittstelle f√ºr Pizza aus H√§lften zu erstellen, waren wir etwas verwirrt.  Ich m√∂chte es sch√∂n und klar und bequem und gro√ü und interaktiv und viel mehr.  Ich m√∂chte cool machen. </p><br><p>  Designer versuchten verschiedene Ans√§tze: ein Raster aus Pizzen, horizontalen und vertikalen Karten, aber sie entschieden sich f√ºr den halben Schlag.  Wir wussten nicht, wie wir ein solches Ergebnis erzielen sollten, also begannen wir mit einem Experiment und brauchten zwei Wochen, um den Prototyp zu erstellen.  Sogar das grobe Layout konnte allen gefallen.  Die Reaktion wurde auf Video aufgezeichnet: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Xc80sP0StVs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="kak-rabotaet-uicollectionview">  So funktioniert UICollectionView </h2><br><p>  <code>UICollectionView</code> ist eine Unterklasse von <code>UIScrollView</code> und eine regul√§re UIView, deren <code>bounds</code> sich durch Wischen √§ndern.  Wenn Sie <code>.origin</code> , verschieben wir den sichtbaren Bereich, und das √Ñndern der Gr√∂√üe <code>.size</code> auf die Skalierung aus. </p><br><p>  Wenn sich der Bildschirm <code>UICollectionView</code> erstellt die UICollectionView die Zellen (oder verwendet sie erneut), und die Regeln f√ºr deren Anzeige werden im <code>UICollectionViewLayout</code> .  Wir werden mit ihm arbeiten. </p><br><p>  Die M√∂glichkeiten von <code>UICollectionViewLayout</code> gro√ü. Sie k√∂nnen eine beliebige Beziehung zwischen Zellen angeben.  Sie k√∂nnen beispielsweise sehr √§hnlich wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">iCarousel Folgendes tun</a> : </p><br><p><img src="https://habrastorage.org/webt/nn/1e/ju/nn1eju91xr0as7rfsfwifeygp7u.png"></p><br><h2 id="pervyy-podhod">  Erster Ansatz </h2><br><p>  Das √Ñndern des Aussehens beim Verschieben des Bildschirms erleichterte mir das Verst√§ndnis des Layouts des Layouts. <br>  Wir sind daran gew√∂hnt, dass sich Zellen auf dem Bildschirm bewegen (das gr√ºne Rechteck ist der Bildschirm des Telefons): </p><br><p><img src="https://habrastorage.org/webt/jm/lv/oj/jmlvojpkpk_pe33dhifgggz7tds.gif"></p><br><p>  Umgekehrt bewegt sich dieser Bildschirm relativ zu den Zellen.  Die B√§ume stehen noch, dieser Zug f√§hrt: </p><br><p><img src="https://habrastorage.org/webt/lm/rj/le/lmrjletsid2reyfambdwpsgnriw.gif"></p><br><p>  Im Beispiel √§ndern sich die Zellenrahmen nicht, aber die <code>bounds</code> der Sammlung selbst √§ndern sich.  <code>Origin</code> dieser <code>bounds</code> ist das <code>contentOffset</code> bekannte <code>contentOffset</code> . </p><br><p>  Um ein Layout zu erstellen, m√ºssen Sie zwei Schritte durchlaufen: </p><br><ul><li>  Berechnen Sie die Gr√∂√üe aller Zellen </li><li>  Nur auf dem Bildschirm sichtbar anzeigen. </li></ul><br><h2 id="prostoy-leyaut-kak-v-uitableview">  Einfaches Layout wie in UITableView </h2><br><p>  Das Layout funktioniert nicht direkt mit Zellen.  Stattdessen verwenden sie <code>UICollectionViewLayoutAttributes</code> - dies ist der Satz von Parametern, die auf die Zelle angewendet werden.  <code>Frame</code> - der Hauptrahmen ist f√ºr die Position und Gr√∂√üe der Zelle verantwortlich.  Andere Parameter: Transparenz, Versatz, Position in der Tiefe des Bildschirms usw. </p><br><p><img src="https://habrastorage.org/webt/mc/fp/-f/mcfp-fywrwp2tbor22aiucsp8x0.png"></p><br><p>  Schreiben <code>UICollectionViewLayout</code> ein einfaches <code>UICollectionViewLayout</code> , das das Verhalten einer <code>UITableView</code> wiederholt: Die Zellen nehmen die gesamte Breite ein und gehen nacheinander. </p><br><p>  4 Schritte voraus: </p><br><ul><li>  Berechnen Sie den <code>frame</code> f√ºr alle Zellen in der <code>prepare</code> . </li><li>  <code>layoutAttributesForElements(in:)</code> sichtbare Zellen in der <code>layoutAttributesForElements(in:)</code> -Methode zur√ºck. </li><li>  <code>layoutAttributesForItem(at:)</code> die <code>layoutAttributesForItem(at:)</code> anhand ihres Index in der <code>layoutAttributesForItem(at:)</code> -Methode zur√ºck.  Diese Methode wird beispielsweise beim Aufrufen der Erfassungsmethode scrollToItem (at :) verwendet. </li><li>  Geben Sie die Abmessungen des resultierenden Inhalts in <code>collectionViewContentSize</code> .  So findet der Sammler heraus, wo sich der Rand befindet, zu dem Sie scrollen k√∂nnen. </li></ul><br><p>  Auf den meisten Ger√§ten betr√§gt die Pizzagr√∂√üe 300 Punkte, dann die Koordinaten und Gr√∂√üen aller Zellen: </p><br><p><img src="https://habrastorage.org/webt/nd/kl/6g/ndkl6gwoyp7ib-yrdzryacwtlve.png"></p><br><p>  Ich habe die Berechnungen in einer separaten Klasse durchgef√ºhrt.  Es besteht aus zwei Teilen: Es berechnet alle Frames im Konstruktor und gibt dann nur Zugriff auf die fertigen Ergebnisse: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableLayoutCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Calculation func recalculateDefaultFrames(numberOfItems: Int) { defaultFrames = (0..&lt;numberOfItems).map { defaultCellFrame(atRow: $0) } } func defaultCellFrame(atRow row: Int) -&gt; CGRect { let y = itemSize.height * CGFloat(row) let defaultFrame = CGRect(x: 0, y: y, width: collectionWidth, height: itemSize.height) return defaultFrame } // MARK: - Access func visibleRows(in frame: CGRect) -&gt; [Int] { return defaultFrames .enumerated() // Index to frame relation .filter { $0.element.intersects(frame)} // Filter by frame .map { $0.offset } // Return indexes } var contentSize: CGSize { return CGSize(width: collectionWidth, height: defaultFrames.last?.maxY ?? 0) } static var zero: TableLayoutCache { return TableLayoutCache(itemSize: .zero, collectionWidth: 0) } init(itemSize: CGSize, collectionWidth: CGFloat) { self.itemSize = itemSize self.collectionWidth = collectionWidth } private let itemSize: CGSize private let collectionWidth: CGFloat private var defaultFrames = [CGRect]() }</span></span></code> </pre> <br><p>  In der Layoutklasse m√ºssen Sie dann nur noch Parameter aus dem Cache √ºbergeben. </p><br><ol><li>  Die <code>prepare</code> Methode ruft die Berechnung aller Frames auf. </li><li>  layoutAttributesForElements (in :) filtert die Frames.  Wenn sich der Rahmen mit dem sichtbaren Bereich schneidet, muss die Zelle angezeigt werden: Berechnen Sie alle Attribute und geben Sie sie an das Array der sichtbaren Zellen zur√ºck. </li><li>  layoutAttributesForItem (at :) - Berechnet die Attribute f√ºr eine einzelne Zelle. </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TableLayout</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collectionViewContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache.contentSize } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numberOfItems = collectionView!.numberOfItems(inSection: section) cache = <span class="hljs-type"><span class="hljs-type">TableLayoutCache</span></span>(itemSize: itemSize, collectionWidth: collectionView!.bounds.width) cache.recalculateDefaultFrames(numberOfItems: numberOfItems) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexes = cache.visibleRows(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cells = indexes.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { (row) -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: row, section: section) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = layoutAttributesForItem(at: path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }.compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>(forCellWith: indexPath) attributes.frame = cache.defaultCellFrame(atRow: indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> = .zero { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateLayout() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> section = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache = <span class="hljs-type"><span class="hljs-type">TableLayoutCache</span></span>.zero }</code> </pre> <br><h2 id="menyaem-pod-svoinuzhdy">  Wir √§ndern uns nach Ihren Bed√ºrfnissen </h2><br><p>  Wir haben die Tabellenansicht sortiert, aber jetzt m√ºssen wir ein dynamisches Layout erstellen.  Bei jeder Fingerverschiebung berechnen wir die Attribute der Zellen neu: Nehmen Sie bereits gez√§hlte Frames und √§ndern Sie sie mit <code>.transform</code> .  Alle √Ñnderungen werden in einer Unterklasse von <code>PizzaHalfSelectorLayout</code> . </p><br><h3 id="schitaem-indeks-tekuscheypiccy">  Wir lesen den aktuellen Pizza-Index </h3><br><p>  Der <code>contentOffset</code> k√∂nnen Sie <code>contentOffset</code> vergessen und durch die Nummer der aktuellen Pizza ersetzen.  Dann m√ºssen Sie nicht mehr √ºber Koordinaten nachdenken. Alle Entscheidungen beziehen sich auf die Pizzanummer und deren Verschiebungsgrad von der Mitte des Bildschirms. </p><br><p>  Es werden zwei Methoden ben√∂tigt: eine konvertiert <code>contentOffset</code> in eine <code>contentOffset</code> , die andere umgekehrt: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PizzaHalfSelectorLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pizzaIndex: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellHeight = itemSize.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenHalf = collectionView!.bounds.height / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> midY = cellHeight * <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(pizzaIndex) + cellHeight / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newY = midY - screenHalf <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: newY) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pizzaIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(offset: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellHeight = itemSize.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proposedCenterY = collectionView!.screenCenterYOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: offset) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pizzaIndex = proposedCenterY / cellHeight <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pizzaIndex } }</code> </pre> <br><p>  Die <code>contentOffset</code> Berechnung f√ºr die Bildschirmmitte wird in der <code>extension</code> gerendert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIScrollView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">screenCenterYOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset: CGPoint? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offsetY = offset?.y ?? contentOffset.y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contentOffsetY = offsetY + bounds.height / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentOffsetY } }</code> </pre> <br><h3 id="ostanavlivaemsya-na-picce-vcentre">  Wir halten an der Pizza in der Mitte </h3><br><p>  Das erste, was wir tun m√ºssen, ist die Pizza in der Mitte des Bildschirms anzuhalten.  Die Methode <code>targetContentOffset(forProposedContentOffset:)</code> fragt, wo gestoppt werden soll, wenn sie bei der aktuellen Geschwindigkeit bei <code>proposedContentOffset</code> <code>targetContentOffset(forProposedContentOffset:)</code> anhalten soll. </p><br><p>  Die Berechnung ist einfach: Sehen Sie sich an, in welche Pizza das <code>proposedContentOffset</code> ContentOffset f√§llt, und scrollen Sie so, dass es in der Mitte steht: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pizzaIndex = <span class="hljs-type"><span class="hljs-type">Int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pizzaIndex(offset: proposedContentOffset)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> projectedOffset = contentOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: pizzaIndex) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> projectedOffset }</code> </pre> <br><p>  <code>UIScrollView</code> hat zwei <code>.normal</code> : <code>.normal</code> und <code>.fast</code> .  <code>.fast</code> besser f√ºr <code>.fast</code> geeignet: </p><br><pre> <code class="swift hljs">collectionView!.decelerationRate = .fast</code> </pre> <br><p>  Aber es gibt ein Problem: Wenn wir nur ein wenig gescrollt haben, m√ºssen wir auf Pizza bleiben und nicht zum n√§chsten springen.  Es gibt keine Methode zum √Ñndern der Geschwindigkeit, so dass der R√ºckw√§rtssprung zwar in geringer Entfernung, aber mit sehr hoher Geschwindigkeit erfolgt: </p><br><p><img src="https://habrastorage.org/webt/bh/u_/bm/bhu_bm7b_mmktpu_rtmeyq7fxby.gif"></p><br><p>  <strong>Achtung, Hack!</strong> </p><br><p>  Wenn sich die Zelle nicht √§ndert, geben wir das aktuelle <code>contentOffset</code> , sodass der <code>contentOffset</code> wird.  Dann scrollen wir selbst mit dem Standard <code>scrollToItem</code> zum vorherigen Ort.  Leider m√ºssen Sie auch asynchron scrollen, damit der Code nach der <code>return</code> aufgerufen wird. Dann wird es w√§hrend der Animation nur wenig verblassen. </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pizzaIndex = <span class="hljs-type"><span class="hljs-type">Int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pizzaIndex(offset: proposedContentOffset)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> projectedOffset = contentOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: pizzaIndex) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sameCell = pizzaIndex == currentPizzaIndexInt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sameCell { animateBackwardScroll(to: pizzaIndex) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collectionView!.contentOffset <span class="hljs-comment"><span class="hljs-comment">// Stop scroll, we've animated manually } return projectedOffset } /// A bit of magic. Without that, high velocity moves cells backward very fast. /// We slow down the animation private func animateBackwardScroll(to pizzaIndex: Int) { let path = IndexPath(row: pizzaIndex, section: 0) collectionView?.scrollToItem(at: path, at: .centeredVertically, animated: true) // More magic here. Fix double-step animation. // You can't do it smoothly without that. DispatchQueue.main.async { self.collectionView?.scrollToItem(at: path, at: .centeredVertically, animated: true) } }</span></span></code> </pre> <br><p>  Das Problem ist weg, jetzt kehrt die Pizza reibungslos zur√ºck: </p><br><p><img src="https://habrastorage.org/webt/ya/kw/c3/yakwc3d1ihbwahdk5zfp62qtgga.gif"></p><br><h2 id="uvelichivaem-centralnuyu-piccu">  Erh√∂hen Sie die zentrale Pizza </h2><br><h3 id="pereschityvaem-leyaut-pri-dvizhenii">  Wir erz√§hlen das Layout beim Umzug </h3><br><p>  Es ist notwendig, dass die zentrale Pizza allm√§hlich zunimmt, wenn sie sich dem Zentrum n√§hert.  Dazu m√ºssen Sie die Parameter nicht einmal zu Beginn, sondern jedes Mal am Offset berechnen.  Schaltet sich einfach ein: </p><br><pre> <code class="objectivec hljs"> override func shouldInvalidateLayout(forBoundsChange newBounds: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Jetzt werden mit jedem Offset die Methoden <code>prepare</code> und <code>layoutAttributesForElements(in:)</code> aufgerufen.  So k√∂nnen wir die <code>UICollectionViewLayoutAttributes</code> viele Male hintereinander aktualisieren und so die Position und Transparenz reibungslos √§ndern. </p><br><h3 id="transformiruem-yacheyki">  Zellen transformieren </h3><br><p>  Im Tabellenlayout lagen die Zellen untereinander und ihre Koordinaten wurden einmal gez√§hlt.  Jetzt werden wir sie abh√§ngig von der Position relativ zur Mitte des Bildschirms √§ndern.  F√ºgen Sie eine Methode hinzu, die sie im laufenden Betrieb √§ndert. </p><br><p>  In der <code>layoutAttributesForElements</code> Methode m√ºssen <code>layoutAttributesForElements</code> die Attribute aus der Oberklasse <code>updateCells</code> , die Attribute der Zellen <code>updateCells</code> und an die <code>updateCells</code> Methode √ºbergeben: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutAttributesForElements(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cells = elements.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.representedElementCategory == .cell } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updateCells(cells) }</code> </pre> <br><p>  Jetzt werden wir die Attribute der Zelle in einer Funktion √§ndern: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cells: [UICollectionViewLayoutAttributes])</span></span></span></span></code> </pre> <br><p>  W√§hrend der Bewegung m√ºssen wir die Transparenz und Gr√∂√üe √§ndern und die Pizza in der Mitte halten. </p><br><p>  Die Position der Zelle relativ zur Mitte des Bildschirms wird zweckm√§√üigerweise in normalisierter Form dargestellt.  Befindet sich die Zelle in der Mitte, ist der Parameter 0, wenn er verschoben ist, √§ndert sich der Parameter von -1 beim Verschieben auf 1 beim Verschieben.  Wenn die Werte weiter von Null als 1 / -1 entfernt sind, bedeutet dies, dass die Zelle nicht mehr zentral ist und sich nicht mehr √§ndert.  Ich habe diesen Skalenparameter genannt: </p><br><p><img src="https://habrastorage.org/webt/r0/of/1n/r0of1n0adfj7bxlgqctip-otjio.png"></p><br><p>  Sie m√ºssen die Differenz zwischen der Mitte des Rahmens und der Mitte des Bildschirms berechnen.  Wenn wir die Differenz durch eine Konstante teilen, normalisieren wir den Wert, und min und max f√ºhren zu einem Bereich von -1 bis +1: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PizzaHalfSelectorLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = cache.defaultCellFrame(atRow: row) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scale = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scale(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scale.normalized } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frame: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> criticalOffset = <span class="hljs-type"><span class="hljs-type">PizzaHalfSelectorLayout</span></span>.criticalOffsetFromCenter <span class="hljs-comment"><span class="hljs-comment">// 200 pt let centerOffset = offsetFromScreenCenter(frame) let relativeOffset = centerOffset / criticalOffset return relativeOffset } func offsetFromScreenCenter(_ frame: CGRect) -&gt; CGFloat { return frame.midY - collectionView!.screenCenterYOffset() } } extension CGFloat { var normalized: CGFloat { return CGFloat.minimum(1, CGFloat.maximum(-1, self)) } }</span></span></code> </pre> <br><h3 id="razmer">  Gr√∂√üe </h3><br><p>  Mit einer normalisierten <code>scale</code> k√∂nnen Sie alles tun.  √Ñnderungen von -1 bis +1 sind zu stark, sie m√ºssen f√ºr die Gr√∂√üe konvertiert werden.  Zum Beispiel m√∂chten wir, dass die Gr√∂√üe auf maximal 0,6 der Gr√∂√üe der zentralen Pizza verringert wird: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cells: [UICollectionViewLayoutAttributes])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cell <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cells { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> normScale = scale(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: cell.indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scale = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-type"><span class="hljs-type">PizzaHalfSelectorLayout</span></span>.scaleFactor * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(normScale) cell.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(scaleX: scale, y: scale) } }</code> </pre> <br><p>  <code>.transform</code> Gr√∂√üe der <code>.transform</code> √§ndert sich relativ zur Mitte der Zellen.  Die zentrale Zelle hat normScale = 0, ihre Gr√∂√üe √§ndert sich nicht: </p><br><p><img src="https://habrastorage.org/webt/d9/-_/au/d9-_au_wqnc2a1l2clpk9719day.gif"></p><br><h3 id="prozrachnost">  Transparenz </h3><br><p>  Die Transparenz kann √ºber den <code>alpha</code> Parameter ge√§ndert werden.  Der <code>scale</code> , den wir bei der <code>transform</code> ist ebenfalls geeignet. </p><br><pre> <code class="swift hljs"> cell.alpha = scale</code> </pre> <br><p>  Jetzt √§ndert Pizza ihre Gr√∂√üe und Transparenz.  Schon nicht so langweilig wie bei normalen Tischen. </p><br><p><img src="https://habrastorage.org/webt/ac/hq/r_/achqr_d_nlvnd6qnn0j4zuh0tm8.gif"></p><br><h2 id="delim-popolam">  Halbieren </h2><br><p>  Vorher haben wir mit einer Pizza gearbeitet: Wir haben das Referenzsystem von der Mitte aus eingestellt, die Gr√∂√üe und Transparenz ge√§ndert.  Jetzt m√ºssen Sie in zwei H√§lften teilen. </p><br><p>  Die Verwendung einer Sammlung ist zu schwierig: Sie m√ºssen f√ºr jede H√§lfte einen eigenen Gestenhandler schreiben.  Es ist einfacher, zwei Sammlungen mit jeweils eigenem Layout zu erstellen.  Erst jetzt gibt es anstelle einer ganzen Pizza H√§lften. </p><br><h3 id="dva-kontrollera-odin-konteyner">  Zwei Controller, ein Container </h3><br><p>  Fast immer <code>UIViewController</code> ich einen Bildschirm in mehrere <code>UIViewController</code> , von denen jeder seine eigene Aufgabe hat.  Diesmal stellte sich heraus: </p><br><p><img src="https://habrastorage.org/webt/xz/bo/zu/xzbozug6y3xxy3l9ywew5e2p9u8.png"></p><br><ol><li>  Die Hauptsteuerung: Alle Teile sind darin zusammengebaut und die Schaltfl√§che ‚ÄûMischen‚Äú. </li><li>  Controller mit zwei Beh√§ltern f√ºr H√§lften, einer zentralen Signatur und Bildlaufanzeigen. </li><li>  Der Controller mit einem Kollektor (rechts wei√ü). </li><li>  Bodenplatte mit Preis. </li></ol><br><p>  Um zwischen der linken und der rechten H√§lfte zu unterscheiden, habe ich <code>enum</code> gestartet. Es wird im Layout in der <code>.orientation</code> .orientation gespeichert: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PizzaHalfOrientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opposite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">PizzaHalfOrientation</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> } } }</code> </pre> <br><h2 id="smeschaem-polovinki-kcentru">  Wir verschieben die H√§lften in die Mitte </h2><br><p>  Das vorherige Layout hat aufgeh√∂rt, das zu tun, was wir erwarten: Die H√§lften begannen sich in die Mitte ihrer Sammlungen zu verschieben, nicht in die Mitte des Bildschirms: </p><br><p><img src="https://habrastorage.org/webt/1d/s8/e1/1ds8e1t6yebpklae9cnihhhwlga.gif"></p><br><p>  Die Korrektur ist einfach: Sie m√ºssen die Zellen horizontal zur H√§lfte in die Mitte des Bildschirms verschieben: </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centerAlignedFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element: UICollectionViewLayoutAttributes, scale: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hOffset = horizontalOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: element, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> orientation { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Align to right return element.frame.offsetBy(dx: +hOffset - spaceBetweenHalves / 2, dy: 0) case .right: // Align to left return element.frame.offsetBy(dx: -hOffset + spaceBetweenHalves / 2, dy: 0) } } private func horizontalOffset(for element: UICollectionViewLayoutAttributes, scale: CGFloat) -&gt; CGFloat { let collectionWidth = collectionView!.bounds.width let scaledElementWidth = element.frame.width * scale let hOffset = (collectionWidth - scaledElementWidth) / 2 return hOffset }</span></span></code> </pre> <br><p>  Der Abstand zwischen den H√§lften wird sofort gesteuert. </p><br><p><img src="https://habrastorage.org/webt/bb/ge/mv/bbgemv9hp2fkfqosnftew4nnss4.gif"></p><br><h3 id="smeschenie-vnutri-yacheyki">  Zellenversatz </h3><br><p>  Es war einfach, runde Pizza in ein Quadrat zu passen, und f√ºr eine H√§lfte braucht man ein halbes Quadrat: </p><br><p><img src="https://habrastorage.org/webt/sa/l8/be/sal8bevbx67mjl4vpjtehf5am1q.png"></p><br><p>  Sie k√∂nnen die Berechnung der Frames neu schreiben: Halbieren Sie die Breite, richten Sie die Frames f√ºr jede H√§lfte unterschiedlich zur Mitte aus.  √Ñndern Sie der Einfachheit halber einfach den <code>contentMode</code> Bildes in der Zelle: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PizzaHalfCell: <span class="hljs-built_in"><span class="hljs-built_in">UICollectionViewCell</span></span> { var halfOrientation: PizzaHalfOrientation = .left { didSet { imageView?.contentMode = halfOrientation == .left ? .topRight : .topLeft <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.setNeedsLayout() } } }</code> </pre> <br><p><img src="https://habrastorage.org/webt/5z/lv/qc/5zlvqc_h1j8yqa104nx0cqag7ai.gif"></p><br><h3 id="prizhimaem-piccy-po-vertikali">  Dr√ºcken Sie die Pizza senkrecht </h3><br><p>  Die Pizzas nahmen ab, aber der Abstand zwischen ihren Zentren √§nderte sich nicht, es traten gro√üe L√ºcken auf.  Sie k√∂nnen sie auf die gleiche Weise kompensieren, wie wir die H√§lften in der Mitte ausgerichtet haben. </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verticalOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element: UICollectionViewLayoutAttributes, scale: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offsetFromCenter = offsetFromScreenCenter(element.frame) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vOffset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-type"><span class="hljs-type">PizzaHalfSelectorLayout</span></span>.verticalOffset( offsetFromCenter: offsetFromCenter, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vOffset } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verticalOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(offsetFromCenter: CGFloat, scale: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -offsetFromCenter / <span class="hljs-number"><span class="hljs-number">4</span></span> * scale }</code> </pre> <br><p>  Infolgedessen sehen alle Kompensationen folgenderma√üen aus: </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centerAlignedFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element: UICollectionViewLayoutAttributes, scale: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hOffset = horizontalOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: element, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vOffset = verticalOffset (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: element, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> orientation { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Align to right return element.frame.offsetBy(dx: +hOffset - spaceBetweenHalves / 2, dy: vOffset) case .right: // Align to left return element.frame.offsetBy(dx: -hOffset + spaceBetweenHalves / 2, dy: vOffset) } }</span></span></code> </pre> <br><p>  Und die Zelleneinstellung ist wie folgt: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cells: [UICollectionViewLayoutAttributes])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cell <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cells { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> normScale = scale(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: cell.indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scale = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-type"><span class="hljs-type">PizzaHalfSelectorLayout</span></span>.scaleFactor * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(normScale) cell.alpha = scale cell.frame = centerAlignedFrame(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: cell, scale: scale) cell.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(scaleX: scale, y: scale) cell.zIndex = cellZLevel } }</code> </pre> <br><p>  <em><strong>Nicht verwechseln:</strong> Die Rahmeneinstellung sollte vor der Transformation liegen.</em>  <em>Wenn Sie die Reihenfolge √§ndern, ist das Ergebnis der Berechnungen v√∂llig anders.</em> </p><br><p>  Fertig!  Wir haben die H√§lften geschnitten und in der Mitte ausgerichtet: </p><br><p><img src="https://habrastorage.org/webt/ns/tn/-h/nstn-hvnc53bierlvesqdauifhq.gif"></p><br><h2 id="dobavlyaem-podpisi">  Bildunterschriften hinzuf√ºgen </h2><br><p>  Header werden auf die gleiche Weise wie Zellen erstellt, nur anstelle von <code>UICollectionViewLayoutAttributes(forCellWith:)</code> Sie den Konstruktor <code>UICollectionViewLayoutAttributes(forSupplementaryViewOfKind:)</code> <br>  und geben Sie sie zusammen mit den <code>layoutAttributesForElements(in:)</code> in <code>layoutAttributesForElements(in:)</code> </p><br><p>  Zun√§chst beschreiben wir eine Methode zum <code>IndexPath</code> eines Headers durch <code>IndexPath</code> : </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForSupplementaryView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ofKind elementKind: String, at indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>( forSupplementaryViewOfKind: elementKind, with: indexPath) attributes.frame = defaultFrameForHeader(at: indexPath) attributes.zIndex = headerZLevel <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }</code> </pre> <br><p>  Die Rahmenberechnung ist in der <code>defaultFrameForHeader</code> Methode (sp√§ter <code>defaultFrameForHeader</code> ) <code>defaultFrameForHeader</code> . </p><br><p>  Jetzt k√∂nnen Sie den <code>IndexPath</code> sichtbaren Zellen <code>IndexPath</code> und die <code>IndexPath</code> f√ºr sie <code>IndexPath</code> : </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> visiblePaths = cells.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.indexPath } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> headers = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.headers(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: visiblePaths) updateHeaders(headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells + headers }</code> </pre> <br><p>  Ein furchtbar langer Funktionsaufruf ist in den <code>headers(for:)</code> versteckt <code>headers(for:)</code> Methode: </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">headers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> paths: [IndexPath])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> headers: [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>] = paths.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { layoutAttributesForSupplementaryView( ofKind: <span class="hljs-type"><span class="hljs-type">UICollectionView</span></span>.elementKindSectionHeader, at: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }.compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> headers }</code> </pre> <br><h3 id="zindex">  zIndex </h3><br><p>  Jetzt befinden sich die Zellen und Signaturen auf derselben "H√∂he", sodass sie sich √ºberlappen k√∂nnen.  Um die Header immer h√∂her zu halten, geben Sie ihnen <code>zIndex</code> gr√∂√üer als Null.  Zum Beispiel 100. </p><br><h2 id="fiksiruem-poziciyu-na-samom-delenet">  Wir legen eine Position fest (eigentlich nicht) </h2><br><p>  Auf dem Bildschirm fixierte Signaturen sind etwas r√§tselhaft.  Sie m√∂chten das Problem beheben, aber umgekehrt, bewegen Sie sich st√§ndig mit den <code>bounds</code> : </p><br><p><img src="https://habrastorage.org/webt/wd/z5/q0/wdz5q0v6znupz4669qjlk1by9bw.gif"></p><br><p>  Im Code ist alles einfach: Wir erhalten die Position der Signatur auf dem Bildschirm und verschieben sie in <code>contentOffset</code> : </p><br><pre> <code class="objectivec hljs"> func defaultFrameForHeader(at indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> { let inset = max(collectionView!.layoutMargins.left, collectionView!.layoutMargins.right) let y = collectionView!.bounds.minY let height = collectionView!.bounds.height let width = collectionView!.bounds.width let headerWidth = width - inset * <span class="hljs-number"><span class="hljs-number">2</span></span> let headerHeight: <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">60</span></span> let vOffset: <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">30</span></span> let screenY = (height - itemSize.height) / <span class="hljs-number"><span class="hljs-number">2</span></span> - headerHeight / <span class="hljs-number"><span class="hljs-number">2</span></span> - vOffset <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: inset, y: y + screenY, width: headerWidth, height: headerHeight) }</code> </pre> <br><p>  Die H√∂he der Signaturen kann unterschiedlich sein. Es ist besser, sie im Delegaten (und dort im Cache) zu ber√ºcksichtigen. </p><br><h3 id="animiruem-podpisi">  Animationen animieren </h3><br><p>  Alles ist den Zellen sehr √§hnlich.  Basierend auf der aktuellen <code>scale</code> k√∂nnen Sie die Transparenz der Zelle berechnen.  Der Versatz kann √ºber <code>.transform</code> eingestellt werden, sodass die Beschriftung relativ zu ihrem Rahmen verschoben wird: </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateHeaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headers: [UICollectionViewLayoutAttributes])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> header <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> headers { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scale = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scale(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: header.indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(scale) header.alpha = alpha <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translation = <span class="hljs-number"><span class="hljs-number">20</span></span> * scale header.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: translation) } }</code> </pre> <br><p><img src="https://habrastorage.org/webt/mw/z5/t2/mwz5t2lrk_0ptrezx8d4aufts-m.gif"></p><br><h3 id="optimiziruem">  Optimieren </h3><br><p>  Nach dem Hinzuf√ºgen von Headern ging die Leistung drastisch zur√ºck.  Es ist passiert, weil wir die Signaturen versteckt haben, sie aber trotzdem an <code>UICollectionViewLayoutAttributes</code> .  Daraus werden der Hierarchie √úberschriften hinzugef√ºgt, die am Layout teilnehmen, aber nicht angezeigt.  Wir haben nur die Zellen gezeigt, die sich mit den aktuellen <code>bounds</code> schneiden, und die Header m√ºssen nach <code>alpha</code> gefiltert werden: </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> visibleHeaders = headers.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.alpha &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells + visibleHeaders }</code> </pre> <br><h2 id="soglasovyvaem-s-centralnoy-podpisyu-originalnyy-recept">  Wir stimmen der zentralen Unterschrift zu (Originalrezept) </h2><br><p>  Wir haben gro√üartige Arbeit geleistet, aber es gab einen Widerspruch in der Benutzeroberfl√§che - wenn Sie zwei identische H√§lften ausw√§hlen, werden sie zu einer normalen Pizza. </p><br><p>  Wir haben beschlossen, es so zu belassen, aber den Zustand korrekt zu verarbeiten, was zeigt, dass es sich um eine normale Pizza handelt.  Unsere neue Aufgabe ist es, ein Etikett f√ºr identische Pizzen in der Mitte anzuzeigen und an den R√§ndern zu verstecken. </p><br><p><img src="https://habrastorage.org/webt/r6/cq/ek/r6cqek3djuomdfy2eakfqep3aeo.gif"></p><br><p>  Das Layout allein ist zu schwer zu l√∂sen, da sich die Inschrift an der Kreuzung zweier Sammler befindet.  Es ist einfacher, wenn der Controller, der beide Sammlungen enth√§lt, die Bewegung aller Signaturen koordiniert. </p><br><p>  Beim Scrollen √ºbergeben wir den aktuellen Index an den Controller, er sendet den Index an die gegen√ºberliegende H√§lfte.  Wenn die Indizes √ºbereinstimmen, wird der Titel der Originalpizza angezeigt. Wenn dies nicht der Fall ist, sind die Signaturen f√ºr jede H√§lfte sichtbar. </p><br><h2 id="kak-pridumyvat-svoileyauty">  So erfinden Sie Ihre Layouts </h2><br><p>  Am schwierigsten war es, herauszufinden, wie Sie Ihre Idee in die Datenverarbeitung umsetzen k√∂nnen.  Zum Beispiel m√∂chte ich, dass Pizzen wie eine Trommel rollen.  Um das Problem zu verstehen, habe ich 4 √ºbliche Schritte durchlaufen: </p><br><ol><li>  Ich habe ein paar Staaten gezeichnet. </li><li>  Ich habe verstanden, wie die Elemente mit der Position des Bildschirms zusammenh√§ngen (die Elemente bewegen sich relativ zur Mitte des Bildschirms). </li><li>  Erstellt Variablen, mit denen bequem gearbeitet werden kann (Bildschirmmitte, zentraler Pizzarahmen, Skala). </li><li>  Ich habe mir einfache Schritte ausgedacht, von denen jeder √ºberpr√ºft werden kann. </li></ol><br><p>  Zust√§nde und Animationen lassen sich in Keynote leicht zeichnen.  Ich nahm das Standardlayout und zeichnete die ersten beiden Schritte: </p><br><p><img src="https://habrastorage.org/webt/vm/b6/rf/vmb6rfn1yjlyhapafdb89m30uko.png"></p><br><p>  Das Video sieht folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/ij/bv/vb/ijbvvbipgfr_1hfvhchtbjjxbwe.gif"></p><br><p>  Es dauerte drei √Ñnderungen: </p><br><ol><li>  Anstelle von Frames aus dem Cache nehmen wir <code>centerPizzaFrame</code> . </li><li>  Lesen Sie mithilfe der <code>scale</code> den Versatz aus diesem Rahmen ab. </li><li><p>  <code>zIndex</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centerAlignedFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element: UICollectionViewLayoutAttributes, scale: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGRect</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hOffset = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.horizontalOffset(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: element, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vOffset = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verticalOffset (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: element, scale: scale) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pizzaHalf { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Align to right return centerPizzaFrame.offsetBy(dx: hOffset - spaceBetweenHalves / 2, dy: vOffset) case .right: // Align to left return centerPizzaFrame.offsetBy(dx: -hOffset + spaceBetweenHalves / 2, dy: vOffset) } } private func horizontalOffset(for element: UICollectionViewLayoutAttributes, scale: CGFloat) -&gt; CGFloat { let collectionWidth = self.collectionView!.bounds.width let scaledElementWidth = centerPizzaFrame.width * scale let hOffset = (collectionWidth - scaledElementWidth) / 2 return hOffset } private func verticalOffset(for element: UICollectionViewLayoutAttributes, scale: CGFloat) -&gt; CGFloat { let totalProgress = self.scale(for: element.frame).normalized(by: 1) let criticalOffset = PizzaHalfSelectorLayout.criticalOffsetFromCenter * 1.1 return totalProgress * criticalOffset }</span></span></code> </pre> <br></li></ol><br><p>      ,         <code>zIndex</code> .  :      ,     ,    <code>zIndex</code> . </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cells: [UICollectionViewLayoutAttributes])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cell <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cells { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> normScale = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scale(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: cell.indexPath.row) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scale = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-type"><span class="hljs-type">PizzaHalfSelectorLayout</span></span>.scaleFactor * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(normScale) cell.alpha = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-comment"><span class="hljs-comment">//scale cell.frame = self.centerAlignedFrame(for: cell, scale: scale) cell.transform = CGAffineTransform(scaleX: scale, y: scale) cell.zIndex = self.zIndex(row: cell.indexPath.row) } } private func zIndex(row: Int) -&gt; Int { let numberOfCells = self.cache.defaultFrames.count if row == self.currentPizzaIndexInt { return numberOfCells } else if row &lt; self.currentPizzaIndexInt { return row } else { return numberOfCells - row - 1 } }</span></span></code> </pre> <br><p> ,    ,    : </p><br><pre> <code class="plaintext hljs">row: zIndex` 0: 0 1: 1 2: 2 3: 10 ‚Äî   4: 5 5: 4 6: 3 7: 2 8: 1 9: 0</code> </pre> <br><p>      ,         . </p><br><h2 id="reliz">  Erscheinungsdatum </h2><br><p>   ,     :     ,        .   :           ,    . </p><br><p> ,       : </p><br><ul><li>    , </li><li>    ,     :  ,     , </li><li>     , </li><li>       , </li><li>      -, </li><li>   ¬´¬ª, </li><li>    Voice Over. </li></ul><br><p>       : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_XIEJUy1y6A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> .</a> </p><br><p>       <code>UICollectionViewLayout</code> ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A Tour of UICollectionView</a> </p><br><p>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452876/">https://habr.com/ru/post/de452876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452850/index.html">Systeme in Kassetten: Wie Ingenieure die Funktionen von Spielekonsolen erweiterten</a></li>
<li><a href="../de452852/index.html">Fernarbeit: Mythen in der Nacht</a></li>
<li><a href="../de452854/index.html">Vom normalen Benutzer zum vollwertigen Serveradministrator (XSS, LFI, Web-Shell)</a></li>
<li><a href="../de452856/index.html">Warum Indie-Projekte nicht live ver√∂ffentlicht werden</a></li>
<li><a href="../de452872/index.html">Da ich kein Rosnanov-Seminar √ºber FPGAs in Moskau vorbereitet und abgehalten habe. Pl√§ne, dasselbe in Las Vegas und Zelenograd zu tun</a></li>
<li><a href="../de452880/index.html">Sensationelle Benutzerdatenlecks f√ºr Januar - April 2019</a></li>
<li><a href="../de452882/index.html">Kundenfehler beim ersten Kontakt mit Freelancer</a></li>
<li><a href="../de452884/index.html">Analyse der Leistung virtueller Maschinen in VMware vSphere. Teil 1: CPU</a></li>
<li><a href="../de452886/index.html">Wiki-Projekte und Noosphere-Name auf HACKNOWLEGE</a></li>
<li><a href="../de452888/index.html">In der N√§he von M√ºnchen begann der Test des f√ºnfsitzigen Tiltrotors Lilium Jet in Originalgr√∂√üe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>