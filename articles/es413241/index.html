<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèª üõå ü§≠ Funciones de interceptaci√≥n en el kernel de Linux usando ftrace üòè üå≠ üë¥üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un proyecto relacionado con la seguridad de los sistemas Linux, necesit√°bamos interceptar llamadas a funciones importantes dentro del n√∫cleo (como ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones de interceptaci√≥n en el kernel de Linux usando ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Ping√ºino Ninja, En3l" align="right" width="40%"></a>  En un proyecto relacionado con la seguridad de los sistemas Linux, necesit√°bamos interceptar llamadas a funciones importantes dentro del n√∫cleo (como abrir archivos y ejecutar procesos) para proporcionar la capacidad de monitorear la actividad en el sistema y bloquear preventivamente la actividad de procesos sospechosos. <br><br>  Durante el proceso de desarrollo, logramos inventar un enfoque bastante bueno, que nos permite interceptar convenientemente cualquier funci√≥n en el n√∫cleo por nombre y ejecutar nuestro c√≥digo alrededor de sus llamadas.  El interceptor se puede instalar desde un m√≥dulo GPL cargable, sin reconstruir el n√∫cleo.  El enfoque admite kernels versi√≥n 3.19+ para la arquitectura x86_64. <br><a name="habracut"></a><br>  <font color="gray">(Imagen de ping√ºino justo arriba: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬© En3l con DeviantArt</a> .)</font> <br><br><h2>  Enfoques conocidos </h2><br><h3>  API de seguridad de Linux </h3><br>  Lo m√°s correcto ser√≠a utilizar la <em>API de seguridad de Linux</em> , una interfaz especial creada espec√≠ficamente para estos fines.  En lugares cr√≠ticos del c√≥digo del n√∫cleo, se ubican las llamadas a las funciones de seguridad, que, a su vez, llaman a las devoluciones de llamada establecidas por el m√≥dulo de seguridad.  El m√≥dulo de seguridad puede examinar el contexto de una operaci√≥n y tomar una decisi√≥n sobre si est√° permitido o denegado. <br><br>  Desafortunadamente, la API de seguridad de Linux tiene un par de limitaciones importantes: <br><br><ul><li>  los m√≥dulos de seguridad no pueden cargarse din√°micamente, son parte del n√∫cleo y requieren reconstrucci√≥n </li><li>  solo puede haber un m√≥dulo de seguridad en el sistema (con algunas excepciones) </li></ul><br>  Si la posici√≥n de los desarrolladores del kernel es ambigua con respecto a la multiplicidad de m√≥dulos, entonces la prohibici√≥n de la carga din√°mica es fundamental: el m√≥dulo de seguridad debe ser parte del kernel para garantizar la seguridad constantemente, desde el momento de la carga. <br><br>  Por lo tanto, para usar la API de seguridad, debe suministrar su propio conjunto de kernel, as√≠ como integrar el m√≥dulo adicional con SELinux o AppArmor, que son utilizados por distribuciones populares.  El cliente no quer√≠a suscribirse a tales obligaciones, por lo que esta ruta se cerr√≥. <br><br>  Por estas razones, la API de seguridad no nos conven√≠a, de lo contrario ser√≠a una opci√≥n ideal. <br><br><h3>  Modificaci√≥n de la tabla de llamadas del sistema. </h3><br>  El monitoreo se requer√≠a principalmente para las acciones realizadas por las aplicaciones de los usuarios, de modo que, en principio, podr√≠a implementarse a nivel de llamadas del sistema.  Como sabe, Linux almacena todos los manejadores de llamadas del sistema en la tabla <code>sys_call_table</code> .  La sustituci√≥n de valores en esta tabla conduce a un cambio en el comportamiento de todo el sistema.  Por lo tanto, manteniendo los valores antiguos del controlador y sustituyendo nuestro propio controlador en la tabla, podemos interceptar cualquier llamada al sistema. <br><br>  Este enfoque tiene ciertas ventajas: <br><br><ul><li>  <strong>Control total sobre cualquier llamada del sistema</strong> : la √∫nica interfaz con el n√∫cleo para aplicaciones de usuario.  Al usarlo, podemos estar seguros de que no perderemos ninguna acci√≥n importante realizada por el proceso del usuario. <br></li><li>  <strong>Gastos generales m√≠nimos.</strong>  Hay una inversi√≥n de capital √∫nica al actualizar la tabla de llamadas del sistema.  Adem√°s de la inevitable carga √∫til de monitoreo, el √∫nico gasto es una llamada de funci√≥n adicional (para llamar al manejador de llamadas del sistema original). <br></li><li>  <strong>Requisitos m√≠nimos de kernel.</strong>  Si lo desea, este enfoque no requiere ninguna opci√≥n de configuraci√≥n adicional en el n√∫cleo, por lo que, en teor√≠a, admite la gama m√°s amplia posible de sistemas. <br></li></ul><br>  Sin embargo, tambi√©n sufre algunos defectos: <br><br><ul><li>  <strong>La complejidad t√©cnica de la implementaci√≥n.</strong>  Por s√≠ solo, reemplazar punteros en una tabla no es dif√≠cil.  Pero las tareas relacionadas requieren soluciones no obvias y una cierta calificaci√≥n: <br><ul><li>  tabla de llamadas del sistema de b√∫squeda </li><li>  bypass de protecci√≥n de modificaci√≥n de tabla </li><li>  reemplazo at√≥mico y seguro </li></ul><br>  Todas estas son cosas interesantes, pero requieren un tiempo de desarrollo valioso, primero para la implementaci√≥n y luego para el soporte y la comprensi√≥n. <br></li><li>  <strong>Incapacidad para interceptar algunos manejadores.</strong>  En los n√∫cleos anteriores a la versi√≥n 4.16, el manejo de llamadas del sistema para la arquitectura x86_64 conten√≠a varias optimizaciones.  Algunos de ellos exigieron que el manejador de llamadas del sistema sea un adaptador especial implementado en ensamblador.  En consecuencia, tales controladores son a veces dif√≠ciles, y a veces incluso imposibles de reemplazar con los suyos, escritos en C.  Adem√°s, se utilizan diferentes optimizaciones en diferentes versiones del n√∫cleo, lo que se suma a las dificultades t√©cnicas de la hucha. <br></li><li>  <strong>Solo se interceptan las llamadas del sistema.</strong>  Este enfoque le permite reemplazar los manejadores de llamadas del sistema, lo que limita los puntos de entrada solo a ellos.  Todas las verificaciones adicionales se realizan al principio o al final, y solo tenemos los argumentos de la llamada al sistema y su valor de retorno.  A veces esto lleva a la necesidad de duplicar las verificaciones sobre la adecuaci√≥n de los argumentos y las verificaciones de acceso.  A veces causa una sobrecarga innecesaria cuando necesita copiar la memoria del proceso del usuario dos veces: si el argumento se pasa a trav√©s de un puntero, primero tenemos que copiarlo nosotros mismos, luego el controlador original copiar√° el argumento nuevamente por s√≠ mismo.  Adem√°s, en algunos casos, las llamadas al sistema proporcionan una granularidad muy baja de eventos que deben filtrarse adicionalmente del ruido. <br></li></ul><br>  Inicialmente, elegimos e implementamos con √©xito este enfoque, buscando los beneficios de soportar la mayor cantidad de sistemas.  Sin embargo, en ese momento todav√≠a no sab√≠amos sobre las caracter√≠sticas de x86_64 y las restricciones en las llamadas interceptadas.  M√°s tarde, result√≥ cr√≠tico para nosotros admitir llamadas al sistema relacionadas con el inicio de nuevos procesos: clone () y execve (), que son simplemente especiales.  Esto es lo que nos llev√≥ a buscar nuevas opciones. <br><br><h3>  Usando kprobes </h3><br>  Una de las opciones que se consideraron fue el uso de <em>kprobes</em> : una API especializada dise√±ada principalmente para depurar y rastrear el n√∫cleo.  Esta interfaz le permite configurar controladores previos y posteriores para <em>cualquier instrucci√≥n</em> en el n√∫cleo, as√≠ como controladores para ingresar y regresar de una funci√≥n.  Los manejadores obtienen acceso a los registros y pueden cambiarlos.  Por lo tanto, podr√≠amos obtener monitoreo y la capacidad de influir en el curso posterior del trabajo. <br><br>  Beneficios de usar kprobes para interceptar: <br><br><ul><li>  <strong>API madura</strong>  Las sondas K han existido y mejorado desde tiempos inmemoriales (2002).  Tienen una interfaz bien documentada, la mayor√≠a de las trampas ya se han encontrado, su trabajo se ha optimizado lo m√°s posible, y as√≠ sucesivamente.  En general, toda una monta√±a de ventajas sobre las bicicletas experimentales de fabricaci√≥n propia. <br></li><li>  <strong>Intercepci√≥n de cualquier lugar en el n√∫cleo.</strong>  Los Kprobes se implementan utilizando puntos de interrupci√≥n (instrucciones int3) incrustados en el c√≥digo ejecutable del n√∫cleo.  Esto le permite instalar kprobes literalmente en cualquier lugar de cualquier funci√≥n, si se conoce.  Del mismo modo, los kretprobes se implementan mediante la suplantaci√≥n de la direcci√≥n de retorno en la pila y le permiten interceptar el retorno de cualquier funci√≥n (excepto aquellas que, en principio, no devuelven el control). <br></li></ul><br>  Desventajas de kprobes: <br><br><ul><li>  <strong>Dificultad t√©cnica</strong>  Kprobes es solo una forma de establecer un punto de interrupci√≥n en cualquier parte del n√∫cleo.  Para obtener los argumentos de una funci√≥n o los valores de las variables locales, debe saber en qu√© registros o en qu√© parte de la pila se encuentran, y extraerlos de all√≠ de forma independiente.  Para bloquear una llamada de funci√≥n, debe modificar manualmente el estado del proceso para que el procesador piense que ya ha devuelto el control de la funci√≥n. <br></li><li>  <strong>Las sondas J est√°n en desuso.</strong>  Jprobes es un complemento para kprobes que le permite interceptar convenientemente llamadas de funci√≥n.  Extraer√° independientemente los argumentos de la funci√≥n de los registros o la pila y llamar√° a su controlador, que debe tener la misma firma que la funci√≥n enganchada.  El problema es que las jprobes est√°n en desuso y se cortan de los n√∫cleos modernos. <br></li><li>  <strong>Gastos indirectos no triviales.</strong>  Los puntos de interrupci√≥n son caros, pero de una sola vez.  Los puntos de interrupci√≥n no afectan a otras funciones, pero su procesamiento es relativamente costoso.  Afortunadamente, la optimizaci√≥n de salto se implementa para la arquitectura x86_64, lo que reduce significativamente el costo de kprobes, pero sigue siendo mayor que, por ejemplo, al modificar la tabla de llamadas del sistema. <br></li><li>  <strong>Limitaciones de kretprobes.</strong>  Los Kretprobes se implementan falsificando la direcci√≥n de retorno en la pila.  En consecuencia, deben almacenar la direcci√≥n original en alg√∫n lugar para volver all√≠ despu√©s de procesar kretprobe.  Las direcciones se almacenan en un b√∫fer de tama√±o fijo.  En caso de desbordamiento, cuando se ejecutan demasiadas llamadas simult√°neas de la funci√≥n interceptada en el sistema, kretprobes omitir√° las operaciones. <br></li><li>  <strong>Extrusi√≥n desactivada.</strong>  Dado que kprobes se basa en interrupciones y juegos de malabares con los registros del procesador, para la sincronizaci√≥n todos los manejadores se ejecutan con preferencia deshabilitada.  Esto impone ciertas restricciones a los controladores: no puede esperar en ellos: asigne mucha memoria, haga E / S, duerma en temporizadores y sem√°foros, y otras cosas conocidas. <br></li></ul><br>  En el proceso de investigaci√≥n del tema, nuestros ojos se <strong>centraron</strong> en el marco de trabajo, que puede reemplazar a jprobes.  Result√≥ que funciona mejor para nuestras necesidades de interceptaci√≥n de llamadas de funci√≥n.  Sin embargo, si necesita rastrear instrucciones espec√≠ficas dentro de las funciones, entonces kprobes no debe descontarse. <br><br><h3>  Empalme </h3><br>  En aras de la exhaustividad, tambi√©n vale la pena describir el m√©todo cl√°sico de interceptar funciones, que consiste en reemplazar las instrucciones al comienzo de la funci√≥n con una transici√≥n incondicional que conduce a nuestro controlador.  Las instrucciones originales se transfieren a otro lugar y se ejecutan antes de volver a la funci√≥n interceptada.  Con la ayuda de dos transiciones, incorporamos (empalmamos) nuestro c√≥digo adicional en la funci√≥n, por lo tanto, este enfoque se llama <em>empalme</em> . <br><br>  As√≠ es como se implementa la optimizaci√≥n de salto para kprobes.  Con el empalme, puede lograr los mismos resultados, pero sin costos adicionales para kprobes y con un control completo de la situaci√≥n. <br><br>  Los beneficios del empalme son obvios: <br><br><ul><li>  <strong>Requisitos m√≠nimos de kernel.</strong>  El empalme no requiere ninguna opci√≥n especial en el n√∫cleo y funciona al comienzo de cualquier funci√≥n.  Solo necesitas saber su direcci√≥n. <br></li><li>  <strong>Gastos generales m√≠nimos.</strong>  Dos transiciones incondicionales: esas son todas las acciones que debe realizar el c√≥digo interceptado para transferir el control al controlador y viceversa.  Dichas transiciones son perfectamente predichas por el procesador y son muy baratas. <br></li></ul><br>  Sin embargo, el principal inconveniente de este enfoque nubla seriamente la imagen: <br><br><ul><li>  <strong>Dificultad t√©cnica</strong>  Ella se da vuelta.  No puede simplemente tomar y reescribir el c√≥digo de la m√°quina.  Aqu√≠ hay una lista corta e incompleta de tareas a resolver: <br><ul><li>  sincronizaci√≥n de la instalaci√≥n y eliminaci√≥n de la intercepci√≥n (¬øqu√© sucede si la funci√≥n se llama directamente en el proceso de reemplazar sus instrucciones?) </li><li>  omisi√≥n de protecci√≥n en la modificaci√≥n de regiones de memoria con un c√≥digo </li><li>  Invalidaci√≥n de cach√© de CPU despu√©s de reemplazar instrucciones </li><li>  Desmontaje de instrucciones reemplazables para copiarlas enteras </li><li>  comprobar la ausencia de transiciones dentro de la pieza reemplazada </li><li>  verificar la capacidad de mover la pieza reemplazada a otra ubicaci√≥n </li></ul><br>  S√≠, puede espiar kprobes y usar el marco intranuclear livepatch, pero la soluci√≥n final sigue siendo bastante complicada.  Da miedo imaginar cu√°ntos problemas de sue√±o habr√° en cada nueva implementaci√≥n. <br></li></ul><br>  En general, si puede llamar a este demonio, subordinarse solo a los iniciados, y est√° listo para soportarlo en su c√≥digo, entonces el empalme es un enfoque completamente funcional para interceptar llamadas de funci√≥n.  Ten√≠a una actitud negativa a la hora de escribir bicicletas, por lo que esta opci√≥n segu√≠a siendo una copia de seguridad para nosotros en caso de que no hubiera ning√∫n progreso en absoluto con las soluciones preparadas m√°s f√°ciles. <br><br><h2>  Nuevo enfoque con ftrace </h2><br>  <strong>Ftrace</strong> es un marco de seguimiento de kernel de nivel de funci√≥n.  Se ha desarrollado desde 2008 y tiene una interfaz fant√°stica para programas de usuario.  Ftrace le permite rastrear la frecuencia y la duraci√≥n de las llamadas a funciones, mostrar gr√°ficos de llamadas, filtrar funciones de inter√©s por plantilla, etc.  Puede comenzar a leer sobre las caracter√≠sticas de ftrace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> y luego seguir los enlaces y la documentaci√≥n oficial. <br><br>  Implementa ftrace en funci√≥n de las teclas del compilador <code>-pg</code> y <code>-mfentry</code> , que insertan la llamada a la funci√≥n de rastreo especial mcount () o __fentry __ () al comienzo de cada funci√≥n.  T√≠picamente, en los programas de usuario, esta caracter√≠stica del compilador es utilizada por los perfiladores para rastrear llamadas a todas las funciones.  El kernel utiliza estas funciones para implementar el marco ftrace. <br><br>  Por supuesto, llamar a ftrace desde <em>cada</em> funci√≥n no es barato, por lo que la optimizaci√≥n est√° disponible para arquitecturas populares: <em>ftrace din√°mico</em> .  La conclusi√≥n es que el n√∫cleo conoce la ubicaci√≥n de todas las llamadas a mcount () o __fentry __ () y en las primeras etapas de carga reemplaza su c√≥digo de m√°quina con <strong>nop</strong> , una instrucci√≥n especial que no hace nada.  Cuando se incluye el rastreo en las funciones requeridas, se vuelven a agregar las llamadas ftrace.  Por lo tanto, si no se usa ftrace, su impacto en el sistema es m√≠nimo. <br><br><h3>  Descripci√≥n de las funciones requeridas. </h3><br>  Cada funci√≥n interceptada puede describirse mediante la siguiente estructura: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  El usuario debe completar solo los primeros tres campos: nombre, funci√≥n, original.  Los campos restantes se consideran un detalle de implementaci√≥n.  La descripci√≥n de todas las funciones interceptadas se puede ensamblar en una matriz y las macros se pueden usar para aumentar la compacidad del c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Las envolturas sobre las funciones interceptadas son las siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   ‚Äî  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Como puede ver, las funciones interceptadas con un m√≠nimo de c√≥digo adicional.  Lo √∫nico que requiere una atenci√≥n cuidadosa son las firmas de funciones.  Deben coincidir uno a uno.  Sin esto, obviamente, los argumentos se pasar√°n incorrectamente y todo ir√° cuesta abajo.  Para interceptar llamadas del sistema, esto es menos importante, ya que sus manejadores son muy estables y, para mayor eficiencia, toman los argumentos en el mismo orden en que el sistema se llama a s√≠ mismo.  Sin embargo, si planea interceptar otras funciones, debe recordar que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no hay interfaces estables dentro del n√∫cleo</a> . <br><br><h3>  Inicializaci√≥n de Ftrace </h3><br>  Primero, necesitamos encontrar y guardar la direcci√≥n de la funci√≥n que vamos a interceptar.  Ftrace le permite rastrear funciones por nombre, pero a√∫n necesitamos saber la direcci√≥n de la funci√≥n original para poder llamarla. <br><br>  Puede obtener la direcci√≥n usando <em>kallsyms</em> , una lista de todos los caracteres en el n√∫cleo.  Esta lista incluye <em>todos los</em> caracteres, no solo exportados para m√≥dulos.  Obtener la direcci√≥n de la funci√≥n enganchada se parece a esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  A continuaci√≥n, debe inicializar la estructura <code>ftrace_ops</code> .  Es vinculante <br>  el campo es simplemente <em>funcional</em> , lo que indica una devoluci√≥n de llamada, pero tambi√©n necesitamos <br>  establecer algunas banderas importantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () es nuestra devoluci√≥n de llamada que ftrace llamar√° al rastrear una funci√≥n.  Sobre √©l m√°s tarde.  Las banderas que establezcamos ser√°n necesarias para completar la intercepci√≥n.  Indican a ftrace que guarde y restaure los registros del procesador, cuyo contenido podemos cambiar en la devoluci√≥n de llamada. <br><br>  Ahora estamos listos para permitir la intercepci√≥n.  Para hacer esto, primero debe habilitar ftrace para la funci√≥n que nos interese usando ftrace_set_filter_ip (), y luego permitir que ftrace llame a nuestra devoluci√≥n de llamada usando register_ftrace_function (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  La intercepci√≥n se desactiva de manera similar, solo en el orden inverso: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Una vez completada la llamada a unregister_ftrace_function (), se garantiza la ausencia de activaciones de la devoluci√≥n de llamada instalada en el sistema (y con ella nuestros envoltorios).  Por lo tanto, podemos, por ejemplo, descargar con calma el m√≥dulo interceptor, sin temor a que en alg√∫n lugar del sistema nuestras funciones se sigan realizando (porque si desaparecen, el procesador se alterar√°). <br><br><h3>  Realizar un gancho de funci√≥n </h3><br>  ¬øC√≥mo se realiza realmente la intercepci√≥n?  Muy simple  Ftrace le permite cambiar el estado de los registros despu√©s de salir de una devoluci√≥n de llamada.  Al cambiar el registro% rip, un puntero a la siguiente instrucci√≥n ejecutable, cambiamos las instrucciones que ejecuta el procesador, es decir, podemos forzarlo a ejecutar una transici√≥n incondicional de la funci√≥n actual a la nuestra.  As√≠ tomamos el control. <br><br>  La devoluci√≥n de llamada para ftrace es la siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  Usando la macro container_of (), obtenemos la direcci√≥n de nuestra <code>struct ftrace_hook</code> en la direcci√≥n de la <code>struct ftrace_hook</code> incrustada en ella, despu√©s de lo cual reemplazamos el valor de registro% rip en la <code>struct pt_regs</code> estructura <code>struct pt_regs</code> con la direcci√≥n de nuestro controlador.  Eso es todo.  Para arquitecturas que no sean x86_64, este registro puede llamarse de manera diferente (como IP o PC), pero la idea es en principio aplicable a ellos. <br><br>  Tenga en cuenta el <strong>calificador de notrace</strong> agregado para la devoluci√≥n de llamada.  Pueden marcar caracter√≠sticas que no se pueden rastrear con ftrace.  Por ejemplo, as√≠ es como se marcan las funciones de ftrace que est√°n involucradas en el proceso de rastreo.  Esto ayuda a evitar que el sistema se congele en un bucle sin fin al rastrear todas las funciones en el n√∫cleo (ftrace puede hacer esto). <br><br>  La devoluci√≥n de llamada ftback generalmente llama con extrusi√≥n deshabilitada (como kprobes).  Puede haber excepciones, pero no debe confiar en ellas.  En nuestro caso, sin embargo, esta restricci√≥n no es importante, por lo que solo reemplazamos ocho bytes en la estructura. <br><br>  La funci√≥n contenedora, que se llama m√°s adelante, se ejecutar√° en el mismo contexto que la funci√≥n original.  Por lo tanto, all√≠ puede hacer lo que se permite hacer en la funci√≥n interceptada.  Por ejemplo, si interceptas un controlador de interrupciones, a√∫n no puedes dormir en un contenedor. <br><br><h3>  Protecci√≥n de llamadas recursivas </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un problema en el c√≥digo anterior: cuando nuestro contenedor llama a la funci√≥n original, vuelve a entrar en ftrace, que nuevamente llama a nuestra devoluci√≥n de llamada, que nuevamente transfiere el control al contenedor. Esta recursi√≥n infinita necesita ser interrumpida de alguna manera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s elegante que se nos ocurri√≥ es usar </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno de los argumentos de la devoluci√≥n de llamada ftrace, que contiene la direcci√≥n de retorno a la funci√≥n que llam√≥ a la funci√≥n rastreada. Por lo general, este argumento se usa para construir un gr√°fico de llamadas a funciones. Podemos usarlo para distinguir la primera llamada de la funci√≥n interceptada de la repetida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, al volver a llamar</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe apuntar dentro de nuestro contenedor, mientras que al principio, en alg√∫n lugar en otro lugar del n√∫cleo. </font><font style="vertical-align: inherit;">El control debe transferirse solo cuando se llama por primera vez a la funci√≥n, a todos los dem√°s se les debe permitir ejecutar la funci√≥n original. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificaci√≥n de entrada se puede realizar de manera muy eficiente comparando la direcci√≥n con los bordes del m√≥dulo actual (que contiene todas nuestras funciones). </font><font style="vertical-align: inherit;">Esto funciona muy bien si en el m√≥dulo solo el contenedor llama a la funci√≥n interceptada. </font><font style="vertical-align: inherit;">De lo contrario, debe ser m√°s selectivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En total, la devoluci√≥n de llamada correcta de ftrace es la siguiente:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracter√≠sticas distintivas / ventajas de este enfoque: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bajo gastos generales. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo algunas restas y comparaciones. </font><font style="vertical-align: inherit;">Sin spinlocks, lista de pases, etc.</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos un ejemplo: escribi√≥ el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando ls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la terminal </font><font style="vertical-align: inherit;">para ver una lista de archivos en el directorio actual. El shell (digamos Bash) usa un par tradicional de funciones </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () de la biblioteca est√°ndar C </font><font style="vertical-align: inherit;">para comenzar un nuevo proceso </font><font style="vertical-align: inherit;">. Internamente, estas funciones se implementan mediante las llamadas al sistema </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve (),</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respectivamente. Supongamos que interceptamos la llamada al sistema execve () para controlar el inicio de nuevos procesos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En forma gr√°fica, la intercepci√≥n de la funci√≥n del controlador se ve as√≠: </font></font><br><br><img alt="diagrama de secuencia de intercepci√≥n" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ vemos c√≥mo el proceso del usuario ( </font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">azul</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) realiza una llamada del sistema al n√∫cleo ( </font></font><font color="#EA6B66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rojo</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), donde el marco ftrace ( </font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√∫rpura</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) llama a funciones desde nuestro m√≥dulo ( </font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verde</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de usuario ejecuta SYSCALL. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con esta instrucci√≥n, se transfiere el modo kernel y el control se transfiere al manejador de llamadas del sistema de bajo nivel: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Es responsable de todas las llamadas al sistema de programas de 64 bits en n√∫cleos de 64 bits.</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          ‚Äî       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() ‚Äî        sys_execve() ‚Äî     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip ‚Äî      ‚Äî          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        ‚Äî sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -‚Ä¶ <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gerencia vuelve al n√∫cleo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, fh_sys_execve () se completa y el control pasa a do_syscall_64 (), que considera que la llamada al sistema se complet√≥ como de costumbre. </font><font style="vertical-align: inherit;">El n√∫cleo contin√∫a su negocio nuclear.</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gerencia vuelve al proceso del usuario. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, el n√∫cleo ejecuta la instrucci√≥n IRET (o SYSRET, pero para execve () siempre es IRET), configurando registros para el nuevo proceso de usuario y poniendo el procesador central en modo de ejecuci√≥n de c√≥digo de usuario. </font><font style="vertical-align: inherit;">La llamada al sistema (y el inicio de un nuevo proceso) se completa.</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ventajas y desventajas. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, obtenemos una forma muy conveniente de interceptar cualquier funci√≥n en el n√∫cleo, que tiene las siguientes ventajas: </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   ‚Äî   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La intercepci√≥n es compatible con el rastreo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, este m√©todo no entra en conflicto con ftrace, por lo que a√∫n puede tomar indicadores de rendimiento muy √∫tiles del n√∫cleo. </font><font style="vertical-align: inherit;">El uso de kprobes o empalmes puede interferir con los mecanismos de ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øCu√°les son las desventajas de esta soluci√≥n? </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos de configuraci√≥n del kernel. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realizar con √©xito enlaces de funci√≥n utilizando ftrace, el n√∫cleo debe proporcionar una serie de caracter√≠sticas:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de caracteres kallsyms para buscar funciones por nombre </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace framework en general para rastreo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace opciones de intercepci√≥n cr√≠tica </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> ‚Äî      ,    ¬´¬ª  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doble llamada ftrace. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El enfoque de an√°lisis de puntero descrito anteriormente </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da como resultado una llamada ftrace nuevamente para funciones enganchadas. </font><font style="vertical-align: inherit;">Esto agrega un poco de sobrecarga y puede derribar otros rastros que ver√°n el doble de llamadas. </font><font style="vertical-align: inherit;">Este inconveniente se puede evitar aplicando un poco de magia negra: la llamada ftrace se encuentra al comienzo de la funci√≥n, por lo que si la direcci√≥n de la funci√≥n original se adelanta en 5 bytes (la longitud de la instrucci√≥n de llamada), puede saltar a trav√©s de ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere algunas de las desventajas con m√°s detalle. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Requisitos de configuraci√≥n del kernel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, el n√∫cleo debe admitir ftrace y kallsyms. </font><font style="vertical-align: inherit;">Para hacer esto, las siguientes opciones deben estar habilitadas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_FTRACE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ftrace deber√≠a soportar la modificaci√≥n din√°mica del registro. </font><font style="vertical-align: inherit;">La opci√≥n es responsable de esto.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, el n√∫cleo utilizado debe estar basado en la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versi√≥n 3.19 o superior</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tener acceso al indicador FTRACE_OPS_FL_IPMODIFY. </font><font style="vertical-align: inherit;">Las versiones anteriores del kernel tambi√©n pueden reemplazar el registro% rip, pero a partir de 3.19 esto debe hacerse solo despu√©s de configurar este indicador. </font><font style="vertical-align: inherit;">La presencia de un indicador para los n√∫cleos antiguos conducir√° a un error de compilaci√≥n, y su ausencia para los nuevos generar√° una intercepci√≥n inactiva. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, para realizar la intercepci√≥n, la ubicaci√≥n de la llamada ftrace dentro de la funci√≥n es cr√≠tica: la llamada debe ubicarse al principio, antes del pr√≥logo de la funci√≥n (donde se asigna espacio para variables locales y se forma un marco de pila). </font><font style="vertical-align: inherit;">Esta caracter√≠stica de arquitectura se tiene en cuenta por la opci√≥n</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura x86_64 admite esta opci√≥n, pero el i386 no. </font><font style="vertical-align: inherit;">Debido a las limitaciones de la arquitectura i386, el compilador no puede insertar una llamada ftrace antes del pr√≥logo de la funci√≥n, por lo tanto, cuando se llama ftrace, la pila de funciones ya est√° modificada. </font><font style="vertical-align: inherit;">En este caso, para interceptar, no basta con cambiar el valor del registro% eip; tambi√©n debe revertir todas las acciones realizadas en el pr√≥logo que difieren de una funci√≥n a otra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por esta raz√≥n, la intercepci√≥n de ftrace no es compatible con la arquitectura x86 de 32 bits. </font><font style="vertical-align: inherit;">En principio, podr√≠a implementarse usando cierta magia negra (generar y ejecutar un "antipr√≥logo"), pero la simplicidad t√©cnica de la soluci√≥n se ver√° afectada, que es una de las ventajas de usar ftrace.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sorpresas no obvias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante las pruebas, nos encontramos con una </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caracter√≠stica</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interesante </font><font style="vertical-align: inherit;">: en algunas distribuciones, las funciones de enganche hicieron que el sistema se bloqueara fuertemente. Naturalmente, esto solo sucedi√≥ en sistemas distintos a los utilizados por los desarrolladores. El problema tampoco se reprodujo en el prototipo de intercepci√≥n original, con ninguna distribuci√≥n y versiones de kernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La depuraci√≥n mostr√≥ que el bloqueo ocurre dentro de la funci√≥n interceptada. Por alguna raz√≥n m√≠stica, cuando se llam√≥ a la funci√≥n original dentro de la devoluci√≥n de llamada ftrace, la direcci√≥n </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continu√≥ siendo especificada en el c√≥digo del n√∫cleo en lugar del c√≥digo de la funci√≥n de envoltura. Debido a esto, surgi√≥ un bucle sin fin, ya que ftrace llam√≥ a nuestro contenedor una y otra vez sin realizar ninguna acci√≥n √∫til.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, ten√≠amos tanto c√≥digo que funcionaba como roto, por lo que encontrar las diferencias era solo cuesti√≥n de tiempo. </font><font style="vertical-align: inherit;">Despu√©s de unificar el c√≥digo y desechar todo lo innecesario, las diferencias entre las versiones se localizaron en una funci√≥n de contenedor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta opci√≥n funcion√≥:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pero este - colg√≥ el sistema: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo resulta que el nivel de registro afecta el comportamiento? Un estudio cuidadoso del c√≥digo de m√°quina de las dos funciones r√°pidamente aclar√≥ la situaci√≥n y caus√≥ la sensaci√≥n de que el compilador ten√≠a la culpa. Por lo general, est√° en la lista de sospechosos en alg√∫n lugar cerca de los rayos c√≥smicos, pero esta vez no. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cosa, como result√≥, es que las llamadas a pr_devel () se expanden en el vac√≠o. Esta versi√≥n de la macro printk se utiliza para iniciar sesi√≥n durante el desarrollo. Tales entradas de registro no son interesantes durante la operaci√≥n, por lo tanto, se cortan autom√°ticamente del c√≥digo si no se declara la macro DEBUG. Despu√©s de eso, la funci√≥n para el compilador se convierte en esto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aqu√≠ la optimizaci√≥n entra en escena. </font><font style="vertical-align: inherit;">En este caso se trabaj√≥ denominadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamadas de la cola de optimizaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimizaci√≥n de llamada de cola). </font><font style="vertical-align: inherit;">Permite que el compilador reemplace una llamada de funci√≥n honesta con un salto directo a su cuerpo si una funci√≥n llama a otra e inmediatamente devuelve su valor. </font><font style="vertical-align: inherit;">En el c√≥digo de m√°quina, una llamada honesta se ve as√≠:</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y no funciona, as√≠: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera instrucci√≥n CALL es la misma llamada __fentry __ () insertada por el compilador al comienzo de todas las funciones. Pero luego, en el c√≥digo normal, puede ver la llamada a real_sys_execve (mediante el puntero en la memoria) a trav√©s de la instrucci√≥n CALL y regresar desde fh_sys_execve () utilizando la instrucci√≥n RET. El c√≥digo roto va a la funci√≥n real_sys_execve () directamente usando JMP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La optimizaci√≥n de las llamadas de cola le permite ahorrar un poco de tiempo en la formaci√≥n de un marco de pila "sin sentido", que incluye la direcci√≥n de retorno almacenada en la pila por la instrucci√≥n CALL. Sin embargo, para nosotros, la exactitud de la direcci√≥n del remitente desempe√±a un papel fundamental: la usamos </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tomar una decisi√≥n sobre la intercepci√≥n. Despu√©s de la optimizaci√≥n, la funci√≥n fh_sys_execve () ya no guarda la nueva direcci√≥n de retorno en la pila, queda la anterior, apuntando al n√∫cleo. Por lo tanto</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contin√∫a apuntando dentro del n√∫cleo, lo que finalmente conduce a la formaci√≥n de un bucle infinito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto tambi√©n explica por qu√© el problema solo se reproduce en algunas distribuciones. Al compilar m√≥dulos, diferentes distribuciones usan diferentes conjuntos de indicadores de compilaci√≥n. En distribuciones en dificultades, la optimizaci√≥n de llamadas de cola se habilit√≥ de forma predeterminada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n al problema para nosotros fue deshabilitar la optimizaci√≥n de llamadas de cola para todo el archivo con funciones de contenedor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© m√°s puedo decir? Desarrollar c√≥digo de bajo nivel para el kernel de Linux es divertido. </font><font style="vertical-align: inherit;">Espero que esta publicaci√≥n le ahorre a alguien un poco de tiempo para elegir qu√© usar para escribir su mejor antivirus del mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea experimentar con la intercepci√≥n usted mismo, puede encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥digo completo del m√≥dulo del n√∫cleo </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">en Github</font></a><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413241/">https://habr.com/ru/post/es413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413231/index.html">Introducci√≥n a los contratos inteligentes</a></li>
<li><a href="../es413233/index.html">El servicio uLogin env√≠a datos desde formularios (correo, tel√©fono) a un sitio de terceros y no dice nada al respecto.</a></li>
<li><a href="../es413235/index.html">Apuesta por mejores predicciones: nuevas matem√°ticas de pron√≥sticos del tiempo</a></li>
<li><a href="../es413237/index.html">Facebook niega haber enviado a los fabricantes de dispositivos los mismos datos que el desarrollador Alexander Kogan</a></li>
<li><a href="../es413239/index.html">C√≥mo hacer que un tel√©fono inteligente sea un poco m√°s tonto</a></li>
<li><a href="../es413243/index.html">School of Data: c√≥mo combinar matem√°ticas y negocios</a></li>
<li><a href="../es413245/index.html">En equipos Dolby Atmos, solo sonido "nativo". Dolby proh√≠be la mezcla ascendente no nativa</a></li>
<li><a href="../es413247/index.html">¬øPor qu√© monitorear los sistemas de almacenamiento?</a></li>
<li><a href="../es413249/index.html">Escribir un m√≥dulo de kernel de Linux: I2C</a></li>
<li><a href="../es413251/index.html">Reacci√≥n en cadena de la polimerasa y Vladivostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>