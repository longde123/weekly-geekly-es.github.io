<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏻 🛌 🤭 Funciones de interceptación en el kernel de Linux usando ftrace 😏 🌭 👴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un proyecto relacionado con la seguridad de los sistemas Linux, necesitábamos interceptar llamadas a funciones importantes dentro del núcleo (como ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones de interceptación en el kernel de Linux usando ftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="Pingüino Ninja, En3l" align="right" width="40%"></a>  En un proyecto relacionado con la seguridad de los sistemas Linux, necesitábamos interceptar llamadas a funciones importantes dentro del núcleo (como abrir archivos y ejecutar procesos) para proporcionar la capacidad de monitorear la actividad en el sistema y bloquear preventivamente la actividad de procesos sospechosos. <br><br>  Durante el proceso de desarrollo, logramos inventar un enfoque bastante bueno, que nos permite interceptar convenientemente cualquier función en el núcleo por nombre y ejecutar nuestro código alrededor de sus llamadas.  El interceptor se puede instalar desde un módulo GPL cargable, sin reconstruir el núcleo.  El enfoque admite kernels versión 3.19+ para la arquitectura x86_64. <br><a name="habracut"></a><br>  <font color="gray">(Imagen de pingüino justo arriba: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">© En3l con DeviantArt</a> .)</font> <br><br><h2>  Enfoques conocidos </h2><br><h3>  API de seguridad de Linux </h3><br>  Lo más correcto sería utilizar la <em>API de seguridad de Linux</em> , una interfaz especial creada específicamente para estos fines.  En lugares críticos del código del núcleo, se ubican las llamadas a las funciones de seguridad, que, a su vez, llaman a las devoluciones de llamada establecidas por el módulo de seguridad.  El módulo de seguridad puede examinar el contexto de una operación y tomar una decisión sobre si está permitido o denegado. <br><br>  Desafortunadamente, la API de seguridad de Linux tiene un par de limitaciones importantes: <br><br><ul><li>  los módulos de seguridad no pueden cargarse dinámicamente, son parte del núcleo y requieren reconstrucción </li><li>  solo puede haber un módulo de seguridad en el sistema (con algunas excepciones) </li></ul><br>  Si la posición de los desarrolladores del kernel es ambigua con respecto a la multiplicidad de módulos, entonces la prohibición de la carga dinámica es fundamental: el módulo de seguridad debe ser parte del kernel para garantizar la seguridad constantemente, desde el momento de la carga. <br><br>  Por lo tanto, para usar la API de seguridad, debe suministrar su propio conjunto de kernel, así como integrar el módulo adicional con SELinux o AppArmor, que son utilizados por distribuciones populares.  El cliente no quería suscribirse a tales obligaciones, por lo que esta ruta se cerró. <br><br>  Por estas razones, la API de seguridad no nos convenía, de lo contrario sería una opción ideal. <br><br><h3>  Modificación de la tabla de llamadas del sistema. </h3><br>  El monitoreo se requería principalmente para las acciones realizadas por las aplicaciones de los usuarios, de modo que, en principio, podría implementarse a nivel de llamadas del sistema.  Como sabe, Linux almacena todos los manejadores de llamadas del sistema en la tabla <code>sys_call_table</code> .  La sustitución de valores en esta tabla conduce a un cambio en el comportamiento de todo el sistema.  Por lo tanto, manteniendo los valores antiguos del controlador y sustituyendo nuestro propio controlador en la tabla, podemos interceptar cualquier llamada al sistema. <br><br>  Este enfoque tiene ciertas ventajas: <br><br><ul><li>  <strong>Control total sobre cualquier llamada del sistema</strong> : la única interfaz con el núcleo para aplicaciones de usuario.  Al usarlo, podemos estar seguros de que no perderemos ninguna acción importante realizada por el proceso del usuario. <br></li><li>  <strong>Gastos generales mínimos.</strong>  Hay una inversión de capital única al actualizar la tabla de llamadas del sistema.  Además de la inevitable carga útil de monitoreo, el único gasto es una llamada de función adicional (para llamar al manejador de llamadas del sistema original). <br></li><li>  <strong>Requisitos mínimos de kernel.</strong>  Si lo desea, este enfoque no requiere ninguna opción de configuración adicional en el núcleo, por lo que, en teoría, admite la gama más amplia posible de sistemas. <br></li></ul><br>  Sin embargo, también sufre algunos defectos: <br><br><ul><li>  <strong>La complejidad técnica de la implementación.</strong>  Por sí solo, reemplazar punteros en una tabla no es difícil.  Pero las tareas relacionadas requieren soluciones no obvias y una cierta calificación: <br><ul><li>  tabla de llamadas del sistema de búsqueda </li><li>  bypass de protección de modificación de tabla </li><li>  reemplazo atómico y seguro </li></ul><br>  Todas estas son cosas interesantes, pero requieren un tiempo de desarrollo valioso, primero para la implementación y luego para el soporte y la comprensión. <br></li><li>  <strong>Incapacidad para interceptar algunos manejadores.</strong>  En los núcleos anteriores a la versión 4.16, el manejo de llamadas del sistema para la arquitectura x86_64 contenía varias optimizaciones.  Algunos de ellos exigieron que el manejador de llamadas del sistema sea un adaptador especial implementado en ensamblador.  En consecuencia, tales controladores son a veces difíciles, y a veces incluso imposibles de reemplazar con los suyos, escritos en C.  Además, se utilizan diferentes optimizaciones en diferentes versiones del núcleo, lo que se suma a las dificultades técnicas de la hucha. <br></li><li>  <strong>Solo se interceptan las llamadas del sistema.</strong>  Este enfoque le permite reemplazar los manejadores de llamadas del sistema, lo que limita los puntos de entrada solo a ellos.  Todas las verificaciones adicionales se realizan al principio o al final, y solo tenemos los argumentos de la llamada al sistema y su valor de retorno.  A veces esto lleva a la necesidad de duplicar las verificaciones sobre la adecuación de los argumentos y las verificaciones de acceso.  A veces causa una sobrecarga innecesaria cuando necesita copiar la memoria del proceso del usuario dos veces: si el argumento se pasa a través de un puntero, primero tenemos que copiarlo nosotros mismos, luego el controlador original copiará el argumento nuevamente por sí mismo.  Además, en algunos casos, las llamadas al sistema proporcionan una granularidad muy baja de eventos que deben filtrarse adicionalmente del ruido. <br></li></ul><br>  Inicialmente, elegimos e implementamos con éxito este enfoque, buscando los beneficios de soportar la mayor cantidad de sistemas.  Sin embargo, en ese momento todavía no sabíamos sobre las características de x86_64 y las restricciones en las llamadas interceptadas.  Más tarde, resultó crítico para nosotros admitir llamadas al sistema relacionadas con el inicio de nuevos procesos: clone () y execve (), que son simplemente especiales.  Esto es lo que nos llevó a buscar nuevas opciones. <br><br><h3>  Usando kprobes </h3><br>  Una de las opciones que se consideraron fue el uso de <em>kprobes</em> : una API especializada diseñada principalmente para depurar y rastrear el núcleo.  Esta interfaz le permite configurar controladores previos y posteriores para <em>cualquier instrucción</em> en el núcleo, así como controladores para ingresar y regresar de una función.  Los manejadores obtienen acceso a los registros y pueden cambiarlos.  Por lo tanto, podríamos obtener monitoreo y la capacidad de influir en el curso posterior del trabajo. <br><br>  Beneficios de usar kprobes para interceptar: <br><br><ul><li>  <strong>API madura</strong>  Las sondas K han existido y mejorado desde tiempos inmemoriales (2002).  Tienen una interfaz bien documentada, la mayoría de las trampas ya se han encontrado, su trabajo se ha optimizado lo más posible, y así sucesivamente.  En general, toda una montaña de ventajas sobre las bicicletas experimentales de fabricación propia. <br></li><li>  <strong>Intercepción de cualquier lugar en el núcleo.</strong>  Los Kprobes se implementan utilizando puntos de interrupción (instrucciones int3) incrustados en el código ejecutable del núcleo.  Esto le permite instalar kprobes literalmente en cualquier lugar de cualquier función, si se conoce.  Del mismo modo, los kretprobes se implementan mediante la suplantación de la dirección de retorno en la pila y le permiten interceptar el retorno de cualquier función (excepto aquellas que, en principio, no devuelven el control). <br></li></ul><br>  Desventajas de kprobes: <br><br><ul><li>  <strong>Dificultad técnica</strong>  Kprobes es solo una forma de establecer un punto de interrupción en cualquier parte del núcleo.  Para obtener los argumentos de una función o los valores de las variables locales, debe saber en qué registros o en qué parte de la pila se encuentran, y extraerlos de allí de forma independiente.  Para bloquear una llamada de función, debe modificar manualmente el estado del proceso para que el procesador piense que ya ha devuelto el control de la función. <br></li><li>  <strong>Las sondas J están en desuso.</strong>  Jprobes es un complemento para kprobes que le permite interceptar convenientemente llamadas de función.  Extraerá independientemente los argumentos de la función de los registros o la pila y llamará a su controlador, que debe tener la misma firma que la función enganchada.  El problema es que las jprobes están en desuso y se cortan de los núcleos modernos. <br></li><li>  <strong>Gastos indirectos no triviales.</strong>  Los puntos de interrupción son caros, pero de una sola vez.  Los puntos de interrupción no afectan a otras funciones, pero su procesamiento es relativamente costoso.  Afortunadamente, la optimización de salto se implementa para la arquitectura x86_64, lo que reduce significativamente el costo de kprobes, pero sigue siendo mayor que, por ejemplo, al modificar la tabla de llamadas del sistema. <br></li><li>  <strong>Limitaciones de kretprobes.</strong>  Los Kretprobes se implementan falsificando la dirección de retorno en la pila.  En consecuencia, deben almacenar la dirección original en algún lugar para volver allí después de procesar kretprobe.  Las direcciones se almacenan en un búfer de tamaño fijo.  En caso de desbordamiento, cuando se ejecutan demasiadas llamadas simultáneas de la función interceptada en el sistema, kretprobes omitirá las operaciones. <br></li><li>  <strong>Extrusión desactivada.</strong>  Dado que kprobes se basa en interrupciones y juegos de malabares con los registros del procesador, para la sincronización todos los manejadores se ejecutan con preferencia deshabilitada.  Esto impone ciertas restricciones a los controladores: no puede esperar en ellos: asigne mucha memoria, haga E / S, duerma en temporizadores y semáforos, y otras cosas conocidas. <br></li></ul><br>  En el proceso de investigación del tema, nuestros ojos se <strong>centraron</strong> en el marco de trabajo, que puede reemplazar a jprobes.  Resultó que funciona mejor para nuestras necesidades de interceptación de llamadas de función.  Sin embargo, si necesita rastrear instrucciones específicas dentro de las funciones, entonces kprobes no debe descontarse. <br><br><h3>  Empalme </h3><br>  En aras de la exhaustividad, también vale la pena describir el método clásico de interceptar funciones, que consiste en reemplazar las instrucciones al comienzo de la función con una transición incondicional que conduce a nuestro controlador.  Las instrucciones originales se transfieren a otro lugar y se ejecutan antes de volver a la función interceptada.  Con la ayuda de dos transiciones, incorporamos (empalmamos) nuestro código adicional en la función, por lo tanto, este enfoque se llama <em>empalme</em> . <br><br>  Así es como se implementa la optimización de salto para kprobes.  Con el empalme, puede lograr los mismos resultados, pero sin costos adicionales para kprobes y con un control completo de la situación. <br><br>  Los beneficios del empalme son obvios: <br><br><ul><li>  <strong>Requisitos mínimos de kernel.</strong>  El empalme no requiere ninguna opción especial en el núcleo y funciona al comienzo de cualquier función.  Solo necesitas saber su dirección. <br></li><li>  <strong>Gastos generales mínimos.</strong>  Dos transiciones incondicionales: esas son todas las acciones que debe realizar el código interceptado para transferir el control al controlador y viceversa.  Dichas transiciones son perfectamente predichas por el procesador y son muy baratas. <br></li></ul><br>  Sin embargo, el principal inconveniente de este enfoque nubla seriamente la imagen: <br><br><ul><li>  <strong>Dificultad técnica</strong>  Ella se da vuelta.  No puede simplemente tomar y reescribir el código de la máquina.  Aquí hay una lista corta e incompleta de tareas a resolver: <br><ul><li>  sincronización de la instalación y eliminación de la intercepción (¿qué sucede si la función se llama directamente en el proceso de reemplazar sus instrucciones?) </li><li>  omisión de protección en la modificación de regiones de memoria con un código </li><li>  Invalidación de caché de CPU después de reemplazar instrucciones </li><li>  Desmontaje de instrucciones reemplazables para copiarlas enteras </li><li>  comprobar la ausencia de transiciones dentro de la pieza reemplazada </li><li>  verificar la capacidad de mover la pieza reemplazada a otra ubicación </li></ul><br>  Sí, puede espiar kprobes y usar el marco intranuclear livepatch, pero la solución final sigue siendo bastante complicada.  Da miedo imaginar cuántos problemas de sueño habrá en cada nueva implementación. <br></li></ul><br>  En general, si puede llamar a este demonio, subordinarse solo a los iniciados, y está listo para soportarlo en su código, entonces el empalme es un enfoque completamente funcional para interceptar llamadas de función.  Tenía una actitud negativa a la hora de escribir bicicletas, por lo que esta opción seguía siendo una copia de seguridad para nosotros en caso de que no hubiera ningún progreso en absoluto con las soluciones preparadas más fáciles. <br><br><h2>  Nuevo enfoque con ftrace </h2><br>  <strong>Ftrace</strong> es un marco de seguimiento de kernel de nivel de función.  Se ha desarrollado desde 2008 y tiene una interfaz fantástica para programas de usuario.  Ftrace le permite rastrear la frecuencia y la duración de las llamadas a funciones, mostrar gráficos de llamadas, filtrar funciones de interés por plantilla, etc.  Puede comenzar a leer sobre las características de ftrace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aquí</a> y luego seguir los enlaces y la documentación oficial. <br><br>  Implementa ftrace en función de las teclas del compilador <code>-pg</code> y <code>-mfentry</code> , que insertan la llamada a la función de rastreo especial mcount () o __fentry __ () al comienzo de cada función.  Típicamente, en los programas de usuario, esta característica del compilador es utilizada por los perfiladores para rastrear llamadas a todas las funciones.  El kernel utiliza estas funciones para implementar el marco ftrace. <br><br>  Por supuesto, llamar a ftrace desde <em>cada</em> función no es barato, por lo que la optimización está disponible para arquitecturas populares: <em>ftrace dinámico</em> .  La conclusión es que el núcleo conoce la ubicación de todas las llamadas a mcount () o __fentry __ () y en las primeras etapas de carga reemplaza su código de máquina con <strong>nop</strong> , una instrucción especial que no hace nada.  Cuando se incluye el rastreo en las funciones requeridas, se vuelven a agregar las llamadas ftrace.  Por lo tanto, si no se usa ftrace, su impacto en el sistema es mínimo. <br><br><h3>  Descripción de las funciones requeridas. </h3><br>  Cada función interceptada puede describirse mediante la siguiente estructura: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  El usuario debe completar solo los primeros tres campos: nombre, función, original.  Los campos restantes se consideran un detalle de implementación.  La descripción de todas las funciones interceptadas se puede ensamblar en una matriz y las macros se pueden usar para aumentar la compacidad del código: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br>  Las envolturas sobre las funciones interceptadas son las siguientes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   —  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Como puede ver, las funciones interceptadas con un mínimo de código adicional.  Lo único que requiere una atención cuidadosa son las firmas de funciones.  Deben coincidir uno a uno.  Sin esto, obviamente, los argumentos se pasarán incorrectamente y todo irá cuesta abajo.  Para interceptar llamadas del sistema, esto es menos importante, ya que sus manejadores son muy estables y, para mayor eficiencia, toman los argumentos en el mismo orden en que el sistema se llama a sí mismo.  Sin embargo, si planea interceptar otras funciones, debe recordar que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no hay interfaces estables dentro del núcleo</a> . <br><br><h3>  Inicialización de Ftrace </h3><br>  Primero, necesitamos encontrar y guardar la dirección de la función que vamos a interceptar.  Ftrace le permite rastrear funciones por nombre, pero aún necesitamos saber la dirección de la función original para poder llamarla. <br><br>  Puede obtener la dirección usando <em>kallsyms</em> , una lista de todos los caracteres en el núcleo.  Esta lista incluye <em>todos los</em> caracteres, no solo exportados para módulos.  Obtener la dirección de la función enganchada se parece a esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  A continuación, debe inicializar la estructura <code>ftrace_ops</code> .  Es vinculante <br>  el campo es simplemente <em>funcional</em> , lo que indica una devolución de llamada, pero también necesitamos <br>  establecer algunas banderas importantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> () es nuestra devolución de llamada que ftrace llamará al rastrear una función.  Sobre él más tarde.  Las banderas que establezcamos serán necesarias para completar la intercepción.  Indican a ftrace que guarde y restaure los registros del procesador, cuyo contenido podemos cambiar en la devolución de llamada. <br><br>  Ahora estamos listos para permitir la intercepción.  Para hacer esto, primero debe habilitar ftrace para la función que nos interese usando ftrace_set_filter_ip (), y luego permitir que ftrace llame a nuestra devolución de llamada usando register_ftrace_function (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  La intercepción se desactiva de manera similar, solo en el orden inverso: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br>  Una vez completada la llamada a unregister_ftrace_function (), se garantiza la ausencia de activaciones de la devolución de llamada instalada en el sistema (y con ella nuestros envoltorios).  Por lo tanto, podemos, por ejemplo, descargar con calma el módulo interceptor, sin temor a que en algún lugar del sistema nuestras funciones se sigan realizando (porque si desaparecen, el procesador se alterará). <br><br><h3>  Realizar un gancho de función </h3><br>  ¿Cómo se realiza realmente la intercepción?  Muy simple  Ftrace le permite cambiar el estado de los registros después de salir de una devolución de llamada.  Al cambiar el registro% rip, un puntero a la siguiente instrucción ejecutable, cambiamos las instrucciones que ejecuta el procesador, es decir, podemos forzarlo a ejecutar una transición incondicional de la función actual a la nuestra.  Así tomamos el control. <br><br>  La devolución de llamada para ftrace es la siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br>  Usando la macro container_of (), obtenemos la dirección de nuestra <code>struct ftrace_hook</code> en la dirección de la <code>struct ftrace_hook</code> incrustada en ella, después de lo cual reemplazamos el valor de registro% rip en la <code>struct pt_regs</code> estructura <code>struct pt_regs</code> con la dirección de nuestro controlador.  Eso es todo.  Para arquitecturas que no sean x86_64, este registro puede llamarse de manera diferente (como IP o PC), pero la idea es en principio aplicable a ellos. <br><br>  Tenga en cuenta el <strong>calificador de notrace</strong> agregado para la devolución de llamada.  Pueden marcar características que no se pueden rastrear con ftrace.  Por ejemplo, así es como se marcan las funciones de ftrace que están involucradas en el proceso de rastreo.  Esto ayuda a evitar que el sistema se congele en un bucle sin fin al rastrear todas las funciones en el núcleo (ftrace puede hacer esto). <br><br>  La devolución de llamada ftback generalmente llama con extrusión deshabilitada (como kprobes).  Puede haber excepciones, pero no debe confiar en ellas.  En nuestro caso, sin embargo, esta restricción no es importante, por lo que solo reemplazamos ocho bytes en la estructura. <br><br>  La función contenedora, que se llama más adelante, se ejecutará en el mismo contexto que la función original.  Por lo tanto, allí puede hacer lo que se permite hacer en la función interceptada.  Por ejemplo, si interceptas un controlador de interrupciones, aún no puedes dormir en un contenedor. <br><br><h3>  Protección de llamadas recursivas </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un problema en el código anterior: cuando nuestro contenedor llama a la función original, vuelve a entrar en ftrace, que nuevamente llama a nuestra devolución de llamada, que nuevamente transfiere el control al contenedor. Esta recursión infinita necesita ser interrumpida de alguna manera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma más elegante que se nos ocurrió es usar </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno de los argumentos de la devolución de llamada ftrace, que contiene la dirección de retorno a la función que llamó a la función rastreada. Por lo general, este argumento se usa para construir un gráfico de llamadas a funciones. Podemos usarlo para distinguir la primera llamada de la función interceptada de la repetida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, al volver a llamar</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe apuntar dentro de nuestro contenedor, mientras que al principio, en algún lugar en otro lugar del núcleo. </font><font style="vertical-align: inherit;">El control debe transferirse solo cuando se llama por primera vez a la función, a todos los demás se les debe permitir ejecutar la función original. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificación de entrada se puede realizar de manera muy eficiente comparando la dirección con los bordes del módulo actual (que contiene todas nuestras funciones). </font><font style="vertical-align: inherit;">Esto funciona muy bien si en el módulo solo el contenedor llama a la función interceptada. </font><font style="vertical-align: inherit;">De lo contrario, debe ser más selectivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En total, la devolución de llamada correcta de ftrace es la siguiente:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Características distintivas / ventajas de este enfoque: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bajo gastos generales. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo algunas restas y comparaciones. </font><font style="vertical-align: inherit;">Sin spinlocks, lista de pases, etc.</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos un ejemplo: escribió el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando ls</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la terminal </font><font style="vertical-align: inherit;">para ver una lista de archivos en el directorio actual. El shell (digamos Bash) usa un par tradicional de funciones </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () + </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> () de la biblioteca estándar C </font><font style="vertical-align: inherit;">para comenzar un nuevo proceso </font><font style="vertical-align: inherit;">. Internamente, estas funciones se implementan mediante las llamadas al sistema </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve (),</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respectivamente. Supongamos que interceptamos la llamada al sistema execve () para controlar el inicio de nuevos procesos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En forma gráfica, la intercepción de la función del controlador se ve así: </font></font><br><br><img alt="diagrama de secuencia de intercepción" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí vemos cómo el proceso del usuario ( </font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">azul</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) realiza una llamada del sistema al núcleo ( </font></font><font color="#EA6B66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rojo</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), donde el marco ftrace ( </font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">púrpura</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) llama a funciones desde nuestro módulo ( </font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verde</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de usuario ejecuta SYSCALL. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con esta instrucción, se transfiere el modo kernel y el control se transfiere al manejador de llamadas del sistema de bajo nivel: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (). </font><font style="vertical-align: inherit;">Es responsable de todas las llamadas al sistema de programas de 64 bits en núcleos de 64 bits.</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          —       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() —        sys_execve() —     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip —      —          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        — sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -… <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gerencia vuelve al núcleo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, fh_sys_execve () se completa y el control pasa a do_syscall_64 (), que considera que la llamada al sistema se completó como de costumbre. </font><font style="vertical-align: inherit;">El núcleo continúa su negocio nuclear.</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La gerencia vuelve al proceso del usuario. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, el núcleo ejecuta la instrucción IRET (o SYSRET, pero para execve () siempre es IRET), configurando registros para el nuevo proceso de usuario y poniendo el procesador central en modo de ejecución de código de usuario. </font><font style="vertical-align: inherit;">La llamada al sistema (y el inicio de un nuevo proceso) se completa.</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ventajas y desventajas. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, obtenemos una forma muy conveniente de interceptar cualquier función en el núcleo, que tiene las siguientes ventajas: </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   —   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La intercepción es compatible con el rastreo. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, este método no entra en conflicto con ftrace, por lo que aún puede tomar indicadores de rendimiento muy útiles del núcleo. </font><font style="vertical-align: inherit;">El uso de kprobes o empalmes puede interferir con los mecanismos de ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Cuáles son las desventajas de esta solución? </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos de configuración del kernel. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realizar con éxito enlaces de función utilizando ftrace, el núcleo debe proporcionar una serie de características:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de caracteres kallsyms para buscar funciones por nombre </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace framework en general para rastreo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace opciones de intercepción crítica </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> —      ,    «»  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doble llamada ftrace. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El enfoque de análisis de puntero descrito anteriormente </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da como resultado una llamada ftrace nuevamente para funciones enganchadas. </font><font style="vertical-align: inherit;">Esto agrega un poco de sobrecarga y puede derribar otros rastros que verán el doble de llamadas. </font><font style="vertical-align: inherit;">Este inconveniente se puede evitar aplicando un poco de magia negra: la llamada ftrace se encuentra al comienzo de la función, por lo que si la dirección de la función original se adelanta en 5 bytes (la longitud de la instrucción de llamada), puede saltar a través de ftrace.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere algunas de las desventajas con más detalle. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Requisitos de configuración del kernel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, el núcleo debe admitir ftrace y kallsyms. </font><font style="vertical-align: inherit;">Para hacer esto, las siguientes opciones deben estar habilitadas:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_FTRACE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ftrace debería soportar la modificación dinámica del registro. </font><font style="vertical-align: inherit;">La opción es responsable de esto.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, el núcleo utilizado debe estar basado en la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión 3.19 o superior</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para tener acceso al indicador FTRACE_OPS_FL_IPMODIFY. </font><font style="vertical-align: inherit;">Las versiones anteriores del kernel también pueden reemplazar el registro% rip, pero a partir de 3.19 esto debe hacerse solo después de configurar este indicador. </font><font style="vertical-align: inherit;">La presencia de un indicador para los núcleos antiguos conducirá a un error de compilación, y su ausencia para los nuevos generará una intercepción inactiva. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, para realizar la intercepción, la ubicación de la llamada ftrace dentro de la función es crítica: la llamada debe ubicarse al principio, antes del prólogo de la función (donde se asigna espacio para variables locales y se forma un marco de pila). </font><font style="vertical-align: inherit;">Esta característica de arquitectura se tiene en cuenta por la opción</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura x86_64 admite esta opción, pero el i386 no. </font><font style="vertical-align: inherit;">Debido a las limitaciones de la arquitectura i386, el compilador no puede insertar una llamada ftrace antes del prólogo de la función, por lo tanto, cuando se llama ftrace, la pila de funciones ya está modificada. </font><font style="vertical-align: inherit;">En este caso, para interceptar, no basta con cambiar el valor del registro% eip; también debe revertir todas las acciones realizadas en el prólogo que difieren de una función a otra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por esta razón, la intercepción de ftrace no es compatible con la arquitectura x86 de 32 bits. </font><font style="vertical-align: inherit;">En principio, podría implementarse usando cierta magia negra (generar y ejecutar un "antiprólogo"), pero la simplicidad técnica de la solución se verá afectada, que es una de las ventajas de usar ftrace.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sorpresas no obvias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante las pruebas, nos encontramos con una </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">característica</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interesante </font><font style="vertical-align: inherit;">: en algunas distribuciones, las funciones de enganche hicieron que el sistema se bloqueara fuertemente. Naturalmente, esto solo sucedió en sistemas distintos a los utilizados por los desarrolladores. El problema tampoco se reprodujo en el prototipo de intercepción original, con ninguna distribución y versiones de kernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La depuración mostró que el bloqueo ocurre dentro de la función interceptada. Por alguna razón mística, cuando se llamó a la función original dentro de la devolución de llamada ftrace, la dirección </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuó siendo especificada en el código del núcleo en lugar del código de la función de envoltura. Debido a esto, surgió un bucle sin fin, ya que ftrace llamó a nuestro contenedor una y otra vez sin realizar ninguna acción útil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, teníamos tanto código que funcionaba como roto, por lo que encontrar las diferencias era solo cuestión de tiempo. </font><font style="vertical-align: inherit;">Después de unificar el código y desechar todo lo innecesario, las diferencias entre las versiones se localizaron en una función de contenedor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta opción funcionó:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pero este - colgó el sistema: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo resulta que el nivel de registro afecta el comportamiento? Un estudio cuidadoso del código de máquina de las dos funciones rápidamente aclaró la situación y causó la sensación de que el compilador tenía la culpa. Por lo general, está en la lista de sospechosos en algún lugar cerca de los rayos cósmicos, pero esta vez no. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cosa, como resultó, es que las llamadas a pr_devel () se expanden en el vacío. Esta versión de la macro printk se utiliza para iniciar sesión durante el desarrollo. Tales entradas de registro no son interesantes durante la operación, por lo tanto, se cortan automáticamente del código si no se declara la macro DEBUG. Después de eso, la función para el compilador se convierte en esto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aquí la optimización entra en escena. </font><font style="vertical-align: inherit;">En este caso se trabajó denominadas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamadas de la cola de optimización</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimización de llamada de cola). </font><font style="vertical-align: inherit;">Permite que el compilador reemplace una llamada de función honesta con un salto directo a su cuerpo si una función llama a otra e inmediatamente devuelve su valor. </font><font style="vertical-align: inherit;">En el código de máquina, una llamada honesta se ve así:</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y no funciona, así: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera instrucción CALL es la misma llamada __fentry __ () insertada por el compilador al comienzo de todas las funciones. Pero luego, en el código normal, puede ver la llamada a real_sys_execve (mediante el puntero en la memoria) a través de la instrucción CALL y regresar desde fh_sys_execve () utilizando la instrucción RET. El código roto va a la función real_sys_execve () directamente usando JMP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La optimización de las llamadas de cola le permite ahorrar un poco de tiempo en la formación de un marco de pila "sin sentido", que incluye la dirección de retorno almacenada en la pila por la instrucción CALL. Sin embargo, para nosotros, la exactitud de la dirección del remitente desempeña un papel fundamental: la usamos </font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tomar una decisión sobre la intercepción. Después de la optimización, la función fh_sys_execve () ya no guarda la nueva dirección de retorno en la pila, queda la anterior, apuntando al núcleo. Por lo tanto</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continúa apuntando dentro del núcleo, lo que finalmente conduce a la formación de un bucle infinito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto también explica por qué el problema solo se reproduce en algunas distribuciones. Al compilar módulos, diferentes distribuciones usan diferentes conjuntos de indicadores de compilación. En distribuciones en dificultades, la optimización de llamadas de cola se habilitó de forma predeterminada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solución al problema para nosotros fue deshabilitar la optimización de llamadas de cola para todo el archivo con funciones de contenedor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2>  Conclusión </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué más puedo decir? Desarrollar código de bajo nivel para el kernel de Linux es divertido. </font><font style="vertical-align: inherit;">Espero que esta publicación le ahorre a alguien un poco de tiempo para elegir qué usar para escribir su mejor antivirus del mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea experimentar con la intercepción usted mismo, puede encontrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> código completo del módulo del núcleo </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">en Github</font></a><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413241/">https://habr.com/ru/post/es413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413231/index.html">Introducción a los contratos inteligentes</a></li>
<li><a href="../es413233/index.html">El servicio uLogin envía datos desde formularios (correo, teléfono) a un sitio de terceros y no dice nada al respecto.</a></li>
<li><a href="../es413235/index.html">Apuesta por mejores predicciones: nuevas matemáticas de pronósticos del tiempo</a></li>
<li><a href="../es413237/index.html">Facebook niega haber enviado a los fabricantes de dispositivos los mismos datos que el desarrollador Alexander Kogan</a></li>
<li><a href="../es413239/index.html">Cómo hacer que un teléfono inteligente sea un poco más tonto</a></li>
<li><a href="../es413243/index.html">School of Data: cómo combinar matemáticas y negocios</a></li>
<li><a href="../es413245/index.html">En equipos Dolby Atmos, solo sonido "nativo". Dolby prohíbe la mezcla ascendente no nativa</a></li>
<li><a href="../es413247/index.html">¿Por qué monitorear los sistemas de almacenamiento?</a></li>
<li><a href="../es413249/index.html">Escribir un módulo de kernel de Linux: I2C</a></li>
<li><a href="../es413251/index.html">Reacción en cadena de la polimerasa y Vladivostok</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>