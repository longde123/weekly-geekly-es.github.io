<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💈 ✴️ 👨🏽‍🚒 PEG解析器实现 👨🏿‍🍳 👞 👎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="仅出于对PEG的部分理解的启发，我决定尝试实施它。 结果可能不是通用PEG解析器中最好的-已有很多（例如，TatSu用Python编写并生成Python代码）-但这是理解PEG的好方法。 将来，我想将其替换为CPython中解析器的当前实现。 
 Python PEG解析器系列内容 

- 钉解析器...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PEG解析器实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471862/"><p> 仅出于对PEG的部分理解的启发，我决定尝试实施它。 结果可能不是通用PEG解析器中最好的-已有很多（例如，TatSu用Python编写并生成Python代码）-但这是理解PEG的好方法。 将来，我想将其替换为CPython中解析器的当前实现。 </p><br><div class="spoiler">  <b class="spoiler_title">Python PEG解析器系列内容</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">钉解析器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器实现</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器生成</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器可视化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">左递归PEG语法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向PEG语法添加动作</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEG解析器的元语法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施PEG的其余功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">核心开发者Sprint上的PEG</a> </li></ul></div></div><br><p> 在本节中，我使用上一篇文章中玩具语法的简单自写实现示例，为理解解析器的工作奠定了基础。 </p><a name="habracut"></a><br><p>  （顺便说一句，作为实验，我不会在文本中放置链接。如果您不了解某些内容，则可以在Google上搜索它。:-) </p><br><p>通常，PEG使用具有无限缓冲区的递归下降解析器返回。 这是上一篇文章的玩具语法： </p><br><pre><code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p> 该语言的递归下降的超抽象解析器将为将理解替代方案的每个规则定义其功能。 例如，对于<code>statement</code> ，我们将具有以下功能： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p> 当然，这是一个过于简单的示例：它忽略了重要的细节，例如，什么输入该函数的输入以及执行结果将是什么。 </p><br><p> 让我们从参数开始。 经典解析器使用单独的令牌生成器，它将输入（文本文件或行）拆分为一系列令牌，例如关键字，标识符（名称），数字和运算符。  PEG解析器（像其他现代解析器一样，如ANTLR）通常将令牌化和解析结合在一起，但是对于我的项目，我决定保留单独的令牌化器。 </p><br><p>  Python标记化非常复杂，因此我不想在PEG规则上实现它。 例如，您应该跟踪缩进（这需要在令牌生成器内部堆叠）； 用Python处理换行符也很有趣（除了包含在相应括号中的换行符，它们非常重要）。 许多类型的字符串也会引起一些复杂性。 简而言之，我对现有的Python标记器没有任何抱怨，因此我想保持现状。 顺便说一句，CPython有两个标记器：内部的一个由解析器使用，它是用C编写的，而标准的库是一个用纯Python实现的精确副本。 这将在我的项目中派上用场。 </p><br><p> 典型的令牌生成器通常具有一个简单的接口，该接口由单个<code>get_token()</code>函数组成。 每次，它返回输入序列中的下一个标记，分析一组字符。  CPython的<code>tokenize</code>模块也不例外：其核心API是一次生成一个令牌的生成器。 每个令牌都是<code>TypeInfo</code>类型的对象，该对象具有多个字段，其中最重要的是令牌的类型（例如<code>NAME</code> ， <code>NUMBER</code> ， <code>STRING</code> ），其字符串值是其组成的字符集（例如<code>abc</code> ， <code>42</code>或<code>"Hello, world"</code> 。 也有其他字段。 例如，对于输入流中的令牌索引，这在错误消息中很有用。 </p><br><p> 令牌的一种特殊类型是<code>ENDMARKER</code> ，它指示已到达输入文件的末尾。 如果您忽略生成器并尝试获取下一个令牌，则生成器将崩溃。 </p><br><p> 但是我分心了。 我们如何实现无限收益？ 回滚令牌列表要求您能够记住源代码中的位置并从该位置重新进行分析。  tokenizer API不允许我们移动其指针，但是您可以将令牌流捕获到数组中并从那里播放，我们将这样做。 您也可以使用<code>itertools.tee()</code>重复此操作，但是如果您查看文档中的警告，则在我们的情况下这可能不太有效。 </p><br><p> 我想您可以先标记所有输入到列表中，然后将其用作解析器的输入。 但是，如果文件末尾有一个无效的令牌（例如，结尾的引号缺失的行），并且文件中还存在语法错误，那么首先您将从令牌生成器收到一条错误消息。 我认为这对用户不利，因为语法错误可能是无效行的主要原因。 因此，我对令牌生成器的要求略有不同，特别是应将其实现为惰性列表。 </p><br><p> 核心API非常简单。 令牌生成器对象封装令牌数组和该数组中的位置。 他有三种主要方法： </p><br><ul><li>  <code>get_token()</code>返回下一个令牌，移动指针（或者，如果我们在令牌缓冲区的末尾，则从源中读取下一个令牌）； </li><li>  <code>mark()</code>返回缓冲区中的当前位置； </li><li>  <code>reset(pos)</code>设置缓冲区中的位置（必须从<code>mark()</code>获得参数）。 </li></ul><br><p> 我们添加了一个辅助函数<code>peek_token()</code> ，该函数返回下一个标记，而不移动缓冲区中的位置。 </p><br><p> 这是<code>Tokenizer</code>类的基础： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokengen)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Call with tokenize.generate_tokens(...)."""</span></span> self.tokengen = tokengen self.tokens = [] self.pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.pos = pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> token = self.peek_token() self.pos += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.pos == len(self.tokens): self.tokens.append(next(self.tokengen)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokens[self.pos]</code> </pre> <br><p> 这里，为简单起见，省略了一些内容（例如，方法和实例变量的名称必须以下划线开头），但这只是<code>Tokenizer</code> API的原型。 </p><br><p> 解析器还必须成为一个类，以便<code>statement()</code> ， <code>expr()</code>等。 可以实现为方法。 标记生成器将成为实例变量，但我不希望解析器方法直接调用<code>get_token()</code> -相反，我们在<code>Parser</code>类中实现了<code>wait()</code>方法，该方法可以像解析器方法一样成功或失败。  <code>wait()</code>函数的参数是预期的令牌：字符串（例如<code>+</code> ）或令牌的类型（例如<code>NAME</code> ）。 返回值的类型并不重要，我将在讨论解析器的工作结果之后再返回它。 </p><br><p> 现在让语法规则函数仅返回<code>True</code>或<code>False</code> 。 这对理论计算机科学很有用（解析器回答问题“这是语言中<em>的</em>有效字符串吗？”），但对我们而言不是。 我们的任务是创建一个AST。 因此，让我们重写此代码，以便每个分析方法成功时都返回<code>Node</code>对象，失败时则返回<code>None</code> 。 </p><br><p>  <code>Node</code>类可以非常简单： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, children)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.children = children</code> </pre> <br><p> 在这里， <code>type</code>确定AST节点的类型（例如， <code>add</code>或<code>if</code> ），后代是节点和令牌（ <code>TokenInfo</code>实例）的列表。 这足以使编译器生成代码或执行其他分析，例如整理或静态类型检查。 尽管将来我想更改AST的显示方式。 </p><br><p> 为了适合此方案， <code>expect()</code>方法必须在成功时返回<code>TokenInfo</code>对象，而在失败时返回<code>None</code> 。 为了能够回滚到以前的标记，我将对<code>mark()</code>和<code>reset()</code>方法的调用进行了包装（此处的API不变）。 这是发生了什么： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokenizer)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer = tokenizer <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.mark() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer.reset(pos) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, arg)</span></span></span><span class="hljs-function">:</span></span> token = self.tokenizer.peek_token() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.type == arg <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> token.string == arg: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.get_token() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p> 再一次：我省略了一些细节，但这已经是正常工作的代码。 </p><br><p> 现在，我需要介绍解析器方法的一项重要要求。 每个人都应该返回<code>Node</code> ，将令牌生成器放置在他们所识别的语法规则的最后一个令牌之后；  <code>None</code>或保留令牌生成器的位置不变。 如果解析器方法读取多个令牌然后掉落，则它必须恢复令牌生成器的位置。 为此，需要使用<code>mark()</code>和<code>reset()</code> 。 请注意， <code>expect()</code>也遵守此规则。 </p><br><p> 因此，这是实际解析器的草图。 在这里，我使用Python 3.8（ <code>:=</code> ）中的walrus运算符： </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a := self.assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i := self.if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t := self.term(): pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"+"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"-"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"sub"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Very similar... def atom(self): if token := self.expect(NAME): return token if token := self.expect(NUMBER): return token pos = self.mark() if self.expect("("): if e := self.expr(): if self.expect(")"): return e self.reset(pos) return None</span></span></code> </pre> <br><p> 我省略了一些方法的实现，以便读者有机会练习自己。 这确实比仅阅读有关如何实现这种解析器的方法更好。 最后，我们将根据语法自动生成此类代码。 常量（例如<code>NAME</code>和<code>NUMBER</code>是从标准库的<code>token</code>模块中导入的。 这进一步将我们与Python标记器的当前实现联系在一起。 如果我们要创建通用的PEG解析器，则必须找到避免这种情况的方法。 </p><br><p> 另请注意，我有点被骗。  <code>expr</code>方法必须为左递归，但我使解析器为右递归，因为递归下降解析器不适用于左递归语法规则。 这个问题可以解决，但仍然是一些科学研究的主题，我想单独谈一谈。 请记住，此实现与我们的简化语法并非100％一致。 </p><br><p> 到目前为止，我希望您理解的关键事项： </p><br><ul><li> 语法规则对应于解析器方法，当语法规则引用另一个规则时，它将调用另一个规则的方法。 </li><li> 当令牌的序列可以不同地解释时，相应的解析器方法将被依次调用。 </li><li> 当语法规则引用标记时，该方法将调用<code>expect()</code>函数。 </li><li> 如果解析器在当前位置成功识别出其语法规则，则返回相应的AST节点； 如果他不能识别语法规则，则返回<code>None</code> 。 </li><li> 解析器方法在使用一个或多个令牌（直接或间接调用另一种成功的解析方法）后停止解析时，应显式重置令牌生成器的位置。 这不仅适用于拒绝一个选项以继续进行下一个选项的情况，而且适用于整个分析都被拒绝的情况。 </li></ul><br><p> 如果所有解析方法都遵循这些规则，则无需将它们包装在<code>mark()</code>和<code>reset()</code>调用中。 这可以通过归纳证明。 </p><br><p> 此外，尝试使用上下文管理器和<code>with</code>语句摆脱对<code>mark()</code>和<code>reset()</code>的显式调用的尝试很诱人，但是它不起作用：如果成功，则不应调用<code>reset()</code> ！ 作为进一步的解决方案，您可以尝试对控制流使用异常，以便上下文管理器知道是否应重置令牌生成器（我认为TatSu正在执行类似的操作）。 例如，如下所示： </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assignment() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.expr() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.if_statement() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ParsingFailure</code> </pre> <br><p> 尤其是， <code>atom()</code>用于识别方括号中的表达式的<code>if</code>的小阶梯可以写成： </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): self.expect(<span class="hljs-string"><span class="hljs-string">"("</span></span>) e = self.expr() self.expect(<span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br><p> 但是在我看来，这也太“神奇了”-阅读此类代码时，您应该记住，每种解析方法（包括<code>wait()</code> ）都可能引发异常。 并且上下文管理器在<code>with</code>语句中捕获并忽略了此异常。 尽管可以实现（通过从<code>__exit__</code>返回<code>True</code> ），但这是非常不寻常的。 但是，我的最终目标是用C而不是Python生成代码，并且在C中没有<code>with</code>语句来更改控制流。 </p><br><p> 无论如何，这是以下部分的一些主题： </p><br><ul><li> 从语法生成解析器方法； </li><li>  packrat解析（记忆）； </li><li>  EBNF功能，例如<code>(x | y)</code> ， <code>[xy ...]</code> ， <code>x*</code> ， <code>x+</code> ; </li><li> 跟踪（用于调试解析器或语法）； </li><li>  PEG特性，例如前瞻和剪切； </li><li> 如何处理左递归规则； </li><li>  C代码生成 </li></ul><br><p> 本文和引用代码的许可： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471862/">https://habr.com/ru/post/zh-CN471862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471852/index.html">来自OpenStreetMap No.481的世界新闻（10/01/2019-07/10/2019）</a></li>
<li><a href="../zh-CN471854/index.html">热死5G</a></li>
<li><a href="../zh-CN471856/index.html">我们解决了所有42个版本的哈利波特魔药</a></li>
<li><a href="../zh-CN471858/index.html">RabbitMQ与Kafka：群集中的故障转移和高可用性</a></li>
<li><a href="../zh-CN471860/index.html">钉解析器</a></li>
<li><a href="../zh-CN471864/index.html">PEG解析器生成</a></li>
<li><a href="../zh-CN471866/index.html">PEG解析器可视化</a></li>
<li><a href="../zh-CN471872/index.html">C＃8中的接口：默认实现中的危险假设</a></li>
<li><a href="../zh-CN471874/index.html">我们如何绕过审核指南并在电话上启动服务器</a></li>
<li><a href="../zh-CN471876/index.html">PDU和所有所有功能：机架配电</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>