<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🍳 👩🏾‍🎓 🔀 IoT, Nebel und Wolken: Über Technologie sprechen? 🍌 💑 🗓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung von Technologien im Bereich Software und Hardware sowie die Einführung neuer Kommunikationsprotokolle haben zur Erweiterung des Intern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IoT, Nebel und Wolken: Über Technologie sprechen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cloud4y/blog/467711/"><img src="https://habrastorage.org/webt/e-/-2/xi/e--2xiob3rxaedvmvmjlklvkvoo.png"><br><br>  <i>Die Entwicklung von Technologien im Bereich Software und Hardware sowie die Einführung neuer Kommunikationsprotokolle haben zur Erweiterung des Internet der Dinge (IoT) geführt.</i>  <i>Die Anzahl der Geräte wächst von Tag zu Tag und sie generieren eine große Datenmenge.</i>  <i>Daher besteht ein Bedarf an einer bequemen Systemarchitektur, die diese Daten verarbeiten, speichern und übertragen kann.</i> <i><br><br></i>  <i>Jetzt nutzen sie Cloud-Dienste für diese Zwecke.</i>  <i>Das ständig wachsende Foggy-Paradigma (Fog) kann Cloud-Lösungen jedoch durch Skalierung und Optimierung der IoT-Infrastruktur ergänzen.</i> <a name="habracut"></a><br><br>  Clouds können die meisten IoT-Anforderungen schließen.  Zum Beispiel, um Überwachungsdienste bereitzustellen, eine schnelle Verarbeitung jeder von Geräten generierten Datenmenge sowie deren Visualisierung.  Misty Computing ist effektiver bei der Lösung von Echtzeitproblemen.  Sie bieten eine schnelle Antwort auf Anfragen und eine minimale Verzögerung bei der Datenverarbeitung.  Das heißt, Nebel ergänzt genau die "Wolken", erweitert seine Fähigkeiten. <br><br>  Die Hauptfrage ist jedoch anders: Wie sollte all dies im Kontext des IoT interagieren?  Welche Kommunikationsprotokolle sind am effektivsten, wenn Sie in einem einheitlichen IoT-Fog-Cloud-System arbeiten? <br><br>  Trotz der offensichtlichen Dominanz von HTTP verwenden IoT, Fog und Cloud eine Vielzahl anderer Lösungen.  Dies liegt daran, dass IoT die Funktionalität einer Vielzahl von Gerätesensoren mit der Sicherheit, Interoperabilität und anderen Benutzeranforderungen kombinieren muss. <br><br>  Hier ist nur eine einzige Vorstellung von der Referenzarchitektur und der Kommunikationsstandard ist einfach nicht da.  Daher ist die Erstellung eines neuen Protokolls oder die Verfeinerung eines vorhandenen Protokolls für bestimmte IoT-Aufgaben eine der wichtigsten Aufgaben der IT-Community. <br><br>  Welche Protokolle werden derzeit verwendet und was können sie bieten?  Lass es uns richtig machen.  Aber zuerst wollen wir die Prinzipien eines Ökosystems diskutieren, in dem Wolken, Nebel und das Internet der Dinge interagieren. <br><br><h3>  IoT Fog-to-Cloud-Architektur (F2C) </h3><br>  Sie müssen bemerkt haben, wie viel Aufwand darauf verwendet wurde, die Vorteile und den Nutzen einer rationalen und koordinierten Verwaltung von IoT, Wolken und Nebel zu untersuchen.  Wenn nicht, gibt es bereits drei Standardisierungsinitiativen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenFog Consortium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Edge Computing Consortium</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mF2C H2020 EU-Projekt</a> . <br><br>  Wenn früher nur 2 Ebenen, Clouds und Endgeräte berücksichtigt wurden, führt die vorgeschlagene Architektur eine neue Ebene ein - Fog Computing.  In diesem Fall kann der Nebelpegel in mehrere Unterebenen unterteilt werden, abhängig von den Besonderheiten der Ressourcen oder einer Reihe von Richtlinien, die die Verwendung verschiedener Geräte in diesen Unterebenen bestimmen. <br><br>  Wie könnte diese Abstraktion aussehen?  Hier ist ein typisches IoT-Fog-Cloud-Ökosystem.  IoT-Geräte senden Daten an leistungsfähigere Server und Computergeräte, um Aufgaben zu lösen, die eine geringe Latenz erfordern.  Im selben System sind Clouds für die Lösung von Problemen verantwortlich, die eine große Menge an Rechenressourcen oder Datenspeicherplatz erfordern. <br><br><img src="https://habrastorage.org/webt/b1/cr/tf/b1crtfzorujkb5afwoq2m-uwlua.png"><br><br>  Smartphones, Smartwatches und andere Geräte können ebenfalls Teil des IoT sein.  Solche Geräte verwenden jedoch in der Regel proprietäre Kommunikationsprotokolle großer Entwickler.  Die generierten IoT-Daten werden über das REST-HTTP-Protokoll an die Nebelebene übergeben, das Flexibilität und Interoperabilität beim Erstellen von RESTful-Diensten bietet.  Dies ist wichtig im Hinblick auf die Notwendigkeit der Abwärtskompatibilität mit der vorhandenen Computerinfrastruktur, die auf lokalen Computern, Servern oder einem Servercluster ausgeführt wird.  Lokale Ressourcen, die als "Knoten des Nebels" bezeichnet werden, filtern die empfangenen Daten und verarbeiten sie lokal oder senden sie zur weiteren Berechnung an die Cloud. <br><br>  Clouds unterstützen verschiedene Kommunikationsprotokolle, darunter AMQP und REST HTTP.  Da HTTP für das Internet bekannt und inhaftiert ist, kann sich die Frage stellen: "Aber sollte ich es verwenden, um mit IoT und Nebel zu arbeiten?".  Dieses Protokoll weist jedoch Leistungsprobleme auf.  Dazu später mehr. <br><br>  Im Allgemeinen gibt es zwei Modelle von Kommunikationsprotokollen, die für das von uns benötigte System geeignet sind.  Dies ist ein Anfrage-Antwort- und Publikationsabonnement.  Das erste Modell ist insbesondere in der Server-Client-Architektur bekannter.  Der Client fordert Informationen vom Server an, empfängt die Anforderung, verarbeitet sie und gibt eine Antwortnachricht zurück.  Die REST-HTTP- und CoAP-Protokolle funktionieren mit diesem Modell. <br><br>  Das zweite Modell entstand aufgrund der Notwendigkeit, eine asynchrone, verteilte, schwache Kommunikation zwischen den Quellen, die Daten erzeugen, und den Empfängern dieser Daten bereitzustellen. <br><br><img src="https://habrastorage.org/webt/jo/uh/ze/jouhzen4ifrik_e1pqtb9gtwtxa.png"><br><br>  Das Modell umfasst drei Teilnehmer: den Herausgeber (Datenquelle), den Broker (Dispatcher) und den Abonnenten (Empfänger).  Hier sollte der Client, der als Abonnent fungiert, keine Informationen vom Server anfordern.  Anstatt Anforderungen zu senden, abonniert er bestimmte Ereignisse im System über einen Broker, der dafür verantwortlich ist, alle eingehenden Nachrichten zu filtern und zwischen Herausgebern und Abonnenten weiterzuleiten.  Wenn der Herausgeber ein Ereignis zu einem bestimmten Thema eintritt, veröffentlicht er es an den Broker, der die Abonnentendaten zum angeforderten Thema sendet. <br><br>  Im Wesentlichen ist diese Architektur ereignisgesteuert.  Dieses Interaktionsmodell ist für Anwendungen in IoT, Cloud und Fog interessant, da es Skalierbarkeit bietet und die Verbindung zwischen verschiedenen Geräten vereinfacht, um dynamische Viele-zu-Viele-Kommunikation und asynchrone Kommunikation zu unterstützen.  Zu den bekanntesten standardisierten Messaging-Protokollen, die das Publish-Subscribe-Modell verwenden, gehören MQTT, AMQP und DDS. <br><br>  Offensichtlich hat das Publikations-Abonnement-Modell viele Vorteile: <br><br><ul><li>  Verleger und Abonnenten müssen nicht über die Existenz des anderen Bescheid wissen. </li><li>  Ein Abonnent kann Informationen aus vielen verschiedenen Veröffentlichungen empfangen, und ein Verlag kann Daten an viele verschiedene Abonnenten senden (das Prinzip „viele zu viele“). </li><li>  Der Herausgeber und der Abonnent müssen nicht gleichzeitig für den Datenaustausch aktiv sein, da der Broker (der als Warteschlangensystem arbeitet) eine Nachricht für Clients speichern kann, die derzeit nicht mit dem Netzwerk verbunden sind. </li></ul><br>  Das Request-Response-Modell hat jedoch auch seine eigenen Stärken.  In Fällen, in denen die Fähigkeiten der Serverseite zur Verarbeitung von Anforderungen mehrerer Clients kein Problem darstellen, ist es sinnvoll, bereits bewährte zuverlässige Lösungen zu verwenden. <br><br>  Es gibt auch Protokolle, die beide Modelle unterstützen.  Zum Beispiel XMPP und HTTP 2.0, die die Server-Push-Option unterstützen.  Die IETF hat auch CoAP veröffentlicht.  Um das Messaging-Problem zu lösen, wurden mehrere andere Lösungen erstellt, z. B. das WebSockets-Protokoll oder die Verwendung des HTTP-Protokolls über QUIC (Quick UDP Internet Connections). <br><br>  Im Fall von WebSockets ist es nicht für Geräte mit begrenzten Rechenressourcen vorgesehen, obwohl es für die Echtzeit-Datenübertragung vom Server zum Webclient verwendet wird und konstante Verbindungen bei gleichzeitiger bidirektionaler Kommunikation bietet.  QUIC verdient ebenfalls Aufmerksamkeit, da das neue Transportprotokoll viele neue Funktionen bietet.  Da QUIC jedoch noch nicht standardisiert ist, ist es verfrüht, seine mögliche Anwendung und Auswirkungen auf IoT-Lösungen vorherzusagen.  Wir lassen WebSockets und QUIC mit Blick auf die Zukunft im Gedächtnis, werden aber noch nicht näher darauf eingehen. <br><br><h3>  Wer auf der Welt ist am süßesten: Wir vergleichen Protokolle </h3><br>  Lassen Sie uns nun über die Stärken und Schwächen der Protokolle sprechen.  Mit Blick auf die Zukunft machen wir sofort einen Vorbehalt, dass es keinen klaren Führer gibt.  Jedes Protokoll hat einige Vor- und Nachteile. <br><br>  <b>Reaktionszeit</b> <br><br>  Eine der wichtigsten Eigenschaften von Kommunikationsprotokollen, insbesondere im Hinblick auf das Internet der Dinge, ist die Reaktionszeit.  Unter den vorhandenen Protokollen gibt es jedoch keine Besonderheit, die ein Mindestmaß an Verzögerung beim Arbeiten unter verschiedenen Bedingungen aufweist.  Es gibt jedoch eine ganze Reihe von Untersuchungen und Vergleichen der Protokollfunktionen. <br><br>  Beispielsweise zeigten die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnisse des</a> Vergleichs der Wirksamkeit von HTTP und MQTT bei der Arbeit mit IoT, dass die Antwortzeit für Anforderungen von MQTT geringer ist als die von HTTP.  Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Untersuchung der</a> Empfangs- und Sendezeit (RTT) von MQTT und CoAP stellte sich heraus, dass die durchschnittliche RTT-CoAP 20% unter der von MQTT liegt. <br><br>  Ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Experiment</a> mit RTT für die Protokolle MQTT und CoAP wurde in zwei Szenarien durchgeführt: einem lokalen Netzwerk und einem IoT-Netzwerk.  Es stellte sich heraus, dass die durchschnittliche RTT im IoT-Netzwerk 2-3 mal höher ist.  MQTT mit QoS0 zeigte im Vergleich zu CoAP ein niedrigeres Ergebnis, und MQTT mit QoS1 zeigte aufgrund von ACK auf Anwendungs- und Transportebene eine höhere RTT.  Für verschiedene QoS-Ebenen betrugen die Netzwerkverzögerungen ohne Überlastung für MQTT Millisekunden und für CoAP Hunderte von Mikrosekunden.  Es ist jedoch zu beachten, dass MQTT, das auf TCP ausgeführt wird, bei der Arbeit in weniger zuverlässigen Netzwerken ein anderes Ergebnis zeigt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Vergleich</a> der Antwortzeit für die AMQP- und MQTT-Protokolle durch Erhöhen der Nutzlast ergab, dass bei einer kleinen Last der Verzögerungspegel nahezu gleich ist.  Bei der Übertragung großer Datenmengen zeigt MQTT jedoch eine geringere Antwortzeit.  In einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie wurde</a> CoAP mit HTTP in einem Kommunikationsszenario von Maschine zu Maschine verglichen, wobei Geräte auf Fahrzeugen eingesetzt wurden, die mit Gassensoren, Wettersensoren, Standort (GPS) und einer Mobilfunknetzschnittstelle (GPRS) ausgestattet waren.  Die Zeit zum Senden einer CoAP-Nachricht über ein Mobilfunknetz war fast dreimal kürzer als die Zeit zum Verwenden von HTTP-Nachrichten. <br><br>  Es wurden Studien durchgeführt, in denen nicht zwei, sondern drei Protokolle verglichen wurden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleichen</a> Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Leistung der IoT-Protokolle MQTT, DDS und CoAP in einem medizinischen Anwendungsfall mithilfe eines Netzwerkemulators.  DDS übertraf MQTT in Bezug auf die erfahrene Telemetrie-Latenz unter verschiedenen schlechten Netzwerkbedingungen.  UDP-basiertes CoAP funktionierte gut für Anwendungen, die eine schnelle Antwort benötigten. Da es jedoch UDP-basiert war, gab es einen erheblichen unvorhersehbaren Paketverlust. <br><br>  <b>Durchsatz</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Vergleich von</a> MQTT und CoAP hinsichtlich der Bandbreitennutzung wurde als Berechnung der Gesamtmenge der pro Nachricht übertragenen Daten durchgeführt.  CoAP zeigte beim Senden kleiner Nachrichten weniger Bandbreite als MQTT.  Beim Vergleich der Wirksamkeit der Protokolle hinsichtlich des Verhältnisses der Anzahl nützlicher Informationsbytes zur Gesamtzahl der übertragenen Bytes war CoAP jedoch effektiver. <br><br>  Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyse der</a> Verwendung von MQTT, DDS (mit TCP als Transportprotokoll) und CoAP-Bandbreite stellte sich heraus, dass CoAP tendenziell einen relativ geringeren Bandbreitenverbrauch aufwies, der im Gegensatz zu einem Anstieg des Netzwerkpaketverlusts oder einer erhöhten Netzwerkverzögerung nicht zunahm MQTT und DDS, bei denen in den genannten Szenarien die Nutzung der Kanalkapazität zunahm.  In einem anderen Szenario übertrug eine große Anzahl von Geräten gleichzeitig Daten, was in IoT-Umgebungen ein typischer Fall ist.  Die Ergebnisse zeigten, dass es für eine höhere Last besser ist, CoAP zu verwenden. <br><br>  Bei geringer Last verwendete CoAP die geringste Bandbreite, gefolgt von MQTT und HTTP REST.  Wenn jedoch die Nutzlastgröße zunahm, erzielte REST-HTTP die besten Ergebnisse. <br><br>  <b>Stromverbrauch</b> <br><br>  Das Thema Energieverbrauch ist immer von großer Bedeutung, insbesondere im IoT-System.  Wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Stromverbrauch von MQTT und HTTP vergleichen, „frisst“ HTTP viel mehr.  Und CoAP ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">energieeffizienter</a> als MQTT, sodass Sie die Stromversorgung verwalten können.  Darüber hinaus eignet sich MQTT in einfachen Szenarien besser für den Informationsaustausch im Internet der Dinge, insbesondere wenn keine Leistungsbeschränkungen bestehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein weiteres</a> Experiment, bei dem die Funktionen von AMQP und MQTT auf einem Prüfstand für ein mobiles oder instabiles drahtloses Netzwerk verglichen wurden, zeigte, dass AMQP mehr Sicherheitsoptionen bietet, während MQTT energieeffizienter ist. <br><br>  <b>Sicherheit</b> <br><br>  Sicherheit ist ein weiteres wichtiges Thema, das beim Studium des Themas Internet der Dinge und Foggy / Cloud Computing angesprochen wird.  Der Sicherheitsmechanismus basiert normalerweise auf TLS in HTTP, MQTT, AMQP und XMPP, auf oder DTLS in CoAP und unterstützt auch beide Versionen von DDS. <br><br>  TLS und DTLS beginnen mit dem Aufbau der Kommunikation zwischen Client- und Serverseite, um unterstützte Cipher Suites und Schlüssel auszutauschen.  Beide Parteien verhandeln Kits, um sicherzustellen, dass die weitere Kommunikation in einem sicheren Kanal stattfindet.  Der Unterschied zwischen beiden besteht in kleinen Änderungen, die es UDP-basierten DTLS ermöglichen, über eine unzuverlässige Verbindung zu arbeiten. <br><br>  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testangriffen</a> auf mehrere verschiedene TLS- und DTLS-Implementierungen stellte sich heraus, dass TLS bessere Arbeit geleistet hat.  Die Angriffe auf DTLS waren aufgrund ihrer Fehlertoleranz erfolgreicher. <br><br>  Das größte Problem bei diesen Protokollen ist jedoch, dass sie ursprünglich nicht für die Verwendung im Internet der Dinge (IoT) entwickelt wurden und keine Arbeiten im Nebel oder in der Wolke beinhalteten.  Durch einen konsistenten Austausch (Handshake) fügen sie mit jeder Verbindung zusätzlichen Datenverkehr hinzu, wodurch die Rechenressourcen erschöpft werden.  Im Durchschnitt steigt die Arbeitslast für TLS um 6,5% und für DTLS um 11% im Vergleich zur Kommunikation ohne Sicherheitsstufe.  In ressourcenreichen Umgebungen, die normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud-</a> basiert sind, ist dies kein Problem, dies wird jedoch zu einer wichtigen Einschränkung zwischen dem IoT und der Nebelebene. <br><br>  Was soll ich wählen?  Es gibt keine eindeutige Antwort.  MQTT und HTTP scheinen die vielversprechendsten Protokolle zu sein, da sie im Vergleich zu anderen Protokollen als relativ ausgereiftere und stabilere Lösungen für IoT gelten. <br><br><h3>  Unified Communications-Protokolllösungen </h3><br>  Die Praxis einer Einzelprotokolllösung hat viele Nachteile.  Beispielsweise funktioniert ein Protokoll, das eine eingeschränkte Umgebung erfüllt, möglicherweise nicht in einer Domäne mit strengen Sicherheitsanforderungen.  Vor diesem Hintergrund müssen wir fast alle möglichen Lösungen, die auf einem Protokoll im Fog-to-Cloud-Ökosystem im IoT basieren, mit Ausnahme von MQTT und REST HTTP verwerfen. <br><br>  <b>REST HTTP als Einzelprotokolllösung</b> <br><br>  Es gibt ein gutes Beispiel für die Interaktion von IoT-zu-Nebel-REST-HTTP-Anforderungen und -Antworten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart Farm</a> .  Tiere sind mit tragbaren Sensoren (IoT-Client, C) ausgestattet und werden über Cloud Computing von einem Smart Farming-System (Fog Server, S) gesteuert. <br><br>  Der Titel der POST-Methode gibt die zu ändernde Ressource (/ Farm / Tiere) sowie die HTTP-Version und den Inhaltstyp an. In diesem Fall handelt es sich um ein JSON-Objekt, das die vom System zu verwaltende Tierfarm darstellt (Dulcinea / Kuh).  Eine Antwort vom Server zeigt an, dass die Anforderung erfolgreich war, indem ein HTTPS 201-Statuscode (Ressource erstellt) gesendet wurde.  Die GET-Methode sollte nur die angeforderte Ressource in der URI angeben (z. B. / farm / animal / 1), die die JSON-Darstellung des Tieres mit dieser Kennung vom Server zurückgibt. <br><br>  Die PUT-Methode wird verwendet, wenn Sie einen bestimmten Ressourceneintrag aktualisieren müssen.  In diesem Fall wird der URI in der Ressource für den zu ändernden Parameter und den aktuellen Wert angegeben (z. B. um anzuzeigen, dass die Kuh gerade läuft, / farm / animal / 1? State = walk).  Schließlich wird die DELETE-Methode gleichermaßen für die GET-Methode verwendet, löscht jedoch einfach die Ressource als Ergebnis der Operation. <br><br>  <b>MQTT als Einzelprotokolllösung</b> <br><br><img src="https://habrastorage.org/webt/ur/72/0u/ur720umujcr7x5dqvpju9ri72vs.png"><br><br>  Nehmen Sie dieselbe Smart Farm, aber anstelle von REST-HTTP verwenden wir das MQTT-Protokoll.  Der lokale Server mit der installierten Mosquitto-Bibliothek fungiert als Broker.  In diesem Beispiel dient ein einfacher Computer (als Farmserver bezeichnet) Raspberry Pi als MQTT-Client, der durch die Installation der MQTT Paho-Bibliothek implementiert wird, die vollständig mit dem Mosquitto-Broker kompatibel ist. <br><br>  Dieser Client entspricht der IoT-Abstraktionsschicht, die ein Gerät mit Erkennungs- und Rechenfunktionen darstellt.  Der Vermittler hingegen entspricht einer höheren Abstraktionsebene, die den Rechenknoten des Nebels darstellt, der sich durch große Leistung bei der Verarbeitung und Speicherung von Daten auszeichnet. <br><br>  Im vorgeschlagenen Smart Farm-Szenario stellt der Raspberry Pi eine Verbindung zu Beschleunigungsmesser, GPS und Temperatursensoren her und veröffentlicht Daten von diesen Sensoren im Nebelknoten.  Wie Sie wahrscheinlich wissen, behandelt MQTT Themen als Hierarchie.  Ein MQTT-Publisher kann bestimmte Themen veröffentlichen.  In unserem Fall gibt es drei davon.  Für einen Sensor, der die Temperatur in einem Tierstall misst, wählt der Kunde ein Thema (Tierfarm / Stall / Temperatur).  Für Sensoren, die den GPS-Standort und die Tierbewegung über den Beschleunigungsmesser messen, veröffentlicht der Client Aktualisierungen (Tierfarm / Tier / GPS) und (Tierfarm / Tier / Bewegung). <br><br>  Diese Informationen werden an den Broker übertragen, der sie vorübergehend in einer lokalen Datenbank speichern kann, falls später ein anderer interessierter Abonnent erscheint. <br><br>  Zusätzlich zu dem lokalen Server, der als MQTT-Broker im Nebel fungiert und an den Raspberry Pi als MQTT-Clients Daten von Sensoren sendet, gibt es möglicherweise einen weiteren MQTT-Broker auf Cloud-Ebene.  In diesem Fall können die an den lokalen Broker übertragenen Informationen vorübergehend in der lokalen Datenbank gespeichert und / oder an die Cloud gesendet werden.  Der neblige MQTT-Broker wird in dieser Situation verwendet, um alle Daten mit dem Cloud-MQTT-Broker zu verknüpfen.  Mit dieser Architektur kann ein Benutzer einer mobilen Anwendung beide Broker abonnieren. <br><br>  Bei einem Verbindungsfehler mit einem der Broker (z. B. Cloud) erhält der Endbenutzer Informationen von einem anderen (nebligen).  Dies ist ein Merkmal kombinierter Nebel- und Cloud-Computing-Systeme.  Standardmäßig kann die mobile Anwendung für die erste Verbindung zum nebligen MQTT-Broker und im Fehlerfall für die Verbindung zum MQTT-Broker in der Cloud konfiguriert werden.  Diese Lösung ist nur eine von vielen in IoT-F2C-Systemen. <br><br><h3>  Multiprotokoll-Lösungen </h3><br>  Einzelprotokolllösungen sind wegen ihrer einfacheren Implementierung beliebt.  Es ist jedoch offensichtlich, dass es in IoT-F2C-Systemen sinnvoll ist, verschiedene Protokolle zu kombinieren.  Der Punkt ist, dass verschiedene Protokolle auf verschiedenen Ebenen funktionieren können.  Nehmen Sie zum Beispiel drei Abstraktionen: IoT-, Nebel- und Cloud-Computing-Ebenen.  IoT-Geräte gelten im Allgemeinen als begrenzt.  Betrachten wir für diese Überprüfung die IoT-Ebenen als am begrenztesten, die Wolke als am wenigsten begrenzt und die Nebelberechnung als „irgendwo in der Mitte“.  Dann stellt sich heraus, dass zwischen IoT- und Nebelabstraktionen die aktuellen Protokollentscheidungen MQTT, CoAP und XMPP umfassen.  Auf der anderen Seite zwischen Nebel und Wolke ist AMQP neben HTTP REST eines der Hauptprotokolle, das aufgrund seiner Flexibilität auch zwischen IoT und Nebelschichten verwendet wird. <br><br>  Das Hauptproblem hierbei ist die Interoperabilität der Protokolle und die Einfachheit der Übersetzung von Nachrichten von einem Protokoll in ein anderes.  Idealerweise wird die Architektur des IoT-Systems mit Cloud- und Nebelressourcen in Zukunft unabhängig vom verwendeten Kommunikationsprotokoll sein und eine gute Interoperabilität zwischen verschiedenen Protokollen bieten. <br><br><img src="https://habrastorage.org/webt/yl/p7/xr/ylp7xrpyjurp0kczobbyoia62jk.jpeg"><br><br>  Da dies derzeit nicht der Fall ist, ist es sinnvoll, Protokolle zu kombinieren, die keine signifikanten Unterschiede aufweisen.  Zu diesem Zweck basiert eine mögliche Lösung auf einer Kombination von zwei Protokollen, die demselben Architekturstil entsprechen, REST HTTP und CoAP.  Eine andere vorgeschlagene Lösung basiert auf einer Kombination von zwei Protokollen, die eine Interaktion zwischen Veröffentlichung und Abonnement bieten, MQTT und AMQP.  Die Verwendung enger Konzepte (sowohl MQTT als auch AMQP verwenden Broker, CoAP und HTTP verwenden REST) ​​vereinfacht die Implementierung dieser Kombinationen und erfordert weniger Integrationsaufwand. <br><br><img src="https://habrastorage.org/webt/8p/sf/nf/8psfnfqz8nru91-zhamwpurr8ce.png"><br><br>  Abbildung (a) zeigt zwei Modelle basierend auf Request-Response, HTTP und CoAP, und deren mögliche Platzierung in der IoT-F2C-Lösung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da HTTP eines der bekanntesten und angepasstesten Protokolle in modernen Netzwerken ist, ist es unwahrscheinlich, dass es vollständig durch andere Messaging-Protokolle ersetzt wird. Unter den Knoten, die leistungsstarke Geräte zwischen Cloud und Nebel darstellen, ist HTTP REST eine intelligente Lösung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits ist die Verwendung von CoAP für Geräte mit begrenzten Computerressourcen, die zwischen Nebel und IoT kommunizieren, effizienter. Einer der großen Vorteile von CoAP ist die Kompatibilität mit HTTP, da beide Protokolle auf REST-Prinzipien basieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung (b) zeigt zwei Interaktionsmodelle zwischen Veröffentlichung und Abonnement in einem Szenario, einschließlich MQTT und AMQP. Obwohl hypothetisch beide Protokolle für die Kommunikation zwischen Knoten auf jeder Abstraktionsebene verwendet werden können, sollte ihre Position basierend auf der Leistung bestimmt werden. MQTT wurde als vereinfachtes Protokoll für Geräte mit begrenzten Rechenressourcen entwickelt, sodass es für die Kommunikation zwischen IoT und Nebel verwendet werden kann. AMQP eignet sich besser für leistungsstärkere Geräte, die es idealerweise zwischen den Knoten Nebel und Wolke positionieren. Anstelle von MQTT kann IoT das XMPP-Protokoll verwenden, da es als leichtgewichtig gilt. In solchen Szenarien ist es jedoch nicht so weit verbreitet.</font></font><br><br><h3>  Schlussfolgerungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist unwahrscheinlich, dass eines der berücksichtigten Protokolle ausreicht, um die gesamte Kommunikation im System abzudecken, angefangen bei Geräten mit begrenzten Rechenressourcen bis hin zu Cloud-Servern. Die Studie zeigte, dass die beiden vielversprechendsten Optionen, die Entwickler häufiger verwenden, MQTT und RESTful HTTP sind. Diese beiden Protokolle sind nicht nur die ausgereiftesten und stabilsten, sondern umfassen auch viele gut dokumentierte und erfolgreiche Implementierungen und Online-Ressourcen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund seiner Stabilität und einfachen Konfiguration ist MQTT ein Protokoll, das im Laufe der Zeit seine hervorragende Leistung bewiesen hat, wenn es auf IoT-Ebene mit begrenzten Geräten verwendet wird. </font><font style="vertical-align: inherit;">In Teilen des Systems, in denen eine eingeschränkte Kommunikation und ein begrenzter Batterieverbrauch kein Problem darstellen, z. B. in einigen Bereichen des Nebels und den meisten Cloud-Computing-Anwendungen, ist RESTful HTTP eine einfache Wahl. </font><font style="vertical-align: inherit;">CoAP sollte ebenfalls berücksichtigt werden, da es sich auch schnell als IoT-Messaging-Standard entwickelt und wahrscheinlich in naher Zukunft ein ähnliches Stabilitäts- und Reifegrad wie MQTT und HTTP erreichen wird. </font><font style="vertical-align: inherit;">Derzeit wird jedoch der Standard entwickelt, der mit kurzfristigen Kompatibilitätsproblemen verbunden ist.</font></font><br><br>  <b>Was sonst noch nützlich ist, lesen Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud4Y-</a> Blog</b> <br><br>  → Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer macht Sie lecker</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KI hilft bei der Untersuchung von Tieren in Afrika</a> <br>  → Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sommer ist fast vorbei.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es sind fast keine Daten durchgesickert</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4 Möglichkeiten zum Speichern von Backups in der Cloud</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf einer einzelnen Bundesinformationsressource, die Bevölkerungsinformationen enthält</font></font></a> <br><br>  Abonnieren Sie unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> , um keinen weiteren Artikel zu verpassen!  Wir schreiben nicht mehr als zweimal pro Woche und nur geschäftlich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467711/">https://habr.com/ru/post/de467711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467699/index.html">Wie man nicht die schnellste Kraft macht und einen Fehler in der Visual Studio 2019 Community findet</a></li>
<li><a href="../de467701/index.html">Kategorien statt Verzeichnisse. Ein Tool zur bequemen Speicherung von Dateien</a></li>
<li><a href="../de467703/index.html">IT Africa: Die interessantesten Technologieunternehmen und Startups des Kontinents</a></li>
<li><a href="../de467705/index.html">Paramagnons und Magnons: Energie aus Wärme</a></li>
<li><a href="../de467707/index.html">So konfigurieren Sie Linux für die Eingabe der Domäne mithilfe von GOST-Algorithmen</a></li>
<li><a href="../de467719/index.html">Eine Möglichkeit, den Sperrverlauf in PostgreSQL abzurufen</a></li>
<li><a href="../de467723/index.html">Kontrollpunkt Gaia R80.40. Was wird neu sein?</a></li>
<li><a href="../de467727/index.html">Hallo, SaaS | 2019 SaaS Trends von Blissfully</a></li>
<li><a href="../de467729/index.html">Chips oder fahren? Einzigartige Kleinigkeiten in Smartphones</a></li>
<li><a href="../de467733/index.html">Als Entwickler kenne ich nie meinen eigenen Wert, weil es keinen gibt. Aber das ganze System ist so aufgebaut, als ob es so wäre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>