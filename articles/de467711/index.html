<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüç≥ üë©üèæ‚Äçüéì üîÄ IoT, Nebel und Wolken: √úber Technologie sprechen? üçå üíë üóìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung von Technologien im Bereich Software und Hardware sowie die Einf√ºhrung neuer Kommunikationsprotokolle haben zur Erweiterung des Intern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IoT, Nebel und Wolken: √úber Technologie sprechen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cloud4y/blog/467711/"><img src="https://habrastorage.org/webt/e-/-2/xi/e--2xiob3rxaedvmvmjlklvkvoo.png"><br><br>  <i>Die Entwicklung von Technologien im Bereich Software und Hardware sowie die Einf√ºhrung neuer Kommunikationsprotokolle haben zur Erweiterung des Internet der Dinge (IoT) gef√ºhrt.</i>  <i>Die Anzahl der Ger√§te w√§chst von Tag zu Tag und sie generieren eine gro√üe Datenmenge.</i>  <i>Daher besteht ein Bedarf an einer bequemen Systemarchitektur, die diese Daten verarbeiten, speichern und √ºbertragen kann.</i> <i><br><br></i>  <i>Jetzt nutzen sie Cloud-Dienste f√ºr diese Zwecke.</i>  <i>Das st√§ndig wachsende Foggy-Paradigma (Fog) kann Cloud-L√∂sungen jedoch durch Skalierung und Optimierung der IoT-Infrastruktur erg√§nzen.</i> <a name="habracut"></a><br><br>  Clouds k√∂nnen die meisten IoT-Anforderungen schlie√üen.  Zum Beispiel, um √úberwachungsdienste bereitzustellen, eine schnelle Verarbeitung jeder von Ger√§ten generierten Datenmenge sowie deren Visualisierung.  Misty Computing ist effektiver bei der L√∂sung von Echtzeitproblemen.  Sie bieten eine schnelle Antwort auf Anfragen und eine minimale Verz√∂gerung bei der Datenverarbeitung.  Das hei√üt, Nebel erg√§nzt genau die "Wolken", erweitert seine F√§higkeiten. <br><br>  Die Hauptfrage ist jedoch anders: Wie sollte all dies im Kontext des IoT interagieren?  Welche Kommunikationsprotokolle sind am effektivsten, wenn Sie in einem einheitlichen IoT-Fog-Cloud-System arbeiten? <br><br>  Trotz der offensichtlichen Dominanz von HTTP verwenden IoT, Fog und Cloud eine Vielzahl anderer L√∂sungen.  Dies liegt daran, dass IoT die Funktionalit√§t einer Vielzahl von Ger√§tesensoren mit der Sicherheit, Interoperabilit√§t und anderen Benutzeranforderungen kombinieren muss. <br><br>  Hier ist nur eine einzige Vorstellung von der Referenzarchitektur und der Kommunikationsstandard ist einfach nicht da.  Daher ist die Erstellung eines neuen Protokolls oder die Verfeinerung eines vorhandenen Protokolls f√ºr bestimmte IoT-Aufgaben eine der wichtigsten Aufgaben der IT-Community. <br><br>  Welche Protokolle werden derzeit verwendet und was k√∂nnen sie bieten?  Lass es uns richtig machen.  Aber zuerst wollen wir die Prinzipien eines √ñkosystems diskutieren, in dem Wolken, Nebel und das Internet der Dinge interagieren. <br><br><h3>  IoT Fog-to-Cloud-Architektur (F2C) </h3><br>  Sie m√ºssen bemerkt haben, wie viel Aufwand darauf verwendet wurde, die Vorteile und den Nutzen einer rationalen und koordinierten Verwaltung von IoT, Wolken und Nebel zu untersuchen.  Wenn nicht, gibt es bereits drei Standardisierungsinitiativen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenFog Consortium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Edge Computing Consortium</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mF2C H2020 EU-Projekt</a> . <br><br>  Wenn fr√ºher nur 2 Ebenen, Clouds und Endger√§te ber√ºcksichtigt wurden, f√ºhrt die vorgeschlagene Architektur eine neue Ebene ein - Fog Computing.  In diesem Fall kann der Nebelpegel in mehrere Unterebenen unterteilt werden, abh√§ngig von den Besonderheiten der Ressourcen oder einer Reihe von Richtlinien, die die Verwendung verschiedener Ger√§te in diesen Unterebenen bestimmen. <br><br>  Wie k√∂nnte diese Abstraktion aussehen?  Hier ist ein typisches IoT-Fog-Cloud-√ñkosystem.  IoT-Ger√§te senden Daten an leistungsf√§higere Server und Computerger√§te, um Aufgaben zu l√∂sen, die eine geringe Latenz erfordern.  Im selben System sind Clouds f√ºr die L√∂sung von Problemen verantwortlich, die eine gro√üe Menge an Rechenressourcen oder Datenspeicherplatz erfordern. <br><br><img src="https://habrastorage.org/webt/b1/cr/tf/b1crtfzorujkb5afwoq2m-uwlua.png"><br><br>  Smartphones, Smartwatches und andere Ger√§te k√∂nnen ebenfalls Teil des IoT sein.  Solche Ger√§te verwenden jedoch in der Regel propriet√§re Kommunikationsprotokolle gro√üer Entwickler.  Die generierten IoT-Daten werden √ºber das REST-HTTP-Protokoll an die Nebelebene √ºbergeben, das Flexibilit√§t und Interoperabilit√§t beim Erstellen von RESTful-Diensten bietet.  Dies ist wichtig im Hinblick auf die Notwendigkeit der Abw√§rtskompatibilit√§t mit der vorhandenen Computerinfrastruktur, die auf lokalen Computern, Servern oder einem Servercluster ausgef√ºhrt wird.  Lokale Ressourcen, die als "Knoten des Nebels" bezeichnet werden, filtern die empfangenen Daten und verarbeiten sie lokal oder senden sie zur weiteren Berechnung an die Cloud. <br><br>  Clouds unterst√ºtzen verschiedene Kommunikationsprotokolle, darunter AMQP und REST HTTP.  Da HTTP f√ºr das Internet bekannt und inhaftiert ist, kann sich die Frage stellen: "Aber sollte ich es verwenden, um mit IoT und Nebel zu arbeiten?".  Dieses Protokoll weist jedoch Leistungsprobleme auf.  Dazu sp√§ter mehr. <br><br>  Im Allgemeinen gibt es zwei Modelle von Kommunikationsprotokollen, die f√ºr das von uns ben√∂tigte System geeignet sind.  Dies ist ein Anfrage-Antwort- und Publikationsabonnement.  Das erste Modell ist insbesondere in der Server-Client-Architektur bekannter.  Der Client fordert Informationen vom Server an, empf√§ngt die Anforderung, verarbeitet sie und gibt eine Antwortnachricht zur√ºck.  Die REST-HTTP- und CoAP-Protokolle funktionieren mit diesem Modell. <br><br>  Das zweite Modell entstand aufgrund der Notwendigkeit, eine asynchrone, verteilte, schwache Kommunikation zwischen den Quellen, die Daten erzeugen, und den Empf√§ngern dieser Daten bereitzustellen. <br><br><img src="https://habrastorage.org/webt/jo/uh/ze/jouhzen4ifrik_e1pqtb9gtwtxa.png"><br><br>  Das Modell umfasst drei Teilnehmer: den Herausgeber (Datenquelle), den Broker (Dispatcher) und den Abonnenten (Empf√§nger).  Hier sollte der Client, der als Abonnent fungiert, keine Informationen vom Server anfordern.  Anstatt Anforderungen zu senden, abonniert er bestimmte Ereignisse im System √ºber einen Broker, der daf√ºr verantwortlich ist, alle eingehenden Nachrichten zu filtern und zwischen Herausgebern und Abonnenten weiterzuleiten.  Wenn der Herausgeber ein Ereignis zu einem bestimmten Thema eintritt, ver√∂ffentlicht er es an den Broker, der die Abonnentendaten zum angeforderten Thema sendet. <br><br>  Im Wesentlichen ist diese Architektur ereignisgesteuert.  Dieses Interaktionsmodell ist f√ºr Anwendungen in IoT, Cloud und Fog interessant, da es Skalierbarkeit bietet und die Verbindung zwischen verschiedenen Ger√§ten vereinfacht, um dynamische Viele-zu-Viele-Kommunikation und asynchrone Kommunikation zu unterst√ºtzen.  Zu den bekanntesten standardisierten Messaging-Protokollen, die das Publish-Subscribe-Modell verwenden, geh√∂ren MQTT, AMQP und DDS. <br><br>  Offensichtlich hat das Publikations-Abonnement-Modell viele Vorteile: <br><br><ul><li>  Verleger und Abonnenten m√ºssen nicht √ºber die Existenz des anderen Bescheid wissen. </li><li>  Ein Abonnent kann Informationen aus vielen verschiedenen Ver√∂ffentlichungen empfangen, und ein Verlag kann Daten an viele verschiedene Abonnenten senden (das Prinzip ‚Äûviele zu viele‚Äú). </li><li>  Der Herausgeber und der Abonnent m√ºssen nicht gleichzeitig f√ºr den Datenaustausch aktiv sein, da der Broker (der als Warteschlangensystem arbeitet) eine Nachricht f√ºr Clients speichern kann, die derzeit nicht mit dem Netzwerk verbunden sind. </li></ul><br>  Das Request-Response-Modell hat jedoch auch seine eigenen St√§rken.  In F√§llen, in denen die F√§higkeiten der Serverseite zur Verarbeitung von Anforderungen mehrerer Clients kein Problem darstellen, ist es sinnvoll, bereits bew√§hrte zuverl√§ssige L√∂sungen zu verwenden. <br><br>  Es gibt auch Protokolle, die beide Modelle unterst√ºtzen.  Zum Beispiel XMPP und HTTP 2.0, die die Server-Push-Option unterst√ºtzen.  Die IETF hat auch CoAP ver√∂ffentlicht.  Um das Messaging-Problem zu l√∂sen, wurden mehrere andere L√∂sungen erstellt, z. B. das WebSockets-Protokoll oder die Verwendung des HTTP-Protokolls √ºber QUIC (Quick UDP Internet Connections). <br><br>  Im Fall von WebSockets ist es nicht f√ºr Ger√§te mit begrenzten Rechenressourcen vorgesehen, obwohl es f√ºr die Echtzeit-Daten√ºbertragung vom Server zum Webclient verwendet wird und konstante Verbindungen bei gleichzeitiger bidirektionaler Kommunikation bietet.  QUIC verdient ebenfalls Aufmerksamkeit, da das neue Transportprotokoll viele neue Funktionen bietet.  Da QUIC jedoch noch nicht standardisiert ist, ist es verfr√ºht, seine m√∂gliche Anwendung und Auswirkungen auf IoT-L√∂sungen vorherzusagen.  Wir lassen WebSockets und QUIC mit Blick auf die Zukunft im Ged√§chtnis, werden aber noch nicht n√§her darauf eingehen. <br><br><h3>  Wer auf der Welt ist am s√º√üesten: Wir vergleichen Protokolle </h3><br>  Lassen Sie uns nun √ºber die St√§rken und Schw√§chen der Protokolle sprechen.  Mit Blick auf die Zukunft machen wir sofort einen Vorbehalt, dass es keinen klaren F√ºhrer gibt.  Jedes Protokoll hat einige Vor- und Nachteile. <br><br>  <b>Reaktionszeit</b> <br><br>  Eine der wichtigsten Eigenschaften von Kommunikationsprotokollen, insbesondere im Hinblick auf das Internet der Dinge, ist die Reaktionszeit.  Unter den vorhandenen Protokollen gibt es jedoch keine Besonderheit, die ein Mindestma√ü an Verz√∂gerung beim Arbeiten unter verschiedenen Bedingungen aufweist.  Es gibt jedoch eine ganze Reihe von Untersuchungen und Vergleichen der Protokollfunktionen. <br><br>  Beispielsweise zeigten die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnisse des</a> Vergleichs der Wirksamkeit von HTTP und MQTT bei der Arbeit mit IoT, dass die Antwortzeit f√ºr Anforderungen von MQTT geringer ist als die von HTTP.  Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Untersuchung der</a> Empfangs- und Sendezeit (RTT) von MQTT und CoAP stellte sich heraus, dass die durchschnittliche RTT-CoAP 20% unter der von MQTT liegt. <br><br>  Ein weiteres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Experiment</a> mit RTT f√ºr die Protokolle MQTT und CoAP wurde in zwei Szenarien durchgef√ºhrt: einem lokalen Netzwerk und einem IoT-Netzwerk.  Es stellte sich heraus, dass die durchschnittliche RTT im IoT-Netzwerk 2-3 mal h√∂her ist.  MQTT mit QoS0 zeigte im Vergleich zu CoAP ein niedrigeres Ergebnis, und MQTT mit QoS1 zeigte aufgrund von ACK auf Anwendungs- und Transportebene eine h√∂here RTT.  F√ºr verschiedene QoS-Ebenen betrugen die Netzwerkverz√∂gerungen ohne √úberlastung f√ºr MQTT Millisekunden und f√ºr CoAP Hunderte von Mikrosekunden.  Es ist jedoch zu beachten, dass MQTT, das auf TCP ausgef√ºhrt wird, bei der Arbeit in weniger zuverl√§ssigen Netzwerken ein anderes Ergebnis zeigt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein Vergleich</a> der Antwortzeit f√ºr die AMQP- und MQTT-Protokolle durch Erh√∂hen der Nutzlast ergab, dass bei einer kleinen Last der Verz√∂gerungspegel nahezu gleich ist.  Bei der √úbertragung gro√üer Datenmengen zeigt MQTT jedoch eine geringere Antwortzeit.  In einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Studie wurde</a> CoAP mit HTTP in einem Kommunikationsszenario von Maschine zu Maschine verglichen, wobei Ger√§te auf Fahrzeugen eingesetzt wurden, die mit Gassensoren, Wettersensoren, Standort (GPS) und einer Mobilfunknetzschnittstelle (GPRS) ausgestattet waren.  Die Zeit zum Senden einer CoAP-Nachricht √ºber ein Mobilfunknetz war fast dreimal k√ºrzer als die Zeit zum Verwenden von HTTP-Nachrichten. <br><br>  Es wurden Studien durchgef√ºhrt, in denen nicht zwei, sondern drei Protokolle verglichen wurden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleichen</a> Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Leistung der IoT-Protokolle MQTT, DDS und CoAP in einem medizinischen Anwendungsfall mithilfe eines Netzwerkemulators.  DDS √ºbertraf MQTT in Bezug auf die erfahrene Telemetrie-Latenz unter verschiedenen schlechten Netzwerkbedingungen.  UDP-basiertes CoAP funktionierte gut f√ºr Anwendungen, die eine schnelle Antwort ben√∂tigten. Da es jedoch UDP-basiert war, gab es einen erheblichen unvorhersehbaren Paketverlust. <br><br>  <b>Durchsatz</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Vergleich von</a> MQTT und CoAP hinsichtlich der Bandbreitennutzung wurde als Berechnung der Gesamtmenge der pro Nachricht √ºbertragenen Daten durchgef√ºhrt.  CoAP zeigte beim Senden kleiner Nachrichten weniger Bandbreite als MQTT.  Beim Vergleich der Wirksamkeit der Protokolle hinsichtlich des Verh√§ltnisses der Anzahl n√ºtzlicher Informationsbytes zur Gesamtzahl der √ºbertragenen Bytes war CoAP jedoch effektiver. <br><br>  Bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analyse der</a> Verwendung von MQTT, DDS (mit TCP als Transportprotokoll) und CoAP-Bandbreite stellte sich heraus, dass CoAP tendenziell einen relativ geringeren Bandbreitenverbrauch aufwies, der im Gegensatz zu einem Anstieg des Netzwerkpaketverlusts oder einer erh√∂hten Netzwerkverz√∂gerung nicht zunahm MQTT und DDS, bei denen in den genannten Szenarien die Nutzung der Kanalkapazit√§t zunahm.  In einem anderen Szenario √ºbertrug eine gro√üe Anzahl von Ger√§ten gleichzeitig Daten, was in IoT-Umgebungen ein typischer Fall ist.  Die Ergebnisse zeigten, dass es f√ºr eine h√∂here Last besser ist, CoAP zu verwenden. <br><br>  Bei geringer Last verwendete CoAP die geringste Bandbreite, gefolgt von MQTT und HTTP REST.  Wenn jedoch die Nutzlastgr√∂√üe zunahm, erzielte REST-HTTP die besten Ergebnisse. <br><br>  <b>Stromverbrauch</b> <br><br>  Das Thema Energieverbrauch ist immer von gro√üer Bedeutung, insbesondere im IoT-System.  Wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Stromverbrauch von MQTT und HTTP vergleichen, ‚Äûfrisst‚Äú HTTP viel mehr.  Und CoAP ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">energieeffizienter</a> als MQTT, sodass Sie die Stromversorgung verwalten k√∂nnen.  Dar√ºber hinaus eignet sich MQTT in einfachen Szenarien besser f√ºr den Informationsaustausch im Internet der Dinge, insbesondere wenn keine Leistungsbeschr√§nkungen bestehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein weiteres</a> Experiment, bei dem die Funktionen von AMQP und MQTT auf einem Pr√ºfstand f√ºr ein mobiles oder instabiles drahtloses Netzwerk verglichen wurden, zeigte, dass AMQP mehr Sicherheitsoptionen bietet, w√§hrend MQTT energieeffizienter ist. <br><br>  <b>Sicherheit</b> <br><br>  Sicherheit ist ein weiteres wichtiges Thema, das beim Studium des Themas Internet der Dinge und Foggy / Cloud Computing angesprochen wird.  Der Sicherheitsmechanismus basiert normalerweise auf TLS in HTTP, MQTT, AMQP und XMPP, auf oder DTLS in CoAP und unterst√ºtzt auch beide Versionen von DDS. <br><br>  TLS und DTLS beginnen mit dem Aufbau der Kommunikation zwischen Client- und Serverseite, um unterst√ºtzte Cipher Suites und Schl√ºssel auszutauschen.  Beide Parteien verhandeln Kits, um sicherzustellen, dass die weitere Kommunikation in einem sicheren Kanal stattfindet.  Der Unterschied zwischen beiden besteht in kleinen √Ñnderungen, die es UDP-basierten DTLS erm√∂glichen, √ºber eine unzuverl√§ssige Verbindung zu arbeiten. <br><br>  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testangriffen</a> auf mehrere verschiedene TLS- und DTLS-Implementierungen stellte sich heraus, dass TLS bessere Arbeit geleistet hat.  Die Angriffe auf DTLS waren aufgrund ihrer Fehlertoleranz erfolgreicher. <br><br>  Das gr√∂√üte Problem bei diesen Protokollen ist jedoch, dass sie urspr√ºnglich nicht f√ºr die Verwendung im Internet der Dinge (IoT) entwickelt wurden und keine Arbeiten im Nebel oder in der Wolke beinhalteten.  Durch einen konsistenten Austausch (Handshake) f√ºgen sie mit jeder Verbindung zus√§tzlichen Datenverkehr hinzu, wodurch die Rechenressourcen ersch√∂pft werden.  Im Durchschnitt steigt die Arbeitslast f√ºr TLS um 6,5% und f√ºr DTLS um 11% im Vergleich zur Kommunikation ohne Sicherheitsstufe.  In ressourcenreichen Umgebungen, die normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud-</a> basiert sind, ist dies kein Problem, dies wird jedoch zu einer wichtigen Einschr√§nkung zwischen dem IoT und der Nebelebene. <br><br>  Was soll ich w√§hlen?  Es gibt keine eindeutige Antwort.  MQTT und HTTP scheinen die vielversprechendsten Protokolle zu sein, da sie im Vergleich zu anderen Protokollen als relativ ausgereiftere und stabilere L√∂sungen f√ºr IoT gelten. <br><br><h3>  Unified Communications-Protokolll√∂sungen </h3><br>  Die Praxis einer Einzelprotokolll√∂sung hat viele Nachteile.  Beispielsweise funktioniert ein Protokoll, das eine eingeschr√§nkte Umgebung erf√ºllt, m√∂glicherweise nicht in einer Dom√§ne mit strengen Sicherheitsanforderungen.  Vor diesem Hintergrund m√ºssen wir fast alle m√∂glichen L√∂sungen, die auf einem Protokoll im Fog-to-Cloud-√ñkosystem im IoT basieren, mit Ausnahme von MQTT und REST HTTP verwerfen. <br><br>  <b>REST HTTP als Einzelprotokolll√∂sung</b> <br><br>  Es gibt ein gutes Beispiel f√ºr die Interaktion von IoT-zu-Nebel-REST-HTTP-Anforderungen und -Antworten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart Farm</a> .  Tiere sind mit tragbaren Sensoren (IoT-Client, C) ausgestattet und werden √ºber Cloud Computing von einem Smart Farming-System (Fog Server, S) gesteuert. <br><br>  Der Titel der POST-Methode gibt die zu √§ndernde Ressource (/ Farm / Tiere) sowie die HTTP-Version und den Inhaltstyp an. In diesem Fall handelt es sich um ein JSON-Objekt, das die vom System zu verwaltende Tierfarm darstellt (Dulcinea / Kuh).  Eine Antwort vom Server zeigt an, dass die Anforderung erfolgreich war, indem ein HTTPS 201-Statuscode (Ressource erstellt) gesendet wurde.  Die GET-Methode sollte nur die angeforderte Ressource in der URI angeben (z. B. / farm / animal / 1), die die JSON-Darstellung des Tieres mit dieser Kennung vom Server zur√ºckgibt. <br><br>  Die PUT-Methode wird verwendet, wenn Sie einen bestimmten Ressourceneintrag aktualisieren m√ºssen.  In diesem Fall wird der URI in der Ressource f√ºr den zu √§ndernden Parameter und den aktuellen Wert angegeben (z. B. um anzuzeigen, dass die Kuh gerade l√§uft, / farm / animal / 1? State = walk).  Schlie√ülich wird die DELETE-Methode gleicherma√üen f√ºr die GET-Methode verwendet, l√∂scht jedoch einfach die Ressource als Ergebnis der Operation. <br><br>  <b>MQTT als Einzelprotokolll√∂sung</b> <br><br><img src="https://habrastorage.org/webt/ur/72/0u/ur720umujcr7x5dqvpju9ri72vs.png"><br><br>  Nehmen Sie dieselbe Smart Farm, aber anstelle von REST-HTTP verwenden wir das MQTT-Protokoll.  Der lokale Server mit der installierten Mosquitto-Bibliothek fungiert als Broker.  In diesem Beispiel dient ein einfacher Computer (als Farmserver bezeichnet) Raspberry Pi als MQTT-Client, der durch die Installation der MQTT Paho-Bibliothek implementiert wird, die vollst√§ndig mit dem Mosquitto-Broker kompatibel ist. <br><br>  Dieser Client entspricht der IoT-Abstraktionsschicht, die ein Ger√§t mit Erkennungs- und Rechenfunktionen darstellt.  Der Vermittler hingegen entspricht einer h√∂heren Abstraktionsebene, die den Rechenknoten des Nebels darstellt, der sich durch gro√üe Leistung bei der Verarbeitung und Speicherung von Daten auszeichnet. <br><br>  Im vorgeschlagenen Smart Farm-Szenario stellt der Raspberry Pi eine Verbindung zu Beschleunigungsmesser, GPS und Temperatursensoren her und ver√∂ffentlicht Daten von diesen Sensoren im Nebelknoten.  Wie Sie wahrscheinlich wissen, behandelt MQTT Themen als Hierarchie.  Ein MQTT-Publisher kann bestimmte Themen ver√∂ffentlichen.  In unserem Fall gibt es drei davon.  F√ºr einen Sensor, der die Temperatur in einem Tierstall misst, w√§hlt der Kunde ein Thema (Tierfarm / Stall / Temperatur).  F√ºr Sensoren, die den GPS-Standort und die Tierbewegung √ºber den Beschleunigungsmesser messen, ver√∂ffentlicht der Client Aktualisierungen (Tierfarm / Tier / GPS) und (Tierfarm / Tier / Bewegung). <br><br>  Diese Informationen werden an den Broker √ºbertragen, der sie vor√ºbergehend in einer lokalen Datenbank speichern kann, falls sp√§ter ein anderer interessierter Abonnent erscheint. <br><br>  Zus√§tzlich zu dem lokalen Server, der als MQTT-Broker im Nebel fungiert und an den Raspberry Pi als MQTT-Clients Daten von Sensoren sendet, gibt es m√∂glicherweise einen weiteren MQTT-Broker auf Cloud-Ebene.  In diesem Fall k√∂nnen die an den lokalen Broker √ºbertragenen Informationen vor√ºbergehend in der lokalen Datenbank gespeichert und / oder an die Cloud gesendet werden.  Der neblige MQTT-Broker wird in dieser Situation verwendet, um alle Daten mit dem Cloud-MQTT-Broker zu verkn√ºpfen.  Mit dieser Architektur kann ein Benutzer einer mobilen Anwendung beide Broker abonnieren. <br><br>  Bei einem Verbindungsfehler mit einem der Broker (z. B. Cloud) erh√§lt der Endbenutzer Informationen von einem anderen (nebligen).  Dies ist ein Merkmal kombinierter Nebel- und Cloud-Computing-Systeme.  Standardm√§√üig kann die mobile Anwendung f√ºr die erste Verbindung zum nebligen MQTT-Broker und im Fehlerfall f√ºr die Verbindung zum MQTT-Broker in der Cloud konfiguriert werden.  Diese L√∂sung ist nur eine von vielen in IoT-F2C-Systemen. <br><br><h3>  Multiprotokoll-L√∂sungen </h3><br>  Einzelprotokolll√∂sungen sind wegen ihrer einfacheren Implementierung beliebt.  Es ist jedoch offensichtlich, dass es in IoT-F2C-Systemen sinnvoll ist, verschiedene Protokolle zu kombinieren.  Der Punkt ist, dass verschiedene Protokolle auf verschiedenen Ebenen funktionieren k√∂nnen.  Nehmen Sie zum Beispiel drei Abstraktionen: IoT-, Nebel- und Cloud-Computing-Ebenen.  IoT-Ger√§te gelten im Allgemeinen als begrenzt.  Betrachten wir f√ºr diese √úberpr√ºfung die IoT-Ebenen als am begrenztesten, die Wolke als am wenigsten begrenzt und die Nebelberechnung als ‚Äûirgendwo in der Mitte‚Äú.  Dann stellt sich heraus, dass zwischen IoT- und Nebelabstraktionen die aktuellen Protokollentscheidungen MQTT, CoAP und XMPP umfassen.  Auf der anderen Seite zwischen Nebel und Wolke ist AMQP neben HTTP REST eines der Hauptprotokolle, das aufgrund seiner Flexibilit√§t auch zwischen IoT und Nebelschichten verwendet wird. <br><br>  Das Hauptproblem hierbei ist die Interoperabilit√§t der Protokolle und die Einfachheit der √úbersetzung von Nachrichten von einem Protokoll in ein anderes.  Idealerweise wird die Architektur des IoT-Systems mit Cloud- und Nebelressourcen in Zukunft unabh√§ngig vom verwendeten Kommunikationsprotokoll sein und eine gute Interoperabilit√§t zwischen verschiedenen Protokollen bieten. <br><br><img src="https://habrastorage.org/webt/yl/p7/xr/ylp7xrpyjurp0kczobbyoia62jk.jpeg"><br><br>  Da dies derzeit nicht der Fall ist, ist es sinnvoll, Protokolle zu kombinieren, die keine signifikanten Unterschiede aufweisen.  Zu diesem Zweck basiert eine m√∂gliche L√∂sung auf einer Kombination von zwei Protokollen, die demselben Architekturstil entsprechen, REST HTTP und CoAP.  Eine andere vorgeschlagene L√∂sung basiert auf einer Kombination von zwei Protokollen, die eine Interaktion zwischen Ver√∂ffentlichung und Abonnement bieten, MQTT und AMQP.  Die Verwendung enger Konzepte (sowohl MQTT als auch AMQP verwenden Broker, CoAP und HTTP verwenden REST) ‚Äã‚Äãvereinfacht die Implementierung dieser Kombinationen und erfordert weniger Integrationsaufwand. <br><br><img src="https://habrastorage.org/webt/8p/sf/nf/8psfnfqz8nru91-zhamwpurr8ce.png"><br><br>  Abbildung (a) zeigt zwei Modelle basierend auf Request-Response, HTTP und CoAP, und deren m√∂gliche Platzierung in der IoT-F2C-L√∂sung.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da HTTP eines der bekanntesten und angepasstesten Protokolle in modernen Netzwerken ist, ist es unwahrscheinlich, dass es vollst√§ndig durch andere Messaging-Protokolle ersetzt wird. Unter den Knoten, die leistungsstarke Ger√§te zwischen Cloud und Nebel darstellen, ist HTTP REST eine intelligente L√∂sung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits ist die Verwendung von CoAP f√ºr Ger√§te mit begrenzten Computerressourcen, die zwischen Nebel und IoT kommunizieren, effizienter. Einer der gro√üen Vorteile von CoAP ist die Kompatibilit√§t mit HTTP, da beide Protokolle auf REST-Prinzipien basieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung (b) zeigt zwei Interaktionsmodelle zwischen Ver√∂ffentlichung und Abonnement in einem Szenario, einschlie√ülich MQTT und AMQP. Obwohl hypothetisch beide Protokolle f√ºr die Kommunikation zwischen Knoten auf jeder Abstraktionsebene verwendet werden k√∂nnen, sollte ihre Position basierend auf der Leistung bestimmt werden. MQTT wurde als vereinfachtes Protokoll f√ºr Ger√§te mit begrenzten Rechenressourcen entwickelt, sodass es f√ºr die Kommunikation zwischen IoT und Nebel verwendet werden kann. AMQP eignet sich besser f√ºr leistungsst√§rkere Ger√§te, die es idealerweise zwischen den Knoten Nebel und Wolke positionieren. Anstelle von MQTT kann IoT das XMPP-Protokoll verwenden, da es als leichtgewichtig gilt. In solchen Szenarien ist es jedoch nicht so weit verbreitet.</font></font><br><br><h3>  Schlussfolgerungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist unwahrscheinlich, dass eines der ber√ºcksichtigten Protokolle ausreicht, um die gesamte Kommunikation im System abzudecken, angefangen bei Ger√§ten mit begrenzten Rechenressourcen bis hin zu Cloud-Servern. Die Studie zeigte, dass die beiden vielversprechendsten Optionen, die Entwickler h√§ufiger verwenden, MQTT und RESTful HTTP sind. Diese beiden Protokolle sind nicht nur die ausgereiftesten und stabilsten, sondern umfassen auch viele gut dokumentierte und erfolgreiche Implementierungen und Online-Ressourcen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund seiner Stabilit√§t und einfachen Konfiguration ist MQTT ein Protokoll, das im Laufe der Zeit seine hervorragende Leistung bewiesen hat, wenn es auf IoT-Ebene mit begrenzten Ger√§ten verwendet wird. </font><font style="vertical-align: inherit;">In Teilen des Systems, in denen eine eingeschr√§nkte Kommunikation und ein begrenzter Batterieverbrauch kein Problem darstellen, z. B. in einigen Bereichen des Nebels und den meisten Cloud-Computing-Anwendungen, ist RESTful HTTP eine einfache Wahl. </font><font style="vertical-align: inherit;">CoAP sollte ebenfalls ber√ºcksichtigt werden, da es sich auch schnell als IoT-Messaging-Standard entwickelt und wahrscheinlich in naher Zukunft ein √§hnliches Stabilit√§ts- und Reifegrad wie MQTT und HTTP erreichen wird. </font><font style="vertical-align: inherit;">Derzeit wird jedoch der Standard entwickelt, der mit kurzfristigen Kompatibilit√§tsproblemen verbunden ist.</font></font><br><br>  <b>Was sonst noch n√ºtzlich ist, lesen Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud4Y-</a> Blog</b> <br><br>  ‚Üí Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer macht Sie lecker</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KI hilft bei der Untersuchung von Tieren in Afrika</a> <br>  ‚Üí Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sommer ist fast vorbei.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es sind fast keine Daten durchgesickert</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4 M√∂glichkeiten zum Speichern von Backups in der Cloud</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf einer einzelnen Bundesinformationsressource, die Bev√∂lkerungsinformationen enth√§lt</font></font></a> <br><br>  Abonnieren Sie unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> , um keinen weiteren Artikel zu verpassen!  Wir schreiben nicht mehr als zweimal pro Woche und nur gesch√§ftlich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467711/">https://habr.com/ru/post/de467711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467699/index.html">Wie man nicht die schnellste Kraft macht und einen Fehler in der Visual Studio 2019 Community findet</a></li>
<li><a href="../de467701/index.html">Kategorien statt Verzeichnisse. Ein Tool zur bequemen Speicherung von Dateien</a></li>
<li><a href="../de467703/index.html">IT Africa: Die interessantesten Technologieunternehmen und Startups des Kontinents</a></li>
<li><a href="../de467705/index.html">Paramagnons und Magnons: Energie aus W√§rme</a></li>
<li><a href="../de467707/index.html">So konfigurieren Sie Linux f√ºr die Eingabe der Dom√§ne mithilfe von GOST-Algorithmen</a></li>
<li><a href="../de467719/index.html">Eine M√∂glichkeit, den Sperrverlauf in PostgreSQL abzurufen</a></li>
<li><a href="../de467723/index.html">Kontrollpunkt Gaia R80.40. Was wird neu sein?</a></li>
<li><a href="../de467727/index.html">Hallo, SaaS | 2019 SaaS Trends von Blissfully</a></li>
<li><a href="../de467729/index.html">Chips oder fahren? Einzigartige Kleinigkeiten in Smartphones</a></li>
<li><a href="../de467733/index.html">Als Entwickler kenne ich nie meinen eigenen Wert, weil es keinen gibt. Aber das ganze System ist so aufgebaut, als ob es so w√§re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>