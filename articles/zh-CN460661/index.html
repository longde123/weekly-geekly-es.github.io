<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥢 🏝️ 📖 您需要了解的所有关于Node.js的信息 ↪️ 🎤 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您呈现JorgeRamón的文章“您需要了解的有关Node.js的所有知识”的翻译。 





 如今，Node.js平台是用于构建高效且可扩展的REST API的最受欢迎的平台之一。 它还适用于构建混合移动应用程序，桌面程序，甚至用于物联网。 


 我已经使用Node.js平台超...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>您需要了解的所有关于Node.js的信息</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460661/"><p> 哈Ha！ 我向您呈现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JorgeRamón</a>的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“您需要了解的有关Node.js的所有知识”</a>的翻译。 </p><br><p><img src="https://habrastorage.org/webt/ua/qz/gr/uaqzgrarpig3cxhjdiuiutbxbms.jpeg"></p><br><p> 如今，Node.js平台是用于构建高效且可扩展的REST API的最受欢迎的平台之一。 它还适用于构建混合移动应用程序，桌面程序，甚至用于物联网。 </p><br><p> 我已经使用Node.js平台超过6年了，我真的很喜欢它。 这篇文章主要是试图作为Node.js实际工作方式的指南。 </p><a name="habracut"></a><br><p> 让我们开始吧！ </p><br><p>  <strong>将讨论什么：</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js之前的世界</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题C10K</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js和事件循环</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CPU密集型任务的问题</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工人及其流动</a> </li></ul><br><a name="p1"></a><br><h3 id="mir-do-nodejs">  Node.js之前的世界 </h3><br><p>  <strong>多线程服务器</strong> </p><br><p> 遵循客户机/服务器体系结构编写的Web应用程序的工作方式如下：客户机从服务器请求必要的资源，服务器作为响应发送资源。 在此方案中，服务器响应该请求并终止连接。 </p><br><p> 该模型之所以有效，是因为对服务器的每个请求都消耗资源（内存，处理器时间等）。 为了处理来自客户端的每个后续请求，服务器必须完成对前一个请求的处理。 </p><br><p> 这是否意味着服务器一次只能处理一个请求？ 真的不是！ 服务器收到新请求后，将创建一个单独的<strong>线程</strong>来处理它。 </p><br><p> 简而言之， <em>流程</em>是CPU分配用于执行一小段指令的时间和资源。 话虽如此，服务器一次只能处理多个请求，但每个线程只能处理一个。 这样的模型也称为<strong>每个请求线程模型</strong> 。 </p><br><p><img src="https://habrastorage.org/webt/mm/ns/gn/mmnsgnzvz7aptv62xrbo6zxju-w.jpeg"></p><br><p> 要处理N个请求，服务器需要N个线程。 如果服务器收到N + 1个请求，则它必须等待直到其中一个线程可用。 </p><br><p> 在上图中，服务器一次最多可以处理4个请求（线程），并且当它接收到接下来的3个请求时，这些请求必须等待，直到这4个线程中的任何一个可用为止。 </p><br><p> 摆脱限制的一种方法是向服务器添加更多资源（内存，处理器内核等），但这不是最佳解决方案...。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/qz/zl/ybqzzljzkgej-kirqwza-43amcw.gif"></div><br><p> 并且，当然，不要忘记技术限制。 </p><br><p>  <strong>阻止输入/输出</strong> </p><br><p> 服务器上有限数量的线程不是唯一的问题。 也许您想知道为什么单个线程不能同时处理多个请求？ 都是由于<strong>阻塞了I / O操作</strong> 。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ao/02/eiao02s-dtpki8au6sybf8-dmbu.gif"></div><br><p> 假设您正在开发在线商店，并且需要一个页面，用户可以在其中查看所有产品的列表。 </p><br><p> 用户敲了一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://yourstore.com/products</a> ，服务器作为响应，呈现了数据库中所有产品的HTML文件。 一点也不复杂，对吧？ </p><br><p> 但是幕后发生了什么？ </p><br><ul><li>用户敲开<code>/products</code>必须执行特定的方法或功能才能处理请求。 一小段代码（您或您的框架）解析请求URL，并寻找合适的方法或函数。  <strong>流正在运行</strong> 。 <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li> 现在，执行了所需的方法或函数，如第一段所述， <strong>线程开始工作。</strong> <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li> 由于您是一名优秀的开发人员，因此将所有系统日志保存到文件中，当然，要确保路由器执行所需的方法/功能，您还需要在“方法X执行中！”这一行中进行日志记录。输入/输出<strong>流正在等待</strong> 。 <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li> 保存所有日志，并执行以下功能行。  <strong>该线程再次工作</strong> 。 <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li> 是时候访问数据库并获取所有产品了-像<code>SELECT * FROM products</code>这样的简单查询就可以完成工作，但是您猜怎么着？ 是的，这是一个阻塞的I / O操作。  <strong>流正在等待</strong> 。 <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li> 您已经收到一个阵列或所有产品的列表，但是请确保已保证所有这些。  <strong>流正在等待</strong> 。 <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li> 现在您已经拥有了所有产品，现在该为将来的页面呈现模板了，但是在此之前，您需要阅读它们。  <strong>流正在等待</strong> 。 <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li> 呈现引擎完成其工作，并将响应发送给客户端。  <strong>该线程再次工作</strong> 。 <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li> 流是自由的，就像天空中的鸟。 <img width="20" src="https://habrastorage.org/webt/wr/vg/0_/wrvg0_hul5qltn9qpyg9fv6beua.png"></li></ul><br><p>  I / O操作有多慢？ 好吧，这取决于具体情况。 让我们看一下表格： </p><br><div class="scrollable-table"><table><tbody><tr><th>  <b>运作方式</b> </th><th>  <b>CPU周期</b> </th></tr><tr><td>  CPU寄存器 </td><td>  3项措施 </td></tr><tr><td>  L1快取 </td><td>  8项措施 </td></tr><tr><td>  L2快取 </td><td>  12项措施 </td></tr><tr><td> 内存 </td><td>  150措施 </td></tr><tr><td> 磁碟 </td><td>  30,000,000措施 </td></tr><tr><td> 联播网 </td><td>  250,000,000条 </td></tr></tbody></table></div><br><p> 网络和磁盘读取操作太慢。 想象一下，在这段时间内您的系统可以处理多少个外部API请求或调用。 </p><br><p> 总结一下：I / O操作使线程等待并浪费资源。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/qm/k1/bgqmk13cgzyfg7vmynzpkxdxbdc.gif"></div><br><a name="p2"></a><br><h3 id="problema-c10k"> 问题C10K </h3><br><p>  <strong>问题</strong> </p><br><p>  <b>C10k</b> （英文<i>C10k； 10k个连接</i> -1万个连接问题） </p><br><p> 在2000年代初期，服务器和客户端计算机运行缓慢。 当并行处理与同一台计算机的10,000个客户端连接时，就会出现此问题。 </p><br><p> 但是，为什么传统的“每请求线程数”模型（按请求线程数）无法解决此问题？ 好吧，让我们使用一些数学。 </p><br><p> 线程的本机实现为每个流分配超过1 MB的内存，剩下的-对于1万个线程，需要10 GB的RAM，这仅用于流堆栈。 是的，不要忘记，我们处于2000年代初期！ </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/99/xc/af99xcxnykot0wq-zv20o-6cvps.jpeg"></div><br><p> 如今，服务器和客户端计算机可以更快，更高效地工作，几乎任何编程语言或框架都可以解决此问题。 但实际上，问题尚未解决。 对于与一台计算机的一千万个客户端连接，问题再次出现（但现在是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C10M Problem</a> ）。 </p><br><p>  <strong>JavaScript救援？</strong> </p><br><p> 小心扰流板 <img width="70" src="https://habrastorage.org/webt/vl/iw/8n/vliw8nxrmg8paobiiyvuozjxpdc.png">  !!! <br>  Node.js实际上解决了C10K问题...但是如何呢？ </p><br><p> 在2000年代初期，服务器端JavaScript并不是什么新奇的东西，当时，已经有基于JVM（java虚拟机）的实现-RingoJS和AppEngineJS，它们可以按请求的线程模型工作。 </p><br><p> 但是，如果他们不能解决问题，那么Node.js怎么可能？ 都是因为JavaScript是<strong>单线程的</strong> 。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/nx/vh/lpnxvhxjbmqmkzmblpqqmfcxq0s.gif"></div><br><a name="p3"></a><br><h3 id="nodejs-i-cikl-sobytiy">  Node.js和事件循环 </h3><br><p>  <strong>Node.js</strong> </p><br><p>  Node.js是运行在Google Chrome引擎-V8上的服务器平台，可以将JavaScript代码编译为机器代码。 </p><br><p>  Node.js使用<strong>事件驱动</strong>模型和<strong>无阻塞I / O</strong>架构，这使其轻巧高效。 这不是框架，也不是库，它是JavaScript运行时。 </p><br><p> 让我们写一个小例子： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Importing native http module const http = require('http'); // Creating a server instance where every call // the message 'Hello World' is responded to the client const server = http.createServer(function(request, response) { response.write('Hello World'); response.end(); }); // Listening port 8080 server.listen(8080);</span></span></code> </pre> <br><p>  <strong>非阻塞I / O</strong> </p><br><p>  Node.js使用非阻塞输入/输出操作，这意味着什么： </p><br><ul><li> 主线程不会被I / O操作阻塞。 </li><li> 服务器将继续处理请求。 </li><li> 我们将不得不使用<strong>异步代码</strong> 。 </li></ul><br><p> 让我们写一个示例，其中服务器发送HTML页面以响应对<code>/home</code>的请求，并响应所有其他请求-“ Hello World”。 要发送HTML页面，您必须首先从文件中读取它。 </p><br><p> <code>home.html</code> </p> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>This is home page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.url === <span class="hljs-string"><span class="hljs-string">'/home'</span></span>) { fs.readFile(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ __dirname }</span></span></span><span class="hljs-string">/home.html`</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>); response.write(content); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'An error has ocurred'</span></span>); } response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.write(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p> 如果请求的URL是<code>/home</code> ，则使用本机<code>fs</code>模块读取<code>home.html</code>文件。 </p><br><p> 作为参数属于<code>http.createServer</code>和<code>fs.readFile</code>函数是<strong>回调</strong> 。 这些功能将在将来的某个时候执行（第一个功能，服务器收到请求后，第二个功能，从磁盘读取文件并将其放置在缓冲区中）。 </p><br><p> 从磁盘读取文件时，Node.js可以处理其他请求，甚至可以在一个流中再次读取文件以及所有这些信息……但是如何？ </p><br><p>  <strong>事件循环</strong> </p><br><p>  <strong>事件循环</strong>是Node.js内部发生的魔术。 这实际上是一个无限循环，实际上是一个线程。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/sc/go/f_scgo68j5gpf0xsnzklzdr9cjc.jpeg"></div><br><p>  <strong>Libuv</strong>是实现此模式的C库，它是Node.js内核的一部分。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>了解有关libuv的更多信息。 </p><br><p> 一个事件周期有6个阶段，所有6个阶段的每次执行都称为<strong>tick</strong> 。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2k/xy/eq/2kxyeqk7srzdocs9egzl5zlpwhm.png"></div><br><ul><li>  <strong>timers</strong> ：在此阶段，执行由<code>setTimeout()</code>和<code>setInterval()</code>方法安排的回调； </li><li>  <strong>待处理的回调</strong> ：几乎执行所有<strong>回调</strong> ，但<code>close</code>事件，计时器和<code>setImmediate()</code> ； </li><li>  <strong>空闲，准备</strong> ：仅用于内部目的； </li><li>  <strong>poll</strong> ：负责接收新的I / O事件。 此时，Node.js可能会阻塞； </li><li>  <strong>check</strong> ：由<code>setImmediate()</code>方法引起的回调在此阶段执行； </li><li>  <strong>close回调</strong> ：例如<code>socket.on('close', ...)</code> ; </li></ul><br><p> 好吧，只有一个线程，而这个线程是一个事件循环，但是谁来执行所有的I / O？ </p><br><p> 注意一下 <img width="60" src="https://habrastorage.org/webt/92/8i/lj/928iljyzpqhkbczypvvqgkx0zc0.png">  !!! <br> 当事件循环需要执行I / O操作时，它将使用线程池中的OS线程，并且当任务完成时，回调将在<em>挂起的回调</em>阶段排队。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/z7/uw/lzz7uwcdvm1xd1yr6utj7cae36g.png"></div><br><p> 那不是很酷吗？ </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/yo/bh/ityobhc10qgnkk5m9yk5xp94ble.gif"></div><br><a name="p4"></a><br><h3 id="problema-cpu-yomkih-zadach">  CPU密集型任务的问题 </h3><br><p>  Node.js看起来很完美！ 您可以创建任何您想要的东西。 </p><br><p> 让我们编写一个用于计算质数的API。 </p><br><p> 质数是一个大于1的整数（自然数），只能被1整除。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/kn/7f/nlkn7fwr_kxhtktm-_gt0ci7ask.jpeg"></div><br><p> 给定数字N，API应该计算并返回列表（或数组）中的前N个素数。 </p><br><p> <code>primes.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { isPrime, nthPrime };</code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> primes = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./primes'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = primes.nthPrime(query.n || <span class="hljs-number"><span class="hljs-number">0</span></span>); response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  <code>prime.js</code>是必要计算的实现： <code>prime.js</code>函数检查数字是否为质数，nthPrime返回N个此类数字。 </p><br><p>  <code>index.js</code>文件负责创建服务器，并使用<code>prime.js</code>模块处理对<code>/primes</code> <code>prime.js</code>每个请求。  URL中的查询字符串会引发数字N。 </p><br><p> 要获得前20个素数，我们需要向<code>http://localhost:8080/primes?n=20</code>发出请求。 </p><br><p> 假设我们有3个客户敲诈我们并尝试访问我们的非阻塞I / O API： </p><br><ul><li> 第一个查询每秒查询5个素数。 </li><li> 第二个每秒请求1000个素数 </li><li> 第三个请求10,000,000,000个素数，但是... </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/rx/bl/pzrxblziplf06w7-kzbyojhafhg.gif"></div><br><p> 当第三个客户端发送请求时，主线程被阻塞，这是<strong>CPU密集型任务</strong>问题的主要症状。 当主线程忙于执行“繁重”任务时，其他任务将无法访问它。 </p><br><p> 但是libuv呢？ 如果您还记得，这个库可以帮助Node.js使用OS线程执行输入/输出操作，避免阻塞主线程，您绝对是对的，这是解决我们问题的方法，但是为此，我们的模块必须使用以下语言编写： C ++，因此libuv可以使用它。 </p><br><p> 幸运的是，从v10.5开始，本机<strong>Worker Threads</strong>模块已添加到Node.js。 </p><br><a name="p5"></a><br><h3 id="vorkery-i-ih-potoki"> 工人及其流动 </h3><br><p> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档所示</a> ： </p><br><blockquote> 辅助程序对于执行CPU密集型JavaScript操作非常有用； 不要将它们用于输入/输出操作，Node.js中已经内置的机制比Worker线程更有效地处理此类任务。 </blockquote><p>  <strong>代码修复</strong> </p><br><p> 现在是时候重写我们的代码了： </p><br><p> <code>primes-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } parentPort.postMessage(nthPrime(workerData.n));</code> </pre> <br><p> <code>index-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-string"><span class="hljs-string">'./primes-workerthreads.js'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">n</span></span>: query.n || <span class="hljs-number"><span class="hljs-number">0</span></span> } }); worker.on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Oops there was an error...'</span></span>); response.end(); }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; worker.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ result = message; }); worker.on(<span class="hljs-string"><span class="hljs-string">'exit'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p> 在<code>index-workerthreads.js</code> ，对<code>/primes</code>每个请求都会创建<code>Worker</code>类的实例（来自本机模块<code>worker_threads</code> ），以将<code>primes-workerthreads.js</code>文件上载并执行到worker线程中。 当准备好素数列表时，将触发<code>message</code>事件-由于工作人员没有工作，结果落入了主流，他还触发了<code>exit</code>事件，从而使主流可以将数据发送到客户端。 </p><br><p>  <code>primes-workerthreads.js</code>有所更改。 它导入<code>workerData</code> （这是从主线程传递来的参数的副本）和<code>parentPort</code>通过它们工人的工作结果将被传递回主线程。 </p><br><p> 现在，让我们再次尝试我们的示例，看看会发生什么： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/vk/gh/zuvkghy8dnhjryfdf5b62ped8dw.gif"></div><br><p> 主线程不再被阻塞 <img width="115" src="https://habrastorage.org/webt/nn/hs/r3/nnhsr3jiw_4aed53jye8gokutpy.png">  !!!!! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/ij/el/ttijelgt36k_vbengx3qjaaajlc.gif"></div><br><p> 现在一切正常，但是无缘无故地生产工人仍然不是一种好习惯；创建线程并不是一种廉价的乐趣。 确保在此之前创建线程池。 </p><br><h4 id="zaklyuchenie"> 结论 </h4><br><p>  Node.js是一项强大的技术，应尽可能地对其进行探索。 <br> 我的个人建议-总是好奇！ 如果您知道内部是如何工作的，则可以更有效地使用它。 </p><br><p> 今天的家伙就这些了。 希望本文对您有所帮助，并且您了解了有关Node.js的新知识。 </p><br><p> 感谢您的阅读，在接下来的文章中见。 <img width="20" src="https://habrastorage.org/webt/bd/lk/kd/bdlkkdf7adtljydvhxyw22y3cfi.png">  。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460661/">https://habr.com/ru/post/zh-CN460661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460645/index.html">做坏事：使用Go编写邪恶代码，第1部分</a></li>
<li><a href="../zh-CN460647/index.html">使用pwnable.kr 05-密码解决作业。 通过格式字符串漏洞重写过程链接表</a></li>
<li><a href="../zh-CN460651/index.html">匿名测试人员协会会议：TMS，监视监视，搜索质量评估和本地iOS测试</a></li>
<li><a href="../zh-CN460655/index.html">我如何打破电报</a></li>
<li><a href="../zh-CN460659/index.html">使用管道进行旋转</a></li>
<li><a href="../zh-CN460665/index.html">FAQ草案：为什么C ++标准每三年发布一次？</a></li>
<li><a href="../zh-CN460667/index.html">在iOS上自动测试付费服务</a></li>
<li><a href="../zh-CN460669/index.html">如何确保开发的安全性，节省时间和神经</a></li>
<li><a href="../zh-CN460671/index.html">D的所有权和借款</a></li>
<li><a href="../zh-CN460673/index.html">展现DiffUtil的魔力</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>