<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîª üêª üëï Detectores y descriptores de puntos singulares R√ÅPIDO, BREVE, ORB üç• üë©üèª‚Äçü§ù‚Äçüë®üèº ü§òüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo se centrar√° en algunos algoritmos de b√∫squeda y descripciones de puntos de imagen espec√≠ficos. Aqu√≠ este tema ya se ha planteado , y m√°s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detectores y descriptores de puntos singulares R√ÅPIDO, BREVE, ORB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414459/">  Este art√≠culo se centrar√° en algunos algoritmos de b√∫squeda y descripciones de puntos de imagen espec√≠ficos.  Aqu√≠ este tema ya se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">planteado</a> , y m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de una vez</a> .  Considerar√© que las definiciones b√°sicas ya son familiares para el lector, examinaremos en detalle los algoritmos heur√≠sticos FAST, FAST-9, FAST-ER, BRIEF, rBRIEF, ORB, y discutiremos las ideas brillantes subyacentes.  En parte, esta ser√° una traducci√≥n gratuita de la esencia de varios art√≠culos [1, 2, 3, 4, 5], habr√° alg√∫n c√≥digo para "probar". <br><br><img src="https://pp.userapi.com/c846418/v846418322/73b6d/09CAYMQuFMs.jpg" alt="imagen"><br><a name="habracut"></a><br><h1>  Algoritmo R√ÅPIDO </h1><br>  FAST, propuesto por primera vez en 2005 en [1], fue uno de los primeros m√©todos heur√≠sticos para encontrar puntos singulares, que gan√≥ gran popularidad debido a su eficiencia computacional.  Para tomar una decisi√≥n sobre si considerar un punto C dado como especial o no, este m√©todo considera el brillo de los p√≠xeles en un c√≠rculo centrado en el punto C y el radio 3: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5559/qPxNkhmqJSU.jpg" alt="imagen"><br><br>  Comparando el brillo de los p√≠xeles del c√≠rculo con el brillo del centro C, para cada uno obtenemos tres resultados posibles (m√°s claro, m√°s oscuro, parece): <br><br><math> </math> $ en l√≠nea $ \ begin {array} {l} {I_p}&gt; {I_C} + t \\ {I_p} &lt;{I_C} -t \\ {I_C} -t &lt;{I_p} &lt;{I_C} + t \ end {array} $ en l√≠nea $ <br><br>  Aqu√≠ I es el brillo de los p√≠xeles, t es un umbral de brillo predeterminado. <br>  Un punto se marca como especial si hay n = 12 p√≠xeles en una fila m√°s oscuros o 12 p√≠xeles m√°s claros que el centro. <br><br>  Como la pr√°ctica ha demostrado, en promedio, tomar una decisi√≥n, fue necesario verificar alrededor de 9 puntos.  Para acelerar el proceso, los autores sugirieron primero verificar solo cuatro p√≠xeles con n√∫meros: 1, 5, 9, 13. Si entre ellos hay 3 p√≠xeles m√°s claros o m√°s oscuros, entonces se realiza una verificaci√≥n completa en 16 puntos, de lo contrario, el punto se marca inmediatamente como " no especial ".  Esto reduce en gran medida el tiempo de trabajo, para tomar una decisi√≥n en promedio es suficiente sondear solo alrededor de 4 puntos de un c√≠rculo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> hay un poco de c√≥digo ingenuo <br>  Par√°metros variables (descritos en el c√≥digo): radio del c√≠rculo (toma valores 1,2,3), par√°metro n (en el original, n = 12), par√°metro t.  El c√≥digo abre el archivo in.bmp, procesa la imagen, la guarda en out.bmp.  Las im√°genes son ordinarias de 24 bits. <br><br><h1>  Construyendo un √°rbol de decisi√≥n, Tree FAST, FAST-9 </h1><br>  En 2006, en [2], fue posible desarrollar una idea original utilizando el aprendizaje autom√°tico y los √°rboles de decisi√≥n. <br><br>  El FAST original tiene las siguientes desventajas: <br><br><ul><li>  Varios p√≠xeles adyacentes se pueden marcar como puntos especiales.  Necesitamos alguna medida de la "fuerza" de una caracter√≠stica.  Una de las primeras medidas propuestas es el valor m√°ximo de t en el que el punto todav√≠a se toma como uno especial. </li><li>  Una prueba r√°pida de 4 puntos no se generaliza para n menos de 12. Entonces, por ejemplo, visualmente los mejores resultados del m√©todo se logran con n = 9, no 12. </li><li>  ¬°Tambi√©n me gustar√≠a acelerar el algoritmo! </li></ul><br>  En lugar de utilizar una cascada de dos pruebas de 4 y 16 puntos, se propone hacer todo en una sola pasada a trav√©s del √°rbol de decisi√≥n.  De manera similar al m√©todo original, compararemos el brillo del punto central con los puntos en el c√≠rculo, pero en este orden para tomar la decisi√≥n lo m√°s r√°pido posible.  Y resulta que puedes tomar una decisi√≥n para solo ~ 2 (!!!) comparaciones en promedio. <br><br>  La sal es c√≥mo encontrar el orden correcto para comparar puntos.  Encuentra usando el aprendizaje autom√°tico.  Supongamos que alguien se√±ala para nosotros en la imagen muchos puntos especiales.  Los utilizaremos como un conjunto de ejemplos de capacitaci√≥n, y la idea es elegir con <u>entusiasmo</u> el que proporcionar√° la mayor cantidad de informaci√≥n en este paso como el siguiente punto.  Por ejemplo, suponga que inicialmente en nuestra muestra hab√≠a 5 puntos singulares y 5 puntos no singulares.  En forma de tableta como esta: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5596/A83hqZFlbWY.jpg" alt="imagen"><br><br>  Ahora elegimos uno de los p√≠xeles p del c√≠rculo y para todos los puntos singulares comparamos el p√≠xel central con el seleccionado.  Dependiendo del brillo del p√≠xel seleccionado cerca de cada punto en particular, la tabla puede tener el siguiente resultado: <br><br><img src="https://pp.userapi.com/c848536/v848536622/559d/A1CIWhE_LV8.jpg" alt="imagen"><br><br>  La idea es elegir un punto p para que los n√∫meros en las columnas de la tabla sean lo m√°s diferentes posible.  Y si ahora para un nuevo punto desconocido obtenemos el resultado de comparaci√≥n "M√°s ligero", entonces ya podemos decir de inmediato que el punto "no es especial" (ver tabla).  El proceso contin√∫a de manera recursiva hasta que los puntos de una sola de las clases caen en cada grupo despu√©s de dividirse en "m√°s oscuro como el m√°s claro".  Resulta un √°rbol de la siguiente forma: <br><br><img src="https://pp.userapi.com/c848536/v848536622/55a4/W7idq5TQQZ4.jpg" alt="imagen"><br><br>  El valor binario est√° en las hojas del √°rbol (el rojo es especial, el verde no es especial), y en los otros v√©rtices del √°rbol est√° el n√∫mero del punto que debe analizarse.  M√°s espec√≠ficamente, en el art√≠culo original, proponen elegir el n√∫mero de punto cambiando la entrop√≠a.  Se calcula la entrop√≠a del conjunto de puntos: <br><br><p><math> </math> $$ display $$ H = \ left ({c + \ overline c} \ right) {\ log _2} \ left ({c + \ overline c} \ right) - c {\ log _2} c - \ overline c {\ log _2} \ overline c $$ display $$ </p><br><br>  c es el n√∫mero de puntos singulares, <math> </math> $ en l√≠nea $ {\ bar c} $ en l√≠nea $   Es el n√∫mero de puntos no singulares del conjunto. <br><br>  Cambio en la entrop√≠a despu√©s del punto de procesamiento p: <br><br><p><math> </math> $$ display $$ \ Delta H = H - {H_ {dark}} - {H_ {equal}} - {H_ {bright}} $$ display $$ </p><br><br>  En consecuencia, se selecciona un punto para el cual el cambio en la entrop√≠a ser√° m√°ximo.  El proceso de divisi√≥n se detiene cuando la entrop√≠a es cero, lo que significa que todos los puntos son singulares o viceversa, no todos son especiales.  Con una implementaci√≥n de software, despu√©s de todo esto, el √°rbol de decisi√≥n encontrado se convierte en un conjunto de construcciones del tipo "if-else". <br><br>  El √∫ltimo paso del algoritmo es la operaci√≥n de suprimir los no m√°ximos para obtener uno de varios puntos adyacentes.  Los desarrolladores sugieren usar la medida original basada en la suma de las diferencias absolutas entre el punto central y los puntos del c√≠rculo de esta forma: <br><br><p><math> </math> $$ display $$ V = \ max \ left ({\ sum \ limits_ {x \ in {S_ {brillante}}} {\ left | {{I_x} - {I_p}} \ right | - t, \ sum \ l√≠mites_ {x \ in {S_ {dark}}} {\ left | {{I_p} - {I_x}} \ right | - t}}} \ right) $$ display $$ </p><br><br>  Aqui <math> </math> $ en l√≠nea $ {S_ {brillante}} $ en l√≠nea $   y <math> </math> $ en l√≠nea $ {S_ {dark}} $ en l√≠nea $   respectivamente, los grupos de p√≠xeles son m√°s claros y m√°s oscuros, t es el valor de brillo del umbral, <math> </math> $ en l√≠nea $ {I_p} $ en l√≠nea $   - brillo del p√≠xel central, <math> </math> $ en l√≠nea $ {{I_x}} $ en l√≠nea $   - brillo del p√≠xel en el c√≠rculo.  Puedes probar el algoritmo con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente c√≥digo</a> .  El c√≥digo se toma de OpenCV y se libera de todas las dependencias, solo ejec√∫telo. <br><br><h1>  Optimizando el √°rbol de decisiones - FAST-ER </h1><br>  FAST-ER [3] es un algoritmo de los mismos autores que el anterior, un detector r√°pido est√° construido de manera similar, la secuencia √≥ptima de puntos tambi√©n se busca para comparar, tambi√©n se construye un √°rbol de decisi√≥n, pero usando un m√©todo diferente: el m√©todo de optimizaci√≥n. <br><br>  Ya entendemos que un detector se puede representar como un √°rbol de decisi√≥n.  Si tuvi√©ramos alg√∫n criterio para comparar el rendimiento de diferentes √°rboles, entonces podemos maximizar este criterio clasificando diferentes variantes de √°rboles.  Y como tal criterio, se propone utilizar "Repetibilidad". <br><br>  La repetibilidad muestra qu√© tan bien se detectan los puntos singulares de una escena desde diferentes √°ngulos.  Para un par de im√°genes, un punto se llama "√∫til" si se encuentra en un cuadro y, en teor√≠a, se puede encontrar en otro, es decir,  No bloquee los elementos de la escena.  Y el punto se llama "repetido" (repetido), si tambi√©n se encuentra en el segundo cuadro.  Dado que la √≥ptica de la c√°mara no es ideal, el punto en el segundo cuadro puede no estar en el p√≠xel calculado, sino en alg√∫n lugar cercano en su vecindad.  Los desarrolladores tomaron un vecindario de 5 p√≠xeles.  Definimos la repetibilidad como la relaci√≥n entre el n√∫mero de puntos repetidos y el n√∫mero de puntos √∫tiles: <br><br><p><math> </math> $$ display $$ R = \ frac {{{N_ {repetido}}}} {{{N_ {√∫til}}}} $$ display $$ </p><br><br>  Para encontrar el mejor detector, se utiliza un m√©todo de simulaci√≥n de recocido.  Ya hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente art√≠culo</a> sobre Habr√© sobre √©l.  Brevemente, la esencia del m√©todo es la siguiente: <br><br><ul><li>  Se selecciona alguna soluci√≥n inicial al problema (en nuestro caso, este es alg√∫n tipo de √°rbol detector). </li><li>  Se considera la repetibilidad. </li><li>  El √°rbol se modifica al azar. </li><li>  Si la versi√≥n modificada es mejor por el criterio de repetibilidad, entonces se acepta la modificaci√≥n, y si es peor, puede aceptarse o no, con cierta probabilidad, que depende de un n√∫mero real llamado "temperatura".  A medida que aumenta el n√∫mero de iteraciones, la temperatura cae a cero. </li></ul><br>  Adem√°s, la construcci√≥n del detector ahora involucra no 16 puntos del c√≠rculo, como antes, sino 47, pero el significado no cambia en absoluto: <br><br><img src="https://pp.userapi.com/c824411/v824411841/1607f1/5szVOBYHeck.jpg" alt="imagen"><br><br>  De acuerdo con el m√©todo de recocido simulado, definimos tres funciones: <br><br>  ‚Ä¢ Funci√≥n de costo k.  En nuestro caso, usamos la repetibilidad como valor.  Pero hay un problema.  Imagine que todos los puntos en cada una de las dos im√°genes se detectan como singulares.  Entonces resulta que la repetibilidad es 100% - absurdo.  Por otro lado, incluso si hemos encontrado un punto particular en dos im√°genes, y estos puntos coinciden, la repetibilidad tambi√©n es del 100%, pero esto tampoco nos interesa.  Y por lo tanto, los autores propusieron usar esto como un criterio de calidad: <br><br><p><math> </math> $$ display $$ k = \ left ({1 + {{\ left ({\ frac {{{w_r}}} {R}} \ right)} ^ 2}} \ right) \ left ({1 + \ frac {1} {N} \ sum \ limits_ {i = 1} {{{\ left ({\ frac {{{d_i}}} {{{w_n}}}} right)} ^ 2}}} \ right) \ left ({1 + {{\ left ({\ frac {s} {{{w_s}}}} right)} ^ 2}} \ right) $$ display $$ </p><br><br>  r es la repetibilidad <math> </math> $ en l√≠nea $ {{d_i}} $ en l√≠nea $   Es el n√∫mero de √°ngulos detectados en el cuadro i, N es el n√∫mero de cuadros y s es el tama√±o del √°rbol (n√∫mero de v√©rtices).  W son par√°metros de m√©todos personalizados.] <br><br>  ‚Ä¢ Funci√≥n de cambio de temperatura con el tiempo: <br><br><p><math> </math> $$ display $$ T \ left (I \ right) = \ beta \ exp \ left ({- \ frac {{\ alpha I}} {{{I _ {\ max}}}} \ right) $$ display $$ </p><br><br>  donde <math> </math> $ en l√≠nea $ \ alpha, \ beta $ en l√≠nea $   Son los coeficientes, Imax es el n√∫mero de iteraciones. <br><br>  ‚Ä¢ Una funci√≥n que genera una nueva soluci√≥n.  El algoritmo realiza modificaciones aleatorias en el √°rbol.  Primero, seleccione alg√∫n v√©rtice.  Si el v√©rtice seleccionado es una hoja de un √°rbol, entonces con igual probabilidad hacemos lo siguiente: <br><br><ol><li>  Reemplace el v√©rtice con un sub√°rbol aleatorio con profundidad 1 </li><li>  Cambiar la clase de esta hoja (puntos singulares y no singulares) </li></ol><br>  Si esto NO es una hoja: <br><br><ol><li>  Reemplace el n√∫mero del punto probado con un n√∫mero aleatorio de 0 a 47 </li><li>  Reemplazar v√©rtice con una hoja con una clase aleatoria </li><li>  Intercambia dos sub√°rboles de este v√©rtice </li></ol><br>  La probabilidad P de aceptar el cambio en la iteraci√≥n I es: <br><math> </math> $ en l√≠nea $ P = \ exp \ left ({\ frac {{k \ left ({i - 1} \ right) - k \ left (i \ right)}} {T}} \ right) $ en l√≠nea $ <br>  k es la funci√≥n de costo, T es la temperatura, i es el n√∫mero de iteraci√≥n. <br><br>  Estas modificaciones al √°rbol permiten tanto el crecimiento del √°rbol como su reducci√≥n.  El m√©todo es aleatorio, no garantiza que se obtenga el mejor √°rbol.  Ejecute el m√©todo muchas veces, eligiendo la mejor soluci√≥n.  En el art√≠culo original, por ejemplo, se ejecutan 100 veces por cada 100,000 iteraciones cada una, lo que lleva 200 horas de tiempo de procesador.  Como muestran los resultados, el resultado es mejor que Tree FAST, especialmente en im√°genes ruidosas. <br><br><h1>  BREVE descriptor </h1><br>  Despu√©s de encontrar los puntos singulares, se calculan sus descriptores, es decir,  conjuntos de caracter√≠sticas que caracterizan la vecindad de cada punto singular.  BREVE [4] es un descriptor heur√≠stico r√°pido, construido a partir de 256 comparaciones binarias entre el brillo de los p√≠xeles en una imagen <u>borrosa</u> .  La prueba binaria entre los puntos x e y se define de la siguiente manera: <br><br><p><math> </math> $$ display $$ \ tau \ left ({P, x, y} \ right): = \ left \ {{\ begin {array} {* {20} {c}} {1: p \ left (x \ right) &lt;p \ left (y \ right)} \\ {0: p \ left (x \ right) \ ge p \ left (y \ right)} \ end {array}} \ right. $$ display $$ </p><br><br><img src="https://pp.userapi.com/c824411/v824411841/160801/dMWJxyV422c.jpg" alt="imagen"><br><br>  En el art√≠culo original, se consideraron varios m√©todos para elegir puntos para comparaciones binarias.  Al final result√≥ que, una de las mejores maneras es seleccionar puntos al azar utilizando una distribuci√≥n gaussiana alrededor de un p√≠xel central.  Esta secuencia aleatoria de puntos se selecciona una vez y no cambia m√°s.  El tama√±o del vecindario considerado del punto es de 31x31 p√≠xeles, y la apertura de desenfoque es de 5. <br><br>  El descriptor binario resultante es resistente a los cambios de iluminaci√≥n, la distorsi√≥n de perspectiva, se calcula y compara r√°pidamente, pero es muy inestable a la rotaci√≥n en el plano de la imagen. <br><br><h1>  ORB: r√°pido y eficiente </h1><br>  El desarrollo de todas estas ideas fue el algoritmo ORB (Oriented FAST and Rotated BRIEF) [5], en el que se intent√≥ mejorar el rendimiento BRIEF durante la rotaci√≥n de la imagen.  Se propone calcular primero la orientaci√≥n del punto singular y luego realizar comparaciones binarias de acuerdo con esta orientaci√≥n.  El algoritmo funciona as√≠: <br><br>  1) Los puntos de caracter√≠sticas se detectan mediante el uso del √°rbol FAST r√°pido en la imagen original y en varias im√°genes de la pir√°mide en miniatura. <br><br>  2) Para los puntos detectados, se calcula la medida de Harris, se descartan los candidatos con un valor bajo de la medida de Harris. <br><br>  3) Se calcula el √°ngulo de orientaci√≥n del punto singular.  Para esto, primero se calculan los momentos de brillo para la vecindad del punto singular: <br><br><math> </math> $ en l√≠nea $ {m_ {pq}} = \ sum \ limits_ {x, y} {{x ^ p} {y ^ q} I \ left ({x, y} \ right)} $ en l√≠nea $ <br>  x, y - coordenadas de p√≠xeles, I - brillo.  Y luego el √°ngulo de orientaci√≥n del punto singular: <br><math> </math> $ en l√≠nea $ \ theta = {\ rm {atan2}} \ left ({{m_ {01}}, {m_ {10}}} \ right) $ en l√≠nea $ <br><br>  Todo esto, los autores llamaron la "orientaci√≥n centroide".  Como resultado, obtenemos una cierta direcci√≥n para la vecindad del punto singular. <br><br>  4) Teniendo el √°ngulo de orientaci√≥n del punto singular, la secuencia de puntos para comparaciones binarias en el descriptor BREVE gira de acuerdo con este √°ngulo, por ejemplo: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160813/y5R3uZYvsfQ.jpg" alt="imagen"><br><br>  M√°s formalmente, las nuevas posiciones para los puntos de prueba binarios se calculan de la siguiente manera: <br><br><p><math> </math> $$ display $$ \ left ({\ begin {array} {* {20} {c}} {{x_i} '} \\ {{y_i}'} \ end {array}} \ right) = R \ left (\ theta \ right) \ cdot \ left ({\ begin {array} {* {20} {c}} {{x_i}} \\ {{y_i}} \ end {array}} \ right) $$ display $$ </p><br><br>  5) En base a los puntos recibidos, se calcula el descriptor binario BREVE <br><br>  Y eso es ... ¬°no todo!  Hay otro detalle interesante en ORB que requiere una explicaci√≥n por separado.  El hecho es que en el momento en que "convertimos" todos los puntos singulares en un √°ngulo cero, la elecci√≥n aleatoria de las comparaciones binarias en el descriptor deja de ser aleatoria.  Esto lleva al hecho de que, en primer lugar, algunas comparaciones binarias resultan dependientes entre s√≠, y en segundo lugar, su promedio ya no es igual a 0.5 (1 es m√°s claro, 0 es m√°s oscuro cuando la elecci√≥n fue aleatoria, luego el promedio fue 0.5) y todo esto reduce significativamente la capacidad del descriptor para distinguir puntos singulares entre ellos. <br><br>  Soluci√≥n: debe seleccionar las pruebas binarias "correctas" en el proceso de aprendizaje, esta idea arroja el mismo sabor que el entrenamiento del √°rbol para el algoritmo FAST-9.  Supongamos que tenemos un mont√≥n de puntos singulares ya encontrados.  Considere todas las opciones posibles para las pruebas binarias.  Si el vecindario es 31 x 31, y la prueba binaria es un par de 5 x 5 subconjuntos (debido al desenfoque), entonces hay muchas opciones para elegir N = (31-5) ^ 2.  El algoritmo de b√∫squeda para pruebas "buenas" es el siguiente: <br><br><ol><li>  Calculamos el resultado de todas las pruebas para todos los puntos singulares </li><li>  Organice todo el conjunto de pruebas de acuerdo con su distancia del promedio 0.5 </li><li>  Cree una lista que contendr√° las pruebas "buenas" seleccionadas, llamemos a la lista R. </li><li>  Agregue a R la primera prueba del conjunto ordenado </li><li>  Tomamos la siguiente prueba y la comparamos con todas las pruebas en R. Si la correlaci√≥n es mayor que el umbral, descartamos la nueva prueba, de lo contrario la agregamos. </li><li>  Repita el paso 5 hasta que escribamos el n√∫mero requerido de pruebas. </li></ol><br>  Resulta que las pruebas se seleccionan de modo que, por un lado, el valor promedio de estas pruebas sea lo m√°s cercano posible a 0.5, por otro lado, de modo que la correlaci√≥n entre las diferentes pruebas sea m√≠nima.  Y esto es lo que necesitamos.  Compare c√≥mo fue y c√≥mo se convirti√≥: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160829/ozQhEUvtdBs.jpg" alt="imagen"><br><br>  Afortunadamente, el algoritmo ORB se implementa en la biblioteca OpenCV en la clase cv :: ORB.  Estoy usando la versi√≥n 2.4.13.  El constructor de la clase acepta los siguientes par√°metros: <br><br>  nfeatures - n√∫mero m√°ximo de puntos singulares <br>  scaleFactor: multiplicador para la pir√°mide de im√°genes, m√°s de uno.  Value 2 implementa la cl√°sica pir√°mide. <br>  Niveles: el n√∫mero de niveles en la pir√°mide de im√°genes. <br>  edgeThreshold: el n√∫mero de p√≠xeles en el borde de la imagen donde no se detectan puntos singulares. <br>  firstLevel: deja cero. <br>  WTA_K: la cantidad de puntos necesarios para un elemento del descriptor.  Si es igual a 2, se compara el brillo de dos p√≠xeles seleccionados al azar.  Esto es lo que se necesita. <br>  scoreType: si es 0, entonces harris se utiliza como una medida caracter√≠stica, de lo contrario, la medida R√ÅPIDA (basada en la suma de los m√≥dulos de las diferencias de brillo en los puntos del c√≠rculo).  La medida FAST es ligeramente menos estable, pero m√°s r√°pida. <br>  patchSize: el tama√±o del vecindario desde el cual se seleccionan p√≠xeles aleatorios para la comparaci√≥n.  El c√≥digo busca y compara los puntos singulares en dos im√°genes, "templ.bmp" e "img.bmp" <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre><code class="cpp hljs">cv::Mat img_object=cv::imread(<span class="hljs-string"><span class="hljs-string">"templ.bmp"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::KeyPoint&gt; keypoints_object, keypoints_scene; cv::Mat descriptors_object, descriptors_scene; cv::<span class="hljs-function"><span class="hljs-function">ORB </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    orb.detect(img_object, keypoints_object); orb.compute(img_object, keypoints_object, descriptors_object); //    cv::Mat img = cv::imread("img.bmp", 1); cv::Mat img_scene = cv::Mat(img.size(), CV_8UC1); orb.detect(img, keypoints_scene); orb.compute(img, keypoints_scene, descriptors_scene); cv::imshow("desrs", descriptors_scene); cvWaitKey(); int test[10]; for (int q = 0; q&lt;10 ; q++) test[q]=descriptors_scene.data[q]; //-- matching descriptor vectors using FLANN matcher cv::BFMatcher matcher; std::vector&lt;cv::DMatch&gt; matches; cv::Mat img_matches; if(!descriptors_object.empty() &amp;&amp; !descriptors_scene.empty()) { matcher.match (descriptors_object, descriptors_scene, matches); double max_dist = 0; double min_dist = 100; // calculation of max and min idstance between keypoints for( int i = 0; i &lt; descriptors_object.rows; i++) { double dist = matches[i].distance; if( dist &lt; min_dist ) min_dist = dist; if( dist &gt; max_dist ) max_dist = dist; } //-- Draw only good matches (ie whose distance is less than 3*min_dist) std::vector&lt; cv::DMatch &gt;good_matches; for( int i = 0; i &lt; descriptors_object.rows; i++ ) if( matches[i].distance &lt; (max_dist/1.6) ) good_matches.push_back(matches[i]); cv::drawMatches(img_object, keypoints_object, img_scene, keypoints_scene, good_matches, img_matches, cv::Scalar::all(-1), cv::Scalar::all(-1), std::vector&lt;char&gt;(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS); } cv::imshow("match result", img_matches ); cv::waitKey(); return 0;</span></span></code> </pre> <br></div></div><br>  Si alguien ayud√≥ a comprender la esencia de los algoritmos, entonces no es en vano.  A todos los Habr. <br><br>  Referencias <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Puntos de fusi√≥n y l√≠neas para el seguimiento de alto rendimiento</a> <br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprendizaje autom√°tico para la detecci√≥n de curvas de alta velocidad.</a> <br>  3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√°s r√°pido y mejor: un enfoque de aprendizaje autom√°tico para la detecci√≥n de esquinas</a> <br>  4. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BREVE: Caracter√≠sticas elementales independientes binarias robustas</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ORB: una alternativa eficiente a SIFT o SURF</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414459/">https://habr.com/ru/post/es414459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414447/index.html">Tipos de todos los tiempos</a></li>
<li><a href="../es414449/index.html">C√≥mo hacer amigos de todos los operadores en el estadio y no sembrarlo con cientos de antenas</a></li>
<li><a href="../es414451/index.html">"Calendario de pruebas" para junio. El probador debe atrapar el error, leer a Caner y organizar el movimiento.</a></li>
<li><a href="../es414453/index.html">Implemente Path Finder para agentes de IA con NavMesh</a></li>
<li><a href="../es414455/index.html">Algoritmo de generaci√≥n de paleta de colores</a></li>
<li><a href="../es414463/index.html">La IA misma aprendi√≥ a construir un cubo de Rubik</a></li>
<li><a href="../es414465/index.html">Meta Crush Saga: juego en tiempo de compilaci√≥n</a></li>
<li><a href="../es414467/index.html">Art√≠culos de la Conferencia de Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../es414469/index.html">Semana de la seguridad 22: dos segundas cerraduras inteligentes</a></li>
<li><a href="../es414471/index.html">11 c√≠rculos del infierno para aquellos que carecen de experiencia en un nuevo trabajo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>