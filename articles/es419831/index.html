<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¢ ü§æüèª üÖ∞Ô∏è C√≥mo funciona JS: elementos personalizados üöª ü•ê üó°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Recomendar lectura] Las otras 19 partes del ciclo  Parte 1: Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas 
 Part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona JS: elementos personalizados</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimizaci√≥n del c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de p√©rdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, as√≠ncrono y cinco formas de mejorar su c√≥digo con as√≠ncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter√≠sticas y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representaci√≥n de p√°ginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animaci√≥n con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Mecanismos de comunicaci√≥n WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Elementos personalizados</a> </div></div><br>  Le presentamos una traducci√≥n de 19 art√≠culos de la serie de materiales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack</a> sobre las caracter√≠sticas de varios mecanismos del ecosistema JavaScript.  Hoy hablaremos sobre el est√°ndar Elementos personalizados: los llamados "elementos personalizados".  Hablaremos sobre las tareas que permiten resolver y c√≥mo crearlas y usarlas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="imagen"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revisar</font> </h2><br>  En uno de los art√≠culos anteriores de esta serie, hablamos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shadow DOM</a> y algunas otras tecnolog√≠as que forman parte de un fen√≥meno mayor: los componentes web.  Los componentes web est√°n dise√±ados para permitir a los desarrolladores ampliar las caracter√≠sticas est√°ndar de HTML mediante la creaci√≥n de elementos compactos, modulares y reutilizables.  Este es el est√°ndar W3C relativamente nuevo que los fabricantes de todos los principales navegadores ya han notado.  Se lo puede encontrar en la producci√≥n, aunque, por supuesto, mientras su trabajo es proporcionado por pol√≠filos (hablaremos de ellos m√°s adelante). <br><br>  Como ya sabr√°, los navegadores nos proporcionan algunas herramientas esenciales para desarrollar sitios web y aplicaciones web.  Se trata de HTML, CSS y JavaScript.  El HTML se usa para estructurar p√°ginas web, gracias a CSS se les da una buena apariencia, y JavaScript es responsable de las caracter√≠sticas interactivas.  Sin embargo, antes de la aparici√≥n de los componentes web, no era tan f√°cil asociar acciones implementadas con JavaScript con una estructura HTML. <br><br>  De hecho, aqu√≠ consideraremos la base de los componentes web: elementos personalizados.  En pocas palabras, la API dise√±ada para trabajar con ellos le permite al programador crear sus propios elementos HTML con l√≥gica JavaScript incorporada y estilos descritos por CSS.  Muchos confunden elementos personalizados con la tecnolog√≠a Shadow DOM.  Sin embargo, estas son dos cosas completamente diferentes que, de hecho, se complementan entre s√≠, pero no son intercambiables. <br><br>  Algunos marcos (como Angular o React) intentan resolver el mismo problema que resuelven los elementos personalizados mediante la introducci√≥n de sus propios conceptos.  Los elementos personalizados se pueden comparar con directivas angulares o con componentes React.  Sin embargo, los elementos personalizados son una caracter√≠stica est√°ndar del navegador; no necesita usar nada m√°s que JavaScript, HTML y CSS para trabajar con ellos.  Por supuesto, esto no nos permite decir que son un reemplazo para los frameworks JS ordinarios.  Los marcos modernos nos brindan mucho m√°s que la capacidad de simular el comportamiento de elementos personalizados.  Como resultado, podemos decir que tanto los marcos como los elementos de usuario son tecnolog√≠as que se pueden usar juntas para resolver tareas de desarrollo web. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Antes de continuar, veamos qu√© oportunidades nos brinda la API para trabajar con elementos personalizados.  A saber, estamos hablando de un objeto global <code>customElements</code> que tiene varios m√©todos: <br><br><ul><li>  El m√©todo de <code>define(tagName, constructor, options)</code> permite definir (crear, registrar) un nuevo elemento de usuario.  Toma tres argumentos: el nombre de la etiqueta para el elemento del usuario, que corresponde a las reglas de nomenclatura para dichos elementos, una declaraci√≥n de clase y un objeto con par√°metros.  Actualmente, solo se admite un par√°metro: se <code>extends</code> , que es una cadena que especifica el nombre del elemento en l√≠nea que se expandir√°.  Esta caracter√≠stica se utiliza para crear versiones especiales de elementos est√°ndar. </li><li>  El m√©todo <code>get(tagName)</code> devuelve el constructor del elemento de usuario, siempre que este elemento ya est√© definido; de lo contrario, devuelve <code>undefined</code> .  Se necesita un argumento: la etiqueta de nombre del elemento de usuario. </li><li>  El <code>whenDefined(tagName)</code> devuelve la promesa que se resuelve despu√©s de crear el elemento de usuario.  Si un elemento ya est√° definido, esta promesa se resuelve de inmediato.  Se rechaza una promesa si el nombre de etiqueta que se le pasa no es un nombre de etiqueta v√°lido para el elemento de usuario.  Este m√©todo acepta el nombre de etiqueta del elemento de usuario. </li></ul><br><h2>  <font color="#3AC1EF">Crea art√≠culos personalizados</font> </h2><br>  Crear elementos personalizados es muy simple.  Para hacer esto, se deben hacer dos cosas: crear una declaraci√≥n de clase para el elemento que deber√≠a extender la clase <code>HTMLElement</code> y registrar este elemento con el nombre seleccionado.  As√≠ es como se ve: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  Si no desea contaminar el alcance actual, puede usar una clase an√≥nima: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ });</span></span></code> </pre> <br>  Como puede ver en los ejemplos, el elemento de usuario se registra utilizando el <code>customElements.define(...)</code> ya le <code>customElements.define(...)</code> familiar. <br><br><h2>  <font color="#3AC1EF">Problemas que resuelven los elementos personalizados</font> </h2><br>  Hablemos de los problemas que nos permiten resolver elementos personalizados.  Una de ellas es mejorar la estructura del c√≥digo y eliminar lo que se llama una "sopa de etiqueta div" (sopa div).  Este fen√≥meno es una estructura de c√≥digo muy com√∫n en las aplicaciones web modernas, en la que hay muchos elementos <code>div</code> integrados entre s√≠.  As√≠ es como podr√≠a verse: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           ‚Ä¶         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Dicho c√≥digo HTML se utiliza por razones justificables: describe el dise√±o de la p√°gina y garantiza su visualizaci√≥n correcta en la pantalla.  Sin embargo, esto perjudica la legibilidad del c√≥digo HTML y complica su mantenimiento. <br><br>  Supongamos que tenemos un componente que se parece a la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Aspecto componente</font></i> <br><br>  Usando el enfoque tradicional para describir tales cosas, el siguiente c√≥digo corresponder√° a este componente: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Ahora imagine que podr√≠amos, en lugar de este c√≥digo, usar esta descripci√≥n del componente: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Estoy seguro de que todos estar√°n de acuerdo en que el segundo fragmento de c√≥digo se ve mucho mejor.  Dicho c√≥digo es m√°s f√°cil de leer, m√°s f√°cil de mantener y es comprensible tanto para el desarrollador como para el navegador.  Todo se reduce al hecho de que es m√°s simple que aquel en el que hay muchas etiquetas <code>div</code> anidadas. <br><br>  El siguiente problema que se puede resolver con elementos personalizados es la reutilizaci√≥n de c√≥digo.  El c√≥digo que escriben los desarrolladores no solo deber√≠a funcionar, sino tambi√©n admitirse.  Reutilizar el c√≥digo, en lugar de escribir constantemente las mismas construcciones, mejora las capacidades de soporte del proyecto. <br>  Aqu√≠ hay un ejemplo simple que lo ayudar√° a comprender mejor esta idea.  Supongamos que tenemos el siguiente elemento: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  Si lo necesita constantemente, entonces, con el enfoque habitual, tendremos que escribir el mismo c√≥digo HTML una y otra vez.  Ahora imagine que necesita hacer un cambio en este c√≥digo que deber√≠a reflejarse donde sea que se use.  Esto significa que necesitamos encontrar todos los lugares donde se usa este fragmento y luego hacer los mismos cambios en todas partes.  Es largo, duro y lleno de errores. <br><br>  Ser√≠a mucho mejor si pudi√©ramos donde se necesita este elemento, simplemente escriba lo siguiente: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Sin embargo, las aplicaciones web modernas son mucho m√°s que HTML est√°tico.  Son interactivos.  La fuente de su interactividad es JavaScript.  Por lo general, para proporcionar tales capacidades, se crean algunos elementos, luego los oyentes de eventos se conectan a ellos, lo que les permite responder a las influencias del usuario.  Por ejemplo, pueden responder a los clics, al "desplazamiento" del puntero del mouse sobre ellos, al arrastrarlos por la pantalla, etc.  Aqu√≠ le mostramos c√≥mo conectar un detector de eventos a un elemento que ocurre cuando hace clic con el mouse: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  Y aqu√≠ est√° el c√≥digo HTML para este elemento: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  Al usar la API para trabajar con elementos personalizados, toda esta l√≥gica se puede incluir en el elemento mismo.  A modo de comparaci√≥n, a continuaci√≥n se muestra el c√≥digo para declarar un elemento personalizado que incluye un controlador de eventos: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  Y as√≠ es como se ve en el c√≥digo HTML de la p√°gina: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  A primera vista, puede parecer que se requieren m√°s l√≠neas de c√≥digo JS para crear un elemento personalizado.  Sin embargo, en aplicaciones del mundo real, rara vez sucede que tales elementos se creen solo para usarse una sola vez.  Otro fen√≥meno t√≠pico en las aplicaciones web modernas es que la mayor√≠a de los elementos en ellas se crean din√°micamente.  Esto lleva a la necesidad de admitir dos escenarios diferentes de trabajo con elementos: situaciones en las que se agregan din√°micamente a la p√°gina mediante JavaScript y situaciones en las que se describen en la estructura HTML original de la p√°gina.  Gracias al uso de elementos personalizados, el trabajo en estas dos situaciones se simplifica. <br><br>  Como resultado, si resumimos los resultados de esta secci√≥n, podemos decir que los elementos de usuario aclaran el c√≥digo, simplifican su soporte, ayudan a dividirlo en peque√±os m√≥dulos, que incluyen toda la funcionalidad necesaria y son adecuados para su reutilizaci√≥n. <br><br>  Ahora que hemos discutido los problemas generales de trabajar con elementos personalizados, hablemos de sus caracter√≠sticas. <br><br><h2>  <font color="#3AC1EF">Requisitos</font> </h2><br>  Antes de comenzar a desarrollar sus propios elementos personalizados, debe conocer algunas de las reglas que debe seguir al crearlos.  Aqu√≠ est√°n: <br><br><ul><li>  El nombre del componente debe incluir un gui√≥n (s√≠mbolo <code>-</code> ).  Gracias a esto, el analizador HTML puede distinguir entre elementos incrustados y elementos de usuario.  Adem√°s, este enfoque garantiza que no haya colisiones de nombres con elementos integrados (tanto con los que est√°n ahora como con los que aparecer√°n en el futuro).  Por ejemplo, el nombre real del elemento personalizado es <code>&gt;my-custom-element&lt;</code> , y los nombres <code>&gt;myCustomElement&lt;</code> y <code>&lt;my_custom_element&gt;</code> no son adecuados. </li><li>  Est√° prohibido registrar la misma etiqueta m√°s de una vez.  Intentar hacer esto har√° que el navegador <code>DOMException</code> error <code>DOMException</code> .  Los elementos personalizados no se pueden redefinir. </li><li>  Las etiquetas personalizadas no pueden cerrarse autom√°ticamente.  El analizador HTML solo admite un conjunto limitado de etiquetas de cierre autom√°tico est√°ndar (por ejemplo, <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">Las posibilidades</font> </h2><br>  Hablemos sobre lo que puede hacer con elementos personalizados.  Si responde esta pregunta en pocas palabras, resulta que puede hacer muchas cosas interesantes con ellos. <br><br>  Una de las caracter√≠sticas m√°s notables de los elementos personalizados es que la declaraci√≥n de una clase de elemento se refiere al elemento DOM en s√≠.  Esto significa que puede usar la palabra clave this en un anuncio para conectar oyentes de eventos, acceder a propiedades, a nodos secundarios, etc. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  Esto, por supuesto, hace posible escribir nuevos datos en los nodos secundarios del elemento.  Sin embargo, no se recomienda hacerlo, ya que esto puede conducir a un comportamiento inesperado de los elementos.  Si imagina que est√° utilizando elementos dise√±ados por otra persona, entonces probablemente se sorprender√° si su propio marcado colocado en el elemento se reemplaza por otra cosa. <br><br>  Existen varios m√©todos que le permiten ejecutar c√≥digo en ciertos puntos del ciclo de vida de un elemento. <br><br><ul><li>  El m√©todo <code>constructor</code> se llama una vez, al crear o "actualizar" el elemento (hablaremos de esto a continuaci√≥n).  La mayor√≠a de las veces se usa para inicializar el estado de un elemento, para conectar oyentes de eventos, crear un DOM DOM, etc.  No olvides que siempre necesitas llamar a <code>super()</code> en el constructor. </li><li>  El m√©todo <code>connectedCallback</code> se llama cada vez que se agrega un elemento al DOM.  Se puede usar (y esta es exactamente la forma en que se recomienda usarlo) para posponer la ejecuci√≥n de cualquier acci√≥n hasta el momento en que el elemento aparece en la p√°gina (por ejemplo, de esta manera puede retrasar la carga de algunos datos). </li><li>  El m√©todo <code>disconnectedCallback</code> se llama cuando un elemento se elimina del DOM.  Suele utilizarse para liberar recursos.  Tenga en cuenta que este m√©todo no se llama si el usuario cierra la pesta√±a del navegador con la p√°gina.  Por lo tanto, no conf√≠e en √©l cuando sea necesario para realizar algunas acciones particularmente importantes. </li><li>  Se llama al m√©todo <code>attributeChangedCallback</code> cuando se agrega, elimina, actualiza o reemplaza un <code>attributeChangedCallback</code> elemento.  Adem√°s, se llama cuando el analizador crea el elemento.  Sin embargo, tenga en cuenta que este m√©todo solo se aplica a los atributos que se enumeran en la propiedad <code>observedAttributes</code> . </li><li>  Se <code>adoptedCallback</code> m√©todo <code>adoptedCallback</code> cuando se usa el m√©todo <code>document.adoptNode(...)</code> , que se usa para mover el nodo a otro documento. </li></ul><br>  Tenga en cuenta que todos los m√©todos anteriores son sincr√≥nicos.  Por ejemplo, el m√©todo <code>connectedCallback</code> se llama inmediatamente despu√©s de que el elemento se agrega al DOM, y el resto del programa espera la finalizaci√≥n de este m√©todo. <br><br><h2>  <font color="#3AC1EF">Reflexi√≥n de propiedad</font> </h2><br>  Los elementos HTML incorporados tienen una caracter√≠stica muy conveniente: reflejo de propiedad.  Gracias a este mecanismo, los valores de algunas propiedades se reflejan directamente en el DOM como atributos.  Digamos que esto es caracter√≠stico de la propiedad <code>id</code> .  Por ejemplo, realizamos la siguiente operaci√≥n: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Los cambios relevantes afectar√°n al DOM: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Este mecanismo opera en la direcci√≥n opuesta.  Es muy √∫til porque le permite configurar elementos declarativamente. <br><br>  Los elementos personalizados no tienen esta caracter√≠stica incorporada, pero puede implementarla usted mismo.  Para que algunas propiedades de los elementos de usuario se comporten de manera similar, puede configurar sus captadores y definidores. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Extender art√≠culos existentes</font> </h2><br>  La API de elementos personalizados le permite no solo crear nuevos elementos HTML, sino tambi√©n ampliar los existentes.  Adem√°s, estamos hablando tanto de elementos est√°ndar como personalizados.  Esto se hace utilizando la <code>extends</code> al declarar una clase: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Los elementos est√°ndar extendidos tambi√©n se denominan "elementos integrados personalizados". <br><br>  Se recomienda hacer una regla para expandir siempre los elementos existentes y hacerlo progresivamente.  Esto le permitir√° guardar en nuevos elementos las capacidades que se implementaron en elementos creados previamente (es decir, propiedades, atributos, funciones). <br><br>  Tenga en cuenta que ahora los elementos integrados personalizados solo son compatibles con Chrome 67+.  Esto aparecer√° en otros navegadores, sin embargo, se sabe que los desarrolladores de Safari decidieron no implementar esta oportunidad. <br><br><h2>  <font color="#3AC1EF">Actualizar elementos</font> </h2><br>  Como ya se mencion√≥, el <code>customElements.define(...)</code> se utiliza para registrar elementos personalizados.  Sin embargo, el registro no puede llamarse la acci√≥n que debe realizarse en primer lugar.  El registro del elemento de usuario puede posponerse por un tiempo, adem√°s, esta vez puede llegar incluso cuando el elemento ya est√° agregado al DOM.  Este proceso se llama actualizaci√≥n.  Para saber cu√°ndo se registrar√° un elemento, el navegador proporciona el <code>customElements.whenDefined(...)</code> .  Se le da el nombre de la etiqueta del elemento y devuelve la promesa que se resuelve despu√©s de registrar el elemento. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  Por ejemplo, es posible que deba retrasar el registro de un elemento hasta que se declaren sus elementos secundarios.  Tal l√≠nea de comportamiento puede ser extremadamente √∫til si el proyecto ha anidado elementos de usuario.  Algunas veces un padre puede confiar en la implementaci√≥n de elementos secundarios.  En este caso, debe asegurarse de que los ni√±os est√©n registrados antes que los padres. <br><br><h2>  <font color="#3AC1EF">Dom de las sombras</font> </h2><br>  Como ya se mencion√≥, los elementos personalizados y Shadow DOM son tecnolog√≠as complementarias.  El primero le permite encapsular la l√≥gica JS en elementos de usuario, y el segundo le permite crear entornos aislados para fragmentos DOM que no se ven afectados por lo que est√° fuera de ellos.  Si cree que necesita comprender mejor el concepto Shadow DOM, eche un vistazo a una de nuestras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaciones anteriores</a> . <br><br>  Aqu√≠ se explica c√≥mo usar Shadow DOM para un elemento personalizado: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  Como puede ver, llamar a <code>this.attachShadow</code> juega un papel clave <code>this.attachShadow</code> . <br><br><h2>  <font color="#3AC1EF">Patrones</font> </h2><br>  En uno de nuestros art√≠culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriores</a> , hablamos un poco sobre las plantillas, aunque de hecho, son dignas de un art√≠culo separado.  Aqu√≠ veremos un ejemplo simple de c√≥mo incrustar plantillas en elementos personalizados cuando se crean.  Entonces, utilizando la <code>&lt;template&gt;</code> , puede describir el fragmento DOM que procesar√° el analizador, pero que no se mostrar√° en la p√°gina: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  Aqu√≠ se explica c√≥mo aplicar una plantilla en un elemento personalizado: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  Como puede ver, hay una combinaci√≥n de un elemento personalizado, un DOM de sombra y plantillas.  Esto nos permiti√≥ crear un elemento aislado en su propio espacio, en el que la estructura HTML est√° separada de la l√≥gica JS. <br><br><h2>  <font color="#3AC1EF">Estilizaci√≥n</font> </h2><br>  Hasta ahora, solo hemos hablado de JavaScript y HTML, ignorando CSS.  Por lo tanto, ahora tocamos el tema de los estilos.  Obviamente, necesitamos alguna forma de dise√±ar elementos personalizados.  Los estilos se pueden agregar dentro del Shadow DOM, pero luego surge la pregunta de c√≥mo dise√±ar dichos elementos desde el exterior, por ejemplo, si la persona que los cre√≥ no los usa.  La respuesta a esta pregunta es bastante simple: los elementos personalizados tienen el mismo estilo que los elementos integrados. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Tenga en cuenta que los estilos externos tienen prioridad sobre los estilos declarados dentro de un elemento, anul√°ndolos. <br><br>  Es posible que haya visto c√≥mo, cuando se muestra una p√°gina en la pantalla, en alg√∫n momento puede observar el contenido no estilizado (esto es lo que se llama FOUC - Flash Of Unstyled Content).  Puede evitar este fen√≥meno configurando estilos para componentes no registrados y utilizando algunos efectos visuales al registrarlos.  Para hacer esto, puede usar el selector <code>:defined</code> .  Puede hacer esto, por ejemplo, as√≠: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Elementos desconocidos y elementos de usuario indefinidos.</font> </h2><br>  La especificaci√≥n HTML es muy flexible, le permite declarar cualquier etiqueta que necesite para el desarrollador.  Y, si el navegador no reconoce la etiqueta, el analizador la <code>HTMLUnknownElement</code> como <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  Sin embargo, cuando se trabaja con elementos personalizados, dicho esquema no se aplica.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øRecuerdas que hablamos de convenciones de nombres para tales elementos? </font><font style="vertical-align: inherit;">Cuando el navegador encuentra un elemento similar con un nombre formado correctamente, el analizador lo procesar√°, ya </font></font><code>HTMLElement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que el navegador lo presentar√° como un elemento de usuario indefinido.</font></font><br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque exteriormente </font></font><code>HTMLElement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>HTMLUnknownElement</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede ser diferente para algunas de sus caracter√≠sticas, sin embargo, es digno de recordar, ya que se manejan de forma diferente en el analizador. </font><font style="vertical-align: inherit;">Se espera implementar un elemento que tenga un nombre que coincida con las reglas para nombrar elementos personalizados. </font><font style="vertical-align: inherit;">Antes del registro, dicho elemento se considera un elemento vac√≠o </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sin embargo, un elemento de usuario indefinido no implementa ning√∫n m√©todo o propiedad de elementos en l√≠nea.</font></font><br><br><h2> <font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soporte del navegador</font></font></font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         ‚Äî   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   ‚Äî   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Estimados lectores!</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419831/">https://habr.com/ru/post/es419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419817/index.html">Lanzamiento del cl√∫ster RabbitMQ en Kubernetes</a></li>
<li><a href="../es419819/index.html">Biomarcadores del envejecimiento. Fragilidad de panel. Parte 2</a></li>
<li><a href="../es419823/index.html">D√∫o inusual: frases de contrase√±a e im√°genes mnemot√©cnicas</a></li>
<li><a href="../es419825/index.html">Probar el rendimiento de varios tipos de unidades en un entorno virtual</a></li>
<li><a href="../es419829/index.html">El cifrado de clave predeterminado de OpenSSH es peor que ninguno</a></li>
<li><a href="../es419833/index.html">Trabajo remoto, como funciona</a></li>
<li><a href="../es419835/index.html">C√≥mo motivar a los autores, negociar con expertos y, en general, escribir buenos art√≠culos.</a></li>
<li><a href="../es419837/index.html">Yo, RoboLoyer, o c√≥mo buscar anomal√≠as en los documentos.</a></li>
<li><a href="../es419839/index.html">Hack de cajeros autom√°ticos de bajo nivel NCR</a></li>
<li><a href="../es419843/index.html">GeekUniversity abre inscripci√≥n en la Facultad de Inteligencia Artificial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>