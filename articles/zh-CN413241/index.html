<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚗️ 🕯️ 👨🏽‍⚕️ 使用ftrace拦截Linux内核中的函数 👨‍🎓 ⏏️ 🚮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在与Linux系统安全性相关的一个项目中，我们需要拦截对内核内部重要功能的调用（例如打开文件和运行的进程），以提供监视系统活动并预防性地阻止可疑进程活动的能力。 

 在开发过程中，我们设法发明了一种很好的方法，该方法使我们能够按名称方便地拦截内核中的任何函数，并在其调用周围执行代码。 可以从可加载...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用ftrace拦截Linux内核中的函数</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413241/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/xy/k-/zy/xyk-zye1hkr1vaw41hvsxup3brc.png" alt="忍者企鹅（En3l）" align="right" width="40%"></a> 在与Linux系统安全性相关的一个项目中，我们需要拦截对内核内部重要功能的调用（例如打开文件和运行的进程），以提供监视系统活动并预防性地阻止可疑进程活动的能力。 <br><br> 在开发过程中，我们设法发明了一种很好的方法，该方法使我们能够按名称方便地拦截内核中的任何函数，并在其调用周围执行代码。 可以从可加载的GPL模块安装拦截器，而无需重建内核。 该方法支持用于x86_64体系结构的3.19+内核。 <br><a name="habracut"></a><br>  <font color="gray">（上图的企鹅图像： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">©En3l和DeviantArt</a> 。）</font> <br><br><h2> 已知方法 </h2><br><h3>  Linux安全性API </h3><br> 最正确的方法是使用<em>Linux Security API</em> ，这是专门为这些目的而创建的特殊接口。 在内核代码的关键位置，找到了对安全功能的调用，这些安全功能又依次调用了安全模块设置的回调。 安全模块可以检查操作的上下文并决定是允许还是拒绝操作。 <br><br> 不幸的是，Linux安全性API有两个重要的限制： <br><br><ul><li> 安全模块不能动态加载，它是内核的一部分，需要重建 </li><li> 系统中只能有一个安全模块（有一些例外） </li></ul><br> 如果内核开发人员对于模块的多样性持模棱两可的态度，则禁止动态加载是根本的：安全模块必须是内核的一部分，以便从加载时刻起就不断确保安全性。 <br><br> 因此，要使用Security API，必须提供自己的内核程序集，并将附加模块与SELinux或AppArmor集成在一起，流行的发行版都使用该模块。 客户不想订阅此类义务，因此该路线已关闭。 <br><br> 由于这些原因，安全性API不适合我们，否则将是理想的选择。 <br><br><h3> 修改系统调用表 </h3><br> 监视主要是针对用户应用程序执行的操作，因此，原则上可以在系统调用级别实施监视。 如您所知，Linux将所有系统调用处理程序存储在<code>sys_call_table</code>表中。 将该表中的值替换会导致整个系统的行为发生变化。 因此，保留处理程序的旧值并在表中替换我们自己的处理程序，我们可以拦截任何系统调用。 <br><br> 这种方法具有某些优点： <br><br><ul><li>  <strong>完全控制任何系统调用</strong> -用户应用程序到内核的唯一接口。 使用它，我们可以确保我们不会错过用户流程执行的任何重要操作。 <br></li><li>  <strong>最小的开销。</strong> 更新系统调用表时需要一笔一次性的资本投资。 除了不可避免的监视有效负载外，唯一的花费是额外的函数调用（调用原始系统调用处理程序）。 <br></li><li>  <strong>最低内核要求。</strong> 如果需要，此方法在内核中不需要任何其他配置选项，因此从理论上讲，它支持尽可能广泛的系统。 <br></li></ul><br> 但是，他也有一些缺点： <br><br><ul><li>  <strong>实施的技术复杂性。</strong> 就其本身而言，替换表中的指针并不困难。 但是相关任务需要非显而易见的解决方案和一定的资格： <br><ul><li> 搜索系统调用表 </li><li> 表修改保护旁路 </li><li> 原子和安全的替换 </li></ul><br> 这些都是有趣的事情，但是它们需要宝贵的开发时间，首先是实施，然后是支持和理解。 <br></li><li>  <strong>无法拦截某些处理程序。</strong> 在4.16版之前的内核中，针对x86_64体系结构的系统调用处理包含许多优化。 他们中的一些人要求系统调用处理程序是在汇编程序中实现的特殊适配器。 因此，此类处理程序有时很困难，有时甚至无法用C语言编写的您自己的处理程序来替换。 此外，在不同版本的内核中使用了不同的优化，这增加了储钱罐的技术难度。 <br></li><li>  <strong>仅系统调用被拦截。</strong> 这种方法允许您替换系统调用处理程序，从而将入口点限制为仅它们。 所有其他检查都在开始或结束时执行，而我们只有系统调用的参数及其返回值。 有时这导致需要重复检查参数和访问检查是否足够。 有时，当您需要两次复制用户进程的内存时，它会导致不必要的开销：如果参数是通过指针传递的，那么我们首先必须自己复制它，然后原始处理程序将再次为其自身复制参数。 另外，在某些情况下，系统调用提供的事件粒度太低，必须从噪声中另外过滤掉事件。 <br></li></ul><br> 最初，我们选择并成功实施了这种方法，以追求支持最多数量系统的好处。 但是，那时我们仍然不知道x86_64的功能以及对被拦截呼叫的限制。 后来发现，对于我们来说，支持与启动新进程相关的系统调用（clone（）和execve（））非常重要，这很特别。 这就是导致我们寻求新选项的原因。 <br><br><h3> 使用kprobes </h3><br> 被考虑的选项之一是使用<em>kprobes</em> ：一种专门设计用于调试和跟踪内核的专用API。 该接口允许您为内核中的<em>任何指令</em>设置前置和后处理器，以及为函数输入和返回的处理器。 处理程序可以访问寄存器并可以更改它们。 这样，我们既可以进行监视，又可以影响以后的工作过程。 <br><br> 使用kprobes进行拦截的好处： <br><br><ul><li>  <strong>成熟的API。</strong> 自远古时代（2002年）以来，Kprobes已经存在并得到了改善。 他们有一个文档齐全的界面，已经发现了大多数陷阱，并对其工作进行了尽可能多的优化，依此类推。 通常，与实验性的自制自行车相比，它具有很多优势。 <br></li><li>  <strong>截取核心中的任何位置。</strong>  Kprobes是使用嵌入在内核可执行代码中的断点（int3指令）实现的。 这样，您可以在任何功能中的任何位置安装kprobes（如果已知）。 同样，kretprobes是通过欺骗堆栈上的返回地址来实现的，并允许您拦截任何函数的返回（原则上不返回控制的函数除外）。 <br></li></ul><br>  kprobes的缺点： <br><br><ul><li>  <strong>技术难度。</strong>  Kprobes只是在内核中任何地方设置断点的一种方法。 要获取函数的参数或局部变量的值，您需要知道它们位于哪个寄存器中或位于堆栈中的位置，并从那里独立提取它们。 要阻止函数调用，您必须手动修改进程的状态，以便处理器认为它已经从函数中返回了控制。 <br></li><li>  <strong>Jprobes已过时。</strong>  Jprobes是kprobes的附加组件，它使您可以方便地拦截函数调用。 它将从寄存器或堆栈中独立提取函数的参数，并调用您的处理程序，该处理程序应具有与挂钩函数相同的签名。 问题在于，不推荐使用jprobes并从现代内核中删除它们。 <br></li><li>  <strong>非同寻常的开销。</strong> 断点很昂贵，但是只有一次。 断点不影响其他功能，但是它们的处理相对昂贵。 幸运的是，为x86_64体系结构实现了跳转优化，这大大降低了kprobes的成本，但与修改系统调用表时相比，它仍然具有更大的优势。 <br></li><li>  <strong>kretprobes的局限性。</strong>  Kretprobes是通过欺骗堆栈上的返回地址来实现的。 因此，他们需要将原始地址存储在某处，以便在处理kretprobe之后返回该地址。 地址存储在固定大小的缓冲区中。 如果发生溢出，当系统中同时执行太多被拦截函数的调用时，kretprobes将跳过操作。 <br></li><li>  <strong>禁用挤出。</strong> 由于kprobes基于中断并处理处理器寄存器，因此为了进行同步，所有处理程序都在禁用抢占的情况下执行。 这对处理程序施加了某些限制：您不能在处理程序中等待-分配大量内存，执行I / O，在计时器和信号灯中睡眠以及其他已知的事情。 <br></li></ul><br> 在研究该主题的过程中，我们的目光投向了可以代替jprobes的<strong>ftrace</strong>框架。 事实证明，它可以更好地满足我们的函数调用拦截需求。 但是，如果您需要在函数中跟踪特定的指令，则不应忽略kprobes。 <br><br><h3> 拼接 </h3><br> 为了完整起见，还值得描述截取函数的经典方法，该方法包括用导致我们的处理程序的无条件转换替换函数开头的指令。 原始指令将转移到另一个位置并执行，然后再返回到拦截的功能。 在两次转换的帮助下，我们将附加代码嵌入（拼接）到函数中，因此这种方法称为<em>splicing</em> 。 <br><br> 这就是实现kprobes的跳转优化的方式。 使用拼接，您可以实现相同的结果，但无需花费kprobes的额外费用，并且可以完全控制情况。 <br><br> 拼接的好处显而易见： <br><br><ul><li>  <strong>最低内核要求。</strong> 拼接在内核中不需要任何特殊选项，并且可以在任何函数开始时使用。 您只需要知道她的地址即可。 <br></li><li>  <strong>最小的开销。</strong> 两个无条件的转换-就是被拦截的代码需要执行的所有操作，才能将控制权转移给处理程序，反之亦然。 这样的过渡由处理器完美地预测并且非常便宜。 <br></li></ul><br> 但是，此方法的主要缺点严重影响了画面： <br><br><ul><li>  <strong>技术难度。</strong> 她翻身。 您不仅可以获取并重写机器代码。 这是要解决的任务的简短且不完整的列表： <br><ul><li> 安装和移除拦截的同步（如果在替换其指令的过程中直接调用该函数，该怎么办？） </li><li> 通过代码修改存储区域的保护绕过 </li><li> 替换指令后CPU缓存无效 </li><li> 分解可替换的说明以将其完整复制 </li><li> 检查更换的零件内部是否没有过渡 </li><li> 检查将替换的零件移动到另一个位置的能力 </li></ul><br> 是的，您可以监视kprobes并使用livepatch核内框架，但是最终解决方案仍然非常复杂。 很难想象每个新实现中会有多少睡眠问题。 <br></li></ul><br> 通常，如果您能够调用此恶魔（仅服从初始化对象），并准备在代码中忍受它，则拼接是截取函数调用的一种完全有效的方法。 我对编写自行车持消极态度，因此，如果现成的解决方案变得更简单，则根本无法取得进展，那么该选项对我们仍然是一个备份。 <br><br><h2>  ftrace的新方法 </h2><br>  <strong>Ftrace</strong>是功能级别的内核跟踪框架。 它从2008年开始开发，具有用于用户程序的出色界面。  Ftrace允许您跟踪函数调用的频率和持续时间，显示调用图，按模板过滤感兴趣的函数，等等。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从此处</a>开始阅读有关ftrace功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的信息</a> ，然后按照链接和官方文档进行操作。 <br><br> 它基于编译器键<code>-pg</code>和<code>-mfentry</code>实现ftrace，这两个键在每个函数的开头插入对特殊跟踪函数mcount（）或__fentry __（）的调用。 通常，在用户程序中，分析器使用此编译器功能来跟踪对所有函数的调用。 内核使用这些功能来实现ftrace框架。 <br><br> 当然，从<em>每个</em>函数调用ftrace并不便宜，因此可以对流行的体系结构进行优化： <em>dynamic ftrace</em> 。 最重要的是，内核知道所有对mcount（）或__fentry __（）的调用的位置，并且在加载的早期阶段将其机器代码替换为nop-一种不执行任何操作的特殊指令。 当所需的函数中包含跟踪时，ftrace调用将被添加回去。 因此，如果不使用ftrace，则它对系统的影响是最小的。 <br><br><h3> 所需功能的说明 </h3><br> 每个截获的函数可以通过以下结构描述： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * struct ftrace_hook -    * * @name:    * * @function:  -,     *   * * @original:   ,     *  ,    * * @address:   ,    * * @ops:   ftrace,  , *      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *function; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *original; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br> 用户只需要填写前三个字段：名称，功能，原始字段。 其余字段被视为实现细节。 所有拦截函数的描述都可以组装成一个数组，并且宏可以用来提高代码的紧凑性： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOOK(_name, _function, _original) \ { \ .name = (_name), \ .function = (_function), \ .original = (_original), \ } static struct ftrace_hook hooked_functions[] = { HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_clone"</span></span></span><span class="hljs-meta">, fh_sys_clone, &amp;real_sys_clone), HOOK(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sys_execve"</span></span></span><span class="hljs-meta">, fh_sys_execve, &amp;real_sys_execve), };</span></span></code> </pre><br> 拦截函数的包装如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *        execve(). *     .      *  :       , *    ABI (  "asmlinkage"). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*real_sys_execve)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* *      .   —  *   .      *  .      ,  *    . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br> 如您所见，拦截的函数具有最少的额外代码。 唯一需要仔细注意的是函数签名。 它们必须一对一匹配。 显然，没有这个，论点将被错误地传递，一切将变得艰难。 拦截系统调用的重要性不那么重要，因为它们的处理程序非常稳定，并且为了提高效率，以与系统调用自身相同的顺序接受参数。 但是，如果您打算拦截其他函数，则应记住， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内核内部没有稳定的接口</a> 。 <br><br><h3>  Ftrace初始化 </h3><br> 首先，我们需要找到并保存将拦截的函数的地址。  Ftrace允许您按名称跟踪函数，但是我们仍然需要知道原始函数的地址才能调用它。 <br><br> 您可以使用<em>kallsyms</em>获得地址-内核中所有字符的列表。 该列表包括<em>所有</em>字符，不仅是为模块导出的。 获取钩子函数的地址看起来像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_hook_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ hook-&gt;address = kallsyms_lookup_name(hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hook-&gt;address) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unresolved symbol: %s\n"</span></span>, hook-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOENT; } *((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) hook-&gt;original) = hook-&gt;address; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 接下来，您需要初始化<code>ftrace_ops</code>结构。 具有约束力 <br> 该字段只是<em>func</em> ，表示回调，但我们还需要 <br> 设置一些重要标志： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = resolve_hook_address(hook); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; hook-&gt;ops.func = fh_ftrace_thunk; hook-&gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_IPMODIFY; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre><br>  <em>fh_ftrace_thunk</em> （）是ftrace在跟踪函数时将调用的回调。 稍后关于他。 我们设置的标志是完成拦截所必需的。 它们指示ftrace保存和恢复处理器寄存器，我们可以在回调中更改其内容。 <br><br> 现在我们准备启用拦截。 为此，您必须首先使用ftrace_set_filter_ip（）为我们感兴趣的功能启用ftrace，然后允许ftrace使用register_ftrace_function（）调用回调： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_install_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } err = register_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"register_ftrace_function() failed: %d\n"</span></span>, err); <span class="hljs-comment"><span class="hljs-comment">/*    ftrace   . */</span></span> ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 拦截功能类似地被关闭，只是顺序相反： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_remove_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct ftrace_hook *hook)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err; err = unregister_ftrace_function(&amp;hook-&gt;ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"unregister_ftrace_function() failed: %d\n"</span></span>, err); } err = ftrace_set_filter_ip(&amp;hook-&gt;ops, hook-&gt;address, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { pr_debug(<span class="hljs-string"><span class="hljs-string">"ftrace_set_filter_ip() failed: %d\n"</span></span>, err); } }</code> </pre><br> 在完成对unregister_ftrace_function（）的调用之后，可以确保系统（及其包装程序）中没有激活已安装的回调。 因此，例如，我们可以安全地卸载拦截器模块，而不必担心我们系统中的某些功能仍在执行（因为如果它们消失了，处理器将会感到不安）。 <br><br><h3> 执行功能挂钩 </h3><br> 拦截实际上是如何进行的？ 很简单  Ftrace允许您在退出回调后更改寄存器的状态。 通过更改％rip寄存器（指向下一条可执行指令的指针），我们可以更改处理器执行的指令-也就是说，我们可以强制其执行从当前功能到我们函数的无条件转换。 这样我们就可以控制了。 <br><br>  ftrace的回调如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br> 使用container_of（）宏，我们获得嵌入在其中的<code>struct ftrace_hook</code>的地址的<code>struct ftrace_hook</code>的地址，然后用处理程序的地址替换<code>struct pt_regs</code>结构中的％rip寄存器值。 仅此而已。 对于x86_64以外的体系结构，可以以不同的方式调用此寄存器（例如IP或PC），但是该思想原则上适用于它们。 <br><br> 请注意为回调添加了<strong>notrace限定词</strong> 。 它们可以标记不允许使用ftrace跟踪的功能。 例如，这就是跟踪过程中涉及的ftrace自身功能的标记方式。 这有助于防止跟踪内核中的所有功能时系统陷入无限循环（ftrace可以做到这一点）。 <br><br>  ftback回调通常在禁用挤压的情况下进行调用（例如kprobes）。 可能会有例外，但是您不应该依赖它们。 但是，对于我们而言，此限制并不重要，因此我们仅替换结构中的八个字节。 <br><br> 稍后将调用的包装器函数将在与原始函数相同的上下文中执行。 因此，您可以在其中执行拦截函数中允许执行的操作。 例如，如果拦截中断处理程序，则仍然无法在包装器中休眠。 <br><br><h3> 递归呼叫保护 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面的代码有一个陷阱：当我们的包装器调用原始函数时，它将再次陷入ftrace，后者将再次调用我们的回调，这将把控制权再次传递给包装器。这种无限递归需要以某种方式缩短。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对我们来说，最优雅的方法是使用</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ftrace回调的参数之一，该参数包含调用跟踪函数的函数的返回地址。通常，此参数用于构造函数调用图。我们可以使用它来区分被重复调用函数的第一个调用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确实，在回拨时</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该指向我们的包装内部，而在第一个位置-内核中另一个位置。</font><font style="vertical-align: inherit;">只有在首次调用该函数时，才应转移控制权，而应允许所有其他函数执行原始函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将地址与当前模块（包含我们所有功能）的边界进行比较，可以非常有效地执行条目检查。</font><font style="vertical-align: inherit;">如果仅在模块中包装程序调用被拦截的函数，则此方法非常有用。</font><font style="vertical-align: inherit;">否则，您需要更具选择性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，正确的ftrace回调如下：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> notrace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_ftrace_thunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> parent_ip, struct ftrace_ops *ops, struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hook</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ftrace_hook</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ops</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!within_module(parent_ip, THIS_MODULE)) regs-&gt;ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;function; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这种方法的特色/优势： </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低开销。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是一些减去和比较。</font><font style="vertical-align: inherit;">没有自旋锁，列表传递等。</font></font><br></li><li> <strong>   .</strong>         .       ,         . <br></li><li> <strong>   .</strong>     <em>kretprobes</em>         ,     (      ).           ,       . <br></li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看一个例子：您在终端中键入</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ls命令</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以查看当前目录中的文件列表。外壳程序（例如Bash）使用</font><font style="vertical-align: inherit;">C标准库中的</font><font style="vertical-align: inherit;">一对传统的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）+ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数来启动新进程</font><font style="vertical-align: inherit;">。在内部，这些功能分别通过系统调用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone（）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execve（）实现</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。假设我们拦截execve（）系统调用以控制新进程的启动。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以图形形式，处理程序函数的截取如下所示：</font></font><br><br><img alt="截取顺序图" src="https://habrastorage.org/webt/ok/mm/4x/okmm4xnova8g2nfmx7y60oocuju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们看到用户进程（</font></font><font color="#66B2FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蓝色</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">如何</font><font style="vertical-align: inherit;">对内核（</font><font color="#EA6B66"><font style="vertical-align: inherit;">红色</font></font><font style="vertical-align: inherit;">）进行系统调用</font></font><font color="#EA6B66"><font style="vertical-align: inherit;"></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其中ftrace框架（</font></font><font color="#A680B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紫色</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）从我们的模块（</font></font><font color="#97D077"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绿色</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">调用函数</font><font style="vertical-align: inherit;">。</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户进程执行SYSCALL。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此指令，将转移内核模式，并将控制权转移到低级系统调用处理程序</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-entry_SYSCALL_64</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。</font><font style="vertical-align: inherit;">他负责64位内核上的所有64位程序的系统调用。</font></font><br></li><li> <strong>    .</strong>     , <a href="">  </a> ,      <em>do_syscall_64</em> (), <a href="">  </a> .            <code>sys_call_table</code>          —       <em>sys_execve</em> (). <br></li><li> <strong> ftrace.</strong>         <em>__fentry__</em> (),    ftrace.  ,    ,       <em>nop</em> ,      sys_execve()   . <br></li><li> <strong>Ftrace   .</strong>    ftrace     ,   .         ,    %rip,       . <br></li><li> <strong>  .</strong>     <code>parent_ip</code> ,   do_syscall_64() —        sys_execve() —     ,   <em> %rip</em>   <code>pt_regs</code> . <br></li><li> <strong>Ftrace  .</strong>   FTRACE_SAVE_REGS, ftrace      <code>pt_regs</code>   .    ftrace     .     %rip —      —          . <br></li><li> <strong>  -.</strong> -     sys_execve()   .       <em>fh_sys_execve</em> ().           ,                do_syscall_64(). <br></li><li> <strong>   .</strong>          .  fh_sys_execve()        (  )       .        .        — sys_execve()  ,   <em>real_sys_execve</em> ,      . <br></li><li> <strong>  .</strong>      sys_execve(),     ftrace     . ,       -… <br></li><li> <strong>   .</strong>       sys_execve()    fh_sys_execve(),     do_syscall_64().         sys_execve()   .     : ftrace    sys_execve() . <br></li><li> <strong>  .</strong>       sys_execve()      fh_sys_execve().        .   ,    execve()  ,   ,     ,  . . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理回到核心。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，fh_sys_execve（）完成，控制权传递给do_syscall_64（），后者认为系统调用照常完成。</font><font style="vertical-align: inherit;">核心继续其核业务。</font></font><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理返回到用户流程。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，内核执行IRET指令（或SYSRET，但对于execve（），它始终是IRET），为新的用户进程设置寄存器，并使中央处理器进入用户代码执行模式。</font><font style="vertical-align: inherit;">系统调用（并开始新过程）已完成。</font></font><br></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 优缺点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结果，我们获得了一种非常方便的方法来拦截内核中的任何函数，该方法具有以下优点： </font></font><br><br><ul><li> <strong> API   .</strong>        .       ,     ,      .   —   -,    . <br></li><li> <strong>    .</strong>            .   -     ,     ,  ,  - .      (    ),    . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侦听与跟踪兼容。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，此方法与ftrace不冲突，因此您仍然可以从内核中获取非常有用的性能指标。</font><font style="vertical-align: inherit;">使用kprobes或剪接会干扰ftrace机制。</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该解决方案的缺点是什么？ </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核配置要求。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用ftrace成功执行函数挂钩，内核必须提供许多功能：</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kallsyms字符列表，用于按名称搜索功能 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一般用于跟踪的ftrace框架 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ftrace关键拦截选项 </font></font></li></ul><br>                . ,  ,   ,        ,           . ,     -  ,       . <br></li><li> <strong>   ftrace</strong> ,   kprobes (  ftrace    ),   ,   ,  . , <em> ftrace</em> —      ,    «»  ftrace   . <br></li><li> <strong>  .</strong>    ,      . ,         ,  ftrace    . ,         ,       . <br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两次调用ftrace。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面描述的指针分析方法</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次导致对钩子函数的ftrace调用。</font><font style="vertical-align: inherit;">这会增加一些开销，并且会中断其他跟踪，而这些跟踪将看到两倍的呼叫。</font><font style="vertical-align: inherit;">可以通过施加一点黑魔法来避免此缺点：ftrace调用位于函数的开头，因此，如果将原始函数的地址向前移5个字节（调用指令的长度），则可以跳过ftrace。</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更详细地考虑一些缺点。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内核配置要求 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于初学者，内核必须支持ftrace和kallsyms。</font><font style="vertical-align: inherit;">为此，必须启用以下选项：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 配置文件 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_KALLSYMS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，ftrace应该支持动态寄存器修改。</font><font style="vertical-align: inherit;">该选项对此负责。</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_DYNAMIC_FTRACE_WITH_REGS </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，使用的内核必须基于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.19或更高版本</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，才能访问FTRACE_OPS_FL_IPMODIFY标志。</font><font style="vertical-align: inherit;">较早版本的内核也可以替换％rip寄存器，但是从3.19开始，只有在设置该标志后才能执行此操作。</font><font style="vertical-align: inherit;">旧内核标志的存在将导致编译错误，而新内核标志的缺失将导致空闲拦截。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，要执行拦截，ftrace调用的位置至关重要：该调用必须位于函数序言之前的最开始处（在该序言中为局部变量分配空间并形成堆栈框架）。</font><font style="vertical-align: inherit;">该选件考虑了此体系结构功能</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CONFIG_HAVE_FENTRY </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86_64体系结构支持此选项，但i386不支持。</font><font style="vertical-align: inherit;">由于i386体系结构的限制，编译器无法在函数序言之前插入ftrace调用，因此，在调用ftrace时，函数堆栈已被修改。</font><font style="vertical-align: inherit;">在这种情况下，要进行拦截，仅改变％eip寄存器的值是不够的-您还必须撤消在序言中执行的所有因函数而异的所有操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，ftrace拦截不支持x86 32位体系结构。</font><font style="vertical-align: inherit;">原则上，可以借助某些黑魔法（生成并执行“反序言”）来实现它，但是此解决方案的技术简单性将受到损害，这是使用ftrace的优点之一。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不明显的惊喜 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在测试期间，我们遇到了一个有趣的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在某些发行版中，挂钩函数导致系统崩溃。自然，这仅发生在开发人员使用的系统以外的系统上。该问题也没有在具有任何发行版和内核版本的原始拦截原型上重现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试表明，挂起发生在拦截的函数内部。出于某种神秘的原因，当在ftrace回调内部调用原始函数时，将</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续在内核代码中而不是包装函数代码中指定</font><font style="vertical-align: inherit;">地址</font><font style="vertical-align: inherit;">。因此，出现了一个无限循环，因为ftrace一遍又一遍地调用了我们的包装器，而没有执行任何有用的动作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，我们既可以使用工作代码，也可以使用损坏的代码，因此找到差异只是时间问题。</font><font style="vertical-align: inherit;">统一代码并丢弃所有不必要的内容后，将版本之间的差异本地化为包装函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此选项有效：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_debug(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是这个-挂了系统： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ret; pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() called: filename=%p argv=%p envp=%p\n"</span></span>, filename, argv, envp); ret = real_sys_execve(filename, argv, envp); pr_devel(<span class="hljs-string"><span class="hljs-string">"execve() returns: %ld\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，日志记录级别会影响行为吗？对这两个函数的机器代码进行仔细研究后，很快就弄清了情况，并引起了编译器的责任感。通常，他在宇宙射线附近的可疑名单上，但这次不在。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，对pr_devel（）的调用被扩展为void。此版本的printk宏用于在开发过程中进行日志记录。这样的日志条目在操作过程中并不有趣，因此，如果未声明DEBUG宏，则会自动从代码中删除它们。之后，编译器的功能变为：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fh_sys_execve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_sys_execve(filename, argv, envp); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化就在这里。</font><font style="vertical-align: inherit;">在这种情况下，它的工作所谓的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优化尾调用</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（尾调用优化）。</font><font style="vertical-align: inherit;">如果一个函数调用另一个函数并立即返回其值，则它允许编译器用直接跳转到其主体的方式替换诚实函数调用。</font><font style="vertical-align: inherit;">在机器代码中，诚实的呼叫看起来像这样：</font></font><br><br><pre> <code class="hljs xml">0000000000000000 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve</span></span></span><span class="hljs-tag">&gt;</span></span>: 0: e8 00 00 00 00 callq 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fh_sys_execve+0x5</span></span></span><span class="hljs-tag">&gt;</span></span> 5: ff 15 00 00 00 00 callq *0x0(%rip) b: f3 c3 repz retq</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 和无效-像这样： </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;fh_sys_execve&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: e8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> callq <span class="hljs-number"><span class="hljs-number">5</span></span> &lt;fh_sys_execve+<span class="hljs-number"><span class="hljs-number">0x5</span></span>&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> mov <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rip),%rax c: ff e<span class="hljs-number"><span class="hljs-number">0</span></span> jmpq *%rax</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个CALL语句与编译器在所有函数的开头插入的__fentry __（）调用相同。但是在普通代码中，您还可以通过CALL指令看到对real_sys_execve的调用（通过内存中的指针），并使用RET指令从fh_sys_execve（）返回。损坏的代码直接使用JMP转到real_sys_execve（）函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过优化尾部调用，您可以节省一些无意义的堆栈帧，其中包括CALL指令存储在堆栈中的返回地址。但是，对于我们来说，回信地址的正确性起着至关重要的作用-我们用它</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来做出有关拦截的决定。经过优化后，fh_sys_execve（）函数不再将新的返回地址保存在堆栈上，而是保留了旧的-指向内核。因此</font></font><code>parent_ip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续指向原子核内部，最终导致形成无限循环。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这也解释了为什么该问题仅在某些发行版中出现。编译模块时，不同的发行版使用不同的编译标志集。在遇险发行版中，默认情况下启用了尾部调用优化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决该问题的方法是使用包装函数禁用整个文件的尾部调用优化：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> GCC optimize(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-fno-optimize-sibling-calls"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还能说什么呢？为Linux内核开发低级代码很有趣。</font><font style="vertical-align: inherit;">我希望此出版物能为某人节省一些时间，以帮助他们编写出世界上最好的防病毒软件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想自己尝试拦截，那么可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上找到完整的内核模块代码</font><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413241/">https://habr.com/ru/post/zh-CN413241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413231/index.html">智能合约简介</a></li>
<li><a href="../zh-CN413233/index.html">uLogin服务将数据从表单（邮件，电话）发送到第三方站点，并且对此保持沉默</a></li>
<li><a href="../zh-CN413235/index.html">押注更好的预测：天气预报的新数学</a></li>
<li><a href="../zh-CN413237/index.html">Facebook否认向设备制造商发送与开发商Alexander Kogan相同的数据</a></li>
<li><a href="../zh-CN413239/index.html">如何使智能手机变得笨拙</a></li>
<li><a href="../zh-CN413243/index.html">数据学院：如何将数学与商业结合</a></li>
<li><a href="../zh-CN413245/index.html">在杜比全景声（Dolby Atmos）设备上-仅“本机”声音。 杜比禁止非本地混音</a></li>
<li><a href="../zh-CN413247/index.html">为什么要监视存储系统？</a></li>
<li><a href="../zh-CN413249/index.html">编写Linux内核模块：I2C</a></li>
<li><a href="../zh-CN413251/index.html">聚合酶链反应和符拉迪沃斯托克（海参div）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>