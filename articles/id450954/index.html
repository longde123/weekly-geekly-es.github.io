<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅 🏞️ 👨🏻 Bagaimana kami belajar mengeksploitasi Java di Docker ⭕️ 🦉 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bawah tenda, hh.ru berisi sejumlah besar layanan Java yang berjalan dalam wadah buruh pelabuhan. Selama operasi mereka, kami menghadapi banyak masa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami belajar mengeksploitasi Java di Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/450954/">  Di bawah tenda, hh.ru berisi sejumlah besar layanan Java yang berjalan dalam wadah buruh pelabuhan.  Selama operasi mereka, kami menghadapi banyak masalah non-sepele.  Dalam banyak kasus, untuk mendapatkan bagian bawah dari solusi, saya harus google untuk waktu yang lama, membaca sumber OpenJDK dan bahkan profil layanan pada produksi.  Dalam artikel ini saya akan mencoba menyampaikan intisari dari pengetahuan yang diperoleh dalam proses tersebut. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Batas CPU</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker dan mesin kelas server</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Batas CPU (ya, lagi) dan fragmentasi memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami memproses Java-OOM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengoptimalkan pemakaian memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membatasi pemakaian memori: heap, non-heap, direct memory</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membatasi konsumsi memori: Pelacakan Memori Asli</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java dan drive</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara melacak semuanya?</a> </li></ul><br><a name="habracut"></a><a name="cpu"></a><h4>  Batas CPU </h4><br>  Kami dulu tinggal di mesin virtual kvm dengan keterbatasan CPU dan memori dan, pindah ke Docker, menetapkan pembatasan serupa di cgroup.  Dan masalah pertama yang kami temui justru batas CPU.  Saya harus mengatakan segera bahwa masalah ini tidak lagi relevan untuk versi terbaru Java 8 dan Java ≥ 10. Jika Anda mengikuti perkembangan zaman, Anda dapat melewati bagian ini dengan aman. <br><br>  Jadi, kami memulai layanan kecil di wadah dan melihat bahwa itu menghasilkan sejumlah besar utas.  Atau CPU mengkonsumsi jauh lebih dari yang diharapkan, batas waktu berapa banyak yang sia-sia.  Atau inilah situasi sebenarnya: di satu mesin layanan mulai normal, dan di mesin lain, dengan pengaturan yang sama, crash, dipaku oleh pembunuh OOM. <br><br>  Solusinya ternyata sangat sederhana - hanya Java tidak melihat keterbatasan <code>--cpus</code> ditetapkan di buruh pelabuhan dan percaya bahwa semua kernel dari mesin host dapat diakses.  Dan mungkin ada banyak dari mereka (dalam pengaturan standar kami - 80). <br>  Perpustakaan menyesuaikan ukuran kumpulan utas dengan jumlah prosesor yang tersedia - karenanya jumlah utas yang sangat besar. <br>  Java sendiri menskala jumlah thread GC dengan cara yang sama, sehingga konsumsi CPU dan waktu tunggu - layanan mulai menghabiskan sejumlah besar sumber daya untuk pengumpulan sampah, menggunakan bagian terbesar dari kuota yang dialokasikan untuk itu. <br>  Juga, perpustakaan (khususnya Netty) dapat, dalam kasus-kasus tertentu, menyesuaikan ukuran memori off-pinggul dengan jumlah CPU, yang mengarah pada kemungkinan tinggi melebihi batas yang ditetapkan untuk wadah ketika dijalankan pada perangkat keras yang lebih kuat. <br><br>  Pada awalnya, ketika masalah ini memanifestasikan dirinya, kami mencoba menggunakan putaran kerja berikut: <br>  - Mencoba menggunakan beberapa layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libnumcpus</a> - perpustakaan yang memungkinkan Anda untuk "menipu" Java dengan mengatur sejumlah prosesor yang tersedia; <br>  - secara eksplisit menunjukkan jumlah utas GC, <br>  - secara eksplisit menetapkan batas penggunaan buffer byte langsung. <br><br>  Tapi, tentu saja, bergerak dengan kruk seperti itu tidak nyaman, dan pindah ke Jawa 10 (dan kemudian Jawa 11), di mana semua masalah ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak ada</a> , adalah solusi nyata.  Dalam keadilan, perlu dikatakan bahwa dalam delapan juga, semuanya baik-baik saja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembaruan 191</a> , dirilis pada Oktober 2018.  Pada saat itu sudah tidak relevan bagi kami, yang juga saya harapkan untuk Anda. <br><br>  Ini adalah salah satu contoh di mana memperbarui versi Java tidak hanya memberikan kepuasan moral, tetapi juga keuntungan nyata yang nyata dalam bentuk operasi yang disederhanakan dan peningkatan kinerja layanan. <br><br><a name="server-class"></a><h4>  Docker dan mesin kelas server </h4><br>  Jadi, di Java 10, opsi <code>-XX:ActiveProcessorCount</code> dan <code>-XX:+UseContainerSupport</code> muncul (dan di-backport ke Java 8), dengan mempertimbangkan batas cgroup default.  Sekarang semuanya indah.  Atau tidak? <br><br>  Beberapa waktu setelah kami pindah ke Jawa 10/11, kami mulai melihat beberapa keanehan.  Untuk beberapa alasan, di beberapa layanan, grafik GC tampak seperti mereka tidak menggunakan G1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/69/bo/gc69boghbrkf2wmxiuioszq5qgg.png"></div><br><br>  Ini, secara sederhana, sedikit tidak terduga, karena kami tahu pasti bahwa G1 adalah kolektor default, dimulai dengan Java 9. Pada saat yang sama, tidak ada masalah seperti itu di beberapa layanan - G1 dihidupkan, seperti yang diharapkan. <br><br>  Kita mulai memahami dan menemukan sesuatu yang <a href="">menarik</a> .  Ternyata jika Java berjalan pada kurang dari 3 prosesor dan dengan batas memori kurang dari 2 GB, maka itu menganggap dirinya sebagai klien dan tidak memungkinkan untuk menggunakan apa pun selain SerialGC. <br><br>  By the way, ini hanya mempengaruhi <a href="">pilihan GC</a> dan tidak ada hubungannya dengan -client / -server dan opsi kompilasi JIT. <br><br>  Jelas, ketika kami menggunakan Java 8, itu tidak memperhitungkan batas buruh pelabuhan dan berpikir bahwa ia memiliki banyak prosesor dan memori.  Setelah memutakhirkan ke Java 10, banyak layanan dengan batas yang ditetapkan lebih rendah tiba-tiba mulai menggunakan SerialGC.  Untungnya, ini diperlakukan sangat sederhana - dengan secara eksplisit mengatur opsi <code>-XX:+AlwaysActAsServerClassMachine</code> . <br><br><a name="malloc"></a><h4>  Batas CPU (ya, lagi) dan fragmentasi memori </h4><br>  Melihat grafik dalam pemantauan, kami entah bagaimana memperhatikan bahwa Resident Set Size dari wadah terlalu besar - sebanyak tiga kali lebih banyak dari ukuran pinggul maksimum.  Mungkinkah ini terjadi dalam beberapa mekanisme rumit berikutnya yang berskala sesuai dengan jumlah prosesor dalam sistem dan tidak tahu tentang keterbatasan buruh pelabuhan? <br><br>  Ternyata mekanismenya sama sekali tidak rumit - ini adalah malloc terkenal dari glibc.  Singkatnya, glibc menggunakan arena yang disebut untuk mengalokasikan memori.  Saat membuat, setiap utas ditugaskan ke salah satu arena.  Ketika utas yang menggunakan glibc ingin mengalokasikan sejumlah memori di tumpukan asli untuk kebutuhannya dan memanggil malloc, maka memori tersebut dialokasikan di arena yang ditugaskan padanya.  Jika arena menyajikan beberapa utas, maka utas ini akan bersaing untuk itu.  Semakin banyak arena, semakin sedikit kompetisi, tetapi semakin banyak fragmentasi, karena setiap arena memiliki daftar area bebas sendiri. <br><br>  Pada sistem 64-bit, jumlah arena default diatur ke 8 * jumlah CPU.  Jelas, ini adalah overhead yang besar bagi kami, karena tidak semua CPU tersedia untuk wadah.  Selain itu, untuk aplikasi berbasis Java, persaingan untuk arena tidak begitu relevan, karena sebagian besar alokasi dilakukan di Java-heap, memori yang dapat dialokasikan sepenuhnya pada saat startup. <br><br>  Fitur malloc ini telah dikenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejak lama</a> , dan juga solusinya - untuk menggunakan variabel lingkungan <code>MALLOC_ARENA_MAX</code> untuk secara eksplisit menunjukkan jumlah arena.  Sangat mudah dilakukan untuk wadah apa pun.  Berikut adalah efek menentukan <code>MALLOC_ARENA_MAX = 4</code> untuk backend utama kami: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jk/zq/lo/jkzqlo_pqiu4xppzbe-itkjvviy.png"></div><br><br>  Ada dua contoh pada grafik RSS: dalam satu (biru) kita nyalakan <code>MALLOC_ARENA_MAX</code> , yang lain (merah) baru saja kita restart.  Perbedaannya jelas. <br><br>  Tapi setelah itu, ada keinginan yang masuk akal untuk mencari tahu apa yang pada umumnya digunakan memori Jawa.  Apakah mungkin untuk menjalankan microservice di Jawa dengan batas memori 300-400 megabyte dan tidak takut itu akan jatuh dari Java-OOM atau tidak dibunuh oleh sistem OOM killer? <br><br><a name="oom"></a><h4>  Kami memproses Java-OOM </h4><br>  Pertama-tama, Anda perlu mempersiapkan diri untuk fakta bahwa OOM tidak bisa dihindari, dan Anda harus menanganinya dengan benar - setidaknya menyelamatkan pinggul.  Anehnya, usaha sederhana ini pun memiliki nuansa tersendiri.  Misalnya, dump hip tidak ditimpa - jika dump hip dengan nama yang sama sudah disimpan, maka yang baru tidak akan dibuat. <br><br>  Java dapat <a href="">secara otomatis menambahkan</a> nomor seri dump dan memproses id ke nama file, tetapi ini tidak akan membantu kami.  Nomor seri tidak berguna, karena ini adalah OOM, dan bukan hip-dump yang diminta secara rutin - aplikasi restart setelah itu, mengatur ulang penghitung.  Dan id proses tidak cocok, karena di buruh pelabuhan selalu sama (paling sering 1). <br><br>  Karena itu, kami sampai pada opsi ini: <br><br> <code>-XX:+HeapDumpOnOutOfMemoryError <br> -XX:+ExitOnOutOfMemoryError <br> -XX:HeapDumpPath=/var/crash/java.hprof <br> -XX:OnOutOfMemoryError="mv /var/crash/java.hprof /var/crash/heapdump.hprof"</code> <br> <br>  Ini cukup sederhana dan dengan beberapa peningkatan Anda bahkan dapat mengajarkan untuk menyimpannya tidak hanya hip-dump terbaru, tetapi untuk kebutuhan kita ini lebih dari cukup. <br><br>  Java OOM bukan satu-satunya hal yang harus kita hadapi.  Setiap wadah memiliki batas pada memori yang ditempatinya, dan itu dapat dilampaui.  Jika ini terjadi, maka wadah tersebut dibunuh oleh sistem OOM killer dan restart (kami menggunakan <code>restart_policy: always</code> ).  Secara alami, ini tidak diinginkan, dan kami ingin belajar cara menetapkan batas sumber daya yang digunakan oleh JVM dengan benar. <br><br><a name="opt-mem"></a><h4>  Mengoptimalkan pemakaian memori </h4><br>  Tetapi sebelum menetapkan batasan, Anda perlu memastikan bahwa JVM tidak membuang sumber daya.  Kami telah berhasil mengurangi konsumsi memori dengan menggunakan batasan jumlah CPU dan variabel <code>MALLOC_ARENA_MAX</code> .  Apakah ada cara "hampir bebas" lainnya untuk melakukan ini? <br><br>  Ternyata ada beberapa trik lagi yang akan menghemat sedikit memori. <br><br>  Yang pertama adalah penggunaan opsi <code>-Xss</code> (atau <code>-XX:ThreadStackSize</code> ), yang mengontrol ukuran tumpukan untuk utas.  Default untuk JVM 64-bit adalah 1 MB.  Kami menemukan bahwa 512 KB sudah cukup untuk kami.  Karena itu, StackOverflowException belum pernah ditangkap sebelumnya, tetapi saya akui bahwa ini tidak cocok untuk semua orang.  Dan untung dari ini sangat kecil. <br><br>  Yang kedua adalah <code>-XX:+UseStringDeduplication</code> (dengan G1 GC diaktifkan).  Ini memungkinkan Anda untuk menghemat memori dengan menciutkan duplikat baris karena beban prosesor tambahan.  Pengorbanan antara memori dan CPU hanya tergantung pada aplikasi spesifik dan pengaturan mekanisme deduplikasi itu sendiri.  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dok</a> dan uji dalam layanan Anda, kami memiliki opsi ini belum menemukan aplikasinya. <br><br>  Dan akhirnya, metode yang tidak cocok untuk semua orang (tapi itu cocok untuk kita) adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jemalloc</a> bukan dari malloc asli.  Implementasi ini diarahkan untuk mengurangi fragmentasi memori dan dukungan multithreading yang lebih baik dibandingkan dengan malloc dari glibc.  Untuk layanan kami, jemalloc memberikan sedikit peningkatan memori dibandingkan malloc dengan <code>MALLOC_ARENA_MAX=4</code> , tanpa mempengaruhi kinerja secara signifikan. <br><br>  Opsi lain, termasuk yang dijelaskan oleh Alexei Shipilev di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JVM Anatomy Quark # 12: Native Memory Tracking</a> , tampak agak berbahaya atau menyebabkan penurunan kinerja yang nyata.  Namun, untuk tujuan pendidikan, saya sarankan membaca artikel ini. <br><br>  Sementara itu, mari kita beralih ke topik berikutnya dan, akhirnya, coba pelajari cara membatasi konsumsi memori dan pilih batas yang benar. <br><br><a name="lim-mem-1"></a><h4>  Membatasi pemakaian memori: heap, non-heap, direct memory </h4><br>  Untuk melakukan semuanya dengan benar, Anda perlu mengingat memori apa yang secara umum terdiri dari Java.  Pertama, mari kita lihat kumpulan yang statusnya dapat dimonitor melalui JMX. <br><br>  Yang pertama, tentu saja, <b>pinggul</b> .  Sederhana saja: kami <code>-Xmx</code> , tapi bagaimana cara melakukannya dengan benar?  Sayangnya, tidak ada resep universal di sini, semuanya tergantung pada aplikasi dan memuat profil.  Untuk layanan baru, kami mulai dengan ukuran tumpukan yang relatif masuk akal (128 MB) dan, jika perlu, menambah atau menguranginya.  Untuk mendukung yang sudah ada, ada pemantauan dengan grafik konsumsi memori dan metrik GC. <br><br>  Pada saat yang sama dengan <code>-Xms == -Xmx</code> kita mengatur <code>-Xms == -Xmx</code> .  Kami tidak memiliki memori yang berlebihan, sehingga kami berkepentingan agar layanan menggunakan sumber daya yang kami berikan semaksimal mungkin.  Selain itu, dalam layanan biasa kami menyertakan <code>-XX:+AlwaysPreTouch</code> dan mekanisme Transparent Huge Pages: <code>-XX:+UseTransparentHugePages -XX:+UseLargePagesInMetaspace</code> .  Namun, sebelum mengaktifkan THP, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dengan seksama dan uji bagaimana layanan berperilaku dengan opsi ini untuk waktu yang lama.  Kejutan tidak dikesampingkan pada mesin dengan RAM yang tidak mencukupi (misalnya, kami harus mematikan THP di bangku tes). <br><br>  Berikutnya adalah <b>non-heap</b> .  Memori non-tumpukan meliputi: <br>  - Metaspace dan Ruang Kelas Terkompresi, <br>  - Kode Cache. <br><br>  Pertimbangkan kolam-kolam ini secara berurutan. <br><br>  Tentu saja, semua orang telah mendengar tentang <b>Metaspace</b> , saya tidak akan membicarakannya secara detail.  Ini menyimpan metadata kelas, metode bytecode, dan sebagainya.  Faktanya, penggunaan Metaspace secara langsung tergantung pada jumlah dan ukuran kelas yang dimuat, dan Anda dapat menentukannya, seperti hip, hanya dengan meluncurkan aplikasi dan menghapus metrik melalui JMX.  Secara default, Metaspace tidak dibatasi oleh apa pun, tetapi cukup mudah untuk melakukan ini dengan opsi <code>-XX:MaxMetaspaceSize</code> . <br><br>  <b>Ruang Kelas Terkompresi</b> adalah bagian dari Metaspace dan muncul ketika opsi <code>-XX:+UseCompressedClassPointers</code> diaktifkan (diaktifkan secara default untuk tumpukan kurang dari 32 GB, yaitu, ketika itu dapat memberikan peningkatan memori nyata).  Ukuran kumpulan ini dapat dibatasi oleh opsi <code>-XX:CompressedClassSpaceSize</code> , tetapi tidak masuk akal, karena Ruang Kelas Terkompresi termasuk dalam Metaspace dan jumlah total memori yang dikunci untuk Metaspace dan Ruang Kelas Terkompresi pada akhirnya terbatas pada satu <code>-XX:MaxMetaspaceSize</code> . <br><br>  Omong-omong, jika Anda melihat pembacaan JMX, maka jumlah memori non-heap selalu dihitung sebagai <a href="">jumlah dari</a> Metaspace, Ruang Kelas Terkompresi dan Kode Cache.  Bahkan, Anda hanya perlu meringkas Metaspace dan CodeCache. <br><br>  Jadi, di non-heap hanya <b>Code Cache yang</b> tersisa - repositori kode yang dikompilasi oleh kompiler JIT.  Secara default, ukuran maksimumnya diatur ke 240 MB, dan untuk layanan kecil beberapa kali lebih besar dari yang diperlukan.  Ukuran Cache Kode dapat diatur dengan opsi <code>-XX:ReservedCodeCacheSize</code> .  Ukuran yang benar hanya dapat ditentukan dengan menjalankan aplikasi dan mengikutinya di bawah profil memuat khas. <br><br>  Penting untuk tidak membuat kesalahan di sini, karena Cache Kode tidak cukup menghapus kode lama dan dingin dari cache (opsi <code>-XX:+UseCodeCacheFlushing</code> diaktifkan secara default), dan ini, pada gilirannya, dapat menyebabkan konsumsi CPU yang lebih tinggi dan penurunan kinerja. .  Akan lebih bagus jika Anda bisa melempar OOM ketika Code Cache meluap, untuk ini bahkan ada <code>-XX:+ExitOnFullCodeCache</code> , tetapi, sayangnya, itu hanya tersedia dalam <a href="">versi pengembangan</a> JVM. <br><br>  Kumpulan terakhir yang berisi informasi dalam JMX adalah <b>memori langsung</b> .  Secara default, ukurannya tidak terbatas, jadi penting untuk menetapkan semacam batasan untuk itu - setidaknya perpustakaan seperti Netty, yang secara aktif menggunakan buffer byte langsung, akan dipandu olehnya.  Tidaklah sulit untuk menetapkan batas menggunakan <code>-XX:MaxDirectMemorySize</code> , dan, sekali lagi, hanya pemantauan yang akan membantu kami menentukan nilai yang benar. <br><br>  Jadi apa yang kita dapatkan sejauh ini? <br><br><pre>  Memori proses Java = 
     Heap + Metaspace + Kode Cache + Memori Langsung =
         -Xmx +
         -XX: MaxMetaspaceSize +
         -XX: ReservedCodeCacheSize +
         -XX: MaxDirectMemorySize </pre><br><br>  Mari kita coba menggambar semuanya pada bagan dan membandingkannya dengan wadah buruh pelabuhan RSS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/ue/fx/pguefx_0kisoyxg8mna7dxlmimo.png"></div><br><br>  Baris di atas adalah RSS dari wadah dan itu adalah satu setengah kali lebih banyak dari konsumsi memori JVM, yang dapat kita pantau melalui JMX. <br><br>  Menggali lebih jauh! <br><br><a name="lim-mem-2"></a><h4>  Membatasi konsumsi memori: Pelacakan Memori Asli </h4><br>  Tentu saja, selain memori heap, non-heap, dan direct, JVM menggunakan sejumlah kumpulan memori lainnya.  Bendera <code>-XX:NativeMemoryTracking=summary</code> akan membantu kami <code>-XX:NativeMemoryTracking=summary</code> .  Dengan mengaktifkan opsi ini, kami akan dapat memperoleh informasi tentang kumpulan yang diketahui oleh JVM, tetapi tidak tersedia di JMX.  Anda dapat membaca lebih lanjut tentang menggunakan opsi ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  Mari kita mulai dengan yang paling jelas - memori yang ditempati oleh <b>tumpukan benang</b> .  NMT menghasilkan sesuatu seperti berikut ini untuk layanan kami: <br><br><pre>  Utas (dicadangkan = 32166KB, berkomitmen = 5358KB)
     (utas # 52)
     (tumpukan: dicadangkan = 31920KB, berkomitmen = 5112KB)
     (malloc = 185KB # 270) 
     (arena = 61KB # 102) </pre><br>  Ngomong-ngomong, ukurannya juga dapat ditemukan tanpa Native Memory Tracking, menggunakan jstack dan menggali sedikit ke <code>/proc/&lt;pid&gt;/smaps</code> .  Andrey Pangin memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utilitas khusus</a> untuk ini. <br><br>  Ukuran <b>Ruang Kelas Bersama</b> bahkan lebih mudah untuk dievaluasi: <br><br><pre>  Ruang kelas bersama (disediakan = 17084KB, berkomitmen = 17084KB)
     (mmap: dicadangkan = 17084KB, berkomitmen = 17084KB) </pre><br>  Ini adalah mekanisme Berbagi Data Kelas, <code>-Xshare</code> dan <code>-XX:+UseAppCDS</code> .  Di Java 11, opsi <code>-Xshare</code> diatur ke otomatis secara default, yang berarti bahwa jika Anda memiliki <code>$JAVA_HOME/lib/server/classes.jsa</code> (ini ada dalam gambar docker OpenJDK resmi), ia akan memuat peta memori- Ohm saat startup JVM, mempercepat waktu startup.  Dengan demikian, ukuran Ruang Kelas Bersama mudah untuk ditentukan jika Anda mengetahui ukuran jsa-arsip. <br><br>  Berikut ini adalah struktur <b>pengumpul sampah</b> asli: <br><br><pre>  GC (dicadangkan = 42137KB, berkomitmen = 41801KB)
     (malloc = 5705KB # 9460) 
     (mmap: dicadangkan = 36432KB, berkomitmen = 36096KB) </pre><br>  Alexey Shipilev dalam manual yang sudah disebutkan tentang Native Memory Tracking <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa mereka menempati sekitar 4-5% dari ukuran heap, tetapi dalam pengaturan kami untuk heap kecil (hingga beberapa ratus megabyte) overhead mencapai 50% dari ukuran heap. <br><br>  Banyak ruang dapat ditempati oleh <b>tabel simbol</b> : <br><br><pre>  Simbol (dilindungi = 16421KB, berkomitmen = 16421KB)
     (malloc = 15261KB # 203089) 
     (arena = 1159KB # 1) </pre><br>  Mereka menyimpan nama metode, tanda tangan, serta tautan ke string yang diinternir.  Sayangnya, tampaknya mungkin untuk mengestimasi ukuran tabel simbol hanya post factum menggunakan Native Memory Tracking. <br><br>  Apa yang tersisa  Menurut Native Memory Tracking, cukup banyak hal: <br><br><pre>  Kompiler (dicadangkan = 509KB, berkomitmen = 509KB)
 Internal (dicadangkan = 1647KB, berkomitmen = 1647KB)
 Lainnya (dicadangkan = 2110KB, berkomitmen = 2110KB)
 Arena Chunk (disediakan = 1712KB, berkomitmen = 1712KB)
 Logging (dicadangkan = 6KB, berkomitmen = 6KB)
 Argumen (milik = 19KB, berkomitmen = 19KB)
 Modul (disediakan = 227KB, berkomitmen = 227KB)
 Tidak dikenal (disediakan = 32KB, berkomitmen = 32KB) </pre><br>  Tetapi semua ini membutuhkan sedikit ruang. <br><br>  Sayangnya, banyak dari area memori yang disebutkan tidak dapat dibatasi atau dikendalikan, dan jika bisa, konfigurasi akan berubah menjadi neraka.  Bahkan memantau status mereka adalah tugas yang tidak sepele, karena dimasukkannya Native Memory Tracking sedikit menguras kinerja aplikasi dan memungkinkannya pada produksi dalam layanan kritis bukanlah ide yang baik. <br><br>  Namun demikian, demi kepentingan, mari kita coba untuk merefleksikan semua grafik yang dilaporkan oleh Pelacakan Memori Asli: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t_/5d/kn/t_5dkncjh0wrn9qmftrp3wgwg2w.png"></div><br><br>  Tidak buruk!  Perbedaan yang tersisa adalah overhead untuk fragmentasi / alokasi memori (sangat kecil, karena kami menggunakan jemalloc) atau memori yang dialokasikan libs asli.  Kami hanya menggunakan salah satunya untuk penyimpanan efisien dari pohon awalan. <br><br>  Jadi, untuk kebutuhan kita, cukup membatasi apa yang kita bisa: Heap, Metaspace, Code Cache, Direct Memory.  Untuk yang lainnya, kami meninggalkan beberapa dasar yang masuk akal, yang ditentukan oleh hasil pengukuran praktis. <br><br>  Setelah berurusan dengan CPU dan memori, kami beralih ke sumber daya berikutnya di mana aplikasi dapat bersaing - ke disk. <br><br><a name="disks"></a><h4>  Java dan drive </h4><br>  Dan dengan mereka, semuanya sangat buruk: mereka lambat dan dapat menyebabkan aplikasi terlihat kusam.  Karena itu, kami melepaskan ikatan Java dari disk sebanyak mungkin: <br><br><ul><li>  Kami menulis semua log aplikasi ke syslog lokal melalui UDP.  Ini menyisakan beberapa peluang bahwa log yang diperlukan akan hilang di suatu tempat di sepanjang jalan, tetapi, seperti yang telah ditunjukkan oleh praktik, kasus-kasus seperti itu sangat jarang. </li><li>  Kami akan menulis log JVM dalam tmpfs, untuk ini kita hanya perlu memasang docker ke lokasi yang diinginkan dengan <code>/dev/shm</code> . </li></ul><br><br>  Jika kita menulis log di syslog atau di tmpfs, dan aplikasi itu sendiri tidak menulis apa pun ke disk kecuali untuk dump hip, maka ternyata cerita dengan disk dapat dianggap ditutup pada ini? <br><br>  Tentu saja tidak. <br><br>  Kami memperhatikan grafik durasi stop-the-world jeda dan kami melihat gambar sedih - Stop-The-World-jeda pada host adalah ratusan milidetik, dan pada satu host mereka dapat mencapai hingga satu detik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nd/pb/tfndpbg7mtpaylny7-cflvrukzg.png"></div><br><br>  Tidak perlu dikatakan bahwa ini berdampak negatif pada aplikasi?  Di sini, misalnya, adalah grafik yang mencerminkan waktu respons layanan menurut pelanggan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nc/d0/_n/ncd0_ndoybiyy42wzrh68ppj-_0.png"></div><br><br>  Ini adalah layanan yang sangat sederhana, sebagian besar memberikan tanggapan dalam cache, jadi dari mana waktu penghalang seperti itu, dimulai dengan persentil ke-95?  Layanan lain memiliki gambar yang serupa, selain itu, timeout hujan dengan keteguhan yang patut ditiru saat mengambil koneksi dari kumpulan koneksi ke database, ketika mengeksekusi permintaan, dan sebagainya. <br><br>  Apa hubungannya dengan drive itu?  - kamu bertanya.  Ternyata sangat banyak hubungannya dengan itu. <br>  Analisis terperinci masalah menunjukkan bahwa jeda STW yang panjang muncul karena fakta bahwa utas pergi ke titik aman untuk waktu yang lama.  Setelah membaca kode JVM, kami menyadari bahwa selama sinkronisasi utas pada safepoint, JVM dapat menulis file <code>/tmp/hsperfdata*</code> melalui peta memori, yang diekspor beberapa statistik.  Utilitas seperti <code>jstat</code> dan <code>jstat</code> menggunakan <code>jps</code> <code>jstat</code> . <br><br>  Nonaktifkan pada mesin yang sama dengan opsi <code>-XX:+PerfDisableSharedMem</code> dan ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1r/aw/q7/1rawq7kjvmrjznko2781or7kzdm.png"></div><br><br>  Metrik treadpool dermaga menstabilkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/bs/pj/qzbspjvpdjfhjjtbwrn6et55wns.png"></div><br><br>         (,         ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ni/ig/ji/niigjizzguoke8dcfdz2ssqnqa8.png"></div><br><br>  ,         ,  ,        . <br><br><a name="monitor"></a><h4>    ? </h4><br>     Java-  , ,  ,    . <br><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nuts and Bolts</a> ,          .              ,     .     ,      ,  JMX. <br><br>      ,          .          . <br><br>     statsd    JVM,    (heap,   non-heap   ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n9/iw/vs/n9iwvsjan7hxeo-xsksaggthrqy.png"></div><br><br>  ,    ,       . <br><br>    —       ,    ,  ,    ,    ?        .     ()  -,     ,   RPS   . <br><br>     :   ,              .         .        ammo-  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> .    . : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/ry/wh/qrrywh-id3u5lbk7ldms8n-n_ck.png"></div><br><br>        . <br><br>               ,     .  ,      ,     - ,   ,   . <br><br><h4>  Kesimpulannya </h4><br>   ,  Java  Docker —    ,      .     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450954/">https://habr.com/ru/post/id450954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450942/index.html">Sespan untuk pemecahan kode</a></li>
<li><a href="../id450946/index.html">Disk Cell Phone di LPC810</a></li>
<li><a href="../id450948/index.html">MU-MIMO: salah satu algoritma implementasi</a></li>
<li><a href="../id450950/index.html">Dasar-Dasar Aliran Dart</a></li>
<li><a href="../id450952/index.html">Indeks Sedang dan Antibank</a></li>
<li><a href="../id450956/index.html">Perbandingan COB industri: ISIM vs Kics</a></li>
<li><a href="../id450958/index.html">AnyStub, perpustakaan rintisan koneksi Java</a></li>
<li><a href="../id450962/index.html">Pompa insulin, microchip yang rusak, dan radio yang ditentukan oleh perangkat lunak</a></li>
<li><a href="../id450964/index.html">Pustaka intrinsik x86 SIMD baru - debug immintrin</a></li>
<li><a href="../id450966/index.html">Merekam video dari komputer lama - metode dari LGR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>