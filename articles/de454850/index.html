<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏿 😀 🍓 Die Entwicklung eines einzelnen Algorithmus 🛏️ 🚬 🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit bat mich mein Kollege, ihm bei einem Problem zu helfen. Ich habe das Problem für ihn gelöst, aber außerdem schien es mir, dass bei de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Entwicklung eines einzelnen Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p> Vor einiger Zeit bat mich mein Kollege, ihm bei einem Problem zu helfen.  Ich habe das Problem für ihn gelöst, aber außerdem schien es mir, dass bei der Lösung dieses Problems verschiedene Programmieralgorithmen und -techniken erklärt werden können.  Und zeigen Sie auch die Beschleunigung der Ausführungszeit des Algorithmus von 25 Sekunden auf 40 ms. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  Erklärung des Problems </h1><br><p>  Für ein persönliches Projekt benötigte mein Kollege einen Algorithmus, um fünfzig ähnlichste Videos für ein bestimmtes Video zu finden.  Die Ähnlichkeit sollte durch die Anzahl der übereinstimmenden exponierten Tags geschätzt werden.  Je mehr Tags mit dem Video übereinstimmen, desto ähnlicher sind sie.  Daraus können wir sofort mehrere Schlussfolgerungen ziehen: </p><br><ul><li>  Alle Tags unter dem Video können zu einer Gruppe zusammengefasst werden. </li><li>  Es wird definitiv nicht mehr solche Gruppen geben als die Videos selbst; </li><li>  Wenn das Video einem anderen Video aus einer bestimmten Gruppe von Tags ähnlich ist, ähnelt es auch anderen Videos aus dieser Gruppe. </li></ul><br><p>  Es stellt sich heraus, dass es ausreicht, nur mit Tag-Gruppen zu arbeiten.  In der ersten Version hat ein Kollege beschlossen, Tags in einer Tag-Tabelle zu speichern: Jedes Video hat einen Link zur Tag-Gruppen-ID, und die Gruppen selbst sind eine Folge von Booleschen Werten, die angeben, ob das entsprechende Tag festgelegt ist.  In C # sieht eine Tag-Gruppe folgendermaßen aus: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Ein Kollege schlug vor, dass er nicht mehr als eine Million Videos auf der Website und nicht mehr als 4.000 verschiedene Tags haben würde. Für ein rundes Konto können Sie 4096 = 2 ^ 12 verwenden. <br>  Dann kann die <code>TagsGroup</code> Klasse folgendermaßen dargestellt werden: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p>  Jetzt müssen Sie die beiden Gruppen von Tags auf Ähnlichkeit überprüfen.  Unter den aktuellen Bedingungen wird dies zu einer einfachen Überprüfung auf true in den entsprechenden Elementen der <code>InnerTags</code> Arrays von zwei Gruppen von Tags: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Jetzt müssen Sie nur noch die Ähnlichkeit der gewünschten Tag-Gruppe mit jeder vorhandenen Gruppe berechnen und die fünfzig ähnlichsten auswählen.  Ich habe mir eine andere Bedingung gestellt, um die Stabilität der Probe sicherzustellen, d.h.  In der endgültigen Stichprobe gibt es fünfzig Tag-Gruppen, für die <code>MeasureSimilarity</code> das höchste Ergebnis <code>MeasureSimilarity</code> hat, während Tag-Gruppen mit derselben <code>MeasureSimilarity</code> niedrigeren Index für diejenigen haben, die in der ursprünglich vorhandenen Gruppe einen niedrigeren Index hatten.  Weitere Details finden Sie beispielsweise hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://ru.wikipedia.org/wiki/Sustainable_Sort</a> . <br>  Um dieses Problem zu lösen, habe ich beschlossen, die <code>SimilarTagsCalculator</code> Klasse zu <code>SimilarTagsCalculator</code> . Hier ist der Code: </p><br><div class="spoiler">  <b class="spoiler_title">SimilarTagsCalculator</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p>  und die <code>TagsSimilarityInfo</code> Struktur: </p><br><div class="spoiler">  <b class="spoiler_title">TagsSimilarityInfo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p>  Ich habe drei Benchmarks für diesen Algorithmus vorbereitet: </p><br><ul><li>  vollständig zufälliger Benchmark, d.h.  Die Anzahl der gesetzten Tags in den Gruppen ist zufällig und die Tag-Gruppe, mit der wir vergleichen werden, ist ebenfalls zufällig. </li><li>  Die Anzahl der in Gruppen festgelegten Tags nimmt zu. Wir werden sie mit der Gruppe vergleichen, in der alle Tags festgelegt sind.  Es stellt sich heraus, dass einige der letzten Gruppen von Tags am besten geeignet sein sollten. </li><li>  das gleiche wie oben, aber die Anzahl der exponierten Tags nimmt ab.  Die ersten 50 Gruppen von Tags sind am besten geeignet. </li></ul><br><p>  Hier sind die Benchmark-Ergebnisse für eine Million Gruppen: </p><br><p>  BenchmarkDotNet = v0.11.5, OS = Windows 10.0.17134.765 (1803 / April2018Update / Redstone4) <br>  Intel Core i7-6700 CPU 3,40 GHz (Skylake), 1 CPU, 8 logische und 4 physische Kerne <br>  Frequenz = 3328126 Hz, Auflösung = 300,4694 ns, Timer = TSC <br>  .NET Core SDK = 3.0.100-Vorschau5-011568 <br>  [Host]: .NET Core 3.0.0-Vorschau5-27626-15 (CoreCLR 4.6.27622.75, CoreFX 4.700.19.22408), 64-Bit-RyuJIT </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  4,180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4,147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Die Streuung der Ausführungszeit ist sehr groß, außerdem sind 25 Sekunden eine sehr lange Zeit, mein Kollege stimmt nicht zu, so lange zu warten.  Lassen Sie uns also Optimierungen vornehmen.  Jetzt gibt es drei Hauptbereiche, um das Programm zu beschleunigen: </p><br><ul><li>  <code>MeasureSimilarity</code> Methode; </li><li>  ein Algorithmus im Hauptteil der Schleife in <code>GetFiftyMostSimilarGroups</code> ; </li><li>  die Schleife selbst in <code>GetFiftyMostSimilarGroups</code> ; </li></ul><br><p>  Wir werden jede der drei Richtungen nacheinander betrachten. </p><br><h1 id="predskazanie-vetvleniy">  Verzweigungsvorhersage </h1><br><p>  Betrachten Sie zunächst die <code>MeasureSimilarity</code> Methode. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Im vorherigen Benchmark gab es eine sehr große Variation in der Laufzeit zwischen dem Zufallstest und einem der sequentiellen.  Tag-Gruppen für sequentielle Tests wurden nach folgendem Prinzip erstellt: </p><br><ul><li>  Die erforderliche Anzahl von Gruppen wurde in Pakete aufgeteilt.  Anzahl der Pakete - die maximale Anzahl der Tags in der Gruppe; </li><li>  Für jede Gruppe im i-ten Paket wurden die ersten i-Tags festgelegt. </li></ul><br><p>  Es stellt sich heraus, dass jede Gruppe von Tags in diesen Tests aus zwei aufeinanderfolgenden Teilen von belichteten und nicht belichteten Tags besteht.  <code>MeasureSimilarity</code> hat alle Voraussetzungen, damit die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorhersage</a> des Prozessorzweigs unter den aktuellen Bedingungen einen signifikanten Effekt hat.  Um dies zu überprüfen, schreiben Sie einfach einen Benchmark, der die Laufzeit von MeasureSimilarity für zufällige und für sequentielle Daten vergleicht: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Unsortiert </td><td>  8,211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div><br><p>  Eine Million Tag-Gruppen wurden getestet, aber in <code>Sorted</code> in jeder Gruppe gab es zuerst mehrere exponierte Tags und dann nicht exponierte, und in <code>Unsorted</code> die gleiche Anzahl exponierter Tags zufällig über die Gruppe verteilt. <br>  Der Unterschied von 5 Sekunden ist beeindruckend und es muss etwas getan werden.  Um den Einfluss der Verzweigungsvorhersage zu beseitigen und die Methode im Allgemeinen zu beschleunigen, müssen Sie die Verzweigungen selbst beseitigen.  In <code>MeasureSimilarity</code> gibt es nur einen Zweig. Überprüfen Sie, ob die entsprechenden Tags in zwei Gruppen festgelegt sind.  Lassen Sie uns abschätzen, in welchen Fällen die Bedingung wahr sein wird. Dazu erstellen wir eine Tabelle mit der Wahrheit der Bedingung: </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th>  Ergebnis </th></tr></thead><tbody><tr><td>  Falsch </td><td>  Falsch </td><td>  Falsch </td></tr><tr><td>  Falsch </td><td>  Stimmt </td><td>  Falsch </td></tr><tr><td>  Stimmt </td><td>  Falsch </td><td>  Falsch </td></tr><tr><td>  Stimmt </td><td>  Stimmt </td><td>  Stimmt </td></tr></tbody></table></div><br><p>  Die Wahrheitstabelle stimmt vollständig mit dem logischen "UND" überein, d.h.  Das Ergebnis ist genau dann wahr, wenn beide Tags wahr sind. Dann kann die Bedingung auf <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> reduziert werden: <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> .  Auf diese Weise bleibt der Zustand jedoch bestehen.  Im nächsten Schritt stellen wir sicher, dass die Addition zum Ergebnis immer durchgeführt wird. Dazu schreiben wir den Körper der Schleife wie folgt um: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p>  Wir haben den Zustand immer noch nicht beseitigt und die Methode sogar langsamer gemacht.  Jetzt ist jedoch klar geworden, dass Sie die Bedingung im ternären Operator <code>InnerTags</code> , wenn der Typ von <code>InnerTags</code> von bool in byte geändert wird (1 für true und 0 für false).  Dann <code>TagsGroup</code> die <code>TagsGroup</code> Klasse folgendermaßen aus: </p><br><div class="spoiler">  <b class="spoiler_title">TagsGroup</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p>  Hier sind die Benchmark-Ergebnisse für die aktualisierte <code>MeasureSimilarity</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,180 s </td><td>  0,0118 s </td><td>  0,0111 s </td></tr><tr><td>  Unsortiert </td><td>  3,236 s </td><td>  0,0622 s </td><td>  0,0764 s </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">war:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Unsortiert </td><td>  8,211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div></div></div><br><p>  aber für das aktualisierte Hauptbechmark: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  3,219 s </td><td>  0,0492 s </td><td>  0,0436 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  3,223 s </td><td>  0,0117 s </td><td>  0,0110 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  3,422 s </td><td>  0,0697 s </td><td>  0,0999 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">war:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  4,180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4,147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div></div></div><br><p>  Meiner Meinung nach war es schon toll.  Für diejenigen, die davon überzeugt waren, dass die gesamte Beschleunigung nur stattfand, weil der boolesche Typ durch ein Byte ersetzt wurde, habe ich einen Benchmark für einen solchen Schleifenkörper gestartet: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p>  und das sind die Ergebnisse: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,760 s </td><td>  0,0746 s </td><td>  0,1541 s </td></tr><tr><td>  Unsortiert </td><td>  8,628 s </td><td>  0,1699 s </td><td>  0,2382 s </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh">  Datenverpackung </h1><br><p>  Jede Gruppe hat viele Tags und ihre Anzahl kann in keiner Weise reduziert werden.  Außerdem müssen Sie Tags mit demselben Index vergleichen, und Sie können keine endgültige Antwort geben, ohne alle Tags zu überprüfen.  In jedem Fall müssen wir also die gesamte Gruppe von Tags durchlaufen.  Es wäre großartig, diese Aufgabe irgendwie parallelisieren zu können, so dass es möglich wäre, mehrere Tags in einer bedingten Operation zu verarbeiten.  Sie können dies durch echte Parallelisierung oder durch spezielle Datenverpackungen tun, die wir verwenden werden.  Jedes Tag steht jetzt für 1 oder 0. Im <code>result</code> Ergebnis der Operation "AND" einfach akkumuliert.  Die gleiche logische Operation kann jedoch nicht nur auf Einzelbitzahlen angewendet werden.  Mit C # können Sie dies problemlos bis zu 64-Bit-Zahlen tun (Sie können mehr über <code>BitArray</code> tun, aber das ist es nicht).  Wenn wir zwei Gruppen von Tags als einen Satz von 64-Bit-Zahlen mit den entsprechenden gesetzten Bits darstellen, ist es möglich, eine "UND" -Operation für jede solche Gruppe von 64-Bit-Zahlen auszuführen.  Es ist nicht klar, was mit dem Ergebnis zu tun ist.  Schauen wir uns noch einmal den Körper der Schleife an: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p>  Das Ergebnis erhöht sich jedes Mal um 1, wenn t == 1 ist, und ändert sich nicht, wenn t == 0. Als Ergebnis entspricht das Ergebnis, wie oft das Ergebnis von <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> eins war.  Dementsprechend wäre es möglich, alle Ergebnisse von <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> in einer Art Array zu speichern und im Ergebnis nur die Anzahl der Einheiten in dieses Array zu schreiben.  Wenn die UND-Operation für mehr als n-Bit-Zahlen ausgeführt wird, ergibt sich ein n-Bit-Ergebnis, und es reicht aus, nur zu wissen, wie viele Bits unter n gesetzt sind.  Die Anzahl der in der Nummer gesetzten Bits bleibt unverändert, dh Sie können diese Nummern zählen.  Es macht keinen Sinn, für 64 Bit zu zählen  Wir werden nicht so viel RAM finden.  Für 32 Bit finden Sie bereits Platz auf modernen Computern, aber das ist immer noch sehr viel.  Speicher unter 16 Bit ist nicht schwer zu finden, aber die Berechnung ist relativ lang.  Berechnen wir als Kompromiss 8-Bit-Zahlen: </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p>  Jetzt sieht der TagsGroup-Konstruktor folgendermaßen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  Und <code>MeasureSimilarity</code> aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Sie können einen großen Benchmark durchführen und sicherstellen, dass alles besser ist: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  560,5 ms </td><td>  8,285 ms </td><td>  7,344 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  570,1 ms </td><td>  4,108 ms </td><td>  3,431 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  608,1 ms </td><td>  5,691 ms </td><td>  5,324 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Ist es möglich, die <code>MeasureSimilarity</code> Methode noch schneller zu machen?  Natürlich!  Um dies zu tun, reicht es aus, die Tatsache zu erkennen, dass Allzweckregister jetzt meistens 64-Bit sind und wir 8-Bit-Daten in sie treiben.  Erhöhen Sie dazu die Paketgröße, in die die ursprünglichen Tags gepackt werden, erhöhen Sie sie auf 64 Bit und schreiben Sie die erforderlichen Methoden neu: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  und es stellt sich heraus: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  533,3 ms </td><td>  4,802 ms </td><td>  4,492 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  550,9 ms </td><td>  5,435 ms </td><td>  5,084 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  567,6 ms </td><td>  3,879 ms </td><td>  3,439 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Dann können Sie die innere Schleife erweitern: </p><br><div class="spoiler">  <b class="spoiler_title">MeasureSimilarity</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  370,5 ms </td><td>  2,802 ms </td><td>  2,484 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  395,8 ms </td><td>  2,682 ms </td><td>  2,509 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  419,5 ms </td><td>  3,352 ms </td><td>  2,971 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Ist es noch schneller?  Ja!  Wenn Sie die Innovationen von .NET Core 3.0 verwenden.  Diese Version befindet sich zwar noch in der Vorschau, aber von Anfang an gibt es eine Implementierung einiger Eigenheiten.  Das Intel Intrinsic Guide enthält das intrinsische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>_mm_popcnt_u64</code></a> .  Welche, wie beschrieben: " <em>Zählen Sie die Anzahl der auf 1 gesetzten Bits in einer vorzeichenlosen 64-Bit-Ganzzahl a und geben Sie diese Anzahl in dst zurück.</em> "  Genau das wollen wir erreichen!  In .NET Core 3.0 Preview 5 ist dieses Intrinsic in <code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code> implementiert (Wie in den Kommentaren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">a-tk</a> korrekt angegeben, müssen Sie überprüfen, ob der Prozessor sie unterstützt, bevor Sie Intrinsics verwenden. Überprüfen Sie in diesem Fall die <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ).  Wenn Sie es verwenden, <code>MeasureSimilarity</code> der Code der <code>MeasureSimilarity</code> Methode folgendermaßen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  und Ausführungszeit: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  59,33 ms </td><td>  1,148 ms </td><td>  0,9585 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  74,87 ms </td><td>  1,479 ms </td><td>  1,9748 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  119,46 ms </td><td>  2,321 ms </td><td>  2,8509 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Beeindruckend. <br>  Ich kenne die Möglichkeiten nicht, die <code>MeasureSimilarity</code> erheblich beschleunigen und gleichzeitig die Lesbarkeit nicht wesentlich <code>MeasureSimilarity</code> können.  Ich denke, Sie können diese Methode beenden. </p><br><h1 id="struktury-dannyh">  Datenstrukturen </h1><br><p>  Jetzt werden wir uns mit dem Hauptteil der Schleife in der <code>GetFiftyMostSimilarGroups</code> Methode <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Lassen Sie mich kurz daran erinnern, was hier passiert: </p><br><ul><li>  Innerhalb der Liste wird eine sortierte Liste der fünfzig am besten geeigneten Tag-Gruppen gespeichert, und zwar von kleiner zu größer, wenn Sie <code>TagsSimilarityInfo</code> vergleichen. </li><li>  Fügen Sie die betreffende neue Gruppe unter Beibehaltung der Sortierung in die Liste ein. </li><li>  Wenn die Liste mehr als fünfzig Elemente enthält, löschen Sie die am wenigsten ähnliche Gruppe (ihr Info-Objekt ist das größte und befindet sich ganz am Ende der <code>list</code> ). </li></ul><br><p>  Das heißt,  Es stellt sich heraus, dass wir sehr schnell das größte Element in der Sammlung finden müssen, um es schnell einfügen und löschen zu können.  Um solche Probleme zu lösen, gibt es spezielle Datenstrukturen.  Das erste, was mir in den Sinn kommt, ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haufen</a> .  Ihre Einfügung erfolgt in O (log N), wobei das Maximum in O (1) ermittelt und ein Element in O (log N) entfernt wird.  Das einzige Problem ist, dass der Heap nicht von den zunehmenden Elementen iteriert werden kann, ohne ihn zu ändern.  Da es in BCL keinen binären Heap gibt, habe ich ihn selbst geschrieben: </p><br><div class="spoiler">  <b class="spoiler_title">Binärhaufen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  Die entsprechende Implementierung der <code>GetFiftyMostSimilarGroups</code> Methode finden Sie im Quellcode des Artikels (Link unten). <br>  Zusätzlich zum Heap wird möglicherweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">binärer Suchbaum</a> angezeigt.  Ein ausgeglichener binärer Suchbaum kann das Einfügen von O (log N) ermöglichen, ein Maximum für O (log N) erhalten und ein Element für O (log N) entfernen.  Der Vorteil einer solchen Struktur besteht darin, dass sie in aufsteigender Reihenfolge iteriert werden kann und außerdem der rot-schwarze Suchbaum in BCL in SortedSet implementiert ist (in einem großen Framework ist das Erhalten eines Maximums viel langsamer als in .netcore 3.0 und weist Speicher zu).  Die Implementierung von <code>GetFiftyMostSimilarGroups</code> für SortedSet finden Sie im Quellcode des Artikels. <br>  Benchmark-Ergebnisse für alle drei <code>GetFiftyMostSimilarGroups</code> Implementierungen: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Sortieralgorithmus </th><th>  Mittelwert </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zufälliger Test </td><td>  Liste </td><td>  60,06 ms </td><td>  1704 B. </td></tr><tr><td>  Zufälliger Test </td><td>  Sortiertes Set </td><td>  65,46 ms </td><td>  24384 B. </td></tr><tr><td>  Zufälliger Test </td><td>  Haufen </td><td>  60,55 ms </td><td>  2912 B. </td></tr><tr><td>  Aszendententest </td><td>  Liste </td><td>  75,42 ms </td><td>  1704 B. </td></tr><tr><td>  Aszendententest </td><td>  Sortiertes Set </td><td>  161,12 ms </td><td>  9833424 B. </td></tr><tr><td>  Aszendententest </td><td>  Haufen </td><td>  86,87 ms </td><td>  2912 B. </td></tr><tr><td>  DescendantTest </td><td>  Liste </td><td>  119,23 ms </td><td>  880 B. </td></tr><tr><td>  DescendantTest </td><td>  Sortiertes Set </td><td>  125,03 ms </td><td>  3024 B. </td></tr><tr><td>  DescendantTest </td><td>  Haufen </td><td>  118,62 ms </td><td>  2088 B. </td></tr></tbody></table></div><br><p>  Die ursprüngliche Implementierung mit einem Blatt gewinnt fast überall in der Zeit und sicherlich überall im Gedächtnis.  Dies geschieht aufgrund der Tatsache, dass für einen Algorithmus mit einem Blatt die Einfügung in O (log N) für die Suche und fast O (1) für die Einfügung durchgeführt wird, weil  Das Kopieren einer so kleinen Anzahl von Elementen erfolgt sehr schnell, wobei ein Maximum für O (1) erhalten wird und ein Element auch für O (1) gelöscht wird, weil  In .net wird das Löschen des letzten Elements aus dem Blatt ersetzt, indem in das letzte Element ein leerer Wert geschrieben wird (im .net-Kern wird nichts in Strukturen geschrieben).  Wenn es erforderlich wäre, nicht 50 auszugeben, aber sagen wir 1000 der ähnlichsten Gruppen, dann würde ein Algorithmus mit einem Blatt höchstwahrscheinlich nicht funktionieren.  In der Tat ist dies alles eine kleine spekulative Argumentation, weil  Sie können weiterhin jeden der Algorithmen anpassen. </p><br><h1 id="mnogopotochnost">  Multithreading </h1><br><p>  Jetzt muss noch versucht werden, die Schleife selbst in <code>GetFiftyMostSimilarGroups</code> zu verbessern.  Nur Multithreading fällt mir ein.  Die Idee ist, die gesamte Liste der Gruppen in mehrere Pakete aufzuteilen.  Suchen Sie in jedem Paket die 50 ähnlichsten Tag-Gruppen und unter ihnen die letzten 50 ähnlichsten. <br>  Die Multithread-Version von <code>GetFiftyMostSimilarGroups</code> sieht <code>GetFiftyMostSimilarGroups</code> aus: </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> —   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> — -      ; </li><li> <code>current</code> — -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454850/">https://habr.com/ru/post/de454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454830/index.html">3 Schlüsselqualitäten für einen erfolgreichen Produktmanager: Alexander Belyaev</a></li>
<li><a href="../de454832/index.html">Warum eine viertägige Arbeitswoche eine schlechte Geschichte ist</a></li>
<li><a href="../de454834/index.html">Die wirklichen Begriffe des Studiums des Touch-Tippens mit geringer Motivation</a></li>
<li><a href="../de454840/index.html">Sorgfältiger Umzug in die Niederlande mit seiner Frau und Hypothek. Teil 2: Dokumente vorbereiten und umziehen</a></li>
<li><a href="../de454844/index.html">Odigest: interessant für Designer der Woche</a></li>
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454860/index.html">Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterstützen</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454868/index.html">Kompilieren von C in WebAssembly ohne Emscripten</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>