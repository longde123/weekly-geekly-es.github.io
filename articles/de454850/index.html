<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèø üòÄ üçì Die Entwicklung eines einzelnen Algorithmus üõèÔ∏è üö¨ üîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit bat mich mein Kollege, ihm bei einem Problem zu helfen. Ich habe das Problem f√ºr ihn gel√∂st, aber au√üerdem schien es mir, dass bei de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Entwicklung eines einzelnen Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p> Vor einiger Zeit bat mich mein Kollege, ihm bei einem Problem zu helfen.  Ich habe das Problem f√ºr ihn gel√∂st, aber au√üerdem schien es mir, dass bei der L√∂sung dieses Problems verschiedene Programmieralgorithmen und -techniken erkl√§rt werden k√∂nnen.  Und zeigen Sie auch die Beschleunigung der Ausf√ºhrungszeit des Algorithmus von 25 Sekunden auf 40 ms. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  Erkl√§rung des Problems </h1><br><p>  F√ºr ein pers√∂nliches Projekt ben√∂tigte mein Kollege einen Algorithmus, um f√ºnfzig √§hnlichste Videos f√ºr ein bestimmtes Video zu finden.  Die √Ñhnlichkeit sollte durch die Anzahl der √ºbereinstimmenden exponierten Tags gesch√§tzt werden.  Je mehr Tags mit dem Video √ºbereinstimmen, desto √§hnlicher sind sie.  Daraus k√∂nnen wir sofort mehrere Schlussfolgerungen ziehen: </p><br><ul><li>  Alle Tags unter dem Video k√∂nnen zu einer Gruppe zusammengefasst werden. </li><li>  Es wird definitiv nicht mehr solche Gruppen geben als die Videos selbst; </li><li>  Wenn das Video einem anderen Video aus einer bestimmten Gruppe von Tags √§hnlich ist, √§hnelt es auch anderen Videos aus dieser Gruppe. </li></ul><br><p>  Es stellt sich heraus, dass es ausreicht, nur mit Tag-Gruppen zu arbeiten.  In der ersten Version hat ein Kollege beschlossen, Tags in einer Tag-Tabelle zu speichern: Jedes Video hat einen Link zur Tag-Gruppen-ID, und die Gruppen selbst sind eine Folge von Booleschen Werten, die angeben, ob das entsprechende Tag festgelegt ist.  In C # sieht eine Tag-Gruppe folgenderma√üen aus: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Ein Kollege schlug vor, dass er nicht mehr als eine Million Videos auf der Website und nicht mehr als 4.000 verschiedene Tags haben w√ºrde. F√ºr ein rundes Konto k√∂nnen Sie 4096 = 2 ^ 12 verwenden. <br>  Dann kann die <code>TagsGroup</code> Klasse folgenderma√üen dargestellt werden: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p>  Jetzt m√ºssen Sie die beiden Gruppen von Tags auf √Ñhnlichkeit √ºberpr√ºfen.  Unter den aktuellen Bedingungen wird dies zu einer einfachen √úberpr√ºfung auf true in den entsprechenden Elementen der <code>InnerTags</code> Arrays von zwei Gruppen von Tags: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Jetzt m√ºssen Sie nur noch die √Ñhnlichkeit der gew√ºnschten Tag-Gruppe mit jeder vorhandenen Gruppe berechnen und die f√ºnfzig √§hnlichsten ausw√§hlen.  Ich habe mir eine andere Bedingung gestellt, um die Stabilit√§t der Probe sicherzustellen, d.h.  In der endg√ºltigen Stichprobe gibt es f√ºnfzig Tag-Gruppen, f√ºr die <code>MeasureSimilarity</code> das h√∂chste Ergebnis <code>MeasureSimilarity</code> hat, w√§hrend Tag-Gruppen mit derselben <code>MeasureSimilarity</code> niedrigeren Index f√ºr diejenigen haben, die in der urspr√ºnglich vorhandenen Gruppe einen niedrigeren Index hatten.  Weitere Details finden Sie beispielsweise hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://ru.wikipedia.org/wiki/Sustainable_Sort</a> . <br>  Um dieses Problem zu l√∂sen, habe ich beschlossen, die <code>SimilarTagsCalculator</code> Klasse zu <code>SimilarTagsCalculator</code> . Hier ist der Code: </p><br><div class="spoiler">  <b class="spoiler_title">SimilarTagsCalculator</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p>  und die <code>TagsSimilarityInfo</code> Struktur: </p><br><div class="spoiler">  <b class="spoiler_title">TagsSimilarityInfo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p>  Ich habe drei Benchmarks f√ºr diesen Algorithmus vorbereitet: </p><br><ul><li>  vollst√§ndig zuf√§lliger Benchmark, d.h.  Die Anzahl der gesetzten Tags in den Gruppen ist zuf√§llig und die Tag-Gruppe, mit der wir vergleichen werden, ist ebenfalls zuf√§llig. </li><li>  Die Anzahl der in Gruppen festgelegten Tags nimmt zu. Wir werden sie mit der Gruppe vergleichen, in der alle Tags festgelegt sind.  Es stellt sich heraus, dass einige der letzten Gruppen von Tags am besten geeignet sein sollten. </li><li>  das gleiche wie oben, aber die Anzahl der exponierten Tags nimmt ab.  Die ersten 50 Gruppen von Tags sind am besten geeignet. </li></ul><br><p>  Hier sind die Benchmark-Ergebnisse f√ºr eine Million Gruppen: </p><br><p>  BenchmarkDotNet = v0.11.5, OS = Windows 10.0.17134.765 (1803 / April2018Update / Redstone4) <br>  Intel Core i7-6700 CPU 3,40 GHz (Skylake), 1 CPU, 8 logische und 4 physische Kerne <br>  Frequenz = 3328126 Hz, Aufl√∂sung = 300,4694 ns, Timer = TSC <br>  .NET Core SDK = 3.0.100-Vorschau5-011568 <br>  [Host]: .NET Core 3.0.0-Vorschau5-27626-15 (CoreCLR 4.6.27622.75, CoreFX 4.700.19.22408), 64-Bit-RyuJIT </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  4,180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4,147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Die Streuung der Ausf√ºhrungszeit ist sehr gro√ü, au√üerdem sind 25 Sekunden eine sehr lange Zeit, mein Kollege stimmt nicht zu, so lange zu warten.  Lassen Sie uns also Optimierungen vornehmen.  Jetzt gibt es drei Hauptbereiche, um das Programm zu beschleunigen: </p><br><ul><li>  <code>MeasureSimilarity</code> Methode; </li><li>  ein Algorithmus im Hauptteil der Schleife in <code>GetFiftyMostSimilarGroups</code> ; </li><li>  die Schleife selbst in <code>GetFiftyMostSimilarGroups</code> ; </li></ul><br><p>  Wir werden jede der drei Richtungen nacheinander betrachten. </p><br><h1 id="predskazanie-vetvleniy">  Verzweigungsvorhersage </h1><br><p>  Betrachten Sie zun√§chst die <code>MeasureSimilarity</code> Methode. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Im vorherigen Benchmark gab es eine sehr gro√üe Variation in der Laufzeit zwischen dem Zufallstest und einem der sequentiellen.  Tag-Gruppen f√ºr sequentielle Tests wurden nach folgendem Prinzip erstellt: </p><br><ul><li>  Die erforderliche Anzahl von Gruppen wurde in Pakete aufgeteilt.  Anzahl der Pakete - die maximale Anzahl der Tags in der Gruppe; </li><li>  F√ºr jede Gruppe im i-ten Paket wurden die ersten i-Tags festgelegt. </li></ul><br><p>  Es stellt sich heraus, dass jede Gruppe von Tags in diesen Tests aus zwei aufeinanderfolgenden Teilen von belichteten und nicht belichteten Tags besteht.  <code>MeasureSimilarity</code> hat alle Voraussetzungen, damit die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorhersage</a> des Prozessorzweigs unter den aktuellen Bedingungen einen signifikanten Effekt hat.  Um dies zu √ºberpr√ºfen, schreiben Sie einfach einen Benchmark, der die Laufzeit von MeasureSimilarity f√ºr zuf√§llige und f√ºr sequentielle Daten vergleicht: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Unsortiert </td><td>  8,211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div><br><p>  Eine Million Tag-Gruppen wurden getestet, aber in <code>Sorted</code> in jeder Gruppe gab es zuerst mehrere exponierte Tags und dann nicht exponierte, und in <code>Unsorted</code> die gleiche Anzahl exponierter Tags zuf√§llig √ºber die Gruppe verteilt. <br>  Der Unterschied von 5 Sekunden ist beeindruckend und es muss etwas getan werden.  Um den Einfluss der Verzweigungsvorhersage zu beseitigen und die Methode im Allgemeinen zu beschleunigen, m√ºssen Sie die Verzweigungen selbst beseitigen.  In <code>MeasureSimilarity</code> gibt es nur einen Zweig. √úberpr√ºfen Sie, ob die entsprechenden Tags in zwei Gruppen festgelegt sind.  Lassen Sie uns absch√§tzen, in welchen F√§llen die Bedingung wahr sein wird. Dazu erstellen wir eine Tabelle mit der Wahrheit der Bedingung: </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th>  Ergebnis </th></tr></thead><tbody><tr><td>  Falsch </td><td>  Falsch </td><td>  Falsch </td></tr><tr><td>  Falsch </td><td>  Stimmt </td><td>  Falsch </td></tr><tr><td>  Stimmt </td><td>  Falsch </td><td>  Falsch </td></tr><tr><td>  Stimmt </td><td>  Stimmt </td><td>  Stimmt </td></tr></tbody></table></div><br><p>  Die Wahrheitstabelle stimmt vollst√§ndig mit dem logischen "UND" √ºberein, d.h.  Das Ergebnis ist genau dann wahr, wenn beide Tags wahr sind. Dann kann die Bedingung auf <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> reduziert werden: <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> .  Auf diese Weise bleibt der Zustand jedoch bestehen.  Im n√§chsten Schritt stellen wir sicher, dass die Addition zum Ergebnis immer durchgef√ºhrt wird. Dazu schreiben wir den K√∂rper der Schleife wie folgt um: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p>  Wir haben den Zustand immer noch nicht beseitigt und die Methode sogar langsamer gemacht.  Jetzt ist jedoch klar geworden, dass Sie die Bedingung im tern√§ren Operator <code>InnerTags</code> , wenn der Typ von <code>InnerTags</code> von bool in byte ge√§ndert wird (1 f√ºr true und 0 f√ºr false).  Dann <code>TagsGroup</code> die <code>TagsGroup</code> Klasse folgenderma√üen aus: </p><br><div class="spoiler">  <b class="spoiler_title">TagsGroup</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p>  Hier sind die Benchmark-Ergebnisse f√ºr die aktualisierte <code>MeasureSimilarity</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,180 s </td><td>  0,0118 s </td><td>  0,0111 s </td></tr><tr><td>  Unsortiert </td><td>  3,236 s </td><td>  0,0622 s </td><td>  0,0764 s </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">war:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Unsortiert </td><td>  8,211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div></div></div><br><p>  aber f√ºr das aktualisierte Hauptbechmark: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  3,219 s </td><td>  0,0492 s </td><td>  0,0436 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  3,223 s </td><td>  0,0117 s </td><td>  0,0110 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  3,422 s </td><td>  0,0697 s </td><td>  0,0999 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">war:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  4,180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4,147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div></div></div><br><p>  Meiner Meinung nach war es schon toll.  F√ºr diejenigen, die davon √ºberzeugt waren, dass die gesamte Beschleunigung nur stattfand, weil der boolesche Typ durch ein Byte ersetzt wurde, habe ich einen Benchmark f√ºr einen solchen Schleifenk√∂rper gestartet: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p>  und das sind die Ergebnisse: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sortiert </td><td>  3,760 s </td><td>  0,0746 s </td><td>  0,1541 s </td></tr><tr><td>  Unsortiert </td><td>  8,628 s </td><td>  0,1699 s </td><td>  0,2382 s </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh">  Datenverpackung </h1><br><p>  Jede Gruppe hat viele Tags und ihre Anzahl kann in keiner Weise reduziert werden.  Au√üerdem m√ºssen Sie Tags mit demselben Index vergleichen, und Sie k√∂nnen keine endg√ºltige Antwort geben, ohne alle Tags zu √ºberpr√ºfen.  In jedem Fall m√ºssen wir also die gesamte Gruppe von Tags durchlaufen.  Es w√§re gro√üartig, diese Aufgabe irgendwie parallelisieren zu k√∂nnen, so dass es m√∂glich w√§re, mehrere Tags in einer bedingten Operation zu verarbeiten.  Sie k√∂nnen dies durch echte Parallelisierung oder durch spezielle Datenverpackungen tun, die wir verwenden werden.  Jedes Tag steht jetzt f√ºr 1 oder 0. Im <code>result</code> Ergebnis der Operation "AND" einfach akkumuliert.  Die gleiche logische Operation kann jedoch nicht nur auf Einzelbitzahlen angewendet werden.  Mit C # k√∂nnen Sie dies problemlos bis zu 64-Bit-Zahlen tun (Sie k√∂nnen mehr √ºber <code>BitArray</code> tun, aber das ist es nicht).  Wenn wir zwei Gruppen von Tags als einen Satz von 64-Bit-Zahlen mit den entsprechenden gesetzten Bits darstellen, ist es m√∂glich, eine "UND" -Operation f√ºr jede solche Gruppe von 64-Bit-Zahlen auszuf√ºhren.  Es ist nicht klar, was mit dem Ergebnis zu tun ist.  Schauen wir uns noch einmal den K√∂rper der Schleife an: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p>  Das Ergebnis erh√∂ht sich jedes Mal um 1, wenn t == 1 ist, und √§ndert sich nicht, wenn t == 0. Als Ergebnis entspricht das Ergebnis, wie oft das Ergebnis von <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> eins war.  Dementsprechend w√§re es m√∂glich, alle Ergebnisse von <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> in einer Art Array zu speichern und im Ergebnis nur die Anzahl der Einheiten in dieses Array zu schreiben.  Wenn die UND-Operation f√ºr mehr als n-Bit-Zahlen ausgef√ºhrt wird, ergibt sich ein n-Bit-Ergebnis, und es reicht aus, nur zu wissen, wie viele Bits unter n gesetzt sind.  Die Anzahl der in der Nummer gesetzten Bits bleibt unver√§ndert, dh Sie k√∂nnen diese Nummern z√§hlen.  Es macht keinen Sinn, f√ºr 64 Bit zu z√§hlen  Wir werden nicht so viel RAM finden.  F√ºr 32 Bit finden Sie bereits Platz auf modernen Computern, aber das ist immer noch sehr viel.  Speicher unter 16 Bit ist nicht schwer zu finden, aber die Berechnung ist relativ lang.  Berechnen wir als Kompromiss 8-Bit-Zahlen: </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p>  Jetzt sieht der TagsGroup-Konstruktor folgenderma√üen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  Und <code>MeasureSimilarity</code> aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Sie k√∂nnen einen gro√üen Benchmark durchf√ºhren und sicherstellen, dass alles besser ist: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  560,5 ms </td><td>  8,285 ms </td><td>  7,344 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  570,1 ms </td><td>  4,108 ms </td><td>  3,431 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  608,1 ms </td><td>  5,691 ms </td><td>  5,324 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Ist es m√∂glich, die <code>MeasureSimilarity</code> Methode noch schneller zu machen?  Nat√ºrlich!  Um dies zu tun, reicht es aus, die Tatsache zu erkennen, dass Allzweckregister jetzt meistens 64-Bit sind und wir 8-Bit-Daten in sie treiben.  Erh√∂hen Sie dazu die Paketgr√∂√üe, in die die urspr√ºnglichen Tags gepackt werden, erh√∂hen Sie sie auf 64 Bit und schreiben Sie die erforderlichen Methoden neu: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  und es stellt sich heraus: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  533,3 ms </td><td>  4,802 ms </td><td>  4,492 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  550,9 ms </td><td>  5,435 ms </td><td>  5,084 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  567,6 ms </td><td>  3,879 ms </td><td>  3,439 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Dann k√∂nnen Sie die innere Schleife erweitern: </p><br><div class="spoiler">  <b class="spoiler_title">MeasureSimilarity</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  370,5 ms </td><td>  2,802 ms </td><td>  2,484 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  395,8 ms </td><td>  2,682 ms </td><td>  2,509 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  419,5 ms </td><td>  3,352 ms </td><td>  2,971 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Ist es noch schneller?  Ja!  Wenn Sie die Innovationen von .NET Core 3.0 verwenden.  Diese Version befindet sich zwar noch in der Vorschau, aber von Anfang an gibt es eine Implementierung einiger Eigenheiten.  Das Intel Intrinsic Guide enth√§lt das intrinsische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>_mm_popcnt_u64</code></a> .  Welche, wie beschrieben: " <em>Z√§hlen Sie die Anzahl der auf 1 gesetzten Bits in einer vorzeichenlosen 64-Bit-Ganzzahl a und geben Sie diese Anzahl in dst zur√ºck.</em> "  Genau das wollen wir erreichen!  In .NET Core 3.0 Preview 5 ist dieses Intrinsic in <code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code> implementiert (Wie in den Kommentaren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">a-tk</a> korrekt angegeben, m√ºssen Sie √ºberpr√ºfen, ob der Prozessor sie unterst√ºtzt, bevor Sie Intrinsics verwenden. √úberpr√ºfen Sie in diesem Fall die <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ).  Wenn Sie es verwenden, <code>MeasureSimilarity</code> der Code der <code>MeasureSimilarity</code> Methode folgenderma√üen aus: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  und Ausf√ºhrungszeit: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  59,33 ms </td><td>  1,148 ms </td><td>  0,9585 ms </td><td>  1,53 KB </td></tr><tr><td>  Aszendententest </td><td>  74,87 ms </td><td>  1,479 ms </td><td>  1,9748 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  119,46 ms </td><td>  2,321 ms </td><td>  2,8509 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Beeindruckend. <br>  Ich kenne die M√∂glichkeiten nicht, die <code>MeasureSimilarity</code> erheblich beschleunigen und gleichzeitig die Lesbarkeit nicht wesentlich <code>MeasureSimilarity</code> k√∂nnen.  Ich denke, Sie k√∂nnen diese Methode beenden. </p><br><h1 id="struktury-dannyh">  Datenstrukturen </h1><br><p>  Jetzt werden wir uns mit dem Hauptteil der Schleife in der <code>GetFiftyMostSimilarGroups</code> Methode <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Lassen Sie mich kurz daran erinnern, was hier passiert: </p><br><ul><li>  Innerhalb der Liste wird eine sortierte Liste der f√ºnfzig am besten geeigneten Tag-Gruppen gespeichert, und zwar von kleiner zu gr√∂√üer, wenn Sie <code>TagsSimilarityInfo</code> vergleichen. </li><li>  F√ºgen Sie die betreffende neue Gruppe unter Beibehaltung der Sortierung in die Liste ein. </li><li>  Wenn die Liste mehr als f√ºnfzig Elemente enth√§lt, l√∂schen Sie die am wenigsten √§hnliche Gruppe (ihr Info-Objekt ist das gr√∂√üte und befindet sich ganz am Ende der <code>list</code> ). </li></ul><br><p>  Das hei√üt,  Es stellt sich heraus, dass wir sehr schnell das gr√∂√üte Element in der Sammlung finden m√ºssen, um es schnell einf√ºgen und l√∂schen zu k√∂nnen.  Um solche Probleme zu l√∂sen, gibt es spezielle Datenstrukturen.  Das erste, was mir in den Sinn kommt, ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haufen</a> .  Ihre Einf√ºgung erfolgt in O (log N), wobei das Maximum in O (1) ermittelt und ein Element in O (log N) entfernt wird.  Das einzige Problem ist, dass der Heap nicht von den zunehmenden Elementen iteriert werden kann, ohne ihn zu √§ndern.  Da es in BCL keinen bin√§ren Heap gibt, habe ich ihn selbst geschrieben: </p><br><div class="spoiler">  <b class="spoiler_title">Bin√§rhaufen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  Die entsprechende Implementierung der <code>GetFiftyMostSimilarGroups</code> Methode finden Sie im Quellcode des Artikels (Link unten). <br>  Zus√§tzlich zum Heap wird m√∂glicherweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bin√§rer Suchbaum</a> angezeigt.  Ein ausgeglichener bin√§rer Suchbaum kann das Einf√ºgen von O (log N) erm√∂glichen, ein Maximum f√ºr O (log N) erhalten und ein Element f√ºr O (log N) entfernen.  Der Vorteil einer solchen Struktur besteht darin, dass sie in aufsteigender Reihenfolge iteriert werden kann und au√üerdem der rot-schwarze Suchbaum in BCL in SortedSet implementiert ist (in einem gro√üen Framework ist das Erhalten eines Maximums viel langsamer als in .netcore 3.0 und weist Speicher zu).  Die Implementierung von <code>GetFiftyMostSimilarGroups</code> f√ºr SortedSet finden Sie im Quellcode des Artikels. <br>  Benchmark-Ergebnisse f√ºr alle drei <code>GetFiftyMostSimilarGroups</code> Implementierungen: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Sortieralgorithmus </th><th>  Mittelwert </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Zuf√§lliger Test </td><td>  Liste </td><td>  60,06 ms </td><td>  1704 B. </td></tr><tr><td>  Zuf√§lliger Test </td><td>  Sortiertes Set </td><td>  65,46 ms </td><td>  24384 B. </td></tr><tr><td>  Zuf√§lliger Test </td><td>  Haufen </td><td>  60,55 ms </td><td>  2912 B. </td></tr><tr><td>  Aszendententest </td><td>  Liste </td><td>  75,42 ms </td><td>  1704 B. </td></tr><tr><td>  Aszendententest </td><td>  Sortiertes Set </td><td>  161,12 ms </td><td>  9833424 B. </td></tr><tr><td>  Aszendententest </td><td>  Haufen </td><td>  86,87 ms </td><td>  2912 B. </td></tr><tr><td>  DescendantTest </td><td>  Liste </td><td>  119,23 ms </td><td>  880 B. </td></tr><tr><td>  DescendantTest </td><td>  Sortiertes Set </td><td>  125,03 ms </td><td>  3024 B. </td></tr><tr><td>  DescendantTest </td><td>  Haufen </td><td>  118,62 ms </td><td>  2088 B. </td></tr></tbody></table></div><br><p>  Die urspr√ºngliche Implementierung mit einem Blatt gewinnt fast √ºberall in der Zeit und sicherlich √ºberall im Ged√§chtnis.  Dies geschieht aufgrund der Tatsache, dass f√ºr einen Algorithmus mit einem Blatt die Einf√ºgung in O (log N) f√ºr die Suche und fast O (1) f√ºr die Einf√ºgung durchgef√ºhrt wird, weil  Das Kopieren einer so kleinen Anzahl von Elementen erfolgt sehr schnell, wobei ein Maximum f√ºr O (1) erhalten wird und ein Element auch f√ºr O (1) gel√∂scht wird, weil  In .net wird das L√∂schen des letzten Elements aus dem Blatt ersetzt, indem in das letzte Element ein leerer Wert geschrieben wird (im .net-Kern wird nichts in Strukturen geschrieben).  Wenn es erforderlich w√§re, nicht 50 auszugeben, aber sagen wir 1000 der √§hnlichsten Gruppen, dann w√ºrde ein Algorithmus mit einem Blatt h√∂chstwahrscheinlich nicht funktionieren.  In der Tat ist dies alles eine kleine spekulative Argumentation, weil  Sie k√∂nnen weiterhin jeden der Algorithmen anpassen. </p><br><h1 id="mnogopotochnost">  Multithreading </h1><br><p>  Jetzt muss noch versucht werden, die Schleife selbst in <code>GetFiftyMostSimilarGroups</code> zu verbessern.  Nur Multithreading f√§llt mir ein.  Die Idee ist, die gesamte Liste der Gruppen in mehrere Pakete aufzuteilen.  Suchen Sie in jedem Paket die 50 √§hnlichsten Tag-Gruppen und unter ihnen die letzten 50 √§hnlichsten. <br>  Die Multithread-Version von <code>GetFiftyMostSimilarGroups</code> sieht <code>GetFiftyMostSimilarGroups</code> aus: </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> ‚Äî   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> ‚Äî -      ; </li><li> <code>current</code> ‚Äî -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454850/">https://habr.com/ru/post/de454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454830/index.html">3 Schl√ºsselqualit√§ten f√ºr einen erfolgreichen Produktmanager: Alexander Belyaev</a></li>
<li><a href="../de454832/index.html">Warum eine viert√§gige Arbeitswoche eine schlechte Geschichte ist</a></li>
<li><a href="../de454834/index.html">Die wirklichen Begriffe des Studiums des Touch-Tippens mit geringer Motivation</a></li>
<li><a href="../de454840/index.html">Sorgf√§ltiger Umzug in die Niederlande mit seiner Frau und Hypothek. Teil 2: Dokumente vorbereiten und umziehen</a></li>
<li><a href="../de454844/index.html">Odigest: interessant f√ºr Designer der Woche</a></li>
<li><a href="../de454856/index.html">Wir analysieren Schwachstellen bei der Validierung von SSL / TLS-Zertifikaten in Nicht-Browser-Software</a></li>
<li><a href="../de454860/index.html">Lassen Sie uns QueryProvider beim Umgang mit interpolierten Zeichenfolgen unterst√ºtzen</a></li>
<li><a href="../de454864/index.html">Wie sind die Entwicklungsprozesse in verschiedenen Unternehmen</a></li>
<li><a href="../de454868/index.html">Kompilieren von C in WebAssembly ohne Emscripten</a></li>
<li><a href="../de454872/index.html">Space Invaders: jetzt in 512 Bytes (Assembler x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>