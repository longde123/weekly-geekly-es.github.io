<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¢ üêó üê´ C√≥mo dispararte en el pie en C y C ++. Haiku OS Cookbook üÜò üë®üèΩ‚Äçü§ù‚Äçüë®üèª üßúüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia de c√≥mo se reunieron el analizador est√°tico PVS-Studio y el c√≥digo Haiku OS se remonta al a√±o 2015. Fue un experimento emocionante y una e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo dispararte en el pie en C y C ++. Haiku OS Cookbook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461253/">  La historia de c√≥mo se reunieron el analizador est√°tico PVS-Studio y el c√≥digo Haiku OS se remonta al a√±o 2015. Fue un experimento emocionante y una experiencia √∫til para los equipos de ambos proyectos.  ¬øPor qu√© el experimento?  En ese momento, no ten√≠amos el analizador para Linux y no lo tendr√≠amos por otro a√±o y medio.  De todos modos, los esfuerzos de los entusiastas de nuestro equipo han sido recompensados: nos reunimos con los desarrolladores de Haiku y aumentamos la calidad del c√≥digo, ampliamos nuestra base de errores con errores raros hechos por los desarrolladores y refinamos el analizador.  Ahora puede verificar el c√≥digo Haiku en busca de errores de manera f√°cil y r√°pida. <br><div style="text-align:center;"><img src="https://import.viva64.com/docx/blog/0644_Haiku_3/image1.png" alt="Imagen 1"></div><br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Conoce a los personajes principales de nuestra historia: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haiku</a> con c√≥digo fuente abierto y el analizador est√°tico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> para C, C ++, C # y Java.  Cuando analizamos el an√°lisis del proyecto hace 4.5 a√±os, solo ten√≠amos que lidiar con el archivo analizador ejecutable compilado.  Toda la infraestructura para analizar los par√°metros del compilador, ejecutar un preprocesador, hacer el an√°lisis en paralelo, etc., se tom√≥ de la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UI de compilaci√≥n del compilador</a> , escrita en C #.  Esa utilidad fue portada en partes a la plataforma Mono para ejecutarse en Linux.  El proyecto Haiku se construye utilizando el compilador cruzado en varios sistemas operativos, excepto Windows.  Una vez m√°s, me gustar√≠a mencionar la conveniencia y la integridad de la documentaci√≥n relacionada con la construcci√≥n de Haiku.  Tambi√©n me gustar√≠a agradecer a los desarrolladores de Haiku por su ayuda en la construcci√≥n del proyecto. <br><br>  Es mucho m√°s sencillo realizar el an√°lisis ahora.  Aqu√≠ est√° la lista de todos los comandos para construir y analizar el proyecto: <br><br><pre><code class="cpp hljs">cd /opt git clone https:<span class="hljs-comment"><span class="hljs-comment">//review.haiku-os.org/buildtools git clone https://review.haiku-os.org/haiku cd ./haiku mkdir generated.x86_64; cd generated.x86_64 ../configure --distro-compatibility official -j12 \ --build-cross-tools x86_64 ../../buildtools cd ../../buildtools/jam make all cd /opt/haiku/generated.x86_64 pvs-studio-analyzer trace -- /opt/buildtools/jam/bin.linuxx86/jam \ -q -j1 @nightly-anyboot pvs-studio-analyzer analyze -l /mnt/svn/PVS-Studio.lic -r /opt/haiku \ -C x86_64-unknown-haiku-gcc -o /opt/haiku/haiku.log -j12</span></span></code> </pre> <br>  Por cierto, el an√°lisis del proyecto se implement√≥ en un contenedor Docker.  Recientemente hemos preparado nueva documentaci√≥n sobre este tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecutar PVS-Studio en Docker</a> .  Esto puede facilitar que algunas empresas apliquen t√©cnicas de an√°lisis est√°tico para sus proyectos. <br><br><h2>  Variables no inicializadas </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V614</a> Variable no inicializada 'rval' utilizada.  fetch.c 1727 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auto_fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argpos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval; <span class="hljs-comment"><span class="hljs-comment">// &lt;= argpos = 0; if (sigsetjmp(toplevel, 1)) { if (connected) disconnect(0, NULL); if (rval &gt; 0) // &lt;= rval = argpos + 1; return (rval); } .... }</span></span></code> </pre> <br>  La variable <i>rval</i> no se ha inicializado en la declaraci√≥n, por lo que su comparaci√≥n con el valor nulo conducir√° a un resultado indefinido.  Si las circunstancias fallan, el valor incierto de la variable <i>rval puede</i> convertirse en un valor de retorno de la funci√≥n <i>auto_fetch</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V614</a> Puntero no inicializado 'res' utilizado.  comandos.c 2873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_family; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_socktype; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_protocol; <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> ai_addrlen; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ai_canonname; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sourceroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct addrinfo *ai, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **cpp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *protop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *optp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span> + ALIGNBYTES]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, *cp2, *lsrp, *ep; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> *_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sin</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> INET6 struct sockaddr_in6 *sin6; struct ip6_rthdr *rth; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> struct addrinfo hints, *res; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= int error; char c; if (cpp == NULL || lenp == NULL) return -1; if (*cpp != NULL) { switch (res-&gt;ai_family) { // &lt;= case AF_INET: if (*lenp &lt; 7) return -1; break; .... } } .... }</span></span></span></span></code> </pre> <br>  Aqu√≠ hay un caso similar de uso de la variable no inicializada, excepto que <i>res</i> es un puntero no inicializado que tiene lugar aqu√≠. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> puntero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V506</a> a la variable local 'normalizado' se almacena fuera del alcance de esta variable.  Tal puntero se volver√° inv√°lido.  TextView.cpp 5596 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BTextView::_ApplyStyleRange(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BFont* font, ....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (font != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { BFont normalized = *font; _NormalizeFont(&amp;normalized); font = &amp;normalized; } .... fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode, font, color); }</code> </pre> <br>  El programador probablemente necesitaba normalizar el objeto usando una variable intermedia.  Pero ahora el puntero de <i>fuente</i> contiene el puntero al objeto <i>normalizado</i> , que se eliminar√° despu√©s de salir del √°mbito, donde se cre√≥ el objeto temporal. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V603</a> El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 27 <br><br><pre> <code class="cpp hljs">int8 BUnicodeChar::Type(uint32 c) { BUnicodeChar(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_charType(c); }</code> </pre> <br>  Un error muy com√∫n entre los programadores de C ++ es usar la llamada del constructor supuestamente para inicializar / anular campos de clase.  En este caso, la modificaci√≥n de los campos de clase no ocurre, pero se crea un nuevo objeto sin nombre de esta clase y luego se destruye inmediatamente.  Desafortunadamente, hay muchos lugares de este tipo en el proyecto: <br><br><ul><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 37 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 49 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 58 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 67 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 77 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 89 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 103 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 115 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 126 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 142 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 152 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 163 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 186 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 196 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 206 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 214 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 222 </li><li>  V603 El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; BUnicodeChar :: BUnicodeChar (....)'.  UnicodeChar.cpp 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V670</a> El miembro de clase no inicializado 'fPatternHandler' se usa para inicializar el miembro 'fInternal'.  Recuerde que los miembros se inicializan en el orden de sus declaraciones dentro de una clase.  Painter.cpp 184 <br><br><pre> <code class="cpp hljs">Painter::Painter() : fInternal(fPatternHandler), .... fPatternHandler(), .... { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Painter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> PainterAggInterface fInternal; <span class="hljs-comment"><span class="hljs-comment">// line 336 bool fSubpixelPrecise : 1; bool fValidClipping : 1; bool fDrawingText : 1; bool fAttached : 1; bool fIdentityTransform : 1; Transformable fTransform; float fPenSize; const BRegion* fClippingRegion; drawing_mode fDrawingMode; source_alpha fAlphaSrcMode; alpha_function fAlphaFncMode; cap_mode fLineCapMode; join_mode fLineJoinMode; float fMiterLimit; PatternHandler fPatternHandler; // line 355 mutable AGGTextRenderer fTextRenderer; };</span></span></code> </pre> <br>  Otro ejemplo de inicializaci√≥n incorrecta.  Los campos de clase se inicializan en el orden de su declaraci√≥n en la clase misma.  En este ejemplo, el campo <i>fInternal</i> ser√° el primero en inicializarse utilizando el valor no inicializado <i>fPatternHandler</i> . <br><br><h2>  #Define sospechoso </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V523</a> La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  subr_gtaskqueue.c 191 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_LOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_lock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_lock(&amp;(tq)-&gt;tq_mutex); \ } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_ASSERT_LOCKED(tq) mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_UNLOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_unlock(&amp;(tq)-&gt;tq_mutex); \ } while (0) void grouptask_block(struct grouptask *grouptask) { .... TQ_LOCK(queue); gtask-&gt;ta_flags |= TASK_NOENQUEUE; gtaskqueue_drain_locked(queue, gtask); TQ_UNLOCK(queue); }</span></span></code> </pre> <br>  Este fragmento de c√≥digo no parece sospechoso hasta que observe el resultado del preprocesador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grouptask_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct grouptask *grouptask)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); gtask-&gt;ta_flags |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; gtaskqueue_drain_locked(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, gtask); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  El analizador tiene toda la raz√≥n, <i>si las</i> ramas son id√©nticas.  Pero, ¬ød√≥nde est√°n las funciones <i>mtx_lock_spin</i> y <i>mtx_unlock_spin</i> ?  Las macros <i>TQ_LOCK</i> , <i>TQ_UNLOCK</i> y la funci√≥n <i>grouptask_block</i> se declaran en un archivo casi una al lado de la otra, pero, sin embargo, se realiz√≥ un reemplazo en alg√∫n lugar aqu√≠. <br><br>  La b√∫squeda en los archivos solo result√≥ en <i>mutex.h</i> con el siguiente contenido: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* on FreeBSD these are different functions */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_lock_spin(x) mtx_lock(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_unlock_spin(x) mtx_unlock(x)</span></span></code> </pre> <br>  Los desarrolladores de proyectos deben verificar si dicho reemplazo es correcto o no.  Revis√© este proyecto en Linux y esa sustituci√≥n me pareci√≥ sospechosa. <br><br><h2>  Errores con la funci√≥n libre </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V575</a> El puntero nulo se pasa a la funci√≥n 'libre'.  Inspecciona el primer argumento.  setmime.cpp 727 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MimeType::_PurgeProperties() { fShort.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fLong.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefApp.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefAppSig.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fSniffRule.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fSmallIcon; fSmallIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fBigIcon; fBigIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fVectorIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(fVectorIcon); // &lt;= fExtensions.clear(); fAttributes.clear(); }</span></span></code> </pre> <br>  Puede pasar el puntero nulo en la funci√≥n <i>libre</i> , pero dicho uso es definitivamente sospechoso.  Por lo tanto, el analizador encontr√≥ l√≠neas de c√≥digo mezcladas.  Primero, el autor del c√≥digo tuvo que liberar la memoria mediante el puntero <i>fVectorIcon</i> , solo despu√©s de asignar <i>NULL</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V575</a> El puntero nulo se pasa a la funci√≥n 'libre'.  Inspecciona el primer argumento.  driver_settings.cpp 461 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> settings_handle * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_driver_settings_from_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *driverName)</span></span></span><span class="hljs-function"> </span></span>{ .... handle = new_settings(text, driverName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// everything went fine! return handle; } free(handle); // &lt;= .... }</span></span></code> </pre> <br>  Este es otro ejemplo de pasar expl√≠citamente un puntero nulo a la funci√≥n <i>libre</i> .  Esta l√≠nea se puede eliminar, ya que la funci√≥n sale despu√©s de obtener el puntero con √©xito. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V575</a> El puntero nulo se pasa a la funci√≥n 'libre'.  Inspecciona el primer argumento.  PackageFileHeapWriter.cpp 166 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _GetBuffer() { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(fBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; !fBuffers.AddItem(buffer)) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  Alguien cometi√≥ un error aqu√≠.  Se debe utilizar el operador || en lugar de &amp;&amp;.  Solo en este caso se <i>lanzar√° la</i> excepci√≥n <i>std :: bad_alloc ()</i> en caso de que <i>falle la</i> asignaci√≥n de memoria (usando la funci√≥n <i>malloc</i> ). <br><br><h2>  Errores con el operador de eliminaci√≥n </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V611</a> La memoria se asign√≥ usando el operador 'nuevo T []' pero se liber√≥ usando el operador 'borrar'.  Considere inspeccionar este c√≥digo.  Probablemente sea mejor usar 'delete [] fMsg;'.  Err.cpp 65 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Err</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fMsg; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> fPos; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Err::Unset() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fMsg; <span class="hljs-comment"><span class="hljs-comment">// &lt;= fMsg = __null; fPos = -1; } void Err::SetMsg(const char *msg) { if (fMsg) { delete fMsg; // &lt;= fMsg = __null; } if (msg) { fMsg = new(std::nothrow) char[strlen(msg)+1]; // &lt;= if (fMsg) strcpy(fMsg, msg); } }</span></span></code> </pre> <br>  El puntero <i>fMsg</i> se usa para asignar memoria para una matriz de caracteres.  El operador de <i>eliminaci√≥n</i> se utiliza para liberar la memoria en lugar de <i>eliminar []</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V611</a> La memoria fue asignada usando el operador 'nuevo' pero fue liberada usando la funci√≥n 'libre'.  Considere inspeccionar las l√≥gicas de operaci√≥n detr√°s de la variable 'wrapperPool'.  vm_page.cpp 3080 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> vm_page_write_modified_page_range(....) { .... PageWriteWrapper* wrapperPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper[maxPages + <span class="hljs-number"><span class="hljs-number">1</span></span>]; PageWriteWrapper** wrappers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper*[maxPages]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapperPool == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || wrappers == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(wrapperPool); <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(wrappers); // &lt;= wrapperPool = stackWrappersPool; wrappers = stackWrappers; maxPages = 1; } .... }</span></span></code> </pre> <br>  Aqu√≠ <i>malloc_flags</i> es una funci√≥n que llama a <i>malloc</i> .  Luego, <i>ubicaci√≥n-nueva</i> construye el objeto aqu√≠.  Como la clase <i>PageWriteWrapper</i> se implementa de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageWriteWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PageWriteWrapper(); ~PageWriteWrapper(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm_page* page)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: vm_page* fPage; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VMCache</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsActive; }; PageWriteWrapper::PageWriteWrapper() : fIsActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } PageWriteWrapper::~PageWriteWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsActive) panic(<span class="hljs-string"><span class="hljs-string">"page write wrapper going out of scope but isn't completed"</span></span>); }</code> </pre> <br>  los destructores de objetos de esta clase no ser√°n llamados debido al uso de la funci√≥n <i>libre</i> para liberar memoria. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V611</a> La memoria se asign√≥ usando el operador 'nuevo T []' pero se liber√≥ usando el operador 'borrar'.  Considere inspeccionar este c√≥digo.  Probablemente sea mejor usar 'delete [] fOutBuffer;'.  Verifique las l√≠neas: 26, 45. PCL6Rasterizer.h 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PCL6Rasterizer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... ~PCL6Rasterizer() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fOutBuffer; fOutBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fOutBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uchar[fOutBufferSize]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: uchar* fOutBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fOutBufferSize; };</code> </pre> <br>  Es un error com√∫n usar el operador de <i>eliminaci√≥n en</i> lugar de <i>eliminar [].</i>  Es m√°s f√°cil cometer un error al escribir una clase, ya que el c√≥digo del destructor a menudo est√° lejos de las ubicaciones de memoria.  Aqu√≠, el programador libera incorrectamente la memoria almacenada por el puntero <i>fOutBuffer</i> en el destructor. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V772</a> Llamar a un operador 'eliminar' para un puntero nulo causar√° un comportamiento indefinido.  Hashtable.cpp 207 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hashtable::MakeEmpty(int8 keyMode,int8 valueMode) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (entry = fTable[index]; entry; entry = next) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (keyMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HASH_EMPTY_DELETE: <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete (void*)entry-&gt;key; break; case HASH_EMPTY_FREE: free((void*)entry-&gt;key); break; } switch (valueMode) { case HASH_EMPTY_DELETE: // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete entry-&gt;value; break; case HASH_EMPTY_FREE: free(entry-&gt;value); break; } next = entry-&gt;next; delete entry; } .... }</span></span></code> </pre> <br>  Adem√°s de una elecci√≥n incorrecta entre <i>eliminar</i> / <i>eliminar []</i> y <i>liberar</i> , tambi√©n puede encontrarse con un comportamiento indefinido al intentar borrar la memoria con un puntero al tipo de <i>vac√≠o (void *)</i> . <br><br><h2>  Funciones sin valor de retorno </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V591 La funci√≥n</a> no nula deber√≠a devolver un valor.  Referenciable.h 228 <br><br><pre> <code class="cpp hljs">BReference&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BReference&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type&gt;&amp; other) { fReference = other.fReference; }</code> </pre> <br>  Un operador de asignaci√≥n sobrecargado carece de un valor de retorno.  En este caso, el operador devolver√° un valor aleatorio, que puede conducir a errores extra√±os. <br><br>  Aqu√≠ hay problemas similares en otros fragmentos de c√≥digo de esta clase: <br><br><ul><li>  V591 La funci√≥n no nula deber√≠a devolver un valor.  Referenciable.h 233 </li><li>  V591 La funci√≥n no nula deber√≠a devolver un valor.  Referenciable.h 239 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V591 La funci√≥n</a> no nula deber√≠a devolver un valor.  main.c 1010 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, ...)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptionvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with NULL name"</span></span>); c = getoption(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;value); errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with unknown option '%s'"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre> <br>  El comentario de un usuario NOTREACHED no significa nada aqu√≠.  Debe anotar funciones como noreturn para escribir correctamente el c√≥digo para tales escenarios.  Para hacer esto, hay atributos de retorno: est√°ndar y espec√≠ficos del compilador.  En primer lugar, los compiladores tienen en cuenta estos atributos para generar un c√≥digo adecuado o notificar ciertos tipos de errores mediante advertencias.  Varias herramientas de an√°lisis est√°tico tambi√©n tienen en cuenta los atributos para mejorar la calidad del an√°lisis. <br><br><h2>  Manejo de excepciones </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V596</a> El objeto fue creado pero no se est√° utilizando.  Podr√≠a faltar la palabra clave 'throw': throw ParseException (FOO);  Response.cpp 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Response::ExtractNumber(BDataIO&amp; stream) { BString <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = ExtractString(stream); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* end; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> number = strtoul(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.String(), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**)&amp;end, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || end[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) ParseException(<span class="hljs-string"><span class="hljs-string">"Invalid number!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number; }</code> </pre> <br>  El <i>lanzamiento de la</i> palabra clave fue olvidado accidentalmente aqu√≠.  Por lo tanto, la excepci√≥n <i>ParseException</i> no se generar√° mientras que el objeto de esta clase simplemente se destruir√° al salir del √°mbito.  Despu√©s de eso, la funci√≥n continuar√° funcionando como si nada hubiera sucedido, como si se hubiera ingresado el n√∫mero correcto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V1022</a> El puntero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arroj√≥</a> una excepci√≥n.  Considere lanzarlo por valor en su lugar.  gensyscallinfos.cpp 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Main().Run(argc, argv); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception&amp; exception) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= fprintf(stderr, "%s\n", exception.what()); return 1; } } int Run(int argc, char** argv) { .... _ParseSyscalls(argv[1]); .... } void _ParseSyscalls(const char* filename) { ifstream file(filename, ifstream::in); if (!file.is_open()) throw new IOException(string("Failed to open '") + filename + "'."); // &lt;= .... }</span></span></code> </pre> <br>  El analizador detect√≥ la excepci√≥n <i>IOException</i> lanzada por el puntero.  Lanzar un puntero lleva al hecho de que la excepci√≥n no ser√° atrapada.  Entonces, la excepci√≥n finalmente se toma por referencia.  Adem√°s, el uso de un puntero obliga al lado de captura a llamar al operador de <i>eliminaci√≥n</i> para destruir el objeto creado, lo que no se hab√≠a hecho. <br><br>  Un par de otros fragmentos de c√≥digo con problemas: <br><br><ul><li>  V1022 El puntero arroj√≥ una excepci√≥n.  Considere lanzarlo por valor en su lugar.  gensyscallinfos.cpp 347 </li><li>  V1022 El puntero arroj√≥ una excepci√≥n.  Considere lanzarlo por valor en su lugar.  gensyscallinfos.cpp 413 </li></ul><br><h2>  Seguridad formal </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V597</a> El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'f_key'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  dst_api.c 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAFE_FREE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_FREE(a) \ do{</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(a != NULL){memset(a,0, sizeof(*a)); free(a); a=NULL;}} while (0) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DST_KEY * dst_free_key(DST_KEY *f_key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key == NULL) return (f_key); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy) f_key-&gt;dk_KEY_struct = f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { EREPORT((</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dst_free_key(): Unknown key alg %d\n"</span></span></span><span class="hljs-meta">, f_key-&gt;dk_alg)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_KEY_struct) { free(f_key-&gt;dk_KEY_struct); f_key-&gt;dk_KEY_struct = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_key_name) SAFE_FREE(f_key-&gt;dk_key_name); SAFE_FREE(f_key); return (NULL); }</span></span></code> </pre> <br>  El analizador ha detectado c√≥digo sospechoso, destinado a la eliminaci√≥n segura de datos privados.  Desafortunadamente, la macro <i>SAFE_FREE</i> que se expande en el <i>memset</i> , <i>las</i> llamadas <i>gratuitas</i> y la asignaci√≥n <i>NULL</i> no hacen que el c√≥digo sea m√°s seguro, ya que el compilador lo elimina todo al optimizar con <i>O2</i> . <br><br>  Por cierto, no es m√°s que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE-14</a> : eliminaci√≥n del compilador de c√≥digo para borrar buffers. <br><br>  Aqu√≠ est√° la lista de lugares, donde la limpieza de los buffers no se realiza de hecho: <br><br><ul><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'encoded_block'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  dst_api.c 446 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'key_st'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  dst_api.c 685 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'in_buff'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  dst_api.c 916 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el objeto 'ce'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  fs_cache.c 1078 </li></ul><br><h2>  Comparaciones con variables sin signo. </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V547 La</a> expresi√≥n 'restante &lt;0' siempre es falsa.  El valor de tipo sin signo nunca es &lt;0. DwarfFile.cpp 1947 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> DwarfFile::_UnwindCallFrame(....) { .... uint64 remaining = lengthOffset + length - dataReader.Offset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_BAD_DATA; .... }</code> </pre> <br>  El analizador encontr√≥ una comparaci√≥n expl√≠cita de la variable sin signo con valores negativos.  Quiz√°s, uno deber√≠a comparar la variable <i>restante</i> solo con nulo o implementar una verificaci√≥n de desbordamiento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V547 La</a> expresi√≥n 'suspensi√≥n ((sin signo) segundos) &lt;0' siempre es falsa.  El valor de tipo sin signo nunca es &lt;0. Misc.cpp 56 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> snooze(<span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> amount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; int64 secs = amount / <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; int64 usecs = amount % <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sleep((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)secs) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return errno; } if (usecs &gt; 0) { if (usleep((useconds_t)usecs) &lt; 0) return errno; } return B_OK; }</span></span></code> </pre> <br>  Para obtener el punto principal del error, <i>abordemos las</i> firmas de las funciones <i>sleep</i> y <i>usleep</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __seconds)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__useconds_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __useconds)</span></span></span></span>;</code> </pre> <br>  Como podemos ver, la funci√≥n de <i>suspensi√≥n</i> devuelve el valor sin signo y su uso en el c√≥digo es incorrecto. <br><br><h2>  Punteros peligrosos </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V774</a> El puntero 'dispositivo' se us√≥ despu√©s de liberar la memoria.  xhci.cpp 1572 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> XHCI::FreeDevice(Device *device) { uint8 slot = fPortSlots[device-&gt;HubPort()]; TRACE(<span class="hljs-string"><span class="hljs-string">"FreeDevice() port %d slot %d\n"</span></span>, device-&gt;HubPort(), slot); <span class="hljs-comment"><span class="hljs-comment">// Delete the device first, so it cleans up its pipes and tells us // what we need to destroy before we tear down our internal state. delete device; DisableSlot(slot); fDcba-&gt;baseAddress[slot] = 0; fPortSlots[device-&gt;HubPort()] = 0; // &lt;= delete_area(fDevices[slot].trb_area); delete_area(fDevices[slot].input_ctx_area); delete_area(fDevices[slot].device_ctx_area); memset(&amp;fDevices[slot], 0, sizeof(xhci_device)); fDevices[slot].state = XHCI_STATE_DISABLED; }</span></span></code> </pre> <br>  Un objeto de <i>dispositivo es</i> liberado por el operador de <i>eliminaci√≥n</i> .  Es bastante l√≥gico para la funci√≥n <i>FreeDevice</i> .  Pero, por alguna raz√≥n, para liberar otros recursos, se aborda el objeto ya eliminado. <br><br>  Dicho c√≥digo es extremadamente peligroso y se puede cumplir en otros lugares: <br><br><ul><li>  V774 El puntero 'self' se us√≥ despu√©s de liberar la memoria.  TranslatorRoster.cpp 884 </li><li>  V774 El puntero 'string' se us√≥ despu√©s de liberar la memoria.  RemoteView.cpp 1269 </li><li>  V774 El puntero 'bs' se us√≥ despu√©s de liberar la memoria.  mkntfs.c 4291 </li><li>  V774 El puntero 'bs' se us√≥ despu√©s de liberar la memoria.  mkntfs.c 4308 </li><li>  V774 El puntero 'al' se us√≥ despu√©s de reasignar la memoria.  inode.c 1155 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V522</a> Puede tener lugar la desreferenciaci√≥n del puntero nulo 'datos'.  El puntero nulo se pasa a la funci√≥n 'malo_hal_send_helper'.  Inspeccione el tercer argumento.  Verifique las l√≠neas: 350, 394. if_malohal.c 350 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malo_hal_fwload_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct malo_hal *mh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *helper)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* tell the card we're done and... */</span></span> error = malo_hal_send_helper(mh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MALO_NOWAIT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= NULL .... } static int malo_hal_send_helper(struct malo_hal *mh, int bsize, const void *data, size_t dsize, int waitfor) { mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD); mh-&gt;mh_cmdbuf[1] = htole16(bsize); memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize); // &lt;= data .... }</span></span></code> </pre> <br>  El an√°lisis interprocedural revel√≥ el caso cuando <i>NULL</i> se pasa a la funci√≥n y el puntero de <i>datos</i> con dicho valor finalmente se desreferencia en la funci√≥n <i>memcpy</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V773</a> Se sali√≥ de la funci√≥n sin soltar el puntero 'inputFileFile'.  Una p√©rdida de memoria es posible.  command_recompress.cpp 119 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command_recompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span><span class="hljs-function"> </span></span>{ .... BFile* inputFileFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BFile; error = inputFileFile-&gt;SetTo(inputPackageFileName, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: Failed to open input file \"%s\": %s\n"</span></span>, inputPackageFileName, strerror(error)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } inputFile = inputFileFile; .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio puede detectar p√©rdidas de memoria</a> .  En este ejemplo, en caso de error, la memoria no se liberar√°.  Alguien podr√≠a pensar que, en caso de errores, no deber√≠a preocuparse por la liberaci√≥n de la memoria, ya que el programa a√∫n finalizar√°.  Pero no siempre es as√≠.  Es un requisito para muchos programas manejar los errores correctamente y continuar trabajando. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V595</a> El puntero 'fReply' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 49, 52. ReplyBuilder.cpp 49 <br><br><pre> <code class="cpp hljs">RPC::CallbackReply* ReplyBuilder::Reply() { fReply-&gt;Stream().InsertUInt(fStatusPosition, _HaikuErrorToNFS4(fStatus)); fReply-&gt;Stream().InsertUInt(fOpCountPosition, fOpCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fReply == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || fReply-&gt;Stream().Error() == B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fReply; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Es un error muy com√∫n desreferenciar los punteros antes de verificarlos.  El diagn√≥stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V595</a> casi siempre prevalece en el n√∫mero de advertencias en un proyecto.  Este fragmento de c√≥digo incluye el uso peligroso del puntero <i>fReply</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V595</a> El puntero 'mq' se utiliz√≥ antes de verificarlo con nullptr.  L√≠neas de verificaci√≥n: 782, 786. oce_queue.c 782 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oce_mq_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct oce_mq *mq)</span></span></span><span class="hljs-function"> </span></span>{ POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oce_mbx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx_destroy_common_mq</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fwcmd</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Un ejemplo similar  El puntero <i>mg</i> se desreferencia varias l√≠neas antes de que se compruebe si es nulo.  Hay muchos lugares similares en el proyecto.  En algunos fragmentos, el uso y la comprobaci√≥n del puntero est√°n bastante alejados entre s√≠, por lo que en este art√≠culo encontrar√° solo algunos ejemplos.  Los desarrolladores pueden consultar otros ejemplos en el informe completo del analizador. <br><br><h2>  Miscel√°neo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V645</a> La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_acpi_namespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acpi_ns_device_info *device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indenting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> output[<span class="hljs-number"><span class="hljs-number">320</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tabs[<span class="hljs-number"><span class="hljs-number">255</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... strlcat(tabs, <span class="hljs-string"><span class="hljs-string">"|--- "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tabs)); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { uint32 type = device-&gt;acpi-&gt;get_object_type(result); <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(output, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output), <span class="hljs-string"><span class="hljs-string">"%s%s"</span></span>, tabs, result + depth); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_INTEGER: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" INTEGER"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_STRING: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" STRING"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... } .... }</code> </pre> <br>  La diferencia entre las funciones <i>strlcat</i> y <i>strncat</i> no es muy obvia para alguien que no est√° familiarizado con la descripci√≥n de estas funciones.  La funci√≥n <i>strlcat</i> espera el tama√±o de todo el b√∫fer como tercer argumento, mientras que la funci√≥n <i>strncat</i> , el tama√±o del espacio libre en un b√∫fer, que requiere evaluar un valor necesario antes de llamar a la funci√≥n.  Pero los desarrolladores a menudo lo olvidan o no lo saben.  Pasar todo el tama√±o del b√∫fer a la funci√≥n <i>strncat</i> puede provocar un desbordamiento del b√∫fer, ya que la funci√≥n considerar√° este valor como un n√∫mero aceptable de caracteres para copiar.  La funci√≥n <i>strlcat</i> no tiene ese problema.  Pero debe pasar cadenas, que terminan en terminal nulo para que funcione correctamente. <br><br>  Aqu√≠ est√° la lista completa de lugares peligrosos con cadenas: <br><br><ul><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 104 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 107 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 110 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 113 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 118 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 119 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 120 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 123 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 126 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 129 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 132 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 135 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 138 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 141 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'salida'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  NamespaceDump.cpp 144 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'features_string'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  VirtioDevice.cpp 283 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'features_string'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  VirtioDevice.cpp 284 </li><li>  V645 La llamada a la funci√≥n 'strncat' podr√≠a conducir al desbordamiento del b√∫fer 'features_string'.  Los l√≠mites no deben contener el tama√±o del b√∫fer, sino una cantidad de caracteres que puede contener.  VirtioDevice.cpp 285 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V792</a> La funci√≥n 'SetDecoratorSettings' ubicada a la derecha del operador '|'  se llamar√° independientemente del valor del operando izquierdo.  Quiz√°s, es mejor usar '||'.  DesktopListener.cpp 324 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DesktopListener</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DoublyLinkedListLinkImpl&lt;DesktopListener&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDecoratorSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Window* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BMessage&amp; settings)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DesktopObservable::SetDecoratorSettings(Window* window, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage&amp; settings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fWeAreInvoking) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">InvokeGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeGuard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fWeAreInvoking)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (DesktopListener* listener = fDesktopListenerList.First(); listener != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; listener = fDesktopListenerList.GetNext(listener)) changed = changed | listener-&gt;SetDecoratorSettings(window, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> changed; }</code> </pre> <br>  Lo m√°s probable es que '|'  y '||'  los operadores estaban confundidos.  Este error conduce a llamadas innecesarias de la funci√≥n <i>SetDecoratorSettings</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V627</a> Considere inspeccionar la expresi√≥n.  El argumento de sizeof () es la macro que se expande a un n√∫mero.  device.c 72 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCI_line_size 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (1 byte) cache line size in 32 bit words */</span></span></span><span class="hljs-meta"> static status_t wb840_open(const char* name, uint32 flags, void** cookie) { .... data-&gt;wb_cachesize = gPci-&gt;read_pci_config(data-&gt;pciInfo-&gt;bus, data-&gt;pciInfo-&gt;device, data-&gt;pciInfo-&gt;function, PCI_line_size, sizeof(PCI_line_size)) &amp; 0xff; .... }</span></span></code> </pre> <br>  Pasar el valor <i>0x0c</i> al operador <i>sizeof</i> parece sospechoso.  Quiz√°s, el autor deber√≠a haber evaluado el tama√±o de un objeto, por ejemplo, <i>datos</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V562</a> Es extra√±o comparar un valor de tipo bool con un valor de 18: 0x12 == IsProfessionalSpdif ().  CEchoGals_mixer.cpp 533 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BOOL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsProfessionalSpdif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ECHOSTATUS_DSP_DEAD 0x12 ECHOSTATUS CEchoGals::ProcessMixerFunction(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ECHOSTATUS_DSP_DEAD == IsProfessionalSpdif() ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { Status = ECHOSTATUS_DSP_DEAD; } else { pMixerFunction-&gt;Data.bProfSpdif = IsProfessionalSpdif(); } .... }</span></span></span></span></code> </pre> <br>  La funci√≥n <i>IsProfessionalSpdif</i> devuelve el valor de tipo <i>bool</i> .  Al hacerlo, el resultado de la funci√≥n se compara con el n√∫mero <i>0x12</i> en la condici√≥n. <br><br><h2>  Conclusi√≥n </h2><br>  Nos perdimos el lanzamiento de la primera beta de Haiku el oto√±o pasado, ya que est√°bamos ocupados lanzando PVS-Studio para Java.  A√∫n as√≠, la naturaleza de los errores de programaci√≥n es tal que no desaparecen si no los busca y no presta atenci√≥n a la calidad del c√≥digo.  Los desarrolladores de proyectos utilizaron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Coverity Scan</a> , pero la √∫ltima ejecuci√≥n fue hace casi dos a√±os.  Esto debe ser molesto para los usuarios de Haiku.  Aunque el an√°lisis se configur√≥ en 2014 usando Coverity, no nos impidi√≥ escribir dos largos art√≠culos sobre revisi√≥n de errores en 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte 2</a> ) <br><br>  Pronto saldr√° otra revisi√≥n de errores de Haiku para aquellos que leen esta publicaci√≥n hasta el final.  El informe completo del analizador se enviar√° a los desarrolladores antes de publicar esta revisi√≥n de errores, por lo que es posible que algunos errores se solucionen cuando est√© leyendo esto.  Para pasar el tiempo entre los art√≠culos, sugiero descargar y probar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> para su proyecto. <br><br>  ¬øQuieres probar Haiku y tienes preguntas?  Los desarrolladores de Haiku te invitan al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461253/">https://habr.com/ru/post/461253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461241/index.html">Wolfram Mathematica en Geof√≠sica</a></li>
<li><a href="../461243/index.html">No vayas a √Åfrica a caminar: ¬øcu√°l es la situaci√≥n con la censura de Internet en el continente negro?</a></li>
<li><a href="../461247/index.html">Las 50 mejores fuentes de gesti√≥n de productos para leer, escuchar y mirar</a></li>
<li><a href="../461249/index.html">Escribir una aplicaci√≥n de Android para fan√°ticos del cine - Parte 2 (Dise√±o)</a></li>
<li><a href="../461251/index.html">Una selecci√≥n de diapositivas √∫tiles de Julia Evans</a></li>
<li><a href="../461255/index.html">C√≥mo dispararte en el pie en C y C ++. Colecci√≥n de Recetas Haiku OS</a></li>
<li><a href="../461257/index.html">¬øC√≥mo calcular el ROI de la automatizaci√≥n de pruebas con Selenium?</a></li>
<li><a href="../461259/index.html">Storage Party, 8 de agosto, Mosc√∫</a></li>
<li><a href="../461261/index.html">Lista de verificaci√≥n de seminarios web √∫tiles de RRC sobre productos de RRC</a></li>
<li><a href="../461265/index.html">Sobre el abuso del uso del sistema operativo en proyectos para microcontroladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>