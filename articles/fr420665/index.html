<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèΩ üíâ üôáüèª Cr√©ation d'une application sur .NET Core et Kubernetes: notre exp√©rience ü§≤üèø üßëüèΩ‚Äçü§ù‚Äçüßëüèª üõÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Aujourd'hui, nous allons parler de l'exp√©rience de l'un de nos projets DevOps. Nous avons d√©cid√© d'impl√©menter une nouvelle applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'une application sur .NET Core et Kubernetes: notre exp√©rience</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/420665/">  Bonjour √† tous! <br><br>  Aujourd'hui, nous allons parler de l'exp√©rience de l'un de nos projets DevOps.  Nous avons d√©cid√© d'impl√©menter une nouvelle application pour Linux en utilisant .Net Core sur une architecture de microservice. <br><br>  Nous pr√©voyons que le projet se d√©veloppera activement et qu'il y aura de plus en plus d'utilisateurs.  Par cons√©quent, il doit √™tre facilement √©volutif en termes de fonctionnalit√©s et de performances. <br><br>  Nous avons besoin d'un syst√®me tol√©rant aux pannes - si l'un des blocs de fonctionnalit√©s ne fonctionne pas, le reste devrait fonctionner.  Nous voulons √©galement assurer une int√©gration continue, y compris le d√©ploiement de la solution sur les serveurs du client. <br><br>  Par cons√©quent, nous avons utilis√© les technologies suivantes: <br><br><ul><li>  .Net Core pour la mise en ≈ìuvre de microservices.  Notre projet a utilis√© la version 2.0, </li><li>  Kubernetes pour l'orchestration de microservices, </li><li>  Docker pour la cr√©ation d'images de microservices, </li><li>  bus d'int√©gration Rabbit MQ et Mass Transit, </li><li>  Elasticsearch et Kibana pour l'exploitation foresti√®re, </li><li>  TFS pour impl√©menter le pipeline CI / CD. </li></ul><br>  Cet article partagera les d√©tails de notre solution. <br><br><img src="https://habrastorage.org/webt/bp/r9/oo/bpr9ootyfj2tqvrmfpp6uhdnjfu.jpeg"><br><br>  Ceci est une transcription de notre discours lors de la r√©union .NET, voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers la vid√©o du</a> discours. <br><a name="habracut"></a><br><h2>  Notre d√©fi commercial </h2><br>  Notre client est une entreprise f√©d√©rale o√π il y a des marchandiseurs - ce sont des gens qui sont responsables de la fa√ßon dont les marchandises sont pr√©sent√©es dans les magasins.  Et il y a des superviseurs - ce sont les leaders des marchandiseurs. <br><br>  L'entreprise a un processus de formation et d'√©valuation du travail des marchandiseurs par des superviseurs, qui devait √™tre automatis√©. <br><br><img src="https://habrastorage.org/webt/of/w5/bh/ofw5bhdvkm9ml03ofsazm3e5mzg.png"><br><br>  Voici comment fonctionne notre solution: <br><br>  1. Le superviseur √©tablit un questionnaire - c'est une liste de contr√¥le de ce que vous devez v√©rifier dans le travail du marchandiseur. <br>  2. Ensuite, le superviseur s√©lectionne l'employ√© dont le travail sera v√©rifi√©.  La date de l'interrogatoire est attribu√©e. <br>  3. Ensuite, l'activit√© est envoy√©e √† l'appareil mobile du superviseur. <br>  4. Ensuite, le questionnaire est rempli et envoy√© au portail. <br>  5. Le portail g√©n√®re des r√©sultats et divers rapports. <br><br><h3>  Les microservices nous aideront √† r√©soudre trois probl√®mes: </h3><br>  1. √Ä l'avenir, nous voulons √©tendre facilement la fonctionnalit√©, car il existe de nombreux processus commerciaux similaires dans l'entreprise. <br>  2. Nous voulons que la solution soit tol√©rante aux pannes.  Si une partie cesse de fonctionner, la solution pourra restaurer son travail d'elle-m√™me et la d√©faillance d'une partie n'affectera pas consid√©rablement le fonctionnement de la solution dans son ensemble. <br>  3. L'entreprise pour laquelle nous mettons en ≈ìuvre la solution a de nombreuses succursales.  En cons√©quence, le nombre d'utilisateurs de la solution est en constante augmentation.  Par cons√©quent, je voulais que cela n'affecte pas les performances. <br><br>  En cons√©quence, nous avons d√©cid√© d'utiliser des microservices sur ce projet, ce qui a n√©cessit√© un certain nombre de d√©cisions non triviales. <br><br><h3>  Quelles technologies ont aid√© √† mettre en ≈ìuvre cette solution: </h3><br>  ‚Ä¢ Docker simplifie la distribution de la distribution de la solution.  La distribution dans notre cas est un ensemble d'images de microservices <br>  ‚Ä¢ Comme il existe de nombreux microservices dans notre solution, nous devons les g√©rer.  Pour cela, nous utilisons Kubernetes. <br>  ‚Ä¢ Nous impl√©mentons des microservices en utilisant .Net Core. <br>  ‚Ä¢ Afin de mettre √† jour rapidement la solution chez le client, nous devons mettre en ≈ìuvre une int√©gration et une livraison continues pratiques. <br><br>  Voici notre ensemble complet de technologies: <br><br>  ‚Ä¢ .Net Core que nous utilisons pour cr√©er des microservices, <br>  ‚Ä¢ Microservice est emball√© dans une image Docker, <br>  ‚Ä¢ L'int√©gration continue et la livraison continue sont mises en ≈ìuvre √† l'aide de TFS, <br>  ‚Ä¢ L‚Äôextr√©mit√© avant est impl√©ment√©e en angulaire, <br>  ‚Ä¢ Pour la surveillance et la journalisation, nous utilisons Elasticsearch et Kibana, <br>  ‚Ä¢ RabbitMQ et MassTransit sont utilis√©s comme bus d'int√©gration. <br><br><h3>  Solutions .NET Core pour Linux </h3><br>  Nous savons tous ce qu'est le framework .Net classique.  Le principal inconv√©nient de la plate-forme est qu'elle n'est pas multiplateforme.  Par cons√©quent, nous ne pouvons pas ex√©cuter de solutions sur le .Net Framework pour Linux dans Docker. <br><br>  Pour fournir la possibilit√© d'utiliser C # dans Docker, Microsoft a repens√© le .Net Framework et cr√©√© .Net Core.  Et pour utiliser les m√™mes biblioth√®ques, Microsoft a cr√©√© la sp√©cification de biblioth√®que standard .Net.  Les assemblys .Net Standart Library peuvent √™tre utilis√©s √† la fois dans .Net Framework et .Net Core. <br><br><img src="https://habrastorage.org/webt/2z/qy/s9/2zqys9n9-watdykykh0uxpbhgl8.png"><br><br><h3>  Kubernetes - pour l'orchestration de microservices </h3><br>  Kubernetes est utilis√© pour g√©rer et regrouper les conteneurs Docker.  Voici les principaux avantages de Kubernetes dont nous avons profit√©: <br><br>  - offre la possibilit√© de configurer facilement l'environnement des microservices, <br>  - simplifie la gestion environnementale (Dev, QA, Stage), <br>  - Pr√™t √† l'emploi offre la possibilit√© de r√©pliquer les microservices et l'√©quilibrage de charge sur les r√©pliques. <br><br><img src="https://habrastorage.org/webt/jw/fu/11/jwfu11e5m-xv4rrqmy--goxcghs.png"><br><br><h2>  Architecture de la solution </h2><br>  Au d√©but des travaux, nous nous sommes demand√© comment diviser la fonctionnalit√© en microservices.  La division a √©t√© faite sur le principe d'une responsabilit√© unique, mais √† un niveau sup√©rieur.  Sa t√¢che principale est d'apporter des modifications √† un service en affectant le moins possible les autres microservices.  En cons√©quence, dans notre cas, les microservices ont commenc√© √† effectuer un domaine de fonctionnalit√© distinct. <br><br>  En cons√©quence, nous sommes apparus des services qui sont engag√©s dans la planification de questionnaires, un microservice pour afficher les r√©sultats, un microservice pour travailler avec une application mobile et d'autres microservices. <br><br><img src="https://habrastorage.org/webt/f8/by/-6/f8by-6unz3mtb-f8edbczrmvhtg.png"><br><br><h3>  Options d'interaction avec des clients externes </h3><br>  Microsoft dans son livre sur les microservices, ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.NET Microservices.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">.NET Container Application Architecture</a> ¬ªpropose trois impl√©mentations possibles d'interaction avec des microservices.  Nous avons examin√© les trois et choisi la plus appropri√©e. <br><br>  ‚Ä¢ Service API Gateway <br>  L'API de service Gateway est une impl√©mentation de fa√ßade pour les demandes des utilisateurs pour d'autres services.  Le probl√®me avec la solution est que si la fa√ßade ne fonctionne pas, alors toute la solution cessera de fonctionner.  Ils ont d√©cid√© d'abandonner cette approche pour la tol√©rance aux pannes. <br><br>  ‚Ä¢ API Gateway avec Azure API Management <br>  Microsoft offre la possibilit√© d'utiliser une fa√ßade cloud dans Azure.  Mais cette solution ne convenait pas, car nous allions d√©ployer la solution non pas dans le cloud, mais sur les serveurs du client. <br><br>  ‚Ä¢ Communication directe client-microservice <br>  En cons√©quence, il nous reste la derni√®re option - l'interaction directe de l'utilisateur avec les microservices.  Nous l'avons choisi. <br><br><img src="https://habrastorage.org/webt/sc/uc/x6/scucx6-8y4bj629y967_urhsy2q.png"><br><br>  Son plus en tol√©rance aux pannes.  L'inconv√©nient est qu'une partie de la fonctionnalit√© devra √™tre reproduite sur chaque service s√©par√©ment.  Par exemple, il √©tait n√©cessaire de configurer l'autorisation s√©par√©ment sur chaque microservice auquel les utilisateurs ont acc√®s. <br><br>  Bien s√ªr, la question se pose de savoir comment nous allons √©quilibrer la charge et comment la tol√©rance aux pannes est mise en ≈ìuvre.  Tout est simple ici - Ingress Controller Kubernetes le fait. <br><br><img src="https://habrastorage.org/webt/87/3p/zq/873pzqb0ffu9ugon6pa5b8bx6ao.png"><br><br>  Le n≈ìud 1, le n≈ìud 2 et le n≈ìud 3 sont des r√©pliques du m√™me microservice.  Si l'une des r√©pliques √©choue, l'√©quilibreur de charge redirigera automatiquement la charge vers d'autres microservices. <br><br><h3>  Architecture physique </h3><br>  Voici comment nous avons organis√© notre infrastructure de solutions: <br><br>  ‚Ä¢ Chaque microservice a sa propre base de donn√©es (s'il en a bien s√ªr besoin), les autres services n'acc√®dent pas √† la base de donn√©es d'un autre microservice. <br>  ‚Ä¢ Les microservices communiquent entre eux uniquement via le bus RabbitMQ + Mass Transit, ainsi qu'en utilisant des requ√™tes HTTP. <br>  ‚Ä¢ Chaque service a sa propre responsabilit√© clairement d√©finie. <br>  ‚Ä¢ Pour la journalisation, nous utilisons Elasticsearch et Kibana et la biblioth√®que pour travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Serilog</a> . <br><br><img src="https://habrastorage.org/webt/lu/8p/z3/lu8pz3zhxiggf1syj1btyqm9q54.png"><br><br>  Le service de base de donn√©es a √©t√© d√©ploy√© sur une machine virtuelle distincte et non dans Kubernetes, car Microsoft DBMS ne recommande pas d'utiliser Docker sur les environnements de produit. <br><br>  Le service de journalisation a √©galement √©t√© d√©ploy√© sur une machine virtuelle distincte pour des raisons de tol√©rance aux pannes - si nous avons des probl√®mes avec Kubernetes, alors nous pouvons comprendre quel est le probl√®me. <br><br><h2>  D√©ploiement: comment nous avons organis√© les environnements de d√©veloppement et de produits </h2><br>  Notre infrastructure dispose de 3 espaces de noms √† Kubernetes.  Les trois environnements acc√®dent √† un service de base de donn√©es et √† un service de journalisation.  Et, bien s√ªr, chaque environnement regarde sa propre base de donn√©es. <br><br><img src="https://habrastorage.org/webt/rh/el/mz/rhelmza1dleycp5kdiylccr1aig.png"><br><br>  Sur l'infrastructure du client, nous avons √©galement deux environnements: la pr√©-production et la production.  √Ä la production, nous avons des serveurs de base de donn√©es s√©par√©s pour la pr√©-vente et l'environnement du produit.  Pour la journalisation, nous avons allou√© un serveur ELK sur notre infrastructure et sur l'infrastructure du client. <br><br><h3>  Comment d√©ployer 5 environnements avec 10 microservices chacun? </h3><br>  En moyenne, nous avons 10 services par projet et trois environnements: QA, DEV, Stage, sur lesquels environ 30 microservices sont d√©ploy√©s au total.  Et ce n'est que sur l'infrastructure de d√©veloppement!  Ajoutez 2 environnements suppl√©mentaires sur l'infrastructure du client et nous b√©n√©ficions de 50 microservices. <br><br><img src="https://habrastorage.org/webt/sq/1m/kf/sq1mkfrwc4nfuu6whyq-cja9g-m.png"><br><br>  Il est clair qu'un tel nombre de services doit en quelque sorte √™tre g√©r√©.  Kubernetes nous y aide. <br><br>  Pour d√©ployer un microservice, vous devez <br>  ‚Ä¢ D√©veloppez secret, <br>  ‚Ä¢ D√©ployer le d√©ploiement, <br>  ‚Ä¢ √âtendre le service. <br><br>  √Ä propos de l'√©criture secr√®te ci-dessous. <br>  Le d√©ploiement est une instruction pour Kubernetes, sur la base de laquelle il lancera le conteneur Docker de notre microservice.  Voici la commande sur laquelle le d√©ploiement est d√©ploy√©: <br><br> <code>kubectl apply -f .\(yaml  deployment-) --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Ce fichier d√©crit comment le d√©ploiement est appel√© (imtob-etr-it-dictionary-api), quelle image il doit utiliser pour l'ex√©cution, ainsi que d'autres param√®tres.  Dans la section secr√®te, nous allons personnaliser notre environnement. <br><br>  Apr√®s avoir d√©ploy√© le d√©ploiement, nous devons d√©ployer le service, si n√©cessaire. <br><br>  Les services sont n√©cessaires lorsque l'acc√®s au microservice de l'ext√©rieur est n√©cessaire.  Par exemple, lorsque vous souhaitez qu'un utilisateur ou un autre microservice puisse effectuer une demande Get vers un autre microservice. <br><br> <code>kubectl apply -f .\imtob-etr-it-dictionary-api.yml --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: imtob-etr-it-dictionary-api-services spec: ports: - name: http port: 80 targetPort: 80 protocol: TCP selector: name: imtob-etr-it-dictionary-api</code> </pre> <br><br>  Habituellement, la description du service est petite.  On y voit le nom du service, comment y acc√©der et le num√©ro de port. <br><br>  Par cons√©quent, pour d√©ployer l'environnement, nous avons besoin <br><br>  ‚Ä¢ un ensemble de fichiers avec des secrets pour tous les microservices, <br>  ‚Ä¢ un ensemble de fichiers avec le d√©ploiement de tous les microservices, <br>  ‚Ä¢ un ensemble de fichiers avec les services de tous les microservices. <br><br>  Nous stockons tous ces scripts dans le r√©f√©rentiel git. <br><br>  Pour d√©ployer la solution, nous avons obtenu un ensemble de trois types de scripts: <br><br>  ‚Ä¢ dossier avec secrets - ce sont des configurations pour chaque environnement, <br>  ‚Ä¢ dossier avec d√©ploiement pour tous les microservices, <br>  ‚Ä¢ dossier avec services pour certains microservices, <br><br>  dans chacune - une dizaine d'√©quipes, une pour chaque microservice.  Pour plus de commodit√©, nous avons cr√©√© une page avec des scripts dans Confluence, qui nous aide √† d√©ployer rapidement un nouvel environnement. <br><br>  Voici un script de d√©ploiement de d√©ploiement (il existe des ensembles similaires pour secret et pour service): <br><br><div class="spoiler">  <b class="spoiler_title">Script de d√©ploiement</b> <div class="spoiler_text">  kubectl applique -f. \ imtob-etr-it-image-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-mobile-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-planning-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-result-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-web.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-report-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-template-constructor-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-dictionary-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-integration-api.yml --namespace = DEV <br>  kubectl applique -f. \ imtob-etr-it-identity-api.yml --namespace = DEV <br></div></div><br><br><h3>  Impl√©mentation CI / CD </h3><br><br>  Chaque service est dans son propre dossier, et nous avons un dossier avec des composants communs. <br><br><img src="https://habrastorage.org/webt/kj/xk/zf/kjxkzf7k-qzppe0ncduxvb_dzmc.jpeg"><br><br>  Il existe √©galement une d√©finition de build et une d√©finition de version pour chaque microservice.  Nous avons configur√© le lancement de Build Definion lors de la validation sur le service appropri√© ou lors de la validation dans le dossier appropri√©.  Si le contenu du dossier avec les composants communs est mis √† jour, tous les microservices sont d√©ploy√©s. <br><br>  Quels sont les avantages d'une telle organisation Build? <br><br>  1. La solution est dans un r√©f√©rentiel git, <br>  2. Lors du changement de plusieurs microservices, l'assemblage d√©marre en parall√®le avec les agents d'assemblage libres, <br>  3. Chaque d√©finition de build pr√©sente un script simple √† partir de la cr√©ation de l'image et de son insertion dans le registre Nexus. <br><br><h3>  D√©finition de version et d√©finition de version </h3><br>  Comment d√©ployer un agent VSTS, nous l'avons d√©crit pr√©c√©demment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> . <br><br><img src="https://habrastorage.org/webt/df/3i/k6/df3ik6q87wmw9qwjsjituwvmat8.png"><br><br>  Vient d'abord la d√©finition de construction.  √Ä la commande TFS VSTS, l'agent lance la g√©n√©ration Dockerfile.  En cons√©quence, nous obtenons l'image d'un microservice.  Cette image est enregistr√©e localement sur l'environnement o√π l'agent VSTS s'ex√©cute. <br><br>  Apr√®s la g√©n√©ration, Push est lanc√©, qui envoie l'image que nous avons re√ßue √† l'√©tape pr√©c√©dente au registre Nexus.  Maintenant, il peut √™tre utilis√© en externe.  Le registre Nexus est une sorte de Nuget, non seulement pour les biblioth√®ques, mais pour les images Docker et plus encore. <br><br>  Une fois l'image pr√™te et accessible de l'ext√©rieur, vous devez la d√©ployer.  Pour cela, nous avons la d√©finition de version.  Tout est simple ici - nous ex√©cutons la commande set image: <br><br> <code>kubectl set image deployment/imtob-etr-it-dictionary-api imtob-etr-it-dictionary-api=nexus3.company.ru:18085/etr-it-dictionary-api:$(Build.BuildId)</code> <br> <br>  Apr√®s cela, il mettra √† jour l'image du microservice souhait√© et lancera un nouveau conteneur.  En cons√©quence, notre service a √©t√© mis √† jour. <br><br>  Comparons maintenant la construction avec et sans Dockerfile. <br><br><img src="https://habrastorage.org/webt/dn/wq/j6/dnwqj6og3rbyvdojybcrvs88yq0.png"><br><br>  Sans Dockerfile, nous obtenons beaucoup d'√©tapes, qui ont beaucoup de sp√©cificit√©s .Net.  Sur la droite, nous voyons une construction d'image Docker.  Tout est devenu beaucoup plus facile. <br><br>  L'ensemble du processus de construction de l'image est d√©crit dans le Dockerfile.  Cet assembly peut √™tre d√©bogu√© localement. <br><br><img src="https://habrastorage.org/webt/hk/pd/g0/hkpdg0lafe00sbh1_afyquwwjsm.png"><br><br><h3>  Total: nous avons obtenu un CI / CD simple et transparent </h3><br><br>  1. S√©paration du d√©veloppement et du d√©ploiement.  L'assemblage est d√©crit dans Dockerfile et repose sur les √©paules du d√©veloppeur. <br>  2. Lors de la configuration de CI / CD, vous n'avez pas besoin de conna√Ætre les d√©tails et les caract√©ristiques de l'assemblage - le travail se fait uniquement avec le Dockerfile. <br>  3. Nous mettons √† jour uniquement les microservices modifi√©s. <br><br>  Ensuite, vous devez configurer RabbitMQ dans le K8S: nous avons √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article s√©par√©</a> √† ce sujet. <br><br><h3>  R√©glage de l'environnement </h3><br>  D'une mani√®re ou d'une autre, nous devons configurer des microservices.  La partie principale de l'environnement est configur√©e dans le fichier de configuration racine Appsettings.json.  Ce fichier contient des param√®tres ind√©pendants de l'environnement. <br><br>  Ces param√®tres qui d√©pendent de l'environnement sont stock√©s dans le dossier secrets du fichier appsettings.secret.json.  Nous avons adopt√© l'approche d√©crite dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion des param√®tres de l'application ASP.NET Core sur Kubernetes</a> . <br><br><pre> <code class="plaintext hljs">var configuration = new ConfigurationBuilder() .AddJsonFile($"appsettings.json", true) .AddJsonFile("secrets/appsettings.secrets.json", optional: true) .Build();</code> </pre> <br><br>  Le fichier appsettings.secrets.json contient les param√®tres des index Elastic Search et la cha√Æne de connexion √† la base de donn√©es. <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Serilog"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"WriteTo"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elasticsearch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nodeUris"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://192.168.150.114:9200"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"indexFormat"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary-{0:yyyy.MM.dd}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"templateName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"typeName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary.event"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DictionaryDbContext"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=192.168.154.162;Database=DEV.ETR.IT.iField.Dictionary;User Id=it_user;Password=PASSWORD;"</span></span> } }</code> </pre><br><br><h4>  Ajouter un fichier de configuration √† Kubernetes </h4><br>  Pour ajouter ce fichier, vous devez le d√©ployer dans le conteneur Docker.  Cela se fait dans le fichier de d√©ploiement de Kubernetis.  Le d√©ploiement d√©crit dans quel dossier le fichier secret c doit √™tre cr√©√© et √† quel secret il est n√©cessaire d'associer le fichier. <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Vous pouvez cr√©er un secret dans Kubernetes √† l'aide de l'utilitaire kubectl.  Nous voyons ici le nom du secret et le chemin d'acc√®s au fichier.  Nous indiquons √©galement le nom de l'environnement pour lequel nous cr√©ons un secret. <br><br> <code>kubectl create secret generic secret-appsettings-dictionary <br> --from-file=./Dictionary/appsettings.secrets.json --namespace=DEMO</code> <br> <br><h2>  Conclusions </h2><br><h3>  Inconv√©nients de l'approche choisie </h3><br>  1. Seuil d'entr√©e √©lev√©.  Si vous r√©alisez un tel projet pour la premi√®re fois, il y aura beaucoup de nouvelles informations. <br>  2. Microservices ‚Üí conception plus complexe.  Il est n√©cessaire d'appliquer de nombreuses solutions non √©videntes car nous n'avons pas une solution monolithique, mais une solution microservice. <br>  3. Tout n'est pas impl√©ment√© pour Docker.  Tout ne peut pas √™tre ex√©cut√© dans une architecture de microservice.  Par exemple, alors que SSRS n'est pas dans Docker. <br><br><h3>  Avantages d'une approche auto-test√©e </h3><br>  1. L'infrastructure comme code <br>  La description de l'infrastructure est stock√©e dans le contr√¥le de code source.  Au moment du d√©ploiement, vous n'avez pas besoin d'adapter l'environnement. <br>  2. Mise √† l'√©chelle √† la fois au niveau des fonctionnalit√©s et au niveau des performances hors de la bo√Æte. <br>  3. Les microservices sont bien isol√©s <br>  Il n'y a pratiquement pas de parties critiques, dont la d√©faillance conduit √† l'inop√©rabilit√© du syst√®me dans son ensemble. <br>  4. Livraison rapide des modifications <br>  Seuls les microservices dans lesquels il y a eu des mises √† jour sont mis √† jour.  Si vous ne tenez pas compte du temps de coordination et d'autres √©l√©ments li√©s au facteur humain, la mise √† jour d'un microservice s'effectue en 2 minutes ou moins. <br><br><h3>  Conclusions pour nous </h3><br>  1. Sur .NET Core, vous pouvez et devez mettre en ≈ìuvre des solutions industrielles. <br>  2. K8S a vraiment simplifi√© la vie, simplifi√© la mise √† jour des environnements, facilit√© la configuration des services. <br>  3. TFS peut √™tre utilis√© pour impl√©menter CI / CD pour Linux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420665/">https://habr.com/ru/post/fr420665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420655/index.html">Des robots louent des appartements via Airbnb pour apprendre √† mieux saisir les objets</a></li>
<li><a href="../fr420657/index.html">Analyse: sur l'argent duquel Elon Musk pourra retirer Tesla de la bourse</a></li>
<li><a href="../fr420659/index.html">Campagne USB de HRF (Human Rights Foundation) ¬´Flash Drives for Freedom¬ª</a></li>
<li><a href="../fr420661/index.html">Infrastructure cloud continue</a></li>
<li><a href="../fr420663/index.html">Des mesures simples et un moyen de gagner du temps lors de la recherche de probl√®mes dans l'infrastructure</a></li>
<li><a href="../fr420667/index.html">Principes de fonctionnement du protocole EIGRP</a></li>
<li><a href="../fr420669/index.html">Aper√ßu du march√© de l'automatisation d'entreprise: solutions pour les soci√©t√©s de construction et de gestion de logements et de services publics</a></li>
<li><a href="../fr420671/index.html">[Ekaterinbourg, annonce] UralJS # 9 - trois rapports sur les microservices, les tests et la journalisation des erreurs √† l'avant</a></li>
<li><a href="../fr420673/index.html">Docker pour Symfony 4 - du LAN √† la production</a></li>
<li><a href="../fr420675/index.html">Les SOC sont des personnes. ¬´Bonjour, nous recherchons des talents¬ª ou d'o√π viennent les analystes du centre de surveillance et de r√©ponse aux cyberattaques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>