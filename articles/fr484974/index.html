<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼 👆🏾 👩🏾‍🤝‍👩🏽 Tuiles Wang pour la simulation de la machine de Turing 💊 👩🏼‍🎓 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tuiles Wang (dominos) ont été inventées par Hao Wang en 1961 pour des problèmes mathématiques, mais ont été largement utilisées dans les jeux pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tuiles Wang pour la simulation de la machine de Turing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484974/">  Les tuiles Wang (dominos) ont été inventées par Hao Wang en 1961 pour des problèmes mathématiques, mais ont été largement utilisées dans les jeux pour créer des graphiques de tuiles.  Grâce à eux, les résultats ne semblent pas répétitifs, tant dans les textures 2D que dans les modèles 3D avec carrelage. <br><br>  Il semble que les tuiles de Van soient également capables d'exécuter des machines Turing, et donc, elles sont complètes de Turing, ce qui signifie qu'elles peuvent exécuter n'importe quel programme. <br><br>  C'est une déclaration incroyable et incompréhensible, donc dans ce post, j'examinerai un peu ce problème. <br><br><h2>  En bref sur Van Tiles </h2><br>  Les tuiles Van sont des tuiles rectangulaires dans lesquelles chacune des faces ne peut correspondre qu'à d'autres faces spécifiques, mais pour toute face particulière, il existe plusieurs tuiles possibles qui peuvent correspondre à cette face.  En faisant correspondre les visages, je veux dire qu'ils se connectent de manière transparente sans créer d'artefacts visuels ou de signes d'une couture entre les carreaux. <br><br>  Cette propriété est utile pour les graphiques, car elle vous permet de créer des graphiques de tuiles sans couture, mais la configuration de l'emplacement des tuiles peut être complètement aléatoire, à condition que toutes les faces soient compatibles les unes avec les autres.  Le résultat est des graphiques en mosaïque, qui ne ressemblent pas du tout à ceux qui se répètent, car les motifs visuels deviennent beaucoup moins visibles que les graphiques en mosaïque traditionnels. <br><br>  Des exemples graphiques, des informations plus détaillées et des liens vers Shadertoy peuvent être trouvés ici: <a href="https://blog.demofox.org/2014/08/13/wang-tiling/">Wang Tiling</a> . <br><br>  Voici un exemple que j'ai créé.  Mes graphismes sont des «programmeurs artistiques», mais j'espère que l'idée est claire.  Le dessin est composé de 16 tuiles, et pour chaque face, il existe deux types de faces différents. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1dd/f35/586/1ddf35586684620140e0d28b0118dce1.png"></div><a name="habracut"></a><br><h2>  En bref sur les machines de Turing </h2><br>  Les machines de Turing ont été inventées en 1936 par Alan Turing comme un ordinateur généralisé, pour lequel il a été prouvé qu'il peut exécuter n'importe quel algorithme. <br><br>  La machine de Turing est composée de plusieurs composants principaux: bandes de mémoire, têtes de lecture / écriture et machines d'état. <br><br>  La bande mémoire a une longueur infinie, c'est-à-dire qu'elle a une capacité de stockage infinie et, au début, elle est initialisée avec des zéros uniquement. <br><br>  La tête de lecture / écriture commence à partir d'une certaine position de la bande et peut lire / écrire des valeurs, et également se déplacer à gauche et à droite le long de la bande. <br><br>  La machine d'état contrôle la tête de lecture / écriture. <br><br>  La machine d'état sait dans quel état elle se trouve et a des règles sur ce qu'il faut faire dans chaque état lorsqu'elle lit une valeur sur la bande. <br><br>  Par exemple, dans l'état A, si 0 est lu sur la bande, la règle peut être d'écrire 1 à la position actuelle de la bande, de déplacer la tête de lecture / écriture vers la droite ou de passer à l'état B.L'État B peut avoir une logique complètement différente et peut soit effectuer la transition revenir à l'état A, ou rester dans l'état B, ou passer à un état complètement différent. <br><br>  En utilisant une logique de transition entre les états aussi simple, tout algorithme informatique peut être exécuté. <br><br>  La machine de Turing peut également avoir un «état d'arrêt», ce qui signifie que le programme a terminé son exécution et que la réponse a été calculée. <br><br>  Vous cherchez des programmes.  peut être facilement vu.  qu'au fil du temps, ils finiront ou seront dans une boucle infinie et ne s'arrêteront jamais.  Certains programmes sont situés entre eux, ils sont complexes et il n'est pas si facile de déterminer s'ils s'arrêteront jamais.  Turing a prouvé qu'il n'y a pas de solution générale pour déterminer si la machine Turing s'arrêtera (c'est un programme informatique), et c'est ce qu'on appelle <a href="https://en.wikipedia.org/wiki/Halting_problem">le problème d'arrêt</a> .  En général, la seule façon de savoir si un programme s'arrête est d'attendre.  En fait, dans le cas général, les réponses à cette question sont «oui» ou «pas encore», cependant, dans le cas de nombreux programmes spécifiques, vous pouvez voir qu’après leur lancement, ils prendront fin avec le temps. <br><br><h2>  Calculs de tuiles Wang </h2><br>  Il s'avère que les tuiles Wang peuvent simuler une machine de Turing, c'est-à-dire qu'elles sont complètes de Turing, ce qui signifie qu'elles peuvent exécuter n'importe quel algorithme informatique. <br><br>  Pour réaliser cela, nous avons besoin d'une colonne de tuiles Van qui indique l'état de la machine de Turing à un moment donné, en commençant au temps 0 dans la colonne la plus à gauche.  Nous allons mettre des tuiles dans la colonne de droite avec toutes les règles des visages, puis créer une colonne à droite de celle-ci, et ainsi de suite, jusqu'à ce que le programme se termine (ou nous le ferons pour toujours s'il ne se termine pas).  Si vous sélectionnez le bon jeu de tuiles, il vous suffira de vérifier la conformité aux règles des faces dans le processus de disposition des tuiles pour terminer la machine de Turing. <br><br>  Regardons un exemple simple qui a les règles de logique de la machine à états suivantes: <br><br><ol><li>  Lorsque la machine est dans l'état A, alors dans le cas de la lecture de 0, nous écrivons 1, déplaçons la tête de lecture / écriture vers le bas et passons à l'état B. </li><li>  Lorsque la machine est dans l'état A, dans le cas de la lecture 1, le programme s'arrête (passe à l'état final). </li><li>  Lorsque la machine est dans l'état B, dans le cas de la lecture de 0, nous écrivons 1, déplaçons la tête de lecture-écriture et passons à l'état A. </li><li>  Lorsque la machine est à l'état B, dans le cas de la lecture 1, le programme s'arrête (passe à l'état final) </li></ol><br><h3>  Lecteur de bande </h3><br>  Tout d'abord, nous avons besoin d'un stockage permanent pour la bande.  Pour ce faire, nous avons besoin des deux tuiles suivantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/125/5dc/d811255dc542e1d46ff70e7dbeb94123.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br>  Pour tester leur travail, nous pouvons préparer un segment de la bande avec quelques valeurs (créer une colonne de tuiles Van) et nous assurer que les seules tuiles Van appropriées situées à côté de la colonne initiale sont des tuiles qui transfèrent les valeurs 0 et 1 dans le temps sans changer eux. <br><br>  Dans le diagramme ci-dessous, nous initialisons la bande avec la valeur 0101 dans la colonne la plus à gauche (temps 0).  N'ayant que des tuiles avec des faces compatibles, nous voyons que les valeurs en mémoire sont stockées pour toujours.  Nous avons implémenté un lecteur de mémoire! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/773/2b8/cff/7732b8cffe9ffaf7b33320070373485d.png"></div><br>  Nous allons commencer à montrer notre exemple avec une mémoire initialisée à 0, et la figure ci-dessus montre simplement la persistance de la mémoire. <br><br><h3>  Machine d'état de tête de lecture-écriture </h3><br>  La tête de lecture / écriture d'une machine de Turing est présentée comme faisant partie des informations sur le visage.  Ainsi, en plus du visage stockant 0 ou 1, si la tête de lecture / écriture s'y trouve, elle stocke également l'état de la machine d'état. <br><br>  Dans notre exemple, deux états sont utilisés (sans inclure l'état final): A et B. Si 1 est lu, alors dans l'un des états (A ou B) le programme se termine. <br><br>  Pour gérer cela, nous avons besoin des tuiles suivantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/4a3/988/7d94a39887d1a95352c0205ff9f530eb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4d/31b/a7a/a4d31ba7a6b49c895390e7caeda59479.png"></div><br>  Maintenant que nous avons les règles de transition vers l'état final (règles 2 et 4), nous devons comprendre comment mettre en œuvre les règles qui contrôlent le passage d'un état à un autre (règles 1 et 3). <br><br><h3>  Déplacement de la tête de lecture / écriture </h3><br>  La règle 1 stipule que si nous sommes dans l'état A et lisons 0, nous devons écrire 1, déplacer la tête de lecture / écriture vers le bas et passer à l'état B. <br><br>  Nous avons besoin de cette tuile pour lire 0 dans l'état A, pour écrire 1 comme sortie, et commander la tuile ci-dessous pour entrer dans l'état B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/85d/f54/3a385df54323ebee4f460b42899498a9.png"></div><br>  La tuile en dessous de la tuile actuelle peut avoir une valeur de 0 ou 1;  sans connaître une valeur spécifique, nous devons la sauvegarder, mais accepter la tête de lecture / écriture et être dans l'état B. Pour cela, nous avons besoin de deux tuiles - une pour 0 sur la bande dans cette position, l'autre pour 1 sur la bande. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/18c/7f8/97318c7f8e44bf70cb6537da8c2bbd9e.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8e/ab0/772/f8eab0772ad7827b994646a275b9f23b.png"></div><br>  La règle 3 stipule que si nous sommes dans l'état B et lisons 0, nous devons écrire 1, déplacer la tête de lecture-écriture vers le haut et passer à l'état A. <br><br>  Pour ce faire, nous avons besoin d'une construction similaire à la construction de la règle 1, mais nous ne descendons pas, mais vers le haut.  Les trois tuiles suivantes donneront le résultat souhaité: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1a/d68/bd0/c1ad68bd057f7b7fa0bb228d158bb36b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/e96/0da/a6fe960da1b315bda9d7461c7f2f4e6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br><h2>  Carreaux de colonne initiale </h2><br>  Nous percevrons les limites de la zone de simulation comme si elles avaient une face «x». <br><br>  Cela signifie que pour créer la colonne initiale (machine de Turing au temps 0), nous avons besoin de deux tuiles spéciales.  Une tuile est nécessaire pour stocker la valeur 0 sur la bande, qui initialise la bande, et une autre tuile - pour stocker la position de la tête de lecture / écriture dans l'état A, qui est notre état initial. <br><br>  Ces deux tuiles sont: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d34/969/edbd349698db9c4871c63fc44298fefe.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/6df/449/1996df4494d4b8ea4854ea1b3d2f9036.png"></div><br><h2>  Ensemble de tuiles prêt </h2><br>  Voici l'ensemble complet de 12 tuiles que nous utiliserons: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/d56/8c1/853d568c1a623fe7c1fc123dff3dd671.png"></div><br><h2>  Simulation complète </h2><br>  Voici la conception originale de notre machine Turing au temps 0. Notez que c'est l'un des états initiaux possibles, mais c'est l'état que nous avons choisi.  Nous ne laissons pas la possibilité de choisir où commence la tête de lecture / écriture et sa présence également.  Si nous ne suivons que les règles des faces, nous pouvons obtenir 4 ou 0 têtes de lecture-écriture, ou n'importe quel nombre entre elles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/5b8/e7a/33e5b8e7a21b1c52a54b28324f50665d.png"></div><br>  De là, pour créer la deuxième colonne, nous partons du haut et descendons, en choisissant une tuile qui correspond aux restrictions de la face qu'elle touche.  Dans cette première étape, la tête lit 0, écrit 1, descend et passe à l'état B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/551/9b1/4c65519b125288868d742b3f362e7380.png"></div><br>  Voici la deuxième étape, où la tête lit 0, écrit 1, monte et passe à l'état A. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/5bd/1e0/3e25bd1e0afad891f739c61a500dbf4c.png"></div><br>  Voici la dernière étape dans laquelle la tête lit 1 et entre dans l'état final, indiquant que le programme est terminé. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/25d/6bb/bb825d6bb75417f9863376d7f23524df.png"></div><br>  Le programme s'est terminé et nous a donné une valeur de sortie de 0110, ou 6. Ces valeurs de sortie ne sont pas particulièrement importantes, mais d'autres programmes peuvent produire une sortie significative.  Par exemple, nous pouvons forcer une machine de Turing à ajouter deux nombres, et la sortie sera la somme de ces deux nombres. <br><br><h2>  Détail important </h2><br>  Ici, nous devons mentionner un détail important que nous n'avons pas considéré ci-dessus, et qui n'est pas mentionné dans la plupart des explications des machines de Turing sur les carreaux Van. <br><br>  Lorsque vous placez la deuxième tuile pour le temps 2, la seule restriction sur les faces est que la tuile doit avoir x en haut et 1 à gauche.  En fait, à cause de cela, la situation devient ambiguë, car il n'est pas clair laquelle des deux tuiles illustrées ci-dessous doit être sélectionnée. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br>  Alors, comment choisissons-nous la bonne? <br><br>  La réponse est que nous faisons simplement une hypothèse et choisissons l'une d'entre elles.  Si dans ce cas la mauvaise tuile est sélectionnée, alors quand nous passerons à la tuile suivante, nous chercherons une tuile avec x en haut et B0 à gauche.  Une telle tuile n'existe pas, nous ne pouvons donc pas mettre la tuile.  Lorsque cela se produit, nous devons revenir à la dernière vignette et essayer l'une des autres options. <br><br>  C'est, malheureusement, lors de la simulation de machines Turing à l'aide de carreaux Wang, il y a littéralement un processus d'essai et d'erreur, mais au moins, il est tout à fait gérable.  Cela complique vraiment un peu les calculs dans le pixel shader (ou dans d'autres appareils à parallélisme élevé), mais les coûts ne sont pas beaucoup plus élevés. <br><br><h2>  Conclusion et liens </h2><br>  Certains des liens ci-dessous traitent des carreaux Wang et des machines Turing, mais les discussions ne semblent pas adhérer strictement aux machines Turing.  Par exemple, vous remarquerez peut-être que dans certains exemples, les données sont autorisées à revenir dans le temps - lorsque le programme se termine, la réponse est sur bande au moment 0 de la machine de Turing, malgré le fait que ces données n'étaient pas là au moment 0. Cela montre que les tuiles Wang peuvent faire les calculs par elles-mêmes, pas seulement simuler des machines de Turing, mais je ne sais pas exactement comment cette technique sera appelée. <br><br>  De plus, si vous êtes intéressé à savoir ce qui est utile dans le calcul à l'aide de carreaux Wang, alors personnellement, je ne peux pas imaginer des cas d'application pratique.  Cependant, les scientifiques semblent avoir découvert que l'ADN peut agir de la même manière que les carreaux de Van dans le sens où les connexions ne sont établies qu'entre des faces compatibles.  Grâce à cela, des calculs basés sur l'ADN sont désormais recherchés sur la base du processus de calcul à l'aide de carreaux Wang.  Sujet assez intéressant! <br><br>  Voici l'implémentation du calcul des nombres premiers à l'aide des tuiles Wang dans Shadertoy dans le pixel shader WebGL: <br><br>  <a href="https://www.shadertoy.com/view/4sV3zK">Shadertoy: WangTiles: PrimeGenerator</a> <br><br>  Voici d'autres vidéos intéressantes sur les voitures Turing et le problème de l'arrêt: <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DdNRDvLACg5Q">Turing Machines Explained - Computerphile</a> <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DmacM_MtS_w4">Turing et le problème de l'arrêt - Computerphile</a> <br><br>  Et voici quelques liens supplémentaires: <br><br>  <a href="https://moyix.wordpress.com/2012/04/06/computing-with-tiles/">Calculer avec des tuiles</a> <br><br>  <a href="https://en.wikipedia.org/wiki/Wang_tile">Wikipédia: tuiles Van</a> <br><br>  <a href="http://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/">Tuiles Wang et machines de Turing</a> <br><br>  <a href="https://because0fbeauty.wordpress.com/2014/02/28/wang-tiles-1/">Tuiles Wang - 1</a> <br><br>  Voici quelques articles scientifiques: <br><br>  <a href="http://www.math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings1989/2_Michie89.pdf">Calculer avec des tuiles</a> <br><br>  <a href="http://link.springer.com/chapter/10.1007%252F978-0-387-09680-3_13">Calculabilité des pavages</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484974/">https://habr.com/ru/post/fr484974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484954/index.html">Guide de dépannage visuel pour Kubernetes</a></li>
<li><a href="../fr484964/index.html">Configuration de l'équilibrage de charge sur InfoWatch Traffic Monitor</a></li>
<li><a href="../fr484966/index.html">Modèle prêt à l'emploi pour les tests à l'aide de Spring</a></li>
<li><a href="../fr484968/index.html">WPF DataGrid. Battez-vous pour le modèle</a></li>
<li><a href="../fr484972/index.html">Wine 5.0 est sorti</a></li>
<li><a href="../fr484978/index.html">PubSub est presque gratuit: NOTIFY fonctionnalités de PostgreSQL</a></li>
<li><a href="../fr484982/index.html">Est-il facile d'organiser votre entreprise pour un spécialiste informatique</a></li>
<li><a href="../fr484984/index.html">Développeur de jeux Unity. Nouveau cours d'OTUS</a></li>
<li><a href="../fr484990/index.html">Luxoft TechTalks - podcasts vidéo de gourous informatiques mondiaux et plus</a></li>
<li><a href="../fr484992/index.html">Plus joli dans les grands projets: passez 20 minutes sur la configuration, oubliez le formatage pour toujours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>