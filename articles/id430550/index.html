<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃 ⚱️ 🖕🏻 Membangun sistem komponen reaktif dengan Kotlin 🎳 🐛 🧓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Anatoly Varivonchik, saya adalah pengembang Android di Badoo. Hari ini saya akan berbagi dengan Anda terjemahan bagian kedua ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun sistem komponen reaktif dengan Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430550/"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Halo semuanya!  Nama saya Anatoly Varivonchik, saya adalah pengembang Android di Badoo.  Hari ini saya akan berbagi dengan Anda terjemahan bagian kedua artikel oleh rekan saya Zsolt Kocsi tentang implementasi MVI, yang kami gunakan setiap hari dalam proses pengembangan.  Bagian pertama ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Apa yang kita inginkan dan bagaimana kita melakukannya </h2><br>  Di bagian pertama artikel, kami memperkenalkan <b>Fitur</b> , elemen utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MVICore</a> yang dapat digunakan kembali.  Mereka dapat memiliki struktur paling sederhana dan hanya menyertakan satu <b>Peredam</b> , atau mereka dapat menjadi alat yang berfungsi penuh untuk mengelola tugas, peristiwa, dan banyak lagi yang tidak sinkron. <br><br>  Setiap Fitur dapat dilacak - ada peluang untuk berlangganan perubahan dalam statusnya dan menerima pemberitahuan tentang hal itu.  Namun, Fitur dapat berlangganan ke sumber input.  Dan ini masuk akal, karena dengan dimasukkannya Rx dalam basis kode, kita sudah memiliki banyak objek dan langganan yang dapat diamati di berbagai tingkatan. <br><br>  Sehubungan dengan peningkatan jumlah komponen reaktif inilah saatnya untuk merenungkan apa yang kita miliki dan apakah mungkin untuk membuat sistem lebih baik. <br><a name="habracut"></a><br>  Kami harus menjawab tiga pertanyaan: <br><br><ol><li>  Elemen apa yang harus digunakan ketika menambahkan komponen reaktif baru? <br></li><li>  Apa cara termudah untuk mengelola langganan Anda? <br></li><li>  Apakah mungkin untuk mengabaikan manajemen siklus hidup / kebutuhan untuk menghapus langganan untuk menghindari kebocoran memori?  Dengan kata lain, dapatkah kita memisahkan ikatan komponen dari manajemen berlangganan? <br></li></ol><br>  Pada bagian artikel ini, kita akan melihat dasar-dasar dan manfaat membangun sistem menggunakan komponen reaktif dan melihat bagaimana Kotlin membantu dalam hal ini. <br><br><h2>  Elemen utama </h2><br>  Pada saat kami mulai mengerjakan desain dan standardisasi <b>Fitur</b> kami, kami telah mencoba berbagai pendekatan dan memutuskan bahwa <b>Fitur</b> tersebut akan dalam bentuk komponen reaktif.  Pertama, kami fokus pada antarmuka utama.  Pertama-tama, kami perlu menentukan jenis input dan output data. <br><br>  Kami beralasan sebagai berikut: <br><br><ul><li>  Mari kita tidak menciptakan kembali roda - mari kita lihat antarmuka apa yang sudah ada. <br></li><li>  Karena kita sudah menggunakan pustaka RxJava, masuk akal untuk merujuk ke antarmuka dasarnya. <br></li><li>  Jumlah antarmuka harus diminimalkan. <br></li></ul><br>  Akibatnya, kami memutuskan untuk menggunakan <b>ObservableSource &lt;T&gt;</b> untuk output dan <b>Konsumen &lt;T&gt;</b> untuk input.  Mengapa tidak <b>Teramati / Pengamat</b> , Anda bertanya.  <b>Observable</b> adalah kelas abstrak yang harus Anda warisi, dan <b>ObservableSource</b> adalah antarmuka yang Anda implementasikan yang sepenuhnya memenuhi kebutuhan untuk mengimplementasikan protokol reaktif. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Pengamat</b> , antarmuka pertama yang terlintas dalam pikiran, menerapkan empat metode: onSubscribe, onNext, onError, dan onComplete.  Dalam upaya menyederhanakan protokol sebanyak mungkin, kami lebih suka <b>Konsumen &lt;T&gt;</b> , yang menerima elemen baru menggunakan metode tunggal.  Jika kami memilih <b>Pengamat</b> , maka metode yang tersisa akan paling sering menjadi berlebihan atau bekerja secara berbeda (misalnya, kami ingin menyajikan kesalahan sebagai bagian dari <b>Negara</b> , dan bukan sebagai pengecualian, dan tentu saja tidak mengganggu aliran). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  Jadi, kami memiliki dua antarmuka, yang masing-masing berisi satu metode.  Sekarang kita dapat mengikat mereka dengan menandatangani <b>Konsumen &lt;T&gt;</b> ke <b>ObservableSource &lt;T&gt;</b> .  Yang terakhir hanya menerima instance dari <b>Pengamat &lt;T&gt;</b> , tetapi kami dapat membungkusnya dengan <b>Observable &lt;T&gt;</b> , yang berlangganan <b>Pelanggan &lt;T&gt;</b> : <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Untungnya, fungsi <i>.wrap (output)</i> tidak membuat objek baru jika <i>output</i> sudah menjadi <b>Observable &lt;T&gt;</b> ). <br><br>  Anda mungkin ingat bahwa komponen <b>Fitur</b> dari bagian pertama artikel menggunakan input data tipe <b>Wish</b> (sesuai dengan Intent dari Model-View-Intent) dan output dari tipe <b>Negara</b> , dan karena itu bisa di kedua sisi bundel: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Tautan antara <i>Konsumen</i> dan <i>Produsen ini</i> sudah terlihat cukup sederhana, tetapi ada cara yang bahkan lebih mudah di mana Anda tidak perlu membuat langganan secara manual atau membatalkannya. <br><br>  Memperkenalkan <b>Binder</b> . <br><br><h2>  Mengikat steroid </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MVICore</a> berisi kelas yang disebut <b>Binder</b> yang menyediakan API sederhana untuk mengelola langganan Rx dan memiliki sejumlah fitur keren. <br><br>  Mengapa itu dibutuhkan? <br><br><ul><li>  Buat ikatan dengan berlangganan input ke akhir pekan. <br></li><li>  Kemampuan untuk berhenti berlangganan pada akhir siklus hidup (ketika itu adalah konsep abstrak dan tidak ada hubungannya dengan Android). <br></li><li>  Bonus: <b>Binder</b> memungkinkan Anda untuk menambahkan objek perantara, misalnya, untuk logging atau debugging perjalanan waktu. <br></li></ul><br>  Alih-alih menandatangani secara manual, Anda dapat menulis ulang contoh di atas sebagai berikut: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Berkat Kotlin, semuanya terlihat sangat sederhana. <br><br>  Contoh-contoh ini berfungsi jika jenis input dan output sama.  Tetapi bagaimana jika tidak?  Dengan menerapkan fungsi ekstensi, kita dapat membuat transformasi otomatis: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Perhatikan sintaks: bunyinya hampir seperti kalimat normal (dan ini adalah alasan lain mengapa saya suka Kotlin).  Tetapi <b>Binder</b> tidak hanya digunakan sebagai gula sintaksis - juga bermanfaat bagi kita untuk menyelesaikan masalah dengan siklus hidup. <br><br><h2>  Buat Binder </h2><br>  Membuat instance terlihat lebih mudah: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  Tetapi dalam hal ini, Anda harus berhenti berlangganan secara manual, dan Anda harus menelepon <code>binder.dispose()</code> kapan pun diperlukan untuk menghapus langganan.  Ada cara lain: menyuntikkan instance siklus hidup ke dalam konstruktor.  Seperti ini: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Sekarang Anda tidak perlu khawatir tentang langganan - mereka akan dihapus pada akhir siklus hidup.  Pada saat yang sama, siklus hidup dapat diulang berkali-kali (seperti siklus mulai dan berhenti di Android UI) - dan <b>Binder</b> akan membuat dan menghapus langganan untuk Anda setiap waktu. <br><br><h2>  Dan apa itu siklus hidup? </h2><br>  Sebagian besar pengembang Android, melihat frasa "siklus hidup", mewakili siklus Aktivitas dan Fragmen.  Ya, <b>Binder</b> dapat bekerja dengan mereka, berhenti berlangganan di akhir siklus. <br><br>  Tapi ini hanya permulaan, karena Anda tidak menggunakan antarmuka Android <b>LifecycleOwner</b> dengan cara apa pun - <b>Binder</b> memiliki sendiri, lebih universal.  Ini pada dasarnya adalah aliran sinyal BEGIN / END: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  Anda bisa mengimplementasikan aliran ini menggunakan Observable (by mapping), atau cukup menggunakan kelas <b>ManualLifecycle</b> dari perpustakaan untuk lingkungan non-Rx (lihat persis di bawah). <br><br>  Bagaimana cara <b>kerja binder</b> ?  Menerima sinyal BEGIN, itu membuat langganan untuk komponen yang sebelumnya Anda konfigurasi ( <i>input / output</i> ), dan menerima sinyal AKHIR, menghapusnya.  Yang paling menarik adalah Anda bisa mulai dari awal lagi: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  Fleksibilitas dalam menetapkan kembali langganan ini sangat berguna ketika bekerja dengan Android, ketika ada beberapa siklus Start-Stop dan Resume-Pause, di samping Buat-Hancurkan yang biasa. <br><br><h2>  Android Binder Lifecycles </h2><br>  Ada tiga kelas di perpustakaan: <br><br><ul><li>  <i>BuatDestroyBinderLifecycle</i> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> adalah nilai yang dikembalikan oleh metode <code>getLifecycle()</code> , yaitu, <b>AppCompatActivity</b> , <b>AppCompatDialogFragment</b> , dll. Semuanya sangat sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Siklus hidup individu </h2><br>  Jangan berhenti di situ, karena kita tidak terikat dengan Android dengan cara apa pun.  Apa siklus hidup <b>pengikat</b> ?  Secara harfiah apa saja: misalnya, waktu pemutaran dialog atau waktu eksekusi beberapa tugas yang tidak sinkron.  Anda dapat, misalnya, ikat ke lingkup DI - dan kemudian langganan apa pun akan dihapus bersamanya.  Kebebasan penuh untuk bertindak. <br><br><ol><li>  Ingin langganan disimpan sebelum <b>Observable</b> mengirim item?  Konversi objek ini ke <b>Lifecycle</b> dan berikan ke <b>Binder</b> .  Terapkan kode berikut dalam fungsi <i>ekstensi</i> dan gunakan nanti: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  Ingin menjaga ikatan Anda sampai <b>Completable</b> selesai?  Tidak ada masalah - ini dilakukan dengan analogi dengan paragraf sebelumnya: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  Ingin beberapa kode non-Rx lainnya memutuskan kapan harus menghapus langganan?  Gunakan <b>ManualLifecycle</b> seperti dijelaskan di atas. <br></li></ol><br>  Bagaimanapun, Anda dapat meletakkan aliran reaktif ke aliran elemen <b>Siklus Hidup.</b> <b>Bahkan</b> , atau menggunakan <b>ManualLifecycle</b> jika Anda bekerja dengan kode non-Rx. <br><br><h2>  Tinjauan Umum Sistem </h2><br>  <b>Binder</b> menyembunyikan detail membuat dan mengelola langganan Rx.  Yang tersisa adalah gambaran umum singkat dan umum: "Komponen A berinteraksi dengan komponen B dalam lingkup C". <br><br>  Misalkan kita memiliki komponen reaktif berikut untuk layar saat ini: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  Kami ingin komponen yang akan terhubung dalam layar saat ini, dan kami tahu bahwa: <br><br><ul><li>  UIEvent dapat diumpankan langsung ke <b>AnalyticsTracker</b> ; <br></li><li>  UIEvent dapat diubah menjadi <b>Wish</b> for <b>Feature</b> ; <br></li><li>  <b>Negara</b> dapat diubah menjadi <b>Model</b> <b>View</b> untuk <b>Tampilan</b> . <br></li></ul><br>  Ini dapat diungkapkan dalam beberapa baris: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  Kami membuat meremas tersebut untuk menunjukkan interkoneksi komponen.  Dan karena kami pengembang menghabiskan lebih banyak waktu membaca kode daripada menulisnya, ikhtisar singkat seperti itu sangat berguna, terutama ketika jumlah komponen bertambah. <br><br><h2>  Kesimpulan </h2><br>  Kami melihat bagaimana <b>Binder</b> membantu dalam mengelola langganan Rx dan bagaimana <b>Binder</b> membantu Anda mendapatkan gambaran umum tentang sistem yang dibangun dari komponen reaktif. <br><br>  Dalam artikel berikut, kami akan menjelaskan bagaimana kami memisahkan komponen UI reaktif dari logika bisnis dan cara menambahkan objek perantara menggunakan <b>Binder</b> (untuk logging dan debugging perjalanan waktu).  Jangan beralih! <br><br>  Sementara itu, periksa perpustakaan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430550/">https://habr.com/ru/post/id430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430536/index.html">Merancang fungsi jendela diringkas menjadi satu unit dengan tingkat tumpang tindih yang diberikan</a></li>
<li><a href="../id430538/index.html">Apakah Anda membaca Scaladoc untuk metode pengumpulan yang "jelas"? Atau mengapa kemalasan tidak selalu baik</a></li>
<li><a href="../id430542/index.html">Buka webinar "Infrastruktur sebagai kode"</a></li>
<li><a href="../id430546/index.html">"Diyakini bahwa kode tersebut akan diganti oleh diagram UML, tetapi tidak perlu diuji": sebuah wawancara dengan Alexei Barantsev</a></li>
<li><a href="../id430548/index.html">Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 1. Evolusi pengendali interupsi</a></li>
<li><a href="../id430552/index.html">Startup of the day (September-Oktober 2018)</a></li>
<li><a href="../id430554/index.html">Google mematenkan sepatu VR yang bisa Anda jalani selamanya</a></li>
<li><a href="../id430556/index.html">GeekBrains Meluncurkan Kursus Pelatihan Manajer Produk</a></li>
<li><a href="../id430558/index.html">Cara penilaian bekerja di industri berbagi mobil. Bagian 1. Ikhtisar alat populer pada data nyata</a></li>
<li><a href="../id430560/index.html">Frontend, algoritme, dan possum Frederick. Kami menganalisis tugas-tugas dari kontes Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>