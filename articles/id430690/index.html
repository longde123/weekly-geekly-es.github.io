<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‡ğŸ¿ ğŸ¹ ğŸ˜‰ Pengecualian deterministik dan penanganan kesalahan dalam â€œC ++ of the futureâ€ ğŸ ğŸ‘°ğŸ½ ğŸˆ²</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sungguh aneh bahwa di Habrt belum ada proposal kasar untuk standar C ++ yang disebut "Zero-overhead deterministic exceptionions". Memperbaiki kelalaia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengecualian deterministik dan penanganan kesalahan dalam â€œC ++ of the futureâ€</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Sungguh aneh bahwa di Habrt belum ada proposal kasar untuk standar C ++ yang disebut "Zero-overhead deterministic exceptionions".  Memperbaiki kelalaian yang mengganggu ini. </p><br><p>  Jika Anda khawatir tentang overhead pengecualian, atau Anda harus mengkompilasi kode tanpa dukungan pengecualian, atau hanya ingin tahu apa yang akan terjadi dengan penanganan kesalahan di C ++ 2b (referensi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting terbaru</a> ), saya meminta cat.  Anda sedang menunggu untuk memeras segala sesuatu yang sekarang dapat ditemukan pada topik, dan beberapa jajak pendapat. </p><a name="habracut"></a><br><p>  Diskusi di bawah ini akan dilakukan tidak hanya tentang pengecualian statis, tetapi juga tentang proposal terkait dengan standar, dan tentang segala macam cara lain untuk menangani kesalahan.  Jika Anda pergi ke sini untuk melihat sintaksnya, maka ini dia: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Jika jenis kesalahan tertentu tidak penting / tidak diketahui, maka Anda cukup menggunakan <code>throws</code> dan <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Senang tahu </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> dan <code>std::expected</code> </h3><br><p>  Mari kita putuskan bahwa kesalahan yang berpotensi muncul dalam fungsi tidak "fatal" cukup untuk melemparkan pengecualian untuk itu.  Secara tradisional, informasi kesalahan dikembalikan menggunakan parameter keluar.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Filesystem TS</a> menawarkan sejumlah fitur serupa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Jangan membuang pengecualian karena fakta bahwa file itu tidak ditemukan?) Namun demikian, pemrosesan kode kesalahan rumit dan rentan terhadap bug.  Kode kesalahan mudah dilupakan untuk diperiksa.  Gaya kode modern <a href="">melarang</a> penggunaan parameter output, sebagai gantinya, disarankan untuk mengembalikan struktur yang berisi seluruh hasil. </p><br><p>  Untuk beberapa waktu sekarang, Boost telah menawarkan solusi yang elegan untuk menangani kesalahan "tidak fatal" tersebut, yang dalam skenario tertentu dapat terjadi dalam ratusan program yang benar: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  Jenis yang <code>expected</code> mirip dengan <code>variant</code> , tetapi menyediakan antarmuka yang nyaman untuk bekerja dengan "hasil" dan "kesalahan".  Secara default, hasil yang <code>expected</code> disimpan dalam yang <code>expected</code> .  Implementasi <code>file_size</code> mungkin terlihat seperti ini: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Jika penyebab kesalahan tidak menarik bagi kami, atau kesalahan hanya dapat terdiri dari "tidak adanya" hasilnya, maka <code>optional</code> dapat digunakan: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  Di C ++ 17 dari Boost, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsional</a> sampai ke std (tanpa dukungan untuk <code>optional&lt;T&amp;&gt;</code> );  di C ++ 20, mereka dapat menambahkan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diharapkan</a> (ini hanya Proposal, terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">RamzesXI</a> untuk koreksi). </p><br><h3 id="contracts">  Kontrak </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kontrak</a> (jangan dikacaukan dengan konsep) adalah cara baru untuk menerapkan batasan pada parameter fungsi, ditambahkan dalam C ++ 20.  3 anotasi ditambahkan: </p><br><ul><li>  <strong>mengharapkan</strong> parameter fungsi pemeriksaan </li><li>  <strong>memastikan</strong> memeriksa nilai kembali fungsi (menganggapnya sebagai argumen) </li><li>  <strong>menegaskan</strong> - pengganti yang beradab untuk pernyataan makro </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Anda dapat mengonfigurasi pelanggaran kontrak: </p><br><ul><li>  Disebut Perilaku Tidak Terdefinisi, atau </li><li>  Ia memeriksa dan memanggil pengguna keluar, setelah itu <code>std::terminate</code> </li></ul><br><p>  Tidak mungkin untuk terus menjalankan program setelah pelanggaran kontrak, karena kompiler menggunakan jaminan dari kontrak untuk mengoptimalkan kode fungsi.  Jika ada keraguan sedikit pun bahwa kontrak akan dipenuhi, ada baiknya menambahkan cek tambahan. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  Pustaka <code>&lt;system_error&gt;</code> , ditambahkan dalam C ++ 11, memungkinkan Anda untuk membakukan penanganan kode kesalahan dalam program Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: error_code</a> terdiri dari kode kesalahan bertipe <code>int</code> dan sebuah pointer ke objek beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas</a> turunan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: error_category</a> .  Objek ini, pada kenyataannya, memainkan peran tabel fungsi virtual dan menentukan perilaku <code>std::error_code</code> diberikan. </p><br><p>  Untuk membuat <code>std::error_code</code> Anda, Anda harus mendefinisikan <code>std::error_category</code> turunan dan menerapkan metode virtual, yang paling penting di antaranya adalah: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Anda juga harus membuat variabel global untuk <code>std::error_category</code> .  Kesalahan penanganan menggunakan error_code + diharapkan terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  Penting bahwa dalam <code>std::error_code</code> nilai 0 berarti tidak ada kesalahan.  Jika ini bukan kasus untuk kode kesalahan Anda, maka sebelum Anda mengubah kode kesalahan sistem ke <code>std::error_code</code> , Anda harus mengganti kode 0 dengan SUCCESS, dan sebaliknya. </p><br><p>  Semua kode kesalahan sistem dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">errc</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">system_category</a> .  Jika pada tahap tertentu penerusan kode kesalahan secara manual menjadi terlalu suram, maka Anda selalu dapat membungkus kode kesalahan dalam <code>std::system_error</code> dan membuangnya. </p><br><h3 id="destructive-move--trivially-relocatable">  Langkah destruktif / Dapat dipindahkan secara sepele </h3><br><p>  Biarkan Anda perlu membuat kelas objek lain yang memiliki beberapa sumber daya.  Kemungkinan besar, Anda ingin membuatnya tidak dapat disalin, tetapi dapat dipindah-pindahkan, karena tidak nyaman untuk bekerja dengan objek yang tidak dapat dipindahkan (sebelum C ++ 17, mereka tidak dapat dikembalikan dari suatu fungsi). </p><br><p>  Tapi inilah masalahnya: dalam hal apa pun, objek yang dipindahkan perlu dihapus.  Oleh karena itu, diperlukan kondisi "pindah-dari" khusus, yaitu objek "kosong" yang tidak menghapus apa pun.  Ternyata setiap kelas C ++ harus memiliki keadaan kosong, yaitu, tidak mungkin untuk membuat kelas dengan invarian (jaminan) kebenaran, dari konstruktor ke destruktor.  Sebagai contoh, tidak mungkin untuk membuat kelas <code>open_file</code> benar dari sebuah file yang terbuka sepanjang masa pakainya.  Sangat aneh untuk mengamati ini dalam salah satu dari sedikit bahasa yang secara aktif menggunakan RAII. </p><br><p>  Masalah lain adalah memusatkan perhatian objek lama ketika bergerak menambahkan overhead: mengisi <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> bisa hingga 2 kali lebih lambat dari <code>std::vector&lt;T*&gt;</code> karena tumpukan zeroing dari pointer lama ketika bergerak , diikuti oleh penghapusan boneka. </p><br><p>  Pengembang C ++ telah lama menjilat Rust, di mana destruktor tidak dipanggil pada objek yang dipindahkan.  Fitur ini disebut Destructive move.  Sayangnya, Proposal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Trivially relocatable</a> tidak menawarkan untuk menambahkannya ke C ++.  Tetapi masalah overhead akan terpecahkan. </p><br><p>  Kelas dianggap dapat dipindahkan secara Trivial jika dua operasi: memindahkan dan menghapus objek lama sama dengan memcpy dari objek lama ke yang baru.  Objek lama tidak dihapus, penulis menyebutnya "jatuhkan di lantai". </p><br><p>  Suatu tipe dapat dipindahkan dari sudut pandang kompiler jika salah satu dari kondisi berikut (rekursif) benar: </p><br><ol><li>  Dapat dipindahkan secara sepele + diremehkan secara sepele (mis. <code>int</code> atau struktur POD) </li><li>  Ini adalah kelas yang ditandai dengan atribut <code>[[trivially_relocatable]]</code> </li><li>  Ini adalah kelas yang semua anggotanya dapat direlokasi Trivially. </li></ol><br><p>  Anda dapat menggunakan informasi ini dengan <code>std::uninitialized_relocate</code> , yang mengeksekusi move init + delete dengan cara biasa, atau dipercepat jika memungkinkan.  Disarankan untuk menandai sebagai <code>[[trivially_relocatable]]</code> sebagian besar tipe perpustakaan standar, termasuk <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> dengan ini, Proposal akan hilang. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  Apa yang salah dengan pengecualian sekarang? </h2><br><p>  Mekanisme pengecualian C ++ dikembangkan pada tahun 1992.  Berbagai opsi implementasi telah diusulkan.  Dari jumlah tersebut, mekanisme tabel pengecualian dipilih yang menjamin tidak adanya overhead untuk jalur utama pelaksanaan program.  Karena sejak saat penciptaan mereka, diasumsikan bahwa <em>pengecualian harus dilemparkan sangat jarang</em> . </p><br><p>  Kekurangan pengecualian dinamis (mis. Reguler): </p><br><ol><li>  Dalam kasus pengecualian yang dilemparkan, biaya overhead rata-rata sekitar 10.000-100.000 siklus CPU, dan dalam kasus terburuk, dapat mencapai urutan milidetik </li><li>  Ukuran file biner meningkat 15-38% </li><li>  Ketidakcocokan dengan antarmuka pemrograman C </li><li>  Pengecualian dukungan lemparan implisit dalam semua fungsi kecuali kecuali.  Pengecualian dapat dilemparkan hampir di mana saja dalam program, bahkan di mana penulis fungsi tidak mengharapkannya </li></ol><br><p>  Karena kekurangan ini, ruang lingkup pengecualian sangat terbatas.  Ketika pengecualian tidak dapat diterapkan: </p><br><ol><li>  Di mana determinisme penting, yaitu, di mana tidak dapat diterima bahwa kode "kadang-kadang" bekerja 10, 100, 1000 kali lebih lambat dari biasanya </li><li>  Ketika mereka tidak didukung di ABI, misalnya, dalam mikrokontroler </li><li>  Ketika sebagian besar kode ditulis dalam C </li><li>  Di perusahaan dengan banyak kode lawas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Gaya Google</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt</a> ).  Jika ada setidaknya satu fungsi non-pengecualian-aman dalam kode, maka menurut hukum kekejaman, pengecualian akan dilemparkan melalui itu cepat atau lambat dan membuat bug </li><li>  Di perusahaan mempekerjakan programmer yang tidak tahu tentang keamanan pengecualian </li></ol><br><p>  Menurut survei, di tempat kerja 52% (!) Pengembang, pengecualian dilarang oleh aturan perusahaan. </p><br><p>  Tetapi pengecualian merupakan bagian integral dari C ++!  Dengan menyertakan <code>-fno-exceptions</code> , pengembang kehilangan kemampuan untuk menggunakan bagian penting dari pustaka standar.  Ini lebih lanjut menghasut perusahaan untuk menanam "perpustakaan standar" mereka sendiri dan, ya, menciptakan kelas string mereka sendiri. </p><br><p>  Tapi ini bukan akhirnya.  Pengecualian adalah satu-satunya cara standar untuk membatalkan pembuatan objek di konstruktor dan melemparkan kesalahan.  Ketika dimatikan, kekejian seperti inisialisasi dua fase muncul.  Operator juga tidak dapat menggunakan kode kesalahan, sehingga diganti dengan fungsi seperti <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposal: pengecualian untuk masa depan </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Mekanisme transfer pengecualian baru </h3><br><p>  Herb Sutter dalam P709 menjelaskan mekanisme transfer pengecualian baru.  Pada prinsipnya, fungsi mengembalikan <code>std::expected</code> , alih-alih sebagai pembeda terpisah dari tipe <code>bool</code> , yang bersama-sama dengan penyelarasan akan menempati hingga 8 byte pada stack, sedikit informasi ini ditransmisikan dalam beberapa cara yang lebih cepat, misalnya, untuk Membawa Bendera. </p><br><p>  Fungsi yang tidak menyentuh CF (kebanyakan dari mereka) akan mendapatkan kesempatan untuk menggunakan pengecualian statis secara gratis - baik dalam kasus pengembalian normal, dan dalam kasus melempar pengecualian!  Fungsi yang dipaksa untuk menyimpan dan mengembalikannya akan menerima overhead minimal, dan itu masih akan lebih cepat dari <code>std::expected</code> dan kode kesalahan biasa. </p><br><p>  Pengecualian statis terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Dalam versi alternatif, diusulkan untuk mewajibkan kata kunci <code>try</code> dalam ekspresi yang sama dengan panggilan fungsi <code>throws</code> : <code>try i + safe_divide(j, k)</code> .  Ini akan mengurangi jumlah kasus menggunakan fungsi <code>throws</code> dalam kode yang tidak aman untuk pengecualian menjadi hampir nol.  Dalam kasus apa pun, tidak seperti pengecualian dinamis, IDE akan dapat menyoroti ekspresi yang melemparkan pengecualian. </p><br><p>  Fakta bahwa pengecualian yang dilemparkan tidak disimpan secara terpisah, tetapi diletakkan langsung di tempat nilai yang dikembalikan, memberlakukan pembatasan pada jenis pengecualian.  Pertama, itu harus direlokasi sepele.  Kedua, ukurannya tidak boleh terlalu besar (tetapi bisa berupa <code>std::unique_ptr</code> ), jika tidak semua fungsi akan menyimpan lebih banyak ruang di stack. </p><br><h3 id="status_code">  status_code </h3><br><p>  Pustaka <code>&lt;system_error2&gt;</code> , yang dikembangkan oleh Niall Douglas, akan berisi <code>status_code&lt;T&gt;</code> - "baru, lebih baik" <code>error_code</code> .  Perbedaan utama dari <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - jenis templat yang dapat digunakan untuk menyimpan hampir semua kode kesalahan yang dapat dibayangkan (bersama dengan penunjuk ke <code>status_code_category</code> ), tanpa menggunakan pengecualian statis </li><li>  <code>T</code> harus dengan mudah dipindahkan dan dapat disalin (yang terakhir, IMHO, tidak harus wajib).  Saat menyalin dan menghapus, fungsi virtual dipanggil dari <code>status_code_category</code> </li><li>  <code>status_code</code> tidak hanya dapat menyimpan data kesalahan, tetapi juga informasi tambahan tentang operasi yang berhasil diselesaikan </li><li>  Fungsi "virtual" <code>code.message()</code> tidak mengembalikan <code>std::string</code> , tetapi <code>string_ref</code> adalah jenis string yang agak berat, yang merupakan " <code>std::string_view</code> " yang mungkin memiliki "virtual".  Di sana Anda dapat <code>string_view</code> atau <code>string</code> , atau <code>std::shared_ptr&lt;string&gt;</code> , atau cara gila lainnya untuk memiliki string.  Niall mengklaim bahwa <code>#include &lt;string&gt;</code> akan membuat tajuk <code>&lt;system_error2&gt;</code> "berat" </li></ol><br><p>  Selanjutnya, <code>errored_status_code&lt;T&gt;</code> dimasukkan - pembungkus <code>status_code&lt;T&gt;</code> dengan konstruktor berikut: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  kesalahan </h3><br><p>  Tipe eksepsi default ( <code>throws</code> tanpa tipe), serta tipe dasar pengecualian yang digunakan semua yang lain (seperti <code>std::exception</code> ), adalah <code>error</code> .  Ini didefinisikan sesuatu seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Artinya, <code>error</code> adalah "error" <code>status_code</code> , di mana nilai ( <code>value</code> ) ditempatkan dalam 1 pointer.  Karena mekanisme <code>status_code_category</code> memastikan penghapusan, perpindahan, dan penyalinan yang benar, secara teoritis, struktur data apa pun dapat disimpan dalam <code>error</code> .  Dalam praktiknya, ini akan menjadi salah satu opsi berikut: </p><br><ol><li>  Integer (int) </li><li>  <code>std::exception_handle</code> , mis. penunjuk ke pengecualian dinamis yang dilemparkan </li><li>  <code>status_code_ptr</code> , mis. <code>unique_ptr</code> ke <code>status_code&lt;T&gt;</code> sewenang-wenang <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  Masalahnya adalah kasus 3 tidak direncanakan untuk memberikan kesempatan untuk membawa <code>error</code> kembali ke <code>status_code&lt;T&gt;</code> .  Satu-satunya hal yang dapat Anda lakukan adalah mendapatkan <code>message()</code> <code>status_code&lt;T&gt;</code> dikemas <code>status_code&lt;T&gt;</code> .  Untuk mendapatkan kembali nilai <code>error</code> , lemparkan itu sebagai pengecualian dinamis (!), Lalu tangkap dan bungkus <code>error</code> .  Secara umum, Niall percaya bahwa hanya kode kesalahan dan pesan string yang harus disimpan dalam <code>error</code> , yang cukup untuk semua program. </p><br><p>  Untuk membedakan berbagai jenis kesalahan, disarankan untuk menggunakan operator perbandingan "virtual": </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  Menggunakan beberapa blok tangkapan atau <code>dynamic_cast</code> untuk memilih jenis pengecualian akan gagal! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaksi dengan pengecualian dinamis </h3><br><p>  Suatu fungsi mungkin memiliki salah satu dari spesifikasi berikut: </p><br><ul><li>  <code>noexcept</code> : tidak melempar pengecualian </li><li>  <code>throws(E)</code> : hanya melempar pengecualian statis </li><li>  (tidak ada): hanya melempar pengecualian dinamis </li></ul><br><p>  <code>throws</code> menyiratkan <code>noexcept</code> .  Jika pengecualian dinamis dilemparkan dari fungsi "statis", maka itu dibungkus <code>error</code> .  Jika pengecualian statis dilemparkan dari fungsi "dinamis", maka itu dibungkus dalam pengecualian <code>status_error</code> .  Contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Pengecualian dalam C?! </h3><br><p>  Proposal memberikan tambahan pengecualian untuk salah satu standar C di masa depan, dan pengecualian ini akan kompatibel dengan ABI dengan pengecualian statis C ++.  Struktur yang mirip dengan <code>std::expected&lt;T, U&gt;</code> , pengguna harus mendeklarasikan secara independen, meskipun redundansi dapat dihapus menggunakan makro.  Sintaks terdiri dari (untuk kesederhanaan, kami akan menganggap ini) kata kunci gagal, gagal, tangkap. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Pada saat yang sama, dalam C ++ juga dimungkinkan untuk memanggil fungsi <code>fails</code> dari C, mendeklarasikannya dalam blok <code>extern C</code> .  Dengan demikian, dalam C ++ akan ada seluruh galaksi kata kunci untuk bekerja dengan pengecualian: </p><br><ul><li>  <code>throw()</code> - dihapus dalam C ++ 20 </li><li>  <code>noexcept</code> - specifier fungsi, fungsi tidak membuang pengecualian dinamis </li><li>  <code>noexcept(expression)</code> - <code>noexcept(expression)</code> fungsi, fungsi tidak membuang pengecualian dinamis yang disediakan </li><li>  <code>noexcept(expression)</code> - Apakah ekspresi membuang pengecualian dinamis? </li><li>  <code>throws(E)</code> - specifier fungsi, fungsi melempar pengecualian statis </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - fungsi yang diimpor dari C melempar pengecualian statis </li></ul><br><p>  Jadi, di C ++ mereka membawa (atau lebih tepatnya, mengirim) keranjang alat baru untuk penanganan kesalahan.  Selanjutnya, muncul pertanyaan logis: </p><br><h2 id="kogda-chto-ispolzovat">  Kapan menggunakan apa? </h2><br><h3 id="napravlenie-v-celom">  Arah umum </h3><br><p>  Kesalahan dibagi menjadi beberapa tingkatan: </p><br><ul><li>  Kesalahan pemrogram.  Diproses menggunakan kontrak.  Mereka mengarah pada pengumpulan log dan penghentian program sesuai dengan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gagal-cepat</a> .  Contoh: null pointer (saat ini tidak valid);  pembagian dengan nol;  kesalahan alokasi memori tidak diramalkan oleh programmer. </li><li>  Kesalahan fatal diberikan oleh programmer.  Diusir jutaan kali lebih jarang daripada pengembalian normal dari suatu fungsi, yang membuat penggunaan pengecualian dinamis dibenarkan untuk mereka.  Biasanya, dalam kasus seperti itu, Anda harus memulai kembali seluruh subsistem program atau memberikan kesalahan saat melakukan operasi.  Contoh: koneksi tiba-tiba terputus dengan basis data;  kesalahan alokasi memori yang disediakan oleh programmer. </li><li>  Kesalahan yang dapat dipulihkan saat <em>sesuatu</em> mencegah fungsi menyelesaikan tugasnya, tetapi fungsi panggilan mungkin tahu apa yang harus dilakukan dengannya.  Ditangani oleh pengecualian statis.  Contoh: bekerja dengan sistem file;  kesalahan input / output (IO) lainnya;  Data pengguna salah  <code>vector::at()</code> . </li><li>  Fungsi berhasil menyelesaikan tugasnya, meskipun dengan hasil yang tidak terduga.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Contoh: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  Di perpustakaan standar, yang paling dapat diandalkan untuk sepenuhnya meninggalkan penggunaan pengecualian dinamis untuk membuat kompilasi "tanpa pengecualian" legal. </p><br><h3 id="errno">  errno </h3><br><p>  Fungsi yang menggunakan <code>errno</code> untuk bekerja dengan cepat dan mudah dengan kode kesalahan C dan C ++ harus diganti dengan <code>fails(int)</code> dan <code>throws(std::errc)</code> , masing-masing.  Untuk beberapa waktu, versi lama dan baru dari fungsi perpustakaan standar akan hidup berdampingan, maka yang lama akan dinyatakan usang. </p><br><h3 id="out-of-memory">  Kehabisan memori </h3><br><p>  Kesalahan alokasi memori ditangani oleh kait global <code>new_handler</code> , yang dapat: </p><br><ol><li>  Menghilangkan kekurangan memori dan melanjutkan eksekusi </li><li>  Lempar pengecualian </li><li>  Program kerusakan </li></ol><br><p>  Sekarang <code>std::bad_alloc</code> dilemparkan secara default.  Disarankan untuk memanggil <code>std::terminate()</code> secara default.  Jika Anda membutuhkan perilaku lama, gantilah pawang dengan yang Anda butuhkan di awal <code>main()</code> . </p><br><p>  Semua fungsi yang ada dari perpustakaan standar akan menjadi <code>noexcept</code> dan akan crash program ketika <code>std::bad_alloc</code> .  Pada saat yang sama, API baru seperti <code>vector::try_push_back</code> akan ditambahkan, yang memungkinkan kesalahan alokasi memori. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Pengecualian <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> melaporkan pelanggaran terhadap prasyarat fungsi.  Model kesalahan baru harus menggunakan kontrak sebagai gantinya.  Jenis pengecualian yang terdaftar <strong>tidak</strong> akan ditinggalkan, tetapi hampir semua kasus penggunaannya di perpustakaan standar akan diganti oleh <code>[[expects: â€¦]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Status Proposal Saat Ini </h2><br><p>  Proposal sekarang dalam keadaan draft.  Ini sudah banyak berubah, dan masih bisa banyak berubah.  Beberapa perkembangan tidak berhasil dipublikasikan, jadi API yang diusulkan <code>&lt;system_error2&gt;</code> tidak sepenuhnya relevan. </p><br><p>  Proposal dijelaskan dalam 3 dokumen: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P709</a> - dokumen asli dari lambang Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1095</a> - Pengecualian Ditentukan dalam Visi Niall Douglas, Beberapa Saat Berubah, Ditambahkan Kompatibilitas Bahasa C </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1028</a> - API dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi uji</a> <code>std::error</code> </li></ol><br><p>  Saat ini tidak ada kompiler yang mendukung pengecualian statis.  Oleh karena itu, tolok ukur mereka belum memungkinkan. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430690/">https://habr.com/ru/post/id430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430680/index.html">Menulis prosesor dan lingkungan yang sederhana untuknya</a></li>
<li><a href="../id430682/index.html">Tiga tahun proyek mikrosatelit bulan: tahap-tahap pertumbuhan</a></li>
<li><a href="../id430684/index.html">Memindai Kontrak Ethereum Langsung untuk Kesalahan Tidak Terkirim-Kirim. Bagian 2</a></li>
<li><a href="../id430686/index.html">Tinjauan: Mesin pemotong waterjet pertama WAZER</a></li>
<li><a href="../id430688/index.html">Transfer data melalui animasi QR ke Gomobile dan GopherJS</a></li>
<li><a href="../id430692/index.html">Rekayasa Sosial dengan Perangkat Lunak Universal Windows Platform (APPX)</a></li>
<li><a href="../id430694/index.html">Panduan singkat untuk mempelajari C ++: apa, kapan dan apa yang harus dibuat</a></li>
<li><a href="../id430700/index.html">Sistem terpadu untuk merekam tayangan film online akan mulai berfungsi di Rusia</a></li>
<li><a href="../id430704/index.html">Bagaimana Teknologi Kecerdasan Buatan Membantu Aviasales Tumbuh: Tujuh Contoh</a></li>
<li><a href="../id430706/index.html">Teori Evolusi Baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>