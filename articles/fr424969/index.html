<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèΩ ‚òÅÔ∏è üå≤ Guide Node.js, partie 9: Utilisation du syst√®me de fichiers üõÉ üèúÔ∏è ü¶ó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, dans la neuvi√®me partie de la traduction du didacticiel Node.js, nous parlerons de l'utilisation des fichiers. En particulier, nous parle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide Node.js, partie 9: Utilisation du syst√®me de fichiers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424969/">  Aujourd'hui, dans la neuvi√®me partie de la traduction du didacticiel Node.js, nous parlerons de l'utilisation des fichiers.  En particulier, nous parlerons des modules fs et path - des descripteurs de fichiers, des chemins de fichiers, de l'obtention d'informations sur les fichiers, de leur lecture et de leur √©criture, de l'utilisation des r√©pertoires. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Nous vous conseillons de lire] Autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales et mise en route</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript, V8, quelques astuces de d√©veloppement</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H√©bergement, REPL, travailler avec la console, les modules</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers npm, package.json et package-lock.json</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm et npx</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucle d'√©v√©nements, pile d'appels, temporisateurs</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 8: Protocoles HTTP et WebSocket</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, partie 9: utilisation du syst√®me de fichiers</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Node.js, Partie 10: Modules standard, flux, bases de donn√©es, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PDF complet du guide Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Utilisation des descripteurs de fichiers dans Node.js</font> </h2><br>  Avant de pouvoir interagir avec des fichiers situ√©s dans le syst√®me de fichiers de votre serveur, vous devez obtenir un descripteur de fichier. <br><br>  Le descripteur peut √™tre obtenu en utilisant la m√©thode asynchrone <code>open()</code> du module <code>fs</code> pour ouvrir le fichier: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.open(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, fd)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>fd -    })</code> </pre> <br>  Notez le deuxi√®me param√®tre, <code>r</code> , utilis√© lors de l'appel de la m√©thode <code>fs.open()</code> .  Il s'agit d'un indicateur qui indique au syst√®me que le fichier est en cours de lecture.  Voici quelques autres indicateurs qui sont souvent utilis√©s lors de l'utilisation de cette m√©thode et d'autres m√©thodes: <br><br><ul><li>  <code>r+</code> - ouvre le fichier en lecture et en √©criture. </li><li>  <code>w+</code> - ouvrez le fichier pour la lecture et l'√©criture en positionnant le pointeur de flux au d√©but du fichier.  Si le fichier n'existe pas, il est cr√©√©. </li><li>  <code>a</code> - ouvrez le fichier pour l'√©criture en pla√ßant le pointeur de flux √† la fin du fichier.  Si le fichier n'existe pas, il est cr√©√©. </li><li>  <code>a+</code> - ouvrez le fichier en lecture et en √©criture en positionnant le pointeur de flux √† la fin du fichier.  Si le fichier n'existe pas, il est cr√©√©. </li></ul><br>  Les fichiers peuvent √™tre ouverts √† l'aide de la m√©thode synchrone <code>fs.openSync()</code> qui, au lieu de fournir un descripteur de fichier dans le rappel, le renvoie: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fd = fs.openSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Apr√®s avoir re√ßu le descripteur √† l'aide de l'une des m√©thodes ci-dessus, vous pouvez effectuer les op√©rations n√©cessaires avec lui. <br><br><h2>  <font color="#3AC1EF">Donn√©es de fichier</font> </h2><br>  Chaque fichier est associ√© √† un ensemble de donn√©es; vous pouvez examiner ces donn√©es √† l'aide de Node.js.  En particulier, cela peut √™tre fait en utilisant la m√©thode <code>stat()</code> du module <code>fs</code> . <br><br>  Cette m√©thode est appel√©e, en lui passant le chemin d'acc√®s au fichier, et apr√®s que Node.js ait re√ßu les informations n√©cessaires sur le fichier, il appellera le rappel pass√© √† la m√©thode <code>stat()</code> .  Voici √† quoi √ßa ressemble: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      `<span class="javascript"><span class="javascript">stats</span></span>` })</code> </pre> <br>  Node.js a la capacit√© de r√©cup√©rer de mani√®re synchrone les informations de fichier.  Avec cette approche, le thread principal est bloqu√© jusqu'√† ce que les propri√©t√©s du fichier soient obtenues: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stats = fs.statSync (<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Les informations sur le fichier tomberont dans la constante des <code>stats</code> .  Quelle est cette information?  En fait, l'objet correspondant nous fournit un grand nombre de propri√©t√©s et de m√©thodes utiles: <br><br><ul><li>  Les <code>.isFile()</code> et <code>.isDirectory()</code> permettent respectivement de savoir si le fichier √©tudi√© est un fichier ou un r√©pertoire normal. </li><li>  La m√©thode <code>.isSymbolicLink()</code> vous permet de savoir si un fichier est un lien symbolique. </li><li>  La taille du fichier peut √™tre trouv√©e √† l'aide de la propri√©t√© <code>.size</code> . </li></ul><br>  Il existe d'autres m√©thodes ici, mais ce sont les plus utilis√©es.  Voici comment les utiliser: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.stat(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } stats.isFile() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">true</span></span> stats.isDirectory() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.isSymbolicLink() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span> stats.size <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1024000</span></span> //= <span class="hljs-number"><span class="hljs-number">1</span></span>MB })</code> </pre> <br><h2>  <font color="#3AC1EF">Chemins de fichiers dans Node.js et le module de chemin</font> </h2><br>  Le chemin d'acc√®s au fichier est l'adresse de l'endroit dans le syst√®me de fichiers o√π il se trouve. <br><br>  Sous Linux et macOS, le chemin pourrait ressembler √† ceci: <br><br><pre> <code class="hljs mel">/users/flavio/<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>.txt</code> </pre> <br>  Sous Windows, les chemins semblent un peu diff√©rents: <br><br><pre> <code class="hljs tex">C:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">flavio</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span></span>.txt</code> </pre> <br>  Il convient de noter les diff√©rences de formats d'enregistrement de chemin lors de l'utilisation de diff√©rents syst√®mes d'exploitation, compte tenu du syst√®me d'exploitation utilis√© pour d√©ployer le serveur Node.js. <br><br>  Node.js dispose d'un module de <code>path</code> standard con√ßu pour fonctionner avec les chemins de fichiers.  Avant d'utiliser ce module dans un programme, il doit √™tre connect√©: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Obtention des informations sur le chemin du fichier</font> </h3><br>  Si vous avez un chemin d'acc√®s au fichier, puis en utilisant les capacit√©s du module de <code>path</code> , vous pouvez, sous une forme pratique pour la perception et le traitement ult√©rieur, trouver des d√©tails sur ce chemin d'acc√®s.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs pgsql">const notes = <span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.dirname(notes) // /users/flavio <span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes) // notes.txt <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes) // .txt</code> </pre> <br>  Ici, dans la ligne des <code>notes</code> , le chemin du fichier est stock√©.  Les m√©thodes suivantes du module de <code>path</code> ont √©t√© utilis√©es pour analyser le <code>path</code> : <br><br><ul><li>  <code>dirname()</code> - retourne le r√©pertoire parent du fichier. </li><li>  <code>basename()</code> - renvoie le nom du fichier. </li><li>  <code>extname()</code> - renvoie l'extension du fichier. </li></ul><br>  Vous pouvez trouver le nom du fichier sans l'extension en appelant la m√©thode <code>.basename()</code> et en lui passant le deuxi√®me argument repr√©sentant l'extension: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.basename(notes, <span class="hljs-type"><span class="hljs-type">path</span></span>.extname(notes)) //notes</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçTravailler avec des chemins de fichiers</font> </h3><br>  Plusieurs parties du chemin peuvent √™tre combin√©es √† l'aide de la m√©thode <code>path.join()</code> : <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br>  Vous pouvez trouver le chemin absolu du fichier en fonction du chemin d'acc√®s relatif √† celui-ci √† l'aide de la m√©thode <code>path.resolve()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      </code> </pre> <br>  Dans ce cas, Node.js ajoute simplement <code>/flavio.txt</code> au chemin menant au r√©pertoire de travail actuel.  Si, lors de l'appel de cette m√©thode, vous passez un autre param√®tre repr√©sentant le chemin d'acc√®s au dossier, la m√©thode l'utilise comme base pour d√©terminer le chemin absolu: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/Users/flavio/tmp/flavio.txt'</span></span>      </code> </pre> <br>  Si le chemin d'acc√®s pass√© en tant que premier param√®tre commence par une barre oblique, cela signifie qu'il s'agit d'un chemin absolu. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'/etc'</span></span>, <span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'/etc/flavio.txt'</span></span></code> </pre> <br>  Voici une autre m√©thode utile - <code>path.normalize()</code> .  Il vous permet de trouver le vrai chemin d'acc√®s au fichier en utilisant le chemin d'acc√®s qui contient les qualificatifs de chemin d'acc√®s relatifs comme un point ( <code>.</code> ), Deux points ( <code>..</code> ) ou deux barres obliques: <br><br><pre> <code class="hljs mel">path.<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// /users/test.txt</span></span></code> </pre> <br>  Les m√©thodes <code>resolve()</code> et <code>normalize()</code> ne v√©rifient pas l'existence d'un r√©pertoire.  Ils trouvent simplement le chemin en fonction des donn√©es qui leur sont transmises. <br><br><h2>  <font color="#3AC1EF">Lecture de fichiers dans Node.js</font> </h2><br>  La fa√ßon la plus simple de lire des fichiers dans Node.js est d'utiliser la m√©thode <code>fs.readFile()</code> , en lui passant le chemin d'acc√®s au fichier et le rappel, qui sera appel√© avec le transfert des donn√©es du fichier (ou l'objet d'erreur): <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br>  Si n√©cessaire, vous pouvez utiliser la version synchrone de cette m√©thode - <code>fs.readFileSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br>  Par d√©faut, le codage <code>utf8</code> est utilis√© lors de la lecture des fichiers, mais le codage peut √©galement √™tre d√©fini ind√©pendamment en passant le param√®tre appropri√© √† la m√©thode. <br><br>  Les <code>fs.readFile()</code> et <code>fs.readFileSync()</code> lisent l'int√©gralit√© du contenu du fichier en m√©moire.  Cela signifie que travailler avec des fichiers volumineux √† l'aide de ces m√©thodes affectera s√©rieusement la consommation de m√©moire de votre application et affectera ses performances.  Si vous devez travailler avec de tels fichiers, il est pr√©f√©rable d'utiliser des flux. <br><br><h2>  <font color="#3AC1EF">√âcriture de fichiers dans Node.js</font> </h2><br>  Dans Node.js, il est plus facile d'√©crire des fichiers en utilisant la m√©thode <code>fs.writeFile()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, (err) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  Il existe √©galement une version synchrone de la m√™me m√©thode - <code>fs.writeFileSync()</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = require(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = fs.writeFileSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content) <span class="hljs-comment"><span class="hljs-comment">//   } catch (err) { console.error(err) }</span></span></code> </pre> <br>  Ces m√©thodes, par d√©faut, remplacent le contenu des fichiers existants.  Vous pouvez modifier leur comportement standard en utilisant l'indicateur appropri√©: <br><br><pre> <code class="hljs coffeescript">fs.writeFile(<span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>, content, { flag: <span class="hljs-string"><span class="hljs-string">'a+'</span></span> }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {})</code> </pre> <br>  Les drapeaux peuvent √™tre utilis√©s ici, que nous avons d√©j√† √©num√©r√©s dans la section sur les descripteurs.  Des d√©tails sur les drapeaux peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Joindre des donn√©es √† un fichier</font> </h2><br>  La m√©thode <code>fs.appendFile()</code> (et sa version synchrone, <code>fs.appendFileSync()</code> ) est commod√©ment utilis√©e pour attacher des donn√©es √† la fin du fichier: <br><br><pre> <code class="hljs coffeescript">const content = <span class="hljs-string"><span class="hljs-string">'Some content!'</span></span> fs.appendFile(<span class="hljs-string"><span class="hljs-string">'file.log'</span></span>, content, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>! })</code> </pre> <br><h2>  <font color="#3AC1EF">√Ä propos de l'utilisation des threads</font> </h2><br>  Ci-dessus, nous avons d√©crit des m√©thodes qui, lors de l'√©criture dans un fichier, √©crivent la totalit√© des donn√©es qui y sont transf√©r√©es, apr√®s quoi, si leurs versions synchrones sont utilis√©es, elles renvoient le contr√¥le au programme, et si des versions asynchrones sont utilis√©es, elles appellent des rappels.  Si cet √©tat de fait ne vous convient pas, il serait pr√©f√©rable d'utiliser des flux. <br><br><h2>  <font color="#3AC1EF">Utilisation de r√©pertoires dans Node.js</font> </h2><br>  Le module <code>fs</code> fournit au d√©veloppeur de nombreuses m√©thodes pratiques qui peuvent √™tre utilis√©es pour travailler avec des r√©pertoires. <br><br><h3>  <font color="#3AC1EF">‚ñçV√©rifiez l'existence du dossier</font> </h3><br>  Afin de v√©rifier si le r√©pertoire existe et si Node.js peut y acc√©der, compte tenu des autorisations, vous pouvez utiliser la m√©thode <code>fs.access()</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçCr√©er un nouveau dossier</font> </h3><br>  Pour cr√©er de nouveaux dossiers, vous pouvez utiliser les <code>fs.mkdir()</code> et <code>fs.mkdirSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderName = <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fs.existsSync(dir)){   fs.mkdirSync(dir) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçLire le contenu du dossier</font> </h3><br>  Pour lire le contenu d'un dossier, vous pouvez utiliser les <code>fs.readdir()</code> et <code>fs.readdirSync()</code> .  Cet exemple lit le contenu du dossier, c'est-√†-dire les informations sur les fichiers et les sous-r√©pertoires qu'il contient et renvoie leurs chemins d'acc√®s relatifs: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folderPath = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.readdirSync(folderPath)</code> </pre> <br>  Voici comment obtenir le chemin d'acc√®s complet au fichier: <br><br><pre> <code class="hljs swift">fs.readdirSync(folderPath).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(fileName =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(folderPath, fileName) }</code> </pre> <br>  Les r√©sultats peuvent √™tre filtr√©s afin d'obtenir uniquement les fichiers et les exclure de la sortie du r√©pertoire: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isFile = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.lstatSync(fileName).isFile() } fs.readdirSync(folderPath).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileName</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.join(folderPath, fileName)).filter(isFile) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Renommer le dossier</font> </h3><br>  Vous pouvez utiliser les <code>fs.rename()</code> et <code>fs.renameSync()</code> pour renommer le dossier.  Le premier param√®tre est le chemin du dossier actuel, le second est un nouveau: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Vous pouvez renommer le dossier √† l'aide de la m√©thode synchrone <code>fs.renameSync()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/roger'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Supprimer le dossier</font> </h3><br>  Pour supprimer un dossier, vous pouvez utiliser les <code>fs.rmdir()</code> ou <code>fs.rmdirSync()</code> .  Il convient de noter que la suppression d'un dossier dans lequel se trouve quelque chose est une t√¢che un peu plus compliqu√©e que la suppression d'un dossier vide.  Si vous devez supprimer de tels dossiers, utilisez le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fs-extra</a> , qui est tr√®s populaire et bien pris en charge.  Il remplace le module <code>fs</code> , √©largissant ses capacit√©s. <br><br>  La m√©thode <code>remove()</code> du package <code>fs-extra</code> peut supprimer des dossiers qui ont d√©j√† quelque chose. <br><br>  Vous pouvez installer ce module comme suit: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> fs-extra</code> </pre> <br>  Voici un exemple de son utilisation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs-extra'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> folder = <span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span> fs.remove(folder, err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Ses m√©thodes peuvent √™tre utilis√©es sous forme de promesses: <br><br><pre> <code class="hljs coffeescript">fs.remove(folder).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> }).<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  La construction async / wait est √©galement acceptable: <br><br><pre> <code class="hljs matlab">async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fs</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span><span class="hljs-function">   // } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catch</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">folder</span></span></span><span class="hljs-function"> = '/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Users</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flavio</span></span></span><span class="hljs-function">' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(folder)</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Module Fs</font> </h2><br>  Ci-dessus, nous avons d√©j√† rencontr√© quelques m√©thodes du module <code>fs</code> qui sont utilis√©es lors de l'utilisation du syst√®me de fichiers.  En fait, il contient beaucoup plus de choses utiles.  Rappelons qu'il n'a pas besoin d'√™tre install√©, pour l'utiliser dans le programme, il suffit de le connecter: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>)</code> </pre> <br>  Apr√®s cela, vous aurez acc√®s √† ses m√©thodes, parmi lesquelles on note les suivantes, dont certaines que vous connaissez d√©j√†: <br><br><ul><li>  <code>fs.access()</code> : v√©rifie l'existence d'un fichier et la possibilit√© d'y acc√©der en fonction des autorisations. </li><li>  <code>fs.appendFile()</code> : <code>fs.appendFile()</code> donn√©es √† un fichier.  Si le fichier n'existe pas, il sera cr√©√©. </li><li>  <code>fs.chmod()</code> : modifie les autorisations pour un fichier donn√©.  M√©thodes similaires: <code>fs.lchmod()</code> , <code>fs.fchmod()</code> . </li><li>  <code>fs.chown()</code> : change le propri√©taire et le groupe pour le fichier donn√©.  M√©thodes similaires: <code>fs.fchown()</code> , <code>fs.lchown()</code> . </li><li>  <code>fs.close()</code> : ferme le descripteur de fichier. </li><li>  <code>fs.copyFile()</code> : copie le fichier. </li><li>  <code>fs.createReadStream()</code> : cr√©e un flux pour lire un fichier. </li><li>  <code>fs.createWriteStream()</code> : cr√©e un flux d'√©criture de fichier. </li><li>  <code>fs.link()</code> : cr√©e un nouveau lien dur vers le fichier. </li><li>  <code>fs.mkdir()</code> : cr√©e un nouveau r√©pertoire. </li><li>  <code>fs.mkdtemp()</code> : cr√©e un r√©pertoire temporaire. </li><li>  <code>fs.open()</code> : ouvre un fichier. </li><li>  <code>fs.readdir()</code> : lit le contenu d'un r√©pertoire. </li><li>  <code>fs.readFile()</code> : lit le contenu d'un fichier.  M√©thode similaire: <code>fs.read()</code> . </li><li>  <code>fs.readlink()</code> : lit la valeur d'un lien symbolique. </li><li>  <code>fs.realpath()</code> : r√©sout le chemin relatif du fichier construit √† l'aide de caract√®res <code>.</code>  et <code>..</code> , sur le chemin complet. </li><li>  <code>fs.rename()</code> : renomme un fichier ou un dossier. </li><li>  <code>fs.rmdir()</code> : supprime le dossier. </li><li>  <code>fs.stat()</code> : retourne les informations du fichier.  M√©thodes similaires: <code>fs.fstat()</code> , <code>fs.lstat()</code> . </li><li>  <code>fs.symlink()</code> : cr√©e un nouveau lien symbolique vers le fichier. </li><li>  <code>fs.truncate()</code> : tronque le fichier √† la longueur sp√©cifi√©e.  M√©thode similaire: <code>fs.ftruncate()</code> . </li><li>  <code>fs.unlink()</code> : supprime un fichier ou un lien symbolique. </li><li>  <code>fs.unwatchFile()</code> : d√©sactive la surveillance des modifications de fichiers. </li><li>  <code>fs.utimes()</code> : modifie l'horodatage d'un fichier.  M√©thode similaire: <code>fs.futimes()</code> . </li><li>  <code>fs.watchFile()</code> : permet de surveiller les modifications des fichiers.  M√©thode similaire: <code>fs.watch()</code> . </li><li>  <code>fs.writeFile()</code> : √©crit des donn√©es dans un fichier.  M√©thode similaire: <code>fs.write()</code> . </li></ul><br>  Une caract√©ristique int√©ressante du module <code>fs</code> est le fait que toutes ses m√©thodes, par d√©faut, sont asynchrones, mais il existe √©galement des versions synchrones d'entre elles, dont les noms sont obtenus en ajoutant le mot <code>Sync</code> aux noms des m√©thodes asynchrones. <br><br>  Par exemple: <br><br><ul><li> <code>fs.rename()</code> </li> <li> <code>fs.renameSync()</code> </li> <li> <code>fs.write()</code> </li> <li> <code>fs.writeSync()</code> </li> </ul><br>  L'utilisation de m√©thodes synchrones affecte s√©rieusement le fonctionnement du programme. <br><br>  Node.js 10 fournit un support exp√©rimental pour ces API bas√©es sur des promesses. <br><br>  Explorez la m√©thode <code>fs.rename()</code> .  Voici une version asynchrone de cette m√©thode utilisant des rappels: <br><br><pre> <code class="hljs coffeescript">const fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) fs.rename(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> })</code> </pre> <br>  Lors de l'utilisation de sa version synchrone, la construction <code>try/catch</code> est utilis√©e pour g√©rer les erreurs: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fs.renameSync(<span class="hljs-string"><span class="hljs-string">'before.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'after.json'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// } catch (err) { console.error(err) }</span></span></code> </pre> <br>  La principale diff√©rence entre ces options d'utilisation de cette m√©thode est que dans le second cas, le script sera bloqu√© jusqu'√† la fin de l'op√©ration de fichier. <br><br><h2>  <font color="#3AC1EF">Module de chemin</font> </h2><br>  Le module de chemin, dont nous avons √©galement parl√© de certaines de ses fonctionnalit√©s, contient de nombreux outils utiles qui vous permettent d'interagir avec le syst√®me de fichiers.  Comme d√©j√† mentionn√©, vous n'avez pas besoin de l'installer, car il fait partie de Node.js.  Pour l'utiliser, il suffit de le connecter: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>)</code> </pre> <br>  La propri√©t√© <code>path.sep</code> de ce module fournit le caract√®re utilis√© pour s√©parer les segments de chemin ( <code>\</code> sous Windows et <code>/</code> sous Linux et macOS), et la propri√©t√© <code>path.delimiter</code> donne le caract√®re utilis√© pour s√©parer plusieurs chemins ( <code>;</code> sous Windows et <code>:</code> sous Linux et macOS). <br><br>  Consid√©rons et illustrons quelques m√©thodes du module de <code>path</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçpath.basename ()</font> </h3><br>  Renvoie le dernier fragment du chemin.  En passant le deuxi√®me param√®tre √† cette m√©thode, vous pouvez supprimer l'extension de fichier. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) //something <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>) //something.txt <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).basename(<span class="hljs-string"><span class="hljs-string">'/test/something.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>) //something</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.dirname ()</font> </h3><br>  Renvoie la partie du chemin qui repr√©sente le nom du r√©pertoire: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).dirname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/ /test</span></span><span class="hljs-regexp"><span class="hljs-regexp">/something</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.extname ()</font> </h3><br>  Renvoie la partie du chemin qui repr√©sente l'extension du fichier: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).extname(<span class="hljs-string"><span class="hljs-string">'/test/something/file.txt'</span></span>) // <span class="hljs-string"><span class="hljs-string">'.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.isAbsolute ()</font> </h3><br>  Renvoie vrai si le chemin est absolu: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'/test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).isAbsolute(<span class="hljs-string"><span class="hljs-string">'./test/something'</span></span>) // <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.join ()</font> </h3><br>  Connecte plusieurs parties du chemin: <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'flavio'</span></span> require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'users'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-string"><span class="hljs-string">'notes.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/users/flavio/notes.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.normalize ()</font> </h3><br>  Essayer de comprendre le vrai chemin en fonction du chemin qui contient les caract√®res utilis√©s pour construire des chemins relatifs comme <code>.</code>  , <code>..</code> et <code>//</code> : <br><br><pre> <code class="hljs mel">require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-string"><span class="hljs-string">'/users/flavio/..//test.txt'</span></span>) <span class="hljs-comment"><span class="hljs-comment">///users/test.txt</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.parse ()</font> </h3><br>  Convertit un chemin d'acc√®s en un objet dont les propri√©t√©s repr√©sentent des parties individuelles du chemin d'acc√®s: <br><br><ul><li>  <code>root</code> : le r√©pertoire racine. </li><li>  <code>dir</code> : chemin du fichier √† partir du r√©pertoire racine </li><li>  <code>base</code> : nom et extension du fichier. </li><li>  <code>name</code> : <code>name</code> fichier. </li><li>  <code>ext</code> : extension de fichier. </li></ul><br>  Voici un exemple utilisant cette m√©thode: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).parse(<span class="hljs-string"><span class="hljs-string">'/users/test.txt'</span></span>)</code> </pre> <br>  √Ä la suite de son travail, l'objet suivant est obtenu: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">root</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, dir: <span class="hljs-string"><span class="hljs-string">'/users'</span></span>, base: <span class="hljs-string"><span class="hljs-string">'test.txt'</span></span>, ext: <span class="hljs-string"><span class="hljs-string">'.txt'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'test'</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.relative ()</font> </h3><br>  Prend, comme arguments, 2 fa√ßons.  Renvoie le chemin relatif du premier chemin au second, en fonction du r√©pertoire de travail actuel: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'test.txt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>).relative(<span class="hljs-string"><span class="hljs-string">'/Users/flavio'</span></span>, <span class="hljs-string"><span class="hljs-string">'/Users/flavio/something/test.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'something/test.txt'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçpath.resolve ()</font> </h3><br>  Recherche le chemin absolu en fonction du chemin relatif qui lui a √©t√© transmis: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">path</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'flavio.txt'</span></span>) //<span class="hljs-string"><span class="hljs-string">'/Users/flavio/flavio.txt'</span></span>      .</code> </pre> <br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Aujourd'hui, nous avons examin√© les modules <code>fs</code> et <code>path</code> Node.js qui sont utilis√©s pour travailler avec le syst√®me de fichiers.  Dans la prochaine partie de cette s√©rie, sur laquelle elle se termine, nous discuterons du syst√®me d'exploitation, des <code>events</code> , des modules <code>http</code> , parlerons de l'utilisation des flux et des syst√®mes de gestion de base de donn√©es dans Node.js. <br><br>  <b>Chers lecteurs!</b>  Quels packages npm utilisez-vous lorsque vous travaillez avec le syst√®me de fichiers dans Node.js? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424969/">https://habr.com/ru/post/fr424969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424957/index.html">G√©n√©ration d'images √† partir de texte √† l'aide d'AttnGAN</a></li>
<li><a href="../fr424961/index.html">MTA-STS pour Postfix</a></li>
<li><a href="../fr424963/index.html">Financement Zuckerberg: cr√©er ensemble des outils pour la science</a></li>
<li><a href="../fr424965/index.html">D√©veloppement d'applications React √† l'aide de ReasonReact</a></li>
<li><a href="../fr424967/index.html">Raccourcis JavaScript pour les d√©butants</a></li>
<li><a href="../fr424971/index.html">Habrokast "Sunset Manually" # 1. Essayer de mettre en place un environnement pour d√©velopper un jouet pour Windows</a></li>
<li><a href="../fr424973/index.html">D√©tection de visages sur vid√©o: Raspberry Pi et Neural Compute Stick</a></li>
<li><a href="../fr424975/index.html">Profondeurs SIEM: corr√©lations pr√™tes √† l'emploi. Partie 2. Le sch√©ma de donn√©es comme reflet du mod√®le ¬´monde¬ª</a></li>
<li><a href="../fr424977/index.html">Apprendre des erreurs: optimiser les applications sur l'App Store et Google Play</a></li>
<li><a href="../fr424979/index.html">Orme. Confortable et maladroit. Http, Task</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>