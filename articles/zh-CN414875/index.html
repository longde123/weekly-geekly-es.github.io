<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐗 👨🏿‍🌾 🚉 Kubernetes容器集成取代Docker并投入生产 👨‍🏭 🖕🏿 👨‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意事项 佩雷夫 ：我们已经为Kubernetes写了不止一次有关容器化和其他运行时的文章。 该新出版物是对最近发布的关于集装箱开发的一个重要里程碑的公告的翻译，该公告已发布在Kubernetes项目的官方博客上。 这些文字是由Google和IBM的员工编写的，它们（当然，还有Docker Inc....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes容器集成取代Docker并投入生产</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/414875/"><img src="https://habrastorage.org/webt/bw/-e/lu/bw-elulxcq_ts7y7ln0cjnwyxng.png"><br><br>  <i><b>注意事项</b></i>  <i><b>佩雷夫</b></i>  <i>：我们已经为Kubernetes写了不止一次有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器化</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他</a>运行时的文章。</i>  <i>该新出版物是对最近发布的关于集装箱开发的一个重要里程碑的公告的翻译，该公告已发布在Kubernetes项目的官方博客上。</i>  <i>这些文字是由Google和IBM的员工编写的，它们（当然，还有Docker Inc.）也为改善容器化做出了巨大贡献。</i> <br><br> 在博客的较早部分（在注记着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Containered为Kubernetes带来了更多的容器运行时选项）中，</a>我们介绍了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Containerd</a>与Kubernetes集成的Alpha版本。 在接下来的6个月的开发过程中，集成已经公开可用！ 这意味着现在您可以将<a href="">容器化的1.1</a>用作生产中Kubernetes集群中容器的运行时。 <br><br>  Containerd 1.1与Kubernetes 1.10及更高版本一起使用，支持所有Kubernetes功能。 在Kubernetes测试基础架构中，Google Cloud Platform上的容器集成测试的覆盖范围已与与Docker的集成相同（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试仪表板</a> ）。 <a name="habracut"></a><br><br><blockquote>  “我们很高兴看到集装箱运输迅速达到这一重要里程碑。 在阿里云，我们从一开始就开始积极使用容器化，并且由于其对简单性和可靠性的重视，使得容器化成为我们无服务器Kubernetes产品中的默认容器引擎，这对性能和稳定性提出了很高的要求。 毫无疑问，集装箱运输将成为集装箱时代的主要动力，并带动创新的发展。”  <i>-阿里云的专职工程师Xinwei</i> </blockquote><br><h2> 架构上的改进 </h2><br> 与Kubernetes集成容器的架构发生了两次变化。 它的每个进化步骤均稳定并提高了堆叠效率。 <br><br><h3> 容器式1.0-CRI容器（已存在） </h3><br><img src="https://habrastorage.org/webt/8q/n4/2o/8qn42ofstq8qrrucp5txrrb2wze.png"><br><br> 在containerd 1.0中， <i>Kubelet</i>和containerd之间的交互需要cri-containerd守护进程<i>（我们在本文结尾处写了它- <b>大约Transl。</b> ）</i> 。 该守护程序处理来自<i>Kubelet的</i>对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器运行时接口（CRI）</a>的<i>请求，</i>并使用容器来正确管理容器和容器映像。 与Docker CRI实现（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dockershim</a> ）相比，此方法消除了堆栈中的另一个链接- <i>请参见上图</i> 。 <br><br> 但是，cri-containerd和containerd 1.0是通过GRPC进行交互的两个单独的守护程序。 该捆绑软件中的附加守护程序使用户在了解设备和部署过程中都变得很困难，并且还产生了不必要的交互开销。 <br><br><h3> 容器1.1-CRI插件（当前版本） </h3><br><img src="https://habrastorage.org/webt/sc/hl/uw/schluwslee8y_n4kihjgseh0kpw.png"><br><br> 在容器1.1中，cri-containerd守护进程已重做到容器CRI插件中。 此插件内置在容器1.1中，默认情况下启用。 与cri-containerd不同，该插件通过直接调用必要的功能与容器交互。 新架构使集成更加稳定和高效，从堆栈中消除了另一个链接（GRPC）。 现在，可以在Kubernetes中直接使用容器化的1.1，并且不再需要cri-containerd守护程序。 <br><br><h2> 性能表现 </h2><br> 容器1.1的主要目标之一是提高性能。 在启动时间和守护程序使用的资源方面进行了优化。 <br><br> 以下结果是对容器化1.1和Docker 18.03 CE的比较。 集成容器1.1使用内置的CRI插件，而Docker 18.03 CE的集成与dockershim一起使用。 结果是使用Kubernetes节点性能基准生成的，该基准是<a href="">K8s节点</a>的<a href="">e2e测试的一部分</a> 。 大多数比较数据可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">节点性能仪表板上</a>公开获得。 <br><br><h3> 炉床启动延迟 </h3><br>  <i>105个pod批处理启动基准测试的</i>结果表明，容器1.1集成与使用dockershim的Docker 18.03 CE相比，启动pod的延迟更少（越小越好）。 <br><br><img src="https://habrastorage.org/webt/1e/20/re/1e20rewi6uzg9ixrkmfsybifidk.png"><br><br><h3>  CPU和内存 </h3><br> 在空闲状态下，具有105个炉膛的容器式1.1集成比与dockershim的Docker 18.03 CE集成消耗更少的处理器和内存。 结果可能会有所不同，具体取决于节点上启动的炉床数量-选择了105炉床数量，因为 现在，默认值是节点上自定义炉床的最大值。 <br><br> 从下图可以看出，容器式1.1与<i>Kubelet的</i>集成消耗的CPU减少了30.89％，RSS内存（驻留集大小）减少了11.30％，容器运行时消耗的RSS内存也减少了12.78％ 。 <br><br><img src="https://habrastorage.org/webt/ic/w6/rf/icw6rfbsd1rqn6byqbzosaalkim.png"><br><br><h3>  <i>译者的加法</i> </h3><br>  <i>值得关注的是，另一个替代解决方案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRI-O</a>正在继续开发。</i>  <i>特别是在这些天的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2018年日本开源峰会上</a> ，NTT的一名员工发表了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一份报告</a> ，对现有容器的可执行环境进行了广泛的比较。</i>  <i>这是他比较性能的一张幻灯片：</i> <br><br><img src="https://habrastorage.org/webt/q8/vv/zf/q8vvzfa4zw7ydge80hhj_higkhi.png"><br><br><h2> 关键 </h2><br> 容器运行时控制台界面（CLI）是用于识别系统和应用程序中问题的有用工具。 当在Kubernetes中将Docker用作容器环境时，系统管理员有时会去Kubernetes站点运行Docker命令并收集有关系统和/或应用程序的信息。 例如，他们可以使用<code>docker ps</code>和<code>docker inspect</code>检查进程的状态，使用<code>docker images</code>获取节点上图像的列表，使用<code>docker info</code>获取容器的运行时配置，等等。 <br><br> 对于与Dockershim等容器化和所有其他CRI兼容的环境，我们建议使用<i>crictl</i>作为Docker控制台命令的CLI替代方法，以分析Kubernetes节点上托管的Pod，容器和容器映像上的问题。 <br><br>  <i>crictl</i>是一种实用程序，提供与Docker CLI类似的功能，并且在与CRI兼容的容器的所有运行时环境中<i>均能</i>很好地工作。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes-incubator / cri-tools</a>存储库中找到它； 当前版本是<a href="">cri-tools v1.11.0</a> <i>（该版本已在3天前针对当前发行版进行了修复，而不是原始文章中指出的<a href="">v1.0.0-beta.1</a> ， <b>大约是transl。</b> ）</i> 。 尽管<i>crictl</i>实用程序的设计类似于Docker CLI，为用户提供了一个简单的过渡，但它并不是完整的副本。 以下是一些重要的区别。 <br><br><h3> 限制使用：crictl是故障排除工具 </h3><br>  <i>crictl不能替代docker</i>或<code>kubectl</code> -它的使用仅限于问题识别和分析的范围。  Docker控制台界面提供了丰富的命令集，使其成为非常有用的开发工具。 但是，这不是在Kubernetes节点上进行故障排除的最佳选择。 某些Docker命令（例如docker <code>docker network</code>和docker <code>docker build</code> ）对Kubernetes无效，而某些（例如docker named）可以破坏一切。  <i>crictl</i>的目的是提供足够的命令来识别在生产环境中可以安全使用的节点上的问题。 <br><br><h3>  Kubernetes重点 </h3><br>  <i>crictl</i>在Kubernetes世界中提供了更易理解的容器视图。  Docker控制台界面无法与基本的Kubernetes概念一起使用，例如在（pod）和命名空间（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">namespace</a> ）下，这阻止了容器和炉膛的可视化表示<i>（这个问题的重要性是真实的，在监控环境中已经存在，我们最近在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本报告中</a>谈到了- <b>注意。perev。</b> ）</i> 一个这样的示例是<code>docker ps</code>显示了晦涩的Docker容器的长名称，暂停容器列表以及应用程序容器： <br><br><img src="https://habrastorage.org/webt/4w/ne/cs/4wnecsys4wdvacswvpxcfgmhtj8.png"><br><br> 但是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">暂停容器</a>是炉床实现的一部分，其中每个炉床都使用一个这样的容器。 当显示属于炉膛的容器时，不应显示它们。 <br><br> 相比之下，crictl是为Kubernetes创建的。 该实用程序为炉膛和容器提供了不同的命令集。 例如， <code>crictl pods</code>显示有关<code>crictl pods</code>信息，而<code>crictl ps</code>仅显示有关应用程序容器的信息。 所有数据都在表格视图中格式化： <br><br><img src="https://habrastorage.org/webt/fq/su/ck/fqsuckdyowdo74u-u88okijpjsk.png"><br><br><img src="https://habrastorage.org/webt/iy/xg/tf/iyxgtfzobswe9woyeay9lqylwsy.png"><br><br> 另一个示例-在<code>crictl pods</code>有一个参数<code>--namespace</code> ，它允许通过Kubernetes中定义的名称空间过滤pod： <br><br><img src="https://habrastorage.org/webt/ib/gq/3u/ibgq3udmdsf_wbjdw5lto57ckqa.png"><br><br> 有关如何在容器中使用crictl的更多信息，请参见此处： <br><br><ul><li>  <a href="">文献资料</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示视频在asciinema</a> 。 </li></ul><br><h2> 但是Docker引擎呢？ </h2><br> 我们经常听到以下问题：“切换到容器意味着我不能再使用Docker引擎了吗？”，对此的简短回答是“否”。 <br><br>  Docker Engine是基于容器构建的。 下一版本的Docker Community Edition（Docker CE）将使用容器化版本1.1。 因此，它将具有内置的默认CRI插件并启用。 这意味着用户将有机会继续在其他典型场景下使用Docker引擎，并且能够配置Kubernetes以使用Docker引擎随附的基础容器，并且该容器在同一主机上同时被Docker引擎使用。 看一下下面的架构图，展示Docker Engine和<i>Kubelet</i>如何使用相同的容器： <br><br><img src="https://habrastorage.org/webt/qj/f2/r2/qjf2r2vn_j4odysnyxytokycz9u.png"><br><br> 由于<i>Kubelet</i>和Docker Engine都使用了<i>containerd</i> ，因此选择与containerd集成的用户不仅将获得Kubernetes的所有新功能，性能和稳定性的提高，还可以选择使用Docker Engine来满足其他需求。 <br><br> 容器中的<a href="">命名空间</a>机制可确保<i>Kubelet</i>和Docker Engine无法访问它们未创建的容器和映像。 这意味着它们不会互相干扰，以及： <br><br><ul><li> 输入docker <code>docker ps</code>用户将不会看到在Kubernetes中创建的容器。 为此使用<code>crictl ps</code> 。 相反，用户将不会在Kubernetes或<code>crictl ps</code>命令上看到在Docker CLI中创建的容器。  <code>crictl create</code>和<code>crictl run</code>仅用于故障排除。 不建议在生产节点上使用<code>crictl</code>手动运行炉<code>crictl</code>或容器。 </li><li> 输入docker <code>docker images</code>用户将看不到来自Kubernetes的图像。 为此，请使用<code>crictl images</code>命令。 相反，Kubernetes将看不到docker pull，docker <code>docker load</code>和<code>docker build</code>命令创建的图像。 为此，如果要加载映像，请使用<code>crictl pull</code>命令以及<code><a href="">ctr</a> cri load</code> 。 </li></ul><br><h2> 总结 </h2><br><ul><li> 容器1.1具有本机CRI支持。  Kubernetes可以直接使用它。 </li><li> 容器化的1.1准备生产。 </li><li> 容器1.1在容器启动时间和系统资源利用率方面具有良好的性能。 </li><li>  crictl是一个控制台（CLI）实用程序，用于与容器1.1和其他符合CRI的容器的运行时环境进行通信，以识别节点上的问题。 </li><li>  Docker CE的下一个稳定版本将包含Containerd 1.1。 在非Kubernetes的情况下，用户可以选择继续使用Docker，并配置Kubernetes使用Docker的基础容器。 </li></ul><br> 我们要感谢来自Google，IBM，Docker，ZTE，ZJU的每个人以及为这一切做出了贡献并使之成为可能的个人开发人员！ <br><br> 有关容器1.1的更改的详细列表，请参见<a href="">发行说明</a> 。 <br><br><h2> 如何尝试 </h2><br> 设置Kubernetes集群以使用容器化作为默认运行时的说明： <br><br><ul><li> 对于GCE上的集群，使用<code>kube-up.sh</code>引发<code>kube-up.sh</code> ; </li><li> 在<a href="">这里</a>使用Ansible和kubeadm安装许多节点的集群; </li><li> 在Google Cloud中从头开始创建集群-请参阅“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes的艰辛路</a> ”； </li><li> 从tarball档案库进行手动安装; </li><li> 使用LinuxKit在本地虚拟机上进行安装- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 </li></ul><br><h2> 如何贡献 </h2><br>  Containered CRI插件-GitHub上的一个开源项目，它是containerd的一部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/containerd/cri</a> 。 欢迎所有提议的更改，包括意见，建议，更正的形式。 该开发人员入门<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指南</a>是进行更改的良好起点。 <br><br><h2> 译者的PS </h2><br> 另请参阅我们的博客： <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRI-O-Docker的替代品，用于在Kubernetes中启动容器</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker为什么要做Moby并与Kubernetes集成？”</a>  “; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">四个CNCF在KubeCon 2017上发布了有关Kubernetes的1.0版和重要公告</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么我们需要容器，以及为什么将其与Docker分开</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Moby项目的本质是什么？为什么moby / moby突然成为主要的Docker存储库？</a>  ” </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414875/">https://habr.com/ru/post/zh-CN414875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414865/index.html">iMaterialist家具挑战赛或50副椅子</a></li>
<li><a href="../zh-CN414867/index.html">ThinkingHome.Migrator版本的.NET Core平台上的数据库架构迁移</a></li>
<li><a href="../zh-CN414869/index.html">消失的框架</a></li>
<li><a href="../zh-CN414871/index.html">火星上的沙尘暴达到了行星级，甚至好奇心也受到影响</a></li>
<li><a href="../zh-CN414873/index.html">IDisposable-您的妈妈没有谈论释放资源。 第一部分</a></li>
<li><a href="../zh-CN414877/index.html">普通相机的不寻常镜头或如何停止思考焦点</a></li>
<li><a href="../zh-CN414879/index.html">为什么在3D打印机中使用2台挤出机？</a></li>
<li><a href="../zh-CN414881/index.html">有点后台VK</a></li>
<li><a href="../zh-CN414883/index.html">回忆以一种新的方式听起来：BBC更新了RemArc项目的声音档案</a></li>
<li><a href="../zh-CN414885/index.html">我们处理统一法律实体国家注册簿中的错误和“拐杖”-法律实体国家注册簿</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>