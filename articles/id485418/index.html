<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ³ â›´ï¸ PHPUnit. "Bagaimana cara menguji controller sialanku", atau menguji keraguan ğŸ•¢ ğŸ° ğŸ™Š</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. 



 Ya, ini adalah pos lain tentang topik pengujian. Tampaknya di sini sudah mungkin untuk membahas? Semua yang membutuhkannya - mereka me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Bagaimana cara menguji controller sialanku", atau menguji keraguan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Hai, Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="gambar"><br><br>  Ya, ini adalah pos lain tentang topik pengujian.  Tampaknya di sini sudah mungkin untuk membahas?  Semua yang membutuhkannya - mereka menulis tes, siapa yang tidak membutuhkannya - mereka tidak menulis, semua orang senang!  Faktanya adalah bahwa sebagian besar posting tentang pengujian unit memiliki ... bagaimana menyinggung siapa pun ... contoh bodoh!  Tidak, sungguh!  Hari ini saya akan mencoba memperbaikinya.  Saya minta kucing. <br><a name="habracut"></a><br>  Maka, pencarian cepat pada topik pengujian hanya menemukan banyak artikel, yang dalam jumlah besar dibagi menjadi dua kategori: <br><br>  1) Kebahagiaan seorang copywriter.  Pertama kita melihat pengantar yang panjang, kemudian sejarah pengujian unit di Rusia Kuno, lalu sepuluh peretasan dengan tes, dan pada akhirnya, sebuah contoh.  Dengan pengujian kode seperti ini: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Dan saya tidak bercanda sekarang.  Saya benar-benar melihat artikel dengan "kalkulator" sebagai panduan belajar.  Ya, ya, saya mengerti bahwa untuk memulainya perlu menyederhanakan segalanya, abstraksi, bolak-balik ... Tapi di sinilah semuanya berakhir!  Dan kemudian menyelesaikan burung hantu, seperti yang mereka katakan <br><br>  2) Contoh-contoh yang terlalu canggih.  Dan mari kita menulis tes, dan menjejalkannya ke Gitlab CI, dan kemudian kita akan memperbaikinya secara otomatis jika tes lulus, dan kita akan menerapkan PHP Infection ke tes, tetapi kami akan menghubungkan semuanya ke Hudson.  Dan seterusnya dalam gaya itu.  Tampaknya bermanfaat, tetapi tampaknya itu sama sekali tidak apa yang Anda cari.  Tetapi Anda hanya ingin sedikit meningkatkan stabilitas proyek Anda.  Dan semua kontinuitas ini - yah, tidak sekaligus. <br><br>  Akibatnya, orang ragu, "Tetapi apakah saya membutuhkannya."  Saya, pada gilirannya, ingin mencoba menjelaskan dengan lebih jelas tentang pengujian.  Dan segera lakukan reservasi - saya seorang pengembang, saya bukan penguji.  Saya yakin bahwa saya sendiri tidak tahu banyak, dan kata pertama saya dalam hidup saya bukanlah kata "mok".  Saya bahkan belum pernah bekerja di TDD!  Tapi saya tahu pasti bahwa bahkan tingkat keterampilan saya saat ini telah memungkinkan saya untuk menutup beberapa proyek dengan tes, dan tes ini sudah menangkap selusin bug.  Dan jika itu membantu saya, maka itu bisa membantu orang lain.  Beberapa bug yang tertangkap akan sulit ditangkap secara manual. <br><br>  Untuk mulai dengan, program pendidikan singkat dalam format tanya jawab: <br><br>  T: Apakah saya harus menggunakan semacam kerangka kerja?  Bagaimana jika saya memiliki Yii?  Bagaimana jika Kohana?  Bagaimana jika% one_more_framework_name%? <br>  A: Tidak, PHPUnit adalah kerangka kerja pengujian independen, Anda bahkan dapat mengacaukannya pada kode lawas pada kerangka kerja buatan sendiri. <br><br>  T: Dan sekarang saya dengan cepat menelusuri situs dengan tangan saya, dan itu normal.  Mengapa saya membutuhkannya? <br>  A: "Jalankan" dari beberapa lusin tes berlangsung beberapa detik.  Pengujian otomatis selalu lebih cepat daripada pengujian manual, dan dengan pengujian berkualitas tinggi juga lebih andal, karena mencakup semua skenario. <br><br>  T: Saya memiliki kode lawas dengan fungsi 2000 baris.  Bisakah saya menguji ini? <br>  A: Ya dan tidak.  Secara teori, ya, kode apa pun dapat ditutupi dengan tes.  Dalam praktiknya, kode harus ditulis dengan dasar untuk pengujian di masa depan.  Fungsi 2000 baris akan memiliki terlalu banyak dependensi, cabang, kasus perbatasan.  Mungkin pada akhirnya akan mencakup semuanya, tetapi kemungkinan besar itu akan memakan waktu lama bagi Anda.  Semakin baik kode, semakin mudah untuk mengujinya.  Tanggung jawab tunggal yang lebih baik dihormati, semakin mudah tes akan.  Untuk menguji proyek lama paling sering, Anda harus terlebih dahulu refactor mereka dengan dingin. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="gambar"><br><br>  T: Saya memiliki metode (fungsi) yang sangat sederhana, apa yang harus diuji?  Semuanya bisa diandalkan di sana, tidak ada ruang untuk kesalahan! <br>  A: Harus dipahami bahwa Anda tidak menguji implementasi fungsi yang benar (jika Anda tidak memiliki TDD), Anda cukup "memperbaiki" kondisi kerjanya saat ini.  Di masa depan, ketika Anda perlu mengubahnya, Anda dapat dengan cepat menentukan apakah Anda melanggar perilakunya menggunakan tes.  Contoh: ada fungsi yang memvalidasi email.  Dia membuatnya menjadi biasa. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Semua kode Anda mengharapkan bahwa jika Anda mengirim email yang valid ke fungsi ini, itu akan mengembalikan true.  Array email yang valid juga benar.  Array dengan setidaknya satu alamat email tidak valid salah.  Nah dan seterusnya, kodenya jelas.  Tetapi hari itu tiba, dan Anda memutuskan untuk mengganti musim reguler yang mengerikan dengan API eksternal.  Tetapi bagaimana menjamin bahwa fungsi yang ditulis ulang tidak mengubah prinsip operasi?  Tiba-tiba tidak menangani array dengan baik?  Atau akankah kembali bukan boolean?  Dan tes dapat menjaga ini di bawah kendali.  Tes yang ditulis dengan baik akan segera menunjukkan perilaku fungsi selain yang diharapkan. <br><br>  T: Kapan saya akan mulai melihat beberapa perasaan dari tes? <br>  A: Pertama, segera setelah Anda membahas bagian penting dari kode.  Semakin dekat cakupan ke 100%, semakin dapat diandalkan pengujian.  Kedua, segera setelah Anda harus membuat perubahan global, atau perubahan pada bagian kompleks kode.  Tes dapat menangkap masalah yang dapat dengan mudah terjawab secara manual (kasus batas).  Ketiga, saat menulis tes sendiri!  Seringkali ada situasi ketika menulis tes mengungkapkan kesalahan kode yang tidak terlihat pada pandangan pertama. <br><br>  T: Ya, saya punya situs web di laravel.  Situs ini bukan fungsi, situs ini adalah gunung kode yang menyebalkan.  Bagaimana cara menguji di sini? <br>  A: Inilah yang akan dibahas nanti.  Singkatnya: kami menguji secara terpisah metode pengontrol, secara terpisah middleware, secara terpisah layanan, dll. <br><br>  Salah satu ide pengujian Unit adalah untuk mengisolasi bagian kode yang diuji.  Semakin sedikit kode yang Anda uji dengan satu tes, semakin baik.  Mari kita lihat contoh sedekat mungkin dengan kehidupan nyata: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Ini adalah metode yang sangat khas untuk masuk ke sistem pada proyek-proyek kecil.  Yang kami harapkan adalah pesan kesalahan yang benar, dan email yang dikirim jika berhasil masuk.  Bagaimana cara menguji metode ini?  Pertama, Anda perlu mengidentifikasi dependensi eksternal.  Dalam kasus kami, ada dua di antaranya - $ userService dan $ emailService.  Mereka melewati konstruktor kelas, yang sangat memudahkan tugas kita.  Tapi, seperti yang disebutkan sebelumnya, semakin sedikit kode yang kami uji dalam satu pass, semakin baik. <br><br>  Persaingan, penggantian objek disebut mokanem (dari bahasa Inggris. Objek tiruan, secara harfiah: "objek-parodi").  Tidak ada yang mengganggu untuk menulis objek seperti itu secara manual, tetapi semuanya telah ditemukan sebelum kita, sehingga perpustakaan yang luar biasa seperti <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> datang untuk menyelamatkan.  Mari kita membuat mokas untuk layanan. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Sekarang buat objek $ request.  Untuk mulai dengan, kami akan menguji logika memeriksa bidang login dan kata sandi.  Kami ingin memastikan bahwa jika tidak ada, metode kami akan menangani kasus ini dengan benar dan mengembalikan Pesan (!) Yang diinginkan. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Tidak ada yang rumit, bukan?  Kami membuat stubs untuk parameter kelas yang diperlukan, membuat instance dari kelas yang diinginkan, dan "menarik" metode yang diinginkan, dengan sengaja melewatkan permintaan yang salah.  Mendapat jawaban.  Tapi bagaimana cara memeriksanya sekarang?  Ini adalah bagian paling penting dari tes ini - apa yang disebut pernyataan.  PHPUnit memiliki lusinan <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">pernyataan</a> siap pakai.  Cukup gunakan salah satunya. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Tes ini menjamin yang berikut - jika argumen login tiba di objek metode yang tidak memiliki bidang login atau kata sandi, maka metode akan mengembalikan string "Kesalahan auth".  Itu, secara umum, itu saja.  Sangat sederhana - tetapi sangat berguna, karena sekarang kita dapat mengedit metode login tanpa takut merusak sesuatu.  Frontend kita dapat memastikan bahwa jika sesuatu terjadi - dia akan mendapatkan kesalahan seperti itu.  Dan jika seseorang merusak perilaku ini (misalnya, memutuskan untuk mengubah teks kesalahan), maka tes akan segera memberi sinyal ini!  Kami menambahkan sisa cek untuk mencakup sebanyak mungkin skenario. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Perhatikan metode shouldReceive dan andReturn?  Mereka memungkinkan kita untuk membuat metode dalam bertopik yang hanya mengembalikan apa yang kita butuhkan.  Perlu menguji kesalahan kata sandi yang salah?  Kami menulis stub $ userService yang selalu mengembalikan kata sandi yang salah.  Dan itu dia. <br><br>  Dan bagaimana dengan dependensi, Anda bertanya.  Kami kemudian â€œmenenggelamkanâ€ mereka, dan bagaimana jika mereka pecah?  Tapi inilah tepatnya cakupan kode maksimum dengan tes.  Kami tidak akan memeriksa operasi layanan ini dalam konteks login - kami akan menguji login dengan harapan operasi layanan yang benar.  Dan kemudian kami menulis tes terisolasi yang sama untuk layanan ini.  Dan kemudian menguji ketergantungan mereka.  Dan sebagainya.  Akibatnya, setiap tes individu <b>hanya</b> menjamin operasi yang benar dari sepotong kecil kode, asalkan semua dependensinya bekerja dengan benar.  Dan karena semua dependensi juga dicakup oleh tes, operasi yang benar juga dijamin.  Akibatnya, setiap perubahan pada sistem yang merusak logika pekerjaan bahkan bagian terkecil dari kode akan segera muncul dalam tes tertentu.  Cara khusus menjalankan uji coba - saya tidak akan memberi tahu, dokumentasi di PHPUnit cukup baik.  Dan di Laravel, misalnya, cukup menjalankan vendor / bin / phpunit dari root proyek untuk melihat pesan seperti ini <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="gambar">  - Semua tes berhasil.  Atau sesuatu seperti ini <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="gambar">  Satu dari tujuh pernyataan gagal. <br><br>  "Ini, tentu saja, keren, tapi apa yang tidak bisa kukerjakan?" Anda bertanya.  Dan mari kita bayangkan kode berikut untuk ini <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Kami melihat model yang disederhanakan untuk bekerja dengan API eksternal.  Fungsi ini menggunakan beberapa kelas untuk bekerja dengan API, dan jika terjadi kesalahan, mengembalikan nol.  Jika, ketika menggunakan fungsi ini, kita mendapatkan nol, kita harus "meningkatkan kepanikan" (mengirim pesan ke slack, atau mengirim email ke pengembang, atau melemparkan kesalahan ke dalam kibana. Ya, banyak pilihan).  Segalanya tampak sederhana, bukan?  Tetapi bayangkan bahwa setelah beberapa waktu pengembang lain memutuskan untuk "memperbaiki" fungsi ini.  Dia memutuskan bahwa mengembalikan nol adalah abad terakhir, dan dia harus melemparkan pengecualian. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  Dan dia bahkan menulis ulang semua bagian kode tempat fungsi ini dipanggil!  Semua kecuali satu.  Dia merindukannya.  Mengalihkan perhatian, lelah, salah - tetapi Anda tidak pernah tahu.  Faktanya adalah bahwa sepotong kode masih menunggu perilaku fungsi lama.  Dan PHP bukan Java untuk kami - kami tidak akan mendapatkan kesalahan kompilasi dengan alasan bahwa fungsi throwable tidak dibungkus dengan try-catch.  Akibatnya, dalam salah satu dari 100 skenario untuk menggunakan situs ini, jika terjadi kerusakan API, kami tidak akan menerima pesan dari sistem.  Selain itu, dengan pengujian manual, kemungkinan besar kami tidak akan menangkap versi acara ini.  API bersifat eksternal, tidak tergantung pada kami, itu berfungsi dengan baik - dan kemungkinan besar kami tidak akan mendapatkannya jika terjadi kegagalan API, dan penanganan pengecualian yang salah.  Tetapi jika kita memiliki tes, mereka akan menangkap kasus ini dengan sangat baik, karena kelas ExternalApi â€œteredamâ€ dalam sejumlah tes, dan ini mengemulasi perilaku normal dan crash.  Dan tes selanjutnya akan jatuh <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Informasi ini sebenarnya cukup.  Jika Anda tidak memiliki mie Legacy, setelah 20-30 menit Anda dapat menulis tes pertama Anda.  Dan beberapa minggu kemudian - untuk mempelajari sesuatu yang baru, keren, kembali ke komentar di bawah posting ini, dan tulis penulis mana yang govnokoder tidak tahu tentang% framework_name%, dan menulis tes buruk, tetapi Anda perlu melakukan% this_way%.  Dan saya akan sangat senang dalam hal ini.  Ini akan berarti bahwa tujuan saya telah tercapai: orang lain menemukan pengujian untuk dirinya sendiri, dan sedikit meningkatkan tingkat profesionalisme secara umum di bidang kita! <br><br>  Kritik yang masuk akal disambut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485418/">https://habr.com/ru/post/id485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485394/index.html">Bagaimana infrastruktur Internet lahir</a></li>
<li><a href="../id485396/index.html">Pemeriksaan Kesehatan Regu: Mengukur Kesehatan Tim</a></li>
<li><a href="../id485398/index.html">PostgreSQL Antipatterns: tekan kamus di JOIN berat</a></li>
<li><a href="../id485404/index.html">Kami menyadari efek visual dari film "The Matrix"</a></li>
<li><a href="../id485416/index.html">Cara praktis untuk memetakan data di Kotlin</a></li>
<li><a href="../id485424/index.html">Bagaimana Saya Mengajari Anak-Anak Python</a></li>
<li><a href="../id485426/index.html">Mobil di Belanda: statistik dan informasi untuk 2019</a></li>
<li><a href="../id485428/index.html">Program LyX yang misterius. Bagian 5</a></li>
<li><a href="../id485430/index.html">Editor teks multi-pengguna yang sederhana dengan enkripsi ujung ke ujung</a></li>
<li><a href="../id485438/index.html">Menguji Komponen UI Bereaksi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>