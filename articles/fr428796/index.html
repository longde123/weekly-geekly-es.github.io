<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 🌃 👨🏾‍🚒 Manipulation en temps réel des maillages sur Unity 🏂🏻 🧛🏼 🎊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'un des avantages d'Unity en tant que plateforme de développement de jeux est son puissant moteur 3D. Dans ce didacticiel, vous découvrirez le monde ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manipulation en temps réel des maillages sur Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428796/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif" alt="image"></div><br>  L'un des avantages d'Unity en tant que plateforme de développement de jeux est son puissant moteur 3D.  Dans ce didacticiel, vous découvrirez le monde des objets 3D et la manipulation des maillages. <br><br>  En raison de la croissance des technologies de réalité virtuelle et augmentée (VR / AR), la plupart des développeurs sont confrontés à des concepts complexes de graphiques 3D.  Que ce didacticiel soit le point de départ pour eux.  Ne vous inquiétez pas, il n'y aura pas de mathématiques 3D compliquées - seulement des coeurs, des dessins, des flèches et plein de choses intéressantes! <br><a name="habracut"></a><br><blockquote>  <em>Remarque:</em> ce didacticiel est destiné aux utilisateurs qui connaissent l'EDI Unity et ont une certaine expérience de programmation en C #.  Si vous ne disposez pas de telles connaissances, étudiez d'abord les didacticiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Introduction à l'interface utilisateur Unity</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Introduction aux scripts Unity</a> . <br><br>  Vous aurez besoin d'une version d'Unity inférieure à 2017.3.1.  La dernière version d'Unity peut être téléchargée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">ici</a> .  Ce didacticiel utilise un éditeur personnalisé et vous pouvez en savoir plus à leur sujet dans le didacticiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Extension de l'éditeur Unity</a> . </blockquote><br><h2>  Se rendre au travail </h2><br>  Pour commencer, familiarisez-vous avec les termes de base des graphiques 3D, qui vous permettront de mieux comprendre le didacticiel. <br><br>  Termes techniques de base des graphiques 3D: <br><br><ul><li>  <em>Sommets</em> : chaque sommet est un point dans l'espace 3D. </li><li>  <em>Maillage</em> : contient tous les sommets, arêtes, triangles, normales et données UV du modèle. </li><li>  <em>Filtre de maillage</em> : stocke les données de maillage du modèle. </li><li>  <em>Rendu de maillage</em> : restitue les données de maillage dans la scène. </li><li>  <em>Normales</em> : vecteur d'un sommet ou d'une surface.  Il est dirigé vers l'extérieur, perpendiculairement à la surface du maillage. </li><li>  <em>Lignes / arêtes</em> : lignes invisibles reliant les sommets les uns aux autres. </li><li>  <em>Triangles</em> : formés en reliant trois pics. </li><li>  <em>Carte UV</em> : attache le matériau à un objet, créant une texture et une couleur pour celui-ci. </li></ul><br>  L'anatomie d'un objet 3D commence par son maillage.  La création de ce maillage commence à ses sommets.  Les lignes invisibles reliant ces sommets forment des triangles qui définissent la forme de base de l'objet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/83a/4c2/5a783a4c2ed2c144ccd0d7eb97369370.gif"></div><br>  Ensuite, les données normales et UV définissent l'ombrage, la couleur et la texture.  Les données de maillage sont stockées dans un filtre de maillage et le rendu de maillage utilise ces données pour dessiner un objet dans la scène. <br><br>  Autrement dit, le pseudocode pour créer un modèle 3D ressemble à ceci: <br><br><ul><li>  Créez un nouveau maillage appelé «myMesh». </li><li>  Ajoutez des données aux propriétés des sommets et triangles myMesh. </li><li>  Créez un nouveau filtre maillé appelé «myMeshFilter». </li><li>  Définissez la propriété de maillage myMeshFilter sur myMesh. </li></ul><br>  Une fois que vous maîtrisez les bases, téléchargez le <a href="">projet</a> , décompressez les fichiers et exécutez la pièce du projet dans Unity.  Regardez la structure des dossiers dans la fenêtre <em>Projet</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/690/2d6/c2e/6902d6c2e14a98284c8af39055242bc7.png"></div><br>  Description des dossiers: <br><br><ul><li>  <em>Préfabriqués</em> : contient le préfabriqué Sphère qui sera utilisé pour enregistrer le maillage 3D lors de l'exécution de l'application. </li><li>  <em>Scènes</em> : contient les trois scènes que nous utilisons dans ce didacticiel. </li><li>  <em>Editeur</em> : les scripts à l'intérieur de ce dossier nous donnent les super-fonctionnalités de l'éditeur que nous utilisons en développement. </li><li>  <em>Scripts</em> : voici les scripts d'exécution qui s'attachent au GameObject et s'exécutent lorsque vous cliquez sur <em>Play</em> . </li><li>  <em>Matériaux</em> : ce dossier contient le matériau du maillage. </li></ul><br>  Dans la section suivante, nous allons créer un éditeur personnalisé pour visualiser la création d'un maillage 3D. <br><br><h2>  Modifier les maillages avec l'éditeur personnalisé </h2><br>  Ouvrez la <em>démo 01 Mesh Study</em> située dans le dossier <em>Scenes</em> .  Dans la fenêtre <em>Scène</em> , vous verrez un cube 3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/ed2/812/6d5ed28123a0c65bb083c67efab702c7.gif"></div><br>  Avant d'entrer dans le maillage, jetons un œil au script de l'éditeur personnalisé. <br><br><h3>  Modification d'un script d'éditeur </h3><br>  Sélectionnez le dossier <em>Editeur</em> dans la fenêtre <em>Projet</em> .  Les scripts de ce dossier ajoutent des fonctionnalités à l'éditeur (Editor) pendant le développement et ne sont pas disponibles en mode Build. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/442/653/b41/442653b41ca755b67d3a1ce42ae1ec5a.png"></div><br>  Ouvrez <em>MeshInspector.cs</em> et affichez le code source.  Tous les scripts Editor doivent implémenter la classe <code>Editor</code> , son attribut <code>CustomEditor</code> indique à la classe <code>Editor</code> quel type d'objet il est destiné.  <code>OnSceneGUI()</code> est une méthode d'événement qui permet le rendu dans la fenêtre Scene;  <code>OnInspectorGUI()</code> vous permet d'ajouter des éléments GUI supplémentaires à l'inspecteur. <br><br>  Dans <em>MeshInspector.cs,</em> avant de démarrer la classe <code>MeshInspector</code> ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(MeshStudy))</span></span>]</code> </pre> <br>  Explication du code: l'attribut <code>CustomEditor</code> indique à Unity quel type d'objet la classe de l'éditeur personnalisé peut modifier. <br><br>  Dans <code>OnSceneGUI()</code> avant <code>EditMesh()</code> ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">mesh = target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MeshStudy; Debug.Log(<span class="hljs-string"><span class="hljs-string">"Custom editor is running"</span></span>);</code> </pre> <br>  Explication du code: la classe <code>Editor</code> a une variable <code>target</code> standard.  Ici, la <code>target</code> est une conversion vers <code>MeshStudy</code> .  Maintenant, l'éditeur personnalisé dessinera tous les GameObjects dans la fenêtre Scene et les <em>MeshStudy.cs</em> qui leur <em>sont</em> attachés.  L'ajout de messages de débogage vous permet de vérifier dans la console que l'éditeur personnalisé est réellement en cours d'exécution. <br><br>  Enregistrez le fichier et revenez à Unity.  Accédez au dossier <em>Scripts</em> et faites glisser <em>MeshStudy.cs</em> sur le <em>cube</em> GameObject dans la <em>hiérarchie</em> pour le joindre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/b8a/ee4/aa6b8aee48eacb8421eff3c4e1ef4be3.png"></div><br>  Maintenant, le message «L'éditeur personnalisé est en cours d'exécution» devrait s'afficher dans la console, ce qui signifie que nous avons tout fait correctement!  Vous pouvez supprimer le message de débogage afin qu'il ne nous dérange pas dans la console. <br><br><h3>  Clonage et vidage du maillage </h3><br>  Lorsque vous travaillez avec un maillage 3D en mode Édition à l'aide de l'éditeur personnalisé, veillez à ne pas écraser le maillage Unity par défaut.  Si cela se produit, vous devrez redémarrer Unity. <br><br>  Pour cloner le maillage en toute sécurité sans écraser le formulaire d'origine, créez une copie du maillage à partir de la propriété <code>MeshFilter.sharedmesh</code> et affectez-le à nouveau au filtre de maillage. <br><br>  Pour ce faire, double-cliquez sur <em>MeshStudy.cs</em> dans le dossier <em>Scripts</em> pour ouvrir le fichier dans l'éditeur de code.  Ce script hérite de la classe <code>MonoBehaviour</code> et sa fonction <code>Start()</code> n'est pas exécutée en mode Edit. <br><br>  Dans <em>MeshStudy.cs,</em> avant de démarrer la classe <code>MeshStudy</code> ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>]</code> </pre> <br>  Explication du code: après l'ajout de cet attribut, la fonction <code>Start()</code> sera exécutée à la fois en mode Play et en mode Edit.  Maintenant, nous pouvons d'abord instancier l'objet maillé et le cloner. <br><br>  Dans <code>InitMesh()</code> ajoutez le code suivant: <br><br><pre> <code class="cs hljs">oMeshFilter = GetComponent&lt;MeshFilter&gt;(); oMesh = oMeshFilter.sharedMesh; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh = new Mesh(); //2 cMesh.name = "clone"; cMesh.vertices = oMesh.vertices; cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; isCloned = true; Debug.Log("Init &amp; Cloned");</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Obtient le maillage <code>oMesh</code> origine du composant <code>MeshFilter</code> . </li><li>  Copie <code>cMesh</code> dans une nouvelle <code>cMesh</code> maillage. </li><li>  Attribue à nouveau le filtre de maillage de maillage copié. </li><li>  Met à jour les variables locales. </li></ol><br>  Enregistrez le fichier et revenez à Unity.  Le message «Init &amp; Cloned» doit être affiché dans la console de débogage.  Sélectionnez le <code>Cube</code> GameObject dans la <em>hiérarchie</em> et vérifiez ses propriétés dans l' <em>inspecteur</em> .  <em>Le filtre de maillage</em> doit afficher un élément de maillage appelé <em>clone</em> .  Super!  Cela signifie que nous avons réussi à cloner le maillage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/2da/3e0/c6c2da3e0e29703888bad5e50bb608a6.png"></div><br>  Dans le dossier Editor, accédez à <em>MeshInspector.cs</em> .  Dans <code>OnInspectorGUI()</code> , après la deuxième ligne de code, ajoutez ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Reset"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.Reset(); //2 }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Ce code dessine un bouton Réinitialiser dans l' <em>inspecteur</em> . </li><li>  Lorsqu'il est pressé, il appelle la fonction <code>Reset()</code> dans <em>MeshStudy.cs</em> . </li></ol><br>  Enregistrez le fichier, ouvrez <em>MeshStudy.cs</em> et ajoutez le code suivant à la fonction <code>Reset()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; oMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1 { cMesh.vertices = oMesh.vertices; //2 cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Vérification de l'existence de la source et du maillage cloné. </li><li>  Réinitialisez <code>cMesh</code> au maillage d'origine. </li><li>  Affectation à <code>cMesh</code> <code>oMeshFilter</code> . </li><li>  Mise à jour des variables locales. </li></ol><br>  Enregistrez le fichier et revenez à Unity.  Dans l' <em>inspecteur,</em> cliquez sur le bouton <em>Test Edit</em> pour déformer le maillage du cube.  Ensuite, cliquez sur le bouton <em>Réinitialiser</em> ;  le cube doit reprendre sa forme d'origine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a8a/e22/0c3a8ae22c8f8382dd46ee652b4b6eea.gif"></div><br><h3>  Explication des sommets et triangles dans Unity </h3><br>  Un maillage est composé de sommets reliés par des arêtes en triangles.  Les triangles définissent la forme de base de l'objet. <br><br><blockquote>  <em>Classe de maille:</em> <br><br><ul><li>  Les sommets sont stockés sous forme de tableau de valeurs <code>Vector3</code> . </li><li>  Les triangles sont stockés sous la forme d'un tableau d'entiers correspondant aux indices du tableau de sommets. </li></ul><br>  Autrement dit, dans un simple maillage Quad, composé de quatre sommets et de deux triangles, les données du maillage ressembleront à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/56d/794/56c56d794628ff20592f801340308790.gif"></div></blockquote><br><h3>  Cartographie des sommets </h3><br>  Ici, nous voulons afficher les sommets du cube sous forme de points bleus. <br><br>  Dans <em>MeshInspector.cs,</em> nous <em>allons</em> entrer dans la fonction <code>EditMesh()</code> et ajouter ce qui suit: <br><br><pre> <code class="cs hljs">handleTransform = mesh.transform; <span class="hljs-comment"><span class="hljs-comment">//1 handleRotation = Tools.pivotRotation == PivotRotation.Local ? handleTransform.rotation : Quaternion.identity; //2 for (int i = 0; i &lt; mesh.vertices.Length; i++) //3 { ShowPoint(i); }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  <code>handleTransform</code> obtient les valeurs de transformation à partir du <code>mesh</code> . </li><li>  <code>handleRotation</code> obtient le mode Rotation de l'articulation actuelle. </li><li>  Parcourez les sommets du maillage et tracez les points à l'aide de <code>ShowPoint()</code> . </li></ol><br>  Dans la fonction <code>ShowPoint()</code> , immédiatement après le commentaire <code>//draw dot</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">Vector3 point = handleTransform.TransformPoint(mesh.vertices[index]);</code> </pre> <br>  Explication du code: cette ligne convertit la position locale du sommet en coordonnées dans l'espace mondial. <br><br>  Dans la même fonction, dans le bloc <code>if</code> , immédiatement après la ligne de code que vous venez d'ajouter, ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; point = Handles.FreeMoveHandle(point, handleRotation, mesh.handleSize, Vector3.zero, Handles.DotHandleCap);</code> </pre> <br>  Explication du code: <br><br><ol><li>  Définit la couleur, la taille et la position d'un point à l'aide de la classe d'assistance <code>Handles</code> . </li><li>  <code>Handles.FreeMoveHandle()</code> crée un manipulateur de mouvement illimité qui simplifie l'opération de glisser-déposer, ce qui nous est utile dans la section suivante. </li></ol><br>  Enregistrez le fichier et revenez à Unity.  Vérifiez la propriété du cube dans l' <em>inspecteur</em> et assurez-vous que l'option <em>Déplacer le point de</em> sommet est activée.  Vous devriez maintenant voir que le maillage à l'écran est marqué de plusieurs points bleus.  Les voici - les sommets du maillage cube!  Essayez de le faire avec d'autres objets 3D et observez les résultats. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/3aa/205/d783aa2054dd9ca81ee7a6c948c7c00a.gif"></div><br><h3>  Déplacer un seul sommet </h3><br>  Commençons par l'étape la plus simple de manipulation du maillage - déplacer un seul sommet. <br><br>  Accédez à <em>MeshInspector.cs</em> .  Dans la fonction <code>ShowPoint()</code> , immédiatement après le commentaire <code>//drag</code> et juste avant les crochets de fermeture du bloc <code>if</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUI.changed) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.DoAction(index, handleTransform.InverseTransformPoint(point)); //2 }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  <code>GUI.changed</code> garde une trace de toutes les modifications qui se produisent avec les points et fonctionne bien avec <code>Handles.FreeMoveHandle()</code> pour reconnaître une opération de glisser-déposer. </li><li>  Pour le sommet déplaçable, la fonction <code>mesh.DoAction()</code> reçoit ses valeurs d'index et de transformation comme paramètres.  Étant donné que les valeurs de sommet de transformation sont dans l'espace mondial, nous les convertissons en espace local à l'aide d' <code>InverseTransformPoint()</code> . </li></ol><br>  Enregistrez le fichier de script et accédez à <em>MeshStudy.cs</em> .  Dans <code>DoAction()</code> , après les crochets d'ouverture, ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">PullOneVertex(index, localPos);</code> </pre> <br>  Ajoutez ensuite ce qui suit à la fonction <code>PullOneVertex()</code> : <br><br><pre> <code class="cs hljs">vertices[index] = newPos; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh.vertices = vertices; //2 cMesh.RecalculateNormals(); //3</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Nous mettons à jour le sommet cible avec la valeur <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> valeurs de sommet mises à jour à <code>cMesh.vertices</code> . </li><li>  Dans <code>RecalculateNormals()</code> recalculons et redessinons le maillage afin qu'il corresponde aux modifications. </li></ol><br>  Enregistrez le fichier et revenez à Unity.  Essayez de faire glisser des points sur le cube;  avez-vous vu un maillage cassé? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fca/ccf/c86/fcaccfc865e30b3c922e6cabcf9f79d7.gif"></div><br>  Il semble que certains des sommets aient la même position, donc lorsque nous ne faisons glisser qu'un seul, les sommets restants restent derrière, et le maillage se brise.  Dans la section suivante, nous allons résoudre ce problème. <br><br><h3>  Trouver tous les sommets similaires </h3><br>  Visuellement, un maillage cubique se compose de huit sommets, six côtés et 12 triangles.  Vérifions si c'est le cas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/a30/b3f/253a30b3fcca7b0d9028d92b4c4149c2.gif"></div><br>  Ouvrez <em>MeshStudy.cs</em> , jetez un œil devant la fonction <code>Start()</code> et trouvez la variable des <code>vertices</code> .  Nous verrons ce qui suit: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices;</code> </pre> <br>  Explication du code: <code>[HideInInspector]</code> masque une variable partagée dans la fenêtre <em>Inspecteur</em> . <br><br>  Commentez cet attribut: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//[HideInInspector] public Vector3[] vertices;</span></span></code> </pre> <br><blockquote>  <em>Remarque:</em> masquer les valeurs des sommets aide <code>[HideInInspector]</code> avec des maillages 3D plus complexes.  Étant donné que la taille du tableau de sommets peut atteindre des milliers d'éléments, cela peut entraîner une inhibition de Unity lorsque vous essayez d'afficher la valeur du tableau dans l'inspecteur. </blockquote><br>  Enregistrez le fichier et revenez à Unity.  Allez à l' <em>inspecteur</em> .  Maintenant, sous le composant de script <em>Mesh Study</em> , la propriété <em>verteices</em> est apparue.  Cliquez sur l'icône de flèche à côté;  vous <code>Vector3</code> tableau des éléments <code>Vector3</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/f83/fd0/febf83fd02d469734b73910b1769d670.gif"></div><br>  Vous pouvez voir que la taille du tableau est de 24, c'est-à-dire qu'il y a des sommets ayant la même position!  Avant de continuer, assurez-vous de décommenter <code>[HideInInspector]</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi y a-t-il 24 sommets?</b> <div class="spoiler_text">  Il existe de nombreuses théories à ce sujet.  Mais la réponse la plus simple est: le cube a six côtés, et chaque côté est composé de quatre sommets qui forment un plan. <br><br>  Par conséquent, le calcul est le suivant: 6 x 4 = 24 sommets. <br><br>  Vous pouvez rechercher d'autres réponses.  Mais pour l'instant, c'est assez simple de savoir que certains maillages auront des sommets qui auront la même position. </div></div><br>  Dans <em>MeshStudy.cs,</em> remplacez <em>tout le</em> code à l'intérieur de la fonction <code>DoAction()</code> par ce qui suit: <br><br><pre> <code class="cs hljs">PullSimilarVertices(index, localPos);</code> </pre> <br>  Passons à la fonction <code>PullSimilarVertices()</code> et ajoutons ce qui suit: <br><br><pre> <code class="cs hljs">Vector3 targetVertexPos = vertices[index]; <span class="hljs-comment"><span class="hljs-comment">//1 List&lt;int&gt; relatedVertices = FindRelatedVertices(targetVertexPos, false); //2 foreach (int i in relatedVertices) //3 { vertices[i] = newPos; } cMesh.vertices = vertices; //4 cMesh.RecalculateNormals();</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  nous obtenons la position du sommet cible, qui sera utilisée comme argument de la méthode <code>FindRelatedVertices()</code> . </li><li>  Cette méthode renvoie une liste d'index (correspondant aux sommets) qui ont la même position que le sommet cible. </li><li>  La boucle traverse la liste entière et définit les sommets correspondants sur <code>newPos</code> . </li><li>  <code>cMesh.vertices</code> <code>vertices</code> mis à jour à <code>cMesh.vertices</code> .  Ensuite, nous appelons <code>RecalculateNormals()</code> pour redessiner le maillage avec les nouvelles valeurs. </li></ol><br>  Enregistrez le fichier et revenez à Unity.  Faites glisser l'un des sommets;  maintenant le maillage doit conserver sa forme et ne pas s'effondrer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/66d/bcc/b1b66dbccb73ac3a8ad8c56594611919.gif"></div><br>  Maintenant que nous avons terminé la première étape de la manipulation des maillages, enregistrez la scène et passez à la section suivante. <br><br><h2>  Manipulation de maillage </h2><br>  Dans cette section, vous apprendrez à manipuler les maillages en temps réel.  Il existe de nombreuses façons, mais dans ce didacticiel, nous examinerons le type de manipulation de maillage le plus simple, à savoir le déplacement des sommets de maillage créés précédemment. <br><br><h3>  Collecte des index sélectionnés </h3><br>  Commençons par sélectionner les sommets que nous déplacerons en temps réel. <br><br>  Ouvrez la scène <em>02 Create Heart Mesh à</em> partir du dossier <em>Scenes</em> .  Dans la fenêtre Scène, vous verrez une sphère rouge.  Sélectionnez <em>Sphère</em> dans la <em>hiérarchie</em> et accédez à <em>Inspecteur</em> .  Vous verrez que le composant de script <em>Heart Mesh</em> est attaché à l'objet. <br><br>  Nous avons maintenant besoin du script Editor pour cet objet pour afficher les sommets du maillage dans la fenêtre Scene.  Accédez au dossier <em>Editor</em> et double-cliquez sur <em>HeartMeshInspector.cs</em> . <br><br>  Dans la fonction <code>ShowHandle()</code> , à l'intérieur du bloc <code>if</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handles.Button(point, handleRotation, mesh.pickSize, mesh.pickSize, Handles.DotHandleCap)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.selectedIndices.Add(index); //2 }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Définit et affiche les sommets du maillage en tant que type <code>Handles.Button</code> . </li><li>  Lorsque vous cliquez dessus, il ajoute l'index sélectionné à la <code>mesh.selectedIndices</code> pressée, <code>mesh.selectedIndices</code> . </li></ol><br>  Dans <code>OnInspectorGUI()</code> , avant le crochet de fermeture, ajoutez ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Clear Selected Vertices"</span></span>)) { mesh.ClearAllData(); }</code> </pre> <br>  Explication du code: <code>mesh.ClearAllData()</code> comment ajouter un bouton Reset à l' <em>inspecteur</em> pour appeler <code>mesh.ClearAllData()</code> . <br><br>  Enregistrez le fichier et ouvrez <em>HeartMesh.cs à</em> partir du dossier <em>Scripts</em> .  Dans la fonction <code>ClearAllData()</code> , ajoutez les éléments suivants: <br><br><pre> <code class="cs hljs">selectedIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); targetIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; targetVertex = Vector3.zero;</code> </pre> <br>  Explication du code: le code efface les valeurs dans <code>selectedIndices</code> et <code>targetIndex</code> .  Il réinitialise également <code>targetVertex</code> . <br><br>  Enregistrez le fichier et revenez à Unity.  Sélectionnez <em>Sphère</em> et accédez à l' <em>inspecteur</em> du <em>composant de</em> script <em>HeartMesh</em> .  Développez les <em>indices sélectionnés</em> en cliquant sur l'icône en forme de flèche à côté.  Cela nous permettra de suivre chaque sommet ajouté à la liste. <br><br>  Activez le <em>mode d'édition</em> à l'aide de la case à cocher à côté.  Pour cette raison, les sommets du maillage seront dessinés dans la fenêtre Scène.  Un clic sur les points bleus dans les <em>indices sélectionnés</em> devrait modifier les valeurs en conséquence.  <em>Testez également le</em> bouton <em>Effacer les sommets sélectionnés</em> pour vous assurer qu'il efface toutes les valeurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17a/271/dea/17a271dea970e9c3ade451773b87eb65.gif"></div><br>  <em>Remarque:</em> dans l' <em>inspecteur</em> personnalisé modifié, nous avons la possibilité d'afficher / masquer le manipulateur de transformation à l'aide de <em>Afficher la poignée de transformation</em> .  Alors ne paniquez pas si vous ne trouvez pas le manipulateur Transform dans d'autres scènes!  Allumez-le avant de quitter. <br><br><h3>  Transformer une sphère en cœur </h3><br>  La modification des sommets du maillage en temps réel consiste essentiellement en trois étapes: <br><br><ol><li>  Copiez les sommets de maillage actuels (avant l'animation) dans <code>mVertices</code> . </li><li>  <code>mVertices</code> calculs et modifions les valeurs dans <code>mVertices</code> . </li><li>  Mettez à jour les sommets de maillage actuels avec <code>mVertices</code> lors de la modification à chaque étape et laissez Unity calculer automatiquement les normales. </li></ol><br>  Ouvrez <em>HeartMesh.cs</em> et les variables suivantes avant la fonction <code>Start()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radiusofeffect = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 public float pullvalue = 0.3f; //2 public float duration = 1.2f; //3 int currentIndex = 0; //4 bool isAnimate = false; float starttime = 0f; float runtime = 0f;</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Rayon de la zone affectée par le sommet cible. </li><li>  Faites glisser la force. </li><li>  La durée de l'animation. </li><li>  Index actuel de la liste <code>selectedIndices</code> . </li></ol><br>  Dans la fonction <code>Init()</code> , avant le bloc <code>if</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">currentIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Explication du code: au début du jeu, <code>currentIndex</code> à 0, le premier index de la liste <code>selectedIndices</code> . <br><br>  Dans la même fonction <code>Init()</code> , avant le crochet de fermeture du bloc <code>else</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">StartDisplacement();</code> </pre> <br>  Explication du code: exécutez la fonction <code>StartDisplacement()</code> si <code>isEditMode</code> est false. <br><br>  Dans la fonction <code>StartDisplacement()</code> , ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">targetVertex = oVertices[selectedIndices[currentIndex]]; <span class="hljs-comment"><span class="hljs-comment">//1 starttime = Time.time; //2 isAnimate = true;</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Sélectionnez <code>targetVertex</code> pour démarrer l'animation. </li><li>  Définissez l'heure de début et modifiez la valeur de <code>isAnimate</code> sur true. </li></ol><br>  Après la fonction <code>StartDisplacement()</code> , créez la fonction <code>FixedUpdate()</code> avec le code suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//1 { if (!isAnimate) //2 { return; } runtime = Time.time - starttime; //3 if (runtime &lt; duration) //4 { Vector3 targetVertexPos = oFilter.transform.InverseTransformPoint(targetVertex); DisplaceVertices(targetVertexPos, pullvalue, radiusofeffect); } else //5 { currentIndex++; if (currentIndex &lt; selectedIndices.Count) //6 { StartDisplacement(); } else //7 { oMesh = GetComponent&lt;MeshFilter&gt;().mesh; isAnimate = false; isMeshReady = true; } } }</span></span></span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  La fonction <code>FixedUpdate()</code> est exécutée dans une boucle FPS fixe. </li><li>  Si <code>isAnimate</code> est faux, ignorez le code suivant. </li><li>  Modifiez <code>runtime</code> animations d' <code>runtime</code> . </li><li>  Si l' <code>runtime</code> est dans la <code>duration</code> , nous obtenons alors les coordonnées mondiales de <code>targetVertex</code> et <code>DisplaceVertices()</code> , couvrant le sommet cible avec les <code>radiusofeffect</code> <code>pullvalue</code> et <code>radiusofeffect</code> . </li><li>  Sinon, le temps est écoulé.  Ajoutez-en un à <code>currentIndex</code> . </li><li>  Vérifiez si <code>currentIndex</code> partie des <code>selectedIndices</code> .  Accédez au sommet suivant de la liste à l'aide de <code>StartDisplacement()</code> . </li><li>  Sinon, à la fin de la liste, remplacez les données <code>oMesh</code> par le maillage actuel et <code>isAnimate</code> sur false pour arrêter l'animation. </li></ol><br>  Dans <code>DisplaceVertices()</code> ajoutez les éléments suivants: <br><br><pre> <code class="cs hljs">Vector3 currentVertexPos = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqrRadius = radius * radius; <span class="hljs-comment"><span class="hljs-comment">//1 for (int i = 0; i &lt; mVertices.Length; i++) //2 { currentVertexPos = mVertices[i]; float sqrMagnitute = (currentVertexPos - targetVertexPos).sqrMagnitude; //3 if (sqrMagnitute &gt; sqrRadius) { continue; //4 } float distance = Mathf.Sqrt(sqrMagnitute); //5 float falloff = GaussFalloff(distance, radius); Vector3 translate = (currentVertexPos * force) * falloff; //6 translate.z = 0f; Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(currentVertexPos); } oMesh.vertices = mVertices; //7 oMesh.RecalculateNormals();</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Le carré du rayon. </li><li>  Nous parcourons chaque sommet du maillage. </li><li>  <code>sqrMagnitude</code> entre <code>currentVertexPos</code> et <code>targetVertexPos</code> . </li><li>  Si <code>sqrMagnitude</code> dépasse <code>sqrRadius</code> , passez au sommet suivant. </li><li>  Sinon, continuez en définissant la valeur d' <code>falloff</code> , qui dépend de la <code>distance</code> sommet actuel par rapport au point central de l'oscilloscope. </li><li>  <code>Vector3</code> nouvelle position de <code>Vector3</code> et appliquez sa transformation au sommet actuel. </li><li>  Lorsque vous quittez la boucle, nous <code>mVertices</code> valeurs <code>mVertices</code> modifiées aux <code>mVertices</code> et <code>mVertices</code> Unity à recalculer les normales. </li></ol><br><blockquote>  <em>Source de technologie Falloff</em> <br>  La formule d'origine est extraite du fichier de package d'actifs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Exemples de procédures</a> , qui peut être téléchargé gratuitement à partir de l'Unity Asset Store. </blockquote><br>  Enregistrez le fichier et revenez à Unity.  Sélectionnez <em>Sphère</em> , accédez au composant <em>HeartMesh</em> et essayez d'ajouter des sommets à la propriété <em>Indices sélectionnés</em> .  Désactivez le <em>mode Édition</em> et cliquez sur <em>Lecture</em> pour voir le résultat de votre travail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1e/527/23b/e1e52723b08453591da6d10a28dbe13d.gif"></div><br>  Essayez les <em>valeurs Radiusofeffect</em> , <em>Pullvalue</em> et <em>Duration</em> pour obtenir des résultats différents.  Lorsque vous êtes prêt, modifiez les paramètres conformément à la capture d'écran ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/c44/082/a63c44082183529e737f287cb746dfd6.png"></div><br>  Cliquez sur <em>Play</em> .  Votre sphère s'est-elle transformée en cœur? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif"></div><br>  Félicitations!  Dans la section suivante, nous enregistrerons le maillage en tant que préfabriqué pour une utilisation future. <br><br><h3>  Sauvegarde du maillage en temps réel </h3><br>  Pour enregistrer un maillage procédural en forme de cœur en mode Lecture, vous devez préparer un préfabriqué dont l'enfant sera un objet 3D, puis remplacer son actif de maillage par un nouveau à l'aide d'un script. <br><br>  Dans la fenêtre <em>Projet,</em> recherchez <em>CustomHeart</em> dans le dossier <em>Prefabs</em> .  Cliquez sur l'icône de flèche pour développer son contenu et sélectionnez <em>Enfant</em> .  Vous voyez maintenant un objet Sphère dans la fenêtre d'aperçu de l' <em>inspecteur</em> .  Il s'agit du préfabriqué qui stockera les données du nouveau maillage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f07/048/9a3f070486f3a66ee56304dae5bd2b12.png"></div><br>  Ouvrez <em>HeartMeshInspector.cs</em> .  Dans la fonction <code>OnInspectorGUI()</code> , avant le crochet de fermeture, ajoutez ce qui suit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mesh.isEditMode &amp;&amp; mesh.isMeshReady) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Prefabs/CustomHeart.prefab"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 if (GUILayout.Button("Save Mesh")) { mesh.isMeshReady = false; Object pfObj = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)); //2 Object pfRef = AssetDatabase.LoadAssetAtPath (path, typeof(GameObject)); GameObject gameObj = (GameObject)PrefabUtility.InstantiatePrefab(pfObj); Mesh pfMesh = (Mesh)AssetDatabase.LoadAssetAtPath(path, typeof(Mesh)); //3 if (!pfMesh) { pfMesh = new Mesh(); } else { pfMesh.Clear(); } pfMesh = mesh.SaveMesh(); //4 AssetDatabase.AddObjectToAsset(pfMesh, path); gameObj.GetComponentInChildren&lt;MeshFilter&gt;().mesh = pfMesh; //5 PrefabUtility.ReplacePrefab(gameObj, pfRef, ReplacePrefabOptions.Default); //6 Object.DestroyImmediate(gameObj); //7 } }</span></span></code> </pre> <br>  Explication du code: <br><br><ol><li>  Définit le <code>path</code> d' <code>path</code> au <code>path</code> d'accès à l'objet <em>préfabriqué</em> CustomHeart. </li><li>  Crée deux objets à partir du <em>préfabriqué</em> CustomHeart, un pour créer une instance en tant que GameObject ( <code>pfObj</code> ) et le second en tant que liens ( <code>pfRef</code> ). </li><li>  Crée <em>une</em> instance de l'actif de maillage <code>pfMesh</code> .  S'il n'est pas trouvé, crée un nouveau maillage, sinon il nettoie les données existantes. </li><li>  <code>pfMesh</code> avec de nouvelles données de maillage, puis l'ajoute en tant qu'actif à <em>CustomHeart</em> . <br></li><li>  Remplit un actif maillé dans <code>gameObj</code> valeur <code>pfMesh</code> . </li><li>  Remplace <em>CustomHeart</em> par <code>gameObj</code> faisant correspondre les connexions préexistantes. </li><li>  <code>gameObj</code> instantanément <code>gameObj</code> . </li></ol><br>  Enregistrez le fichier et accédez à <em>HeartMesh.cs</em> .  Dans la <code>SaveMesh()</code> générale <code>SaveMesh()</code> , après avoir créé l'instance <code>nMesh</code> ajoutez ce qui suit: <br><br><pre> <code class="cs hljs">nMesh.name = <span class="hljs-string"><span class="hljs-string">"HeartMesh"</span></span>; nMesh.vertices = oMesh.vertices; nMesh.triangles = oMesh.triangles; nMesh.normals = oMesh.normals;</code> </pre> <br>  Explication du code: renvoie un actif de maillage avec des valeurs provenant d'un maillage en forme de cœur. <br><br>  Enregistrez le fichier et revenez à Unity.  Cliquez sur <em>Lecture</em> .  Une fois l'animation terminée, le bouton <em>Enregistrer le maillage</em> apparaît dans l' <em>inspecteur</em> .  Cliquez sur le bouton pour enregistrer le nouveau maillage, puis arrêtez le lecteur. <br><br>  Accédez au dossier <em>Prefabs</em> et examinez le <em>préfabriqué</em> CustomHeart.  Vous devriez voir que maintenant dans l'objet <em>préfabriqué</em> CustomHeart il y a un tout nouveau maillage en forme de coeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/126/dee/103/126dee103ce798611d2dc2e94013c23c.png"></div><br>  <i>Excellent travail!</i> <br><br><h2>  Tout mettre ensemble </h2><br>  Dans la scène précédente, la fonction <code>DisplaceVertices()</code> utilisé la formule Falloff pour déterminer la force de traînée qui a été appliquée à chaque sommet dans un rayon donné.  Le point de «chute», auquel la force de traînée commence à diminuer, dépend du type de chute utilisé: linéaire, gaussien ou aiguille.  Chaque type produit des résultats différents dans le maillage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/284/9c0/9ff2849c0d0fe5f9d496d641c07e35d8.png"></div><br>  Dans cette section, nous verrons une autre façon de manipuler les sommets: en utilisant une courbe donnée.  En supposant que la vitesse est égale à la distance divisée par le temps (d = (v / t)), nous pouvons déterminer la position du vecteur, en se référant à sa distance divisée par le temps. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/2d6/13c/3b82d613cedaf85e12db66beb6349201.gif"></div><br><h3>  Utilisation de la méthode de courbe </h3><br>  Enregistrez la scène actuelle et ouvrez <em>03 Customize Heart Mesh</em> dans le dossier <em>Scenes</em> .  Vous verrez une instance de <em>hiérarchie</em> du <em>préfabriqué</em> CustomHeart.  Cliquez sur l'icône en forme de flèche à côté pour développer son contenu et sélectionnez <em>Enfant</em> . <br><br>  Affichez ses propriétés dans l' <em>inspecteur</em> .  Vous verrez le composant <em>Filtre de maillage</em> avec l'actif de <em>maillage Heart</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attachez </font><font style="vertical-align: inherit;">un script </font><em><font style="vertical-align: inherit;">Heart personnalisé</font></em><font style="vertical-align: inherit;"> à </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Child en</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tant que composant </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, l'actif devrait passer de </font><em><font style="vertical-align: inherit;">HeartMesh</font></em><font style="vertical-align: inherit;"> à </font><em><font style="vertical-align: inherit;">cloner</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/27f/89d/95427f89d17410e26893a0ec27dff51d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, ouvrez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart.cs à</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir du dossier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scripts</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Avant la fonction, </font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoutez ce qui suit:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurveType { Curve1, Curve2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CurveType curveType; Curve curve;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explication du code: ici une énumération générale est créée sous le nom </font></font><code>CurveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, après quoi elle est mise à disposition par l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspecteur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accédez à </font></font><code>CurveType1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutez les éléments suivants:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 1, 0); curvepoints[1] = new Vector3(0.5f, 0.5f, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explication du code: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une courbe simple se compose de trois points. </font><font style="vertical-align: inherit;">Définissez les points de la première courbe.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous générons la première courbe avec l'aide </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et attribuons ses valeurs </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La courbe dessinée peut être affichée dans l'aperçu si vous spécifiez true comme dernier paramètre.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accédez à </font></font><code>CurveType2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutez les éléments suivants:</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 0, 0); curvepoints[1] = new Vector3(0.5f, 1, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explication du code: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Définissez les points de la deuxième courbe. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous générons la deuxième courbe avec </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et attribuons ses valeurs </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La courbe dessinée peut être affichée dans l'aperçu si vous spécifiez true comme dernier paramètre.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>StartDisplacement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avant le crochet de fermeture, ajoutez ce qui suit:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve1) { CurveType1(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve2) { CurveType2(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explication du code: ici nous vérifions l'option sélectionnée par l'utilisateur </font></font><code>curveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la générons en conséquence </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>DisplaceVertices()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à l'intérieur de l'instruction de boucle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant les crochets de fermeture, ajoutez ce qui suit:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> increment = curve.GetPoint(distance).y * force; <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 translate = (vert * increment) * Time.deltaTime; //2 Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(mVertices[i]);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explication du code: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous </font><font style="vertical-align: inherit;">obtenons la </font><font style="vertical-align: inherit;">position de la courbe à celle donnée </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et multiplions sa valeur </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour obtenir </font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un nouveau type de données </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour stocker la nouvelle position du sommet actuel et appliquez sa transformation en conséquence.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrez le fichier et revenez à Unity. </font><font style="vertical-align: inherit;">Vérifiez les propriétés du composant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objet jeu d' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enfants</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous verrez une liste déroulante où vous pouvez sélectionner le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type de courbe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans la liste déroulante </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifier le type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">sélectionnez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter des indices</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimer des indices</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour mettre à jour la liste des sommets et expérimenter différents paramètres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/1a7/3b6/7921a73b676b205bd33ec1db076cd4a6.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour voir des résultats détaillés pour différents types de courbes, entrez les valeurs selon la capture d'écran: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/ab3/e5d/e06ab3e5d0bfc950be0c6dbc82d36f6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour la liste </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curve Type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">sélectionnez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curve1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , assurez-vous que </font><em><font style="vertical-align: inherit;">None est</font></em><font style="vertical-align: inherit;"> sélectionné </font><font style="vertical-align: inherit;">pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edit Type,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puis cliquez sur </font><em><font style="vertical-align: inherit;">Play</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous devriez voir le maillage diverger dans le motif. </font><font style="vertical-align: inherit;">Faites rouler le modèle pour le voir en vue latérale et comparez les résultats pour les deux types de courbes. </font><font style="vertical-align: inherit;">Vous voyez ici comment le </font><em><font style="vertical-align: inherit;">type de courbe</font></em><font style="vertical-align: inherit;"> sélectionné </font><font style="vertical-align: inherit;">affecte le décalage du maillage.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f90/4d5/8e1f904d50987247014011ac32261134.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da0/e1a/df4/da0e1adf49f8503188f47826c4079cf1.png"></div><br>  C'est tout!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez cliquer sur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effacer les sommets sélectionnés</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour réinitialiser les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indices sélectionnés</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et expérimenter avec vos propres motifs. </font><font style="vertical-align: inherit;">Mais n'oubliez pas qu'il existe d'autres facteurs qui affecteront le résultat final du maillage, à savoir:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La valeur du rayon. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La distribution des sommets dans la zone. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position du motif des sommets sélectionnés. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La méthode sélectionnée pour le décalage. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Où aller ensuite? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fichiers du projet terminé sont dans les </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archives du projet de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutoriel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne vous arrêtez pas là! </font><font style="vertical-align: inherit;">Essayez les techniques plus sophistiquées utilisées </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> didacticiel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Unity Procedural Maze Generation</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espère que vous avez apprécié ce didacticiel et que les informations vous ont été utiles. </font><font style="vertical-align: inherit;">Un grand </font><font style="vertical-align: inherit;">merci que </font><font style="vertical-align: inherit;">j'exprime </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jasper Flick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catlike de </font><font style="vertical-align: inherit;">codage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ses excellents tutoriels qui m'a aidé à </font><font style="vertical-align: inherit;">assembler une démo pour mon projet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/190/e37/362/190e3736241796c39eac74bbe3ddc86e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428796/">https://habr.com/ru/post/fr428796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428786/index.html">Processeur quantique basé sur la résonance de spin et les manipulations avec un système singlet-triplet</a></li>
<li><a href="../fr428788/index.html">Sous le capot de Bitfury Clarke - comment fonctionne notre nouvelle puce minière</a></li>
<li><a href="../fr428790/index.html">Nous écrivons un chat bot pour VKontakte en python en utilisant longpoll. Deuxième partie Boucles doubles, exceptions et autres hérésies</a></li>
<li><a href="../fr428792/index.html">La nouvelle puce Apple T2 rend difficile l'écoute via le microphone intégré de l'ordinateur portable</a></li>
<li><a href="../fr428794/index.html">Présentation des méthodes de base d'optimisation mathématique pour les problèmes de contraintes</a></li>
<li><a href="../fr428798/index.html">Comment survivre à un développeur indépendant. 2e partie</a></li>
<li><a href="../fr428800/index.html">Cooking Perfect CSS</a></li>
<li><a href="../fr428806/index.html">Analyse des chèques de consommation: ce qu'ils achètent sur Amazon</a></li>
<li><a href="../fr428808/index.html">Peu de commodité dans la vie étudiante</a></li>
<li><a href="../fr428810/index.html">18 documents sur la technologie numérique dans l'audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>