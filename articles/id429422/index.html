<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏 ✂️ 🈺 UHCI, atau USB pertama 🛤️ 🚱 🧜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, pembaca yang budiman! Saya diminta untuk menulis tentang UHCI - well, saya menulis. 

 Anda mungkin menemukan artikel ini berguna jika,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UHCI, atau USB pertama</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429422/"><img src="https://habrastorage.org/webt/89/wk/ye/89wkyeuwi_jbnzlge2bawtlabum.png"><br><br>  Selamat siang, pembaca yang budiman!  Saya diminta untuk menulis tentang UHCI - well, saya menulis. <br><br>  Anda mungkin menemukan artikel ini berguna jika, misalnya, Anda tidak memiliki keterampilan menulis yang cukup untuk driver dan membaca dokumentasi untuk perangkat keras.  Contoh sederhana: Anda ingin menulis OS untuk mini-PC, sehingga beberapa Windows atau distribusi Linux lainnya tidak mengunduh perangkat keras, dan Anda menggunakan semua kekuatannya secara eksklusif untuk keperluan Anda sendiri. <br><a name="habracut"></a><br><h2>  Apa itu UHCI? </h2><br>  Saya pikir, agar tidak menyemprot lagi pada topik apa dan mengapa, tinggalkan saja tautan ke artikel saya sebelumnya tentang EHCI.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aduk di sini</a> <br>  UHCI - Universal Host Controller Interface, beroperasi sebagai perangkat PCI, tetapi, tidak seperti EHCI menggunakan port, bukan MMIO (Memory-Mapped-IO). <br><br><img src="https://habrastorage.org/webt/nk/bl/--/nkbl--cqrxvs21lcitfothfcw4k.png"><br><br><h2>  Ketentuan untuk digunakan selanjutnya </h2><br><ul><li>  Driver USB (USBD) - driver USB itu sendiri </li><li>  HC (Host Controller) - pengendali host, atau hanya UHCI kami </li><li>  Host Controller Driver (HCD) - driver yang menghubungkan perangkat keras dan USBD </li><li>  Perangkat USB - perangkat USB itu sendiri </li></ul><br><h2>  Jenis-jenis Transfer Data </h2><br>  Isochronous - transmisi isosynchronous, yang memiliki frekuensi transfer data tertentu.  Ini dapat digunakan, misalnya, untuk mikrofon USB, dll. <br><br>  Interrupt - Kecil, transfer data spontan dari suatu perangkat.  Jenis transmisi interupsi mendukung perangkat yang memerlukan interval layanan yang dapat diprediksi tetapi tidak selalu menyediakan aliran data yang dapat diprediksi.  Biasa digunakan untuk perangkat seperti papan ketik dan perangkat penunjuk yang mungkin tidak menyediakan data untuk jangka waktu yang lama, tetapi memerlukan respons cepat ketika mereka memiliki data untuk dikirim. <br><br>  Kontrol - Jenis pengiriman informasi tentang status perangkat, status dan konfigurasi.  Jenis transfer Kontrol digunakan untuk menyediakan saluran kontrol dari Host ke perangkat USB.  Transmisi kontrol selalu terdiri dari fase pengaturan dan nol atau lebih fase data diikuti oleh fase status.  Sangat penting bahwa kontrol transfer ke titik akhir yang diberikan diproses dalam mode FIFO.  Jika kontrol dilewatkan ke titik akhir yang sama, interleaving dapat menyebabkan perilaku yang tidak terduga. <br><br>  Jenis transfer array data secara massal.  Digunakan, misalnya, di perangkat MassStorage. <br><br><img src="https://habrastorage.org/webt/j1/d5/4a/j1d54aqfs0iicr_-dfpmkwx8d_e.png"><br><br>  Ini adalah bagaimana distribusi waktu 1ms terlihat seperti - pemrosesan satu frame. <br><br><h2>  Distribusi waktu </h2><br>  Pengontrol host mendukung pengiriman data real-time dengan menghasilkan paket Start Of Frame (SOF) setiap 1 ms.  Paket SOF dihasilkan ketika penghitung SOF di pengontrol host kedaluwarsa (Gambar 3).  Pengontrol host menginisialisasi penghitung SOF untuk waktu bingkai 1 ms.  Perubahan kecil dapat dibuat untuk nilai ini (dan karenanya periode waktu bingkai) dengan memprogram register perubahan SOF.  Fitur ini memungkinkan Anda untuk membuat perubahan kecil pada periode waktu bingkai, jika perlu, untuk mempertahankan sinkronisasi waktu nyata di seluruh sistem USB. <br><br>  Pengontrol host menyertakan nomor bingkai di setiap paket SOF.  Nomor bingkai ini secara unik menentukan periode bingkai secara real time.  Kondisi akhir bingkai (EOF) terjadi pada akhir interval waktu 1 ms ketika pengendali host memulai waktu bingkai berikutnya, menghasilkan paket SOF lain dengan nomor bingkai yang sesuai.  Selama periode frame, data ditransmisikan sebagai paket informasi.  Periode waktu frame diberlakukan secara ketat oleh pengontrol host, dan paket data dalam frame saat ini tidak dapat melampaui EOF (lihat Bab 11 dalam spesifikasi USB).  Pengendali host mendukung sinkronisasi pengiriman data antara frame secara real time, menghubungkan nomor frame untuk melakukan entri tertentu dalam daftar frame.  Penghitung bingkai pengontrol host menghasilkan nomor bingkai (nilai 11-bit) dan memasukkannya ke dalam setiap paket SOF.  Penghitung diprogram melalui register dan setiap periode frame bertambah.  Pengontrol host menggunakan 10 bit lebih rendah dari jumlah frame sebagai indeks dalam daftar frame dengan 1024 frame, yang disimpan dalam memori sistem.  Jadi, karena penghitung bingkai mengontrol pemilihan entri dari daftar bingkai, pengontrol host memproses setiap entri dalam daftar dalam periode bingkai yang diberikan.  Pengontrol host memperluas ke entri berikutnya dalam daftar bingkai untuk setiap bingkai baru.  Ini memastikan bahwa transmisi isochronous dilakukan dalam bingkai tertentu. <br><br>  Gambar 3: <br><br><img src="https://habrastorage.org/webt/d8/pj/iw/d8pjiwyjanx3yse7tmmtnyeooqe.png"><br><br><h2>  Struktur UHCI </h2><br>  Semuanya persis sama dengan EHCI.  Contoh permintaan ke HC: <br><br><img src="https://habrastorage.org/webt/io/1d/sm/io1dsmtielklqhm84nhekufybj4.png"><br><br><h2>  Konfigurasikan dan akses UHCI </h2><br>  Jadi, seperti yang saya katakan sebelumnya, UHCI bekerja melalui port, jadi dari PCI kita perlu mencari tahu basis register UHCI. <br><br><img src="https://habrastorage.org/webt/gz/ql/3f/gzql3fejuar2ko92q8dnok-ehpi.png"><br><br>  Pada offset 0x20 ada 4 byte - IO Base.  Mengenai Basis IO, kita dapat menggunakan register berikut: <br><br><img src="https://habrastorage.org/webt/jk/a5/od/jka5odl_cbgmqxcdsix8e-1tkl0.png"><br><br><h2>  Register UHCI </h2><br><ul><li>  USBCMD adalah register untuk mengendalikan HC.  Bit: <ul><li>  Bit 6 adalah bendera yang berhasil dikonfigurasikan dan diinisialisasi oleh perangkat. </li><li>  Bit 1 - Reset HC.  Setel untuk mengatur ulang HC. </li><li>  Bit 0 - Run / Stop.  Menampilkan status HC.  1 - bekerja, 0 - tidak. </li></ul></li><li>  USBSTS - Status Register.  Bit: <ul><li>  Bit 5 - HC Dihentikan.  Terjadi kesalahan, atau pengontrol berhasil menyelesaikan HC Reset. </li><li>  Bit 4 - Kesalahan Proses Pengontrol Host.  Bit diatur ke 1 ketika kesalahan kritis telah terjadi dan HC tidak dapat melanjutkan antrian dan TD. </li><li>  Bit 3 - Kesalahan Sistem Host.  Kesalahan PCI. </li><li>  Bit 1 - Interupsi Kesalahan.  Menunjukkan bahwa telah terjadi kesalahan dan HC menghasilkan interupsi. </li><li>  Bit 0 - Interrupt.  Menunjukkan bahwa HC menghasilkan interupsi. </li></ul></li><li>  USBINTR - Daftar pengaturan interupsi.  Bit: <ul><li>  Bit 2 - IOC - Interrupt on complete - menghasilkan interrupt pada akhir transaksi. </li></ul></li><li>  FRNUM - Jumlah bingkai saat ini (Ambil &amp; 0x3FF untuk nilai yang benar). </li><li>  FLBASEADD - Frame List Base Address - alamat dari daftar frame. </li><li>  PORTSC - Status port dan kontrol - status dan register kontrol port.  Bit: <ul><li>  Bit 9 - Port Reset - 1 - port untuk mengatur ulang. </li><li>  Bit 8 - menunjukkan bahwa perangkat berkecepatan rendah terhubung ke port </li><li>  Bit 3 - Menunjukkan bahwa port on state telah berubah </li><li>  Bit 2 - Menunjukkan apakah port diaktifkan </li><li>  Bit 1 - menunjukkan bahwa status perangkat terhubung ke port </li><li>  Bit 0 - menunjukkan bahwa perangkat terhubung ke port. </li></ul></li></ul><br><h2>  Struktur </h2><br><h3>  Pointer daftar penunjuk </h3><br><img src="https://habrastorage.org/webt/oc/y8/a6/ocy8a6is-xd60i9bxmtdjjyqcdy.png"><br><br><h3>  Descrptor transfer </h3><br><img src="https://habrastorage.org/webt/jz/sh/bl/jzshblpig4inzxxtzkzxlmvsvq8.png"><br><br><h5>  KONTROL DAN STATUS TD </h5>  .  Bit: <br><ul><li>  Bit 28-27 - penghitung kesalahan, mirip dengan EHCI. </li><li><ul><li>  Bit 26 - 1 = Perangkat berkecepatan rendah, 0 = Perangkat berkecepatan penuh. </li><li>  Bit 25 - 1 = TD sinkron </li><li>  Bit 24 - IOC </li><li>  Bit 23-16 - Status: </li><li>  Bit 23 - Menunjukkan bahwa itu adalah TD aktif </li><li>  Bit 22 - Stalled </li><li>  Bit 21 - Kesalahan Penyangga Data </li><li>  Bit 20 - Babble Terdeteksi </li><li>  Bit 19 - NAK </li></ul></li><li>  Bit 10-0: Jumlah byte yang dikirimkan oleh pengontrol host. </li></ul><br><h5>  Token TD </h5><br><ul><li>  Bits 31:21 - Max Packet Len, mirip dengan EHCI </li><li>  Bit 19 - Data Toggle, Mirip dengan EHCI </li><li>  Bit 18:15 - Nomor Titik Akhir </li><li>  Bit 18:14 - alamat perangkat </li><li>  Bits 7: 0 - PID.  Dalam = 0x69, Keluar = 0xE1, Pengaturan = 0x2D </li></ul><br><h3>  Kepala antrian </h3><br><img src="https://habrastorage.org/webt/-4/pb/ia/-4pbiakp01iozcmkne4q1tums4i.png"><br><br><h2>  Kode </h2><br>  Inisialisasi dan konfigurasi HC: <br><br><pre><code class="cpp hljs">PciBar bar; PciGetBar(&amp;bar, id, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~bar.flags &amp; PCI_BAR_IO) { <span class="hljs-comment"><span class="hljs-comment">// Only Port I/O supported return; } unsigned int ioAddr = bar.u.port; UhciController *hc = VMAlloc(sizeof(UhciController)); hc-&gt;ioAddr = ioAddr; hc-&gt;frameList = VMAlloc(1024 * sizeof(u32) + 8292); hc-&gt;frameList = ((int)hc-&gt;frameList / 4096) * 4096 + 4096; hc-&gt;qhPool = (UhciQH *)VMAlloc(sizeof(UhciQH) * MAX_QH + 8292); hc-&gt;qhPool = ((int)hc-&gt;qhPool / 4096) * 4096 + 4096; hc-&gt;tdPool = (UhciTD *)VMAlloc(sizeof(UhciTD) * MAX_TD + 8292); hc-&gt;tdPool = ((int)hc-&gt;tdPool / 4096) * 4096 + 4096; memset(hc-&gt;qhPool, 0, sizeof(UhciQH) * MAX_QH); memset(hc-&gt;tdPool, 0, sizeof(UhciTD) * MAX_TD); memset(hc-&gt;frameList, 0, 4 * 1024); // Frame list setup UhciQH *qh = UhciAllocQH(hc); qh-&gt;head = TD_PTR_TERMINATE; qh-&gt;element = TD_PTR_TERMINATE; qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;asyncQH = qh; for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = 2 | (u32)(uintptr_t)qh; IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); IoWrite16(hc-&gt;ioAddr + REG_CMD, IoRead16(hc-&gt;ioAddr + REG_CMD)&amp;(~1)); unsigned short cfg = PciRead16(id, 4); PciWrite16(id, 4, cfg &amp; (~1)); PciWrite16(id, 0x20, (short)-1); unsigned short size = ~(PciRead16(id, 0x20)&amp;(~3)) + 1; PciWrite16(id, 0x20, hc-&gt;ioAddr); PciWrite16(id, 4, cfg | 5); // Disable Legacy Support IoWrite16(hc-&gt;ioAddr + REG_LEGSUP, 0x8f00); // Disable interrupts IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); // Assign frame list IoWrite16(hc-&gt;ioAddr + REG_FRNUM, 0); IoWrite32(hc-&gt;ioAddr + REG_FRBASEADD, (int)hc-&gt;frameList); IoWrite16(hc-&gt;ioAddr + REG_SOFMOD, 0x40); // Clear status IoWrite16(hc-&gt;ioAddr + REG_STS, 0xffff); // Enable controller IoWrite16(hc-&gt;ioAddr + REG_CMD, 0x1); // Probe devices UhciProbe(hc, size);</span></span></code> </pre> <br>  Permintaan titik akhir dan kontrol: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static void UhciDevControl(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = 0; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { return; } UhciTD *head = td; UhciTD *prev = 0; // Setup packet uint toggle = 0; uint packetType = TD_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_IN : TD_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; while (it &lt; end) { td = UhciAllocTD(hc); if (!td) { return; } toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) { packetSize = maxSize; } UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet td = UhciAllocTD(hc); if (!td) { return; } toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_OUT : TD_PACKET_IN; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, 0, 0); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Wait until queue has been processed UhciInsertQH(hc, qh); UhciWaitForQH(hc, qh); } // ------------------------------------------------------------------------------------------------ static void UhciDevIntr(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } UhciTD *head = td; UhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = TD_PACKET_IN; //Here for compiler, on some last expression hadn't worked if (t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80) packetType = TD_PACKET_IN; else packetType = TD_PACKET_OUT; uint packetSize = t-&gt;len; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Schedule queue UhciInsertQH(hc, qh); if(t-&gt;w) UhciWaitForQH(hc, qh); }</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429422/">https://habr.com/ru/post/id429422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../hi434972/index.html">अगर आपको ऐसा महसूस नहीं होता है तो यूनिट टेस्ट कैसे लिखें</a></li>
<li><a href="../hi434974/index.html">कॉन्फ़िगरेशन 1 सी के प्रारूप के साथ काम करें: एंटरप्राइज</a></li>
<li><a href="../hi434976/index.html">आईटीएमओ यूनिवर्सिटी फैबलैब: रचनात्मक लोगों के लिए DIY-सहकर्मियों - शो के अंदर क्या है</a></li>
<li><a href="../hi434978/index.html">पेश है HealthKit</a></li>
<li><a href="../id429420/index.html">PlayStation Classic menggunakan emulator PCSX ReARMed untuk operasi, tidak ada solusi eksklusif</a></li>
<li><a href="../id429424/index.html">Robotaxi dari Daimler dan Bosch akan muncul di California</a></li>
<li><a href="../id429426/index.html">QGIS dan ekspor ubin</a></li>
<li><a href="../id429448/index.html">Kami menulis pemuat FPGA di LabVIEW. Bagian 2</a></li>
<li><a href="../id429450/index.html">Teknik pemrograman umum di Rust: bagaimana kami menerjemahkan Exonum dari Iron ke actix-web</a></li>
<li><a href="../id429452/index.html">Pentagon mulai mendeklasifikasi malware orang lain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>