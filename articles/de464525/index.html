<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèª üßùüèæ ‚ûï Ihr eigener JSON-Konverter oder etwas mehr √ºber ExpressionTrees üëµüèΩ üé° üë©üèΩ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serialisierung und Deserialisierung sind typische Vorg√§nge, die der moderne Entwickler als trivial betrachtet. Wir kommunizieren mit Datenbanken, gene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ihr eigener JSON-Konverter oder etwas mehr √ºber ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464525/"><img src="https://habrastorage.org/webt/ud/qn/kd/udqnkdpyauh-0k7h5d-g_hgzrys.png"><br><br>  Serialisierung und Deserialisierung sind typische Vorg√§nge, die der moderne Entwickler als trivial betrachtet.  Wir kommunizieren mit Datenbanken, generieren HTTP-Anforderungen, empfangen Daten √ºber die REST-API und denken oft nicht einmal dar√ºber nach, wie dies funktioniert.  Heute schlage ich vor, meinen Serializer und Deserializer f√ºr JSON zu schreiben, um herauszufinden, was sich unter der Haube befindet. <br><a name="habracut"></a><br><h2>  Haftungsausschluss </h2><br>  Wie beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal</a> werde ich feststellen: Wir werden einen primitiven Serializer schreiben, man k√∂nnte sagen, ein Fahrrad.  Wenn Sie eine schl√ºsselfertige L√∂sung ben√∂tigen, verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.NET</a> .  Diese Jungs haben ein wundervolles Produkt ver√∂ffentlicht, das hochgradig anpassbar ist, viel kann und <i>bereits Probleme l√∂st</i> , die bei der Arbeit mit JSON auftreten.  Die Verwendung Ihrer eigenen L√∂sung ist wirklich cool, aber nur, wenn Sie maximale Leistung, spezielle Anpassungen ben√∂tigen oder Fahrr√§der so m√∂gen, wie ich sie mag. <br><br><h2>  Themenbereich </h2><br>  Der Dienst zum Konvertieren von JSON in eine Objektdarstellung besteht aus mindestens zwei Subsystemen.  Deserializer ist ein Subsystem, das g√ºltigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON</a> (Text) in eine Objektdarstellung in unserem Programm verwandelt.  Die Deserialisierung umfasst die Tokenisierung, dh das Parsen von JSON in logische Elemente.  Serializer ist ein Subsystem, das die inverse Aufgabe ausf√ºhrt: Verwandelt die Objektdarstellung von Daten in JSON. <br><br>  Der Verbraucher sieht am h√§ufigsten die folgende Schnittstelle.  Ich habe es bewusst vereinfacht, um die wichtigsten Methoden hervorzuheben, die am h√§ufigsten verwendet werden. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span> { T Deserialize&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Unter der Haube umfasst die Deserialisierung die Tokenisierung (Parsen eines JSON-Textes) und das Erstellen einiger Grundelemente, die das sp√§tere Erstellen einer Objektdarstellung erleichtern.  Zu Schulungszwecken √ºberspringen wir die Konstruktion von Zwischenprimitiven (z. B. JObject, JProperty von Json.NET) und schreiben sofort Daten in das Objekt.  Dies ist ein Minus, da es die Anpassungsoptionen reduziert, es jedoch unm√∂glich ist, eine gesamte Bibliothek im Rahmen eines Artikels zu erstellen. <br><br><h2>  Tokenisierung </h2><br>  Ich m√∂chte Sie daran erinnern, dass der Prozess der Tokenisierung oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikalischen Analyse</a> eine Analyse des Textes ist, um eine andere, strengere Darstellung der darin enthaltenen Daten zu erhalten.  In der Regel wird diese Darstellung als <b>Token</b> oder Token bezeichnet.  Zum Parsen von JSON m√ºssen die Eigenschaften, ihre Werte, die Symbole f√ºr den Anfang und das Ende von Strukturen hervorgehoben werden, dh Token, die im Code als JsonToken dargestellt werden k√∂nnen. <br><br>  <a href="">JsonToken</a> ist eine Struktur, die einen Wert (Text) sowie eine Art Token enth√§lt.  JSON ist eine strikte Notation, sodass alle Arten von Token auf die <a href="">n√§chste Aufz√§hlung</a> reduziert werden k√∂nnen.  Nat√ºrlich w√§re es sch√∂n, dem Token seine Koordinaten in den eingehenden Daten (Zeile und Spalte) hinzuzuf√ºgen, aber das Debuggen geht √ºber den Rahmen der Implementierung hinaus, was bedeutet, dass JsonToken diese Daten nicht enth√§lt. <br><br>  Der einfachste Weg, Text in Token zu analysieren, besteht darin, jedes Zeichen nacheinander zu lesen und mit Mustern zu vergleichen.  Wir m√ºssen verstehen, was dieses oder jenes Symbol bedeutet.  Es ist m√∂glich, dass das Schl√ºsselwort (wahr, falsch, null) mit diesem Zeichen beginnt, dass dies m√∂glicherweise der Anfang der Zeile ist (Anf√ºhrungszeichen), oder dass dieses Zeichen selbst ein Token ist ([,], {,}).  Die allgemeine Idee sieht so aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tokens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;JsonToken&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; json.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = json[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ch) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayStart)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayEnd)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = ReadString(); tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.String, stringValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br>  Wenn Sie sich den Code ansehen, scheinen Sie die gelesenen Daten lesen und sofort etwas damit anfangen zu k√∂nnen.  Sie m√ºssen nicht gelagert werden, sondern m√ºssen sofort an den Verbraucher gesendet werden.  Daher bittet ein bestimmter IEnumerator, der den Text in St√ºcke zerlegt.  Erstens wird dadurch die Zuordnung verringert, da keine Zwischenergebnisse (ein Array von Token) gespeichert werden m√ºssen.  Zweitens werden wir die Arbeitsgeschwindigkeit erh√∂hen - ja, in unserem Beispiel ist die Eingabe eine Zeichenfolge, aber in einer realen Situation wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie durch Stream</a> (aus einer Datei oder einem Netzwerk) ersetzt, den wir nacheinander lesen. <br><br>  Ich habe den <b>JsonTokenizer-</b> Code vorbereitet, den <b>Sie</b> <a href="">hier finden</a> .  Die Idee ist dieselbe - der Tokenizer geht nacheinander entlang der Linie und versucht festzustellen, worauf sich das Symbol oder seine Reihenfolge bezieht.  Wenn sich herausstellt, dass es verstanden wird, erstellen wir ein Token und √ºbertragen die Kontrolle an den Verbraucher.  Wenn es noch nicht klar ist, lesen Sie weiter. <br><br><h2>  Vorbereiten der Deserialisierung von Objekten </h2><br>  In den meisten <b>F√§llen</b> handelt es sich bei einer Anforderung zum Konvertieren von Daten aus JSON um einen Aufruf der generischen Deserialize-Methode, wobei <b>TOut</b> der Datentyp ist, mit dem JSON-Token zugeordnet werden sollen.  Wo <a href="">Typ ist</a> : Es ist Zeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflection</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> anzuwenden.  Die Grundlagen der Arbeit mit ExpressionTrees sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Gr√ºnde,</a> warum kompilierte Ausdr√ºcke besser sind als "nackte" Reflexion, habe ich in einem fr√ºheren Artikel beschrieben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Sie Ihren AutoMapper erstellen</a> .  Wenn Sie nichts √ºber Expression.Labmda.Compile () wissen, empfehle ich, es zu lesen.  Am Beispiel des Mappers scheint es mir verst√§ndlich geworden zu sein. <br><br>  Der Plan zum Erstellen eines Objektdeserialisierers basiert also auf dem Wissen, dass wir jederzeit Eigenschaftstypen aus dem TOut-Typ abrufen k√∂nnen, dh aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo-</a> Auflistung.  Gleichzeitig werden Eigenschaftstypen durch die JSON-Notation begrenzt: Zahlen, Zeichenfolgen, Arrays und Objekte.  Auch wenn wir Null nicht vergessen, ist dies nicht so sehr, wie es auf den ersten Blick scheinen mag.  Und wenn wir f√ºr jeden primitiven Typ gezwungen sind, einen separaten Deserializer zu erstellen, k√∂nnen wir f√ºr Arrays und Objekte generische Klassen erstellen.  Wenn Sie ein wenig nachdenken, k√∂nnen alle Serializer-Deserializer (oder <b>Konverter</b> ) auf die folgende Schnittstelle reduziert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JsonTokenizer tokenizer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StringBuilder builder</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Der Code eines stark typisierten Konverters primitiver Typen ist so einfach wie m√∂glich: Wir extrahieren das aktuelle JsonToken aus dem Tokenizer und wandeln es durch Parsen in einen Wert um.  Zum Beispiel float.Parse (currentToken.Value).  Schauen Sie sich <a href="">BoolConverter</a> oder <a href="">FloatConverter an</a> - nichts Kompliziertes.  Als n√§chstes, wenn Sie einen Deserializer f√ºr Bool ben√∂tigen?  oder float? kann es auch hinzugef√ºgt werden. <br><br><h2>  Array-Deserialisierung </h2><br>  <a href="">Der generische Klassencode</a> zum Konvertieren eines Arrays aus JSON ist ebenfalls relativ einfach.  Es wird durch den Elementtyp parametrisiert, den wir extrahieren k√∂nnen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TypE</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GetElementType ()</a> .  Das Bestimmen, dass ein Typ ein Array ist, ist ebenfalls einfach: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Type.IsArray</a> .  Bei der Array-Deserialisierung wird tokenizer.MoveNext () angezeigt, bis ein Token vom Typ ArrayEnd erreicht ist.  Die Deserialisierung von Array-Elementen ist die Deserialisierung des Array-Elementtyps. Daher wird beim Erstellen eines ArrayConverter der Element-Deserializer an diesen √ºbergeben. <br><br>  Manchmal gibt es Schwierigkeiten bei der Instanziierung generischer Implementierungen, daher werde ich Ihnen sofort erkl√§ren, wie es geht.  Mit Reflection k√∂nnen Sie generische Typen in Echtzeit erstellen. Dies bedeutet, dass wir den erstellten Typ als Argument f√ºr Activator.CreateInstance verwenden k√∂nnen.  Nutzen Sie dies: <br><br><pre> <code class="cs hljs">Type elementType = arrayType.GetElementType(); Type converterType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ArrayConverter&lt;&gt;).MakeGenericType(elementType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> converterInstance = Activator.CreateInstance(converterType, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args);</code> </pre><br>  Wenn Sie die Vorbereitungen zum Erstellen eines Deserialisierers f√ºr Objekte abgeschlossen haben, k√∂nnen Sie den gesamten Infrastrukturcode f√ºr die Erstellung und Speicherung von Deserialisierern in die Fassade von <a href="">JConverter einf√ºgen</a> .  Er wird f√ºr alle JSON-Serialisierungs- und Deserialisierungsvorg√§nge verantwortlich sein und steht den Verbrauchern als Service zur Verf√ºgung. <br><br><h2>  Objektdeserialisierung </h2><br>  Ich m√∂chte Sie daran erinnern, dass Sie alle Eigenschaften des Typs T wie folgt erhalten k√∂nnen: typeof (T) .GetProperties ().  F√ºr jede Eigenschaft k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.PropertyType</a> extrahieren, wodurch wir die M√∂glichkeit haben, einen typisierten IJsonConverter zum Serialisieren und Deserialisieren von Daten eines bestimmten Typs zu erstellen.  Wenn der Typ der Eigenschaft ein Array ist, instanziieren wir den ArrayConverter oder finden einen geeigneten unter den vorhandenen.  Wenn der Eigenschaftstyp ein primitiver Typ ist, werden im JConverter-Konstruktor bereits Deserialisierer (Konverter) f√ºr sie erstellt. <br><br>  Der resultierende Code kann in der generischen Klasse <a href="">ObjectConverter</a> angezeigt werden.  In seinem Konstruktor wird ein Aktivator erstellt, Eigenschaften werden aus einem speziell vorbereiteten W√∂rterbuch extrahiert und f√ºr jedes von ihnen wird eine Deserialisierungsmethode erstellt - Aktion &lt;TObject, JsonTokenizer&gt;.  Dies ist zum einen erforderlich, um den IJsonConverter sofort mit der gew√ºnschten Eigenschaft zu verkn√ºpfen, und zum anderen, um beim Extrahieren und Schreiben primitiver Typen ein Boxen zu vermeiden.  Jede Deserialisierungsmethode wei√ü, welche Eigenschaft des ausgehenden Objekts aufgezeichnet wird, der Deserialisierer des Werts wird streng typisiert und gibt den Wert genau in der Form zur√ºck, in der er ben√∂tigt wird. <br><br>  Die Bindung eines IJsonConverter an eine Eigenschaft lautet wie folgt: <br><br><pre> <code class="cs hljs">Type converterType = propertyValueConverter.GetType(); ConstantExpression Expression.Constant(propertyValueConverter, converterType); MethodInfo deserializeMethod = converterType.GetMethod(<span class="hljs-string"><span class="hljs-string">"Deserialize"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Expression.Call(converter, deserializeMethod, tokenizer);</code> </pre><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Expression.Constant-</a> Konstante wird direkt im Ausdruck erstellt, in dem ein Verweis auf die Deserializer-Instanz f√ºr den Eigenschaftswert gespeichert ist.  Dies ist nicht genau die Konstante, die wir in "regul√§res C #" schreiben, da sie einen Referenztyp speichern kann.  Als n√§chstes wird die Deserialize-Methode vom Deserializer-Typ abgerufen, der den Wert des gew√ºnschten Typs zur√ºckgibt, und dann hei√üt sie - <a href="">Expression.Call</a> .  So erhalten wir eine Methode, die genau wei√ü, wo und was zu schreiben ist.  Es bleibt, es in das W√∂rterbuch aufzunehmen und es aufzurufen, wenn ein Token vom Typ Eigenschaft mit dem gew√ºnschten Namen vom Tokenizer "kommt".  Ein weiteres Plus ist, dass alles sehr schnell funktioniert. <br><br><h2>  Wie schnell </h2><br>  Fahrr√§der, wie eingangs erw√§hnt, ist es in mehreren F√§llen sinnvoll zu schreiben: Wenn dies ein Versuch ist, die Funktionsweise der Technologie zu verstehen, oder wenn Sie einige spezielle Ergebnisse erzielen m√ºssen.  Zum Beispiel Geschwindigkeit.  Sie k√∂nnen sicherstellen, dass der Deserializer <a href="">mit den vorbereiteten Tests</a> wirklich deserialisiert (ich verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoFixture</a> , um Testdaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abzurufen</a> ).  √úbrigens haben Sie wahrscheinlich bemerkt, dass ich auch die Serialisierung von Objekten geschrieben habe.  Da sich der Artikel jedoch als ziemlich umfangreich herausstellte, werde ich ihn nicht beschreiben, sondern nur Benchmarks geben.  Ja, genau wie im vorherigen Artikel habe ich Benchmarks mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet-</a> Bibliothek geschrieben. <br><br>  Nat√ºrlich habe ich <a href="">die</a> Deserialisierungsgeschwindigkeit mit Newtonsoft (Json.NET) verglichen, der h√§ufigsten und empfohlenen L√∂sung f√ºr die Arbeit mit JSON.  Dar√ºber hinaus steht direkt auf ihrer Website: 50% schneller als DataContractJsonSerializer und 250% schneller als JavaScriptSerializer.  Kurz gesagt, ich wollte wissen, wie viel mein Code verlieren w√ºrde.  Die Ergebnisse haben mich √ºberrascht: Beachten Sie, dass die Datenzuweisung fast dreimal geringer ist und die Deserialisierungsrate etwa zweimal schneller ist. <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  75,39 ms </td><td>  0,3027 ms </td><td>  0,2364 ms </td><td>  1,00 </td><td>  35,47 MB </td></tr><tr><td>  Velo </td><td>  31,78 ms </td><td>  0,1135 ms </td><td>  0,1062 ms </td><td>  0,42 </td><td>  12,36 MB </td></tr></tbody></table></div><br>  Der Vergleich von Geschwindigkeit und Zuordnung <a href="">w√§hrend der Datenserialisierung</a> ergab noch interessantere Ergebnisse.  Es stellt sich heraus, dass der Bike-Serializer fast f√ºnfmal weniger zugewiesen hat und fast dreimal schneller gearbeitet hat.  Wenn mich die Geschwindigkeit wirklich st√∂ren w√ºrde (wirklich sehr), w√§re das ein klarer Erfolg. <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  54,83 ms </td><td>  0,5582 ms </td><td>  0,5222 ms </td><td>  1,00 </td><td>  25,44 MB </td></tr><tr><td>  Velo </td><td>  20,66 ms </td><td>  0,0484 ms </td><td>  0,0429 ms </td><td>  0,38 </td><td>  5,93 MB </td></tr></tbody></table></div><br>  Ja, bei der Geschwindigkeitsmessung habe ich die auf der Json.NET-Website ver√∂ffentlichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps zur Steigerung der Produktivit√§t</a> nicht verwendet.  Ich habe Messungen sofort durchgef√ºhrt, dh gem√§√ü dem am h√§ufigsten verwendeten Szenario: JsonConvert.DeserializeObject.  Es gibt m√∂glicherweise andere M√∂glichkeiten, die Leistung zu verbessern, aber ich wei√ü nichts dar√ºber. <br><br><h2>  Schlussfolgerungen </h2><br>  Trotz der relativ hohen Geschwindigkeit der Serialisierung und Deserialisierung w√ºrde ich nicht empfehlen, Json.NET zugunsten meiner eigenen L√∂sung aufzugeben.  Der Geschwindigkeitsgewinn wird in Millisekunden berechnet und sie "ertrinken" leicht in Netzwerkverz√∂gerungen, Festplatten oder Code, die sich hierarchisch √ºber dem Ort befinden, an dem die Serialisierung angewendet wird.  Solche propriet√§ren L√∂sungen zu unterst√ºtzen ist die H√∂lle, wo nur Entwickler zugelassen werden k√∂nnen, die sich mit dem Thema auskennen. <br><br>  Der Umfang solcher Fahrr√§der sind Anwendungen, die vollst√§ndig im Hinblick auf hohe Leistung entwickelt wurden, oder Haustierprojekte, bei denen Sie verstehen, wie diese oder jene Technologie funktioniert.  Ich hoffe, ich habe dir dabei ein bisschen geholfen. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464525/">https://habr.com/ru/post/de464525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464511/index.html">So sammeln Sie Benutzerkohorten in Form von Grafiken in Grafana [+ Docker-Bild mit einem Beispiel]</a></li>
<li><a href="../de464513/index.html">Duffle: Transformator von XD Design</a></li>
<li><a href="../de464515/index.html">Wie man E-Mails erstellt und nicht durcheinander bringt: Praktische Tipps</a></li>
<li><a href="../de464517/index.html">Neue KUBA-Karten</a></li>
<li><a href="../de464523/index.html">Zahlungssysteme (PSP) f√ºr das IT-Gesch√§ft: Wir spielen gro√ü</a></li>
<li><a href="../de464529/index.html">F√ºr kontextbezogene Werbung mit den Namen von Wettbewerbern k√∂nnen jetzt 500.000 Rubel bestraft werden</a></li>
<li><a href="../de464535/index.html">Details zum Ger√§t und zu den Funktionen des KickScooter T60 Elektrorollers</a></li>
<li><a href="../de464537/index.html">Arduino DIY D√§monisches Karussell</a></li>
<li><a href="../de464539/index.html">Klinische Studien. Wie man in die Versuchsgruppe kommt, eine kostenlose Krebsbehandlung erh√§lt und der Wissenschaft hilft</a></li>
<li><a href="../de464543/index.html">Was ist und was nicht in Go. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>