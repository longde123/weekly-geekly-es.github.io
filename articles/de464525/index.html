<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏻 🧝🏾 ➕ Ihr eigener JSON-Konverter oder etwas mehr über ExpressionTrees 👵🏽 🎡 👩🏽‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serialisierung und Deserialisierung sind typische Vorgänge, die der moderne Entwickler als trivial betrachtet. Wir kommunizieren mit Datenbanken, gene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ihr eigener JSON-Konverter oder etwas mehr über ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464525/"><img src="https://habrastorage.org/webt/ud/qn/kd/udqnkdpyauh-0k7h5d-g_hgzrys.png"><br><br>  Serialisierung und Deserialisierung sind typische Vorgänge, die der moderne Entwickler als trivial betrachtet.  Wir kommunizieren mit Datenbanken, generieren HTTP-Anforderungen, empfangen Daten über die REST-API und denken oft nicht einmal darüber nach, wie dies funktioniert.  Heute schlage ich vor, meinen Serializer und Deserializer für JSON zu schreiben, um herauszufinden, was sich unter der Haube befindet. <br><a name="habracut"></a><br><h2>  Haftungsausschluss </h2><br>  Wie beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal</a> werde ich feststellen: Wir werden einen primitiven Serializer schreiben, man könnte sagen, ein Fahrrad.  Wenn Sie eine schlüsselfertige Lösung benötigen, verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Json.NET</a> .  Diese Jungs haben ein wundervolles Produkt veröffentlicht, das hochgradig anpassbar ist, viel kann und <i>bereits Probleme löst</i> , die bei der Arbeit mit JSON auftreten.  Die Verwendung Ihrer eigenen Lösung ist wirklich cool, aber nur, wenn Sie maximale Leistung, spezielle Anpassungen benötigen oder Fahrräder so mögen, wie ich sie mag. <br><br><h2>  Themenbereich </h2><br>  Der Dienst zum Konvertieren von JSON in eine Objektdarstellung besteht aus mindestens zwei Subsystemen.  Deserializer ist ein Subsystem, das gültigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON</a> (Text) in eine Objektdarstellung in unserem Programm verwandelt.  Die Deserialisierung umfasst die Tokenisierung, dh das Parsen von JSON in logische Elemente.  Serializer ist ein Subsystem, das die inverse Aufgabe ausführt: Verwandelt die Objektdarstellung von Daten in JSON. <br><br>  Der Verbraucher sieht am häufigsten die folgende Schnittstelle.  Ich habe es bewusst vereinfacht, um die wichtigsten Methoden hervorzuheben, die am häufigsten verwendet werden. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span> { T Deserialize&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Unter der Haube umfasst die Deserialisierung die Tokenisierung (Parsen eines JSON-Textes) und das Erstellen einiger Grundelemente, die das spätere Erstellen einer Objektdarstellung erleichtern.  Zu Schulungszwecken überspringen wir die Konstruktion von Zwischenprimitiven (z. B. JObject, JProperty von Json.NET) und schreiben sofort Daten in das Objekt.  Dies ist ein Minus, da es die Anpassungsoptionen reduziert, es jedoch unmöglich ist, eine gesamte Bibliothek im Rahmen eines Artikels zu erstellen. <br><br><h2>  Tokenisierung </h2><br>  Ich möchte Sie daran erinnern, dass der Prozess der Tokenisierung oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lexikalischen Analyse</a> eine Analyse des Textes ist, um eine andere, strengere Darstellung der darin enthaltenen Daten zu erhalten.  In der Regel wird diese Darstellung als <b>Token</b> oder Token bezeichnet.  Zum Parsen von JSON müssen die Eigenschaften, ihre Werte, die Symbole für den Anfang und das Ende von Strukturen hervorgehoben werden, dh Token, die im Code als JsonToken dargestellt werden können. <br><br>  <a href="">JsonToken</a> ist eine Struktur, die einen Wert (Text) sowie eine Art Token enthält.  JSON ist eine strikte Notation, sodass alle Arten von Token auf die <a href="">nächste Aufzählung</a> reduziert werden können.  Natürlich wäre es schön, dem Token seine Koordinaten in den eingehenden Daten (Zeile und Spalte) hinzuzufügen, aber das Debuggen geht über den Rahmen der Implementierung hinaus, was bedeutet, dass JsonToken diese Daten nicht enthält. <br><br>  Der einfachste Weg, Text in Token zu analysieren, besteht darin, jedes Zeichen nacheinander zu lesen und mit Mustern zu vergleichen.  Wir müssen verstehen, was dieses oder jenes Symbol bedeutet.  Es ist möglich, dass das Schlüsselwort (wahr, falsch, null) mit diesem Zeichen beginnt, dass dies möglicherweise der Anfang der Zeile ist (Anführungszeichen), oder dass dieses Zeichen selbst ein Token ist ([,], {,}).  Die allgemeine Idee sieht so aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tokens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;JsonToken&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; json.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = json[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ch) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayStart)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayEnd)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = ReadString(); tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.String, stringValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br>  Wenn Sie sich den Code ansehen, scheinen Sie die gelesenen Daten lesen und sofort etwas damit anfangen zu können.  Sie müssen nicht gelagert werden, sondern müssen sofort an den Verbraucher gesendet werden.  Daher bittet ein bestimmter IEnumerator, der den Text in Stücke zerlegt.  Erstens wird dadurch die Zuordnung verringert, da keine Zwischenergebnisse (ein Array von Token) gespeichert werden müssen.  Zweitens werden wir die Arbeitsgeschwindigkeit erhöhen - ja, in unserem Beispiel ist die Eingabe eine Zeichenfolge, aber in einer realen Situation wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie durch Stream</a> (aus einer Datei oder einem Netzwerk) ersetzt, den wir nacheinander lesen. <br><br>  Ich habe den <b>JsonTokenizer-</b> Code vorbereitet, den <b>Sie</b> <a href="">hier finden</a> .  Die Idee ist dieselbe - der Tokenizer geht nacheinander entlang der Linie und versucht festzustellen, worauf sich das Symbol oder seine Reihenfolge bezieht.  Wenn sich herausstellt, dass es verstanden wird, erstellen wir ein Token und übertragen die Kontrolle an den Verbraucher.  Wenn es noch nicht klar ist, lesen Sie weiter. <br><br><h2>  Vorbereiten der Deserialisierung von Objekten </h2><br>  In den meisten <b>Fällen</b> handelt es sich bei einer Anforderung zum Konvertieren von Daten aus JSON um einen Aufruf der generischen Deserialize-Methode, wobei <b>TOut</b> der Datentyp ist, mit dem JSON-Token zugeordnet werden sollen.  Wo <a href="">Typ ist</a> : Es ist Zeit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflection</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> anzuwenden.  Die Grundlagen der Arbeit mit ExpressionTrees sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Gründe,</a> warum kompilierte Ausdrücke besser sind als "nackte" Reflexion, habe ich in einem früheren Artikel beschrieben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie Sie Ihren AutoMapper erstellen</a> .  Wenn Sie nichts über Expression.Labmda.Compile () wissen, empfehle ich, es zu lesen.  Am Beispiel des Mappers scheint es mir verständlich geworden zu sein. <br><br>  Der Plan zum Erstellen eines Objektdeserialisierers basiert also auf dem Wissen, dass wir jederzeit Eigenschaftstypen aus dem TOut-Typ abrufen können, dh aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo-</a> Auflistung.  Gleichzeitig werden Eigenschaftstypen durch die JSON-Notation begrenzt: Zahlen, Zeichenfolgen, Arrays und Objekte.  Auch wenn wir Null nicht vergessen, ist dies nicht so sehr, wie es auf den ersten Blick scheinen mag.  Und wenn wir für jeden primitiven Typ gezwungen sind, einen separaten Deserializer zu erstellen, können wir für Arrays und Objekte generische Klassen erstellen.  Wenn Sie ein wenig nachdenken, können alle Serializer-Deserializer (oder <b>Konverter</b> ) auf die folgende Schnittstelle reduziert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JsonTokenizer tokenizer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StringBuilder builder</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Der Code eines stark typisierten Konverters primitiver Typen ist so einfach wie möglich: Wir extrahieren das aktuelle JsonToken aus dem Tokenizer und wandeln es durch Parsen in einen Wert um.  Zum Beispiel float.Parse (currentToken.Value).  Schauen Sie sich <a href="">BoolConverter</a> oder <a href="">FloatConverter an</a> - nichts Kompliziertes.  Als nächstes, wenn Sie einen Deserializer für Bool benötigen?  oder float? kann es auch hinzugefügt werden. <br><br><h2>  Array-Deserialisierung </h2><br>  <a href="">Der generische Klassencode</a> zum Konvertieren eines Arrays aus JSON ist ebenfalls relativ einfach.  Es wird durch den Elementtyp parametrisiert, den wir extrahieren können. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TypE</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GetElementType ()</a> .  Das Bestimmen, dass ein Typ ein Array ist, ist ebenfalls einfach: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Type.IsArray</a> .  Bei der Array-Deserialisierung wird tokenizer.MoveNext () angezeigt, bis ein Token vom Typ ArrayEnd erreicht ist.  Die Deserialisierung von Array-Elementen ist die Deserialisierung des Array-Elementtyps. Daher wird beim Erstellen eines ArrayConverter der Element-Deserializer an diesen übergeben. <br><br>  Manchmal gibt es Schwierigkeiten bei der Instanziierung generischer Implementierungen, daher werde ich Ihnen sofort erklären, wie es geht.  Mit Reflection können Sie generische Typen in Echtzeit erstellen. Dies bedeutet, dass wir den erstellten Typ als Argument für Activator.CreateInstance verwenden können.  Nutzen Sie dies: <br><br><pre> <code class="cs hljs">Type elementType = arrayType.GetElementType(); Type converterType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ArrayConverter&lt;&gt;).MakeGenericType(elementType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> converterInstance = Activator.CreateInstance(converterType, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args);</code> </pre><br>  Wenn Sie die Vorbereitungen zum Erstellen eines Deserialisierers für Objekte abgeschlossen haben, können Sie den gesamten Infrastrukturcode für die Erstellung und Speicherung von Deserialisierern in die Fassade von <a href="">JConverter einfügen</a> .  Er wird für alle JSON-Serialisierungs- und Deserialisierungsvorgänge verantwortlich sein und steht den Verbrauchern als Service zur Verfügung. <br><br><h2>  Objektdeserialisierung </h2><br>  Ich möchte Sie daran erinnern, dass Sie alle Eigenschaften des Typs T wie folgt erhalten können: typeof (T) .GetProperties ().  Für jede Eigenschaft können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.PropertyType</a> extrahieren, wodurch wir die Möglichkeit haben, einen typisierten IJsonConverter zum Serialisieren und Deserialisieren von Daten eines bestimmten Typs zu erstellen.  Wenn der Typ der Eigenschaft ein Array ist, instanziieren wir den ArrayConverter oder finden einen geeigneten unter den vorhandenen.  Wenn der Eigenschaftstyp ein primitiver Typ ist, werden im JConverter-Konstruktor bereits Deserialisierer (Konverter) für sie erstellt. <br><br>  Der resultierende Code kann in der generischen Klasse <a href="">ObjectConverter</a> angezeigt werden.  In seinem Konstruktor wird ein Aktivator erstellt, Eigenschaften werden aus einem speziell vorbereiteten Wörterbuch extrahiert und für jedes von ihnen wird eine Deserialisierungsmethode erstellt - Aktion &lt;TObject, JsonTokenizer&gt;.  Dies ist zum einen erforderlich, um den IJsonConverter sofort mit der gewünschten Eigenschaft zu verknüpfen, und zum anderen, um beim Extrahieren und Schreiben primitiver Typen ein Boxen zu vermeiden.  Jede Deserialisierungsmethode weiß, welche Eigenschaft des ausgehenden Objekts aufgezeichnet wird, der Deserialisierer des Werts wird streng typisiert und gibt den Wert genau in der Form zurück, in der er benötigt wird. <br><br>  Die Bindung eines IJsonConverter an eine Eigenschaft lautet wie folgt: <br><br><pre> <code class="cs hljs">Type converterType = propertyValueConverter.GetType(); ConstantExpression Expression.Constant(propertyValueConverter, converterType); MethodInfo deserializeMethod = converterType.GetMethod(<span class="hljs-string"><span class="hljs-string">"Deserialize"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Expression.Call(converter, deserializeMethod, tokenizer);</code> </pre><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Expression.Constant-</a> Konstante wird direkt im Ausdruck erstellt, in dem ein Verweis auf die Deserializer-Instanz für den Eigenschaftswert gespeichert ist.  Dies ist nicht genau die Konstante, die wir in "reguläres C #" schreiben, da sie einen Referenztyp speichern kann.  Als nächstes wird die Deserialize-Methode vom Deserializer-Typ abgerufen, der den Wert des gewünschten Typs zurückgibt, und dann heißt sie - <a href="">Expression.Call</a> .  So erhalten wir eine Methode, die genau weiß, wo und was zu schreiben ist.  Es bleibt, es in das Wörterbuch aufzunehmen und es aufzurufen, wenn ein Token vom Typ Eigenschaft mit dem gewünschten Namen vom Tokenizer "kommt".  Ein weiteres Plus ist, dass alles sehr schnell funktioniert. <br><br><h2>  Wie schnell </h2><br>  Fahrräder, wie eingangs erwähnt, ist es in mehreren Fällen sinnvoll zu schreiben: Wenn dies ein Versuch ist, die Funktionsweise der Technologie zu verstehen, oder wenn Sie einige spezielle Ergebnisse erzielen müssen.  Zum Beispiel Geschwindigkeit.  Sie können sicherstellen, dass der Deserializer <a href="">mit den vorbereiteten Tests</a> wirklich deserialisiert (ich verwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoFixture</a> , um Testdaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abzurufen</a> ).  Übrigens haben Sie wahrscheinlich bemerkt, dass ich auch die Serialisierung von Objekten geschrieben habe.  Da sich der Artikel jedoch als ziemlich umfangreich herausstellte, werde ich ihn nicht beschreiben, sondern nur Benchmarks geben.  Ja, genau wie im vorherigen Artikel habe ich Benchmarks mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet-</a> Bibliothek geschrieben. <br><br>  Natürlich habe ich <a href="">die</a> Deserialisierungsgeschwindigkeit mit Newtonsoft (Json.NET) verglichen, der häufigsten und empfohlenen Lösung für die Arbeit mit JSON.  Darüber hinaus steht direkt auf ihrer Website: 50% schneller als DataContractJsonSerializer und 250% schneller als JavaScriptSerializer.  Kurz gesagt, ich wollte wissen, wie viel mein Code verlieren würde.  Die Ergebnisse haben mich überrascht: Beachten Sie, dass die Datenzuweisung fast dreimal geringer ist und die Deserialisierungsrate etwa zweimal schneller ist. <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verhältnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  75,39 ms </td><td>  0,3027 ms </td><td>  0,2364 ms </td><td>  1,00 </td><td>  35,47 MB </td></tr><tr><td>  Velo </td><td>  31,78 ms </td><td>  0,1135 ms </td><td>  0,1062 ms </td><td>  0,42 </td><td>  12,36 MB </td></tr></tbody></table></div><br>  Der Vergleich von Geschwindigkeit und Zuordnung <a href="">während der Datenserialisierung</a> ergab noch interessantere Ergebnisse.  Es stellt sich heraus, dass der Bike-Serializer fast fünfmal weniger zugewiesen hat und fast dreimal schneller gearbeitet hat.  Wenn mich die Geschwindigkeit wirklich stören würde (wirklich sehr), wäre das ein klarer Erfolg. <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verhältnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  54,83 ms </td><td>  0,5582 ms </td><td>  0,5222 ms </td><td>  1,00 </td><td>  25,44 MB </td></tr><tr><td>  Velo </td><td>  20,66 ms </td><td>  0,0484 ms </td><td>  0,0429 ms </td><td>  0,38 </td><td>  5,93 MB </td></tr></tbody></table></div><br>  Ja, bei der Geschwindigkeitsmessung habe ich die auf der Json.NET-Website veröffentlichten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps zur Steigerung der Produktivität</a> nicht verwendet.  Ich habe Messungen sofort durchgeführt, dh gemäß dem am häufigsten verwendeten Szenario: JsonConvert.DeserializeObject.  Es gibt möglicherweise andere Möglichkeiten, die Leistung zu verbessern, aber ich weiß nichts darüber. <br><br><h2>  Schlussfolgerungen </h2><br>  Trotz der relativ hohen Geschwindigkeit der Serialisierung und Deserialisierung würde ich nicht empfehlen, Json.NET zugunsten meiner eigenen Lösung aufzugeben.  Der Geschwindigkeitsgewinn wird in Millisekunden berechnet und sie "ertrinken" leicht in Netzwerkverzögerungen, Festplatten oder Code, die sich hierarchisch über dem Ort befinden, an dem die Serialisierung angewendet wird.  Solche proprietären Lösungen zu unterstützen ist die Hölle, wo nur Entwickler zugelassen werden können, die sich mit dem Thema auskennen. <br><br>  Der Umfang solcher Fahrräder sind Anwendungen, die vollständig im Hinblick auf hohe Leistung entwickelt wurden, oder Haustierprojekte, bei denen Sie verstehen, wie diese oder jene Technologie funktioniert.  Ich hoffe, ich habe dir dabei ein bisschen geholfen. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464525/">https://habr.com/ru/post/de464525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464511/index.html">So sammeln Sie Benutzerkohorten in Form von Grafiken in Grafana [+ Docker-Bild mit einem Beispiel]</a></li>
<li><a href="../de464513/index.html">Duffle: Transformator von XD Design</a></li>
<li><a href="../de464515/index.html">Wie man E-Mails erstellt und nicht durcheinander bringt: Praktische Tipps</a></li>
<li><a href="../de464517/index.html">Neue KUBA-Karten</a></li>
<li><a href="../de464523/index.html">Zahlungssysteme (PSP) für das IT-Geschäft: Wir spielen groß</a></li>
<li><a href="../de464529/index.html">Für kontextbezogene Werbung mit den Namen von Wettbewerbern können jetzt 500.000 Rubel bestraft werden</a></li>
<li><a href="../de464535/index.html">Details zum Gerät und zu den Funktionen des KickScooter T60 Elektrorollers</a></li>
<li><a href="../de464537/index.html">Arduino DIY Dämonisches Karussell</a></li>
<li><a href="../de464539/index.html">Klinische Studien. Wie man in die Versuchsgruppe kommt, eine kostenlose Krebsbehandlung erhält und der Wissenschaft hilft</a></li>
<li><a href="../de464543/index.html">Was ist und was nicht in Go. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>